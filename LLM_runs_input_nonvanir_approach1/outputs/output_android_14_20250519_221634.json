[
    {
        "id": "ASB-A-353240784",
        "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-353240784",
        "severity": "High",
        "failures": [
            {
                "downstream_version": "14",
                "gemini_token_usage": 107969,
                "branch_used": "android14-release",
                "downstream_patch": "ae39a3f6538e5a5a73aea4daf8b552539247227f",
                "repo_path": "android_repos/base",
                "result": "failure",
                "downstream_patch_content": "commit ae39a3f6538e5a5a73aea4daf8b552539247227f\nAuthor: Pinyao Ting <pinyaoting@google.com>\nDate:   Tue Aug 20 21:17:13 2024 +0000\n\n    Enforce hard limits on hosts per package and widgets per host.\n    \n    Bug: 353240784\n    Merged-In: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Change-Id: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Test: manually verified with PoC app that at most 20 hosts can exists\n    Flag: EXEMPT CVE\n\ndiff --git a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nindex f5063ac4a023..356613ab3377 100644\n--- a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n",
                "downstream_patch_tokens": {
                    "openai": 1088,
                    "general": {
                        "word_based": 485,
                        "char_based": 1099
                    },
                    "gemini": 1336
                },
                "file_conflicts": [
                    {
                        "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
                        "total_hunks": 4,
                        "failed_hunks": [
                            1,
                            4
                        ],
                        "inline_merge_conflicts": [],
                        "inline_merge_token_summary": {
                            "gemini": 0,
                            "openai": 0,
                            "general_word": 0,
                            "general_char": 0
                        },
                        "rej_file_content": "```diff\n--- services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -217,6 +217,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // See {@link Provider#pendingDeletedWidgetIds}.\n     private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     // Handles user and package related broadcasts.\n     // See {@link #registerBroadcastReceiver}\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n@@ -3591,11 +3618,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (DEBUG) {\n             Slog.i(TAG, \"addWidgetLocked() \" + widget);\n         }\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n```",
                        "rej_file_tokens": {
                            "openai": 555,
                            "general": {
                                "word_based": 254,
                                "char_based": 607
                            },
                            "gemini": 667
                        },
                        "patch_apply_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 FAILED at 217.\nHunk #2 succeeded at 1698 (offset -577 lines).\nHunk #3 succeeded at 1706 with fuzz 2 (offset -577 lines).\nHunk #4 FAILED at 3591.\n2 out of 4 hunks FAILED -- saving rejects to file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java.rej",
                        "inline_merge_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 merged at 229-237.\nHunk #2 already applied at 2296.\nHunk #3 merged at 2322-2339.\nHunk #4 already applied at 3630, merged at 3636-3655.",
                        "upstream_file_content": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appwidget;\n\nimport static android.appwidget.flags.Flags.removeAppWidgetServiceIoFromCriticalPath;\nimport static android.appwidget.flags.Flags.supportResumeRestoreAfterReboot;\nimport static android.content.Context.KEYGUARD_SERVICE;\nimport static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.res.Resources.ID_NULL;\nimport static android.provider.DeviceConfig.NAMESPACE_SYSTEMUI;\n\nimport static com.android.server.appwidget.AppWidgetXmlUtil.deserializeWidgetSizesStr;\nimport static com.android.server.appwidget.AppWidgetXmlUtil.serializeWidgetSizes;\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\n\nimport android.Manifest;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.RequiresPermission;\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.ActivityOptions;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManagerInternal;\nimport android.app.BroadcastOptions;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.KeyguardManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerInternal.OnCrossProfileWidgetProvidersChangeListener;\nimport android.app.usage.Flags;\nimport android.app.usage.UsageEvents;\nimport android.app.usage.UsageStatsManager;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.appwidget.AppWidgetManager;\nimport android.appwidget.AppWidgetManagerInternal;\nimport android.appwidget.AppWidgetProviderInfo;\nimport android.appwidget.PendingHostUpdate;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.Intent.FilterComparison;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.LauncherApps;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.ShortcutServiceInternal;\nimport android.content.pm.SuspendDialogInfo;\nimport android.content.pm.UserInfo;\nimport android.content.pm.UserPackage;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.graphics.Point;\nimport android.graphics.drawable.Icon;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.HandlerExecutor;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.PersistableBundle;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.service.appwidget.AppWidgetServiceDumpProto;\nimport android.service.appwidget.WidgetProto;\nimport android.text.TextUtils;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.AttributeSet;\nimport android.util.IntArray;\nimport android.util.Log;\nimport android.util.LongSparseArray;\nimport android.util.Pair;\nimport android.util.SizeF;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.SparseLongArray;\nimport android.util.TypedValue;\nimport android.util.Xml;\nimport android.util.proto.ProtoOutputStream;\nimport android.view.Display;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.app.SuspendedAppActivity;\nimport com.android.internal.app.UnlaunchableAppActivity;\nimport com.android.internal.appwidget.IAppWidgetHost;\nimport com.android.internal.appwidget.IAppWidgetService;\nimport com.android.internal.config.sysui.SystemUiDeviceConfigFlags;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.widget.IRemoteViewsFactory;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.server.LocalServices;\nimport com.android.server.ServiceThread;\nimport com.android.server.WidgetBackupProvider;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.function.BiConsumer;\nimport java.util.function.Function;\nimport java.util.function.LongSupplier;\n\nclass AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBackupProvider,\n        OnCrossProfileWidgetProvidersChangeListener {\n    // Name of the tag associated with the system logs generated by this service.\n    private static final String TAG = \"AppWidgetServiceImpl\";\n    // Simple flag to enable/disable debug logging.\n    private static final boolean DEBUG = Build.IS_DEBUGGABLE;\n\n    // String constants for XML schema migration related to changes in keyguard package.\n    private static final String OLD_KEYGUARD_HOST_PACKAGE = \"android\";\n    private static final String NEW_KEYGUARD_HOST_PACKAGE = \"com.android.keyguard\";\n    private static final int KEYGUARD_HOST_ID = 0x4b455947;\n\n    // Filename for app widgets state persisted on disk.\n    private static final String STATE_FILENAME = \"appwidgets.xml\";\n\n    // XML tag for widget size options of each individual widget when persisted on disk.\n    private static final String KEY_SIZES = \"sizes\";\n\n    // Minimum amount of time in millieconds before a widget is updated.\n    private static final int MIN_UPDATE_PERIOD = DEBUG ? 0 : 30 * 60 * 1000; // 30 minutes\n\n    // Default value of {@link Provider#tag} and {@link Host#tag}.\n    private static final int TAG_UNDEFINED = -1;\n\n    // Default uid of {@link ProviderId} when corresponding app haven't been installed yet.\n    private static final int UNKNOWN_UID = -1;\n\n    // Default return value when we can't find the parent of a given profileId.\n    private static final int UNKNOWN_USER_ID = -10;\n\n    // Version of XML schema for app widgets. Bump if the stored widgets need to be upgraded.\n    private static final int CURRENT_VERSION = 1;\n\n    // Every widget update request is associated which an increasing sequence number. This is\n    // used to verify which request has successfully been received by the host.\n    private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n\n    // Default reset interval for generated preview API rate limiting.\n    private static final long DEFAULT_GENERATED_PREVIEW_RESET_INTERVAL_MS =\n            Duration.ofHours(1).toMillis();\n    // Default max API calls per reset interval for generated preview API rate limiting.\n    private static final int DEFAULT_GENERATED_PREVIEW_MAX_CALLS_PER_INTERVAL = 2;\n    // XML attribute for widget ids that are pending deletion.\n    // See {@link Provider#pendingDeletedWidgetIds}.\n    private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n\n    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n    // surfaces in the host app.\n    // @see AppWidgetHost\n    // @see AppWidgetHost#mHostId\n    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n    // Hard limit of number of widgets can be pinned by a host.\n    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n\n    // Handles user and package related broadcasts.\n    // See {@link #registerBroadcastReceiver}\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Received broadcast: \" + action + \" on user \" + userId);\n            }\n\n            switch (action) {\n                case Intent.ACTION_MANAGED_PROFILE_AVAILABLE:\n                case Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE:\n                    synchronized (mLock) {\n                        reloadWidgetsMaskedState(userId);\n                    }\n                    break;\n                case Intent.ACTION_PACKAGES_SUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, true, getSendingUserId());\n                    break;\n                case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, false, getSendingUserId());\n                    break;\n                case Intent.ACTION_PACKAGE_RESTARTED:\n                case Intent.ACTION_PACKAGE_UNSTOPPED:\n                    if (!android.content.pm.Flags.stayStopped()) return;\n                    updateWidgetPackageStoppedMaskedState(intent);\n                    break;\n                default:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    break;\n            }\n        }\n    };\n\n    // Manages persistent references to RemoteViewsServices from different App Widgets.\n    private final HashMap<Pair<Integer, FilterComparison>, HashSet<Integer>>\n            mRemoteViewsServicesAppWidgets = new HashMap<>();\n\n    // Synchronization lock for internal states in this service.\n    // TODO: Add GuardedBy annotation on states that need to be guarded.\n    private final Object mLock = new Object();\n\n    // Instances of actual widgets currently bound to each host.\n    private final ArrayList<Widget> mWidgets = new ArrayList<>();\n    // Information about the host apps that has one or more widgets bound to it.\n    private final ArrayList<Host> mHosts = new ArrayList<>();\n    // Information about the provider apps who indicates that they provide App Widgets\n    // in their manifest.\n    private final ArrayList<Provider> mProviders = new ArrayList<>();\n    // Pairs of (userId, packageName) which has explicit consent from user to\n    // hold the MODIFY_APPWIDGET_BIND_PERMISSIONS permission.\n    // See {@link AppWidgetManager#setBindAppWidgetPermission}\n    private final ArraySet<Pair<Integer, String>> mPackagesWithBindWidgetPermission =\n            new ArraySet<>();\n    // Ids of users whose widgets/provider/hosts have been loaded from disk.\n    private final SparseBooleanArray mLoadedUserIds = new SparseBooleanArray();\n    // Synchronization lock dedicated to {@link #mWidgetPackages}.\n    private final Object mWidgetPackagesLock = new Object();\n    // Set of packages that has at least one widget bounded by a host, keyed on userId.\n    private final SparseArray<ArraySet<String>> mWidgetPackages = new SparseArray<>();\n\n    private BackupRestoreController mBackupRestoreController;\n\n    private final Context mContext;\n\n    private IPackageManager mPackageManager;\n    private AlarmManager mAlarmManager;\n    private UserManager mUserManager;\n    private AppOpsManager mAppOpsManager;\n    private KeyguardManager mKeyguardManager;\n    private DevicePolicyManagerInternal mDevicePolicyManagerInternal;\n    private PackageManagerInternal mPackageManagerInternal;\n    private ActivityManagerInternal mActivityManagerInternal;\n    private AppOpsManagerInternal mAppOpsManagerInternal;\n    private UsageStatsManagerInternal mUsageStatsManagerInternal;\n\n    private SecurityPolicy mSecurityPolicy;\n\n    // Handler to the background thread that saves states to disk.\n    private Handler mSaveStateHandler;\n    // Handler to the foreground thread that handles broadcasts related to user\n    // and package events, as well as various internal events within\n    // AppWidgetService.\n    private Handler mCallbackHandler;\n    // Map of user id to the next app widget id (monotonically increasing integer)\n    // that can be allocated for a new app widget.\n    // See {@link AppWidgetHost#allocateAppWidgetId}.\n    private final SparseIntArray mNextAppWidgetIds = new SparseIntArray();\n    // Indicates whether the device is running in safe mode.\n    private boolean mSafeMode;\n    // Load time validation of maximum memory can be used in widget bitmaps.\n    private int mMaxWidgetBitmapMemory;\n    // Feature flag that indicates whether\n    // {@link AppWidgetManager#ACTION_APPWIDGET_ENABLED} and\n    // {@linkAppWidgetManager#ACTION_APPWIDGET_UPDATE} are combined into a\n    // single broadcast.\n    private boolean mIsCombinedBroadcastEnabled;\n\n    // Mark widget lifecycle broadcasts as 'interactive'\n    private Bundle mInteractiveBroadcast;\n    // Counter that keeps track of how many times generated preview API are\n    // being called to ensure they are subject to rate limiting.\n    private ApiCounter mGeneratedPreviewsApiCounter;\n\n    AppWidgetServiceImpl(Context context) {\n        mContext = context;\n    }\n\n    @RequiresPermission(android.Manifest.permission.READ_DEVICE_CONFIG)\n    public void onStart() {\n        mPackageManager = AppGlobals.getPackageManager();\n        mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n        mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);\n        mKeyguardManager = (KeyguardManager) mContext.getSystemService(KEYGUARD_SERVICE);\n        mDevicePolicyManagerInternal = LocalServices.getService(DevicePolicyManagerInternal.class);\n        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        if (removeAppWidgetServiceIoFromCriticalPath()) {\n            mSaveStateHandler = new Handler(BackgroundThread.get().getLooper(),\n                    this::handleSaveMessage);\n        } else {\n            mSaveStateHandler = BackgroundThread.getHandler();\n        }\n        final ServiceThread serviceThread = new ServiceThread(TAG,\n                android.os.Process.THREAD_PRIORITY_FOREGROUND, false /* allowIo */);\n        serviceThread.start();\n        mCallbackHandler = new CallbackHandler(serviceThread.getLooper());\n        mBackupRestoreController = new BackupRestoreController();\n        mSecurityPolicy = new SecurityPolicy();\n        mIsCombinedBroadcastEnabled = DeviceConfig.getBoolean(NAMESPACE_SYSTEMUI,\n            SystemUiDeviceConfigFlags.COMBINED_BROADCAST_ENABLED, true);\n\n        final long generatedPreviewResetInterval = DeviceConfig.getLong(NAMESPACE_SYSTEMUI,\n                SystemUiDeviceConfigFlags.GENERATED_PREVIEW_API_RESET_INTERVAL_MS,\n                DEFAULT_GENERATED_PREVIEW_RESET_INTERVAL_MS);\n        final int generatedPreviewMaxCallsPerInterval = DeviceConfig.getInt(NAMESPACE_SYSTEMUI,\n                SystemUiDeviceConfigFlags.GENERATED_PREVIEW_API_RESET_INTERVAL_MS,\n                DEFAULT_GENERATED_PREVIEW_MAX_CALLS_PER_INTERVAL);\n        mGeneratedPreviewsApiCounter = new ApiCounter(generatedPreviewResetInterval,\n                generatedPreviewMaxCallsPerInterval);\n        DeviceConfig.addOnPropertiesChangedListener(NAMESPACE_SYSTEMUI,\n                new HandlerExecutor(mCallbackHandler), this::handleSystemUiDeviceConfigChange);\n\n        BroadcastOptions opts = BroadcastOptions.makeBasic();\n        opts.setBackgroundActivityStartsAllowed(false);\n        opts.setInteractive(true);\n        mInteractiveBroadcast = opts.toBundle();\n\n        computeMaximumWidgetBitmapMemory();\n        registerBroadcastReceiver();\n        registerOnCrossProfileProvidersChangedListener();\n\n        LocalServices.addService(AppWidgetManagerInternal.class, new AppWidgetManagerLocal());\n    }\n\n    /**\n     * Returns the maximum memory can be used in widget bitmaps, in respect to\n     * the display size. Note this should only be called after\n     * {@link #computeMaximumWidgetBitmapMemory} is invoked.\n     */\n    @Override\n    public int getMaxBitmapMemory() {\n        return mMaxWidgetBitmapMemory;\n    }\n\n    /**\n     * Signals that system services (esp. ActivityManagerService) are ready.\n     */\n    void systemServicesReady() {\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n        mAppOpsManagerInternal = LocalServices.getService(AppOpsManagerInternal.class);\n        mUsageStatsManagerInternal = LocalServices.getService(UsageStatsManagerInternal.class);\n    }\n\n    /**\n     * Computes the maximum memory can be used in widget bitmaps, in respect to\n     * the display size.\n     */\n    private void computeMaximumWidgetBitmapMemory() {\n        Display display = mContext.getDisplayNoVerify();\n        Point size = new Point();\n        display.getRealSize(size);\n        // Cap memory usage at 1.5 times the size of the display\n        // 1.5 * 4 bytes/pixel * w * h ==> 6 * w * h\n        mMaxWidgetBitmapMemory = 6 * size.x * size.y;\n    }\n\n    /**\n     * Callback function that persists the states of the widgets to disk,\n     * should be scheduled on a background thread.\n     */\n    private boolean handleSaveMessage(Message msg) {\n        final int userId = msg.what;\n        SparseArray<byte[]> userIdToBytesMapping;\n        synchronized (mLock) {\n            // No need to enforce unlocked state when there is no caller. User can be in the\n            // stopping state or removed by the time the message is processed\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"convert_state_to_bytes\");\n            ensureGroupStateLoadedLocked(userId, false /* enforceUserUnlockingOrUnlocked */);\n            userIdToBytesMapping = saveStateToByteArrayLocked(userId);\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n        }\n\n        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"byte_to_disk_io\");\n        for (int i = 0; i < userIdToBytesMapping.size(); i++) {\n            int currentProfileId = userIdToBytesMapping.keyAt(i);\n            byte[] currentStateByteArray = userIdToBytesMapping.valueAt(i);\n            AtomicFile currentFile = getSavedStateFile(currentProfileId);\n            FileOutputStream fileStream;\n            try {\n                fileStream = currentFile.startWrite();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to start writing stream\", e);\n                continue;\n            }\n\n            try {\n                fileStream.write(currentStateByteArray);\n                currentFile.finishWrite(fileStream);\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to write state byte stream to file\", e);\n                currentFile.failWrite(fileStream);\n            }\n        }\n        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n        return true;\n    }\n\n    /**\n     * Register receivers for system broadcasts, esp. broadcasts from package manager.\n     */\n    private void registerBroadcastReceiver() {\n        // Register for broadcasts about package install, etc., so we can\n        // update the provider list.\n        IntentFilter packageFilter = new IntentFilter();\n        packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_DATA_CLEARED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_UNSTOPPED);\n        packageFilter.addDataScheme(\"package\");\n        packageFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                packageFilter, null, mCallbackHandler);\n\n        // Register for events related to sdcard installation.\n        IntentFilter sdFilter = new IntentFilter();\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                sdFilter, null, mCallbackHandler);\n\n        IntentFilter offModeFilter = new IntentFilter();\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_AVAILABLE);\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                offModeFilter, null, mCallbackHandler);\n\n        IntentFilter suspendPackageFilter = new IntentFilter();\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                suspendPackageFilter, null, mCallbackHandler);\n    }\n\n    /**\n     * Listens to cross-profile widget providers changes.\n     *\n     * @see #onCrossProfileWidgetProvidersChanged\n     * @see DevicePolicyManager#addCrossProfileWidgetProvider\n     * @see DevicePolicyManager#removeCrossProfileWidgetProvider\n     */\n    private void registerOnCrossProfileProvidersChangedListener() {\n        // The device policy is an optional component.\n        if (mDevicePolicyManagerInternal != null) {\n            mDevicePolicyManagerInternal.addOnCrossProfileWidgetProvidersChangeListener(this);\n        }\n    }\n\n    public void setSafeMode(boolean safeMode) {\n        mSafeMode = safeMode;\n    }\n\n    /**\n     * Handles broadcasts from package manager, add/remove/update widget\n     * providers in respect to changes in corresponding packages.\n     * Note: When a package is archived, it is treated as removed.\n     */\n    private void onPackageBroadcastReceived(Intent intent, int userId) {\n        final String action = intent.getAction();\n        boolean added = false;\n        boolean changed = false;\n        boolean componentsModified = false;\n        int clearedUid = -1;\n\n        final String pkgList[];\n        switch (action) {\n            case Intent.ACTION_PACKAGES_SUSPENDED:\n            case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                changed = true;\n                break;\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:\n                added = true;\n                // fall through\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                break;\n            case Intent.ACTION_PACKAGE_DATA_CLEARED:\n                pkgList = null;\n                clearedUid = intent.getIntExtra(Intent.EXTRA_UID, -1);\n                break;\n            default: {\n                Uri uri = intent.getData();\n                if (uri == null) {\n                    return;\n                }\n                String pkgName = uri.getSchemeSpecificPart();\n                if (pkgName == null) {\n                    return;\n                }\n                pkgList = new String[] { pkgName };\n                added = Intent.ACTION_PACKAGE_ADDED.equals(action);\n                changed = Intent.ACTION_PACKAGE_CHANGED.equals(action);\n            }\n        }\n        if ((pkgList == null || pkgList.length == 0) && clearedUid == -1) {\n            return;\n        }\n\n        synchronized (mLock) {\n            if (!mUserManager.isUserUnlockingOrUnlocked(userId) ||\n                    isProfileWithLockedParent(userId)) {\n                return;\n            }\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            Bundle extras = intent.getExtras();\n\n            if (added || changed) {\n                final boolean newPackageAdded = added && (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                for (String pkgName : pkgList) {\n                    // Fix up the providers - add/remove/update.\n                    componentsModified |= updateProvidersForPackageLocked(pkgName, userId, null);\n\n                    // ... and see if these are hosts we've been awaiting.\n                    // NOTE: We are backing up and restoring only the owner.\n                    // TODO: http://b/22388012\n                    if (newPackageAdded && userId == UserHandle.USER_SYSTEM) {\n                        final int uid = getUidForPackage(pkgName, userId);\n                        if (uid >= 0 ) {\n                            resolveHostUidLocked(pkgName, uid);\n                        }\n                    }\n                }\n            } else if (clearedUid != -1) {\n                componentsModified |= clearPreviewsForUidLocked(clearedUid);\n            } else {\n                // If the package is being updated, we'll receive a PACKAGE_ADDED\n                // shortly, otherwise it is removed permanently.\n                boolean isReplacing = extras != null && extras.getBoolean(Intent.EXTRA_REPLACING,\n                        false);\n                boolean isArchival = extras != null && extras.getBoolean(Intent.EXTRA_ARCHIVAL,\n                        false);\n                final boolean packageRemovedPermanently =\n                        (extras == null || !isReplacing || (isReplacing && isArchival));\n                if (packageRemovedPermanently) {\n                    for (String pkgName : pkgList) {\n                        if (DEBUG) {\n                            Slog.i(TAG, \"calling removeHostsAndProvidersForPackageLocked() \"\n                                    + \"because package removed permanently. extras=\" + extras\n                                    + \" isReplacing=\" + isReplacing + \" isArchival=\" + isArchival);\n                        }\n                        componentsModified |= removeHostsAndProvidersForPackageLocked(\n                                pkgName, userId);\n                    }\n                }\n            }\n\n            if (componentsModified) {\n                saveGroupStateAsync(userId);\n\n                // If the set of providers has been modified, notify each active AppWidgetHost\n                scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                // Possibly notify any new components of widget id changes\n                mBackupRestoreController.widgetComponentsChanged(userId);\n            }\n        }\n    }\n\n    /**\n     * Clears the generated previews for all widgets belonging to the given UID.\n     * @return true if any previews were cleared.\n     */\n    @GuardedBy(\"mLock\")\n    private boolean clearPreviewsForUidLocked(int clearedUid) {\n        boolean changed = false;\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.id.uid == clearedUid) {\n                changed |= provider.clearGeneratedPreviewsLocked();\n            }\n        }\n        return changed;\n    }\n\n    /**\n     * Reload all widgets' masked state for the given user and its associated profiles, including\n     * due to user not being available and package suspension.\n     * userId must be the group parent.\n     */\n    void reloadWidgetsMaskedStateForGroup(int userId) {\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            return;\n        }\n        synchronized (mLock) {\n            reloadWidgetsMaskedState(userId);\n            int[] profileIds = mUserManager.getEnabledProfileIds(userId);\n            for (int profileId : profileIds) {\n                reloadWidgetsMaskedState(profileId);\n            }\n        }\n    }\n\n    /**\n     * Reload all widgets' masked state for the given user or profile.\n     * Keep track of whether the given user or profile is locked, in quiet mode,\n     * suspended or stopped.\n     */\n    private void reloadWidgetsMaskedState(int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            UserInfo user  = mUserManager.getUserInfo(userId);\n\n            boolean lockedProfile = !mUserManager.isUserUnlockingOrUnlocked(userId);\n            boolean quietProfile = user.isQuietModeEnabled();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != userId) {\n                    continue;\n                }\n\n                boolean changed = provider.setMaskedByLockedProfileLocked(lockedProfile);\n                changed |= provider.setMaskedByQuietProfileLocked(quietProfile);\n                try {\n                    boolean suspended;\n                    boolean stopped;\n                    try {\n                        suspended = mPackageManager.isPackageSuspendedForUser(\n                                provider.id.componentName.getPackageName(), provider.getUserId());\n                        stopped = mPackageManager.isPackageStoppedForUser(\n                                provider.id.componentName.getPackageName(), provider.getUserId());\n                    } catch (IllegalArgumentException ex) {\n                        // Package not found.\n                        suspended = false;\n                        stopped = false;\n                    }\n                    changed |= provider.setMaskedBySuspendedPackageLocked(suspended);\n                    changed |= provider.setMaskedByStoppedPackageLocked(stopped);\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Failed to query application info\", e);\n                }\n                if (changed) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * Incrementally update the masked state due to package suspension state.\n     */\n    private void updateWidgetPackageSuspensionMaskedState(Intent intent, boolean suspended,\n            int profileId) {\n        String[] packagesArray = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n        if (packagesArray == null) {\n            return;\n        }\n        Set<String> packages = new ArraySet<>(Arrays.asList(packagesArray));\n        synchronized (mLock) {\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != profileId\n                        || !packages.contains(provider.id.componentName.getPackageName())) {\n                    continue;\n                }\n                if (provider.setMaskedBySuspendedPackageLocked(suspended)) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Update the masked state for a stopped or unstopped package.\n     */\n    private void updateWidgetPackageStoppedMaskedState(@NonNull Intent intent) {\n        final int providerUid = intent.getIntExtra(Intent.EXTRA_UID, Process.INVALID_UID);\n        final Uri uri = intent.getData();\n        if (providerUid == Process.INVALID_UID || uri == null) {\n            return;\n        }\n\n        final String packageName = uri.getSchemeSpecificPart();\n        if (packageName == null) {\n            return;\n        }\n\n        boolean isStopped;\n        try {\n            isStopped = mPackageManager.isPackageStoppedForUser(packageName,\n                    UserHandle.getUserId(providerUid));\n        } catch (Exception e) {\n            Slog.e(TAG, \"Failed to query package stopped state\", e);\n            return;\n        }\n\n        if (DEBUG) {\n            Slog.i(TAG, \"Updating package stopped masked state for uid \" + providerUid + \" package \"\n                    + packageName + \" isStopped \" + isStopped);\n        }\n        synchronized (mLock) {\n            final int count = mProviders.size();\n            for (int i = 0; i < count; i++) {\n                Provider provider = mProviders.get(i);\n                if (providerUid != provider.id.uid\n                        || !packageName.equals(provider.id.componentName.getPackageName())) {\n                    continue;\n                }\n                if (provider.setMaskedByStoppedPackageLocked(isStopped)) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                        cancelBroadcastsLocked(provider);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                        final int widgetCount = provider.widgets.size();\n                        if (widgetCount > 0) {\n                            final int[] widgetIds = new int[widgetCount];\n                            for (int j = 0; j < widgetCount; j++) {\n                                widgetIds[j] = provider.widgets.get(j).appWidgetId;\n                            }\n                            registerForBroadcastsLocked(provider, widgetIds);\n                            sendUpdateIntentLocked(provider, widgetIds, /* interactive= */ false);\n                        }\n\n                        final int pendingIdsCount = provider.pendingDeletedWidgetIds.size();\n                        if (pendingIdsCount > 0) {\n                            if (DEBUG) {\n                                Slog.i(TAG, \"Sending missed deleted broadcasts for \"\n                                        + provider.id.componentName + \" \"\n                                        + provider.pendingDeletedWidgetIds);\n                            }\n                            for (int j = 0; j < pendingIdsCount; j++) {\n                                sendDeletedIntentLocked(provider.id.componentName,\n                                        provider.id.getProfile(),\n                                        provider.pendingDeletedWidgetIds.get(j));\n                            }\n                            provider.pendingDeletedWidgetIds.clear();\n                            if (widgetCount == 0) {\n                                sendDisabledIntentLocked(provider);\n                            }\n                            saveGroupStateAsync(provider.id.getProfile().getIdentifier());\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Mask the target widget belonging to the specified provider, or all active widgets\n     * of the provider if target widget == null.\n     */\n    private void maskWidgetsViewsLocked(Provider provider, Widget targetWidget) {\n        final int widgetCount = provider.widgets.size();\n        if (widgetCount == 0) {\n            return;\n        }\n        RemoteViews views = new RemoteViews(mContext.getPackageName(),\n                R.layout.work_widget_mask_view);\n        final ActivityInfo activityInfo = provider.info.providerInfo;\n        final ApplicationInfo appInfo = activityInfo != null ? activityInfo.applicationInfo : null;\n        final String packageName = appInfo != null\n                ? appInfo.packageName : provider.id.componentName.getPackageName();\n        final int appUserId = provider.getUserId();\n        boolean showBadge = false;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            Intent onClickIntent = null;\n\n            if (provider.maskedByQuietProfile) {\n                showBadge = true;\n                onClickIntent = UnlaunchableAppActivity.createInQuietModeDialogIntent(appUserId);\n            } else if (provider.maskedBySuspendedPackage) {\n                showBadge = mUserManager.hasBadge(appUserId);\n                final UserPackage suspendingPackage = mPackageManagerInternal.getSuspendingPackage(\n                        packageName, appUserId);\n                // TODO(b/281839596): don't rely on platform always meaning suspended by admin.\n                if (suspendingPackage != null\n                        && PLATFORM_PACKAGE_NAME.equals(suspendingPackage.packageName)) {\n                    onClickIntent = mDevicePolicyManagerInternal.createShowAdminSupportIntent(\n                            appUserId, true);\n                } else {\n                    final SuspendDialogInfo dialogInfo =\n                            mPackageManagerInternal.getSuspendedDialogInfo(\n                                    packageName, suspendingPackage, appUserId);\n                    // onUnsuspend is null because we don't want to start any activity on\n                    // unsuspending from a suspended widget.\n                    onClickIntent = SuspendedAppActivity.createSuspendedAppInterceptIntent(\n                            packageName, suspendingPackage, dialogInfo, null, null,\n                            appUserId);\n                }\n            } else if (provider.maskedByLockedProfile) {\n                showBadge = true;\n                onClickIntent = mKeyguardManager\n                        .createConfirmDeviceCredentialIntent(null, null, appUserId);\n                if (onClickIntent != null) {\n                    onClickIntent.setFlags(\n                            FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                }\n            } else if (provider.maskedByStoppedPackage) {\n                showBadge = mUserManager.hasBadge(appUserId);\n            }\n\n            Icon icon = (appInfo != null && appInfo.icon != 0)\n                    ? Icon.createWithResource(appInfo.packageName, appInfo.icon)\n                    : Icon.createWithResource(mContext, android.R.drawable.sym_def_app_icon);\n            views.setImageViewIcon(R.id.work_widget_app_icon, icon);\n            if (!showBadge) {\n                views.setViewVisibility(R.id.work_widget_badge_icon, View.INVISIBLE);\n            }\n\n            for (int j = 0; j < widgetCount; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (targetWidget != null && targetWidget != widget) continue;\n                if (provider.maskedByStoppedPackage) {\n                    Intent intent = createUpdateIntentLocked(provider,\n                            new int[] { widget.appWidgetId });\n                    views.setOnClickPendingIntent(android.R.id.background,\n                            PendingIntent.getBroadcast(mContext, widget.appWidgetId,\n                                    intent, PendingIntent.FLAG_UPDATE_CURRENT\n                                            | PendingIntent.FLAG_IMMUTABLE));\n                } else if (onClickIntent != null) {\n                    views.setOnClickPendingIntent(android.R.id.background,\n                            PendingIntent.getActivity(mContext, widget.appWidgetId, onClickIntent,\n                                    PendingIntent.FLAG_UPDATE_CURRENT\n                                       | PendingIntent.FLAG_IMMUTABLE));\n                }\n                if (widget.replaceWithMaskedViewsLocked(views)) {\n                    scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * Unmask widgets of the specified provider. Notify the host to remove the masked views\n     * if previously masked.\n     */\n    private void unmaskWidgetsViewsLocked(Provider provider) {\n        final int widgetCount = provider.widgets.size();\n        for (int j = 0; j < widgetCount; j++) {\n            Widget widget = provider.widgets.get(j);\n            if (widget.clearMaskedViewsLocked()) {\n                scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n            }\n        }\n    }\n\n    /**\n     * Called when a new package is installed, and updates {@link HostId} in corresponding\n     * {@link Host}.\n     */\n    private void resolveHostUidLocked(String pkg, int uid) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.uid == UNKNOWN_UID && pkg.equals(host.id.packageName)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"host \" + host.id + \" resolved to uid \" + uid);\n                }\n                host.id = new HostId(uid, host.id.hostId, host.id.packageName);\n                return;\n            }\n        }\n    }\n\n    /**\n     * Load widgets/providers/hosts for the specified user and all of its enabled\n     * child profiles from disk if not already loaded.\n     *\n     * @param userId the user id to load\n     *\n     * @see #ensureGroupStateLoadedLocked(int, boolean)\n     */\n    @GuardedBy(\"mLock\")\n    private void ensureGroupStateLoadedLocked(int userId) {\n        ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ true );\n    }\n\n    /**\n     * Load widgets/providers/hosts for the specified user and all of its enabled\n     * child profiles from disk if not already loaded.\n     *\n     * @param userId the user id to load\n     * @param enforceUserUnlockingOrUnlocked if true, the user must be unlocked or unlocking\n     * @throws IllegalStateException if the user or profile is not unlocked or unlocking and\n     * {@code enforceUserUnlockingOrUnlocked} is true\n     */\n    @GuardedBy(\"mLock\")\n    private void ensureGroupStateLoadedLocked(int userId, boolean enforceUserUnlockingOrUnlocked) {\n        if (enforceUserUnlockingOrUnlocked && !isUserRunningAndUnlocked(userId)) {\n            throw new IllegalStateException(\n                    \"User \" + userId + \" must be unlocked for widgets to be available\");\n        }\n        if (enforceUserUnlockingOrUnlocked && isProfileWithLockedParent(userId)) {\n            throw new IllegalStateException(\n                    \"Profile \" + userId + \" must have unlocked parent\");\n        }\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        IntArray newIds = new IntArray(1);\n        for (int profileId : profileIds) {\n            if (!mLoadedUserIds.get(profileId)) {\n                mLoadedUserIds.put(profileId, true);\n                newIds.add(profileId);\n            }\n        }\n        if (newIds.size() <= 0) {\n            return;\n        }\n        final int[] newProfileIds = newIds.toArray();\n        clearProvidersAndHostsTagsLocked();\n\n        loadGroupWidgetProvidersLocked(newProfileIds);\n        loadGroupStateLocked(newProfileIds);\n    }\n\n    private boolean isUserRunningAndUnlocked(@UserIdInt int userId) {\n        return mUserManager.isUserUnlockingOrUnlocked(userId);\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;\n\n        synchronized (mLock) {\n            if (args.length > 0 && \"--proto\".equals(args[0])) {\n                dumpProto(fd);\n            } else {\n                dumpInternalLocked(pw);\n            }\n        }\n    }\n\n    private void dumpProto(FileDescriptor fd) {\n        Slog.i(TAG, \"dump proto for \" + mWidgets.size() + \" widgets\");\n\n        ProtoOutputStream proto = new ProtoOutputStream(fd);\n        int N = mWidgets.size();\n        for (int i=0; i < N; i++) {\n            dumpProtoWidget(proto, mWidgets.get(i));\n        }\n        proto.flush();\n    }\n\n    private void dumpProtoWidget(ProtoOutputStream proto, Widget widget) {\n        if (widget.host == null || widget.provider == null) {\n            Slog.d(TAG, \"skip dumping widget because host or provider is null: widget.host=\"\n                + widget.host + \" widget.provider=\"  + widget.provider);\n            return;\n        }\n        long token = proto.start(AppWidgetServiceDumpProto.WIDGETS);\n        proto.write(WidgetProto.IS_CROSS_PROFILE,\n            widget.host.getUserId() != widget.provider.getUserId());\n        proto.write(WidgetProto.IS_HOST_STOPPED, widget.host.callbacks == null);\n        proto.write(WidgetProto.HOST_PACKAGE, widget.host.id.packageName);\n        proto.write(WidgetProto.PROVIDER_PACKAGE, widget.provider.id.componentName.getPackageName());\n        proto.write(WidgetProto.PROVIDER_CLASS, widget.provider.id.componentName.getClassName());\n        if (widget.options != null) {\n            proto.write(WidgetProto.RESTORE_COMPLETED,\n                    widget.options.getBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED));\n            proto.write(WidgetProto.MIN_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, 0));\n            proto.write(WidgetProto.MIN_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, 0));\n            proto.write(WidgetProto.MAX_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, 0));\n            proto.write(WidgetProto.MAX_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, 0));\n        }\n        proto.end(token);\n    }\n\n    private void dumpInternalLocked(PrintWriter pw) {\n        int N = mProviders.size();\n        pw.println(\"Providers:\");\n        for (int i = 0; i < N; i++) {\n            dumpProviderLocked(mProviders.get(i), i, pw);\n        }\n\n        N = mWidgets.size();\n        pw.println(\" \");\n        pw.println(\"Widgets:\");\n        for (int i = 0; i < N; i++) {\n            dumpWidget(mWidgets.get(i), i, pw);\n        }\n\n        N = mHosts.size();\n        pw.println(\" \");\n        pw.println(\"Hosts:\");\n        for (int i = 0; i < N; i++) {\n            dumpHost(mHosts.get(i), i, pw);\n        }\n\n        N = mPackagesWithBindWidgetPermission.size();\n        pw.println(\" \");\n        pw.println(\"Grants:\");\n        for (int i = 0; i < N; i++) {\n            Pair<Integer, String> grant = mPackagesWithBindWidgetPermission.valueAt(i);\n            dumpGrant(grant, i, pw);\n        }\n    }\n\n    /**\n     * Called by {@link AppWidgetHost} to start listening for updates from specified widgets.\n     */\n    @Override\n    public ParceledListSlice<PendingHostUpdate> startListening(IAppWidgetHost callbacks,\n            String callingPackage, int hostId, int[] appWidgetIds) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"startListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n            host.callbacks = callbacks;\n\n            long updateSequenceNo = UPDATE_COUNTER.incrementAndGet();\n            int N = appWidgetIds.length;\n            ArrayList<PendingHostUpdate> outUpdates = new ArrayList<>(N);\n            LongSparseArray<PendingHostUpdate> updatesMap = new LongSparseArray<>();\n            for (int i = 0; i < N; i++) {\n                updatesMap.clear();\n                host.getPendingUpdatesForIdLocked(mContext, appWidgetIds[i], updatesMap);\n                // We key the updates based on request id, so that the values are sorted in the\n                // order they were received.\n                int m = updatesMap.size();\n                for (int j = 0; j < m; j++) {\n                    outUpdates.add(updatesMap.valueAt(j));\n                }\n            }\n            // Reset the update counter once all the updates have been calculated\n            host.lastWidgetUpdateSequenceNo = updateSequenceNo;\n            return new ParceledListSlice<>(outUpdates);\n        }\n    }\n\n    /**\n     * Called by {@link AppWidgetHost} to stop listening for updates from all\n     * widgets bounded to this host.\n     */\n    @Override\n    public void stopListening(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"stopListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                host.callbacks = null;\n                pruneHostLocked(host);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(host.getWidgetUidsIfBound(),\n                        false);\n            }\n        }\n    }\n\n    /**\n     * Creates a new instance of app widget and associate it with the specified host.\n     * Allocate a new app widget id for the new instance.\n     */\n    @Override\n    public int allocateAppWidgetId(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"allocateAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return AppWidgetManager.INVALID_APPWIDGET_ID;\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n                mNextAppWidgetIds.put(userId, AppWidgetManager.INVALID_APPWIDGET_ID + 1);\n            }\n\n            final int appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n\n            Widget widget = new Widget();\n            widget.appWidgetId = appWidgetId;\n            widget.host = host;\n\n            host.widgets.add(widget);\n            addWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Allocated widget id \" + appWidgetId\n                        + \" for host \" + host.id);\n            }\n\n            return appWidgetId;\n        }\n    }\n\n    /**\n     * Called by {@link AppWidgetHost} to mark all widgets associated with this host\n     * to be visually hidden (for state tracking).\n     *\n     * @see AppOpsManagerInternal#updateAppWidgetVisibility\n     */\n    @Override\n    public void setAppWidgetHidden(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"setAppWidgetHidden() \" + userId);\n        }\n\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */false);\n\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                mAppOpsManagerInternal.updateAppWidgetVisibility(host.getWidgetUidsIfBound(),\n                        false);\n            }\n        }\n    }\n\n    /**\n     * Deletes specified widget.\n     * Note: appWidgetId is a monotonic increasing number, so the appWidgetId cannot be\n     * reclaimed by a new widget.\n     */\n    @Override\n    public void deleteAppWidgetId(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            deleteAppWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted widget id \" + appWidgetId\n                        + \" for host \" + widget.host.id);\n            }\n        }\n    }\n\n    /**\n     * Query if a given package was granted permission by the user to bind app widgets.\n     *\n     * <p class=\"note\">You need the MODIFY_APPWIDGET_BIND_PERMISSIONS permission\n     *\n     * @param packageName The package for which the permission is being queried\n     * @param userId The user id of the user under which the package runs.\n     * @return true if the package was granted permission by the user to bind app widgets\n     *\n     * @see AppWidgetManager#hasBindAppWidgetPermission(String, int)\n     */\n    @Override\n    public boolean hasBindAppWidgetPermission(String packageName, int userId) {\n        if (DEBUG) {\n            Slog.i(TAG, \"hasBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(userId);\n\n            final int packageUid = getUidForPackage(packageName, userId);\n            if (packageUid < 0) {\n                return false;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(userId, packageName);\n            return mPackagesWithBindWidgetPermission.contains(packageId);\n        }\n    }\n\n    /**\n     * Changes any user-granted permission for the given package to bind app widgets.\n     *\n     * <p class=\"note\">You need the MODIFY_APPWIDGET_BIND_PERMISSIONS permission\n     *\n     * @param packageName The package whose permission is being changed\n     * @param userId The user under which the package is running.\n     * @param permission Whether to give the package permission to bind widgets\n     *\n     * @see AppWidgetManager#setBindAppWidgetPermission(String, int, boolean)\n     */\n    @Override\n    public void setBindAppWidgetPermission(String packageName, int userId,\n            boolean grantPermission) {\n        if (DEBUG) {\n            Slog.i(TAG, \"setBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(userId);\n\n            final int packageUid = getUidForPackage(packageName, userId);\n            if (packageUid < 0) {\n                return;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(userId, packageName);\n            if (grantPermission) {\n                mPackagesWithBindWidgetPermission.add(packageId);\n            } else {\n                mPackagesWithBindWidgetPermission.remove(packageId);\n            }\n\n            saveGroupStateAsync(userId);\n        }\n    }\n\n    /**\n     * Called by {@link AppWidgetHost} to start app widget provider configure\n     * activity for result.\n     * This method is used if the provider is in a profile different from the host\n     * as the host is not allowed to start an activity in another profile.\n     * <p>\n     * Note that the provided app widget has to be bound for this method to work.\n     * </p>\n     *\n     * @param callingPackage Package that calls this method.\n     * @param appWidgetId The bound app widget whose provider's config activity to start.\n     * @param intentFlags Optional intent flags.\n     * @return IntentSender to start the config activity.\n     * @throws IllegalArgumentException If the widget is not found.\n     *\n     * @see AppWidgetProviderInfo#getProfile()\n     * @see AppWidgetHost#startAppWidgetConfigureActivityForResult\n     */\n    @Override\n    public IntentSender createAppWidgetConfigIntentSender(String callingPackage, int appWidgetId,\n            final int intentFlags) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"createAppWidgetConfigIntentSender() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id \" + appWidgetId);\n            }\n\n            Provider provider = widget.provider;\n            if (provider == null) {\n                throw new IllegalArgumentException(\"Widget not bound \" + appWidgetId);\n            }\n\n            // Make sure only safe flags can be passed it.\n            final int secureFlags = intentFlags & ~Intent.IMMUTABLE_FLAGS;\n\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_CONFIGURE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\n            intent.setComponent(provider.getInfoLocked(mContext).configure);\n            intent.setFlags(secureFlags);\n\n            final ActivityOptions options =\n                    ActivityOptions.makeBasic().setPendingIntentCreatorBackgroundActivityStartMode(\n                            ActivityOptions.MODE_BACKGROUND_ACTIVITY_START_DENIED);\n\n            // All right, create the sender.\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return PendingIntent.getActivityAsUser(\n                        mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_CANCEL_CURRENT,\n                                options.toBundle(), new UserHandle(provider.getUserId()))\n                        .getIntentSender();\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    /**\n     * Associates an {@link Widget} (as specified by {@code appWidgetId}) with\n     * a {@link Provider} (as specified by {@code providerComponent}) from\n     * a specific user/profile, if applicable.\n     *\n     * Note: The {@link Widget} itself is already associated with its {@link Host}\n     * in {@link #allocateAppWidgetId}.\n     *\n     * @param callingPackage The package that calls this method.\n     * @param appWidgetId The id of theapp widget to bind.\n     * @param providerProfileId The user/profile id of the provider.\n     * @param providerComponent The {@link ComponentName} that provides the widget.\n     * @param options The options to pass to the provider.\n     * @see AppWidgetManager#bindAppWidgetIdIfAllowed(int, ComponentName)\n     * @see AppWidgetManager#bindAppWidgetIdIfAllowed(int, ComponentName, Bundle)\n     * @see AppWidgetManager#bindAppWidgetIdIfAllowed(int, UserHandle, ComponentName, Bundle)\n     */\n    @Override\n    public boolean bindAppWidgetId(String callingPackage, int appWidgetId,\n            int providerProfileId, ComponentName providerComponent, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"bindAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        // Check that if a cross-profile binding is attempted, it is allowed.\n        if (!mSecurityPolicy.isEnabledGroupProfile(providerProfileId)) {\n            return false;\n        }\n\n        // If the provider is not under the calling user, make sure this\n        // provider is allowlisted for access from the parent.\n        if (!mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                providerComponent.getPackageName(), providerProfileId)) {\n            return false;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // A special permission or allowlisting is required to bind widgets.\n            if (!mSecurityPolicy.hasCallerBindPermissionOrBindWhiteListedLocked(\n                    callingPackage)) {\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                Slog.e(TAG, \"Bad widget id \" + appWidgetId);\n                return false;\n            }\n\n            if (widget.provider != null) {\n                Slog.e(TAG, \"Widget id \" + appWidgetId\n                        + \" already bound to: \" + widget.provider.id);\n                return false;\n            }\n\n            final int providerUid = getUidForPackage(providerComponent.getPackageName(),\n                    providerProfileId);\n            if (providerUid < 0) {\n                Slog.e(TAG, \"Package \" + providerComponent.getPackageName() + \" not installed \"\n                        + \" for profile \" + providerProfileId);\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the provider is in the already vetted user profile.\n            ProviderId providerId = new ProviderId(providerUid, providerComponent);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.e(TAG, \"No widget provider \" + providerComponent + \" for profile \"\n                        + providerProfileId);\n                return false;\n            }\n\n            if (provider.zombie) {\n                Slog.e(TAG, \"Can't bind to a 3rd party provider in\"\n                        + \" safe mode \" + provider);\n                return false;\n            }\n\n            widget.provider = provider;\n            widget.options = (options != null) ? cloneIfLocalBinder(options) : new Bundle();\n\n            // We need to provide a default value for the widget category if it is not specified\n            if (!widget.options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {\n                widget.options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY,\n                        AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            }\n\n            provider.widgets.add(widget);\n\n            onWidgetProviderAddedOrChangedLocked(widget);\n\n            final int widgetCount = provider.widgets.size();\n            if (widgetCount == 1) {\n                // If we are binding the very first widget from a provider, we will send\n                // a combined broadcast or 2 separate broadcasts to tell the provider that\n                // it's ready, and we need them to provide the update now.\n                sendEnableAndUpdateIntentLocked(provider, new int[]{appWidgetId});\n            } else {\n                // For any widget other then the first one, we just send update intent\n                // as we normally would.\n                sendUpdateIntentLocked(provider, new int[]{appWidgetId}, true);\n            }\n\n            // Schedule the future updates.\n            registerForBroadcastsLocked(provider, getWidgetIds(provider.widgets));\n\n            saveGroupStateAsync(userId);\n            Slog.i(TAG, \"Bound widget \" + appWidgetId + \" to provider \" + provider.id);\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the list of appWidgetIds that have been bound to the given AppWidget\n     * provider.\n     *\n     * Note: User can create multiple instances of {@link Widget} that are\n     * supplied by the same {@link Provider}.\n     *\n     * @param provider The {@link android.content.BroadcastReceiver} that is the\n     *            AppWidget provider to find appWidgetIds for.\n     * @see AppWidgetManager#getAppWidgetIds(ComponentName)\n     */\n    @Override\n    public int[] getAppWidgetIds(ComponentName componentName) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIds() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider != null) {\n                return getWidgetIds(provider.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    /**\n     * Gets a list of appWidgetIds that are bound to the specified host.\n     *\n     * @param callingPackage The package that calls this method.\n     * @param hostId id of the {@link Host}.\n     * @rerurn int[] list of appWidgetIds that are bound to this host.\n     */\n    @Override\n    public int[] getAppWidgetIdsForHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIdsForHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access its hosts.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                return getWidgetIds(host.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    /**\n     * Binds the RemoteViewsService for a given appWidgetId and intent.\n     * This method is used by {@link RemoteViewsAdapter} to establish a connection\n     * to the {@link RemoteViewsService} that provides data for the adapter.\n     *\n     * The appWidgetId specified must already be bound to the calling AppWidgetHost via\n     * {@link android.appwidget.AppWidgetManager#bindAppWidgetId AppWidgetManager.bindAppWidgetId()}.\n     *\n     * Note: Since {@link AppWidgetManager#setRemoteAdapter(int, RemoteViewsAdapter))} is deprecated,\n     * this method is effectively deprecated as well.\n     *\n     * @param callingPackage The package that calls this method.\n     * @param appWidgetId   The AppWidget instance for which to bind the RemoteViewsService.\n     * @param intent        The intent of the service which will be providing the data to the\n     *                      RemoteViewsAdapter.\n     * @param caller        Caller's {@link IApplicationThread}, see\n     *                      {@link Context#getIApplicationThread()}\n     * @param activityToken Caller's {@link IBinder}, see {@link Context#getActivityToken()}\n     * @param connection    The callback interface to be notified when a connection is made or lost.\n     * @param flags         Flags used for binding to the service. Only\n     *                     {@link Context#BIND_AUTO_CREATE} and\n     *                     {@link Context#BIND_FOREGROUND_SERVICE_WHILE_AWAKE} are supported.\n     *\n     * @see AppWidgetManager#setRemoteAdapter(int, RemoteViewsAdapter)\n     */\n    @Override\n    public boolean bindRemoteViewsService(String callingPackage, int appWidgetId, Intent intent,\n            IApplicationThread caller, IBinder activtiyToken, IServiceConnection connection,\n            long flags) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"bindRemoteViewsService() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id\");\n            }\n\n            // Make sure the widget has a provider.\n            if (widget.provider == null) {\n                throw new IllegalArgumentException(\"No provider for widget \"\n                        + appWidgetId);\n            }\n\n            ComponentName componentName = intent.getComponent();\n\n            // Ensure that the service belongs to the same package as the provider.\n            // But this is not enough as they may be under different users - see below...\n            String providerPackage = widget.provider.id.componentName.getPackageName();\n            String servicePackage = componentName.getPackageName();\n            if (!servicePackage.equals(providerPackage)) {\n                throw new SecurityException(\"The taget service not in the same package\"\n                        + \" as the widget provider\");\n            }\n\n            // Make sure this service exists under the same user as the provider and\n            // requires a permission which allows only the system to bind to it.\n            mSecurityPolicy.enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                    componentName, widget.provider.getUserId());\n\n            // Good to go - the service package is correct, it exists for the correct\n            // user, and requires the bind permission.\n\n            final long callingIdentity = Binder.clearCallingIdentity();\n            try {\n                // Ask ActivityManager to bind it. Notice that we are binding the service with the\n                // caller app instead of DevicePolicyManagerService.\n                if (ActivityManager.getService().bindService(\n                        caller, activtiyToken, intent,\n                        intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                        connection, flags & (Context.BIND_AUTO_CREATE\n                                | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE),\n                        mContext.getOpPackageName(), widget.provider.getUserId()) != 0) {\n\n                    // Add it to the mapping of RemoteViewsService to appWidgetIds so that we\n                    // can determine when we can call back to the RemoteViewsService later to\n                    // destroy associated factories.\n                    incrementAppWidgetServiceRefCount(appWidgetId,\n                            Pair.create(widget.provider.id.uid, new FilterComparison(intent)));\n                    return true;\n                }\n            } catch (RemoteException ex) {\n                // Same process, should not happen.\n            } finally {\n                Binder.restoreCallingIdentity(callingIdentity);\n            }\n        }\n\n        // Failed to bind.\n        return false;\n    }\n\n    @Override\n    public void deleteHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts in its uid and package.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host == null) {\n                return;\n            }\n\n            deleteHostLocked(host);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted host \" + host.id);\n            }\n        }\n    }\n\n    @Override\n    public void deleteAllHosts() {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAllHosts() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            boolean changed = false;\n\n            final int N = mHosts.size();\n            for (int i = N - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n\n                // Delete only hosts in the calling uid.\n                if (host.id.uid == Binder.getCallingUid()) {\n                    deleteHostLocked(host);\n                    changed = true;\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Deleted host \" + host.id);\n                    }\n                }\n            }\n\n            if (changed) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    @Override\n    public AppWidgetProviderInfo getAppWidgetInfo(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetInfo() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.provider != null && !widget.provider.zombie) {\n                final AppWidgetProviderInfo info = widget.provider.getInfoLocked(mContext);\n                if (info == null) {\n                    Slog.e(TAG, \"getAppWidgetInfo() returns null because\"\n                            + \" widget.provider.getInfoLocked() returned null.\"\n                            + \" appWidgetId=\" + appWidgetId + \" userId=\" + userId\n                            + \" widget=\" + widget);\n                    return null;\n                }\n                final AppWidgetProviderInfo ret = cloneIfLocalBinder(info);\n                if (ret == null) {\n                    Slog.e(TAG, \"getAppWidgetInfo() returns null because\"\n                            + \" cloneIfLocalBinder() returned null.\"\n                            + \" appWidgetId=\" + appWidgetId + \" userId=\" + userId\n                            + \" widget=\" + widget + \" appWidgetProviderInfo=\" + info);\n                }\n                return ret;\n            } else {\n                if (widget == null) {\n                    Slog.e(TAG, \"getAppWidgetInfo() returns null because widget is null.\"\n                            + \" appWidgetId=\" + appWidgetId + \" userId=\" + userId);\n                } else if (widget.provider == null) {\n                    Slog.e(TAG, \"getAppWidgetInfo() returns null because widget.provider is null.\"\n                            + \" appWidgetId=\" + appWidgetId + \" userId=\" + userId\n                            + \" widget=\" + widget);\n                } else {\n                    Slog.e(TAG, \"getAppWidgetInfo() returns null because widget.provider is zombie.\"\n                            + \" appWidgetId=\" + appWidgetId + \" userId=\" + userId\n                            + \" widget=\" + widget);\n                }\n            }\n            return null;\n        }\n    }\n\n    @Override\n    public RemoteViews getAppWidgetViews(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetViews() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null) {\n                return cloneIfLocalBinder(widget.getEffectiveViewsLocked());\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetOptions(String callingPackage, int appWidgetId, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            // Merge the options.\n            widget.options.putAll(options);\n\n            // Send the broacast to notify the provider that options changed.\n            sendOptionsChangedIntentLocked(widget);\n\n            saveGroupStateAsync(userId);\n        }\n    }\n\n    @Override\n    public Bundle getAppWidgetOptions(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.options != null) {\n                return cloneIfLocalBinder(widget.options);\n            }\n\n            return Bundle.EMPTY;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, false);\n    }\n\n    @Override\n    public void partiallyUpdateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"partiallyUpdateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, true);\n    }\n\n    @Override\n    public void notifyProviderInheritance(@Nullable final ComponentName[] componentNames) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"notifyProviderInheritance() \" + userId);\n        }\n\n        if (componentNames == null) {\n            return;\n        }\n\n        for (ComponentName componentName : componentNames) {\n            if (componentName == null) {\n                return;\n            }\n            mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n        }\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            for (ComponentName componentName : componentNames) {\n                final ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n                final Provider provider = lookupProviderLocked(providerId);\n\n                if (provider == null || provider.info == null) {\n                    return;\n                }\n\n                provider.info.isExtendedFromAppWidgetProvider = true;\n            }\n            saveGroupStateAsync(userId);\n        }\n    }\n\n    @Override\n    public void notifyAppWidgetViewDataChanged(String callingPackage, int[] appWidgetIds,\n            int viewId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"notifyAppWidgetViewDataChanged() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    scheduleNotifyAppWidgetViewDataChanged(widget, viewId);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProvider(ComponentName componentName, RemoteViews views) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.w(TAG, \"Provider doesn't exist \" + providerId);\n                return;\n            }\n\n            ArrayList<Widget> instances = provider.widgets;\n            final int N = instances.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = instances.get(i);\n                updateAppWidgetInstanceLocked(widget, views, false);\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProviderInfo(ComponentName componentName, String metadataKey) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n            if (provider == null) {\n                throw new IllegalArgumentException(\n                        componentName + \" is not a valid AppWidget provider\");\n            }\n            if (Objects.equals(provider.infoTag, metadataKey)) {\n                // No change\n                return;\n            }\n\n            String keyToUse = metadataKey == null\n                    ? AppWidgetManager.META_DATA_APPWIDGET_PROVIDER : metadataKey;\n            AppWidgetProviderInfo info = parseAppWidgetProviderInfo(mContext, providerId,\n                    provider.getPartialInfoLocked().providerInfo, keyToUse);\n            if (info == null) {\n                throw new IllegalArgumentException(\"Unable to parse \" + keyToUse\n                        + \" meta-data to a valid AppWidget provider\");\n            }\n\n            provider.setInfoLocked(info);\n            provider.infoTag = metadataKey;\n\n            // Update all widgets for this provider\n            final int N = provider.widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = provider.widgets.get(i);\n                scheduleNotifyProviderChangedLocked(widget);\n                updateAppWidgetInstanceLocked(widget, widget.views, false /* isPartialUpdate */);\n            }\n\n            saveGroupStateAsync(userId);\n            scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n        }\n    }\n\n    @Override\n    public boolean isRequestPinAppWidgetSupported() {\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + Binder.getCallingUid()\n                        + \" query information about app widgets\");\n                return false;\n            }\n        }\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .isRequestPinItemSupported(UserHandle.getCallingUserId(),\n                        LauncherApps.PinItemRequest.REQUEST_TYPE_APPWIDGET);\n    }\n\n    @Override\n    public boolean requestPinAppWidget(String callingPackage, ComponentName componentName,\n            Bundle extras, IntentSender resultSender) {\n        final int callingUid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(callingUid);\n\n        if (DEBUG) {\n            Slog.i(TAG, \"requestPinAppWidget() \" + userId);\n        }\n\n        final AppWidgetProviderInfo info;\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final String pkg = componentName.getPackageName();\n            final ProviderId id;\n            if (!mPackageManagerInternal.isSameApp(pkg, callingUid, userId)) {\n                // If the calling process is requesting to pin appwidgets from another process,\n                // check if the calling process has the necessary permission.\n                if (!injectHasAccessWidgetsPermission(Binder.getCallingPid(), callingUid)) {\n                    return false;\n                }\n                id = new ProviderId(mPackageManagerInternal.getPackageUid(\n                        pkg, 0 /* flags */, userId), componentName);\n            } else {\n                id = new ProviderId(callingUid, componentName);\n            }\n            // Look for the widget associated with the caller.\n            Provider provider = lookupProviderLocked(id);\n            if (provider == null || provider.zombie) {\n                return false;\n            }\n            info = provider.getInfoLocked(mContext);\n            if ((info.widgetCategory & AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN) == 0) {\n                return false;\n            }\n        }\n\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .requestPinAppWidget(callingPackage, info, extras, resultSender, userId);\n    }\n\n    /**\n     * Returns true if the caller has the proper permission to access app widgets.\n     */\n    private boolean injectHasAccessWidgetsPermission(int callingPid, int callingUid) {\n        return mContext.checkPermission(Manifest.permission.CLEAR_APP_USER_DATA,\n                callingPid, callingUid) == PackageManager.PERMISSION_GRANTED;\n    }\n\n    @Override\n    public ParceledListSlice<AppWidgetProviderInfo> getInstalledProvidersForProfile(int categoryFilter,\n            int profileId, String packageName) {\n        final int userId = UserHandle.getCallingUserId();\n        final int callingUid = Binder.getCallingUid();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getInstalledProvidersForProfiles() \" + userId);\n        }\n\n        // Ensure the profile is in the group and enabled.\n        if (!mSecurityPolicy.isEnabledGroupProfile(profileId)) {\n            return null;\n        }\n\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + callingUid\n                        + \" cannot access widget providers\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            ArrayList<AppWidgetProviderInfo> result = new ArrayList<AppWidgetProviderInfo>();\n\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                final String providerPackageName = provider.id.componentName.getPackageName();\n\n                // Ignore an invalid provider or one that isn't in the given package, if any.\n                boolean inPackage = packageName == null || providerPackageName.equals(packageName);\n                if (provider.zombie || !inPackage) {\n                    continue;\n                }\n\n                // Ignore the ones not matching the filter.\n                AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n                if ((info.widgetCategory & categoryFilter) == 0) {\n                    continue;\n                }\n\n                // Add providers only for the requested profile that are allowlisted.\n                final int providerProfileId = info.getProfile().getIdentifier();\n                if (providerProfileId == profileId\n                        && mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                        providerPackageName, providerProfileId)\n                        && !mPackageManagerInternal.filterAppAccess(providerPackageName, callingUid,\n                        profileId)) {\n                    result.add(cloneIfLocalBinder(info));\n                }\n            }\n\n            return new ParceledListSlice<AppWidgetProviderInfo>(result);\n        }\n    }\n\n    private void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views, boolean partially) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    updateAppWidgetInstanceLocked(widget, views, partially);\n                }\n            }\n        }\n    }\n\n    private int incrementAndGetAppWidgetIdLocked(int userId) {\n        final int appWidgetId = peekNextAppWidgetIdLocked(userId) + 1;\n        mNextAppWidgetIds.put(userId, appWidgetId);\n        return appWidgetId;\n    }\n\n    private void setMinAppWidgetIdLocked(int userId, int minWidgetId) {\n        final int nextAppWidgetId = peekNextAppWidgetIdLocked(userId);\n        if (nextAppWidgetId < minWidgetId) {\n            mNextAppWidgetIds.put(userId, minWidgetId);\n        }\n    }\n\n    private int peekNextAppWidgetIdLocked(int userId) {\n        if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n            return AppWidgetManager.INVALID_APPWIDGET_ID + 1;\n        } else {\n            return mNextAppWidgetIds.get(userId);\n        }\n    }\n\n    private Host lookupOrAddHostLocked(HostId id) {\n        Host host = lookupHostLocked(id);\n        if (host != null) {\n            return host;\n        }\n        ensureHostCountBeforeAddLocked(id);\n        host = new Host();\n        host.id = id;\n        mHosts.add(host);\n\n        return host;\n    }\n\n    /**\n     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n     * removes the oldest host.\n     */\n    private void ensureHostCountBeforeAddLocked(@NonNull final HostId hostId) {\n        final List<Host> hosts = new ArrayList<>();\n        for (Host host : mHosts) {\n            if (host.id.uid == hostId.uid\n                    && host.id.packageName.equals(hostId.packageName)) {\n                hosts.add(host);\n            }\n        }\n        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n            deleteHostLocked(hosts.remove(0));\n        }\n    }\n\n    private void deleteHostLocked(Host host) {\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteHostLocked() \" + host);\n        }\n        final int N = host.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = host.widgets.remove(i);\n            deleteAppWidgetLocked(widget);\n        }\n        mHosts.remove(host);\n\n        // it's gone or going away, abruptly drop the callback connection\n        host.callbacks = null;\n    }\n\n    private void deleteAppWidgetLocked(Widget widget) {\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAppWidgetLocked() \" + widget);\n        }\n        // We first unbind all services that are bound to this id\n        // Check if we need to destroy any services (if no other app widgets are\n        // referencing the same service)\n        decrementAppWidgetServiceRefCount(widget);\n\n        Host host = widget.host;\n        host.widgets.remove(widget);\n        pruneHostLocked(host);\n\n        removeWidgetLocked(widget);\n\n        Provider provider = widget.provider;\n        if (provider != null) {\n            provider.widgets.remove(widget);\n            if (!provider.zombie) {\n                // If the package is not stopped, send the broadcast saying that this appWidgetId\n                // has been deleted. Otherwise, save the ID and send the broadcast when the package\n                // is unstopped.\n                if (!provider.maskedByStoppedPackage) {\n                    sendDeletedIntentLocked(widget);\n                } else {\n                    provider.pendingDeletedWidgetIds.add(widget.appWidgetId);\n                }\n\n                if (provider.widgets.isEmpty()) {\n                    // cancel the future updates\n                    cancelBroadcastsLocked(provider);\n\n                    // send the broadcast saying that the provider is not in use any more\n                    if (!provider.maskedByStoppedPackage) {\n                        sendDisabledIntentLocked(provider);\n                    }\n                }\n            }\n        }\n    }\n\n    private void cancelBroadcastsLocked(Provider provider) {\n        if (DEBUG) {\n            Slog.i(TAG, \"cancelBroadcastsLocked() for \" + provider);\n        }\n        if (provider.broadcast != null) {\n            final PendingIntent broadcast = provider.broadcast;\n            mSaveStateHandler.post(() -> {\n                    mAlarmManager.cancel(broadcast);\n                    broadcast.cancel();\n            });\n            provider.broadcast = null;\n        }\n    }\n\n    // Destroys the cached factory on the RemoteViewsService's side related to the specified intent\n    private void destroyRemoteViewsService(final Intent intent, Widget widget) {\n        final ServiceConnection conn = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName name, IBinder service) {\n                final IRemoteViewsFactory cb = IRemoteViewsFactory.Stub.asInterface(service);\n                try {\n                    cb.onDestroy(intent);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Error calling remove view factory\", re);\n                }\n                mContext.unbindService(this);\n            }\n\n            @Override\n            public void onServiceDisconnected(ComponentName name) {\n                // Do nothing\n            }\n        };\n\n        // Bind to the service and remove the static intent->factory mapping in the\n        // RemoteViewsService.\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, conn,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    widget.provider.id.getProfile());\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    // Adds to the ref-count for a given RemoteViewsService intent\n    private void incrementAppWidgetServiceRefCount(int appWidgetId,\n            Pair<Integer, FilterComparison> serviceId) {\n        final HashSet<Integer> appWidgetIds;\n        if (mRemoteViewsServicesAppWidgets.containsKey(serviceId)) {\n            appWidgetIds = mRemoteViewsServicesAppWidgets.get(serviceId);\n        } else {\n            appWidgetIds = new HashSet<>();\n            mRemoteViewsServicesAppWidgets.put(serviceId, appWidgetIds);\n        }\n        appWidgetIds.add(appWidgetId);\n    }\n\n    // Subtracts from the ref-count for a given RemoteViewsService intent, prompting a delete if\n    // the ref-count reaches zero.\n    private void decrementAppWidgetServiceRefCount(Widget widget) {\n        Iterator<Pair<Integer, FilterComparison>> it = mRemoteViewsServicesAppWidgets\n                .keySet().iterator();\n        while (it.hasNext()) {\n            final Pair<Integer, FilterComparison> key = it.next();\n            final HashSet<Integer> ids = mRemoteViewsServicesAppWidgets.get(key);\n            if (ids.remove(widget.appWidgetId)) {\n                // If we have removed the last app widget referencing this service, then we\n                // should destroy it and remove it from this set. This is skipped for widgets whose\n                // provider is in a stopped package, to avoid waking up the package.\n                if (ids.isEmpty() && !widget.provider.maskedByStoppedPackage) {\n                    destroyRemoteViewsService(key.second.getIntent(), widget);\n                    it.remove();\n                }\n            }\n        }\n    }\n\n    private void saveGroupStateAsync(int groupId) {\n        if (removeAppWidgetServiceIoFromCriticalPath()) {\n            mSaveStateHandler.removeMessages(groupId);\n            mSaveStateHandler.sendEmptyMessage(groupId);\n        } else {\n            mSaveStateHandler.post(new SaveStateRunnable(groupId));\n        }\n    }\n\n    private void updateAppWidgetInstanceLocked(Widget widget, RemoteViews views,\n            boolean isPartialUpdate) {\n        if (widget != null && widget.provider != null\n                && !widget.provider.zombie && !widget.host.zombie) {\n\n            if (isPartialUpdate && widget.views != null) {\n                // For a partial update, we merge the new RemoteViews with the old.\n                widget.views.mergeRemoteViews(views);\n            } else {\n                // For a full update we replace the RemoteViews completely.\n                widget.views = views;\n            }\n            int memoryUsage;\n            if ((UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) &&\n                    (widget.views != null) &&\n                    ((memoryUsage = widget.views.estimateMemoryUsage()) > mMaxWidgetBitmapMemory)) {\n                widget.views = null;\n                throw new IllegalArgumentException(\"RemoteViews for widget update exceeds\"\n                        + \" maximum bitmap memory usage (used: \" + memoryUsage\n                        + \", max: \" + mMaxWidgetBitmapMemory + \")\");\n            }\n            scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n        }\n    }\n    private void scheduleNotifyAppWidgetViewDataChanged(Widget widget, int viewId) {\n        if (viewId == ID_VIEWS_UPDATE || viewId == ID_PROVIDER_CHANGED) {\n            // A view id should never collide with these constants but a developer can call this\n            // method with a wrong id. In that case, ignore the call.\n            return;\n        }\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(viewId, requestId);\n        }\n        if (widget == null || widget.host == null || widget.host.zombie\n                || widget.host.callbacks == null || widget.provider == null\n                || widget.provider.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n        args.argi2 = viewId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_VIEW_DATA_CHANGED,\n                args).sendToTarget();\n    }\n\n\n    private void handleNotifyAppWidgetViewDataChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, int viewId, long requestId) {\n        try {\n            Slog.d(TAG, \"Trying to notify widget view data changed\");\n            callbacks.viewDataChanged(appWidgetId, viewId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            // It failed; remove the callback. No need to prune because\n            // we know that this host is still referenced by this instance.\n            callbacks = null;\n        }\n\n        // If the host is unavailable, then we call the associated\n        // RemoteViewsFactory.onDataSetChanged() directly\n        synchronized (mLock) {\n            if (callbacks == null) {\n                host.callbacks = null;\n\n                Set<Pair<Integer, FilterComparison>> keys = mRemoteViewsServicesAppWidgets.keySet();\n                for (Pair<Integer, FilterComparison> key : keys) {\n                    if (mRemoteViewsServicesAppWidgets.get(key).contains(appWidgetId)) {\n                        final ServiceConnection connection = new ServiceConnection() {\n                            @Override\n                            public void onServiceConnected(ComponentName name, IBinder service) {\n                                IRemoteViewsFactory cb = IRemoteViewsFactory.Stub\n                                        .asInterface(service);\n                                try {\n                                    cb.onDataSetChangedAsync();\n                                } catch (RemoteException e) {\n                                    Slog.e(TAG, \"Error calling onDataSetChangedAsync()\", e);\n                                }\n                                mContext.unbindService(this);\n                            }\n\n                            @Override\n                            public void onServiceDisconnected(android.content.ComponentName name) {\n                                // Do nothing\n                            }\n                        };\n\n                        final int userId = UserHandle.getUserId(key.first);\n                        Intent intent = key.second.getIntent();\n\n                        // Bind to the service and call onDataSetChanged()\n                        bindService(intent, connection, new UserHandle(userId));\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleNotifyUpdateAppWidgetLocked(Widget widget, RemoteViews updateViews) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            if (widget.trackingUpdate) {\n                // This is the first update, end the trace\n                widget.trackingUpdate = false;\n                Log.i(TAG, \"Widget update received \" + widget.toString());\n                Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER,\n                        \"appwidget update-intent \" + widget.provider.id.toString(),\n                        widget.appWidgetId);\n            }\n            widget.updateSequenceNos.put(ID_VIEWS_UPDATE, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n        if (updateViews != null) {\n            updateViews = new RemoteViews(updateViews);\n            updateViews.setProviderInstanceId(requestId);\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = updateViews;\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        if (updateViews != null && updateViews.isLegacyListRemoteViews()) {\n            mCallbackHandler.obtainMessage(\n                    CallbackHandler.MSG_NOTIFY_UPDATE_APP_WIDGET_DEFERRED,\n                    args).sendToTarget();\n            return;\n        }\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_UPDATE_APP_WIDGET,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyUpdateAppWidgetDeferred(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, long requestId) {\n        try {\n            Slog.d(TAG, \"Trying to notify widget update deferred for id: \" + appWidgetId);\n            callbacks.updateAppWidgetDeferred(appWidgetId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void handleNotifyUpdateAppWidget(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, RemoteViews views, long requestId) {\n        try {\n            Slog.d(TAG, \"Trying to notify widget update for package \"\n                    + (views == null ? \"null\" : views.getPackage())\n                    + \" with widget id: \" + appWidgetId);\n            callbacks.updateAppWidget(appWidgetId, views);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    @GuardedBy(\"mLock\")\n    private void scheduleNotifyProviderChangedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            // When the provider changes, reset everything else.\n            widget.updateSequenceNos.clear();\n            widget.updateSequenceNos.append(ID_PROVIDER_CHANGED, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = widget.provider.getInfoLocked(mContext);\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_PROVIDER_CHANGED,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyProviderChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, AppWidgetProviderInfo info, long requestId) {\n        try {\n            Slog.d(TAG, \"Trying to notify provider update\");\n            callbacks.providerChanged(appWidgetId, info);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock){\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyAppWidgetRemovedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            if (widget.trackingUpdate) {\n                // Widget is being removed without any update, end the trace\n                widget.trackingUpdate = false;\n                Log.i(TAG, \"Widget removed \" + widget.toString());\n                Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER,\n                        \"appwidget update-intent \" + widget.provider.id.toString(),\n                        widget.appWidgetId);\n            }\n\n            widget.updateSequenceNos.clear();\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n            CallbackHandler.MSG_NOTIFY_APP_WIDGET_REMOVED,\n            args).sendToTarget();\n    }\n\n    private void handleNotifyAppWidgetRemoved(Host host, IAppWidgetHost callbacks, int appWidgetId,\n            long requestId) {\n        try {\n            Slog.d(TAG, \"Trying to notify widget removed\");\n            callbacks.appWidgetRemoved(appWidgetId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyGroupHostsForProvidersChangedLocked(int userId) {\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n\n            boolean hostInGroup = false;\n            final int M = profileIds.length;\n            for (int j = 0; j < M; j++) {\n                final int profileId = profileIds[j];\n                if (host.getUserId() == profileId) {\n                    hostInGroup = true;\n                    break;\n                }\n            }\n\n            if (!hostInGroup) {\n                continue;\n            }\n\n            if (host == null || host.zombie || host.callbacks == null) {\n                continue;\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = host;\n            args.arg2 = host.callbacks;\n\n            mCallbackHandler.obtainMessage(\n                    CallbackHandler.MSG_NOTIFY_PROVIDERS_CHANGED,\n                    args).sendToTarget();\n        }\n    }\n\n    private void handleNotifyProvidersChanged(Host host, IAppWidgetHost callbacks) {\n        try {\n            Slog.d(TAG, \"Trying to notify widget providers changed\");\n            callbacks.providersChanged();\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private static boolean isLocalBinder() {\n        return Process.myPid() == Binder.getCallingPid();\n    }\n\n    private static RemoteViews cloneIfLocalBinder(RemoteViews rv) {\n        if (isLocalBinder() && rv != null) {\n            return rv.clone();\n        }\n        return rv;\n    }\n\n    private static AppWidgetProviderInfo cloneIfLocalBinder(AppWidgetProviderInfo info) {\n        if (isLocalBinder() && info != null) {\n            return info.clone();\n        }\n        return info;\n    }\n\n    private static Bundle cloneIfLocalBinder(Bundle bundle) {\n        // Note: this is only a shallow copy. For now this will be fine, but it could be problematic\n        // if we start adding objects to the options. Further, it would only be an issue if keyguard\n        // used such options.\n        if (isLocalBinder() && bundle != null) {\n            return (Bundle) bundle.clone();\n        }\n        return bundle;\n    }\n\n    private Widget lookupWidgetLocked(int appWidgetId, int uid, String packageName) {\n        final int N = mWidgets.size();\n        for (int i = 0; i < N; i++) {\n            Widget widget = mWidgets.get(i);\n            if (widget.appWidgetId == appWidgetId\n                    && mSecurityPolicy.canAccessAppWidget(widget, uid, packageName)) {\n                return widget;\n            }\n        }\n        if (DEBUG) {\n            Slog.i(TAG, \"cannot find widget for appWidgetId=\" + appWidgetId + \" uid=\" + uid\n                    + \" packageName=\" + packageName);\n        }\n        return null;\n    }\n\n    private Provider lookupProviderLocked(ProviderId id) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.id.equals(id)) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host lookupHostLocked(HostId hostId) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.equals(hostId)) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    private void pruneHostLocked(Host host) {\n        if (host.widgets.size() == 0 && host.callbacks == null) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Pruning host \" + host.id);\n            }\n            mHosts.remove(host);\n        }\n    }\n\n    @GuardedBy(\"mLock\")\n    private void loadGroupWidgetProvidersLocked(int[] profileIds) {\n        List<ResolveInfo> allReceivers = null;\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            List<ResolveInfo> receivers = queryIntentReceivers(intent, profileId);\n            if (receivers != null && !receivers.isEmpty()) {\n                if (allReceivers == null) {\n                    allReceivers = new ArrayList<>();\n                }\n                allReceivers.addAll(receivers);\n            }\n        }\n\n        final int N = (allReceivers == null) ? 0 : allReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo receiver = allReceivers.get(i);\n            addProviderLocked(receiver);\n        }\n    }\n\n    private boolean addProviderLocked(ResolveInfo ri) {\n        if ((ri.activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n            return false;\n        }\n\n        ComponentName componentName = new ComponentName(ri.activityInfo.packageName,\n                ri.activityInfo.name);\n        ProviderId providerId = new ProviderId(ri.activityInfo.applicationInfo.uid, componentName);\n\n        // we might have an inactive entry for this provider already due to\n        // a preceding restore operation.  if so, fix it up in place; otherwise\n        // just add this new one.\n        Provider existing = lookupProviderLocked(providerId);\n\n        // If the provider was not found it may be because it was restored and\n        // we did not know its UID so let us find if there is such one.\n        if (existing == null) {\n            ProviderId restoredProviderId = new ProviderId(UNKNOWN_UID, componentName);\n            existing = lookupProviderLocked(restoredProviderId);\n        }\n\n        AppWidgetProviderInfo info = createPartialProviderInfo(providerId, ri, existing);\n\n        if (android.os.Flags.allowPrivateProfile()\n                && android.multiuser.Flags.disablePrivateSpaceItemsOnHome()\n                && android.multiuser.Flags.enablePrivateSpaceFeatures()) {\n            // Do not add widget providers for profiles with items restricted on home screen.\n            if (info != null && mUserManager\n                    .getUserProperties(info.getProfile()).areItemsRestrictedOnHomeScreen()) {\n                return false;\n            }\n        }\n\n        if (info != null) {\n            if (existing != null) {\n                if (existing.zombie && !mSafeMode) {\n                    // it's a placeholder that was set up during an app restore\n                    existing.id = providerId;\n                    existing.zombie = false;\n                    existing.setPartialInfoLocked(info);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Provider placeholder now reified: \" + existing);\n                    }\n                }\n            } else {\n                Provider provider = new Provider();\n                provider.id = providerId;\n                provider.setPartialInfoLocked(info);\n                mProviders.add(provider);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    // Remove widgets for provider that are hosted in userId.\n    private void deleteWidgetsLocked(Provider provider, int userId) {\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteWidgetsLocked() provider=\" + provider + \" userId=\" + userId);\n        }\n        final int N = provider.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = provider.widgets.get(i);\n            if (userId == UserHandle.USER_ALL\n                    || userId == widget.host.getUserId()) {\n                provider.widgets.remove(i);\n                // Call back with empty RemoteViews\n                updateAppWidgetInstanceLocked(widget, null, false);\n                // clear out references to this appWidgetId\n                widget.host.widgets.remove(widget);\n                removeWidgetLocked(widget);\n                widget.provider = null;\n                pruneHostLocked(widget.host);\n                widget.host = null;\n            }\n        }\n    }\n\n    private void deleteProviderLocked(Provider provider) {\n        deleteWidgetsLocked(provider, UserHandle.USER_ALL);\n        mProviders.remove(provider);\n        mGeneratedPreviewsApiCounter.remove(provider.id);\n\n        // no need to send the DISABLE broadcast, since the receiver is gone anyway\n        cancelBroadcastsLocked(provider);\n    }\n\n    private void sendEnableAndUpdateIntentLocked(@NonNull Provider p, int[] appWidgetIds) {\n        final boolean canSendCombinedBroadcast = mIsCombinedBroadcastEnabled && p.info != null\n                && p.info.isExtendedFromAppWidgetProvider;\n        if (!canSendCombinedBroadcast) {\n            // If this function is called by mistake, send two separate broadcasts instead\n            sendEnableIntentLocked(p);\n            sendUpdateIntentLocked(p, appWidgetIds, true);\n            return;\n        }\n\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_ENABLE_AND_UPDATE);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n        intent.setComponent(p.id.componentName);\n        // Placing a widget is something users expect to be UX-responsive, so mark this\n        // broadcast as interactive\n        sendBroadcastAsUser(intent, p.id.getProfile(), true);\n    }\n\n    private void sendEnableIntentLocked(Provider p) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_ENABLED);\n        intent.setComponent(p.id.componentName);\n        // Enabling the widget is something users expect to be UX-responsive, so mark this\n        // broadcast as interactive\n        sendBroadcastAsUser(intent, p.id.getProfile(), true);\n    }\n\n    private void sendUpdateIntentLocked(Provider provider, int[] appWidgetIds,\n            boolean interactive) {\n        Intent intent = createUpdateIntentLocked(provider, appWidgetIds);\n        sendBroadcastAsUser(intent, provider.id.getProfile(), interactive);\n    }\n\n    private Intent createUpdateIntentLocked(Provider provider, int[] appWidgetIds) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n        intent.setComponent(provider.id.componentName);\n        return intent;\n    }\n\n    private void sendDeletedIntentLocked(Widget widget) {\n        sendDeletedIntentLocked(widget.provider.id.componentName, widget.provider.id.getProfile(),\n                widget.appWidgetId);\n    }\n\n    private void sendDeletedIntentLocked(ComponentName provider, UserHandle profile,\n            int appWidgetId) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DELETED);\n        intent.setComponent(provider);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\n        // Cleanup after deletion isn't an interactive UX case\n        sendBroadcastAsUser(intent, profile, false);\n    }\n\n    private void sendDisabledIntentLocked(Provider provider) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DISABLED);\n        intent.setComponent(provider.id.componentName);\n        // Cleanup after disable isn't an interactive UX case\n        sendBroadcastAsUser(intent, provider.id.getProfile(), false);\n    }\n\n    public void sendOptionsChangedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_OPTIONS_CHANGED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, widget.options);\n        // The user's changed the options, so seeing them take effect promptly is\n        // an interactive UX expectation\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile(), true);\n    }\n\n    @GuardedBy(\"mLock\")\n    private void registerForBroadcastsLocked(Provider provider, int[] appWidgetIds) {\n        AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n        if (info.updatePeriodMillis > 0) {\n            // if this is the first instance, set the alarm. otherwise,\n            // rely on the fact that we've already set it and that\n            // PendingIntent.getBroadcast will update the extras.\n            boolean alreadyRegistered = provider.broadcast != null;\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n            intent.setComponent(info.provider);\n            final long token = Binder.clearCallingIdentity();\n            try {\n                // Broadcast alarms sent by system are immutable\n                provider.broadcast = PendingIntent.getBroadcastAsUser(mContext, 1, intent,\n                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                        info.getProfile());\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (!alreadyRegistered) {\n                // Set the alarm outside of our locks; we've latched the first-time\n                // invariant and established the PendingIntent safely.\n                final long period = Math.max(info.updatePeriodMillis, MIN_UPDATE_PERIOD);\n                final PendingIntent broadcast = provider.broadcast;\n                mSaveStateHandler.post(() ->\n                    mAlarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,\n                            SystemClock.elapsedRealtime() + period, period, broadcast)\n                );\n            }\n        }\n    }\n\n    private static int[] getWidgetIds(ArrayList<Widget> widgets) {\n        int instancesSize = widgets.size();\n        int appWidgetIds[] = new int[instancesSize];\n        for (int i = 0; i < instancesSize; i++) {\n            appWidgetIds[i] = widgets.get(i).appWidgetId;\n        }\n        return appWidgetIds;\n    }\n\n    private static void dumpProviderLocked(Provider provider, int index, PrintWriter pw) {\n        AppWidgetProviderInfo info = provider.getPartialInfoLocked();\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] provider \");\n        pw.println(provider.id);\n        pw.print(\"    min=(\"); pw.print(info.minWidth);\n        pw.print(\"x\"); pw.print(info.minHeight);\n        pw.print(\")   minResize=(\"); pw.print(info.minResizeWidth);\n        pw.print(\"x\"); pw.print(info.minResizeHeight);\n        pw.print(\") updatePeriodMillis=\");\n        pw.print(info.updatePeriodMillis);\n        pw.print(\" resizeMode=\");\n        pw.print(info.resizeMode);\n        pw.print(\" widgetCategory=\");\n        pw.print(info.widgetCategory);\n        pw.print(\" autoAdvanceViewId=\");\n        pw.print(info.autoAdvanceViewId);\n        pw.print(\" initialLayout=#\");\n        pw.print(Integer.toHexString(info.initialLayout));\n        pw.print(\" initialKeyguardLayout=#\");\n        pw.print(Integer.toHexString(info.initialKeyguardLayout));\n        pw.print(\"   zombie=\"); pw.println(provider.zombie);\n    }\n\n    private static void dumpHost(Host host, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] hostId=\");\n        pw.println(host.id);\n        pw.print(\"    callbacks=\"); pw.println(host.callbacks);\n        pw.print(\"    widgets.size=\"); pw.print(host.widgets.size());\n        pw.print(\" zombie=\"); pw.println(host.zombie);\n    }\n\n    private static void dumpGrant(Pair<Integer, String> grant, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(']');\n        pw.print(\" user=\"); pw.print(grant.first);\n        pw.print(\" package=\"); pw.println(grant.second);\n    }\n\n    private static void dumpWidget(Widget widget, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] id=\");\n        pw.println(widget.appWidgetId);\n        pw.print(\"    host=\");\n        pw.println(widget.host.id);\n        if (widget.provider != null) {\n            pw.print(\"    provider=\"); pw.println(widget.provider.id);\n        }\n        if (widget.host != null) {\n            pw.print(\"    host.callbacks=\"); pw.println(widget.host.callbacks);\n        }\n        if (widget.views != null) {\n            pw.print(\"    views=\"); pw.println(widget.views);\n        }\n    }\n\n    private static void serializeProvider(@NonNull final TypedXmlSerializer out,\n            @NonNull final Provider p, final boolean persistsProviderInfo) throws IOException {\n        Objects.requireNonNull(out);\n        Objects.requireNonNull(p);\n        out.startTag(null, \"p\");\n        out.attribute(null, \"pkg\", p.id.componentName.getPackageName());\n        out.attribute(null, \"cl\", p.id.componentName.getClassName());\n        out.attributeIntHex(null, \"tag\", p.tag);\n        if (!TextUtils.isEmpty(p.infoTag)) {\n            out.attribute(null, \"info_tag\", p.infoTag);\n        }\n        if (persistsProviderInfo && p.mInfoParsed) {\n            AppWidgetXmlUtil.writeAppWidgetProviderInfoLocked(out, p.info);\n        }\n        final int pendingIdsCount = p.pendingDeletedWidgetIds.size();\n        if (pendingIdsCount > 0) {\n            final List<String> idStrings = new ArrayList<>();\n            for (int i = 0; i < pendingIdsCount; i++) {\n                idStrings.add(String.valueOf(p.pendingDeletedWidgetIds.get(i)));\n            }\n            out.attribute(null, PENDING_DELETED_IDS_ATTR, String.join(\",\", idStrings));\n        }\n        out.endTag(null, \"p\");\n    }\n\n    private static void serializeHost(TypedXmlSerializer out, Host host) throws IOException {\n        out.startTag(null, \"h\");\n        out.attribute(null, \"pkg\", host.id.packageName);\n        out.attributeIntHex(null, \"id\", host.id.hostId);\n        out.attributeIntHex(null, \"tag\", host.tag);\n        out.endTag(null, \"h\");\n    }\n\n    private static void serializeAppWidget(TypedXmlSerializer out, Widget widget,\n            boolean saveRestoreCompleted) throws IOException {\n        out.startTag(null, \"g\");\n        out.attributeIntHex(null, \"id\", widget.appWidgetId);\n        out.attributeIntHex(null, \"rid\", widget.restoredId);\n        out.attributeIntHex(null, \"h\", widget.host.tag);\n        if (widget.provider != null) {\n            out.attributeIntHex(null, \"p\", widget.provider.tag);\n        }\n        if (widget.options != null) {\n            int minWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH);\n            int minHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);\n            int maxWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH);\n            int maxHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT);\n            out.attributeIntHex(null, \"min_width\", (minWidth > 0) ? minWidth : 0);\n            out.attributeIntHex(null, \"min_height\", (minHeight > 0) ? minHeight : 0);\n            out.attributeIntHex(null, \"max_width\", (maxWidth > 0) ? maxWidth : 0);\n            out.attributeIntHex(null, \"max_height\", (maxHeight > 0) ? maxHeight : 0);\n            out.attributeIntHex(null, \"host_category\", widget.options.getInt(\n                    AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY));\n            List<SizeF> sizes = widget.options.getParcelableArrayList(\n                    AppWidgetManager.OPTION_APPWIDGET_SIZES, SizeF.class);\n            if (sizes != null) {\n                out.attribute(null, KEY_SIZES, serializeWidgetSizes(sizes));\n            }\n            if (saveRestoreCompleted) {\n                boolean restoreCompleted = widget.options.getBoolean(\n                        AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED);\n                out.attributeBoolean(null, \"restore_completed\", restoreCompleted);\n            }\n        }\n        out.endTag(null, \"g\");\n    }\n\n    private static Bundle parseWidgetIdOptions(TypedXmlPullParser parser) {\n        Bundle options = new Bundle();\n        boolean restoreCompleted = parser.getAttributeBoolean(null, \"restore_completed\", false);\n        if (restoreCompleted) {\n            options.putBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED, true);\n        }\n        int minWidth = parser.getAttributeIntHex(null, \"min_width\", -1);\n        if (minWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, minWidth);\n        }\n        int minHeight = parser.getAttributeIntHex(null, \"min_height\", -1);\n        if (minHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, minHeight);\n        }\n        int maxWidth = parser.getAttributeIntHex(null, \"max_width\", -1);\n        if (maxWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, maxWidth);\n        }\n        int maxHeight = parser.getAttributeIntHex(null, \"max_height\", -1);\n        if (maxHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, maxHeight);\n        }\n        String sizesStr = parser.getAttributeValue(null, KEY_SIZES);\n        ArrayList<SizeF> sizes = deserializeWidgetSizesStr(sizesStr);\n        if (sizes != null) {\n            options.putParcelableArrayList(AppWidgetManager.OPTION_APPWIDGET_SIZES, sizes);\n        }\n        int category = parser.getAttributeIntHex(null, \"host_category\",\n                AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN);\n        if (category != AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY, category);\n        }\n        return options;\n    }\n\n    @Override\n    public List<String> getWidgetParticipants(int userId) {\n        return mBackupRestoreController.getWidgetParticipants(userId);\n    }\n\n    @Override\n    public byte[] getWidgetState(String packageName, int userId) {\n        return mBackupRestoreController.getWidgetState(packageName, userId);\n    }\n\n    @Override\n    public void systemRestoreStarting(int userId) {\n        mBackupRestoreController.systemRestoreStarting(userId);\n    }\n\n    @Override\n    public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n        mBackupRestoreController.restoreWidgetState(packageName, restoredState, userId);\n    }\n\n    @Override\n    public void systemRestoreFinished(int userId) {\n        mBackupRestoreController.systemRestoreFinished(userId);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private AppWidgetProviderInfo createPartialProviderInfo(ProviderId providerId, ResolveInfo ri,\n            Provider provider) {\n        boolean hasXmlDefinition = false;\n        Bundle metaData = ri.activityInfo.metaData;\n        if (metaData == null) {\n            return null;\n        }\n\n        if (provider != null && !TextUtils.isEmpty(provider.infoTag)) {\n            hasXmlDefinition = metaData.getInt(provider.infoTag) != 0;\n        }\n        hasXmlDefinition |= metaData.getInt(AppWidgetManager.META_DATA_APPWIDGET_PROVIDER) != 0;\n\n        if (hasXmlDefinition) {\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = ri.activityInfo;\n            if (DEBUG) {\n                Objects.requireNonNull(ri.activityInfo);\n            }\n            return info;\n        }\n        return null;\n    }\n\n    private static AppWidgetProviderInfo parseAppWidgetProviderInfo(Context context,\n            ProviderId providerId, ActivityInfo activityInfo, String metadataKey) {\n        final PackageManager pm = context.getPackageManager();\n        try (XmlResourceParser parser = activityInfo.loadXmlMetaData(pm, metadataKey)) {\n            if (parser == null) {\n                Slog.w(TAG, \"No \" + metadataKey + \" meta-data for AppWidget provider '\"\n                        + providerId + '\\'');\n                return null;\n            }\n\n            AttributeSet attrs = Xml.asAttributeSet(parser);\n\n            int type;\n            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                    && type != XmlPullParser.START_TAG) {\n                // drain whitespace, comments, etc.\n            }\n\n            String nodeName = parser.getName();\n            if (!\"appwidget-provider\".equals(nodeName)) {\n                Slog.w(TAG, \"Meta-data does not start with appwidget-provider tag for\"\n                        + \" AppWidget provider \" + providerId.componentName\n                        + \" for user \" + providerId.uid);\n                return null;\n            }\n\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = activityInfo;\n            if (DEBUG) {\n                Objects.requireNonNull(activityInfo);\n            }\n\n            final Resources resources;\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final int userId = UserHandle.getUserId(providerId.uid);\n                final ApplicationInfo app = pm.getApplicationInfoAsUser(activityInfo.packageName,\n                        0, userId);\n                resources = pm.getResourcesForApplication(app);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n\n            TypedArray sa = resources.obtainAttributes(attrs,\n                    com.android.internal.R.styleable.AppWidgetProviderInfo);\n\n            // These dimensions has to be resolved in the application's context.\n            // We simply send back the raw complex data, which will be\n            // converted to dp in {@link AppWidgetManager#getAppWidgetInfo}.\n            TypedValue value = sa\n                    .peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minWidth);\n            info.minWidth = value != null ? value.data : 0;\n            value = sa.peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minHeight);\n            info.minHeight = value != null ? value.data : 0;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeWidth);\n            info.minResizeWidth = value != null ? value.data : info.minWidth;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeHeight);\n            info.minResizeHeight = value != null ? value.data : info.minHeight;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeWidth);\n            info.maxResizeWidth = value != null ? value.data : 0;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeHeight);\n            info.maxResizeHeight = value != null ? value.data : 0;\n\n            info.targetCellWidth = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellWidth, 0);\n            info.targetCellHeight = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellHeight, 0);\n\n            info.updatePeriodMillis = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_updatePeriodMillis, 0);\n            info.initialLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_initialLayout, ID_NULL);\n            info.initialKeyguardLayout = sa.getResourceId(com.android.internal.R.styleable.\n                    AppWidgetProviderInfo_initialKeyguardLayout, ID_NULL);\n\n            String className = sa\n                    .getString(com.android.internal.R.styleable.AppWidgetProviderInfo_configure);\n            if (className != null) {\n                info.configure = new ComponentName(providerId.componentName.getPackageName(),\n                        className);\n            }\n            info.label = activityInfo.loadLabel(pm).toString();\n            info.icon = activityInfo.getIconResource();\n            info.previewImage = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewImage, ID_NULL);\n            info.previewLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewLayout, ID_NULL);\n            info.autoAdvanceViewId = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_autoAdvanceViewId,\n                    View.NO_ID);\n            info.resizeMode = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_resizeMode,\n                    AppWidgetProviderInfo.RESIZE_NONE);\n            info.widgetCategory = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetCategory,\n                    AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            info.widgetFeatures = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetFeatures, 0);\n            info.descriptionRes = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_description, ID_NULL);\n            sa.recycle();\n            return info;\n        } catch (IOException | PackageManager.NameNotFoundException | XmlPullParserException e) {\n            // Ok to catch Exception here, because anything going wrong because\n            // of what a client process passes to us should not be fatal for the\n            // system process.\n            Slog.w(TAG, \"XML parsing failed for AppWidget provider \"\n                    + providerId.componentName + \" for user \" + providerId.uid, e);\n            return null;\n        }\n    }\n\n    private int getUidForPackage(String packageName, int userId) {\n        PackageInfo pkgInfo = null;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            pkgInfo = mPackageManager.getPackageInfo(packageName, 0, userId);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local call\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n\n        if (pkgInfo == null || pkgInfo.applicationInfo == null) {\n            return -1;\n        }\n\n        return pkgInfo.applicationInfo.uid;\n    }\n\n    private ActivityInfo getProviderInfo(ComponentName componentName, int userId) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setComponent(componentName);\n\n        List<ResolveInfo> receivers = queryIntentReceivers(intent, userId);\n        // We are setting component, so there is only one or none.\n        if (!receivers.isEmpty()) {\n            return receivers.get(0).activityInfo;\n        }\n\n        return null;\n    }\n\n    private List<ResolveInfo> queryIntentReceivers(Intent intent, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            int flags = PackageManager.GET_META_DATA;\n\n            // We really need packages to be around and parsed to know if they\n            // provide widgets.\n            flags |= PackageManager.MATCH_DEBUG_TRIAGED_MISSING;\n\n            // Widget hosts that are non-crypto aware may be hosting widgets\n            // from a profile that is still locked, so let them see those\n            // widgets.\n            if (isProfileWithUnlockedParent(userId)) {\n                flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE\n                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE;\n            }\n\n            // Widgets referencing shared libraries need to have their\n            // dependencies loaded.\n            flags |= PackageManager.GET_SHARED_LIBRARY_FILES;\n\n            return mPackageManager.queryIntentReceivers(intent,\n                    intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                    flags, userId).getList();\n        } catch (RemoteException re) {\n            return Collections.emptyList();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * This does not use the usual onUserUnlocked() listener mechanism because it is\n     * invoked at a choreographed point in the middle of the user unlock sequence,\n     * before the boot-completed broadcast is issued and the listeners notified.\n     */\n    void handleUserUnlocked(int userId) {\n        if (isProfileWithLockedParent(userId)) {\n            return;\n        }\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            Slog.w(TAG, \"User \" + userId + \" is no longer unlocked - exiting\");\n            return;\n        }\n        long time = SystemClock.elapsedRealtime();\n        synchronized (mLock) {\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget ensure\");\n            ensureGroupStateLoadedLocked(userId);\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget reload\");\n            reloadWidgetsMaskedStateForGroup(mSecurityPolicy.getGroupParent(userId));\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n\n                // Send broadcast only to the providers of the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n\n                if (provider.widgets.size() > 0 && !provider.maskedByStoppedPackage) {\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,\n                            \"appwidget init \" + provider.id.componentName.getPackageName());\n                    provider.widgets.forEach(widget -> {\n                        widget.trackingUpdate = true;\n                        Trace.asyncTraceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,\n                                \"appwidget update-intent \" + provider.id.toString(),\n                                widget.appWidgetId);\n                        Log.i(TAG, \"Widget update scheduled on unlock \" + widget.toString());\n                    });\n                    int[] appWidgetIds = getWidgetIds(provider.widgets);\n                    sendEnableAndUpdateIntentLocked(provider, appWidgetIds);\n                    registerForBroadcastsLocked(provider, appWidgetIds);\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                }\n            }\n        }\n        Slog.i(TAG, \"Processing of handleUserUnlocked u\" + userId + \" took \"\n                + (SystemClock.elapsedRealtime() - time) + \" ms\");\n    }\n\n    // only call from initialization -- it assumes that the data structures are all empty\n    @GuardedBy(\"mLock\")\n    private void loadGroupStateLocked(int[] profileIds) {\n        // We can bind the widgets to host and providers only after\n        // reading the host and providers for all users since a widget\n        // can have a host and a provider in different users.\n        List<LoadedWidgetState> loadedWidgets = new ArrayList<>();\n\n        int version = 0;\n\n        final int profileIdCount = profileIds.length;\n        for (int i = 0; i < profileIdCount; i++) {\n            final int profileId = profileIds[i];\n\n            // No file written for this user - nothing to do.\n            AtomicFile file = getSavedStateFile(profileId);\n            try (FileInputStream stream = file.openRead()) {\n                version = readProfileStateFromFileLocked(stream, profileId, loadedWidgets);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to read state: \" + e);\n            }\n        }\n\n        if (version >= 0) {\n            // Hooke'm up...\n            bindLoadedWidgetsLocked(loadedWidgets);\n\n            // upgrade the database if needed\n            performUpgradeLocked(version);\n        } else {\n            // failed reading, clean up\n            Slog.w(TAG, \"Failed to read state, clearing widgets and hosts.\");\n            clearWidgetsLocked();\n            mHosts.clear();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                mProviders.get(i).widgets.clear();\n            }\n        }\n    }\n\n    private void bindLoadedWidgetsLocked(List<LoadedWidgetState> loadedWidgets) {\n        final int loadedWidgetCount = loadedWidgets.size();\n        for (int i = loadedWidgetCount - 1; i >= 0; i--) {\n            LoadedWidgetState loadedWidget = loadedWidgets.remove(i);\n            Widget widget = loadedWidget.widget;\n\n            widget.provider = findProviderByTag(loadedWidget.providerTag);\n            if (widget.provider == null) {\n                // This provider is gone. We just let the host figure out\n                // that this happened when it fails to load it.\n                continue;\n            }\n\n            widget.host = findHostByTag(loadedWidget.hostTag);\n            if (widget.host == null) {\n                // This host is gone.\n                continue;\n            }\n\n            widget.provider.widgets.add(widget);\n            widget.host.widgets.add(widget);\n            addWidgetLocked(widget);\n        }\n    }\n\n    private Provider findProviderByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.tag == tag) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host findHostByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            if (host.tag == tag) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n     */\n    void addWidgetLocked(Widget widget) {\n        if (DEBUG) {\n            Slog.i(TAG, \"addWidgetLocked() \" + widget);\n        }\n        ensureWidgetCountBeforeAddLocked(widget);\n        mWidgets.add(widget);\n\n        onWidgetProviderAddedOrChangedLocked(widget);\n    }\n\n    /**\n     * Ensures that the widget count for the widget's host is not greater than the maximum\n     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n     * from the host until the count is less than or equal to the maximum.\n     */\n    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n        if (widget.host == null || widget.host.id == null) {\n            return;\n        }\n        final List<Widget> widgetsInSameHost = new ArrayList<>();\n        for (Widget w : mWidgets) {\n            if (w.host != null && widget.host.id.equals(w.host.id)) {\n                widgetsInSameHost.add(w);\n            }\n        }\n        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n            removeWidgetLocked(widgetsInSameHost.remove(0));\n        }\n    }\n\n    /**\n     * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n     * that have bound widgets.\n     */\n    void onWidgetProviderAddedOrChangedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        int userId = widget.provider.getUserId();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                mWidgetPackages.put(userId, packages = new ArraySet<String>());\n            }\n            packages.add(widget.provider.id.componentName.getPackageName());\n        }\n\n        // If we are adding a widget it might be for a provider that\n        // is currently masked, if so mask the widget.\n        if (widget.provider.isMaskedLocked()) {\n            maskWidgetsViewsLocked(widget.provider, widget);\n        } else {\n            widget.clearMaskedViewsLocked();\n        }\n    }\n\n    /**\n     * Removes a widget from mWidgets and updates the cache of bound widget provider packages.\n     * If there are other widgets with the same package, leaves it in the cache, otherwise it\n     * removes the associated package from the cache.\n     */\n    void removeWidgetLocked(Widget widget) {\n        if (DEBUG) {\n            Slog.i(TAG, \"removeWidgetLocked() \" + widget);\n        }\n        mWidgets.remove(widget);\n        onWidgetRemovedLocked(widget);\n        scheduleNotifyAppWidgetRemovedLocked(widget);\n    }\n\n    private void onWidgetRemovedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        final int userId = widget.provider.getUserId();\n        final String packageName = widget.provider.id.componentName.getPackageName();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                return;\n            }\n            // Check if there is any other widget with the same package name.\n            // Remove packageName if none.\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget w = mWidgets.get(i);\n                if (w.provider == null) continue;\n                if (w.provider.getUserId() == userId\n                        && packageName.equals(w.provider.id.componentName.getPackageName())) {\n                    return;\n                }\n            }\n            packages.remove(packageName);\n        }\n    }\n\n    /**\n     * Clears all widgets and associated cache of packages with bound widgets.\n     */\n    void clearWidgetsLocked() {\n        if (DEBUG) {\n            Slog.i(TAG, \"clearWidgetsLocked()\");\n        }\n        mWidgets.clear();\n\n        onWidgetsClearedLocked();\n    }\n\n    private void onWidgetsClearedLocked() {\n        synchronized (mWidgetPackagesLock) {\n            mWidgetPackages.clear();\n        }\n    }\n\n    @Override\n    public boolean isBoundWidgetPackage(String packageName, int userId) {\n        if (Binder.getCallingUid() != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Only the system process can call this\");\n        }\n        synchronized (mWidgetPackagesLock) {\n            final ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages != null) {\n                return packages.contains(packageName);\n            }\n        }\n        return false;\n    }\n\n    @GuardedBy(\"mLock\")\n    private @NonNull SparseArray<byte[]> saveStateToByteArrayLocked(int userId) {\n        tagProvidersAndHosts();\n\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n        SparseArray<byte[]> userIdToBytesMapping = new SparseArray<>();\n\n        for (int profileId : profileIds) {\n            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n            if (writeProfileStateToStreamLocked(outputStream, profileId)) {\n                userIdToBytesMapping.put(profileId, outputStream.toByteArray());\n            }\n        }\n\n        return userIdToBytesMapping;\n    }\n\n    @GuardedBy(\"mLock\")\n    private void saveStateLocked(int userId) {\n        tagProvidersAndHosts();\n\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            AtomicFile file = getSavedStateFile(profileId);\n            FileOutputStream stream;\n            try {\n                stream = file.startWrite();\n                if (writeProfileStateToStreamLocked(stream, profileId)) {\n                    file.finishWrite(stream);\n                } else {\n                    file.failWrite(stream);\n                    Slog.w(TAG, \"Failed to save state, restoring backup.\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed open state file for write: \" + e);\n            }\n        }\n    }\n\n    private void tagProvidersAndHosts() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = i;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = i;\n        }\n    }\n\n    private void clearProvidersAndHostsTagsLocked() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = TAG_UNDEFINED;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = TAG_UNDEFINED;\n        }\n    }\n\n    @GuardedBy(\"mLock\")\n    private boolean writeProfileStateToStreamLocked(OutputStream stream, int userId) {\n        int N;\n\n        try {\n            TypedXmlSerializer out = Xml.resolveSerializer(stream);\n            out.startDocument(null, true);\n            out.startTag(null, \"gs\");\n            out.attributeInt(null, \"version\", CURRENT_VERSION);\n\n            N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                // Save only providers for the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n                serializeProvider(out, provider, true /* persistsProviderInfo */);\n            }\n\n            N = mHosts.size();\n            for (int i = 0; i < N; i++) {\n                Host host = mHosts.get(i);\n                // Save only hosts for the user.\n                if (host.getUserId() != userId) {\n                    continue;\n                }\n                serializeHost(out, host);\n            }\n\n            N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                // Save only widgets hosted by the user.\n                if (widget.host.getUserId() != userId) {\n                    continue;\n                }\n                serializeAppWidget(out, widget, true);\n            }\n\n            Iterator<Pair<Integer, String>> it = mPackagesWithBindWidgetPermission.iterator();\n            while (it.hasNext()) {\n                Pair<Integer, String> binding = it.next();\n                // Save only white listings for the user.\n                if (binding.first != userId) {\n                    continue;\n                }\n                out.startTag(null, \"b\");\n                out.attribute(null, \"packageName\", binding.second);\n                out.endTag(null, \"b\");\n            }\n\n            out.endTag(null, \"gs\");\n\n            if (supportResumeRestoreAfterReboot()\n                    && mBackupRestoreController.requiresPersistenceLocked()) {\n                AppWidgetXmlUtil.writeBackupRestoreControllerState(\n                        out, mBackupRestoreController.getStateLocked(userId));\n            }\n\n            out.endDocument();\n            return true;\n        } catch (IOException e) {\n            Slog.w(TAG, \"Failed to write state: \" + e);\n            return false;\n        }\n    }\n\n    @GuardedBy(\"mLock\")\n    private int readProfileStateFromFileLocked(FileInputStream stream, int userId,\n            List<LoadedWidgetState> outLoadedWidgets) {\n        int version = -1;\n        try {\n            TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n\n            int legacyProviderIndex = -1;\n            int legacyHostIndex = -1;\n            int type;\n            do {\n                type = parser.next();\n                if (type == XmlPullParser.START_TAG) {\n                    String tag = parser.getName();\n                    if (\"gs\".equals(tag)) {\n                        version = parser.getAttributeInt(null, \"version\", 0);\n                    } else if (\"p\".equals(tag)) {\n                        legacyProviderIndex++;\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n                        String cl = parser.getAttributeValue(null, \"cl\");\n\n                        pkg = getCanonicalPackageName(pkg, cl, userId);\n                        if (pkg == null) {\n                            continue;\n                        }\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            continue;\n                        }\n\n                        ComponentName componentName = new ComponentName(pkg, cl);\n\n                        ActivityInfo providerInfo = getProviderInfo(componentName, userId);\n                        if (providerInfo == null) {\n                            continue;\n                        }\n\n                        ProviderId providerId = new ProviderId(uid, componentName);\n                        Provider provider = lookupProviderLocked(providerId);\n\n                        if (provider == null && mSafeMode) {\n                            // if we're in safe mode, make a temporary one\n                            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                            info.provider = providerId.componentName;\n                            info.providerInfo = providerInfo;\n                            if (DEBUG) {\n                                Objects.requireNonNull(providerInfo);\n                            }\n\n                            provider = new Provider();\n                            provider.setPartialInfoLocked(info);\n                            provider.zombie = true;\n                            provider.id = providerId;\n                            mProviders.add(provider);\n                        } else {\n                            final AppWidgetProviderInfo info =\n                                    AppWidgetXmlUtil.readAppWidgetProviderInfoLocked(parser);\n                            if (DEBUG && info == null) {\n                                Slog.d(TAG, \"Unable to load widget provider info from xml for \"\n                                        + providerId.componentName);\n                            }\n                            if (info != null) {\n                                info.provider = providerId.componentName;\n                                info.providerInfo = providerInfo;\n                                if (DEBUG) {\n                                    Objects.requireNonNull(providerInfo);\n                                }\n                                provider.setInfoLocked(info);\n                            }\n                        }\n\n                        final int providerTag = parser.getAttributeIntHex(null, \"tag\",\n                                legacyProviderIndex);\n                        provider.tag = providerTag;\n                        provider.infoTag = parser.getAttributeValue(null, \"info_tag\");\n\n                        final String pendingDeletedIds = parser.getAttributeValue(null,\n                                PENDING_DELETED_IDS_ATTR);\n                        if (pendingDeletedIds != null && !pendingDeletedIds.isEmpty()) {\n                            final String[] idStrings = pendingDeletedIds.split(\",\");\n                            for (int i = 0; i < idStrings.length; i++) {\n                                provider.pendingDeletedWidgetIds.add(\n                                        Integer.parseInt(idStrings[i]));\n                            }\n                        }\n                    } else if (\"h\".equals(tag)) {\n                        legacyHostIndex++;\n                        Host host = new Host();\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            host.zombie = true;\n                        }\n\n                        if (!host.zombie || mSafeMode) {\n                            // In safe mode, we don't discard the hosts we don't recognize\n                            // so that they're not pruned from our list. Otherwise, we do.\n                            final int hostId = parser.getAttributeIntHex(null, \"id\");\n                            final int hostTag = parser.getAttributeIntHex(null, \"tag\",\n                                    legacyHostIndex);\n\n                            host.tag = hostTag;\n                            host.id = new HostId(uid, hostId, pkg);\n                            mHosts.add(host);\n                        }\n                    } else if (\"b\".equals(tag)) {\n                        String packageName = parser.getAttributeValue(null, \"packageName\");\n                        final int uid = getUidForPackage(packageName, userId);\n                        if (uid >= 0) {\n                            Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                            mPackagesWithBindWidgetPermission.add(packageId);\n                        }\n                    } else if (\"g\".equals(tag)) {\n                        Widget widget = new Widget();\n                        widget.appWidgetId = parser.getAttributeIntHex(null, \"id\");\n                        setMinAppWidgetIdLocked(userId, widget.appWidgetId + 1);\n\n                        // restored ID is allowed to be absent\n                        widget.restoredId = parser.getAttributeIntHex(null, \"rid\", 0);\n                        widget.options = parseWidgetIdOptions(parser);\n\n                        final int hostTag = parser.getAttributeIntHex(null, \"h\");\n                        String providerString = parser.getAttributeValue(null, \"p\");\n                        final int providerTag = (providerString != null)\n                                ? parser.getAttributeIntHex(null, \"p\") : TAG_UNDEFINED;\n\n                        // We can match widgets with hosts and providers only after hosts\n                        // and providers for all users have been loaded since the widget\n                        // host and provider can be in different user profiles.\n                        LoadedWidgetState loadedWidgets = new LoadedWidgetState(widget,\n                                hostTag, providerTag);\n                        outLoadedWidgets.add(loadedWidgets);\n                    } else if (supportResumeRestoreAfterReboot()\n                            && AppWidgetXmlUtil.TAG_BACKUP_RESTORE_CONTROLLER_STATE.equals(tag)) {\n                        final BackupRestoreController.State s =\n                                AppWidgetXmlUtil.readBackupRestoreControllerState(parser);\n                        if (s == null) {\n                            continue;\n                        }\n                        final Set<String> prunedAppsInFile = s.getPrunedApps();\n                        if (prunedAppsInFile != null) {\n                            final Set<String> prunedAppsInMemory = mBackupRestoreController\n                                    .mPrunedAppsPerUser.get(userId);\n                            if (prunedAppsInMemory == null) {\n                                mBackupRestoreController.mPrunedAppsPerUser.put(\n                                        userId, prunedAppsInFile);\n                            } else {\n                                prunedAppsInMemory.addAll(prunedAppsInFile);\n                            }\n                        }\n                        loadUpdateRecords(s.getUpdatesByProvider(),\n                                this::findProviderByTag,\n                                mBackupRestoreController.mUpdatesByProvider::get,\n                                mBackupRestoreController.mUpdatesByProvider::put);\n                        loadUpdateRecords(s.getUpdatesByHost(),\n                                this::findHostByTag,\n                                mBackupRestoreController.mUpdatesByHost::get,\n                                mBackupRestoreController.mUpdatesByHost::put);\n                    }\n                }\n            } while (type != XmlPullParser.END_DOCUMENT);\n        } catch (NullPointerException\n                | NumberFormatException\n                | XmlPullParserException\n                | IOException\n                | IndexOutOfBoundsException e) {\n            Slog.w(TAG, \"failed parsing \" + e);\n            return -1;\n        }\n\n        return version;\n    }\n\n    private <T> void loadUpdateRecords(\n            @Nullable final SparseArray<\n                    List<BackupRestoreController.RestoreUpdateRecord>> updatesOnFile,\n            @NonNull final Function<Integer, T> findKeyByTagCb,\n            @NonNull final Function<T, List<\n                    BackupRestoreController.RestoreUpdateRecord>> findRecordsCb,\n            @NonNull final BiConsumer<T, List<\n                    BackupRestoreController.RestoreUpdateRecord>> newRecordsCb) {\n        if (updatesOnFile == null) {\n            return;\n        }\n        for (int i = 0; i < updatesOnFile.size(); i++) {\n            final int tag = updatesOnFile.keyAt(i);\n            final List<\n                    BackupRestoreController.RestoreUpdateRecord\n                    > recordsOnFile = updatesOnFile.get(tag);\n            if (recordsOnFile == null || recordsOnFile.isEmpty()) {\n                continue;\n            }\n            final T key = findKeyByTagCb.apply(tag);\n            final List<BackupRestoreController.RestoreUpdateRecord> recordsInMemory =\n                    findRecordsCb.apply(key);\n            if (recordsInMemory != null) {\n                recordsInMemory.addAll(recordsOnFile);\n            } else  {\n                newRecordsCb.accept(key, recordsOnFile);\n            }\n        }\n    }\n\n    private void performUpgradeLocked(int fromVersion) {\n        if (fromVersion < CURRENT_VERSION) {\n            Slog.v(TAG, \"Upgrading widget database from \" + fromVersion + \" to \"\n                    + CURRENT_VERSION);\n        }\n\n        int version = fromVersion;\n\n        // Update 1: keyguard moved from package \"android\" to \"com.android.keyguard\"\n        if (version == 0) {\n            HostId oldHostId = new HostId(Process.myUid(),\n                    KEYGUARD_HOST_ID, OLD_KEYGUARD_HOST_PACKAGE);\n\n            Host host = lookupHostLocked(oldHostId);\n            if (host != null) {\n                final int uid = getUidForPackage(NEW_KEYGUARD_HOST_PACKAGE,\n                        UserHandle.USER_SYSTEM);\n                if (uid >= 0) {\n                    host.id = new HostId(uid, KEYGUARD_HOST_ID, NEW_KEYGUARD_HOST_PACKAGE);\n                }\n            }\n\n            version = 1;\n        }\n\n        if (version != CURRENT_VERSION) {\n            throw new IllegalStateException(\"Failed to upgrade widget database\");\n        }\n    }\n\n    private static File getStateFile(int userId) {\n        return new File(Environment.getUserSystemDirectory(userId), STATE_FILENAME);\n    }\n\n    private static AtomicFile getSavedStateFile(int userId) {\n        File dir = Environment.getUserSystemDirectory(userId);\n        File settingsFile = getStateFile(userId);\n        if (!settingsFile.exists() && userId == UserHandle.USER_SYSTEM) {\n            if (!dir.exists()) {\n                dir.mkdirs();\n            }\n            // Migrate old data\n            File oldFile = new File(\"/data/system/\" + STATE_FILENAME);\n            // Method doesn't throw an exception on failure. Ignore any errors\n            // in moving the file (like non-existence)\n            oldFile.renameTo(settingsFile);\n        }\n        return new AtomicFile(settingsFile);\n    }\n\n    void onUserStopped(int userId) {\n        if (DEBUG) {\n            Slog.i(TAG, \"onUserStopped() \" + userId);\n        }\n        synchronized (mLock) {\n            boolean crossProfileWidgetsChanged = false;\n\n            // Remove widgets that have both host and provider in the user.\n            final int widgetCount = mWidgets.size();\n            for (int i = widgetCount - 1; i >= 0; i--) {\n                Widget widget = mWidgets.get(i);\n\n                final boolean hostInUser = widget.host.getUserId() == userId;\n                final boolean hasProvider = widget.provider != null;\n                final boolean providerInUser = hasProvider && widget.provider.getUserId() == userId;\n\n                // If both host and provider are in the user, just drop the widgets\n                // as we do not want to make host callbacks and provider broadcasts\n                // as the host and the provider will be killed.\n                if (hostInUser && (!hasProvider || providerInUser)) {\n                    removeWidgetLocked(widget);\n                    widget.host.widgets.remove(widget);\n                    widget.host = null;\n                    if (hasProvider) {\n                        widget.provider.widgets.remove(widget);\n                        widget.provider = null;\n                    }\n                }\n            }\n\n            // Remove hosts and notify providers in other profiles.\n            final int hostCount = mHosts.size();\n            for (int i = hostCount - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n                if (host.getUserId() == userId) {\n                    crossProfileWidgetsChanged |= !host.widgets.isEmpty();\n                    deleteHostLocked(host);\n                }\n            }\n\n            // Leave the providers present as hosts will show the widgets\n            // masked while the user is stopped.\n\n            // Remove grants for this user.\n            final int grantCount = mPackagesWithBindWidgetPermission.size();\n            for (int i = grantCount - 1; i >= 0; i--) {\n                Pair<Integer, String> packageId = mPackagesWithBindWidgetPermission.valueAt(i);\n                if (packageId.first == userId) {\n                    mPackagesWithBindWidgetPermission.removeAt(i);\n                }\n            }\n\n            // Take a note we no longer have state for this user.\n            final int userIndex = mLoadedUserIds.indexOfKey(userId);\n            if (userIndex >= 0) {\n                mLoadedUserIds.removeAt(userIndex);\n            }\n\n            // Remove the widget id counter.\n            final int nextIdIndex = mNextAppWidgetIds.indexOfKey(userId);\n            if (nextIdIndex >= 0) {\n                mNextAppWidgetIds.removeAt(nextIdIndex);\n            }\n\n            // Save state if removing a profile changed the group state.\n            // Nothing will be saved if the group parent was removed.\n            if (crossProfileWidgetsChanged) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    private void applyResourceOverlaysToWidgetsLocked(Set<String> packageNames, int userId,\n            boolean updateFrameworkRes) {\n        for (int i = 0, N = mProviders.size(); i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.getUserId() != userId) {\n                continue;\n            }\n\n            final String packageName = provider.id.componentName.getPackageName();\n            if (!updateFrameworkRes && !packageNames.contains(packageName)) {\n                continue;\n            }\n\n            ApplicationInfo newAppInfo = null;\n            try {\n                newAppInfo = mPackageManager.getApplicationInfo(packageName,\n                        PackageManager.GET_SHARED_LIBRARY_FILES, userId);\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"Failed to retrieve app info for \" + packageName\n                        + \" userId=\" + userId, e);\n            }\n            if (newAppInfo == null || provider.info == null\n                    || provider.info.providerInfo == null) {\n                continue;\n            }\n            ApplicationInfo oldAppInfo = provider.info.providerInfo.applicationInfo;\n            if (oldAppInfo == null || !newAppInfo.sourceDir.equals(oldAppInfo.sourceDir)) {\n                // Overlay paths are generated against a particular version of an application.\n                // The overlays paths of a newly upgraded application are incompatible with the\n                // old version of the application.\n                continue;\n            }\n\n            // Isolate the changes relating to RROs. The app info must be copied to prevent\n            // affecting other parts of system server that may have cached this app info.\n            oldAppInfo = new ApplicationInfo(oldAppInfo);\n            oldAppInfo.overlayPaths = newAppInfo.overlayPaths == null\n                    ? null : newAppInfo.overlayPaths.clone();\n            oldAppInfo.resourceDirs = newAppInfo.resourceDirs == null\n                    ? null : newAppInfo.resourceDirs.clone();\n            provider.info.providerInfo.applicationInfo = oldAppInfo;\n\n            for (int j = 0, M = provider.widgets.size(); j < M; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (widget.views != null) {\n                    widget.views.updateAppInfo(oldAppInfo);\n                }\n                if (widget.maskedViews != null) {\n                    widget.maskedViews.updateAppInfo(oldAppInfo);\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates all providers with the specified package names, and records any providers that were\n     * pruned.\n     *\n     * @return whether any providers were updated\n     */\n    @GuardedBy(\"mLock\")\n    private boolean updateProvidersForPackageLocked(String packageName, int userId,\n            Set<ProviderId> removedProviders) {\n        boolean providersUpdated = false;\n\n        HashSet<ProviderId> keep = new HashSet<>();\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setPackage(packageName);\n        List<ResolveInfo> broadcastReceivers = queryIntentReceivers(intent, userId);\n\n        // add the missing ones and collect which ones to keep\n        int N = broadcastReceivers == null ? 0 : broadcastReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo ri = broadcastReceivers.get(i);\n            ActivityInfo ai = ri.activityInfo;\n\n            if ((ai.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n                continue;\n            }\n\n            if (packageName.equals(ai.packageName)) {\n                ProviderId providerId = new ProviderId(ai.applicationInfo.uid,\n                        new ComponentName(ai.packageName, ai.name));\n\n                Provider provider = lookupProviderLocked(providerId);\n                if (provider == null) {\n                    if (addProviderLocked(ri)) {\n                        keep.add(providerId);\n                        providersUpdated = true;\n                    }\n                } else {\n                    AppWidgetProviderInfo info =\n                            createPartialProviderInfo(providerId, ri, provider);\n                    if (info != null) {\n                        keep.add(providerId);\n                        // Use the new AppWidgetProviderInfo.\n                        provider.setPartialInfoLocked(info);\n                        // If it's enabled\n                        final int M = provider.widgets.size();\n                        if (M > 0) {\n                            int[] appWidgetIds = getWidgetIds(provider.widgets);\n                            // Reschedule for the new updatePeriodMillis (don't worry about handling\n                            // it specially if updatePeriodMillis didn't change because we just sent\n                            // an update, and the next one will be updatePeriodMillis from now).\n                            cancelBroadcastsLocked(provider);\n                            registerForBroadcastsLocked(provider, appWidgetIds);\n                            // If it's currently showing, call back with the new\n                            // AppWidgetProviderInfo.\n                            for (int j = 0; j < M; j++) {\n                                Widget widget = provider.widgets.get(j);\n                                widget.views = null;\n                                scheduleNotifyProviderChangedLocked(widget);\n                            }\n                            // Now that we've told the host, push out an update.\n                            sendUpdateIntentLocked(provider, appWidgetIds, false);\n                        }\n                    }\n                    providersUpdated = true;\n                }\n            }\n        }\n\n        // prune the ones we don't want to keep\n        N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (packageName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && !keep.contains(provider.id)) {\n                if (removedProviders != null) {\n                    removedProviders.add(provider.id);\n                }\n                deleteProviderLocked(provider);\n                providersUpdated = true;\n            }\n        }\n\n        return providersUpdated;\n    }\n\n    // Remove widgets for provider in userId that are hosted in parentUserId\n    private void removeWidgetsForPackageLocked(String pkgName, int userId, int parentUserId) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; ++i) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && provider.widgets.size() > 0) {\n                deleteWidgetsLocked(provider, parentUserId);\n            }\n        }\n    }\n\n    private boolean removeProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = false;\n\n        final int N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId) {\n                deleteProviderLocked(provider);\n                removed = true;\n            }\n        }\n        return removed;\n    }\n\n    private boolean removeHostsAndProvidersForPackageLocked(String pkgName, int userId) {\n        if (DEBUG) {\n            Slog.i(TAG, \"removeHostsAndProvidersForPackageLocked() pkg=\" + pkgName\n                    + \" userId=\" + userId);\n        }\n        boolean removed = removeProvidersForPackageLocked(pkgName, userId);\n\n        // Delete the hosts for this package too\n        // By now, we have removed any AppWidgets that were in any hosts here,\n        // so we don't need to worry about sending DISABLE broadcasts to them.\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n            if (pkgName.equals(host.id.packageName)\n                    && host.getUserId() == userId) {\n                deleteHostLocked(host);\n                removed = true;\n            }\n        }\n\n        return removed;\n    }\n\n    private String getCanonicalPackageName(String packageName, String className, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            try {\n                AppGlobals.getPackageManager().getReceiverInfo(new ComponentName(packageName,\n                        className), 0, userId);\n                return packageName;\n            } catch (RemoteException re) {\n                String[] packageNames = mContext.getPackageManager()\n                        .currentToCanonicalPackageNames(new String[]{packageName});\n                if (packageNames != null && packageNames.length > 0) {\n                    return packageNames[0];\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return null;\n    }\n\n    /**\n     * Sends a widget lifecycle broadcast within the specified user.  If {@code isInteractive}\n     * is specified as {@code true}, the broadcast dispatch mechanism will be told that it\n     * is related to a UX flow with user-visible expectations about timely dispatch.  This\n     * should only be used for broadcast flows that do have such expectations.\n     */\n    private void sendBroadcastAsUser(Intent intent, UserHandle userHandle, boolean isInteractive) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            mContext.sendBroadcastAsUser(intent, userHandle, null,\n                    isInteractive ? mInteractiveBroadcast : null);\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void bindService(Intent intent, ServiceConnection connection,\n            UserHandle userHandle) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, connection,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void unbindService(ServiceConnection connection) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.unbindService(connection);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Callback functions that add/update/remove widget providers in respect to\n     * changes in a specific child profile (e.g. deleting a work profile)\n     * depicted by DevicePolicyManager.\n     */\n    @Override\n    public void onCrossProfileWidgetProvidersChanged(int userId, List<String> packages) {\n        final int parentId = mSecurityPolicy.getProfileParent(userId);\n        // We care only if the allowlisted package is in a profile of\n        // the group parent as only the parent can add widgets from the\n        // profile and not the other way around.\n        if (parentId != userId) {\n            synchronized (mLock) {\n                boolean providersChanged = false;\n\n                ArraySet<String> previousPackages = new ArraySet<String>();\n                final int providerCount = mProviders.size();\n                for (int i = 0; i < providerCount; ++i) {\n                    Provider provider = mProviders.get(i);\n                    if (provider.getUserId() == userId) {\n                        previousPackages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n\n                final int packageCount = packages.size();\n                for (int i = 0; i < packageCount; i++) {\n                    String packageName = packages.get(i);\n                    previousPackages.remove(packageName);\n                    providersChanged |= updateProvidersForPackageLocked(packageName,\n                            userId, null);\n                }\n\n                // Remove widgets from hosts in parent user for packages not in the allowlist\n                final int removedCount = previousPackages.size();\n                for (int i = 0; i < removedCount; ++i) {\n                    removeWidgetsForPackageLocked(previousPackages.valueAt(i),\n                            userId, parentId);\n                }\n\n                if (providersChanged || removedCount > 0) {\n                    saveGroupStateAsync(userId);\n                    scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                }\n            }\n        }\n    }\n\n    private boolean isProfileWithLockedParent(int userId) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            UserInfo userInfo = mUserManager.getUserInfo(userId);\n            if (userInfo != null && userInfo.isProfile()) {\n                UserInfo parentInfo = mUserManager.getProfileParent(userId);\n                if (parentInfo != null\n                        && !isUserRunningAndUnlocked(parentInfo.getUserHandle().getIdentifier())) {\n                    return true;\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return false;\n    }\n\n    private boolean isProfileWithUnlockedParent(int userId) {\n        UserInfo userInfo = mUserManager.getUserInfo(userId);\n        if (userInfo != null && userInfo.isProfile()) {\n            UserInfo parentInfo = mUserManager.getProfileParent(userId);\n            if (parentInfo != null\n                    && mUserManager.isUserUnlockingOrUnlocked(parentInfo.getUserHandle())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Note an app widget is tapped on. If a app widget is tapped, the underlying app is treated as\n     * foreground so the app can get while-in-use permission.\n     *\n     * @param callingPackage calling app's packageName.\n     * @param appWidgetId App widget id.\n     */\n    @Override\n    public void noteAppWidgetTapped(String callingPackage, int appWidgetId) {\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        final int callingUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            // The launcher must be at TOP.\n            final int procState = mActivityManagerInternal.getUidProcessState(callingUid);\n            if (procState > ActivityManager.PROCESS_STATE_TOP) {\n                return;\n            }\n            synchronized (mLock) {\n                final Widget widget = lookupWidgetLocked(appWidgetId, callingUid, callingPackage);\n                if (widget == null) {\n                    return;\n                }\n                final ProviderId providerId = widget.provider.id;\n                final String packageName = providerId.componentName.getPackageName();\n                if (packageName == null) {\n                    return;\n                }\n                final SparseArray<String> uid2PackageName = new SparseArray<String>();\n                uid2PackageName.put(providerId.uid, packageName);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(uid2PackageName, true);\n                reportWidgetInteractionEvent(packageName, UserHandle.getUserId(providerId.uid),\n                        \"tap\");\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private void reportWidgetInteractionEvent(@NonNull String packageName, @UserIdInt int userId,\n            @NonNull String action) {\n        if (Flags.userInteractionTypeApi()) {\n            PersistableBundle extras = new PersistableBundle();\n            extras.putString(UsageStatsManager.EXTRA_EVENT_CATEGORY, \"android.appwidget\");\n            extras.putString(UsageStatsManager.EXTRA_EVENT_ACTION, action);\n            mUsageStatsManagerInternal.reportUserInteractionEvent(packageName, userId, extras);\n        } else {\n            mUsageStatsManagerInternal.reportEvent(packageName, userId,\n                    UsageEvents.Event.USER_INTERACTION);\n        }\n    }\n\n    @Override\n    @Nullable\n    public RemoteViews getWidgetPreview(@NonNull String callingPackage,\n            @NonNull ComponentName providerComponent, int profileId,\n            @AppWidgetProviderInfo.CategoryFlags int widgetCategory) {\n        final int callingUserId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"getWidgetPreview() \" + callingUserId);\n        }\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        ensureWidgetCategoryCombinationIsValid(widgetCategory);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(profileId);\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                final ComponentName componentName = provider.id.componentName;\n                if (provider.zombie || !providerComponent.equals(componentName)) {\n                    continue;\n                }\n\n                final AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n                final int providerProfileId = info.getProfile().getIdentifier();\n                if (providerProfileId != profileId) {\n                    continue;\n                }\n\n                // Allow access to this provider if it is from the calling package or the caller has\n                // BIND_APPWIDGET permission.\n                final int callingUid = Binder.getCallingUid();\n                final String providerPackageName = componentName.getPackageName();\n                final boolean providerIsInCallerProfile =\n                        mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                                providerPackageName, providerProfileId);\n                final boolean shouldFilterAppAccess = mPackageManagerInternal.filterAppAccess(\n                        providerPackageName, callingUid, providerProfileId);\n                final boolean providerIsInCallerPackage =\n                        mSecurityPolicy.isProviderInPackageForUid(provider, callingUid,\n                                callingPackage);\n                final boolean hasBindAppWidgetPermission =\n                        mSecurityPolicy.hasCallerBindPermissionOrBindWhiteListedLocked(\n                                callingPackage);\n                if (providerIsInCallerProfile && !shouldFilterAppAccess\n                        && (providerIsInCallerPackage || hasBindAppWidgetPermission)) {\n                    return provider.getGeneratedPreviewLocked(widgetCategory);\n                }\n            }\n        }\n        // Either the provider does not exist or the caller does not have permission to access its\n        // previews.\n        return null;\n    }\n\n    @Override\n    public boolean setWidgetPreview(@NonNull ComponentName providerComponent,\n            @AppWidgetProviderInfo.CategoryFlags int widgetCategories,\n            @NonNull RemoteViews preview) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"setWidgetPreview() \" + userId);\n        }\n\n        // Make sure callers only set previews for their own package.\n        mSecurityPolicy.enforceCallFromPackage(providerComponent.getPackageName());\n\n        ensureWidgetCategoryCombinationIsValid(widgetCategories);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final ProviderId providerId = new ProviderId(Binder.getCallingUid(), providerComponent);\n            final Provider provider = lookupProviderLocked(providerId);\n            if (provider == null) {\n                throw new IllegalArgumentException(\n                        providerComponent + \" is not a valid AppWidget provider\");\n            }\n            if (mGeneratedPreviewsApiCounter.tryApiCall(providerId)) {\n                provider.setGeneratedPreviewLocked(widgetCategories, preview);\n                scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                return true;\n            }\n            return false;\n        }\n    }\n\n    @Override\n    public void removeWidgetPreview(@NonNull ComponentName providerComponent,\n            @AppWidgetProviderInfo.CategoryFlags int widgetCategories) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"removeWidgetPreview() \" + userId);\n        }\n\n        // Make sure callers only remove previews for their own package.\n        mSecurityPolicy.enforceCallFromPackage(providerComponent.getPackageName());\n\n        ensureWidgetCategoryCombinationIsValid(widgetCategories);\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final ProviderId providerId = new ProviderId(Binder.getCallingUid(), providerComponent);\n            final Provider provider = lookupProviderLocked(providerId);\n            if (provider == null) {\n                throw new IllegalArgumentException(\n                        providerComponent + \" is not a valid AppWidget provider\");\n            }\n            final boolean changed = provider.removeGeneratedPreviewLocked(widgetCategories);\n            if (changed) scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n        }\n    }\n\n    private static void ensureWidgetCategoryCombinationIsValid(int widgetCategories) {\n        int validCategories = AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN\n                | AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD\n                | AppWidgetProviderInfo.WIDGET_CATEGORY_SEARCHBOX;\n        int invalid = ~validCategories;\n        if ((widgetCategories & invalid) != 0) {\n            throw new IllegalArgumentException(widgetCategories\n                    + \" is not a valid widget category combination\");\n        }\n    }\n\n    private void handleSystemUiDeviceConfigChange(DeviceConfig.Properties properties) {\n        Set<String> changed = properties.getKeyset();\n        synchronized (mLock) {\n            if (changed.contains(\n                    SystemUiDeviceConfigFlags.GENERATED_PREVIEW_API_RESET_INTERVAL_MS)) {\n                long resetIntervalMs = properties.getLong(\n                        SystemUiDeviceConfigFlags.GENERATED_PREVIEW_API_RESET_INTERVAL_MS,\n                        /* defaultValue= */ mGeneratedPreviewsApiCounter.getResetIntervalMs());\n                mGeneratedPreviewsApiCounter.setResetIntervalMs(resetIntervalMs);\n            }\n            if (changed.contains(\n                    SystemUiDeviceConfigFlags.GENERATED_PREVIEW_API_MAX_CALLS_PER_INTERVAL)) {\n                int maxCallsPerInterval = properties.getInt(\n                        SystemUiDeviceConfigFlags.GENERATED_PREVIEW_API_MAX_CALLS_PER_INTERVAL,\n                        /* defaultValue= */ mGeneratedPreviewsApiCounter.getMaxCallsPerInterval());\n                mGeneratedPreviewsApiCounter.setMaxCallsPerInterval(maxCallsPerInterval);\n            }\n        }\n    }\n\n    private final class CallbackHandler extends Handler {\n        public static final int MSG_NOTIFY_UPDATE_APP_WIDGET = 1;\n        public static final int MSG_NOTIFY_PROVIDER_CHANGED = 2;\n        public static final int MSG_NOTIFY_PROVIDERS_CHANGED = 3;\n        public static final int MSG_NOTIFY_VIEW_DATA_CHANGED = 4;\n        public static final int MSG_NOTIFY_APP_WIDGET_REMOVED = 5;\n        public static final int MSG_NOTIFY_UPDATE_APP_WIDGET_DEFERRED = 6;\n\n        public CallbackHandler(Looper looper) {\n            super(looper, null, false);\n        }\n\n        @Override\n        public void handleMessage(Message message) {\n            switch (message.what) {\n                case MSG_NOTIFY_UPDATE_APP_WIDGET: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    RemoteViews views = (RemoteViews) args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyUpdateAppWidget(host, callbacks, appWidgetId, views, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDER_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    AppWidgetProviderInfo info = (AppWidgetProviderInfo)args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyProviderChanged(host, callbacks, appWidgetId, info, requestId);\n                } break;\n\n                case MSG_NOTIFY_APP_WIDGET_REMOVED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n                    handleNotifyAppWidgetRemoved(host, callbacks, appWidgetId, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDERS_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    args.recycle();\n\n                    handleNotifyProvidersChanged(host, callbacks);\n                } break;\n\n                case MSG_NOTIFY_VIEW_DATA_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    final int viewId = args.argi2;\n                    args.recycle();\n\n                    handleNotifyAppWidgetViewDataChanged(host, callbacks, appWidgetId, viewId,\n                            requestId);\n                } break;\n\n                case MSG_NOTIFY_UPDATE_APP_WIDGET_DEFERRED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyUpdateAppWidgetDeferred(host, callbacks, appWidgetId, requestId);\n                } break;\n            }\n        }\n    }\n\n    private final class SecurityPolicy {\n\n        public boolean isEnabledGroupProfile(int profileId) {\n            final int parentId = UserHandle.getCallingUserId();\n            return isParentOrProfile(parentId, profileId) && isProfileEnabled(profileId);\n        }\n\n        public int[] getEnabledGroupProfileIds(int userId) {\n            final int parentId = getGroupParent(userId);\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mUserManager.getEnabledProfileIds(parentId);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                ComponentName componentName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                ServiceInfo serviceInfo = mPackageManager.getServiceInfo(componentName,\n                        PackageManager.GET_PERMISSIONS, userId);\n                if (serviceInfo == null) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" not installed for user \" + userId);\n                }\n                if (!android.Manifest.permission.BIND_REMOTEVIEWS.equals(serviceInfo.permission)) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" in user \" + userId + \"does not require \"\n                            + android.Manifest.permission.BIND_REMOTEVIEWS);\n                }\n            } catch (RemoteException re) {\n                // Local call - shouldn't happen.\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceModifyAppWidgetBindPermissions(String packageName) {\n            mContext.enforceCallingPermission(\n                    android.Manifest.permission.MODIFY_APPWIDGET_BIND_PERMISSIONS,\n                    \"hasBindAppWidgetPermission packageName=\" + packageName);\n        }\n\n        public boolean isCallerInstantAppLocked() {\n            final int callingUid =  Binder.getCallingUid();\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final String[] uidPackages = mPackageManager.getPackagesForUid(callingUid);\n                if (!ArrayUtils.isEmpty(uidPackages)) {\n                    return mPackageManager.isInstantApp(uidPackages[0],\n                            UserHandle.getUserId(callingUid));\n                }\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public boolean isInstantAppLocked(String packageName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mPackageManager.isInstantApp(packageName, userId);\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public void enforceCallFromPackage(String packageName) {\n            mAppOpsManager.checkPackage(Binder.getCallingUid(), packageName);\n        }\n\n        public boolean hasCallerBindPermissionOrBindWhiteListedLocked(String packageName) {\n            try {\n                mContext.enforceCallingOrSelfPermission(\n                        android.Manifest.permission.BIND_APPWIDGET, null);\n            } catch (SecurityException se) {\n                if (!isCallerBindAppWidgetAllowListedLocked(packageName)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean isCallerBindAppWidgetAllowListedLocked(String packageName) {\n            final int userId = UserHandle.getCallingUserId();\n            final int packageUid = getUidForPackage(packageName, userId);\n            if (packageUid < 0) {\n                throw new IllegalArgumentException(\"No package \" + packageName\n                        + \" for user \" + userId);\n            }\n            synchronized (mLock) {\n                ensureGroupStateLoadedLocked(userId);\n\n                Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                if (mPackagesWithBindWidgetPermission.contains(packageId)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        public boolean canAccessAppWidget(Widget widget, int uid, String packageName) {\n            if (isHostInPackageForUid(widget.host, uid, packageName)) {\n                // Apps hosting the AppWidget have access to it.\n                return true;\n            }\n            if (isProviderInPackageForUid(widget.provider, uid, packageName)) {\n                // Apps providing the AppWidget have access to it.\n                return true;\n            }\n            if (isHostAccessingProvider(widget.host, widget.provider, uid, packageName)) {\n                // Apps hosting the AppWidget get to bind to a remote view service in the provider.\n                return true;\n            }\n            final int userId = UserHandle.getUserId(uid);\n            if ((widget.host.getUserId() == userId || (widget.provider != null\n                    && widget.provider.getUserId() == userId))\n                && mContext.checkCallingPermission(android.Manifest.permission.BIND_APPWIDGET)\n                    == PackageManager.PERMISSION_GRANTED) {\n                // Apps that run in the same user as either the host or the provider and\n                // have the bind widget permission have access to the widget.\n                return true;\n            }\n            if (DEBUG) {\n                Slog.i(TAG, \"canAccessAppWidget() failed. packageName=\" + packageName\n                        + \" uid=\" + uid + \" userId=\" + userId + \" widget=\" + widget);\n            }\n            return false;\n        }\n\n        private boolean isParentOrProfile(int parentId, int profileId) {\n            if (parentId == profileId) {\n                return true;\n            }\n            return getProfileParent(profileId) == parentId;\n        }\n\n        public boolean isProviderInCallerOrInProfileAndWhitelListed(String packageName,\n                int profileId) {\n            final int callerId = UserHandle.getCallingUserId();\n            if (profileId == callerId) {\n                return true;\n            }\n            final int parentId = getProfileParent(profileId);\n            if (parentId != callerId) {\n                return false;\n            }\n            return isProviderWhiteListed(packageName, profileId);\n        }\n\n        public boolean isProviderWhiteListed(String packageName, int profileId) {\n            // If the policy manager is not available on the device we deny it all.\n            if (mDevicePolicyManagerInternal == null) {\n                return false;\n            }\n\n            List<String> crossProfilePackages = mDevicePolicyManagerInternal\n                    .getCrossProfileWidgetProviders(profileId);\n\n            return crossProfilePackages.contains(packageName);\n        }\n\n        public int getProfileParent(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo parent = mUserManager.getProfileParent(profileId);\n                if (parent != null) {\n                    return parent.getUserHandle().getIdentifier();\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return UNKNOWN_USER_ID;\n        }\n\n        public int getGroupParent(int profileId) {\n            final int parentId = mSecurityPolicy.getProfileParent(profileId);\n            return (parentId != UNKNOWN_USER_ID) ? parentId : profileId;\n        }\n\n        public boolean isHostInPackageForUid(Host host, int uid, String packageName) {\n            return host.id.uid == uid && host.id.packageName.equals(packageName);\n        }\n\n        public boolean isProviderInPackageForUid(Provider provider, int uid,\n                String packageName) {\n            // Packages providing the AppWidget have access to it.\n            return provider != null && provider.id.uid == uid\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        public boolean isHostAccessingProvider(Host host, Provider provider, int uid,\n                String packageName) {\n            // The host creates a package context to bind to remote views service in the provider.\n            return host.id.uid == uid && provider != null\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        private boolean isProfileEnabled(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo userInfo = mUserManager.getUserInfo(profileId);\n                if (userInfo == null || !userInfo.isEnabled()) {\n                    return false;\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return true;\n        }\n    }\n\n    static final class Provider {\n\n        ProviderId id;\n        AppWidgetProviderInfo info;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        PendingIntent broadcast;\n        String infoTag;\n        SparseArray<RemoteViews> generatedPreviews = new SparseArray<>(3);\n        private static final int[] WIDGET_CATEGORY_FLAGS = new int[]{\n                AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN,\n                AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD,\n                AppWidgetProviderInfo.WIDGET_CATEGORY_SEARCHBOX,\n        };\n\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        boolean maskedByLockedProfile;\n        boolean maskedByQuietProfile;\n        boolean maskedBySuspendedPackage;\n        // This provider's package has been stopped\n        boolean maskedByStoppedPackage;\n        // Widget IDs for which we haven't yet sent DELETED broadcasts because the package was\n        // stopped.\n        IntArray pendingDeletedWidgetIds = new IntArray();\n\n        boolean mInfoParsed = false;\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId\n                    && id.componentName.getPackageName().equals(packageName);\n        }\n\n        // is there an instance of this provider hosted by the given app?\n        public boolean hostedByPackageForUser(String packageName, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (packageName.equals(widget.host.id.packageName)\n                        && widget.host.getUserId() == userId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @GuardedBy(\"this.mLock\")\n        public AppWidgetProviderInfo getInfoLocked(Context context) {\n            if (!mInfoParsed) {\n                // parse\n                if (!zombie) {\n                    AppWidgetProviderInfo newInfo = null;\n                    if (!TextUtils.isEmpty(infoTag)) {\n                        newInfo = parseAppWidgetProviderInfo(\n                                context, id, info.providerInfo, infoTag);\n                    }\n                    if (newInfo == null) {\n                        newInfo = parseAppWidgetProviderInfo(context, id, info.providerInfo,\n                                AppWidgetManager.META_DATA_APPWIDGET_PROVIDER);\n                    }\n                    if (newInfo != null) {\n                        info = newInfo;\n                        if (DEBUG) {\n                            Objects.requireNonNull(info);\n                        }\n                        updateGeneratedPreviewCategoriesLocked();\n                    }\n                }\n                mInfoParsed = true;\n            }\n            return info;\n        }\n\n        /**\n         * Returns the last updated AppWidgetProviderInfo for this provider. This info may not\n         * be completely parsed and only contain placeHolder information like\n         * {@link AppWidgetProviderInfo#providerInfo}\n         */\n        @GuardedBy(\"AppWidgetServiceImpl.mLock\")\n        public AppWidgetProviderInfo getPartialInfoLocked() {\n            return info;\n        }\n\n        @GuardedBy(\"AppWidgetServiceImpl.mLock\")\n        public void setPartialInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            if (DEBUG) {\n                Objects.requireNonNull(this.info);\n            }\n            mInfoParsed = false;\n        }\n\n        @GuardedBy(\"AppWidgetServiceImpl.mLock\")\n        public void setInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            if (DEBUG) {\n                Objects.requireNonNull(this.info);\n            }\n            mInfoParsed = true;\n        }\n\n        @GuardedBy(\"this.mLock\")\n        @Nullable\n        public RemoteViews getGeneratedPreviewLocked(\n                @AppWidgetProviderInfo.CategoryFlags int widgetCategories) {\n            for (int i = 0; i < generatedPreviews.size(); i++) {\n                if ((widgetCategories & generatedPreviews.keyAt(i)) != 0) {\n                    return generatedPreviews.valueAt(i);\n                }\n            }\n            return null;\n        }\n\n        @GuardedBy(\"this.mLock\")\n        public void setGeneratedPreviewLocked(\n                @AppWidgetProviderInfo.CategoryFlags int widgetCategories,\n                @NonNull RemoteViews preview) {\n            for (int flag : WIDGET_CATEGORY_FLAGS) {\n                if ((widgetCategories & flag) != 0) {\n                    generatedPreviews.put(flag, preview);\n                }\n            }\n            updateGeneratedPreviewCategoriesLocked();\n        }\n\n        @GuardedBy(\"this.mLock\")\n        public boolean removeGeneratedPreviewLocked(int widgetCategories) {\n            boolean changed = false;\n            for (int flag : WIDGET_CATEGORY_FLAGS) {\n                if ((widgetCategories & flag) != 0) {\n                    changed |= generatedPreviews.removeReturnOld(flag) != null;\n                }\n            }\n            if (changed) {\n                updateGeneratedPreviewCategoriesLocked();\n            }\n            return changed;\n        }\n\n        @GuardedBy(\"this.mLock\")\n        public boolean clearGeneratedPreviewsLocked() {\n            if (generatedPreviews.size() > 0) {\n                generatedPreviews.clear();\n                updateGeneratedPreviewCategoriesLocked();\n                return true;\n            }\n            return false;\n        }\n\n        @GuardedBy(\"this.mLock\")\n        private void updateGeneratedPreviewCategoriesLocked() {\n            info.generatedPreviewCategories = 0;\n            for (int i = 0; i < generatedPreviews.size(); i++) {\n                info.generatedPreviewCategories |= generatedPreviews.keyAt(i);\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Provider{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByQuietProfileLocked(boolean masked) {\n            boolean oldState = maskedByQuietProfile;\n            maskedByQuietProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByLockedProfileLocked(boolean masked) {\n            boolean oldState = maskedByLockedProfile;\n            maskedByLockedProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedBySuspendedPackageLocked(boolean masked) {\n            boolean oldState = maskedBySuspendedPackage;\n            maskedBySuspendedPackage = masked;\n            return masked != oldState;\n        }\n\n        public boolean setMaskedByStoppedPackageLocked(boolean masked) {\n            boolean oldState = maskedByStoppedPackage;\n            maskedByStoppedPackage = masked;\n            return masked != oldState;\n        }\n\n        public boolean isMaskedLocked() {\n            return maskedByQuietProfile || maskedByLockedProfile || maskedBySuspendedPackage\n                    || maskedByStoppedPackage;\n        }\n\n        public boolean shouldBePersisted() {\n            return !widgets.isEmpty() || !TextUtils.isEmpty(infoTag);\n        }\n    }\n\n    static final class ProviderId {\n        final int uid;\n        final ComponentName componentName;\n\n        ProviderId(int uid, ComponentName componentName) {\n            this.uid = uid;\n            this.componentName = componentName;\n        }\n\n        public UserHandle getProfile() {\n            return UserHandle.getUserHandleForUid(uid);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            ProviderId other = (ProviderId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (componentName == null) {\n                if (other.componentName != null) {\n                    return false;\n                }\n            } else if (!componentName.equals(other.componentName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + ((componentName != null)\n                    ? componentName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"ProviderId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", cmp:\" + componentName + '}';\n        }\n    }\n\n    static final class Host {\n        HostId id;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        IAppWidgetHost callbacks;\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        private static final boolean DEBUG = true;\n\n        private static final String TAG = \"AppWidgetServiceHost\";\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n        // Sequence no for the last update successfully sent. This is updated whenever a\n        // widget update is successfully sent to the host callbacks. As all new/undelivered updates\n        // will have sequenceNo greater than this, all those updates will be sent when the host\n        // callbacks are attached again.\n        long lastWidgetUpdateSequenceNo;\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId && id.packageName.equals(packageName);\n        }\n\n        private boolean hostsPackageForUser(String pkg, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = widgets.get(i).provider;\n                if (provider != null && provider.getUserId() == userId\n                        && pkg.equals(provider.id.componentName.getPackageName())) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Adds all pending updates in {@param outUpdates} keys by the update time.\n         */\n        @GuardedBy(\"mLock\")\n        public void getPendingUpdatesForIdLocked(Context context, int appWidgetId,\n                LongSparseArray<PendingHostUpdate> outUpdates) {\n            long updateSequenceNo = lastWidgetUpdateSequenceNo;\n            int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (widget.appWidgetId == appWidgetId) {\n                    for (int j = widget.updateSequenceNos.size() - 1; j >= 0; j--) {\n                        long requestId = widget.updateSequenceNos.valueAt(j);\n                        if (requestId <= updateSequenceNo) {\n                            continue;\n                        }\n                        int id = widget.updateSequenceNos.keyAt(j);\n                        final PendingHostUpdate update;\n                        switch (id) {\n                            case ID_PROVIDER_CHANGED:\n                                update = PendingHostUpdate.providerChanged(\n                                        appWidgetId, widget.provider.getInfoLocked(context));\n                                break;\n                            case ID_VIEWS_UPDATE:\n                                update = PendingHostUpdate.updateAppWidget(appWidgetId,\n                                        cloneIfLocalBinder(widget.getEffectiveViewsLocked()));\n                                break;\n                            default:\n                                update = PendingHostUpdate.viewDataChanged(appWidgetId, id);\n                        }\n                        outUpdates.put(requestId, update);\n                    }\n                    return;\n                }\n            }\n            outUpdates.put(lastWidgetUpdateSequenceNo,\n                    PendingHostUpdate.appWidgetRemoved(appWidgetId));\n        }\n\n        public SparseArray<String> getWidgetUidsIfBound() {\n            final SparseArray<String> uids = new SparseArray<>();\n            for (int i = widgets.size() - 1; i >= 0; i--) {\n                final Widget widget = widgets.get(i);\n                if (widget.provider == null) {\n                    if (DEBUG) {\n                        Slog.d(TAG, \"Widget with no provider \" + widget.toString());\n                    }\n                    continue;\n                }\n                final ProviderId providerId = widget.provider.id;\n                uids.put(providerId.uid, providerId.componentName.getPackageName());\n            }\n            return uids;\n        }\n\n        @Override\n        public String toString() {\n            return \"Host{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n    }\n\n    private static final class HostId {\n        final int uid;\n        final int hostId;\n        final String packageName;\n\n        public HostId(int uid, int hostId, String packageName) {\n            this.uid = uid;\n            this.hostId = hostId;\n            this.packageName = packageName;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            HostId other = (HostId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (hostId != other.hostId) {\n                return false;\n            }\n            if (packageName == null) {\n                if (other.packageName != null) {\n                    return false;\n                }\n            } else if (!packageName.equals(other.packageName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + hostId;\n            result = 31 * result + ((packageName != null)\n                    ? packageName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"HostId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", hostId:\" + hostId\n                    + \", pkg:\" + packageName + '}';\n        }\n    }\n\n    // These can be any constants that would not collide with a resource id.\n    private static final int ID_VIEWS_UPDATE = 0;\n    private static final int ID_PROVIDER_CHANGED = 1;\n\n    private static final class Widget {\n        int appWidgetId;\n        int restoredId;  // tracking & remapping any restored state\n        Provider provider;\n        RemoteViews views;\n        RemoteViews maskedViews;\n        Bundle options;\n        Host host;\n        // Map of request type to updateSequenceNo.\n        SparseLongArray updateSequenceNos = new SparseLongArray(2);\n        boolean trackingUpdate = false;\n\n        @Override\n        public String toString() {\n            return \"AppWidgetId{\" + appWidgetId + ':' + host + ':' + provider + '}';\n        }\n\n        private boolean replaceWithMaskedViewsLocked(RemoteViews views) {\n            maskedViews = views;\n            return true;\n        }\n\n        private boolean clearMaskedViewsLocked() {\n            if (maskedViews != null) {\n                maskedViews = null;\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        public RemoteViews getEffectiveViewsLocked() {\n            return maskedViews != null ? maskedViews : views;\n        }\n    }\n\n    /**\n     * This class keeps track of API calls and implements rate limiting. One instance of this class\n     * tracks calls from all providers for one API, or a group of APIs that should share the same\n     * rate limit.\n     */\n    static final class ApiCounter {\n\n        private static final class ApiCallRecord {\n            // Number of times the API has been called for this provider.\n            public int apiCallCount = 0;\n            // The last time (from SystemClock.elapsedRealtime) the api call count was reset.\n            public long lastResetTimeMs = 0;\n\n            void reset(long nowMs) {\n                apiCallCount = 0;\n                lastResetTimeMs = nowMs;\n            }\n        }\n\n        private final Map<ProviderId, ApiCallRecord> mCallCount = new ArrayMap<>();\n        // The interval at which the call count is reset.\n        private long mResetIntervalMs;\n        // The max number of API calls per interval.\n        private int mMaxCallsPerInterval;\n        // Returns the current time (monotonic). By default this is SystemClock.elapsedRealtime.\n        private LongSupplier mMonotonicClock;\n\n        ApiCounter(long resetIntervalMs, int maxCallsPerInterval) {\n            this(resetIntervalMs, maxCallsPerInterval, SystemClock::elapsedRealtime);\n        }\n\n        ApiCounter(long resetIntervalMs, int maxCallsPerInterval,\n                LongSupplier monotonicClock) {\n            mResetIntervalMs = resetIntervalMs;\n            mMaxCallsPerInterval = maxCallsPerInterval;\n            mMonotonicClock = monotonicClock;\n        }\n\n        public void setResetIntervalMs(long resetIntervalMs) {\n            mResetIntervalMs = resetIntervalMs;\n        }\n\n        public long getResetIntervalMs() {\n            return mResetIntervalMs;\n        }\n\n        public void setMaxCallsPerInterval(int maxCallsPerInterval) {\n            mMaxCallsPerInterval = maxCallsPerInterval;\n        }\n\n        public int getMaxCallsPerInterval() {\n            return mMaxCallsPerInterval;\n        }\n\n        /**\n         * Returns true if the API call for the provider should be allowed, false if it should be\n         * rate-limited.\n         */\n        public boolean tryApiCall(@NonNull ProviderId provider) {\n            final ApiCallRecord record = getOrCreateRecord(provider);\n            final long now = mMonotonicClock.getAsLong();\n            final long timeSinceLastResetMs = now - record.lastResetTimeMs;\n            // If the last reset was beyond the reset interval, reset now.\n            if (timeSinceLastResetMs > mResetIntervalMs) {\n                record.reset(now);\n            }\n            if (record.apiCallCount < mMaxCallsPerInterval) {\n                record.apiCallCount++;\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * Remove the provider's call record from this counter, when the provider is no longer\n         * tracked.\n         */\n        public void remove(@NonNull ProviderId id) {\n            mCallCount.remove(id);\n        }\n\n        @NonNull\n        private ApiCallRecord getOrCreateRecord(@NonNull ProviderId provider) {\n            if (!mCallCount.containsKey(provider)) {\n                mCallCount.put(provider, new ApiCallRecord());\n            }\n            return mCallCount.get(provider);\n        }\n    }\n\n    private class LoadedWidgetState {\n        final Widget widget;\n        final int hostTag;\n        final int providerTag;\n\n        public LoadedWidgetState(Widget widget, int hostTag, int providerTag) {\n            this.widget = widget;\n            this.hostTag = hostTag;\n            this.providerTag = providerTag;\n        }\n    }\n\n    private final class SaveStateRunnable implements Runnable {\n        final int mUserId;\n\n        public SaveStateRunnable(int userId) {\n            mUserId = userId;\n        }\n\n        @Override\n        public void run() {\n            synchronized (mLock) {\n                // No need to enforce unlocked state when there is no caller. User can be in the\n                // stopping state or removed by the time the message is processed\n                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"convert_state_and_io\");\n                ensureGroupStateLoadedLocked(mUserId, false /* enforceUserUnlockingOrUnlocked */ );\n                saveStateLocked(mUserId);\n                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n            }\n        }\n    }\n\n    /**\n     * This class encapsulates the backup and restore logic for a user group state.\n     */\n    final class BackupRestoreController {\n        private static final String TAG = \"BackupRestoreController\";\n\n        private static final boolean DEBUG = AppWidgetServiceImpl.DEBUG;\n\n        // Version of backed-up widget state.\n        private static final int WIDGET_STATE_VERSION = 2;\n\n        // We need to make sure to wipe the pre-restore widget state only once for\n        // a given package.  Keep track of what we've done so far here; the list is\n        // cleared at the start of every system restore pass, but preserved through\n        // any install-time restore operations.\n        @GuardedBy(\"AppWidgetServiceImpl.this.mLock\")\n        private final SparseArray<Set<String>> mPrunedAppsPerUser = new SparseArray<>();\n\n        @GuardedBy(\"AppWidgetServiceImpl.this.mLock\")\n        final Map<Provider, List<RestoreUpdateRecord>> mUpdatesByProvider =\n                new ArrayMap<>();\n\n        @GuardedBy(\"AppWidgetServiceImpl.this.mLock\")\n        private final Map<Host, List<RestoreUpdateRecord>> mUpdatesByHost =\n                new ArrayMap<>();\n\n        @GuardedBy(\"AppWidgetServiceImpl.this.mLock\")\n        private boolean mHasSystemRestoreFinished;\n\n        @GuardedBy(\"AppWidgetServiceImpl.this.mLock\")\n        public boolean requiresPersistenceLocked() {\n            if (mHasSystemRestoreFinished) {\n                // No need to persist intermediate states if system restore is already finished.\n                return false;\n            }\n            // If either of the internal states is non-empty, then we need to persist that\n            return !(mPrunedAppsPerUser.size() == 0 && mUpdatesByProvider.isEmpty()\n                    && mUpdatesByHost.isEmpty());\n        }\n\n        public List<String> getWidgetParticipants(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget participants for user: \" + userId);\n            }\n\n            HashSet<String> packages = new HashSet<>();\n            synchronized (mLock) {\n                final int N = mWidgets.size();\n                for (int i = 0; i < N; i++) {\n                    Widget widget = mWidgets.get(i);\n\n                    // Skip cross-user widgets.\n                    if (!isProviderAndHostInUser(widget, userId)) {\n                        continue;\n                    }\n\n                    packages.add(widget.host.id.packageName);\n                    Provider provider = widget.provider;\n                    if (provider != null) {\n                        packages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n            }\n            return new ArrayList<>(packages);\n        }\n\n        public byte[] getWidgetState(String backedupPackage, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget state for user: \" + userId);\n            }\n\n            ByteArrayOutputStream stream = new ByteArrayOutputStream();\n            synchronized (mLock) {\n                // Preflight: if this app neither hosts nor provides any live widgets\n                // we have no work to do.\n                if (!packageNeedsWidgetBackupLocked(backedupPackage, userId)) {\n                    return null;\n                }\n\n                try {\n                    TypedXmlSerializer out = Xml.newFastSerializer();\n                    out.setOutput(stream, StandardCharsets.UTF_8.name());\n                    out.startDocument(null, true);\n                    out.startTag(null, \"ws\");      // widget state\n                    out.attributeInt(null, \"version\", WIDGET_STATE_VERSION);\n                    out.attribute(null, \"pkg\", backedupPackage);\n\n                    // Remember all the providers that are currently hosted or published\n                    // by this package: that is, all of the entities related to this app\n                    // which will need to be told about id remapping.\n                    int index = 0;\n                    int N = mProviders.size();\n                    for (int i = 0; i < N; i++) {\n                        Provider provider = mProviders.get(i);\n\n                        if (provider.shouldBePersisted()\n                                && (provider.isInPackageForUser(backedupPackage, userId)\n                                || provider.hostedByPackageForUser(backedupPackage, userId))) {\n                            provider.tag = index;\n                            serializeProvider(out, provider, false /* persistsProviderInfo*/);\n                            index++;\n                        }\n                    }\n\n                    N = mHosts.size();\n                    index = 0;\n                    for (int i = 0; i < N; i++) {\n                        Host host = mHosts.get(i);\n\n                        if (!host.widgets.isEmpty()\n                                && (host.isInPackageForUser(backedupPackage, userId)\n                                || host.hostsPackageForUser(backedupPackage, userId))) {\n                            host.tag = index;\n                            serializeHost(out, host);\n                            index++;\n                        }\n                    }\n\n                    // All widget instances involving this package,\n                    // either as host or as provider\n                    N = mWidgets.size();\n                    for (int i = 0; i < N; i++) {\n                        Widget widget = mWidgets.get(i);\n\n                        Provider provider = widget.provider;\n                        if (widget.host.isInPackageForUser(backedupPackage, userId)\n                                || (provider != null\n                                &&  provider.isInPackageForUser(backedupPackage, userId))) {\n                            serializeAppWidget(out, widget, false);\n                        }\n                    }\n\n                    out.endTag(null, \"ws\");\n                    out.endDocument();\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Unable to save widget state for \" + backedupPackage);\n                    return null;\n                }\n            }\n\n            return stream.toByteArray();\n        }\n\n        public void systemRestoreStarting(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"System restore starting for user: \" + userId);\n            }\n\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = false;\n                // We're starting a new \"system\" restore operation, so any widget restore\n                // state that we see from here on is intended to replace the current\n                // widget configuration of any/all of the affected apps.\n                getPrunedAppsLocked(userId).clear();\n                mUpdatesByProvider.clear();\n                mUpdatesByHost.clear();\n            }\n        }\n\n        public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Restoring widget state for user:\" + userId\n                        + \" package: \" + packageName);\n            }\n\n            ByteArrayInputStream stream = new ByteArrayInputStream(restoredState);\n            try {\n                // Providers mentioned in the widget dataset by ordinal\n                ArrayList<Provider> restoredProviders = new ArrayList<>();\n\n                // Hosts mentioned in the widget dataset by ordinal\n                ArrayList<Host> restoredHosts = new ArrayList<>();\n\n                TypedXmlPullParser parser = Xml.newFastPullParser();\n                parser.setInput(stream, StandardCharsets.UTF_8.name());\n\n                synchronized (mLock) {\n                    int type;\n                    do {\n                        type = parser.next();\n                        if (type == XmlPullParser.START_TAG) {\n                            final String tag = parser.getName();\n                            if (\"ws\".equals(tag)) {\n                                final int versionNumber = parser.getAttributeInt(null, \"version\");\n                                if (versionNumber > WIDGET_STATE_VERSION) {\n                                    Slog.w(TAG, \"Unable to process state version \" + versionNumber);\n                                    return;\n                                }\n\n                                // TODO: fix up w.r.t. canonical vs current package names\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                if (!packageName.equals(pkg)) {\n                                    Slog.w(TAG, \"Package mismatch in ws\");\n                                    return;\n                                }\n                            } else if (\"p\".equals(tag)) {\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                String cl = parser.getAttributeValue(null, \"cl\");\n\n                                // hostedProviders index will match 'p' attribute in widget's\n                                // entry in the xml file being restored\n                                // If there's no live entry for this provider, add an inactive one\n                                // so that widget IDs referring to them can be properly allocated\n\n                                // Backup and restore only for the parent profile.\n                                ComponentName componentName = new ComponentName(pkg, cl);\n\n                                Provider p = findProviderLocked(componentName, userId);\n                                if (p == null) {\n                                    AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                                    info.provider = componentName;\n\n                                    p = new Provider();\n                                    p.id = new ProviderId(UNKNOWN_UID, componentName);\n                                    p.setPartialInfoLocked(info);\n                                    p.zombie = true;\n                                    mProviders.add(p);\n                                }\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   provider \" + p.id);\n                                }\n                                restoredProviders.add(p);\n                            } else if (\"h\".equals(tag)) {\n                                // The host app may not yet exist on the device.  If it's here we\n                                // just use the existing Host entry, otherwise we create a\n                                // placeholder whose uid will be fixed up at PACKAGE_ADDED time.\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                                final int uid = getUidForPackage(pkg, userId);\n                                final int hostId = parser.getAttributeIntHex(null, \"id\");\n\n                                HostId id = new HostId(uid, hostId, pkg);\n                                Host h = lookupOrAddHostLocked(id);\n                                restoredHosts.add(h);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   host[\" + restoredHosts.size()\n                                            + \"]: {\" + h.id + \"}\");\n                                }\n                            } else if (\"g\".equals(tag)) {\n                                int restoredId = parser.getAttributeIntHex(null, \"id\");\n                                int hostIndex = parser.getAttributeIntHex(null, \"h\");\n                                Host host = restoredHosts.get(hostIndex);\n                                Provider p = null;\n                                int which = parser.getAttributeIntHex(null, \"p\", -1);\n                                if (which != -1) {\n                                    // could have been null if the app had allocated an id\n                                    // but not yet established a binding under that id\n                                    p = restoredProviders.get(which);\n                                }\n\n                                // We'll be restoring widget state for both the host and\n                                // provider sides of this widget ID, so make sure we are\n                                // beginning from a clean slate on both fronts.\n                                pruneWidgetStateLocked(host.id.packageName, userId);\n                                if (p != null) {\n                                    pruneWidgetStateLocked(p.id.componentName.getPackageName(),\n                                            userId);\n                                }\n\n                                // Have we heard about this ancestral widget instance before?\n                                Widget id = findRestoredWidgetLocked(restoredId, host, p);\n                                if (id == null) {\n                                    id = new Widget();\n                                    id.appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n                                    id.restoredId = restoredId;\n                                    id.options = parseWidgetIdOptions(parser);\n                                    id.host = host;\n                                    id.host.widgets.add(id);\n                                    id.provider = p;\n                                    if (id.provider != null) {\n                                        id.provider.widgets.add(id);\n                                    }\n                                    if (DEBUG) {\n                                        Slog.i(TAG, \"New restored id \" + restoredId\n                                                + \" now \" + id);\n                                    }\n                                    addWidgetLocked(id);\n                                }\n                                if (id.provider != null\n                                        && id.provider.getPartialInfoLocked() != null) {\n                                    stashProviderRestoreUpdateLocked(id.provider,\n                                            restoredId, id.appWidgetId);\n                                } else {\n                                    Slog.w(TAG, \"Missing provider for restored widget \" + id);\n                                }\n                                stashHostRestoreUpdateLocked(id.host, restoredId, id.appWidgetId);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   instance: \" + restoredId\n                                            + \" -> \" + id.appWidgetId\n                                            + \" :: p=\" + id.provider);\n                                }\n                            }\n                        }\n                    } while (type != XmlPullParser.END_DOCUMENT);\n\n                    // We've updated our own bookkeeping.  We'll need to notify the hosts and\n                    // providers about the changes, but we can't do that yet because the restore\n                    // target is not necessarily fully live at this moment.  Set aside the\n                    // information for now; the backup manager will call us once more at the\n                    // end of the process when all of the targets are in a known state, and we\n                    // will update at that point.\n                }\n            } catch (XmlPullParserException | IOException e) {\n                Slog.w(TAG, \"Unable to restore widget state for \" + packageName);\n            } finally {\n                saveGroupStateAsync(userId);\n            }\n        }\n\n        // Called once following the conclusion of a system restore operation.  This is when we\n        // send out updates to apps involved in widget-state restore telling them about\n        // the new widget ID space.  Apps that are not yet installed will be notifed when they are.\n        public void systemRestoreFinished(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"systemRestoreFinished for \" + userId);\n            }\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = true;\n                maybeSendWidgetRestoreBroadcastsLocked(userId);\n            }\n        }\n\n        // Called when widget components (hosts or providers) are added or changed.  If system\n        // restore has completed, we use this opportunity to tell the apps to update to the new\n        // widget ID space.  If system restore is still in progress, we delay the updates until\n        // the end, to allow all participants to restore their state before updating widget IDs.\n        public void widgetComponentsChanged(int userId) {\n            synchronized (mLock) {\n                if (mHasSystemRestoreFinished) {\n                    maybeSendWidgetRestoreBroadcastsLocked(userId);\n                }\n            }\n        }\n\n        // Called following the conclusion of a restore operation and when widget components\n        // are added or changed.  This is when we send out updates to apps involved in widget-state\n        // restore telling them about the new widget ID space.\n        @GuardedBy(\"mLock\")\n        private void maybeSendWidgetRestoreBroadcastsLocked(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"maybeSendWidgetRestoreBroadcasts for \" + userId);\n            }\n\n            final UserHandle userHandle = new UserHandle(userId);\n            // Build the providers' broadcasts and send them off\n            Set<Map.Entry<Provider, List<RestoreUpdateRecord>>> providerEntries\n                    = mUpdatesByProvider.entrySet();\n            for (Map.Entry<Provider, List<RestoreUpdateRecord>> e : providerEntries) {\n                // For each provider there's a list of affected IDs\n                Provider provider = e.getKey();\n                if (provider.zombie) {\n                    // Provider not installed, we can't send them broadcasts yet.\n                    // We'll be called again when the provider is installed.\n                    continue;\n                }\n                List<RestoreUpdateRecord> updates = e.getValue();\n                final int pending = countPendingUpdates(updates);\n                if (DEBUG) {\n                    Slog.i(TAG, \"Provider \" + provider + \" pending: \" + pending);\n                }\n                if (pending > 0) {\n                    int[] oldIds = new int[pending];\n                    int[] newIds = new int[pending];\n                    final int N = updates.size();\n                    int nextPending = 0;\n                    for (int i = 0; i < N; i++) {\n                        RestoreUpdateRecord r = updates.get(i);\n                        if (!r.notified) {\n                            r.notified = true;\n                            oldIds[nextPending] = r.oldId;\n                            newIds[nextPending] = r.newId;\n                            nextPending++;\n                            if (DEBUG) {\n                                Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                            }\n                        }\n                    }\n                    sendWidgetRestoreBroadcastLocked(\n                            AppWidgetManager.ACTION_APPWIDGET_RESTORED,\n                            provider, null, oldIds, newIds, userHandle);\n                }\n            }\n\n            // same thing per host\n            Set<Map.Entry<Host, List<RestoreUpdateRecord>>> hostEntries\n                    = mUpdatesByHost.entrySet();\n            for (Map.Entry<Host, List<RestoreUpdateRecord>> e : hostEntries) {\n                Host host = e.getKey();\n                if (host.id.uid != UNKNOWN_UID) {\n                    List<RestoreUpdateRecord> updates = e.getValue();\n                    final int pending = countPendingUpdates(updates);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Host \" + host + \" pending: \" + pending);\n                    }\n                    if (pending > 0) {\n                        int[] oldIds = new int[pending];\n                        int[] newIds = new int[pending];\n                        final int N = updates.size();\n                        int nextPending = 0;\n                        for (int i = 0; i < N; i++) {\n                            RestoreUpdateRecord r = updates.get(i);\n                            if (!r.notified) {\n                                r.notified = true;\n                                oldIds[nextPending] = r.oldId;\n                                newIds[nextPending] = r.newId;\n                                nextPending++;\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                                }\n                            }\n                        }\n                        sendWidgetRestoreBroadcastLocked(\n                                AppWidgetManager.ACTION_APPWIDGET_HOST_RESTORED,\n                                null, host, oldIds, newIds, userHandle);\n                    }\n                }\n            }\n        }\n\n        private Provider findProviderLocked(ComponentName componentName, int userId) {\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                if (provider.getUserId() == userId\n                        && provider.id.componentName.equals(componentName)) {\n                    return provider;\n                }\n            }\n            return null;\n        }\n\n        private Widget findRestoredWidgetLocked(int restoredId, Host host, Provider p) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Find restored widget: id=\" + restoredId\n                        + \" host=\" + host + \" provider=\" + p);\n            }\n\n            if (p == null || host == null) {\n                return null;\n            }\n\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                if (widget.restoredId == restoredId\n                        && widget.host.id.equals(host.id)\n                        && widget.provider.id.equals(p.id)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"   Found at \" + i + \" : \" + widget);\n                    }\n                    return widget;\n                }\n            }\n            return null;\n        }\n\n        private boolean packageNeedsWidgetBackupLocked(String packageName, int userId) {\n            int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n\n                // Skip cross-user widgets.\n                if (!isProviderAndHostInUser(widget, userId)) {\n                    continue;\n                }\n\n                if (widget.host.isInPackageForUser(packageName, userId)) {\n                    // this package is hosting widgets, so it knows widget IDs.\n                    return true;\n                }\n\n                Provider provider = widget.provider;\n                if (provider != null && provider.isInPackageForUser(packageName, userId)) {\n                    // someone is hosting this app's widgets, so it knows widget IDs.\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @GuardedBy(\"mLock\")\n        private void stashProviderRestoreUpdateLocked(Provider provider, int oldId, int newId) {\n            List<RestoreUpdateRecord> r = mUpdatesByProvider.get(provider);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByProvider.put(provider, r);\n            } else {\n                // don't duplicate\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + provider);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private boolean alreadyStashed(List<RestoreUpdateRecord> stash,\n                final int oldId, final int newId) {\n            final int N = stash.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = stash.get(i);\n                if (r.oldId == oldId && r.newId == newId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @GuardedBy(\"mLock\")\n        private void stashHostRestoreUpdateLocked(Host host, int oldId, int newId) {\n            List<RestoreUpdateRecord> r = mUpdatesByHost.get(host);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByHost.put(host, r);\n            } else {\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + host);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private void sendWidgetRestoreBroadcastLocked(String action, Provider provider,\n                Host host, int[] oldIds, int[] newIds, UserHandle userHandle) {\n            // Users expect restore to emplace widgets properly ASAP, so flag these as\n            // being interactive broadcast dispatches\n            Intent intent = new Intent(action);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OLD_IDS, oldIds);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, newIds);\n            if (provider != null) {\n                intent.setComponent(provider.id.componentName);\n                sendBroadcastAsUser(intent, userHandle, true);\n            }\n            if (host != null) {\n                intent.setComponent(null);\n                intent.setPackage(host.id.packageName);\n                intent.putExtra(AppWidgetManager.EXTRA_HOST_ID, host.id.hostId);\n                sendBroadcastAsUser(intent, userHandle, true);\n            }\n        }\n\n        // We're restoring widget state for 'pkg', so we start by wiping (a) all widget\n        // instances that are hosted by that app, and (b) all instances in other hosts\n        // for which 'pkg' is the provider.  We assume that we'll be restoring all of\n        // these hosts & providers, so will be reconstructing a correct live state.\n        @GuardedBy(\"mLock\")\n        private void pruneWidgetStateLocked(String pkg, int userId) {\n            final Set<String> prunedApps = getPrunedAppsLocked(userId);\n            if (!prunedApps.contains(pkg)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"pruning widget state for restoring package \" + pkg);\n                }\n                for (int i = mWidgets.size() - 1; i >= 0; i--) {\n                    Widget widget = mWidgets.get(i);\n\n                    Host host = widget.host;\n                    Provider provider = widget.provider;\n\n                    if (host.hostsPackageForUser(pkg, userId)\n                            || (provider != null && provider.isInPackageForUser(pkg, userId))) {\n                        // 'pkg' is either the host or the provider for this instances,\n                        // so we tear it down in anticipation of it (possibly) being\n                        // reconstructed due to the restore\n                        host.widgets.remove(widget);\n                        if (provider != null) {\n                            provider.widgets.remove(widget);\n                        }\n                        // Check if we need to destroy any services (if no other app widgets are\n                        // referencing the same service)\n                        decrementAppWidgetServiceRefCount(widget);\n                        removeWidgetLocked(widget);\n                    }\n                }\n                prunedApps.add(pkg);\n            } else {\n                if (DEBUG) {\n                    Slog.i(TAG, \"already pruned \" + pkg + \", continuing normally\");\n                }\n            }\n        }\n\n        @GuardedBy(\"mLock\")\n        @NonNull\n        private Set<String> getPrunedAppsLocked(int userId) {\n            if (!mPrunedAppsPerUser.contains(userId)) {\n                mPrunedAppsPerUser.set(userId, new ArraySet<>());\n            }\n            return mPrunedAppsPerUser.get(userId);\n        }\n\n        private boolean isProviderAndHostInUser(Widget widget, int userId) {\n            // Backup only widgets hosted or provided by the owner profile.\n            return widget.host.getUserId() == userId && (widget.provider == null\n                    || widget.provider.getUserId() == userId);\n        }\n\n        private int countPendingUpdates(List<RestoreUpdateRecord> updates) {\n            int pending = 0;\n            final int N = updates.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = updates.get(i);\n                if (!r.notified) {\n                    pending++;\n                }\n            }\n            return pending;\n        }\n\n        @GuardedBy(\"mLock\")\n        @NonNull\n        private State getStateLocked(final int userId) {\n            final Set<String> prunedApps = mPrunedAppsPerUser.get(userId);\n            final SparseArray<List<RestoreUpdateRecord>> updatesByProvider = new SparseArray<>();\n            final SparseArray<List<RestoreUpdateRecord>> updatesByHost = new SparseArray<>();\n            mUpdatesByProvider.forEach((p, updates) -> {\n                if (p.getUserId() == userId) {\n                    updatesByProvider.put(p.tag, new ArrayList<>(updates));\n                }\n            });\n            mUpdatesByHost.forEach((h, updates) -> {\n                if (h.getUserId() == userId) {\n                    updatesByHost.put(h.tag, new ArrayList<>(updates));\n                }\n            });\n            return new State(prunedApps, updatesByProvider, updatesByHost);\n        }\n\n        // Accumulate a list of updates that affect the given provider for a final\n        // coalesced notification broadcast once restore is over.\n        static class RestoreUpdateRecord {\n            public int oldId;\n            public int newId;\n            public boolean notified;\n\n            public RestoreUpdateRecord(int theOldId, int theNewId) {\n                oldId = theOldId;\n                newId = theNewId;\n                notified = false;\n            }\n        }\n\n        static final class State {\n            // We need to make sure to wipe the pre-restore widget state only once for\n            // a given package.  Keep track of what we've done so far here; the list is\n            // cleared at the start of every system restore pass, but preserved through\n            // any install-time restore operations.\n            @Nullable\n            private final Set<String> mPrunedApps;\n\n            @Nullable\n            private final SparseArray<List<RestoreUpdateRecord>> mUpdatesByProvider;\n\n            @Nullable\n            private final SparseArray<List<RestoreUpdateRecord>> mUpdatesByHost;\n\n            State(\n                    @Nullable final Set<String> prunedApps,\n                    @Nullable final SparseArray<List<RestoreUpdateRecord>> updatesByProvider,\n                    @Nullable final SparseArray<List<RestoreUpdateRecord>> updatesByHost) {\n                mPrunedApps = prunedApps;\n                mUpdatesByProvider = updatesByProvider;\n                mUpdatesByHost = updatesByHost;\n            }\n\n            @Nullable\n            Set<String> getPrunedApps() {\n                return mPrunedApps;\n            }\n\n            @Nullable\n            SparseArray<List<BackupRestoreController.RestoreUpdateRecord>> getUpdatesByProvider() {\n                return mUpdatesByProvider;\n            }\n\n            @Nullable\n            SparseArray<List<BackupRestoreController.RestoreUpdateRecord>> getUpdatesByHost() {\n                return mUpdatesByHost;\n            }\n        }\n    }\n\n    private class AppWidgetManagerLocal extends AppWidgetManagerInternal {\n        @Override\n        public ArraySet<String> getHostedWidgetPackages(int uid) {\n            synchronized (mLock) {\n                ArraySet<String> widgetPackages = null;\n                final int widgetCount = mWidgets.size();\n                for (int i = 0; i < widgetCount; i++) {\n                    final Widget widget = mWidgets.get(i);\n                    if  (widget.host.id.uid == uid && widget.provider != null) {\n                        if (widgetPackages == null) {\n                            widgetPackages = new ArraySet<>();\n                        }\n                        widgetPackages.add(widget.provider.id.componentName.getPackageName());\n                    }\n                }\n                return widgetPackages;\n            }\n        }\n\n        @Override\n        public void unlockUser(int userId) {\n            handleUserUnlocked(userId);\n        }\n\n        @Override\n        public void applyResourceOverlaysToWidgets(Set<String> packageNames, int userId,\n                boolean updateFrameworkRes) {\n            synchronized (mLock) {\n                applyResourceOverlaysToWidgetsLocked(new HashSet<>(packageNames), userId,\n                        updateFrameworkRes);\n            }\n        }\n    }\n}\n```",
                        "upstream_file_tokens": {
                            "openai": 50416,
                            "general": {
                                "word_based": 21550,
                                "char_based": 66890
                            },
                            "gemini": 60115
                        },
                        "downstream_file_content": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appwidget;\n\nimport static android.content.Context.KEYGUARD_SERVICE;\nimport static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.res.Resources.ID_NULL;\n\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\n\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManagerInternal;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.KeyguardManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerInternal.OnCrossProfileWidgetProvidersChangeListener;\nimport android.app.usage.UsageEvents;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.appwidget.AppWidgetManager;\nimport android.appwidget.AppWidgetManagerInternal;\nimport android.appwidget.AppWidgetProviderInfo;\nimport android.appwidget.PendingHostUpdate;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.Intent.FilterComparison;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.LauncherApps;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.ShortcutServiceInternal;\nimport android.content.pm.SuspendDialogInfo;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.graphics.Point;\nimport android.graphics.drawable.Icon;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.appwidget.AppWidgetServiceDumpProto;\nimport android.service.appwidget.WidgetProto;\nimport android.text.TextUtils;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.AttributeSet;\nimport android.util.IntArray;\nimport android.util.LongSparseArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.SparseLongArray;\nimport android.util.TypedValue;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\nimport android.util.Xml;\nimport android.util.proto.ProtoOutputStream;\nimport android.view.Display;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.app.SuspendedAppActivity;\nimport com.android.internal.app.UnlaunchableAppActivity;\nimport com.android.internal.appwidget.IAppWidgetHost;\nimport com.android.internal.appwidget.IAppWidgetService;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.widget.IRemoteViewsFactory;\nimport com.android.server.LocalServices;\nimport com.android.server.WidgetBackupProvider;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\n\nclass AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBackupProvider,\n        OnCrossProfileWidgetProvidersChangeListener {\n    private static final String TAG = \"AppWidgetServiceImpl\";\n\n    private static boolean DEBUG = false;\n\n    private static final String OLD_KEYGUARD_HOST_PACKAGE = \"android\";\n    private static final String NEW_KEYGUARD_HOST_PACKAGE = \"com.android.keyguard\";\n    private static final int KEYGUARD_HOST_ID = 0x4b455947;\n\n    private static final String STATE_FILENAME = \"appwidgets.xml\";\n\n    private static final int MIN_UPDATE_PERIOD = DEBUG ? 0 : 30 * 60 * 1000; // 30 minutes\n\n    private static final int TAG_UNDEFINED = -1;\n\n    private static final int UNKNOWN_UID = -1;\n\n    private static final int UNKNOWN_USER_ID = -10;\n\n    // Bump if the stored widgets need to be upgraded.\n    private static final int CURRENT_VERSION = 1;\n\n    // Every widget update request is associated which an increasing sequence number. This is\n    // used to verify which request has successfully been received by the host.\n    private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Received broadcast: \" + action + \" on user \" + userId);\n            }\n\n            switch (action) {\n                case Intent.ACTION_MANAGED_PROFILE_AVAILABLE:\n                case Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE:\n                    synchronized (mLock) {\n                        reloadWidgetsMaskedState(userId);\n                    }\n                    break;\n                case Intent.ACTION_PACKAGES_SUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, true, getSendingUserId());\n                    break;\n                case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, false, getSendingUserId());\n                    break;\n                default:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    break;\n            }\n        }\n    };\n\n    // Manages persistent references to RemoteViewsServices from different App Widgets.\n    private final HashMap<Pair<Integer, FilterComparison>, HashSet<Integer>>\n            mRemoteViewsServicesAppWidgets = new HashMap<>();\n\n    private final Object mLock = new Object();\n\n    private final ArrayList<Widget> mWidgets = new ArrayList<>();\n    private final ArrayList<Host> mHosts = new ArrayList<>();\n    private final ArrayList<Provider> mProviders = new ArrayList<>();\n\n    private final ArraySet<Pair<Integer, String>> mPackagesWithBindWidgetPermission =\n            new ArraySet<>();\n\n    private final SparseBooleanArray mLoadedUserIds = new SparseBooleanArray();\n\n    private final Object mWidgetPackagesLock = new Object();\n    private final SparseArray<ArraySet<String>> mWidgetPackages = new SparseArray<>();\n\n    private BackupRestoreController mBackupRestoreController;\n\n    private final Context mContext;\n\n    private IPackageManager mPackageManager;\n    private AlarmManager mAlarmManager;\n    private UserManager mUserManager;\n    private AppOpsManager mAppOpsManager;\n    private KeyguardManager mKeyguardManager;\n    private DevicePolicyManagerInternal mDevicePolicyManagerInternal;\n    private PackageManagerInternal mPackageManagerInternal;\n    private ActivityManagerInternal mActivityManagerInternal;\n    private AppOpsManagerInternal mAppOpsManagerInternal;\n    private UsageStatsManagerInternal mUsageStatsManagerInternal;\n\n    private SecurityPolicy mSecurityPolicy;\n\n    private Handler mSaveStateHandler;\n    private Handler mCallbackHandler;\n\n    private final SparseIntArray mNextAppWidgetIds = new SparseIntArray();\n\n    private boolean mSafeMode;\n    private int mMaxWidgetBitmapMemory;\n\n    AppWidgetServiceImpl(Context context) {\n        mContext = context;\n    }\n\n    public void onStart() {\n        mPackageManager = AppGlobals.getPackageManager();\n        mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n        mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);\n        mKeyguardManager = (KeyguardManager) mContext.getSystemService(KEYGUARD_SERVICE);\n        mDevicePolicyManagerInternal = LocalServices.getService(DevicePolicyManagerInternal.class);\n        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        mSaveStateHandler = BackgroundThread.getHandler();\n        mCallbackHandler = new CallbackHandler(mContext.getMainLooper());\n        mBackupRestoreController = new BackupRestoreController();\n        mSecurityPolicy = new SecurityPolicy();\n\n        computeMaximumWidgetBitmapMemory();\n        registerBroadcastReceiver();\n        registerOnCrossProfileProvidersChangedListener();\n\n        LocalServices.addService(AppWidgetManagerInternal.class, new AppWidgetManagerLocal());\n    }\n\n    void systemServicesReady() {\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n        mAppOpsManagerInternal = LocalServices.getService(AppOpsManagerInternal.class);\n        mUsageStatsManagerInternal = LocalServices.getService(UsageStatsManagerInternal.class);\n    }\n\n    private void computeMaximumWidgetBitmapMemory() {\n        Display display = mContext.getDisplayNoVerify();\n        Point size = new Point();\n        display.getRealSize(size);\n        // Cap memory usage at 1.5 times the size of the display\n        // 1.5 * 4 bytes/pixel * w * h ==> 6 * w * h\n        mMaxWidgetBitmapMemory = 6 * size.x * size.y;\n    }\n\n    private void registerBroadcastReceiver() {\n        // Register for broadcasts about package install, etc., so we can\n        // update the provider list.\n        IntentFilter packageFilter = new IntentFilter();\n        packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        packageFilter.addDataScheme(\"package\");\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                packageFilter, null, null);\n\n        // Register for events related to sdcard installation.\n        IntentFilter sdFilter = new IntentFilter();\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                sdFilter, null, null);\n\n        IntentFilter offModeFilter = new IntentFilter();\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_AVAILABLE);\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                offModeFilter, null, null);\n\n        IntentFilter suspendPackageFilter = new IntentFilter();\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                suspendPackageFilter, null, null);\n    }\n\n    private void registerOnCrossProfileProvidersChangedListener() {\n        // The device policy is an optional component.\n        if (mDevicePolicyManagerInternal != null) {\n            mDevicePolicyManagerInternal.addOnCrossProfileWidgetProvidersChangeListener(this);\n        }\n    }\n\n    public void setSafeMode(boolean safeMode) {\n        mSafeMode = safeMode;\n    }\n\n    private void onPackageBroadcastReceived(Intent intent, int userId) {\n        final String action = intent.getAction();\n        boolean added = false;\n        boolean changed = false;\n        boolean componentsModified = false;\n\n        final String pkgList[];\n        switch (action) {\n            case Intent.ACTION_PACKAGES_SUSPENDED:\n            case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                changed = true;\n                break;\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:\n                added = true;\n                // Follow through\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                break;\n            default: {\n                Uri uri = intent.getData();\n                if (uri == null) {\n                    return;\n                }\n                String pkgName = uri.getSchemeSpecificPart();\n                if (pkgName == null) {\n                    return;\n                }\n                pkgList = new String[] { pkgName };\n                added = Intent.ACTION_PACKAGE_ADDED.equals(action);\n                changed = Intent.ACTION_PACKAGE_CHANGED.equals(action);\n            }\n        }\n        if (pkgList == null || pkgList.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            if (!mUserManager.isUserUnlockingOrUnlocked(userId) ||\n                    isProfileWithLockedParent(userId)) {\n                return;\n            }\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            Bundle extras = intent.getExtras();\n\n            if (added || changed) {\n                final boolean newPackageAdded = added && (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                for (String pkgName : pkgList) {\n                    // Fix up the providers - add/remove/update.\n                    componentsModified |= updateProvidersForPackageLocked(pkgName, userId, null);\n\n                    // ... and see if these are hosts we've been awaiting.\n                    // NOTE: We are backing up and restoring only the owner.\n                    // TODO: http://b/22388012\n                    if (newPackageAdded && userId == UserHandle.USER_SYSTEM) {\n                        final int uid = getUidForPackage(pkgName, userId);\n                        if (uid >= 0 ) {\n                            resolveHostUidLocked(pkgName, uid);\n                        }\n                    }\n                }\n            } else {\n                // If the package is being updated, we'll receive a PACKAGE_ADDED\n                // shortly, otherwise it is removed permanently.\n                final boolean packageRemovedPermanently = (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                if (packageRemovedPermanently) {\n                    for (String pkgName : pkgList) {\n                        componentsModified |= removeHostsAndProvidersForPackageLocked(\n                                pkgName, userId);\n                    }\n                }\n            }\n\n            if (componentsModified) {\n                saveGroupStateAsync(userId);\n\n                // If the set of providers has been modified, notify each active AppWidgetHost\n                scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                // Possibly notify any new components of widget id changes\n                mBackupRestoreController.widgetComponentsChanged(userId);\n            }\n        }\n    }\n\n    /**\n     * Reload all widgets' masked state for the given user and its associated profiles, including\n     * due to user not being available and package suspension.\n     * userId must be the group parent.\n     */\n    void reloadWidgetsMaskedStateForGroup(int userId) {\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            return;\n        }\n        synchronized (mLock) {\n            reloadWidgetsMaskedState(userId);\n            int[] profileIds = mUserManager.getEnabledProfileIds(userId);\n            for (int profileId : profileIds) {\n                reloadWidgetsMaskedState(profileId);\n            }\n        }\n    }\n\n    private void reloadWidgetsMaskedState(int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            UserInfo user  = mUserManager.getUserInfo(userId);\n\n            boolean lockedProfile = !mUserManager.isUserUnlockingOrUnlocked(userId);\n            boolean quietProfile = user.isQuietModeEnabled();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != userId) {\n                    continue;\n                }\n\n                boolean changed = provider.setMaskedByLockedProfileLocked(lockedProfile);\n                changed |= provider.setMaskedByQuietProfileLocked(quietProfile);\n                try {\n                    boolean suspended;\n                    try {\n                        suspended = mPackageManager.isPackageSuspendedForUser(\n                                provider.id.componentName.getPackageName(), provider.getUserId());\n                    } catch (IllegalArgumentException ex) {\n                        // Package not found.\n                        suspended = false;\n                    }\n                    changed |= provider.setMaskedBySuspendedPackageLocked(suspended);\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Failed to query application info\", e);\n                }\n                if (changed) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * Incrementally update the masked state due to package suspension state.\n     */\n    private void updateWidgetPackageSuspensionMaskedState(Intent intent, boolean suspended,\n            int profileId) {\n        String[] packagesArray = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n        if (packagesArray == null) {\n            return;\n        }\n        Set<String> packages = new ArraySet<>(Arrays.asList(packagesArray));\n        synchronized (mLock) {\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != profileId\n                        || !packages.contains(provider.id.componentName.getPackageName())) {\n                    continue;\n                }\n                if (provider.setMaskedBySuspendedPackageLocked(suspended)) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Mask the target widget belonging to the specified provider, or all active widgets\n     * of the provider if target widget == null.\n     */\n    private void maskWidgetsViewsLocked(Provider provider, Widget targetWidget) {\n        final int widgetCount = provider.widgets.size();\n        if (widgetCount == 0) {\n            return;\n        }\n        RemoteViews views = new RemoteViews(mContext.getPackageName(),\n                R.layout.work_widget_mask_view);\n        ApplicationInfo appInfo = provider.info.providerInfo.applicationInfo;\n        final int appUserId = provider.getUserId();\n        boolean showBadge;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final Intent onClickIntent;\n\n            if (provider.maskedBySuspendedPackage) {\n                showBadge = mUserManager.hasBadge(appUserId);\n                final String suspendingPackage = mPackageManagerInternal.getSuspendingPackage(\n                        appInfo.packageName, appUserId);\n                if (PLATFORM_PACKAGE_NAME.equals(suspendingPackage)) {\n                    onClickIntent = mDevicePolicyManagerInternal.createShowAdminSupportIntent(\n                            appUserId, true);\n                } else {\n                    final SuspendDialogInfo dialogInfo =\n                            mPackageManagerInternal.getSuspendedDialogInfo(\n                                    appInfo.packageName, suspendingPackage, appUserId);\n                    // onUnsuspend is null because we don't want to start any activity on\n                    // unsuspending from a suspended widget.\n                    onClickIntent = SuspendedAppActivity.createSuspendedAppInterceptIntent(\n                            appInfo.packageName, suspendingPackage, dialogInfo, null, null,\n                            appUserId);\n                }\n            } else if (provider.maskedByQuietProfile) {\n                showBadge = true;\n                onClickIntent = UnlaunchableAppActivity.createInQuietModeDialogIntent(appUserId);\n            } else /* provider.maskedByLockedProfile */ {\n                showBadge = true;\n                onClickIntent = mKeyguardManager\n                        .createConfirmDeviceCredentialIntent(null, null, appUserId);\n                if (onClickIntent != null) {\n                    onClickIntent.setFlags(\n                            FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                }\n            }\n\n            if (onClickIntent != null) {\n                views.setOnClickPendingIntent(android.R.id.background,\n                        PendingIntent.getActivity(mContext, 0, onClickIntent,\n                                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE));\n            }\n\n            Icon icon = appInfo.icon != 0\n                    ? Icon.createWithResource(appInfo.packageName, appInfo.icon)\n                    : Icon.createWithResource(mContext, android.R.drawable.sym_def_app_icon);\n            views.setImageViewIcon(R.id.work_widget_app_icon, icon);\n            if (!showBadge) {\n                views.setViewVisibility(R.id.work_widget_badge_icon, View.INVISIBLE);\n            }\n\n            for (int j = 0; j < widgetCount; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (targetWidget != null && targetWidget != widget) continue;\n                if (widget.replaceWithMaskedViewsLocked(views)) {\n                    scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void unmaskWidgetsViewsLocked(Provider provider) {\n        final int widgetCount = provider.widgets.size();\n        for (int j = 0; j < widgetCount; j++) {\n            Widget widget = provider.widgets.get(j);\n            if (widget.clearMaskedViewsLocked()) {\n                scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n            }\n        }\n    }\n\n    private void resolveHostUidLocked(String pkg, int uid) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.uid == UNKNOWN_UID && pkg.equals(host.id.packageName)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"host \" + host.id + \" resolved to uid \" + uid);\n                }\n                host.id = new HostId(uid, host.id.hostId, host.id.packageName);\n                return;\n            }\n        }\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId) {\n        ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ true );\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId, boolean enforceUserUnlockingOrUnlocked) {\n        if (enforceUserUnlockingOrUnlocked && !isUserRunningAndUnlocked(userId)) {\n            throw new IllegalStateException(\n                    \"User \" + userId + \" must be unlocked for widgets to be available\");\n        }\n        if (enforceUserUnlockingOrUnlocked && isProfileWithLockedParent(userId)) {\n            throw new IllegalStateException(\n                    \"Profile \" + userId + \" must have unlocked parent\");\n        }\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        IntArray newIds = new IntArray(1);\n        for (int profileId : profileIds) {\n            if (!mLoadedUserIds.get(profileId)) {\n                mLoadedUserIds.put(profileId, true);\n                newIds.add(profileId);\n            }\n        }\n        if (newIds.size() <= 0) {\n            return;\n        }\n        final int[] newProfileIds = newIds.toArray();\n        clearProvidersAndHostsTagsLocked();\n\n        loadGroupWidgetProvidersLocked(newProfileIds);\n        loadGroupStateLocked(newProfileIds);\n    }\n\n    private boolean isUserRunningAndUnlocked(@UserIdInt int userId) {\n        return mUserManager.isUserUnlockingOrUnlocked(userId);\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;\n\n        synchronized (mLock) {\n            if (args.length > 0 && \"--proto\".equals(args[0])) {\n                dumpProto(fd);\n            } else {\n                dumpInternalLocked(pw);\n            }\n        }\n    }\n\n    private void dumpProto(FileDescriptor fd) {\n        Slog.i(TAG, \"dump proto for \" + mWidgets.size() + \" widgets\");\n\n        ProtoOutputStream proto = new ProtoOutputStream(fd);\n        int N = mWidgets.size();\n        for (int i=0; i < N; i++) {\n            dumpProtoWidget(proto, mWidgets.get(i));\n        }\n        proto.flush();\n    }\n\n    private void dumpProtoWidget(ProtoOutputStream proto, Widget widget) {\n        if (widget.host == null || widget.provider == null) {\n            Slog.d(TAG, \"skip dumping widget because host or provider is null: widget.host=\"\n                + widget.host + \" widget.provider=\"  + widget.provider);\n            return;\n        }\n        long token = proto.start(AppWidgetServiceDumpProto.WIDGETS);\n        proto.write(WidgetProto.IS_CROSS_PROFILE,\n            widget.host.getUserId() != widget.provider.getUserId());\n        proto.write(WidgetProto.IS_HOST_STOPPED, widget.host.callbacks == null);\n        proto.write(WidgetProto.HOST_PACKAGE, widget.host.id.packageName);\n        proto.write(WidgetProto.PROVIDER_PACKAGE, widget.provider.id.componentName.getPackageName());\n        proto.write(WidgetProto.PROVIDER_CLASS, widget.provider.id.componentName.getClassName());\n        if (widget.options != null) {\n            proto.write(WidgetProto.RESTORE_COMPLETED,\n                    widget.options.getBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED));\n            proto.write(WidgetProto.MIN_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, 0));\n            proto.write(WidgetProto.MIN_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, 0));\n            proto.write(WidgetProto.MAX_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, 0));\n            proto.write(WidgetProto.MAX_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, 0));\n        }\n        proto.end(token);\n    }\n\n    private void dumpInternalLocked(PrintWriter pw) {\n        int N = mProviders.size();\n        pw.println(\"Providers:\");\n        for (int i = 0; i < N; i++) {\n            dumpProviderLocked(mProviders.get(i), i, pw);\n        }\n\n        N = mWidgets.size();\n        pw.println(\" \");\n        pw.println(\"Widgets:\");\n        for (int i = 0; i < N; i++) {\n            dumpWidget(mWidgets.get(i), i, pw);\n        }\n\n        N = mHosts.size();\n        pw.println(\" \");\n        pw.println(\"Hosts:\");\n        for (int i = 0; i < N; i++) {\n            dumpHost(mHosts.get(i), i, pw);\n        }\n\n        N = mPackagesWithBindWidgetPermission.size();\n        pw.println(\" \");\n        pw.println(\"Grants:\");\n        for (int i = 0; i < N; i++) {\n            Pair<Integer, String> grant = mPackagesWithBindWidgetPermission.valueAt(i);\n            dumpGrant(grant, i, pw);\n        }\n    }\n\n    @Override\n    public ParceledListSlice<PendingHostUpdate> startListening(IAppWidgetHost callbacks,\n            String callingPackage, int hostId, int[] appWidgetIds) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"startListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n            host.callbacks = callbacks;\n\n            long updateSequenceNo = UPDATE_COUNTER.incrementAndGet();\n            int N = appWidgetIds.length;\n            ArrayList<PendingHostUpdate> outUpdates = new ArrayList<>(N);\n            LongSparseArray<PendingHostUpdate> updatesMap = new LongSparseArray<>();\n            for (int i = 0; i < N; i++) {\n                updatesMap.clear();\n                host.getPendingUpdatesForIdLocked(mContext, appWidgetIds[i], updatesMap);\n                // We key the updates based on request id, so that the values are sorted in the\n                // order they were received.\n                int m = updatesMap.size();\n                for (int j = 0; j < m; j++) {\n                    outUpdates.add(updatesMap.valueAt(j));\n                }\n            }\n            // Reset the update counter once all the updates have been calculated\n            host.lastWidgetUpdateSequenceNo = updateSequenceNo;\n            return new ParceledListSlice<>(outUpdates);\n        }\n    }\n\n    @Override\n    public void stopListening(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"stopListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                host.callbacks = null;\n                pruneHostLocked(host);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(host.getWidgetUids(), false);\n            }\n        }\n    }\n\n    @Override\n    public int allocateAppWidgetId(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"allocateAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return AppWidgetManager.INVALID_APPWIDGET_ID;\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n                mNextAppWidgetIds.put(userId, AppWidgetManager.INVALID_APPWIDGET_ID + 1);\n            }\n\n            final int appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n\n            Widget widget = new Widget();\n            widget.appWidgetId = appWidgetId;\n            widget.host = host;\n\n            host.widgets.add(widget);\n            addWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Allocated widget id \" + appWidgetId\n                        + \" for host \" + host.id);\n            }\n\n            return appWidgetId;\n        }\n    }\n\n    @Override\n    public void deleteAppWidgetId(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            deleteAppWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted widget id \" + appWidgetId\n                        + \" for host \" + widget.host.id);\n            }\n        }\n    }\n\n    @Override\n    public boolean hasBindAppWidgetPermission(String packageName, int grantId) {\n        if (DEBUG) {\n            Slog.i(TAG, \"hasBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return false;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            return mPackagesWithBindWidgetPermission.contains(packageId);\n        }\n    }\n\n    @Override\n    public void setBindAppWidgetPermission(String packageName, int grantId,\n            boolean grantPermission) {\n        if (DEBUG) {\n            Slog.i(TAG, \"setBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            if (grantPermission) {\n                mPackagesWithBindWidgetPermission.add(packageId);\n            } else {\n                mPackagesWithBindWidgetPermission.remove(packageId);\n            }\n\n            saveGroupStateAsync(grantId);\n        }\n    }\n\n    @Override\n    public IntentSender createAppWidgetConfigIntentSender(String callingPackage, int appWidgetId,\n            final int intentFlags) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"createAppWidgetConfigIntentSender() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id \" + appWidgetId);\n            }\n\n            Provider provider = widget.provider;\n            if (provider == null) {\n                throw new IllegalArgumentException(\"Widget not bound \" + appWidgetId);\n            }\n\n            // Make sure only safe flags can be passed it.\n            final int secureFlags = intentFlags & ~Intent.IMMUTABLE_FLAGS;\n\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_CONFIGURE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\n            intent.setComponent(provider.getInfoLocked(mContext).configure);\n            intent.setFlags(secureFlags);\n\n            // All right, create the sender.\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return PendingIntent.getActivityAsUser(\n                        mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_CANCEL_CURRENT,\n                                null, new UserHandle(provider.getUserId()))\n                        .getIntentSender();\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    @Override\n    public boolean bindAppWidgetId(String callingPackage, int appWidgetId,\n            int providerProfileId, ComponentName providerComponent, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"bindAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        // Check that if a cross-profile binding is attempted, it is allowed.\n        if (!mSecurityPolicy.isEnabledGroupProfile(providerProfileId)) {\n            return false;\n        }\n\n        // If the provider is not under the calling user, make sure this\n        // provider is allowlisted for access from the parent.\n        if (!mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                providerComponent.getPackageName(), providerProfileId)) {\n            return false;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // A special permission or allowlisting is required to bind widgets.\n            if (!mSecurityPolicy.hasCallerBindPermissionOrBindWhiteListedLocked(\n                    callingPackage)) {\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                Slog.e(TAG, \"Bad widget id \" + appWidgetId);\n                return false;\n            }\n\n            if (widget.provider != null) {\n                Slog.e(TAG, \"Widget id \" + appWidgetId\n                        + \" already bound to: \" + widget.provider.id);\n                return false;\n            }\n\n            final int providerUid = getUidForPackage(providerComponent.getPackageName(),\n                    providerProfileId);\n            if (providerUid < 0) {\n                Slog.e(TAG, \"Package \" + providerComponent.getPackageName() + \" not installed \"\n                        + \" for profile \" + providerProfileId);\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the provider is in the already vetted user profile.\n            ProviderId providerId = new ProviderId(providerUid, providerComponent);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.e(TAG, \"No widget provider \" + providerComponent + \" for profile \"\n                        + providerProfileId);\n                return false;\n            }\n\n            if (provider.zombie) {\n                Slog.e(TAG, \"Can't bind to a 3rd party provider in\"\n                        + \" safe mode \" + provider);\n                return false;\n            }\n\n            widget.provider = provider;\n            widget.options = (options != null) ? cloneIfLocalBinder(options) : new Bundle();\n\n            // We need to provide a default value for the widget category if it is not specified\n            if (!widget.options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {\n                widget.options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY,\n                        AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            }\n\n            provider.widgets.add(widget);\n\n            onWidgetProviderAddedOrChangedLocked(widget);\n\n            final int widgetCount = provider.widgets.size();\n            if (widgetCount == 1) {\n                // Tell the provider that it's ready.\n                sendEnableIntentLocked(provider);\n            }\n\n            // Send an update now -- We need this update now, and just for this appWidgetId.\n            // It's less critical when the next one happens, so when we schedule the next one,\n            // we add updatePeriodMillis to its start time. That time will have some slop,\n            // but that's okay.\n            sendUpdateIntentLocked(provider, new int[] {appWidgetId});\n\n            // Schedule the future updates.\n            registerForBroadcastsLocked(provider, getWidgetIds(provider.widgets));\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Bound widget \" + appWidgetId + \" to provider \" + provider.id);\n            }\n        }\n\n        return true;\n    }\n\n    @Override\n    public int[] getAppWidgetIds(ComponentName componentName) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIds() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider != null) {\n                return getWidgetIds(provider.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public int[] getAppWidgetIdsForHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIdsForHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access its hosts.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                return getWidgetIds(host.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public boolean bindRemoteViewsService(String callingPackage, int appWidgetId, Intent intent,\n            IApplicationThread caller, IBinder activtiyToken, IServiceConnection connection,\n            int flags) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"bindRemoteViewsService() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id\");\n            }\n\n            // Make sure the widget has a provider.\n            if (widget.provider == null) {\n                throw new IllegalArgumentException(\"No provider for widget \"\n                        + appWidgetId);\n            }\n\n            ComponentName componentName = intent.getComponent();\n\n            // Ensure that the service belongs to the same package as the provider.\n            // But this is not enough as they may be under different users - see below...\n            String providerPackage = widget.provider.id.componentName.getPackageName();\n            String servicePackage = componentName.getPackageName();\n            if (!servicePackage.equals(providerPackage)) {\n                throw new SecurityException(\"The taget service not in the same package\"\n                        + \" as the widget provider\");\n            }\n\n            // Make sure this service exists under the same user as the provider and\n            // requires a permission which allows only the system to bind to it.\n            mSecurityPolicy.enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                    componentName, widget.provider.getUserId());\n\n            // Good to go - the service package is correct, it exists for the correct\n            // user, and requires the bind permission.\n\n            final long callingIdentity = Binder.clearCallingIdentity();\n            try {\n                // Ask ActivityManager to bind it. Notice that we are binding the service with the\n                // caller app instead of DevicePolicyManagerService.\n                if (ActivityManager.getService().bindService(\n                        caller, activtiyToken, intent,\n                        intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                        connection, flags & (Context.BIND_AUTO_CREATE\n                                | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE),\n                        mContext.getOpPackageName(), widget.provider.getUserId()) != 0) {\n\n                    // Add it to the mapping of RemoteViewsService to appWidgetIds so that we\n                    // can determine when we can call back to the RemoteViewsService later to\n                    // destroy associated factories.\n                    incrementAppWidgetServiceRefCount(appWidgetId,\n                            Pair.create(widget.provider.id.uid, new FilterComparison(intent)));\n                    return true;\n                }\n            } catch (RemoteException ex) {\n                // Same process, should not happen.\n            } finally {\n                Binder.restoreCallingIdentity(callingIdentity);\n            }\n        }\n\n        // Failed to bind.\n        return false;\n    }\n\n    @Override\n    public void deleteHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts in its uid and package.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host == null) {\n                return;\n            }\n\n            deleteHostLocked(host);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted host \" + host.id);\n            }\n        }\n    }\n\n    @Override\n    public void deleteAllHosts() {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAllHosts() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            boolean changed = false;\n\n            final int N = mHosts.size();\n            for (int i = N - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n\n                // Delete only hosts in the calling uid.\n                if (host.id.uid == Binder.getCallingUid()) {\n                    deleteHostLocked(host);\n                    changed = true;\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Deleted host \" + host.id);\n                    }\n                }\n            }\n\n            if (changed) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    @Override\n    public AppWidgetProviderInfo getAppWidgetInfo(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetInfo() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.provider != null && !widget.provider.zombie) {\n                return cloneIfLocalBinder(widget.provider.getInfoLocked(mContext));\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public RemoteViews getAppWidgetViews(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetViews() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null) {\n                return cloneIfLocalBinder(widget.getEffectiveViewsLocked());\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetOptions(String callingPackage, int appWidgetId, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            // Merge the options.\n            widget.options.putAll(options);\n\n            // Send the broacast to notify the provider that options changed.\n            sendOptionsChangedIntentLocked(widget);\n\n            saveGroupStateAsync(userId);\n        }\n    }\n\n    @Override\n    public Bundle getAppWidgetOptions(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.options != null) {\n                return cloneIfLocalBinder(widget.options);\n            }\n\n            return Bundle.EMPTY;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, false);\n    }\n\n    @Override\n    public void partiallyUpdateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"partiallyUpdateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, true);\n    }\n\n    @Override\n    public void notifyAppWidgetViewDataChanged(String callingPackage, int[] appWidgetIds,\n            int viewId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"notifyAppWidgetViewDataChanged() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    scheduleNotifyAppWidgetViewDataChanged(widget, viewId);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProvider(ComponentName componentName, RemoteViews views) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.w(TAG, \"Provider doesn't exist \" + providerId);\n                return;\n            }\n\n            ArrayList<Widget> instances = provider.widgets;\n            final int N = instances.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = instances.get(i);\n                updateAppWidgetInstanceLocked(widget, views, false);\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProviderInfo(ComponentName componentName, String metadataKey) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n            if (provider == null) {\n                throw new IllegalArgumentException(\n                        componentName + \" is not a valid AppWidget provider\");\n            }\n            if (Objects.equals(provider.infoTag, metadataKey)) {\n                // No change\n                return;\n            }\n\n            String keyToUse = metadataKey == null\n                    ? AppWidgetManager.META_DATA_APPWIDGET_PROVIDER : metadataKey;\n            AppWidgetProviderInfo info = parseAppWidgetProviderInfo(mContext, providerId,\n                    provider.getPartialInfoLocked().providerInfo, keyToUse);\n            if (info == null) {\n                throw new IllegalArgumentException(\"Unable to parse \" + keyToUse\n                        + \" meta-data to a valid AppWidget provider\");\n            }\n\n            provider.setInfoLocked(info);\n            provider.infoTag = metadataKey;\n\n            // Update all widgets for this provider\n            final int N = provider.widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = provider.widgets.get(i);\n                scheduleNotifyProviderChangedLocked(widget);\n                updateAppWidgetInstanceLocked(widget, widget.views, false /* isPartialUpdate */);\n            }\n\n            saveGroupStateAsync(userId);\n            scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n        }\n    }\n\n    @Override\n    public boolean isRequestPinAppWidgetSupported() {\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + Binder.getCallingUid()\n                        + \" query information about app widgets\");\n                return false;\n            }\n        }\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .isRequestPinItemSupported(UserHandle.getCallingUserId(),\n                        LauncherApps.PinItemRequest.REQUEST_TYPE_APPWIDGET);\n    }\n\n    @Override\n    public boolean requestPinAppWidget(String callingPackage, ComponentName componentName,\n            Bundle extras, IntentSender resultSender) {\n        final int callingUid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(callingUid);\n\n        if (DEBUG) {\n            Slog.i(TAG, \"requestPinAppWidget() \" + userId);\n        }\n\n        final AppWidgetProviderInfo info;\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // Look for the widget associated with the caller.\n            Provider provider = lookupProviderLocked(new ProviderId(callingUid, componentName));\n            if (provider == null || provider.zombie) {\n                return false;\n            }\n            info = provider.getInfoLocked(mContext);\n            if ((info.widgetCategory & AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN) == 0) {\n                return false;\n            }\n        }\n\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .requestPinAppWidget(callingPackage, info, extras, resultSender, userId);\n    }\n\n    @Override\n    public ParceledListSlice<AppWidgetProviderInfo> getInstalledProvidersForProfile(int categoryFilter,\n            int profileId, String packageName) {\n        final int userId = UserHandle.getCallingUserId();\n        final int callingUid = Binder.getCallingUid();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getInstalledProvidersForProfiles() \" + userId);\n        }\n\n        // Ensure the profile is in the group and enabled.\n        if (!mSecurityPolicy.isEnabledGroupProfile(profileId)) {\n            return null;\n        }\n\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + callingUid\n                        + \" cannot access widget providers\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            ArrayList<AppWidgetProviderInfo> result = new ArrayList<AppWidgetProviderInfo>();\n\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n                final String providerPackageName = provider.id.componentName.getPackageName();\n\n                // Ignore an invalid provider, one not matching the filter,\n                // or one that isn't in the given package, if any.\n                boolean inPackage = packageName == null\n                        || providerPackageName.equals(packageName);\n                if (provider.zombie || (info.widgetCategory & categoryFilter) == 0 || !inPackage) {\n                    continue;\n                }\n\n                // Add providers only for the requested profile that are allowlisted.\n                final int providerProfileId = info.getProfile().getIdentifier();\n                if (providerProfileId == profileId\n                        && mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                        providerPackageName, providerProfileId)\n                        && !mPackageManagerInternal.filterAppAccess(providerPackageName, callingUid,\n                        userId)) {\n                    result.add(cloneIfLocalBinder(info));\n                }\n            }\n\n            return new ParceledListSlice<AppWidgetProviderInfo>(result);\n        }\n    }\n\n    private void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views, boolean partially) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    updateAppWidgetInstanceLocked(widget, views, partially);\n                }\n            }\n        }\n    }\n\n    private int incrementAndGetAppWidgetIdLocked(int userId) {\n        final int appWidgetId = peekNextAppWidgetIdLocked(userId) + 1;\n        mNextAppWidgetIds.put(userId, appWidgetId);\n        return appWidgetId;\n    }\n\n    private void setMinAppWidgetIdLocked(int userId, int minWidgetId) {\n        final int nextAppWidgetId = peekNextAppWidgetIdLocked(userId);\n        if (nextAppWidgetId < minWidgetId) {\n            mNextAppWidgetIds.put(userId, minWidgetId);\n        }\n    }\n\n    private int peekNextAppWidgetIdLocked(int userId) {\n        if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n            return AppWidgetManager.INVALID_APPWIDGET_ID + 1;\n        } else {\n            return mNextAppWidgetIds.get(userId);\n        }\n    }\n\n    private Host lookupOrAddHostLocked(HostId id) {\n        Host host = lookupHostLocked(id);\n        if (host != null) {\n            return host;\n        }\n        ensureHostCountBeforeAddLocked(id);\n        host = new Host();\n        host.id = id;\n        mHosts.add(host);\n\n        return host;\n    }\n\n    /**\n     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n     * removes the oldest host.\n     */\n    private void ensureHostCountBeforeAddLocked(@NonNull final HostId hostId) {\n        final List<Host> hosts = new ArrayList<>();\n        for (Host host : mHosts) {\n            if (host.id.uid == hostId.uid\n                    && host.id.packageName.equals(hostId.packageName)) {\n                hosts.add(host);\n            }\n        }\n        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n            deleteHostLocked(hosts.remove(0));\n        }\n    }\n\n    private void deleteHostLocked(Host host) {\n        final int N = host.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = host.widgets.remove(i);\n            deleteAppWidgetLocked(widget);\n        }\n        mHosts.remove(host);\n\n        // it's gone or going away, abruptly drop the callback connection\n        host.callbacks = null;\n    }\n\n    private void deleteAppWidgetLocked(Widget widget) {\n        // We first unbind all services that are bound to this id\n        // Check if we need to destroy any services (if no other app widgets are\n        // referencing the same service)\n        decrementAppWidgetServiceRefCount(widget);\n\n        Host host = widget.host;\n        host.widgets.remove(widget);\n        pruneHostLocked(host);\n\n        removeWidgetLocked(widget);\n\n        Provider provider = widget.provider;\n        if (provider != null) {\n            provider.widgets.remove(widget);\n            if (!provider.zombie) {\n                // send the broacast saying that this appWidgetId has been deleted\n                sendDeletedIntentLocked(widget);\n\n                if (provider.widgets.isEmpty()) {\n                    // cancel the future updates\n                    cancelBroadcastsLocked(provider);\n\n                    // send the broacast saying that the provider is not in use any more\n                    sendDisabledIntentLocked(provider);\n                }\n            }\n        }\n    }\n\n    private void cancelBroadcastsLocked(Provider provider) {\n        if (DEBUG) {\n            Slog.i(TAG, \"cancelBroadcastsLocked() for \" + provider);\n        }\n        if (provider.broadcast != null) {\n            final PendingIntent broadcast = provider.broadcast;\n            mSaveStateHandler.post(() -> {\n                    mAlarmManager.cancel(broadcast);\n                    broadcast.cancel();\n            });\n            provider.broadcast = null;\n        }\n    }\n\n    // Destroys the cached factory on the RemoteViewsService's side related to the specified intent\n    private void destroyRemoteViewsService(final Intent intent, Widget widget) {\n        final ServiceConnection conn = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName name, IBinder service) {\n                final IRemoteViewsFactory cb = IRemoteViewsFactory.Stub.asInterface(service);\n                try {\n                    cb.onDestroy(intent);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Error calling remove view factory\", re);\n                }\n                mContext.unbindService(this);\n            }\n\n            @Override\n            public void onServiceDisconnected(ComponentName name) {\n                // Do nothing\n            }\n        };\n\n        // Bind to the service and remove the static intent->factory mapping in the\n        // RemoteViewsService.\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, conn,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    widget.provider.id.getProfile());\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    // Adds to the ref-count for a given RemoteViewsService intent\n    private void incrementAppWidgetServiceRefCount(int appWidgetId,\n            Pair<Integer, FilterComparison> serviceId) {\n        final HashSet<Integer> appWidgetIds;\n        if (mRemoteViewsServicesAppWidgets.containsKey(serviceId)) {\n            appWidgetIds = mRemoteViewsServicesAppWidgets.get(serviceId);\n        } else {\n            appWidgetIds = new HashSet<>();\n            mRemoteViewsServicesAppWidgets.put(serviceId, appWidgetIds);\n        }\n        appWidgetIds.add(appWidgetId);\n    }\n\n    // Subtracts from the ref-count for a given RemoteViewsService intent, prompting a delete if\n    // the ref-count reaches zero.\n    private void decrementAppWidgetServiceRefCount(Widget widget) {\n        Iterator<Pair<Integer, FilterComparison>> it = mRemoteViewsServicesAppWidgets\n                .keySet().iterator();\n        while (it.hasNext()) {\n            final Pair<Integer, FilterComparison> key = it.next();\n            final HashSet<Integer> ids = mRemoteViewsServicesAppWidgets.get(key);\n            if (ids.remove(widget.appWidgetId)) {\n                // If we have removed the last app widget referencing this service, then we\n                // should destroy it and remove it from this set\n                if (ids.isEmpty()) {\n                    destroyRemoteViewsService(key.second.getIntent(), widget);\n                    it.remove();\n                }\n            }\n        }\n    }\n\n    private void saveGroupStateAsync(int groupId) {\n        mSaveStateHandler.post(new SaveStateRunnable(groupId));\n    }\n\n    private void updateAppWidgetInstanceLocked(Widget widget, RemoteViews views,\n            boolean isPartialUpdate) {\n        if (widget != null && widget.provider != null\n                && !widget.provider.zombie && !widget.host.zombie) {\n\n            if (isPartialUpdate && widget.views != null) {\n                // For a partial update, we merge the new RemoteViews with the old.\n                widget.views.mergeRemoteViews(views);\n            } else {\n                // For a full update we replace the RemoteViews completely.\n                widget.views = views;\n            }\n            int memoryUsage;\n            if ((UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) &&\n                    (widget.views != null) &&\n                    ((memoryUsage = widget.views.estimateMemoryUsage()) > mMaxWidgetBitmapMemory)) {\n                widget.views = null;\n                throw new IllegalArgumentException(\"RemoteViews for widget update exceeds\"\n                        + \" maximum bitmap memory usage (used: \" + memoryUsage\n                        + \", max: \" + mMaxWidgetBitmapMemory + \")\");\n            }\n            scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n        }\n    }\n    private void scheduleNotifyAppWidgetViewDataChanged(Widget widget, int viewId) {\n        if (viewId == ID_VIEWS_UPDATE || viewId == ID_PROVIDER_CHANGED) {\n            // A view id should never collide with these constants but a developer can call this\n            // method with a wrong id. In that case, ignore the call.\n            return;\n        }\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(viewId, requestId);\n        }\n        if (widget == null || widget.host == null || widget.host.zombie\n                || widget.host.callbacks == null || widget.provider == null\n                || widget.provider.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n        args.argi2 = viewId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_VIEW_DATA_CHANGED,\n                args).sendToTarget();\n    }\n\n\n    private void handleNotifyAppWidgetViewDataChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, int viewId, long requestId) {\n        try {\n            callbacks.viewDataChanged(appWidgetId, viewId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            // It failed; remove the callback. No need to prune because\n            // we know that this host is still referenced by this instance.\n            callbacks = null;\n        }\n\n        // If the host is unavailable, then we call the associated\n        // RemoteViewsFactory.onDataSetChanged() directly\n        synchronized (mLock) {\n            if (callbacks == null) {\n                host.callbacks = null;\n\n                Set<Pair<Integer, FilterComparison>> keys = mRemoteViewsServicesAppWidgets.keySet();\n                for (Pair<Integer, FilterComparison> key : keys) {\n                    if (mRemoteViewsServicesAppWidgets.get(key).contains(appWidgetId)) {\n                        final ServiceConnection connection = new ServiceConnection() {\n                            @Override\n                            public void onServiceConnected(ComponentName name, IBinder service) {\n                                IRemoteViewsFactory cb = IRemoteViewsFactory.Stub\n                                        .asInterface(service);\n                                try {\n                                    cb.onDataSetChangedAsync();\n                                } catch (RemoteException e) {\n                                    Slog.e(TAG, \"Error calling onDataSetChangedAsync()\", e);\n                                }\n                                mContext.unbindService(this);\n                            }\n\n                            @Override\n                            public void onServiceDisconnected(android.content.ComponentName name) {\n                                // Do nothing\n                            }\n                        };\n\n                        final int userId = UserHandle.getUserId(key.first);\n                        Intent intent = key.second.getIntent();\n\n                        // Bind to the service and call onDataSetChanged()\n                        bindService(intent, connection, new UserHandle(userId));\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleNotifyUpdateAppWidgetLocked(Widget widget, RemoteViews updateViews) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(ID_VIEWS_UPDATE, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n        if (updateViews != null) {\n            updateViews = new RemoteViews(updateViews);\n            updateViews.setProviderInstanceId(requestId);\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = updateViews;\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_UPDATE_APP_WIDGET,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyUpdateAppWidget(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, RemoteViews views, long requestId) {\n        try {\n            callbacks.updateAppWidget(appWidgetId, views);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyProviderChangedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            // When the provider changes, reset everything else.\n            widget.updateSequenceNos.clear();\n            widget.updateSequenceNos.append(ID_PROVIDER_CHANGED, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = widget.provider.getInfoLocked(mContext);\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_PROVIDER_CHANGED,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyProviderChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, AppWidgetProviderInfo info, long requestId) {\n        try {\n            callbacks.providerChanged(appWidgetId, info);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock){\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyAppWidgetRemovedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.clear();\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n            CallbackHandler.MSG_NOTIFY_APP_WIDGET_REMOVED,\n            args).sendToTarget();\n    }\n\n    private void handleNotifyAppWidgetRemoved(Host host, IAppWidgetHost callbacks, int appWidgetId,\n            long requestId) {\n        try {\n            callbacks.appWidgetRemoved(appWidgetId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyGroupHostsForProvidersChangedLocked(int userId) {\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n\n            boolean hostInGroup = false;\n            final int M = profileIds.length;\n            for (int j = 0; j < M; j++) {\n                final int profileId = profileIds[j];\n                if (host.getUserId() == profileId) {\n                    hostInGroup = true;\n                    break;\n                }\n            }\n\n            if (!hostInGroup) {\n                continue;\n            }\n\n            if (host == null || host.zombie || host.callbacks == null) {\n                continue;\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = host;\n            args.arg2 = host.callbacks;\n\n            mCallbackHandler.obtainMessage(\n                    CallbackHandler.MSG_NOTIFY_PROVIDERS_CHANGED,\n                    args).sendToTarget();\n        }\n    }\n\n    private void handleNotifyProvidersChanged(Host host, IAppWidgetHost callbacks) {\n        try {\n            callbacks.providersChanged();\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private static boolean isLocalBinder() {\n        return Process.myPid() == Binder.getCallingPid();\n    }\n\n    private static RemoteViews cloneIfLocalBinder(RemoteViews rv) {\n        if (isLocalBinder() && rv != null) {\n            return rv.clone();\n        }\n        return rv;\n    }\n\n    private static AppWidgetProviderInfo cloneIfLocalBinder(AppWidgetProviderInfo info) {\n        if (isLocalBinder() && info != null) {\n            return info.clone();\n        }\n        return info;\n    }\n\n    private static Bundle cloneIfLocalBinder(Bundle bundle) {\n        // Note: this is only a shallow copy. For now this will be fine, but it could be problematic\n        // if we start adding objects to the options. Further, it would only be an issue if keyguard\n        // used such options.\n        if (isLocalBinder() && bundle != null) {\n            return (Bundle) bundle.clone();\n        }\n        return bundle;\n    }\n\n    private Widget lookupWidgetLocked(int appWidgetId, int uid, String packageName) {\n        final int N = mWidgets.size();\n        for (int i = 0; i < N; i++) {\n            Widget widget = mWidgets.get(i);\n            if (widget.appWidgetId == appWidgetId\n                    && mSecurityPolicy.canAccessAppWidget(widget, uid, packageName)) {\n                return widget;\n            }\n        }\n        return null;\n    }\n\n    private Provider lookupProviderLocked(ProviderId id) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.id.equals(id)) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host lookupHostLocked(HostId hostId) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.equals(hostId)) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    private void pruneHostLocked(Host host) {\n        if (host.widgets.size() == 0 && host.callbacks == null) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Pruning host \" + host.id);\n            }\n            mHosts.remove(host);\n        }\n    }\n\n    private void loadGroupWidgetProvidersLocked(int[] profileIds) {\n        List<ResolveInfo> allReceivers = null;\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            List<ResolveInfo> receivers = queryIntentReceivers(intent, profileId);\n            if (receivers != null && !receivers.isEmpty()) {\n                if (allReceivers == null) {\n                    allReceivers = new ArrayList<>();\n                }\n                allReceivers.addAll(receivers);\n            }\n        }\n\n        final int N = (allReceivers == null) ? 0 : allReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo receiver = allReceivers.get(i);\n            addProviderLocked(receiver);\n        }\n    }\n\n    private boolean addProviderLocked(ResolveInfo ri) {\n        if ((ri.activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n            return false;\n        }\n\n        ComponentName componentName = new ComponentName(ri.activityInfo.packageName,\n                ri.activityInfo.name);\n        ProviderId providerId = new ProviderId(ri.activityInfo.applicationInfo.uid, componentName);\n\n        // we might have an inactive entry for this provider already due to\n        // a preceding restore operation.  if so, fix it up in place; otherwise\n        // just add this new one.\n        Provider existing = lookupProviderLocked(providerId);\n\n        // If the provider was not found it may be because it was restored and\n        // we did not know its UID so let us find if there is such one.\n        if (existing == null) {\n            ProviderId restoredProviderId = new ProviderId(UNKNOWN_UID, componentName);\n            existing = lookupProviderLocked(restoredProviderId);\n        }\n\n        AppWidgetProviderInfo info = createPartialProviderInfo(providerId, ri, existing);\n        if (info != null) {\n            if (existing != null) {\n                if (existing.zombie && !mSafeMode) {\n                    // it's a placeholder that was set up during an app restore\n                    existing.id = providerId;\n                    existing.zombie = false;\n                    existing.setPartialInfoLocked(info);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Provider placeholder now reified: \" + existing);\n                    }\n                }\n            } else {\n                Provider provider = new Provider();\n                provider.id = providerId;\n                provider.setPartialInfoLocked(info);\n                mProviders.add(provider);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    // Remove widgets for provider that are hosted in userId.\n    private void deleteWidgetsLocked(Provider provider, int userId) {\n        final int N = provider.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = provider.widgets.get(i);\n            if (userId == UserHandle.USER_ALL\n                    || userId == widget.host.getUserId()) {\n                provider.widgets.remove(i);\n                // Call back with empty RemoteViews\n                updateAppWidgetInstanceLocked(widget, null, false);\n                // clear out references to this appWidgetId\n                widget.host.widgets.remove(widget);\n                removeWidgetLocked(widget);\n                widget.provider = null;\n                pruneHostLocked(widget.host);\n                widget.host = null;\n            }\n        }\n    }\n\n    private void deleteProviderLocked(Provider provider) {\n        deleteWidgetsLocked(provider, UserHandle.USER_ALL);\n        mProviders.remove(provider);\n\n        // no need to send the DISABLE broadcast, since the receiver is gone anyway\n        cancelBroadcastsLocked(provider);\n    }\n\n    private void sendEnableIntentLocked(Provider p) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_ENABLED);\n        intent.setComponent(p.id.componentName);\n        sendBroadcastAsUser(intent, p.id.getProfile());\n    }\n\n    private void sendUpdateIntentLocked(Provider provider, int[] appWidgetIds) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    private void sendDeletedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DELETED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void sendDisabledIntentLocked(Provider provider) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DISABLED);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    public void sendOptionsChangedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_OPTIONS_CHANGED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, widget.options);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void registerForBroadcastsLocked(Provider provider, int[] appWidgetIds) {\n        AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n        if (info.updatePeriodMillis > 0) {\n            // if this is the first instance, set the alarm. otherwise,\n            // rely on the fact that we've already set it and that\n            // PendingIntent.getBroadcast will update the extras.\n            boolean alreadyRegistered = provider.broadcast != null;\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n            intent.setComponent(info.provider);\n            final long token = Binder.clearCallingIdentity();\n            try {\n                // Broadcast alarms sent by system are immutable\n                provider.broadcast = PendingIntent.getBroadcastAsUser(mContext, 1, intent,\n                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                        info.getProfile());\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (!alreadyRegistered) {\n                // Set the alarm outside of our locks; we've latched the first-time\n                // invariant and established the PendingIntent safely.\n                final long period = Math.max(info.updatePeriodMillis, MIN_UPDATE_PERIOD);\n                final PendingIntent broadcast = provider.broadcast;\n                mSaveStateHandler.post(() ->\n                    mAlarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,\n                            SystemClock.elapsedRealtime() + period, period, broadcast)\n                );\n            }\n        }\n    }\n\n    private static int[] getWidgetIds(ArrayList<Widget> widgets) {\n        int instancesSize = widgets.size();\n        int appWidgetIds[] = new int[instancesSize];\n        for (int i = 0; i < instancesSize; i++) {\n            appWidgetIds[i] = widgets.get(i).appWidgetId;\n        }\n        return appWidgetIds;\n    }\n\n    private static void dumpProviderLocked(Provider provider, int index, PrintWriter pw) {\n        AppWidgetProviderInfo info = provider.getPartialInfoLocked();\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] provider \");\n        pw.println(provider.id);\n        pw.print(\"    min=(\"); pw.print(info.minWidth);\n        pw.print(\"x\"); pw.print(info.minHeight);\n        pw.print(\")   minResize=(\"); pw.print(info.minResizeWidth);\n        pw.print(\"x\"); pw.print(info.minResizeHeight);\n        pw.print(\") updatePeriodMillis=\");\n        pw.print(info.updatePeriodMillis);\n        pw.print(\" resizeMode=\");\n        pw.print(info.resizeMode);\n        pw.print(\" widgetCategory=\");\n        pw.print(info.widgetCategory);\n        pw.print(\" autoAdvanceViewId=\");\n        pw.print(info.autoAdvanceViewId);\n        pw.print(\" initialLayout=#\");\n        pw.print(Integer.toHexString(info.initialLayout));\n        pw.print(\" initialKeyguardLayout=#\");\n        pw.print(Integer.toHexString(info.initialKeyguardLayout));\n        pw.print(\"   zombie=\"); pw.println(provider.zombie);\n    }\n\n    private static void dumpHost(Host host, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] hostId=\");\n        pw.println(host.id);\n        pw.print(\"    callbacks=\"); pw.println(host.callbacks);\n        pw.print(\"    widgets.size=\"); pw.print(host.widgets.size());\n        pw.print(\" zombie=\"); pw.println(host.zombie);\n    }\n\n    private static void dumpGrant(Pair<Integer, String> grant, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(']');\n        pw.print(\" user=\"); pw.print(grant.first);\n        pw.print(\" package=\"); pw.println(grant.second);\n    }\n\n    private static void dumpWidget(Widget widget, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] id=\");\n        pw.println(widget.appWidgetId);\n        pw.print(\"    host=\");\n        pw.println(widget.host.id);\n        if (widget.provider != null) {\n            pw.print(\"    provider=\"); pw.println(widget.provider.id);\n        }\n        if (widget.host != null) {\n            pw.print(\"    host.callbacks=\"); pw.println(widget.host.callbacks);\n        }\n        if (widget.views != null) {\n            pw.print(\"    views=\"); pw.println(widget.views);\n        }\n    }\n\n    private static void serializeProvider(TypedXmlSerializer out, Provider p) throws IOException {\n        out.startTag(null, \"p\");\n        out.attribute(null, \"pkg\", p.id.componentName.getPackageName());\n        out.attribute(null, \"cl\", p.id.componentName.getClassName());\n        out.attributeIntHex(null, \"tag\", p.tag);\n        if (!TextUtils.isEmpty(p.infoTag)) {\n            out.attribute(null, \"info_tag\", p.infoTag);\n        }\n        out.endTag(null, \"p\");\n    }\n\n    private static void serializeHost(TypedXmlSerializer out, Host host) throws IOException {\n        out.startTag(null, \"h\");\n        out.attribute(null, \"pkg\", host.id.packageName);\n        out.attributeIntHex(null, \"id\", host.id.hostId);\n        out.attributeIntHex(null, \"tag\", host.tag);\n        out.endTag(null, \"h\");\n    }\n\n    private static void serializeAppWidget(TypedXmlSerializer out, Widget widget,\n            boolean saveRestoreCompleted) throws IOException {\n        out.startTag(null, \"g\");\n        out.attributeIntHex(null, \"id\", widget.appWidgetId);\n        out.attributeIntHex(null, \"rid\", widget.restoredId);\n        out.attributeIntHex(null, \"h\", widget.host.tag);\n        if (widget.provider != null) {\n            out.attributeIntHex(null, \"p\", widget.provider.tag);\n        }\n        if (widget.options != null) {\n            int minWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH);\n            int minHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);\n            int maxWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH);\n            int maxHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT);\n            out.attributeIntHex(null, \"min_width\", (minWidth > 0) ? minWidth : 0);\n            out.attributeIntHex(null, \"min_height\", (minHeight > 0) ? minHeight : 0);\n            out.attributeIntHex(null, \"max_width\", (maxWidth > 0) ? maxWidth : 0);\n            out.attributeIntHex(null, \"max_height\", (maxHeight > 0) ? maxHeight : 0);\n            out.attributeIntHex(null, \"host_category\", widget.options.getInt(\n                    AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY));\n            if (saveRestoreCompleted) {\n                boolean restoreCompleted = widget.options.getBoolean(\n                        AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED);\n                out.attributeBoolean(null, \"restore_completed\", restoreCompleted);\n            }\n        }\n        out.endTag(null, \"g\");\n    }\n\n    private static Bundle parseWidgetIdOptions(TypedXmlPullParser parser) {\n        Bundle options = new Bundle();\n        boolean restoreCompleted = parser.getAttributeBoolean(null, \"restore_completed\", false);\n        if (restoreCompleted) {\n            options.putBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED, true);\n        }\n        int minWidth = parser.getAttributeIntHex(null, \"min_width\", -1);\n        if (minWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, minWidth);\n        }\n        int minHeight = parser.getAttributeIntHex(null, \"min_height\", -1);\n        if (minHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, minHeight);\n        }\n        int maxWidth = parser.getAttributeIntHex(null, \"max_width\", -1);\n        if (maxWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, maxWidth);\n        }\n        int maxHeight = parser.getAttributeIntHex(null, \"max_height\", -1);\n        if (maxHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, maxHeight);\n        }\n        int category = parser.getAttributeIntHex(null, \"host_category\",\n                AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN);\n        if (category != AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY, category);\n        }\n        return options;\n    }\n\n    @Override\n    public List<String> getWidgetParticipants(int userId) {\n        return mBackupRestoreController.getWidgetParticipants(userId);\n    }\n\n    @Override\n    public byte[] getWidgetState(String packageName, int userId) {\n        return mBackupRestoreController.getWidgetState(packageName, userId);\n    }\n\n    @Override\n    public void systemRestoreStarting(int userId) {\n        mBackupRestoreController.systemRestoreStarting(userId);\n    }\n\n    @Override\n    public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n        mBackupRestoreController.restoreWidgetState(packageName, restoredState, userId);\n    }\n\n    @Override\n    public void systemRestoreFinished(int userId) {\n        mBackupRestoreController.systemRestoreFinished(userId);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private AppWidgetProviderInfo createPartialProviderInfo(ProviderId providerId, ResolveInfo ri,\n            Provider provider) {\n        boolean hasXmlDefinition = false;\n        Bundle metaData = ri.activityInfo.metaData;\n        if (metaData == null) {\n            return null;\n        }\n\n        if (provider != null && !TextUtils.isEmpty(provider.infoTag)) {\n            hasXmlDefinition = metaData.getInt(provider.infoTag) != 0;\n        }\n        hasXmlDefinition |= metaData.getInt(AppWidgetManager.META_DATA_APPWIDGET_PROVIDER) != 0;\n\n        if (hasXmlDefinition) {\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = ri.activityInfo;\n            return info;\n        }\n        return null;\n    }\n\n    private static AppWidgetProviderInfo parseAppWidgetProviderInfo(Context context,\n            ProviderId providerId, ActivityInfo activityInfo, String metadataKey) {\n        final PackageManager pm = context.getPackageManager();\n        try (XmlResourceParser parser = activityInfo.loadXmlMetaData(pm, metadataKey)) {\n            if (parser == null) {\n                Slog.w(TAG, \"No \" + metadataKey + \" meta-data for AppWidget provider '\"\n                        + providerId + '\\'');\n                return null;\n            }\n\n            AttributeSet attrs = Xml.asAttributeSet(parser);\n\n            int type;\n            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                    && type != XmlPullParser.START_TAG) {\n                // drain whitespace, comments, etc.\n            }\n\n            String nodeName = parser.getName();\n            if (!\"appwidget-provider\".equals(nodeName)) {\n                Slog.w(TAG, \"Meta-data does not start with appwidget-provider tag for\"\n                        + \" AppWidget provider \" + providerId.componentName\n                        + \" for user \" + providerId.uid);\n                return null;\n            }\n\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = activityInfo;\n\n            final Resources resources;\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final int userId = UserHandle.getUserId(providerId.uid);\n                final ApplicationInfo app = pm.getApplicationInfoAsUser(activityInfo.packageName,\n                        0, userId);\n                resources = pm.getResourcesForApplication(app);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n\n            TypedArray sa = resources.obtainAttributes(attrs,\n                    com.android.internal.R.styleable.AppWidgetProviderInfo);\n\n            // These dimensions has to be resolved in the application's context.\n            // We simply send back the raw complex data, which will be\n            // converted to dp in {@link AppWidgetManager#getAppWidgetInfo}.\n            TypedValue value = sa\n                    .peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minWidth);\n            info.minWidth = value != null ? value.data : 0;\n            value = sa.peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minHeight);\n            info.minHeight = value != null ? value.data : 0;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeWidth);\n            info.minResizeWidth = value != null ? value.data : info.minWidth;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeHeight);\n            info.minResizeHeight = value != null ? value.data : info.minHeight;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeWidth);\n            info.maxResizeWidth = value != null ? value.data : 0;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeHeight);\n            info.maxResizeHeight = value != null ? value.data : 0;\n\n            info.targetCellWidth = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellWidth, 0);\n            info.targetCellHeight = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellHeight, 0);\n\n            info.updatePeriodMillis = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_updatePeriodMillis, 0);\n            info.initialLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_initialLayout, ID_NULL);\n            info.initialKeyguardLayout = sa.getResourceId(com.android.internal.R.styleable.\n                    AppWidgetProviderInfo_initialKeyguardLayout, ID_NULL);\n\n            String className = sa\n                    .getString(com.android.internal.R.styleable.AppWidgetProviderInfo_configure);\n            if (className != null) {\n                info.configure = new ComponentName(providerId.componentName.getPackageName(),\n                        className);\n            }\n            info.label = activityInfo.loadLabel(pm).toString();\n            info.icon = activityInfo.getIconResource();\n            info.previewImage = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewImage, ID_NULL);\n            info.previewLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewLayout, ID_NULL);\n            info.autoAdvanceViewId = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_autoAdvanceViewId,\n                    View.NO_ID);\n            info.resizeMode = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_resizeMode,\n                    AppWidgetProviderInfo.RESIZE_NONE);\n            info.widgetCategory = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetCategory,\n                    AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            info.widgetFeatures = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetFeatures, 0);\n            info.descriptionRes = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_description, ID_NULL);\n            sa.recycle();\n            return info;\n        } catch (IOException | PackageManager.NameNotFoundException | XmlPullParserException e) {\n            // Ok to catch Exception here, because anything going wrong because\n            // of what a client process passes to us should not be fatal for the\n            // system process.\n            Slog.w(TAG, \"XML parsing failed for AppWidget provider \"\n                    + providerId.componentName + \" for user \" + providerId.uid, e);\n            return null;\n        }\n    }\n\n    private int getUidForPackage(String packageName, int userId) {\n        PackageInfo pkgInfo = null;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            pkgInfo = mPackageManager.getPackageInfo(packageName, 0, userId);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local call\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n\n        if (pkgInfo == null || pkgInfo.applicationInfo == null) {\n            return -1;\n        }\n\n        return pkgInfo.applicationInfo.uid;\n    }\n\n    private ActivityInfo getProviderInfo(ComponentName componentName, int userId) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setComponent(componentName);\n\n        List<ResolveInfo> receivers = queryIntentReceivers(intent, userId);\n        // We are setting component, so there is only one or none.\n        if (!receivers.isEmpty()) {\n            return receivers.get(0).activityInfo;\n        }\n\n        return null;\n    }\n\n    private List<ResolveInfo> queryIntentReceivers(Intent intent, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            int flags = PackageManager.GET_META_DATA;\n\n            // We really need packages to be around and parsed to know if they\n            // provide widgets.\n            flags |= PackageManager.MATCH_DEBUG_TRIAGED_MISSING;\n\n            // Widget hosts that are non-crypto aware may be hosting widgets\n            // from a profile that is still locked, so let them see those\n            // widgets.\n            if (isProfileWithUnlockedParent(userId)) {\n                flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE\n                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE;\n            }\n\n            // Widgets referencing shared libraries need to have their\n            // dependencies loaded.\n            flags |= PackageManager.GET_SHARED_LIBRARY_FILES;\n\n            return mPackageManager.queryIntentReceivers(intent,\n                    intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                    flags, userId).getList();\n        } catch (RemoteException re) {\n            return Collections.emptyList();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * This does not use the usual onUserUnlocked() listener mechanism because it is\n     * invoked at a choreographed point in the middle of the user unlock sequence,\n     * before the boot-completed broadcast is issued and the listeners notified.\n     */\n    void handleUserUnlocked(int userId) {\n        if (isProfileWithLockedParent(userId)) {\n            return;\n        }\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            Slog.w(TAG, \"User \" + userId + \" is no longer unlocked - exiting\");\n            return;\n        }\n        long time = SystemClock.elapsedRealtime();\n        synchronized (mLock) {\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget ensure\");\n            ensureGroupStateLoadedLocked(userId);\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget reload\");\n            reloadWidgetsMaskedStateForGroup(mSecurityPolicy.getGroupParent(userId));\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n\n                // Send broadcast only to the providers of the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n\n                if (provider.widgets.size() > 0) {\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,\n                            \"appwidget init \" + provider.id.componentName.getPackageName());\n                    sendEnableIntentLocked(provider);\n                    int[] appWidgetIds = getWidgetIds(provider.widgets);\n                    sendUpdateIntentLocked(provider, appWidgetIds);\n                    registerForBroadcastsLocked(provider, appWidgetIds);\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                }\n            }\n        }\n        Slog.i(TAG, \"Processing of handleUserUnlocked u\" + userId + \" took \"\n                + (SystemClock.elapsedRealtime() - time) + \" ms\");\n    }\n\n    // only call from initialization -- it assumes that the data structures are all empty\n    private void loadGroupStateLocked(int[] profileIds) {\n        // We can bind the widgets to host and providers only after\n        // reading the host and providers for all users since a widget\n        // can have a host and a provider in different users.\n        List<LoadedWidgetState> loadedWidgets = new ArrayList<>();\n\n        int version = 0;\n\n        final int profileIdCount = profileIds.length;\n        for (int i = 0; i < profileIdCount; i++) {\n            final int profileId = profileIds[i];\n\n            // No file written for this user - nothing to do.\n            AtomicFile file = getSavedStateFile(profileId);\n            try (FileInputStream stream = file.openRead()) {\n                version = readProfileStateFromFileLocked(stream, profileId, loadedWidgets);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to read state: \" + e);\n            }\n        }\n\n        if (version >= 0) {\n            // Hooke'm up...\n            bindLoadedWidgetsLocked(loadedWidgets);\n\n            // upgrade the database if needed\n            performUpgradeLocked(version);\n        } else {\n            // failed reading, clean up\n            Slog.w(TAG, \"Failed to read state, clearing widgets and hosts.\");\n            clearWidgetsLocked();\n            mHosts.clear();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                mProviders.get(i).widgets.clear();\n            }\n        }\n    }\n\n    private void bindLoadedWidgetsLocked(List<LoadedWidgetState> loadedWidgets) {\n        final int loadedWidgetCount = loadedWidgets.size();\n        for (int i = loadedWidgetCount - 1; i >= 0; i--) {\n            LoadedWidgetState loadedWidget = loadedWidgets.remove(i);\n            Widget widget = loadedWidget.widget;\n\n            widget.provider = findProviderByTag(loadedWidget.providerTag);\n            if (widget.provider == null) {\n                // This provider is gone. We just let the host figure out\n                // that this happened when it fails to load it.\n                continue;\n            }\n\n            widget.host = findHostByTag(loadedWidget.hostTag);\n            if (widget.host == null) {\n                // This host is gone.\n                continue;\n            }\n\n            widget.provider.widgets.add(widget);\n            widget.host.widgets.add(widget);\n            addWidgetLocked(widget);\n        }\n    }\n\n    private Provider findProviderByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.tag == tag) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host findHostByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            if (host.tag == tag) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n     */\n    void addWidgetLocked(Widget widget) {\n        mWidgets.add(widget);\n\n        onWidgetProviderAddedOrChangedLocked(widget);\n    }\n\n    /**\n     * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n     * that have bound widgets.\n     */\n    void onWidgetProviderAddedOrChangedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        int userId = widget.provider.getUserId();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                mWidgetPackages.put(userId, packages = new ArraySet<String>());\n            }\n            packages.add(widget.provider.id.componentName.getPackageName());\n        }\n\n        // If we are adding a widget it might be for a provider that\n        // is currently masked, if so mask the widget.\n        if (widget.provider.isMaskedLocked()) {\n            maskWidgetsViewsLocked(widget.provider, widget);\n        } else {\n            widget.clearMaskedViewsLocked();\n        }\n    }\n\n    /**\n     * Removes a widget from mWidgets and updates the cache of bound widget provider packages.\n     * If there are other widgets with the same package, leaves it in the cache, otherwise it\n     * removes the associated package from the cache.\n     */\n    void removeWidgetLocked(Widget widget) {\n        mWidgets.remove(widget);\n        onWidgetRemovedLocked(widget);\n        scheduleNotifyAppWidgetRemovedLocked(widget);\n    }\n\n    private void onWidgetRemovedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        final int userId = widget.provider.getUserId();\n        final String packageName = widget.provider.id.componentName.getPackageName();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                return;\n            }\n            // Check if there is any other widget with the same package name.\n            // Remove packageName if none.\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget w = mWidgets.get(i);\n                if (w.provider == null) continue;\n                if (w.provider.getUserId() == userId\n                        && packageName.equals(w.provider.id.componentName.getPackageName())) {\n                    return;\n                }\n            }\n            packages.remove(packageName);\n        }\n    }\n\n    /**\n     * Clears all widgets and associated cache of packages with bound widgets.\n     */\n    void clearWidgetsLocked() {\n        mWidgets.clear();\n\n        onWidgetsClearedLocked();\n    }\n\n    private void onWidgetsClearedLocked() {\n        synchronized (mWidgetPackagesLock) {\n            mWidgetPackages.clear();\n        }\n    }\n\n    @Override\n    public boolean isBoundWidgetPackage(String packageName, int userId) {\n        if (Binder.getCallingUid() != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Only the system process can call this\");\n        }\n        synchronized (mWidgetPackagesLock) {\n            final ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages != null) {\n                return packages.contains(packageName);\n            }\n        }\n        return false;\n    }\n\n    private void saveStateLocked(int userId) {\n        tagProvidersAndHosts();\n\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            AtomicFile file = getSavedStateFile(profileId);\n            FileOutputStream stream;\n            try {\n                stream = file.startWrite();\n                if (writeProfileStateToFileLocked(stream, profileId)) {\n                    file.finishWrite(stream);\n                } else {\n                    file.failWrite(stream);\n                    Slog.w(TAG, \"Failed to save state, restoring backup.\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed open state file for write: \" + e);\n            }\n        }\n    }\n\n    private void tagProvidersAndHosts() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = i;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = i;\n        }\n    }\n\n    private void clearProvidersAndHostsTagsLocked() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = TAG_UNDEFINED;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = TAG_UNDEFINED;\n        }\n    }\n\n    private boolean writeProfileStateToFileLocked(FileOutputStream stream, int userId) {\n        int N;\n\n        try {\n            TypedXmlSerializer out = Xml.resolveSerializer(stream);\n            out.startDocument(null, true);\n            out.startTag(null, \"gs\");\n            out.attributeInt(null, \"version\", CURRENT_VERSION);\n\n            N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                // Save only providers for the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n                if (provider.shouldBePersisted()) {\n                    serializeProvider(out, provider);\n                }\n            }\n\n            N = mHosts.size();\n            for (int i = 0; i < N; i++) {\n                Host host = mHosts.get(i);\n                // Save only hosts for the user.\n                if (host.getUserId() != userId) {\n                    continue;\n                }\n                serializeHost(out, host);\n            }\n\n            N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                // Save only widgets hosted by the user.\n                if (widget.host.getUserId() != userId) {\n                    continue;\n                }\n                serializeAppWidget(out, widget, true);\n            }\n\n            Iterator<Pair<Integer, String>> it = mPackagesWithBindWidgetPermission.iterator();\n            while (it.hasNext()) {\n                Pair<Integer, String> binding = it.next();\n                // Save only white listings for the user.\n                if (binding.first != userId) {\n                    continue;\n                }\n                out.startTag(null, \"b\");\n                out.attribute(null, \"packageName\", binding.second);\n                out.endTag(null, \"b\");\n            }\n\n            out.endTag(null, \"gs\");\n            out.endDocument();\n            return true;\n        } catch (IOException e) {\n            Slog.w(TAG, \"Failed to write state: \" + e);\n            return false;\n        }\n    }\n\n    private int readProfileStateFromFileLocked(FileInputStream stream, int userId,\n            List<LoadedWidgetState> outLoadedWidgets) {\n        int version = -1;\n        try {\n            TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n\n            int legacyProviderIndex = -1;\n            int legacyHostIndex = -1;\n            int type;\n            do {\n                type = parser.next();\n                if (type == XmlPullParser.START_TAG) {\n                    String tag = parser.getName();\n                    if (\"gs\".equals(tag)) {\n                        version = parser.getAttributeInt(null, \"version\", 0);\n                    } else if (\"p\".equals(tag)) {\n                        legacyProviderIndex++;\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n                        String cl = parser.getAttributeValue(null, \"cl\");\n\n                        pkg = getCanonicalPackageName(pkg, cl, userId);\n                        if (pkg == null) {\n                            continue;\n                        }\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            continue;\n                        }\n\n                        ComponentName componentName = new ComponentName(pkg, cl);\n\n                        ActivityInfo providerInfo = getProviderInfo(componentName, userId);\n                        if (providerInfo == null) {\n                            continue;\n                        }\n\n                        ProviderId providerId = new ProviderId(uid, componentName);\n                        Provider provider = lookupProviderLocked(providerId);\n\n                        if (provider == null && mSafeMode) {\n                            // if we're in safe mode, make a temporary one\n                            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                            info.provider = providerId.componentName;\n                            info.providerInfo = providerInfo;\n\n                            provider = new Provider();\n                            provider.setPartialInfoLocked(info);\n                            provider.zombie = true;\n                            provider.id = providerId;\n                            mProviders.add(provider);\n                        }\n\n                        final int providerTag = parser.getAttributeIntHex(null, \"tag\",\n                                legacyProviderIndex);\n                        provider.tag = providerTag;\n                        provider.infoTag = parser.getAttributeValue(null, \"info_tag\");\n                    } else if (\"h\".equals(tag)) {\n                        legacyHostIndex++;\n                        Host host = new Host();\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            host.zombie = true;\n                        }\n\n                        if (!host.zombie || mSafeMode) {\n                            // In safe mode, we don't discard the hosts we don't recognize\n                            // so that they're not pruned from our list. Otherwise, we do.\n                            final int hostId = parser.getAttributeIntHex(null, \"id\");\n                            final int hostTag = parser.getAttributeIntHex(null, \"tag\",\n                                    legacyHostIndex);\n\n                            host.tag = hostTag;\n                            host.id = new HostId(uid, hostId, pkg);\n                            mHosts.add(host);\n                        }\n                    } else if (\"b\".equals(tag)) {\n                        String packageName = parser.getAttributeValue(null, \"packageName\");\n                        final int uid = getUidForPackage(packageName, userId);\n                        if (uid >= 0) {\n                            Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                            mPackagesWithBindWidgetPermission.add(packageId);\n                        }\n                    } else if (\"g\".equals(tag)) {\n                        Widget widget = new Widget();\n                        widget.appWidgetId = parser.getAttributeIntHex(null, \"id\");\n                        setMinAppWidgetIdLocked(userId, widget.appWidgetId + 1);\n\n                        // restored ID is allowed to be absent\n                        widget.restoredId = parser.getAttributeIntHex(null, \"rid\", 0);\n                        widget.options = parseWidgetIdOptions(parser);\n\n                        final int hostTag = parser.getAttributeIntHex(null, \"h\");\n                        String providerString = parser.getAttributeValue(null, \"p\");\n                        final int providerTag = (providerString != null)\n                                ? parser.getAttributeIntHex(null, \"p\") : TAG_UNDEFINED;\n\n                        // We can match widgets with hosts and providers only after hosts\n                        // and providers for all users have been loaded since the widget\n                        // host and provider can be in different user profiles.\n                        LoadedWidgetState loadedWidgets = new LoadedWidgetState(widget,\n                                hostTag, providerTag);\n                        outLoadedWidgets.add(loadedWidgets);\n                    }\n                }\n            } while (type != XmlPullParser.END_DOCUMENT);\n        } catch (NullPointerException\n                | NumberFormatException\n                | XmlPullParserException\n                | IOException\n                | IndexOutOfBoundsException e) {\n            Slog.w(TAG, \"failed parsing \" + e);\n            return -1;\n        }\n\n        return version;\n    }\n\n    private void performUpgradeLocked(int fromVersion) {\n        if (fromVersion < CURRENT_VERSION) {\n            Slog.v(TAG, \"Upgrading widget database from \" + fromVersion + \" to \"\n                    + CURRENT_VERSION);\n        }\n\n        int version = fromVersion;\n\n        // Update 1: keyguard moved from package \"android\" to \"com.android.keyguard\"\n        if (version == 0) {\n            HostId oldHostId = new HostId(Process.myUid(),\n                    KEYGUARD_HOST_ID, OLD_KEYGUARD_HOST_PACKAGE);\n\n            Host host = lookupHostLocked(oldHostId);\n            if (host != null) {\n                final int uid = getUidForPackage(NEW_KEYGUARD_HOST_PACKAGE,\n                        UserHandle.USER_SYSTEM);\n                if (uid >= 0) {\n                    host.id = new HostId(uid, KEYGUARD_HOST_ID, NEW_KEYGUARD_HOST_PACKAGE);\n                }\n            }\n\n            version = 1;\n        }\n\n        if (version != CURRENT_VERSION) {\n            throw new IllegalStateException(\"Failed to upgrade widget database\");\n        }\n    }\n\n    private static File getStateFile(int userId) {\n        return new File(Environment.getUserSystemDirectory(userId), STATE_FILENAME);\n    }\n\n    private static AtomicFile getSavedStateFile(int userId) {\n        File dir = Environment.getUserSystemDirectory(userId);\n        File settingsFile = getStateFile(userId);\n        if (!settingsFile.exists() && userId == UserHandle.USER_SYSTEM) {\n            if (!dir.exists()) {\n                dir.mkdirs();\n            }\n            // Migrate old data\n            File oldFile = new File(\"/data/system/\" + STATE_FILENAME);\n            // Method doesn't throw an exception on failure. Ignore any errors\n            // in moving the file (like non-existence)\n            oldFile.renameTo(settingsFile);\n        }\n        return new AtomicFile(settingsFile);\n    }\n\n    void onUserStopped(int userId) {\n        synchronized (mLock) {\n            boolean crossProfileWidgetsChanged = false;\n\n            // Remove widgets that have both host and provider in the user.\n            final int widgetCount = mWidgets.size();\n            for (int i = widgetCount - 1; i >= 0; i--) {\n                Widget widget = mWidgets.get(i);\n\n                final boolean hostInUser = widget.host.getUserId() == userId;\n                final boolean hasProvider = widget.provider != null;\n                final boolean providerInUser = hasProvider && widget.provider.getUserId() == userId;\n\n                // If both host and provider are in the user, just drop the widgets\n                // as we do not want to make host callbacks and provider broadcasts\n                // as the host and the provider will be killed.\n                if (hostInUser && (!hasProvider || providerInUser)) {\n                    removeWidgetLocked(widget);\n                    widget.host.widgets.remove(widget);\n                    widget.host = null;\n                    if (hasProvider) {\n                        widget.provider.widgets.remove(widget);\n                        widget.provider = null;\n                    }\n                }\n            }\n\n            // Remove hosts and notify providers in other profiles.\n            final int hostCount = mHosts.size();\n            for (int i = hostCount - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n                if (host.getUserId() == userId) {\n                    crossProfileWidgetsChanged |= !host.widgets.isEmpty();\n                    deleteHostLocked(host);\n                }\n            }\n\n            // Leave the providers present as hosts will show the widgets\n            // masked while the user is stopped.\n\n            // Remove grants for this user.\n            final int grantCount = mPackagesWithBindWidgetPermission.size();\n            for (int i = grantCount - 1; i >= 0; i--) {\n                Pair<Integer, String> packageId = mPackagesWithBindWidgetPermission.valueAt(i);\n                if (packageId.first == userId) {\n                    mPackagesWithBindWidgetPermission.removeAt(i);\n                }\n            }\n\n            // Take a note we no longer have state for this user.\n            final int userIndex = mLoadedUserIds.indexOfKey(userId);\n            if (userIndex >= 0) {\n                mLoadedUserIds.removeAt(userIndex);\n            }\n\n            // Remove the widget id counter.\n            final int nextIdIndex = mNextAppWidgetIds.indexOfKey(userId);\n            if (nextIdIndex >= 0) {\n                mNextAppWidgetIds.removeAt(nextIdIndex);\n            }\n\n            // Save state if removing a profile changed the group state.\n            // Nothing will be saved if the group parent was removed.\n            if (crossProfileWidgetsChanged) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    private void applyResourceOverlaysToWidgetsLocked(Set<String> packageNames, int userId,\n            boolean updateFrameworkRes) {\n        for (int i = 0, N = mProviders.size(); i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.getUserId() != userId) {\n                continue;\n            }\n\n            final String packageName = provider.id.componentName.getPackageName();\n            if (!updateFrameworkRes && !packageNames.contains(packageName)) {\n                continue;\n            }\n\n            ApplicationInfo newAppInfo = null;\n            try {\n                newAppInfo = mPackageManager.getApplicationInfo(packageName,\n                        PackageManager.GET_SHARED_LIBRARY_FILES, userId);\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"Failed to retrieve app info for \" + packageName\n                        + \" userId=\" + userId, e);\n            }\n            if (newAppInfo == null || provider.info == null\n                    || provider.info.providerInfo == null) {\n                continue;\n            }\n            ApplicationInfo oldAppInfo = provider.info.providerInfo.applicationInfo;\n            if (oldAppInfo == null || !newAppInfo.sourceDir.equals(oldAppInfo.sourceDir)) {\n                // Overlay paths are generated against a particular version of an application.\n                // The overlays paths of a newly upgraded application are incompatible with the\n                // old version of the application.\n                continue;\n            }\n\n            // Isolate the changes relating to RROs. The app info must be copied to prevent\n            // affecting other parts of system server that may have cached this app info.\n            oldAppInfo = new ApplicationInfo(oldAppInfo);\n            oldAppInfo.overlayPaths = newAppInfo.overlayPaths.clone();\n            oldAppInfo.resourceDirs = newAppInfo.resourceDirs.clone();\n            provider.info.providerInfo.applicationInfo = oldAppInfo;\n\n            for (int j = 0, M = provider.widgets.size(); j < M; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (widget.views != null) {\n                    widget.views.updateAppInfo(oldAppInfo);\n                }\n                if (widget.maskedViews != null) {\n                    widget.maskedViews.updateAppInfo(oldAppInfo);\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates all providers with the specified package names, and records any providers that were\n     * pruned.\n     *\n     * @return whether any providers were updated\n     */\n    private boolean updateProvidersForPackageLocked(String packageName, int userId,\n            Set<ProviderId> removedProviders) {\n        boolean providersUpdated = false;\n\n        HashSet<ProviderId> keep = new HashSet<>();\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setPackage(packageName);\n        List<ResolveInfo> broadcastReceivers = queryIntentReceivers(intent, userId);\n\n        // add the missing ones and collect which ones to keep\n        int N = broadcastReceivers == null ? 0 : broadcastReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo ri = broadcastReceivers.get(i);\n            ActivityInfo ai = ri.activityInfo;\n\n            if ((ai.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n                continue;\n            }\n\n            if (packageName.equals(ai.packageName)) {\n                ProviderId providerId = new ProviderId(ai.applicationInfo.uid,\n                        new ComponentName(ai.packageName, ai.name));\n\n                Provider provider = lookupProviderLocked(providerId);\n                if (provider == null) {\n                    if (addProviderLocked(ri)) {\n                        keep.add(providerId);\n                        providersUpdated = true;\n                    }\n                } else {\n                    AppWidgetProviderInfo info =\n                            createPartialProviderInfo(providerId, ri, provider);\n                    if (info != null) {\n                        keep.add(providerId);\n                        // Use the new AppWidgetProviderInfo.\n                        provider.setPartialInfoLocked(info);\n                        // If it's enabled\n                        final int M = provider.widgets.size();\n                        if (M > 0) {\n                            int[] appWidgetIds = getWidgetIds(provider.widgets);\n                            // Reschedule for the new updatePeriodMillis (don't worry about handling\n                            // it specially if updatePeriodMillis didn't change because we just sent\n                            // an update, and the next one will be updatePeriodMillis from now).\n                            cancelBroadcastsLocked(provider);\n                            registerForBroadcastsLocked(provider, appWidgetIds);\n                            // If it's currently showing, call back with the new\n                            // AppWidgetProviderInfo.\n                            for (int j = 0; j < M; j++) {\n                                Widget widget = provider.widgets.get(j);\n                                widget.views = null;\n                                scheduleNotifyProviderChangedLocked(widget);\n                            }\n                            // Now that we've told the host, push out an update.\n                            sendUpdateIntentLocked(provider, appWidgetIds);\n                        }\n                    }\n                    providersUpdated = true;\n                }\n            }\n        }\n\n        // prune the ones we don't want to keep\n        N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (packageName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && !keep.contains(provider.id)) {\n                if (removedProviders != null) {\n                    removedProviders.add(provider.id);\n                }\n                deleteProviderLocked(provider);\n                providersUpdated = true;\n            }\n        }\n\n        return providersUpdated;\n    }\n\n    // Remove widgets for provider in userId that are hosted in parentUserId\n    private void removeWidgetsForPackageLocked(String pkgName, int userId, int parentUserId) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; ++i) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && provider.widgets.size() > 0) {\n                deleteWidgetsLocked(provider, parentUserId);\n            }\n        }\n    }\n\n    private boolean removeProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = false;\n\n        final int N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId) {\n                deleteProviderLocked(provider);\n                removed = true;\n            }\n        }\n        return removed;\n    }\n\n    private boolean removeHostsAndProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = removeProvidersForPackageLocked(pkgName, userId);\n\n        // Delete the hosts for this package too\n        // By now, we have removed any AppWidgets that were in any hosts here,\n        // so we don't need to worry about sending DISABLE broadcasts to them.\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n            if (pkgName.equals(host.id.packageName)\n                    && host.getUserId() == userId) {\n                deleteHostLocked(host);\n                removed = true;\n            }\n        }\n\n        return removed;\n    }\n\n    private String getCanonicalPackageName(String packageName, String className, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            try {\n                AppGlobals.getPackageManager().getReceiverInfo(new ComponentName(packageName,\n                        className), 0, userId);\n                return packageName;\n            } catch (RemoteException re) {\n                String[] packageNames = mContext.getPackageManager()\n                        .currentToCanonicalPackageNames(new String[]{packageName});\n                if (packageNames != null && packageNames.length > 0) {\n                    return packageNames[0];\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return null;\n    }\n\n    private void sendBroadcastAsUser(Intent intent, UserHandle userHandle) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            mContext.sendBroadcastAsUser(intent, userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void bindService(Intent intent, ServiceConnection connection,\n            UserHandle userHandle) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, connection,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void unbindService(ServiceConnection connection) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.unbindService(connection);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void onCrossProfileWidgetProvidersChanged(int userId, List<String> packages) {\n        final int parentId = mSecurityPolicy.getProfileParent(userId);\n        // We care only if the allowlisted package is in a profile of\n        // the group parent as only the parent can add widgets from the\n        // profile and not the other way around.\n        if (parentId != userId) {\n            synchronized (mLock) {\n                boolean providersChanged = false;\n\n                ArraySet<String> previousPackages = new ArraySet<String>();\n                final int providerCount = mProviders.size();\n                for (int i = 0; i < providerCount; ++i) {\n                    Provider provider = mProviders.get(i);\n                    if (provider.getUserId() == userId) {\n                        previousPackages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n\n                final int packageCount = packages.size();\n                for (int i = 0; i < packageCount; i++) {\n                    String packageName = packages.get(i);\n                    previousPackages.remove(packageName);\n                    providersChanged |= updateProvidersForPackageLocked(packageName,\n                            userId, null);\n                }\n\n                // Remove widgets from hosts in parent user for packages not in the allowlist\n                final int removedCount = previousPackages.size();\n                for (int i = 0; i < removedCount; ++i) {\n                    removeWidgetsForPackageLocked(previousPackages.valueAt(i),\n                            userId, parentId);\n                }\n\n                if (providersChanged || removedCount > 0) {\n                    saveGroupStateAsync(userId);\n                    scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                }\n            }\n        }\n    }\n\n    private boolean isProfileWithLockedParent(int userId) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            UserInfo userInfo = mUserManager.getUserInfo(userId);\n            if (userInfo != null && userInfo.isProfile()) {\n                UserInfo parentInfo = mUserManager.getProfileParent(userId);\n                if (parentInfo != null\n                        && !isUserRunningAndUnlocked(parentInfo.getUserHandle().getIdentifier())) {\n                    return true;\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return false;\n    }\n\n    private boolean isProfileWithUnlockedParent(int userId) {\n        UserInfo userInfo = mUserManager.getUserInfo(userId);\n        if (userInfo != null && userInfo.isProfile()) {\n            UserInfo parentInfo = mUserManager.getProfileParent(userId);\n            if (parentInfo != null\n                    && mUserManager.isUserUnlockingOrUnlocked(parentInfo.getUserHandle())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Note an app widget is tapped on. If a app widget is tapped, the underlying app is treated as\n     * foreground so the app can get while-in-use permission.\n     *\n     * @param callingPackage calling app's packageName.\n     * @param appWidgetId App widget id.\n     */\n    @Override\n    public void noteAppWidgetTapped(String callingPackage, int appWidgetId) {\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        final int callingUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            // The launcher must be at TOP.\n            final int procState = mActivityManagerInternal.getUidProcessState(callingUid);\n            if (procState > ActivityManager.PROCESS_STATE_TOP) {\n                return;\n            }\n            synchronized (mLock) {\n                final Widget widget = lookupWidgetLocked(appWidgetId, callingUid, callingPackage);\n                if (widget == null) {\n                    return;\n                }\n                final ProviderId providerId = widget.provider.id;\n                final String packageName = providerId.componentName.getPackageName();\n                if (packageName == null) {\n                    return;\n                }\n                final SparseArray<String> uid2PackageName = new SparseArray<String>();\n                uid2PackageName.put(providerId.uid, packageName);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(uid2PackageName, true);\n                mUsageStatsManagerInternal.reportEvent(packageName,\n                        UserHandle.getUserId(providerId.uid), UsageEvents.Event.USER_INTERACTION);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private final class CallbackHandler extends Handler {\n        public static final int MSG_NOTIFY_UPDATE_APP_WIDGET = 1;\n        public static final int MSG_NOTIFY_PROVIDER_CHANGED = 2;\n        public static final int MSG_NOTIFY_PROVIDERS_CHANGED = 3;\n        public static final int MSG_NOTIFY_VIEW_DATA_CHANGED = 4;\n        public static final int MSG_NOTIFY_APP_WIDGET_REMOVED = 5;\n\n        public CallbackHandler(Looper looper) {\n            super(looper, null, false);\n        }\n\n        @Override\n        public void handleMessage(Message message) {\n            switch (message.what) {\n                case MSG_NOTIFY_UPDATE_APP_WIDGET: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    RemoteViews views = (RemoteViews) args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyUpdateAppWidget(host, callbacks, appWidgetId, views, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDER_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    AppWidgetProviderInfo info = (AppWidgetProviderInfo)args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyProviderChanged(host, callbacks, appWidgetId, info, requestId);\n                } break;\n\n                case MSG_NOTIFY_APP_WIDGET_REMOVED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n                    handleNotifyAppWidgetRemoved(host, callbacks, appWidgetId, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDERS_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    args.recycle();\n\n                    handleNotifyProvidersChanged(host, callbacks);\n                } break;\n\n                case MSG_NOTIFY_VIEW_DATA_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    final int viewId = args.argi2;\n                    args.recycle();\n\n                    handleNotifyAppWidgetViewDataChanged(host, callbacks, appWidgetId, viewId,\n                            requestId);\n                } break;\n            }\n        }\n    }\n\n    private final class SecurityPolicy {\n\n        public boolean isEnabledGroupProfile(int profileId) {\n            final int parentId = UserHandle.getCallingUserId();\n            return isParentOrProfile(parentId, profileId) && isProfileEnabled(profileId);\n        }\n\n        public int[] getEnabledGroupProfileIds(int userId) {\n            final int parentId = getGroupParent(userId);\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mUserManager.getEnabledProfileIds(parentId);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                ComponentName componentName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                ServiceInfo serviceInfo = mPackageManager.getServiceInfo(componentName,\n                        PackageManager.GET_PERMISSIONS, userId);\n                if (serviceInfo == null) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" not installed for user \" + userId);\n                }\n                if (!android.Manifest.permission.BIND_REMOTEVIEWS.equals(serviceInfo.permission)) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" in user \" + userId + \"does not require \"\n                            + android.Manifest.permission.BIND_REMOTEVIEWS);\n                }\n            } catch (RemoteException re) {\n                // Local call - shouldn't happen.\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceModifyAppWidgetBindPermissions(String packageName) {\n            mContext.enforceCallingPermission(\n                    android.Manifest.permission.MODIFY_APPWIDGET_BIND_PERMISSIONS,\n                    \"hasBindAppWidgetPermission packageName=\" + packageName);\n        }\n\n        public boolean isCallerInstantAppLocked() {\n            final int callingUid =  Binder.getCallingUid();\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final String[] uidPackages = mPackageManager.getPackagesForUid(callingUid);\n                if (!ArrayUtils.isEmpty(uidPackages)) {\n                    return mPackageManager.isInstantApp(uidPackages[0],\n                            UserHandle.getUserId(callingUid));\n                }\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public boolean isInstantAppLocked(String packageName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mPackageManager.isInstantApp(packageName, userId);\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public void enforceCallFromPackage(String packageName) {\n            mAppOpsManager.checkPackage(Binder.getCallingUid(), packageName);\n        }\n\n        public boolean hasCallerBindPermissionOrBindWhiteListedLocked(String packageName) {\n            try {\n                mContext.enforceCallingOrSelfPermission(\n                        android.Manifest.permission.BIND_APPWIDGET, null);\n            } catch (SecurityException se) {\n                if (!isCallerBindAppWidgetWhiteListedLocked(packageName)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean isCallerBindAppWidgetWhiteListedLocked(String packageName) {\n            final int userId = UserHandle.getCallingUserId();\n            final int packageUid = getUidForPackage(packageName, userId);\n            if (packageUid < 0) {\n                throw new IllegalArgumentException(\"No package \" + packageName\n                        + \" for user \" + userId);\n            }\n            synchronized (mLock) {\n                ensureGroupStateLoadedLocked(userId);\n\n                Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                if (mPackagesWithBindWidgetPermission.contains(packageId)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        public boolean canAccessAppWidget(Widget widget, int uid, String packageName) {\n            if (isHostInPackageForUid(widget.host, uid, packageName)) {\n                // Apps hosting the AppWidget have access to it.\n                return true;\n            }\n            if (isProviderInPackageForUid(widget.provider, uid, packageName)) {\n                // Apps providing the AppWidget have access to it.\n                return true;\n            }\n            if (isHostAccessingProvider(widget.host, widget.provider, uid, packageName)) {\n                // Apps hosting the AppWidget get to bind to a remote view service in the provider.\n                return true;\n            }\n            final int userId = UserHandle.getUserId(uid);\n            if ((widget.host.getUserId() == userId || (widget.provider != null\n                    && widget.provider.getUserId() == userId))\n                && mContext.checkCallingPermission(android.Manifest.permission.BIND_APPWIDGET)\n                    == PackageManager.PERMISSION_GRANTED) {\n                // Apps that run in the same user as either the host or the provider and\n                // have the bind widget permission have access to the widget.\n                return true;\n            }\n            return false;\n        }\n\n        private boolean isParentOrProfile(int parentId, int profileId) {\n            if (parentId == profileId) {\n                return true;\n            }\n            return getProfileParent(profileId) == parentId;\n        }\n\n        public boolean isProviderInCallerOrInProfileAndWhitelListed(String packageName,\n                int profileId) {\n            final int callerId = UserHandle.getCallingUserId();\n            if (profileId == callerId) {\n                return true;\n            }\n            final int parentId = getProfileParent(profileId);\n            if (parentId != callerId) {\n                return false;\n            }\n            return isProviderWhiteListed(packageName, profileId);\n        }\n\n        public boolean isProviderWhiteListed(String packageName, int profileId) {\n            // If the policy manager is not available on the device we deny it all.\n            if (mDevicePolicyManagerInternal == null) {\n                return false;\n            }\n\n            List<String> crossProfilePackages = mDevicePolicyManagerInternal\n                    .getCrossProfileWidgetProviders(profileId);\n\n            return crossProfilePackages.contains(packageName);\n        }\n\n        public int getProfileParent(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo parent = mUserManager.getProfileParent(profileId);\n                if (parent != null) {\n                    return parent.getUserHandle().getIdentifier();\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return UNKNOWN_USER_ID;\n        }\n\n        public int getGroupParent(int profileId) {\n            final int parentId = mSecurityPolicy.getProfileParent(profileId);\n            return (parentId != UNKNOWN_USER_ID) ? parentId : profileId;\n        }\n\n        public boolean isHostInPackageForUid(Host host, int uid, String packageName) {\n            return host.id.uid == uid && host.id.packageName.equals(packageName);\n        }\n\n        public boolean isProviderInPackageForUid(Provider provider, int uid,\n                String packageName) {\n            // Packages providing the AppWidget have access to it.\n            return provider != null && provider.id.uid == uid\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        public boolean isHostAccessingProvider(Host host, Provider provider, int uid,\n                String packageName) {\n            // The host creates a package context to bind to remote views service in the provider.\n            return host.id.uid == uid && provider != null\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        private boolean isProfileEnabled(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo userInfo = mUserManager.getUserInfo(profileId);\n                if (userInfo == null || !userInfo.isEnabled()) {\n                    return false;\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return true;\n        }\n    }\n\n    private static final class Provider {\n\n        ProviderId id;\n        AppWidgetProviderInfo info;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        PendingIntent broadcast;\n        String infoTag;\n\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        boolean maskedByLockedProfile;\n        boolean maskedByQuietProfile;\n        boolean maskedBySuspendedPackage;\n\n        boolean mInfoParsed = false;\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId\n                    && id.componentName.getPackageName().equals(packageName);\n        }\n\n        // is there an instance of this provider hosted by the given app?\n        public boolean hostedByPackageForUser(String packageName, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (packageName.equals(widget.host.id.packageName)\n                        && widget.host.getUserId() == userId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getInfoLocked(Context context) {\n            if (!mInfoParsed) {\n                // parse\n                if (!zombie) {\n                    AppWidgetProviderInfo newInfo = null;\n                    if (!TextUtils.isEmpty(infoTag)) {\n                        newInfo = parseAppWidgetProviderInfo(\n                                context, id, info.providerInfo, infoTag);\n                    }\n                    if (newInfo == null) {\n                        newInfo = parseAppWidgetProviderInfo(context, id, info.providerInfo,\n                                AppWidgetManager.META_DATA_APPWIDGET_PROVIDER);\n                    }\n                    if (newInfo != null) {\n                        info = newInfo;\n                    }\n                }\n                mInfoParsed = true;\n            }\n            return info;\n        }\n\n        /**\n         * Returns the last updated AppWidgetProviderInfo for this provider. This info may not\n         * be completely parsed and only contain placeHolder information like\n         * {@link AppWidgetProviderInfo#providerInfo}\n         */\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getPartialInfoLocked() {\n            return info;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setPartialInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = true;\n        }\n\n        @Override\n        public String toString() {\n            return \"Provider{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByQuietProfileLocked(boolean masked) {\n            boolean oldState = maskedByQuietProfile;\n            maskedByQuietProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByLockedProfileLocked(boolean masked) {\n            boolean oldState = maskedByLockedProfile;\n            maskedByLockedProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedBySuspendedPackageLocked(boolean masked) {\n            boolean oldState = maskedBySuspendedPackage;\n            maskedBySuspendedPackage = masked;\n            return masked != oldState;\n        }\n\n        public boolean isMaskedLocked() {\n            return maskedByQuietProfile || maskedByLockedProfile || maskedBySuspendedPackage;\n        }\n\n        public boolean shouldBePersisted() {\n            return !widgets.isEmpty() || !TextUtils.isEmpty(infoTag);\n        }\n    }\n\n    private static final class ProviderId {\n        final int uid;\n        final ComponentName componentName;\n\n        private ProviderId(int uid, ComponentName componentName) {\n            this.uid = uid;\n            this.componentName = componentName;\n        }\n\n        public UserHandle getProfile() {\n            return UserHandle.getUserHandleForUid(uid);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            ProviderId other = (ProviderId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (componentName == null) {\n                if (other.componentName != null) {\n                    return false;\n                }\n            } else if (!componentName.equals(other.componentName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + ((componentName != null)\n                    ? componentName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"ProviderId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", cmp:\" + componentName + '}';\n        }\n    }\n\n    private static final class Host {\n        HostId id;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        IAppWidgetHost callbacks;\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n        // Sequence no for the last update successfully sent. This is updated whenever a\n        // widget update is successfully sent to the host callbacks. As all new/undelivered updates\n        // will have sequenceNo greater than this, all those updates will be sent when the host\n        // callbacks are attached again.\n        long lastWidgetUpdateSequenceNo;\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId && id.packageName.equals(packageName);\n        }\n\n        private boolean hostsPackageForUser(String pkg, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = widgets.get(i).provider;\n                if (provider != null && provider.getUserId() == userId\n                        && pkg.equals(provider.id.componentName.getPackageName())) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Adds all pending updates in {@param outUpdates} keys by the update time.\n         */\n        public void getPendingUpdatesForIdLocked(Context context, int appWidgetId,\n                LongSparseArray<PendingHostUpdate> outUpdates) {\n            long updateSequenceNo = lastWidgetUpdateSequenceNo;\n            int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (widget.appWidgetId == appWidgetId) {\n                    for (int j = widget.updateSequenceNos.size() - 1; j >= 0; j--) {\n                        long requestId = widget.updateSequenceNos.valueAt(j);\n                        if (requestId <= updateSequenceNo) {\n                            continue;\n                        }\n                        int id = widget.updateSequenceNos.keyAt(j);\n                        final PendingHostUpdate update;\n                        switch (id) {\n                            case ID_PROVIDER_CHANGED:\n                                update = PendingHostUpdate.providerChanged(\n                                        appWidgetId, widget.provider.getInfoLocked(context));\n                                break;\n                            case ID_VIEWS_UPDATE:\n                                update = PendingHostUpdate.updateAppWidget(appWidgetId,\n                                        cloneIfLocalBinder(widget.getEffectiveViewsLocked()));\n                                break;\n                            default:\n                                update = PendingHostUpdate.viewDataChanged(appWidgetId, id);\n                        }\n                        outUpdates.put(requestId, update);\n                    }\n                    return;\n                }\n            }\n            outUpdates.put(lastWidgetUpdateSequenceNo,\n                    PendingHostUpdate.appWidgetRemoved(appWidgetId));\n        }\n\n        public SparseArray<String> getWidgetUids() {\n            final SparseArray<String> uids = new SparseArray<>();\n            for (int i = widgets.size() - 1; i >= 0; i--) {\n                final Widget widget = widgets.get(i);\n                final ProviderId providerId = widget.provider.id;\n                uids.put(providerId.uid, providerId.componentName.getPackageName());\n            }\n            return uids;\n        }\n\n        @Override\n        public String toString() {\n            return \"Host{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n    }\n\n    private static final class HostId {\n        final int uid;\n        final int hostId;\n        final String packageName;\n\n        public HostId(int uid, int hostId, String packageName) {\n            this.uid = uid;\n            this.hostId = hostId;\n            this.packageName = packageName;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            HostId other = (HostId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (hostId != other.hostId) {\n                return false;\n            }\n            if (packageName == null) {\n                if (other.packageName != null) {\n                    return false;\n                }\n            } else if (!packageName.equals(other.packageName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + hostId;\n            result = 31 * result + ((packageName != null)\n                    ? packageName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"HostId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", hostId:\" + hostId\n                    + \", pkg:\" + packageName + '}';\n        }\n    }\n\n    // These can be any constants that would not collide with a resource id.\n    private static final int ID_VIEWS_UPDATE = 0;\n    private static final int ID_PROVIDER_CHANGED = 1;\n\n    private static final class Widget {\n        int appWidgetId;\n        int restoredId;  // tracking & remapping any restored state\n        Provider provider;\n        RemoteViews views;\n        RemoteViews maskedViews;\n        Bundle options;\n        Host host;\n        // Map of request type to updateSequenceNo.\n        SparseLongArray updateSequenceNos = new SparseLongArray(2);\n\n        @Override\n        public String toString() {\n            return \"AppWidgetId{\" + appWidgetId + ':' + host + ':' + provider + '}';\n        }\n\n        private boolean replaceWithMaskedViewsLocked(RemoteViews views) {\n            maskedViews = views;\n            return true;\n        }\n\n        private boolean clearMaskedViewsLocked() {\n            if (maskedViews != null) {\n                maskedViews = null;\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        public RemoteViews getEffectiveViewsLocked() {\n            return maskedViews != null ? maskedViews : views;\n        }\n    }\n\n    private class LoadedWidgetState {\n        final Widget widget;\n        final int hostTag;\n        final int providerTag;\n\n        public LoadedWidgetState(Widget widget, int hostTag, int providerTag) {\n            this.widget = widget;\n            this.hostTag = hostTag;\n            this.providerTag = providerTag;\n        }\n    }\n\n    private final class SaveStateRunnable implements Runnable {\n        final int mUserId;\n\n        public SaveStateRunnable(int userId) {\n            mUserId = userId;\n        }\n\n        @Override\n        public void run() {\n            synchronized (mLock) {\n                // No need to enforce unlocked state when there is no caller. User can be in the\n                // stopping state or removed by the time the message is processed\n                ensureGroupStateLoadedLocked(mUserId, false /* enforceUserUnlockingOrUnlocked */ );\n                saveStateLocked(mUserId);\n            }\n        }\n    }\n\n    /**\n     * This class encapsulates the backup and restore logic for a user group state.\n     */\n    private final class BackupRestoreController {\n        private static final String TAG = \"BackupRestoreController\";\n\n        private static final boolean DEBUG = true;\n\n        // Version of backed-up widget state.\n        private static final int WIDGET_STATE_VERSION = 2;\n\n        // We need to make sure to wipe the pre-restore widget state only once for\n        // a given package.  Keep track of what we've done so far here; the list is\n        // cleared at the start of every system restore pass, but preserved through\n        // any install-time restore operations.\n        private final HashSet<String> mPrunedApps = new HashSet<>();\n\n        private final HashMap<Provider, ArrayList<RestoreUpdateRecord>> mUpdatesByProvider =\n                new HashMap<>();\n        private final HashMap<Host, ArrayList<RestoreUpdateRecord>> mUpdatesByHost =\n                new HashMap<>();\n\n        @GuardedBy(\"mLock\")\n        private boolean mHasSystemRestoreFinished;\n\n        public List<String> getWidgetParticipants(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget participants for user: \" + userId);\n            }\n\n            HashSet<String> packages = new HashSet<>();\n            synchronized (mLock) {\n                final int N = mWidgets.size();\n                for (int i = 0; i < N; i++) {\n                    Widget widget = mWidgets.get(i);\n\n                    // Skip cross-user widgets.\n                    if (!isProviderAndHostInUser(widget, userId)) {\n                        continue;\n                    }\n\n                    packages.add(widget.host.id.packageName);\n                    Provider provider = widget.provider;\n                    if (provider != null) {\n                        packages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n            }\n            return new ArrayList<>(packages);\n        }\n\n        public byte[] getWidgetState(String backedupPackage, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget state for user: \" + userId);\n            }\n\n            ByteArrayOutputStream stream = new ByteArrayOutputStream();\n            synchronized (mLock) {\n                // Preflight: if this app neither hosts nor provides any live widgets\n                // we have no work to do.\n                if (!packageNeedsWidgetBackupLocked(backedupPackage, userId)) {\n                    return null;\n                }\n\n                try {\n                    TypedXmlSerializer out = Xml.newFastSerializer();\n                    out.setOutput(stream, StandardCharsets.UTF_8.name());\n                    out.startDocument(null, true);\n                    out.startTag(null, \"ws\");      // widget state\n                    out.attributeInt(null, \"version\", WIDGET_STATE_VERSION);\n                    out.attribute(null, \"pkg\", backedupPackage);\n\n                    // Remember all the providers that are currently hosted or published\n                    // by this package: that is, all of the entities related to this app\n                    // which will need to be told about id remapping.\n                    int index = 0;\n                    int N = mProviders.size();\n                    for (int i = 0; i < N; i++) {\n                        Provider provider = mProviders.get(i);\n\n                        if (provider.shouldBePersisted()\n                                && (provider.isInPackageForUser(backedupPackage, userId)\n                                || provider.hostedByPackageForUser(backedupPackage, userId))) {\n                            provider.tag = index;\n                            serializeProvider(out, provider);\n                            index++;\n                        }\n                    }\n\n                    N = mHosts.size();\n                    index = 0;\n                    for (int i = 0; i < N; i++) {\n                        Host host = mHosts.get(i);\n\n                        if (!host.widgets.isEmpty()\n                                && (host.isInPackageForUser(backedupPackage, userId)\n                                || host.hostsPackageForUser(backedupPackage, userId))) {\n                            host.tag = index;\n                            serializeHost(out, host);\n                            index++;\n                        }\n                    }\n\n                    // All widget instances involving this package,\n                    // either as host or as provider\n                    N = mWidgets.size();\n                    for (int i = 0; i < N; i++) {\n                        Widget widget = mWidgets.get(i);\n\n                        Provider provider = widget.provider;\n                        if (widget.host.isInPackageForUser(backedupPackage, userId)\n                                || (provider != null\n                                &&  provider.isInPackageForUser(backedupPackage, userId))) {\n                            serializeAppWidget(out, widget, false);\n                        }\n                    }\n\n                    out.endTag(null, \"ws\");\n                    out.endDocument();\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Unable to save widget state for \" + backedupPackage);\n                    return null;\n                }\n            }\n\n            return stream.toByteArray();\n        }\n\n        public void systemRestoreStarting(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"System restore starting for user: \" + userId);\n            }\n\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = false;\n                // We're starting a new \"system\" restore operation, so any widget restore\n                // state that we see from here on is intended to replace the current\n                // widget configuration of any/all of the affected apps.\n                mPrunedApps.clear();\n                mUpdatesByProvider.clear();\n                mUpdatesByHost.clear();\n            }\n        }\n\n        public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Restoring widget state for user:\" + userId\n                        + \" package: \" + packageName);\n            }\n\n            ByteArrayInputStream stream = new ByteArrayInputStream(restoredState);\n            try {\n                // Providers mentioned in the widget dataset by ordinal\n                ArrayList<Provider> restoredProviders = new ArrayList<>();\n\n                // Hosts mentioned in the widget dataset by ordinal\n                ArrayList<Host> restoredHosts = new ArrayList<>();\n\n                TypedXmlPullParser parser = Xml.newFastPullParser();\n                parser.setInput(stream, StandardCharsets.UTF_8.name());\n\n                synchronized (mLock) {\n                    int type;\n                    do {\n                        type = parser.next();\n                        if (type == XmlPullParser.START_TAG) {\n                            final String tag = parser.getName();\n                            if (\"ws\".equals(tag)) {\n                                final int versionNumber = parser.getAttributeInt(null, \"version\");\n                                if (versionNumber > WIDGET_STATE_VERSION) {\n                                    Slog.w(TAG, \"Unable to process state version \" + versionNumber);\n                                    return;\n                                }\n\n                                // TODO: fix up w.r.t. canonical vs current package names\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                if (!packageName.equals(pkg)) {\n                                    Slog.w(TAG, \"Package mismatch in ws\");\n                                    return;\n                                }\n                            } else if (\"p\".equals(tag)) {\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                String cl = parser.getAttributeValue(null, \"cl\");\n\n                                // hostedProviders index will match 'p' attribute in widget's\n                                // entry in the xml file being restored\n                                // If there's no live entry for this provider, add an inactive one\n                                // so that widget IDs referring to them can be properly allocated\n\n                                // Backup and resotre only for the parent profile.\n                                ComponentName componentName = new ComponentName(pkg, cl);\n\n                                Provider p = findProviderLocked(componentName, userId);\n                                if (p == null) {\n                                    AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                                    info.provider = componentName;\n\n                                    p = new Provider();\n                                    p.id = new ProviderId(UNKNOWN_UID, componentName);\n                                    p.setPartialInfoLocked(info);\n                                    p.zombie = true;\n                                    mProviders.add(p);\n                                }\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   provider \" + p.id);\n                                }\n                                restoredProviders.add(p);\n                            } else if (\"h\".equals(tag)) {\n                                // The host app may not yet exist on the device.  If it's here we\n                                // just use the existing Host entry, otherwise we create a\n                                // placeholder whose uid will be fixed up at PACKAGE_ADDED time.\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                                final int uid = getUidForPackage(pkg, userId);\n                                final int hostId = parser.getAttributeIntHex(null, \"id\");\n\n                                HostId id = new HostId(uid, hostId, pkg);\n                                Host h = lookupOrAddHostLocked(id);\n                                restoredHosts.add(h);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   host[\" + restoredHosts.size()\n                                            + \"]: {\" + h.id + \"}\");\n                                }\n                            } else if (\"g\".equals(tag)) {\n                                int restoredId = parser.getAttributeIntHex(null, \"id\");\n                                int hostIndex = parser.getAttributeIntHex(null, \"h\");\n                                Host host = restoredHosts.get(hostIndex);\n                                Provider p = null;\n                                int which = parser.getAttributeIntHex(null, \"p\", -1);\n                                if (which != -1) {\n                                    // could have been null if the app had allocated an id\n                                    // but not yet established a binding under that id\n                                    p = restoredProviders.get(which);\n                                }\n\n                                // We'll be restoring widget state for both the host and\n                                // provider sides of this widget ID, so make sure we are\n                                // beginning from a clean slate on both fronts.\n                                pruneWidgetStateLocked(host.id.packageName, userId);\n                                if (p != null) {\n                                    pruneWidgetStateLocked(p.id.componentName.getPackageName(),\n                                            userId);\n                                }\n\n                                // Have we heard about this ancestral widget instance before?\n                                Widget id = findRestoredWidgetLocked(restoredId, host, p);\n                                if (id == null) {\n                                    id = new Widget();\n                                    id.appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n                                    id.restoredId = restoredId;\n                                    id.options = parseWidgetIdOptions(parser);\n                                    id.host = host;\n                                    id.host.widgets.add(id);\n                                    id.provider = p;\n                                    if (id.provider != null) {\n                                        id.provider.widgets.add(id);\n                                    }\n                                    if (DEBUG) {\n                                        Slog.i(TAG, \"New restored id \" + restoredId\n                                                + \" now \" + id);\n                                    }\n                                    addWidgetLocked(id);\n                                }\n                                if (id.provider != null\n                                        && id.provider.getPartialInfoLocked() != null) {\n                                    stashProviderRestoreUpdateLocked(id.provider,\n                                            restoredId, id.appWidgetId);\n                                } else {\n                                    Slog.w(TAG, \"Missing provider for restored widget \" + id);\n                                }\n                                stashHostRestoreUpdateLocked(id.host, restoredId, id.appWidgetId);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   instance: \" + restoredId\n                                            + \" -> \" + id.appWidgetId\n                                            + \" :: p=\" + id.provider);\n                                }\n                            }\n                        }\n                    } while (type != XmlPullParser.END_DOCUMENT);\n\n                    // We've updated our own bookkeeping.  We'll need to notify the hosts and\n                    // providers about the changes, but we can't do that yet because the restore\n                    // target is not necessarily fully live at this moment.  Set aside the\n                    // information for now; the backup manager will call us once more at the\n                    // end of the process when all of the targets are in a known state, and we\n                    // will update at that point.\n                }\n            } catch (XmlPullParserException | IOException e) {\n                Slog.w(TAG, \"Unable to restore widget state for \" + packageName);\n            } finally {\n                saveGroupStateAsync(userId);\n            }\n        }\n\n        // Called once following the conclusion of a system restore operation.  This is when we\n        // send out updates to apps involved in widget-state restore telling them about\n        // the new widget ID space.  Apps that are not yet installed will be notifed when they are.\n        public void systemRestoreFinished(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"systemRestoreFinished for \" + userId);\n            }\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = true;\n                maybeSendWidgetRestoreBroadcastsLocked(userId);\n            }\n        }\n\n        // Called when widget components (hosts or providers) are added or changed.  If system\n        // restore has completed, we use this opportunity to tell the apps to update to the new\n        // widget ID space.  If system restore is still in progress, we delay the updates until\n        // the end, to allow all participants to restore their state before updating widget IDs.\n        public void widgetComponentsChanged(int userId) {\n            synchronized (mLock) {\n                if (mHasSystemRestoreFinished) {\n                    maybeSendWidgetRestoreBroadcastsLocked(userId);\n                }\n            }\n        }\n\n        // Called following the conclusion of a restore operation and when widget components\n        // are added or changed.  This is when we send out updates to apps involved in widget-state\n        // restore telling them about the new widget ID space.\n        @GuardedBy(\"mLock\")\n        private void maybeSendWidgetRestoreBroadcastsLocked(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"maybeSendWidgetRestoreBroadcasts for \" + userId);\n            }\n\n            final UserHandle userHandle = new UserHandle(userId);\n            // Build the providers' broadcasts and send them off\n            Set<Map.Entry<Provider, ArrayList<RestoreUpdateRecord>>> providerEntries\n                    = mUpdatesByProvider.entrySet();\n            for (Map.Entry<Provider, ArrayList<RestoreUpdateRecord>> e : providerEntries) {\n                // For each provider there's a list of affected IDs\n                Provider provider = e.getKey();\n                if (provider.zombie) {\n                    // Provider not installed, we can't send them broadcasts yet.\n                    // We'll be called again when the provider is installed.\n                    continue;\n                }\n                ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                final int pending = countPendingUpdates(updates);\n                if (DEBUG) {\n                    Slog.i(TAG, \"Provider \" + provider + \" pending: \" + pending);\n                }\n                if (pending > 0) {\n                    int[] oldIds = new int[pending];\n                    int[] newIds = new int[pending];\n                    final int N = updates.size();\n                    int nextPending = 0;\n                    for (int i = 0; i < N; i++) {\n                        RestoreUpdateRecord r = updates.get(i);\n                        if (!r.notified) {\n                            r.notified = true;\n                            oldIds[nextPending] = r.oldId;\n                            newIds[nextPending] = r.newId;\n                            nextPending++;\n                            if (DEBUG) {\n                                Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                            }\n                        }\n                    }\n                    sendWidgetRestoreBroadcastLocked(\n                            AppWidgetManager.ACTION_APPWIDGET_RESTORED,\n                            provider, null, oldIds, newIds, userHandle);\n                }\n            }\n\n            // same thing per host\n            Set<Map.Entry<Host, ArrayList<RestoreUpdateRecord>>> hostEntries\n                    = mUpdatesByHost.entrySet();\n            for (Map.Entry<Host, ArrayList<RestoreUpdateRecord>> e : hostEntries) {\n                Host host = e.getKey();\n                if (host.id.uid != UNKNOWN_UID) {\n                    ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                    final int pending = countPendingUpdates(updates);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Host \" + host + \" pending: \" + pending);\n                    }\n                    if (pending > 0) {\n                        int[] oldIds = new int[pending];\n                        int[] newIds = new int[pending];\n                        final int N = updates.size();\n                        int nextPending = 0;\n                        for (int i = 0; i < N; i++) {\n                            RestoreUpdateRecord r = updates.get(i);\n                            if (!r.notified) {\n                                r.notified = true;\n                                oldIds[nextPending] = r.oldId;\n                                newIds[nextPending] = r.newId;\n                                nextPending++;\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                                }\n                            }\n                        }\n                        sendWidgetRestoreBroadcastLocked(\n                                AppWidgetManager.ACTION_APPWIDGET_HOST_RESTORED,\n                                null, host, oldIds, newIds, userHandle);\n                    }\n                }\n            }\n        }\n\n        private Provider findProviderLocked(ComponentName componentName, int userId) {\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                if (provider.getUserId() == userId\n                        && provider.id.componentName.equals(componentName)) {\n                    return provider;\n                }\n            }\n            return null;\n        }\n\n        private Widget findRestoredWidgetLocked(int restoredId, Host host, Provider p) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Find restored widget: id=\" + restoredId\n                        + \" host=\" + host + \" provider=\" + p);\n            }\n\n            if (p == null || host == null) {\n                return null;\n            }\n\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                if (widget.restoredId == restoredId\n                        && widget.host.id.equals(host.id)\n                        && widget.provider.id.equals(p.id)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"   Found at \" + i + \" : \" + widget);\n                    }\n                    return widget;\n                }\n            }\n            return null;\n        }\n\n        private boolean packageNeedsWidgetBackupLocked(String packageName, int userId) {\n            int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n\n                // Skip cross-user widgets.\n                if (!isProviderAndHostInUser(widget, userId)) {\n                    continue;\n                }\n\n                if (widget.host.isInPackageForUser(packageName, userId)) {\n                    // this package is hosting widgets, so it knows widget IDs.\n                    return true;\n                }\n\n                Provider provider = widget.provider;\n                if (provider != null && provider.isInPackageForUser(packageName, userId)) {\n                    // someone is hosting this app's widgets, so it knows widget IDs.\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashProviderRestoreUpdateLocked(Provider provider, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByProvider.get(provider);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByProvider.put(provider, r);\n            } else {\n                // don't duplicate\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + provider);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private boolean alreadyStashed(ArrayList<RestoreUpdateRecord> stash,\n                final int oldId, final int newId) {\n            final int N = stash.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = stash.get(i);\n                if (r.oldId == oldId && r.newId == newId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashHostRestoreUpdateLocked(Host host, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByHost.get(host);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByHost.put(host, r);\n            } else {\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + host);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private void sendWidgetRestoreBroadcastLocked(String action, Provider provider,\n                Host host, int[] oldIds, int[] newIds, UserHandle userHandle) {\n            Intent intent = new Intent(action);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OLD_IDS, oldIds);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, newIds);\n            if (provider != null) {\n                intent.setComponent(provider.id.componentName);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n            if (host != null) {\n                intent.setComponent(null);\n                intent.setPackage(host.id.packageName);\n                intent.putExtra(AppWidgetManager.EXTRA_HOST_ID, host.id.hostId);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n        }\n\n        // We're restoring widget state for 'pkg', so we start by wiping (a) all widget\n        // instances that are hosted by that app, and (b) all instances in other hosts\n        // for which 'pkg' is the provider.  We assume that we'll be restoring all of\n        // these hosts & providers, so will be reconstructing a correct live state.\n        private void pruneWidgetStateLocked(String pkg, int userId) {\n            if (!mPrunedApps.contains(pkg)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"pruning widget state for restoring package \" + pkg);\n                }\n                for (int i = mWidgets.size() - 1; i >= 0; i--) {\n                    Widget widget = mWidgets.get(i);\n\n                    Host host = widget.host;\n                    Provider provider = widget.provider;\n\n                    if (host.hostsPackageForUser(pkg, userId)\n                            || (provider != null && provider.isInPackageForUser(pkg, userId))) {\n                        // 'pkg' is either the host or the provider for this instances,\n                        // so we tear it down in anticipation of it (possibly) being\n                        // reconstructed due to the restore\n                        host.widgets.remove(widget);\n                        provider.widgets.remove(widget);\n                        // Check if we need to destroy any services (if no other app widgets are\n                        // referencing the same service)\n                        decrementAppWidgetServiceRefCount(widget);\n                        removeWidgetLocked(widget);\n                    }\n                }\n                mPrunedApps.add(pkg);\n            } else {\n                if (DEBUG) {\n                    Slog.i(TAG, \"already pruned \" + pkg + \", continuing normally\");\n                }\n            }\n        }\n\n        private boolean isProviderAndHostInUser(Widget widget, int userId) {\n            // Backup only widgets hosted or provided by the owner profile.\n            return widget.host.getUserId() == userId && (widget.provider == null\n                    || widget.provider.getUserId() == userId);\n        }\n\n        private int countPendingUpdates(ArrayList<RestoreUpdateRecord> updates) {\n            int pending = 0;\n            final int N = updates.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = updates.get(i);\n                if (!r.notified) {\n                    pending++;\n                }\n            }\n            return pending;\n        }\n\n        // Accumulate a list of updates that affect the given provider for a final\n        // coalesced notification broadcast once restore is over.\n        private class RestoreUpdateRecord {\n            public int oldId;\n            public int newId;\n            public boolean notified;\n\n            public RestoreUpdateRecord(int theOldId, int theNewId) {\n                oldId = theOldId;\n                newId = theNewId;\n                notified = false;\n            }\n        }\n    }\n\n    private class AppWidgetManagerLocal extends AppWidgetManagerInternal {\n        @Override\n        public ArraySet<String> getHostedWidgetPackages(int uid) {\n            synchronized (mLock) {\n                ArraySet<String> widgetPackages = null;\n                final int widgetCount = mWidgets.size();\n                for (int i = 0; i < widgetCount; i++) {\n                    final Widget widget = mWidgets.get(i);\n                    if  (widget.host.id.uid == uid && widget.provider != null) {\n                        if (widgetPackages == null) {\n                            widgetPackages = new ArraySet<>();\n                        }\n                        widgetPackages.add(widget.provider.id.componentName.getPackageName());\n                    }\n                }\n                return widgetPackages;\n            }\n        }\n\n        @Override\n        public void unlockUser(int userId) {\n            handleUserUnlocked(userId);\n        }\n\n        @Override\n        public void applyResourceOverlaysToWidgets(Set<String> packageNames, int userId,\n                boolean updateFrameworkRes) {\n            synchronized (mLock) {\n                applyResourceOverlaysToWidgetsLocked(new HashSet<>(packageNames), userId,\n                        updateFrameworkRes);\n            }\n        }\n    }\n}\n```",
                        "downstream_file_tokens": {
                            "openai": 38238,
                            "general": {
                                "word_based": 16459,
                                "char_based": 50947
                            },
                            "gemini": 45851
                        },
                        "downstream_patched_file_llm_output": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appwidget;\n\nimport static android.content.Context.KEYGUARD_SERVICE;\nimport static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.res.Resources.ID_NULL;\n\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\n\nimport android.annotation.NonNull;\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManagerInternal;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.KeyguardManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerInternal.OnCrossProfileWidgetProvidersChangeListener;\nimport android.app.usage.UsageEvents;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.appwidget.AppWidgetManager;\nimport android.appwidget.AppWidgetManagerInternal;\nimport android.appwidget.AppWidgetProviderInfo;\nimport android.appwidget.PendingHostUpdate;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.Intent.FilterComparison;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.LauncherApps;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.ShortcutServiceInternal;\nimport android.content.pm.SuspendDialogInfo;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.graphics.Point;\nimport android.graphics.drawable.Icon;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.appwidget.AppWidgetServiceDumpProto;\nimport android.service.appwidget.WidgetProto;\nimport android.text.TextUtils;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.AttributeSet;\nimport android.util.IntArray;\nimport android.util.LongSparseArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.SparseLongArray;\nimport android.util.TypedValue;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\nimport android.util.Xml;\nimport android.util.proto.ProtoOutputStream;\nimport android.view.Display;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.app.SuspendedAppActivity;\nimport com.android.internal.app.UnlaunchableAppActivity;\nimport com.android.internal.appwidget.IAppWidgetHost;\nimport com.android.internal.appwidget.IAppWidgetService;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.widget.IRemoteViewsFactory;\nimport com.android.server.LocalServices;\nimport com.android.server.WidgetBackupProvider;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\n\nclass AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBackupProvider,\n        OnCrossProfileWidgetProvidersChangeListener {\n    private static final String TAG = \"AppWidgetServiceImpl\";\n\n    private static boolean DEBUG = false;\n\n    private static final String OLD_KEYGUARD_HOST_PACKAGE = \"android\";\n    private static final String NEW_KEYGUARD_HOST_PACKAGE = \"com.android.keyguard\";\n    private static final int KEYGUARD_HOST_ID = 0x4b455947;\n\n    private static final String STATE_FILENAME = \"appwidgets.xml\";\n\n    private static final int MIN_UPDATE_PERIOD = DEBUG ? 0 : 30 * 60 * 1000; // 30 minutes\n\n    private static final int TAG_UNDEFINED = -1;\n\n    private static final int UNKNOWN_UID = -1;\n\n    private static final int UNKNOWN_USER_ID = -10;\n\n    // Bump if the stored widgets need to be upgraded.\n    private static final int CURRENT_VERSION = 1;\n\n    // Every widget update request is associated which an increasing sequence number. This is\n    // used to verify which request has successfully been received by the host.\n    private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n\n    // See {@link Provider#pendingDeletedWidgetIds}.\n    private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n\n    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n    // surfaces in the host app.\n    // @see AppWidgetHost\n    // @see AppWidgetHost#mHostId\n    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n    // Hard limit of number of widgets can be pinned by a host.\n    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Received broadcast: \" + action + \" on user \" + userId);\n            }\n\n            switch (action) {\n                case Intent.ACTION_MANAGED_PROFILE_AVAILABLE:\n                case Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE:\n                    synchronized (mLock) {\n                        reloadWidgetsMaskedState(userId);\n                    }\n                    break;\n                case Intent.ACTION_PACKAGES_SUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, true, getSendingUserId());\n                    break;\n                case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, false, getSendingUserId());\n                    break;\n                default:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    break;\n            }\n        }\n    };\n\n    // Manages persistent references to RemoteViewsServices from different App Widgets.\n    private final HashMap<Pair<Integer, FilterComparison>, HashSet<Integer>>\n            mRemoteViewsServicesAppWidgets = new HashMap<>();\n\n    private final Object mLock = new Object();\n\n    private final ArrayList<Widget> mWidgets = new ArrayList<>();\n    private final ArrayList<Host> mHosts = new ArrayList<>();\n    private final ArrayList<Provider> mProviders = new ArrayList<>();\n\n    private final ArraySet<Pair<Integer, String>> mPackagesWithBindWidgetPermission =\n            new ArraySet<>();\n\n    private final SparseBooleanArray mLoadedUserIds = new SparseBooleanArray();\n\n    private final Object mWidgetPackagesLock = new Object();\n    private final SparseArray<ArraySet<String>> mWidgetPackages = new SparseArray<>();\n\n    private BackupRestoreController mBackupRestoreController;\n\n    private final Context mContext;\n\n    private IPackageManager mPackageManager;\n    private AlarmManager mAlarmManager;\n    private UserManager mUserManager;\n    private AppOpsManager mAppOpsManager;\n    private KeyguardManager mKeyguardManager;\n    private DevicePolicyManagerInternal mDevicePolicyManagerInternal;\n    private PackageManagerInternal mPackageManagerInternal;\n    private ActivityManagerInternal mActivityManagerInternal;\n    private AppOpsManagerInternal mAppOpsManagerInternal;\n    private UsageStatsManagerInternal mUsageStatsManagerInternal;\n\n    private SecurityPolicy mSecurityPolicy;\n\n    private Handler mSaveStateHandler;\n    private Handler mCallbackHandler;\n\n    private final SparseIntArray mNextAppWidgetIds = new SparseIntArray();\n\n    private boolean mSafeMode;\n    private int mMaxWidgetBitmapMemory;\n\n    AppWidgetServiceImpl(Context context) {\n        mContext = context;\n    }\n\n    public void onStart() {\n        mPackageManager = AppGlobals.getPackageManager();\n        mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n        mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);\n        mKeyguardManager = (KeyguardManager) mContext.getSystemService(KEYGUARD_SERVICE);\n        mDevicePolicyManagerInternal = LocalServices.getService(DevicePolicyManagerInternal.class);\n        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        mSaveStateHandler = BackgroundThread.getHandler();\n        mCallbackHandler = new CallbackHandler(mContext.getMainLooper());\n        mBackupRestoreController = new BackupRestoreController();\n        mSecurityPolicy = new SecurityPolicy();\n\n        computeMaximumWidgetBitmapMemory();\n        registerBroadcastReceiver();\n        registerOnCrossProfileProvidersChangedListener();\n\n        LocalServices.addService(AppWidgetManagerInternal.class, new AppWidgetManagerLocal());\n    }\n\n    void systemServicesReady() {\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n        mAppOpsManagerInternal = LocalServices.getService(AppOpsManagerInternal.class);\n        mUsageStatsManagerInternal = LocalServices.getService(UsageStatsManagerInternal.class);\n    }\n\n    private void computeMaximumWidgetBitmapMemory() {\n        Display display = mContext.getDisplayNoVerify();\n        Point size = new Point();\n        display.getRealSize(size);\n        // Cap memory usage at 1.5 times the size of the display\n        // 1.5 * 4 bytes/pixel * w * h ==> 6 * w * h\n        mMaxWidgetBitmapMemory = 6 * size.x * size.y;\n    }\n\n    private void registerBroadcastReceiver() {\n        // Register for broadcasts about package install, etc., so we can\n        // update the provider list.\n        IntentFilter packageFilter = new IntentFilter();\n        packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        packageFilter.addDataScheme(\"package\");\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                packageFilter, null, null);\n\n        // Register for events related to sdcard installation.\n        IntentFilter sdFilter = new IntentFilter();\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                sdFilter, null, null);\n\n        IntentFilter offModeFilter = new IntentFilter();\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_AVAILABLE);\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                offModeFilter, null, null);\n\n        IntentFilter suspendPackageFilter = new IntentFilter();\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                suspendPackageFilter, null, null);\n    }\n\n    private void registerOnCrossProfileProvidersChangedListener() {\n        // The device policy is an optional component.\n        if (mDevicePolicyManagerInternal != null) {\n            mDevicePolicyManagerInternal.addOnCrossProfileWidgetProvidersChangeListener(this);\n        }\n    }\n\n    public void setSafeMode(boolean safeMode) {\n        mSafeMode = safeMode;\n    }\n\n    private void onPackageBroadcastReceived(Intent intent, int userId) {\n        final String action = intent.getAction();\n        boolean added = false;\n        boolean changed = false;\n        boolean componentsModified = false;\n\n        final String pkgList[];\n        switch (action) {\n            case Intent.ACTION_PACKAGES_SUSPENDED:\n            case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                changed = true;\n                break;\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:\n                added = true;\n                // Follow through\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                break;\n            default: {\n                Uri uri = intent.getData();\n                if (uri == null) {\n                    return;\n                }\n                String pkgName = uri.getSchemeSpecificPart();\n                if (pkgName == null) {\n                    return;\n                }\n                pkgList = new String[] { pkgName };\n                added = Intent.ACTION_PACKAGE_ADDED.equals(action);\n                changed = Intent.ACTION_PACKAGE_CHANGED.equals(action);\n            }\n        }\n        if (pkgList == null || pkgList.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            if (!mUserManager.isUserUnlockingOrUnlocked(userId) ||\n                    isProfileWithLockedParent(userId)) {\n                return;\n            }\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            Bundle extras = intent.getExtras();\n\n            if (added || changed) {\n                final boolean newPackageAdded = added && (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                for (String pkgName : pkgList) {\n                    // Fix up the providers - add/remove/update.\n                    componentsModified |= updateProvidersForPackageLocked(pkgName, userId, null);\n\n                    // ... and see if these are hosts we've been awaiting.\n                    // NOTE: We are backing up and restoring only the owner.\n                    // TODO: http://b/22388012\n                    if (newPackageAdded && userId == UserHandle.USER_SYSTEM) {\n                        final int uid = getUidForPackage(pkgName, userId);\n                        if (uid >= 0 ) {\n                            resolveHostUidLocked(pkgName, uid);\n                        }\n                    }\n                }\n            } else {\n                // If the package is being updated, we'll receive a PACKAGE_ADDED\n                // shortly, otherwise it is removed permanently.\n                final boolean packageRemovedPermanently = (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                if (packageRemovedPermanently) {\n                    for (String pkgName : pkgList) {\n                        componentsModified |= removeHostsAndProvidersForPackageLocked(\n                                pkgName, userId);\n                    }\n                }\n            }\n\n            if (componentsModified) {\n                saveGroupStateAsync(userId);\n\n                // If the set of providers has been modified, notify each active AppWidgetHost\n                scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                // Possibly notify any new components of widget id changes\n                mBackupRestoreController.widgetComponentsChanged(userId);\n            }\n        }\n    }\n\n    /**\n     * Reload all widgets' masked state for the given user and its associated profiles, including\n     * due to user not being available and package suspension.\n     * userId must be the group parent.\n     */\n    void reloadWidgetsMaskedStateForGroup(int userId) {\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            return;\n        }\n        synchronized (mLock) {\n            reloadWidgetsMaskedState(userId);\n            int[] profileIds = mUserManager.getEnabledProfileIds(userId);\n            for (int profileId : profileIds) {\n                reloadWidgetsMaskedState(profileId);\n            }\n        }\n    }\n\n    private void reloadWidgetsMaskedState(int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            UserInfo user  = mUserManager.getUserInfo(userId);\n\n            boolean lockedProfile = !mUserManager.isUserUnlockingOrUnlocked(userId);\n            boolean quietProfile = user.isQuietModeEnabled();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != userId) {\n                    continue;\n                }\n\n                boolean changed = provider.setMaskedByLockedProfileLocked(lockedProfile);\n                changed |= provider.setMaskedByQuietProfileLocked(quietProfile);\n                try {\n                    boolean suspended;\n                    try {\n                        suspended = mPackageManager.isPackageSuspendedForUser(\n                                provider.id.componentName.getPackageName(), provider.getUserId());\n                    } catch (IllegalArgumentException ex) {\n                        // Package not found.\n                        suspended = false;\n                    }\n                    changed |= provider.setMaskedBySuspendedPackageLocked(suspended);\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Failed to query application info\", e);\n                }\n                if (changed) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * Incrementally update the masked state due to package suspension state.\n     */\n    private void updateWidgetPackageSuspensionMaskedState(Intent intent, boolean suspended,\n            int profileId) {\n        String[] packagesArray = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n        if (packagesArray == null) {\n            return;\n        }\n        Set<String> packages = new ArraySet<>(Arrays.asList(packagesArray));\n        synchronized (mLock) {\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != profileId\n                        || !packages.contains(provider.id.componentName.getPackageName())) {\n                    continue;\n                }\n                if (provider.setMaskedBySuspendedPackageLocked(suspended)) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Mask the target widget belonging to the specified provider, or all active widgets\n     * of the provider if target widget == null.\n     */\n    private void maskWidgetsViewsLocked(Provider provider, Widget targetWidget) {\n        final int widgetCount = provider.widgets.size();\n        if (widgetCount == 0) {\n            return;\n        }\n        RemoteViews views = new RemoteViews(mContext.getPackageName(),\n                R.layout.work_widget_mask_view);\n        ApplicationInfo appInfo = provider.info.providerInfo.applicationInfo;\n        final int appUserId = provider.getUserId();\n        boolean showBadge;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final Intent onClickIntent;\n\n            if (provider.maskedBySuspendedPackage) {\n                showBadge = mUserManager.hasBadge(appUserId);\n                final String suspendingPackage = mPackageManagerInternal.getSuspendingPackage(\n                        appInfo.packageName, appUserId);\n                if (PLATFORM_PACKAGE_NAME.equals(suspendingPackage)) {\n                    onClickIntent = mDevicePolicyManagerInternal.createShowAdminSupportIntent(\n                            appUserId, true);\n                } else {\n                    final SuspendDialogInfo dialogInfo =\n                            mPackageManagerInternal.getSuspendedDialogInfo(\n                                    appInfo.packageName, suspendingPackage, appUserId);\n                    // onUnsuspend is null because we don't want to start any activity on\n                    // unsuspending from a suspended widget.\n                    onClickIntent = SuspendedAppActivity.createSuspendedAppInterceptIntent(\n                            appInfo.packageName, suspendingPackage, dialogInfo, null, null,\n                            appUserId);\n                }\n            } else if (provider.maskedByQuietProfile) {\n                showBadge = true;\n                onClickIntent = UnlaunchableAppActivity.createInQuietModeDialogIntent(appUserId);\n            } else /* provider.maskedByLockedProfile */ {\n                showBadge = true;\n                onClickIntent = mKeyguardManager\n                        .createConfirmDeviceCredentialIntent(null, null, appUserId);\n                if (onClickIntent != null) {\n                    onClickIntent.setFlags(\n                            FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                }\n            }\n\n            if (onClickIntent != null) {\n                views.setOnClickPendingIntent(android.R.id.background,\n                        PendingIntent.getActivity(mContext, 0, onClickIntent,\n                                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE));\n            }\n\n            Icon icon = appInfo.icon != 0\n                    ? Icon.createWithResource(appInfo.packageName, appInfo.icon)\n                    : Icon.createWithResource(mContext, android.R.drawable.sym_def_app_icon);\n            views.setImageViewIcon(R.id.work_widget_app_icon, icon);\n            if (!showBadge) {\n                views.setViewVisibility(R.id.work_widget_badge_icon, View.INVISIBLE);\n            }\n\n            for (int j = 0; j < widgetCount; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (targetWidget != null && targetWidget != widget) continue;\n                if (widget.replaceWithMaskedViewsLocked(views)) {\n                    scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void unmaskWidgetsViewsLocked(Provider provider) {\n        final int widgetCount = provider.widgets.size();\n        for (int j = 0; j < widgetCount; j++) {\n            Widget widget = provider.widgets.get(j);\n            if (widget.clearMaskedViewsLocked()) {\n                scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n            }\n        }\n    }\n\n    private void resolveHostUidLocked(String pkg, int uid) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.uid == UNKNOWN_UID && pkg.equals(host.id.packageName)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"host \" + host.id + \" resolved to uid \" + uid);\n                }\n                host.id = new HostId(uid, host.id.hostId, host.id.packageName);\n                return;\n            }\n        }\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId) {\n        ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ true );\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId, boolean enforceUserUnlockingOrUnlocked) {\n        if (enforceUserUnlockingOrUnlocked && !isUserRunningAndUnlocked(userId)) {\n            throw new IllegalStateException(\n                    \"User \" + userId + \" must be unlocked for widgets to be available\");\n        }\n        if (enforceUserUnlockingOrUnlocked && isProfileWithLockedParent(userId)) {\n            throw new IllegalStateException(\n                    \"Profile \" + userId + \" must have unlocked parent\");\n        }\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        IntArray newIds = new IntArray(1);\n        for (int profileId : profileIds) {\n            if (!mLoadedUserIds.get(profileId)) {\n                mLoadedUserIds.put(profileId, true);\n                newIds.add(profileId);\n            }\n        }\n        if (newIds.size() <= 0) {\n            return;\n        }\n        final int[] newProfileIds = newIds.toArray();\n        clearProvidersAndHostsTagsLocked();\n\n        loadGroupWidgetProvidersLocked(newProfileIds);\n        loadGroupStateLocked(newProfileIds);\n    }\n\n    private boolean isUserRunningAndUnlocked(@UserIdInt int userId) {\n        return mUserManager.isUserUnlockingOrUnlocked(userId);\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;\n\n        synchronized (mLock) {\n            if (args.length > 0 && \"--proto\".equals(args[0])) {\n                dumpProto(fd);\n            } else {\n                dumpInternalLocked(pw);\n            }\n        }\n    }\n\n    private void dumpProto(FileDescriptor fd) {\n        Slog.i(TAG, \"dump proto for \" + mWidgets.size() + \" widgets\");\n\n        ProtoOutputStream proto = new ProtoOutputStream(fd);\n        int N = mWidgets.size();\n        for (int i=0; i < N; i++) {\n            dumpProtoWidget(proto, mWidgets.get(i));\n        }\n        proto.flush();\n    }\n\n    private void dumpProtoWidget(ProtoOutputStream proto, Widget widget) {\n        if (widget.host == null || widget.provider == null) {\n            Slog.d(TAG, \"skip dumping widget because host or provider is null: widget.host=\"\n                + widget.host + \" widget.provider=\"  + widget.provider);\n            return;\n        }\n        long token = proto.start(AppWidgetServiceDumpProto.WIDGETS);\n        proto.write(WidgetProto.IS_CROSS_PROFILE,\n            widget.host.getUserId() != widget.provider.getUserId());\n        proto.write(WidgetProto.IS_HOST_STOPPED, widget.host.callbacks == null);\n        proto.write(WidgetProto.HOST_PACKAGE, widget.host.id.packageName);\n        proto.write(WidgetProto.PROVIDER_PACKAGE, widget.provider.id.componentName.getPackageName());\n        proto.write(WidgetProto.PROVIDER_CLASS, widget.provider.id.componentName.getClassName());\n        if (widget.options != null) {\n            proto.write(WidgetProto.RESTORE_COMPLETED,\n                    widget.options.getBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED));\n            proto.write(WidgetProto.MIN_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, 0));\n            proto.write(WidgetProto.MIN_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, 0));\n            proto.write(WidgetProto.MAX_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, 0));\n            proto.write(WidgetProto.MAX_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, 0));\n        }\n        proto.end(token);\n    }\n\n    private void dumpInternalLocked(PrintWriter pw) {\n        int N = mProviders.size();\n        pw.println(\"Providers:\");\n        for (int i = 0; i < N; i++) {\n            dumpProviderLocked(mProviders.get(i), i, pw);\n        }\n\n        N = mWidgets.size();\n        pw.println(\" \");\n        pw.println(\"Widgets:\");\n        for (int i = 0; i < N; i++) {\n            dumpWidget(mWidgets.get(i), i, pw);\n        }\n\n        N = mHosts.size();\n        pw.println(\" \");\n        pw.println(\"Hosts:\");\n        for (int i = 0; i < N; i++) {\n            dumpHost(mHosts.get(i), i, pw);\n        }\n\n        N = mPackagesWithBindWidgetPermission.size();\n        pw.println(\" \");\n        pw.println(\"Grants:\");\n        for (int i = 0; i < N; i++) {\n            Pair<Integer, String> grant = mPackagesWithBindWidgetPermission.valueAt(i);\n            dumpGrant(grant, i, pw);\n        }\n    }\n\n    @Override\n    public ParceledListSlice<PendingHostUpdate> startListening(IAppWidgetHost callbacks,\n            String callingPackage, int hostId, int[] appWidgetIds) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"startListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n            host.callbacks = callbacks;\n\n            long updateSequenceNo = UPDATE_COUNTER.incrementAndGet();\n            int N = appWidgetIds.length;\n            ArrayList<PendingHostUpdate> outUpdates = new ArrayList<>(N);\n            LongSparseArray<PendingHostUpdate> updatesMap = new LongSparseArray<>();\n            for (int i = 0; i < N; i++) {\n                updatesMap.clear();\n                host.getPendingUpdatesForIdLocked(mContext, appWidgetIds[i], updatesMap);\n                // We key the updates based on request id, so that the values are sorted in the\n                // order they were received.\n                int m = updatesMap.size();\n                for (int j = 0; j < m; j++) {\n                    outUpdates.add(updatesMap.valueAt(j));\n                }\n            }\n            // Reset the update counter once all the updates have been calculated\n            host.lastWidgetUpdateSequenceNo = updateSequenceNo;\n            return new ParceledListSlice<>(outUpdates);\n        }\n    }\n\n    @Override\n    public void stopListening(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"stopListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                host.callbacks = null;\n                pruneHostLocked(host);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(host.getWidgetUids(), false);\n            }\n        }\n    }\n\n    @Override\n    public int allocateAppWidgetId(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"allocateAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return AppWidgetManager.INVALID_APPWIDGET_ID;\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n                mNextAppWidgetIds.put(userId, AppWidgetManager.INVALID_APPWIDGET_ID + 1);\n            }\n\n            final int appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n\n            Widget widget = new Widget();\n            widget.appWidgetId = appWidgetId;\n            widget.host = host;\n\n            host.widgets.add(widget);\n            addWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Allocated widget id \" + appWidgetId\n                        + \" for host \" + host.id);\n            }\n\n            return appWidgetId;\n        }\n    }\n\n    @Override\n    public void deleteAppWidgetId(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            deleteAppWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted widget id \" + appWidgetId\n                        + \" for host \" + widget.host.id);\n            }\n        }\n    }\n\n    @Override\n    public boolean hasBindAppWidgetPermission(String packageName, int grantId) {\n        if (DEBUG) {\n            Slog.i(TAG, \"hasBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return false;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            return mPackagesWithBindWidgetPermission.contains(packageId);\n        }\n    }\n\n    @Override\n    public void setBindAppWidgetPermission(String packageName, int grantId,\n            boolean grantPermission) {\n        if (DEBUG) {\n            Slog.i(TAG, \"setBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            if (grantPermission) {\n                mPackagesWithBindWidgetPermission.add(packageId);\n            } else {\n                mPackagesWithBindWidgetPermission.remove(packageId);\n            }\n\n            saveGroupStateAsync(grantId);\n        }\n    }\n\n    @Override\n    public IntentSender createAppWidgetConfigIntentSender(String callingPackage, int appWidgetId,\n            final int intentFlags) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"createAppWidgetConfigIntentSender() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id \" + appWidgetId);\n            }\n\n            Provider provider = widget.provider;\n            if (provider == null) {\n                throw new IllegalArgumentException(\"Widget not bound \" + appWidgetId);\n            }\n\n            // Make sure only safe flags can be passed it.\n            final int secureFlags = intentFlags & ~Intent.IMMUTABLE_FLAGS;\n\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_CONFIGURE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\n            intent.setComponent(provider.getInfoLocked(mContext).configure);\n            intent.setFlags(secureFlags);\n\n            // All right, create the sender.\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return PendingIntent.getActivityAsUser(\n                        mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_CANCEL_CURRENT,\n                                null, new UserHandle(provider.getUserId()))\n                        .getIntentSender();\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    @Override\n    public boolean bindAppWidgetId(String callingPackage, int appWidgetId,\n            int providerProfileId, ComponentName providerComponent, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"bindAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        // Check that if a cross-profile binding is attempted, it is allowed.\n        if (!mSecurityPolicy.isEnabledGroupProfile(providerProfileId)) {\n            return false;\n        }\n\n        // If the provider is not under the calling user, make sure this\n        // provider is allowlisted for access from the parent.\n        if (!mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                providerComponent.getPackageName(), providerProfileId)) {\n            return false;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // A special permission or allowlisting is required to bind widgets.\n            if (!mSecurityPolicy.hasCallerBindPermissionOrBindWhiteListedLocked(\n                    callingPackage)) {\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                Slog.e(TAG, \"Bad widget id \" + appWidgetId);\n                return false;\n            }\n\n            if (widget.provider != null) {\n                Slog.e(TAG, \"Widget id \" + appWidgetId\n                        + \" already bound to: \" + widget.provider.id);\n                return false;\n            }\n\n            final int providerUid = getUidForPackage(providerComponent.getPackageName(),\n                    providerProfileId);\n            if (providerUid < 0) {\n                Slog.e(TAG, \"Package \" + providerComponent.getPackageName() + \" not installed \"\n                        + \" for profile \" + providerProfileId);\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the provider is in the already vetted user profile.\n            ProviderId id = new ProviderId(providerUid, providerComponent);\n            Provider provider = lookupProviderLocked(id);\n\n            if (provider == null) {\n                Slog.e(TAG, \"No widget provider \" + providerComponent + \" for profile \"\n                        + providerProfileId);\n                return false;\n            }\n\n            if (provider.zombie) {\n                Slog.e(TAG, \"Can't bind to a 3rd party provider in\"\n                        + \" safe mode \" + provider);\n                return false;\n            }\n\n            widget.provider = provider;\n            widget.options = (options != null) ? cloneIfLocalBinder(options) : new Bundle();\n\n            // We need to provide a default value for the widget category if it is not specified\n            if (!widget.options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {\n                widget.options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY,\n                        AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            }\n\n            provider.widgets.add(widget);\n\n            onWidgetProviderAddedOrChangedLocked(widget);\n\n            final int widgetCount = provider.widgets.size();\n            if (widgetCount == 1) {\n                // Tell the provider that it's ready.\n                sendEnableIntentLocked(provider);\n            }\n\n            // Send an update now -- We need this update now, and just for this appWidgetId.\n            // It's less critical when the next one happens, so when we schedule the next one,\n            // we add updatePeriodMillis to its start time. That time will have some slop,\n            // but that's okay.\n            sendUpdateIntentLocked(provider, new int[] {appWidgetId});\n\n            // Schedule the future updates.\n            registerForBroadcastsLocked(provider, getWidgetIds(provider.widgets));\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Bound widget \" + appWidgetId + \" to provider \" + provider.id);\n            }\n        }\n\n        return true;\n    }\n\n    @Override\n    public int[] getAppWidgetIds(ComponentName componentName) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIds() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider != null) {\n                return getWidgetIds(provider.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public int[] getAppWidgetIdsForHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIdsForHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access its hosts.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                return getWidgetIds(host.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public boolean bindRemoteViewsService(String callingPackage, int appWidgetId, Intent intent,\n            IApplicationThread caller, IBinder activtiyToken, IServiceConnection connection,\n            int flags) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"bindRemoteViewsService() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id\");\n            }\n\n            // Make sure the widget has a provider.\n            if (widget.provider == null) {\n                throw new IllegalArgumentException(\"No provider for widget \"\n                        + appWidgetId);\n            }\n\n            ComponentName componentName = intent.getComponent();\n\n            // Ensure that the service belongs to the same package as the provider.\n            // But this is not enough as they may be under different users - see below...\n            String providerPackage = widget.provider.id.componentName.getPackageName();\n            String servicePackage = componentName.getPackageName();\n            if (!servicePackage.equals(providerPackage)) {\n                throw new SecurityException(\"The taget service not in the same package\"\n                        + \" as the widget provider\");\n            }\n\n            // Make sure this service exists under the same user as the provider and\n            // requires a permission which allows only the system to bind to it.\n            mSecurityPolicy.enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                    componentName, widget.provider.getUserId());\n\n            // Good to go - the service package is correct, it exists for the correct\n            // user, and requires the bind permission.\n\n            final long callingIdentity = Binder.clearCallingIdentity();\n            try {\n                // Ask ActivityManager to bind it. Notice that we are binding the service with the\n                // caller app instead of DevicePolicyManagerService.\n                if (ActivityManager.getService().bindService(\n                        caller, activtiyToken, intent,\n                        intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                        connection, flags & (Context.BIND_AUTO_CREATE\n                                | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE),\n                        mContext.getOpPackageName(), widget.provider.getUserId()) != 0) {\n\n                    // Add it to the mapping of RemoteViewsService to appWidgetIds so that we\n                    // can determine when we can call back to the RemoteViewsService later to\n                    // destroy associated factories.\n                    incrementAppWidgetServiceRefCount(appWidgetId,\n                            Pair.create(widget.provider.id.uid, new FilterComparison(intent)));\n                    return true;\n                }\n            } catch (RemoteException ex) {\n                // Same process, should not happen.\n            } finally {\n                Binder.restoreCallingIdentity(callingIdentity);\n            }\n        }\n\n        // Failed to bind.\n        return false;\n    }\n\n    @Override\n    public void deleteHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts in its uid and package.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host == null) {\n                return;\n            }\n\n            deleteHostLocked(host);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted host \" + host.id);\n            }\n        }\n    }\n\n    @Override\n    public void deleteAllHosts() {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAllHosts() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            boolean changed = false;\n\n            final int N = mHosts.size();\n            for (int i = N - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n\n                // Delete only hosts in the calling uid.\n                if (host.id.uid == Binder.getCallingUid()) {\n                    deleteHostLocked(host);\n                    changed = true;\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Deleted host \" + host.id);\n                    }\n                }\n            }\n\n            if (changed) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    @Override\n    public AppWidgetProviderInfo getAppWidgetInfo(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetInfo() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.provider != null && !widget.provider.zombie) {\n                return cloneIfLocalBinder(widget.provider.getInfoLocked(mContext));\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public RemoteViews getAppWidgetViews(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetViews() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null) {\n                return cloneIfLocalBinder(widget.getEffectiveViewsLocked());\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetOptions(String callingPackage, int appWidgetId, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            // Merge the options.\n            widget.options.putAll(options);\n\n            // Send the broacast to notify the provider that options changed.\n            sendOptionsChangedIntentLocked(widget);\n\n            saveGroupStateAsync(userId);\n        }\n    }\n\n    @Override\n    public Bundle getAppWidgetOptions(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.options != null) {\n                return cloneIfLocalBinder(widget.options);\n            }\n\n            return Bundle.EMPTY;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, false);\n    }\n\n    @Override\n    public void partiallyUpdateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"partiallyUpdateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, true);\n    }\n\n    @Override\n    public void notifyAppWidgetViewDataChanged(String callingPackage, int[] appWidgetIds,\n            int viewId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"notifyAppWidgetViewDataChanged() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    scheduleNotifyAppWidgetViewDataChanged(widget, viewId);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProvider(ComponentName componentName, RemoteViews views) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.w(TAG, \"Provider doesn't exist \" + providerId);\n                return;\n            }\n\n            ArrayList<Widget> instances = provider.widgets;\n            final int N = instances.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = instances.get(i);\n                updateAppWidgetInstanceLocked(widget, views, false);\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProviderInfo(ComponentName componentName, String metadataKey) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n            if (provider == null) {\n                throw new IllegalArgumentException(\n                        componentName + \" is not a valid AppWidget provider\");\n            }\n            if (Objects.equals(provider.infoTag, metadataKey)) {\n                // No change\n                return;\n            }\n\n            String keyToUse = metadataKey == null\n                    ? AppWidgetManager.META_DATA_APPWIDGET_PROVIDER : metadataKey;\n            AppWidgetProviderInfo info = parseAppWidgetProviderInfo(mContext, providerId,\n                    provider.getPartialInfoLocked().providerInfo, keyToUse);\n            if (info == null) {\n                throw new IllegalArgumentException(\"Unable to parse \" + keyToUse\n                        + \" meta-data to a valid AppWidget provider\");\n            }\n\n            provider.setInfoLocked(info);\n            provider.infoTag = metadataKey;\n\n            // Update all widgets for this provider\n            final int N = provider.widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = provider.widgets.get(i);\n                scheduleNotifyProviderChangedLocked(widget);\n                updateAppWidgetInstanceLocked(widget, widget.views, false /* isPartialUpdate */);\n            }\n\n            saveGroupStateAsync(userId);\n            scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n        }\n    }\n\n    @Override\n    public boolean isRequestPinAppWidgetSupported() {\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + Binder.getCallingUid()\n                        + \" query information about app widgets\");\n                return false;\n            }\n        }\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .isRequestPinItemSupported(UserHandle.getCallingUserId(),\n                        LauncherApps.PinItemRequest.REQUEST_TYPE_APPWIDGET);\n    }\n\n    @Override\n    public boolean requestPinAppWidget(String callingPackage, ComponentName componentName,\n            Bundle extras, IntentSender resultSender) {\n        final int callingUid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(callingUid);\n\n        if (DEBUG) {\n            Slog.i(TAG, \"requestPinAppWidget() \" + userId);\n        }\n\n        final AppWidgetProviderInfo info;\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // Look for the widget associated with the caller.\n            Provider provider = lookupProviderLocked(new ProviderId(callingUid, componentName));\n            if (provider == null || provider.zombie) {\n                return false;\n            }\n            info = provider.getInfoLocked(mContext);\n            if ((info.widgetCategory & AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN) == 0) {\n                return false;\n            }\n        }\n\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .requestPinAppWidget(callingPackage, info, extras, resultSender, userId);\n    }\n\n    @Override\n    public ParceledListSlice<AppWidgetProviderInfo> getInstalledProvidersForProfile(int categoryFilter,\n            int profileId, String packageName) {\n        final int userId = UserHandle.getCallingUserId();\n        final int callingUid = Binder.getCallingUid();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getInstalledProvidersForProfiles() \" + userId);\n        }\n\n        // Ensure the profile is in the group and enabled.\n        if (!mSecurityPolicy.isEnabledGroupProfile(profileId)) {\n            return null;\n        }\n\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + callingUid\n                        + \" cannot access widget providers\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            ArrayList<AppWidgetProviderInfo> result = new ArrayList<AppWidgetProviderInfo>();\n\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n                final String providerPackageName = provider.id.componentName.getPackageName();\n\n                // Ignore an invalid provider, one not matching the filter,\n                // or one that isn't in the given package, if any.\n                boolean inPackage = packageName == null\n                        || providerPackageName.equals(packageName);\n                if (provider.zombie || (info.widgetCategory & categoryFilter) == 0 || !inPackage) {\n                    continue;\n                }\n\n                // Add providers only for the requested profile that are allowlisted.\n                final int providerProfileId = info.getProfile().getIdentifier();\n                if (providerProfileId == profileId\n                        && mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                        providerPackageName, providerProfileId)\n                        && !mPackageManagerInternal.filterAppAccess(providerPackageName, callingUid,\n                        userId)) {\n                    result.add(cloneIfLocalBinder(info));\n                }\n            }\n\n            return new ParceledListSlice<AppWidgetProviderInfo>(result);\n        }\n    }\n\n    private void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views, boolean partially) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    updateAppWidgetInstanceLocked(widget, views, partially);\n                }\n            }\n        }\n    }\n\n    private int incrementAndGetAppWidgetIdLocked(int userId) {\n        final int appWidgetId = peekNextAppWidgetIdLocked(userId) + 1;\n        mNextAppWidgetIds.put(userId, appWidgetId);\n        return appWidgetId;\n    }\n\n    private void setMinAppWidgetIdLocked(int userId, int minWidgetId) {\n        final int nextAppWidgetId = peekNextAppWidgetIdLocked(userId);\n        if (nextAppWidgetId < minWidgetId) {\n            mNextAppWidgetIds.put(userId, minWidgetId);\n        }\n    }\n\n    private int peekNextAppWidgetIdLocked(int userId) {\n        if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n            return AppWidgetManager.INVALID_APPWIDGET_ID + 1;\n        } else {\n            return mNextAppWidgetIds.get(userId);\n        }\n    }\n\n    private Host lookupOrAddHostLocked(HostId id) {\n        Host host = lookupHostLocked(id);\n        if (host != null) {\n            return host;\n        }\n        ensureHostCountBeforeAddLocked(id);\n        host = new Host();\n        host.id = id;\n        mHosts.add(host);\n\n        return host;\n    }\n\n    /**\n     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n     * removes the oldest host.\n     */\n    private void ensureHostCountBeforeAddLocked(@NonNull final HostId hostId) {\n        final List<Host> hosts = new ArrayList<>();\n        for (Host host : mHosts) {\n            if (host.id.uid == hostId.uid\n                    && host.id.packageName.equals(hostId.packageName)) {\n                hosts.add(host);\n            }\n        }\n        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n            deleteHostLocked(hosts.remove(0));\n        }\n    }\n\n    private void deleteHostLocked(Host host) {\n        final int N = host.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = host.widgets.remove(i);\n            deleteAppWidgetLocked(widget);\n        }\n        mHosts.remove(host);\n\n        // it's gone or going away, abruptly drop the callback connection\n        host.callbacks = null;\n    }\n\n    private void deleteAppWidgetLocked(Widget widget) {\n        // We first unbind all services that are bound to this id\n        // Check if we need to destroy any services (if no other app widgets are\n        // referencing the same service)\n        decrementAppWidgetServiceRefCount(widget);\n\n        Host host = widget.host;\n        host.widgets.remove(widget);\n        pruneHostLocked(host);\n\n        removeWidgetLocked(widget);\n\n        Provider provider = widget.provider;\n        if (provider != null) {\n            provider.widgets.remove(widget);\n            if (!provider.zombie) {\n                // send the broacast saying that this appWidgetId has been deleted\n                sendDeletedIntentLocked(widget);\n\n                if (provider.widgets.isEmpty()) {\n                    // cancel the future updates\n                    cancelBroadcastsLocked(provider);\n\n                    // send the broacast saying that the provider is not in use any more\n                    sendDisabledIntentLocked(provider);\n                }\n            }\n        }\n    }\n\n    private void cancelBroadcastsLocked(Provider provider) {\n        if (DEBUG) {\n            Slog.i(TAG, \"cancelBroadcastsLocked() for \" + provider);\n        }\n        if (provider.broadcast != null) {\n            final PendingIntent broadcast = provider.broadcast;\n            mSaveStateHandler.post(() -> {\n                    mAlarmManager.cancel(broadcast);\n                    broadcast.cancel();\n            });\n            provider.broadcast = null;\n        }\n    }\n\n    // Destroys the cached factory on the RemoteViewsService's side related to the specified intent\n    private void destroyRemoteViewsService(final Intent intent, Widget widget) {\n        final ServiceConnection conn = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName name, IBinder service) {\n                final IRemoteViewsFactory cb = IRemoteViewsFactory.Stub.asInterface(service);\n                try {\n                    cb.onDestroy(intent);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Error calling remove view factory\", re);\n                }\n                mContext.unbindService(this);\n            }\n\n            @Override\n            public void onServiceDisconnected(ComponentName name) {\n                // Do nothing\n            }\n        };\n\n        // Bind to the service and remove the static intent->factory mapping in the\n        // RemoteViewsService.\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, conn,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    widget.provider.id.getProfile());\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    // Adds to the ref-count for a given RemoteViewsService intent\n    private void incrementAppWidgetServiceRefCount(int appWidgetId,\n            Pair<Integer, FilterComparison> serviceId) {\n        final HashSet<Integer> appWidgetIds;\n        if (mRemoteViewsServicesAppWidgets.containsKey(serviceId)) {\n            appWidgetIds = mRemoteViewsServicesAppWidgets.get(serviceId);\n        } else {\n            appWidgetIds = new HashSet<>();\n            mRemoteViewsServicesAppWidgets.put(serviceId, appWidgetIds);\n        }\n        appWidgetIds.add(appWidgetId);\n    }\n\n    // Subtracts from the ref-count for a given RemoteViewsService intent, prompting a delete if\n    // the ref-count reaches zero.\n    private void decrementAppWidgetServiceRefCount(Widget widget) {\n        Iterator<Pair<Integer, FilterComparison>> it = mRemoteViewsServicesAppWidgets\n                .keySet().iterator();\n        while (it.hasNext()) {\n            final Pair<Integer, FilterComparison> key = it.next();\n            final HashSet<Integer> ids = mRemoteViewsServicesAppWidgets.get(key);\n            if (ids.remove(widget.appWidgetId)) {\n                // If we have removed the last app widget referencing this service, then we\n                // should destroy it and remove it from this set\n                if (ids.isEmpty()) {\n                    destroyRemoteViewsService(key.second.getIntent(), widget);\n                    it.remove();\n                }\n            }\n        }\n    }\n\n    private void saveGroupStateAsync(int groupId) {\n        mSaveStateHandler.post(new SaveStateRunnable(groupId));\n    }\n\n    private void updateAppWidgetInstanceLocked(Widget widget, RemoteViews views,\n            boolean isPartialUpdate) {\n        if (widget != null && widget.provider != null\n                && !widget.provider.zombie && !widget.host.zombie) {\n\n            if (isPartialUpdate && widget.views != null) {\n                // For a partial update, we merge the new RemoteViews with the old.\n                widget.views.mergeRemoteViews(views);\n            } else {\n                // For a full update we replace the RemoteViews completely.\n                widget.views = views;\n            }\n            int memoryUsage;\n            if ((UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) &&\n                    (widget.views != null) &&\n                    ((memoryUsage = widget.views.estimateMemoryUsage()) > mMaxWidgetBitmapMemory)) {\n                widget.views = null;\n                throw new IllegalArgumentException(\"RemoteViews for widget update exceeds\"\n                        + \" maximum bitmap memory usage (used: \" + memoryUsage\n                        + \", max: \" + mMaxWidgetBitmapMemory + \")\");\n            }\n            scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n        }\n    }\n    private void scheduleNotifyAppWidgetViewDataChanged(Widget widget, int viewId) {\n        if (viewId == ID_VIEWS_UPDATE || viewId == ID_PROVIDER_CHANGED) {\n            // A view id should never collide with these constants but a developer can call this\n            // method with a wrong id. In that case, ignore the call.\n            return;\n        }\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(viewId, requestId);\n        }\n        if (widget == null || widget.host == null || widget.host.zombie\n                || widget.host.callbacks == null || widget.provider == null\n                || widget.provider.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n        args.argi2 = viewId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_VIEW_DATA_CHANGED,\n                args).sendToTarget();\n    }\n\n\n    private void handleNotifyAppWidgetViewDataChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, int viewId, long requestId) {\n        try {\n            callbacks.viewDataChanged(appWidgetId, viewId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            // It failed; remove the callback. No need to prune because\n            // we know that this host is still referenced by this instance.\n            callbacks = null;\n        }\n\n        // If the host is unavailable, then we call the associated\n        // RemoteViewsFactory.onDataSetChanged() directly\n        synchronized (mLock) {\n            if (callbacks == null) {\n                host.callbacks = null;\n\n                Set<Pair<Integer, FilterComparison>> keys = mRemoteViewsServicesAppWidgets.keySet();\n                for (Pair<Integer, FilterComparison> key : keys) {\n                    if (mRemoteViewsServicesAppWidgets.get(key).contains(appWidgetId)) {\n                        final ServiceConnection connection = new ServiceConnection() {\n                            @Override\n                            public void onServiceConnected(ComponentName name, IBinder service) {\n                                IRemoteViewsFactory cb = IRemoteViewsFactory.Stub\n                                        .asInterface(service);\n                                try {\n                                    cb.onDataSetChangedAsync();\n                                } catch (RemoteException e) {\n                                    Slog.e(TAG, \"Error calling onDataSetChangedAsync()\", e);\n                                }\n                                mContext.unbindService(this);\n                            }\n\n                            @Override\n                            public void onServiceDisconnected(android.content.ComponentName name) {\n                                // Do nothing\n                            }\n                        };\n\n                        final int userId = UserHandle.getUserId(key.first);\n                        Intent intent = key.second.getIntent();\n\n                        // Bind to the service and call onDataSetChanged()\n                        bindService(intent, connection, new UserHandle(userId));\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleNotifyUpdateAppWidgetLocked(Widget widget, RemoteViews updateViews) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(ID_VIEWS_UPDATE, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n        if (updateViews != null) {\n            updateViews = new RemoteViews(updateViews);\n            updateViews.setProviderInstanceId(requestId);\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = updateViews;\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_UPDATE_APP_WIDGET,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyUpdateAppWidget(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, RemoteViews views, long requestId) {\n        try {\n            callbacks.updateAppWidget(appWidgetId, views);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyProviderChangedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            // When the provider changes, reset everything else.\n            widget.updateSequenceNos.clear();\n            widget.updateSequenceNos.append(ID_PROVIDER_CHANGED, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = widget.provider.getInfoLocked(mContext);\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_PROVIDER_CHANGED,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyProviderChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, AppWidgetProviderInfo info, long requestId) {\n        try {\n            callbacks.providerChanged(appWidgetId, info);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock){\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyAppWidgetRemovedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.clear();\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n            CallbackHandler.MSG_NOTIFY_APP_WIDGET_REMOVED,\n            args).sendToTarget();\n    }\n\n    private void handleNotifyAppWidgetRemoved(Host host, IAppWidgetHost callbacks, int appWidgetId,\n            long requestId) {\n        try {\n            callbacks.appWidgetRemoved(appWidgetId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyGroupHostsForProvidersChangedLocked(int userId) {\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n\n            boolean hostInGroup = false;\n            final int M = profileIds.length;\n            for (int j = 0; j < M; j++) {\n                final int profileId = profileIds[j];\n                if (host.getUserId() == profileId) {\n                    hostInGroup = true;\n                    break;\n                }\n            }\n\n            if (!hostInGroup) {\n                continue;\n            }\n\n            if (host == null || host.zombie || host.callbacks == null) {\n                continue;\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = host;\n            args.arg2 = host.callbacks;\n\n            mCallbackHandler.obtainMessage(\n                    CallbackHandler.MSG_NOTIFY_PROVIDERS_CHANGED,\n                    args).sendToTarget();\n        }\n    }\n\n    private void handleNotifyProvidersChanged(Host host, IAppWidgetHost callbacks) {\n        try {\n            callbacks.providersChanged();\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private static boolean isLocalBinder() {\n        return Process.myPid() == Binder.getCallingPid();\n    }\n\n    private static RemoteViews cloneIfLocalBinder(RemoteViews rv) {\n        if (isLocalBinder() && rv != null) {\n            return rv.clone();\n        }\n        return rv;\n    }\n\n    private static AppWidgetProviderInfo cloneIfLocalBinder(AppWidgetProviderInfo info) {\n        if (isLocalBinder() && info != null) {\n            return info.clone();\n        }\n        return info;\n    }\n\n    private static Bundle cloneIfLocalBinder(Bundle bundle) {\n        // Note: this is only a shallow copy. For now this will be fine, but it could be problematic\n        // if we start adding objects to the options. Further, it would only be an issue if keyguard\n        // used such options.\n        if (isLocalBinder() && bundle != null) {\n            return (Bundle) bundle.clone();\n        }\n        return bundle;\n    }\n\n    private Widget lookupWidgetLocked(int appWidgetId, int uid, String packageName) {\n        final int N = mWidgets.size();\n        for (int i = 0; i < N; i++) {\n            Widget widget = mWidgets.get(i);\n            if (widget.appWidgetId == appWidgetId\n                    && mSecurityPolicy.canAccessAppWidget(widget, uid, packageName)) {\n                return widget;\n            }\n        }\n        return null;\n    }\n\n    private Provider lookupProviderLocked(ProviderId id) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.id.equals(id)) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host lookupHostLocked(HostId hostId) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.equals(hostId)) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    private void pruneHostLocked(Host host) {\n        if (host.widgets.size() == 0 && host.callbacks == null) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Pruning host \" + host.id);\n            }\n            mHosts.remove(host);\n        }\n    }\n\n    private void loadGroupWidgetProvidersLocked(int[] profileIds) {\n        List<ResolveInfo> allReceivers = null;\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            List<ResolveInfo> receivers = queryIntentReceivers(intent, profileId);\n            if (receivers != null && !receivers.isEmpty()) {\n                if (allReceivers == null) {\n                    allReceivers = new ArrayList<>();\n                }\n                allReceivers.addAll(receivers);\n            }\n        }\n\n        final int N = (allReceivers == null) ? 0 : allReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo receiver = allReceivers.get(i);\n            addProviderLocked(receiver);\n        }\n    }\n\n    private boolean addProviderLocked(ResolveInfo ri) {\n        if ((ri.activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n            return false;\n        }\n\n        ComponentName componentName = new ComponentName(ri.activityInfo.packageName,\n                ri.activityInfo.name);\n        ProviderId providerId = new ProviderId(ri.activityInfo.applicationInfo.uid, componentName);\n\n        // we might have an inactive entry for this provider already due to\n        // a preceding restore operation.  if so, fix it up in place; otherwise\n        // just add this new one.\n        Provider existing = lookupProviderLocked(providerId);\n\n        // If the provider was not found it may be because it was restored and\n        // we did not know its UID so let us find if there is such one.\n        if (existing == null) {\n            ProviderId restoredProviderId = new ProviderId(UNKNOWN_UID, componentName);\n            existing = lookupProviderLocked(restoredProviderId);\n        }\n\n        AppWidgetProviderInfo info = createPartialProviderInfo(providerId, ri, existing);\n        if (info != null) {\n            if (existing != null) {\n                if (existing.zombie && !mSafeMode) {\n                    // it's a placeholder that was set up during an app restore\n                    existing.id = providerId;\n                    existing.zombie = false;\n                    existing.setPartialInfoLocked(info);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Provider placeholder now reified: \" + existing);\n                    }\n                }\n            } else {\n                Provider provider = new Provider();\n                provider.id = providerId;\n                provider.setPartialInfoLocked(info);\n                mProviders.add(provider);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    // Remove widgets for provider that are hosted in userId.\n    private void deleteWidgetsLocked(Provider provider, int userId) {\n        final int N = provider.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = provider.widgets.get(i);\n            if (userId == UserHandle.USER_ALL\n                    || userId == widget.host.getUserId()) {\n                provider.widgets.remove(i);\n                // Call back with empty RemoteViews\n                updateAppWidgetInstanceLocked(widget, null, false);\n                // clear out references to this appWidgetId\n                widget.host.widgets.remove(widget);\n                removeWidgetLocked(widget);\n                widget.provider = null;\n                pruneHostLocked(widget.host);\n                widget.host = null;\n            }\n        }\n    }\n\n    private void deleteProviderLocked(Provider provider) {\n        deleteWidgetsLocked(provider, UserHandle.USER_ALL);\n        mProviders.remove(provider);\n\n        // no need to send the DISABLE broadcast, since the receiver is gone anyway\n        cancelBroadcastsLocked(provider);\n    }\n\n    private void sendEnableIntentLocked(Provider p) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_ENABLED);\n        intent.setComponent(p.id.componentName);\n        sendBroadcastAsUser(intent, p.id.getProfile());\n    }\n\n    private void sendUpdateIntentLocked(Provider provider, int[] appWidgetIds) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    private void sendDeletedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DELETED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void sendDisabledIntentLocked(Provider provider) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DISABLED);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    public void sendOptionsChangedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_OPTIONS_CHANGED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, widget.options);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void registerForBroadcastsLocked(Provider provider, int[] appWidgetIds) {\n        AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n        if (info.updatePeriodMillis > 0) {\n            // if this is the first instance, set the alarm. otherwise,\n            // rely on the fact that we've already set it and that\n            // PendingIntent.getBroadcast will update the extras.\n            boolean alreadyRegistered = provider.broadcast != null;\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n            intent.setComponent(info.provider);\n            final long token = Binder.clearCallingIdentity();\n            try {\n                // Broadcast alarms sent by system are immutable\n                provider.broadcast = PendingIntent.getBroadcastAsUser(mContext, 1, intent,\n                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                        info.getProfile());\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (!alreadyRegistered) {\n                // Set the alarm outside of our locks; we've latched the first-time\n                // invariant and established the PendingIntent safely.\n                final long period = Math.max(info.updatePeriodMillis, MIN_UPDATE_PERIOD);\n                final PendingIntent broadcast = provider.broadcast;\n                mSaveStateHandler.post(() ->\n                    mAlarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,\n                            SystemClock.elapsedRealtime() + period, period, broadcast)\n                );\n            }\n        }\n    }\n\n    private static int[] getWidgetIds(ArrayList<Widget> widgets) {\n        int instancesSize = widgets.size();\n        int appWidgetIds[] = new int[instancesSize];\n        for (int i = 0; i < instancesSize; i++) {\n            appWidgetIds[i] = widgets.get(i).appWidgetId;\n        }\n        return appWidgetIds;\n    }\n\n    private static void dumpProviderLocked(Provider provider, int index, PrintWriter pw) {\n        AppWidgetProviderInfo info = provider.getPartialInfoLocked();\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] provider \");\n        pw.println(provider.id);\n        pw.print(\"    min=(\"); pw.print(info.minWidth);\n        pw.print(\"x\"); pw.print(info.minHeight);\n        pw.print(\")   minResize=(\"); pw.print(info.minResizeWidth);\n        pw.print(\"x\"); pw.print(info.minResizeHeight);\n        pw.print(\") updatePeriodMillis=\");\n        pw.print(info.updatePeriodMillis);\n        pw.print(\" resizeMode=\");\n        pw.print(info.resizeMode);\n        pw.print(\" widgetCategory=\");\n        pw.print(info.widgetCategory);\n        pw.print(\" autoAdvanceViewId=\");\n        pw.print(info.autoAdvanceViewId);\n        pw.print(\" initialLayout=#\");\n        pw.print(Integer.toHexString(info.initialLayout));\n        pw.print(\" initialKeyguardLayout=#\");\n        pw.print(Integer.toHexString(info.initialKeyguardLayout));\n        pw.print(\"   zombie=\"); pw.println(provider.zombie);\n    }\n\n    private static void dumpHost(Host host, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] hostId=\");\n        pw.println(host.id);\n        pw.print(\"    callbacks=\"); pw.println(host.callbacks);\n        pw.print(\"    widgets.size=\"); pw.print(host.widgets.size());\n        pw.print(\" zombie=\"); pw.println(host.zombie);\n    }\n\n    private static void dumpGrant(Pair<Integer, String> grant, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(']');\n        pw.print(\" user=\"); pw.print(grant.first);\n        pw.print(\" package=\"); pw.println(grant.second);\n    }\n\n    private static void dumpWidget(Widget widget, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] id=\");\n        pw.println(widget.appWidgetId);\n        pw.print(\"    host=\");\n        pw.println(widget.host.id);\n        if (widget.provider != null) {\n            pw.print(\"    provider=\"); pw.println(widget.provider.id);\n        }\n        if (widget.host != null) {\n            pw.print(\"    host.callbacks=\"); pw.println(widget.host.callbacks);\n        }\n        if (widget.views != null) {\n            pw.print(\"    views=\"); pw.println(widget.views);\n        }\n    }\n\n    private static void serializeProvider(TypedXmlSerializer out, Provider p) throws IOException {\n        out.startTag(null, \"p\");\n        out.attribute(null, \"pkg\", p.id.componentName.getPackageName());\n        out.attribute(null, \"cl\", p.id.componentName.getClassName());\n        out.attributeIntHex(null, \"tag\", p.tag);\n        if (!TextUtils.isEmpty(p.infoTag)) {\n            out.attribute(null, \"info_tag\", p.infoTag);\n        }\n        out.endTag(null, \"p\");\n    }\n\n    private static void serializeHost(TypedXmlSerializer out, Host host) throws IOException {\n        out.startTag(null, \"h\");\n        out.attribute(null, \"pkg\", host.id.packageName);\n        out.attributeIntHex(null, \"id\", host.id.hostId);\n        out.attributeIntHex(null, \"tag\", host.tag);\n        out.endTag(null, \"h\");\n    }\n\n    private static void serializeAppWidget(TypedXmlSerializer out, Widget widget,\n            boolean saveRestoreCompleted) throws IOException {\n        out.startTag(null, \"g\");\n        out.attributeIntHex(null, \"id\", widget.appWidgetId);\n        out.attributeIntHex(null, \"rid\", widget.restoredId);\n        out.attributeIntHex(null, \"h\", widget.host.tag);\n        if (widget.provider != null) {\n            out.attributeIntHex(null, \"p\", widget.provider.tag);\n        }\n        if (widget.options != null) {\n            int minWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH);\n            int minHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);\n            int maxWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH);\n            int maxHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT);\n            out.attributeIntHex(null, \"min_width\", (minWidth > 0) ? minWidth : 0);\n            out.attributeIntHex(null, \"min_height\", (minHeight > 0) ? minHeight : 0);\n            out.attributeIntHex(null, \"max_width\", (maxWidth > 0) ? maxWidth : 0);\n            out.attributeIntHex(null, \"max_height\", (maxHeight > 0) ? maxHeight : 0);\n            out.attributeIntHex(null, \"host_category\", widget.options.getInt(\n                    AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY));\n            if (saveRestoreCompleted) {\n                boolean restoreCompleted = widget.options.getBoolean(\n                        AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED);\n                out.attributeBoolean(null, \"restore_completed\", restoreCompleted);\n            }\n        }\n        out.endTag(null, \"g\");\n    }\n\n    private static Bundle parseWidgetIdOptions(TypedXmlPullParser parser) {\n        Bundle options = new Bundle();\n        boolean restoreCompleted = parser.getAttributeBoolean(null, \"restore_completed\", false);\n        if (restoreCompleted) {\n            options.putBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED, true);\n        }\n        int minWidth = parser.getAttributeIntHex(null, \"min_width\", -1);\n        if (minWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, minWidth);\n        }\n        int minHeight = parser.getAttributeIntHex(null, \"min_height\", -1);\n        if (minHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, minHeight);\n        }\n        int maxWidth = parser.getAttributeIntHex(null, \"max_width\", -1);\n        if (maxWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, maxWidth);\n        }\n        int maxHeight = parser.getAttributeIntHex(null, \"max_height\", -1);\n        if (maxHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, maxHeight);\n        }\n        int category = parser.getAttributeIntHex(null, \"host_category\",\n                AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN);\n        if (category != AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY, category);\n        }\n        return options;\n    }\n\n    @Override\n    public List<String> getWidgetParticipants(int userId) {\n        return mBackupRestoreController.getWidgetParticipants(userId);\n    }\n\n    @Override\n    public byte[] getWidgetState(String packageName, int userId) {\n        return mBackupRestoreController.getWidgetState(packageName, userId);\n    }\n\n    @Override\n    public void systemRestoreStarting(int userId) {\n        mBackupRestoreController.systemRestoreStarting(userId);\n    }\n\n    @Override\n    public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n        mBackupRestoreController.restoreWidgetState(packageName, restoredState, userId);\n    }\n\n    @Override\n    public void systemRestoreFinished(int userId) {\n        mBackupRestoreController.systemRestoreFinished(userId);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private AppWidgetProviderInfo createPartialProviderInfo(ProviderId providerId, ResolveInfo ri,\n            Provider provider) {\n        boolean hasXmlDefinition = false;\n        Bundle metaData = ri.activityInfo.metaData;\n        if (metaData == null) {\n            return null;\n        }\n\n        if (provider != null && !TextUtils.isEmpty(provider.infoTag)) {\n            hasXmlDefinition = metaData.getInt(provider.infoTag) != 0;\n        }\n        hasXmlDefinition |= metaData.getInt(AppWidgetManager.META_DATA_APPWIDGET_PROVIDER) != 0;\n\n        if (hasXmlDefinition) {\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = ri.activityInfo;\n            return info;\n        }\n        return null;\n    }\n\n    private static AppWidgetProviderInfo parseAppWidgetProviderInfo(Context context,\n            ProviderId providerId, ActivityInfo activityInfo, String metadataKey) {\n        final PackageManager pm = context.getPackageManager();\n        try (XmlResourceParser parser = activityInfo.loadXmlMetaData(pm, metadataKey)) {\n            if (parser == null) {\n                Slog.w(TAG, \"No \" + metadataKey + \" meta-data for AppWidget provider '\"\n                        + providerId + '\\'');\n                return null;\n            }\n\n            AttributeSet attrs = Xml.asAttributeSet(parser);\n\n            int type;\n            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                    && type != XmlPullParser.START_TAG) {\n                // drain whitespace, comments, etc.\n            }\n\n            String nodeName = parser.getName();\n            if (!\"appwidget-provider\".equals(nodeName)) {\n                Slog.w(TAG, \"Meta-data does not start with appwidget-provider tag for\"\n                        + \" AppWidget provider \" + providerId.componentName\n                        + \" for user \" + providerId.uid);\n                return null;\n            }\n\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = activityInfo;\n\n            final Resources resources;\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final int userId = UserHandle.getUserId(providerId.uid);\n                final ApplicationInfo app = pm.getApplicationInfoAsUser(activityInfo.packageName,\n                        0, userId);\n                resources = pm.getResourcesForApplication(app);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n\n            TypedArray sa = resources.obtainAttributes(attrs,\n                    com.android.internal.R.styleable.AppWidgetProviderInfo);\n\n            // These dimensions has to be resolved in the application's context.\n            // We simply send back the raw complex data, which will be\n            // converted to dp in {@link AppWidgetManager#getAppWidgetInfo}.\n            TypedValue value = sa\n                    .peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minWidth);\n            info.minWidth = value != null ? value.data : 0;\n            value = sa.peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minHeight);\n            info.minHeight = value != null ? value.data : 0;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeWidth);\n            info.minResizeWidth = value != null ? value.data : info.minWidth;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeHeight);\n            info.minResizeHeight = value != null ? value.data : info.minHeight;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeWidth);\n            info.maxResizeWidth = value != null ? value.data : 0;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeHeight);\n            info.maxResizeHeight = value != null ? value.data : 0;\n\n            info.targetCellWidth = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellWidth, 0);\n            info.targetCellHeight = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellHeight, 0);\n\n            info.updatePeriodMillis = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_updatePeriodMillis, 0);\n            info.initialLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_initialLayout, ID_NULL);\n            info.initialKeyguardLayout = sa.getResourceId(com.android.internal.R.styleable.\n                    AppWidgetProviderInfo_initialKeyguardLayout, ID_NULL);\n\n            String className = sa\n                    .getString(com.android.internal.R.styleable.AppWidgetProviderInfo_configure);\n            if (className != null) {\n                info.configure = new ComponentName(providerId.componentName.getPackageName(),\n                        className);\n            }\n            info.label = activityInfo.loadLabel(pm).toString();\n            info.icon = activityInfo.getIconResource();\n            info.previewImage = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewImage, ID_NULL);\n            info.previewLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewLayout, ID_NULL);\n            info.autoAdvanceViewId = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_autoAdvanceViewId,\n                    View.NO_ID);\n            info.resizeMode = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_resizeMode,\n                    AppWidgetProviderInfo.RESIZE_NONE);\n            info.widgetCategory = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetCategory,\n                    AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            info.widgetFeatures = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetFeatures, 0);\n            info.descriptionRes = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_description, ID_NULL);\n            sa.recycle();\n            return info;\n        } catch (IOException | PackageManager.NameNotFoundException | XmlPullParserException e) {\n            // Ok to catch Exception here, because anything going wrong because\n            // of what a client process passes to us should not be fatal for the\n            // system process.\n            Slog.w(TAG, \"XML parsing failed for AppWidget provider \"\n                    + providerId.componentName + \" for user \" + providerId.uid, e);\n            return null;\n        }\n    }\n\n    private int getUidForPackage(String packageName, int userId) {\n        PackageInfo pkgInfo = null;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            pkgInfo = mPackageManager.getPackageInfo(packageName, 0, userId);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local call\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n\n        if (pkgInfo == null || pkgInfo.applicationInfo == null) {\n            return -1;\n        }\n\n        return pkgInfo.applicationInfo.uid;\n    }\n\n    private ActivityInfo getProviderInfo(ComponentName componentName, int userId) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setComponent(componentName);\n\n        List<ResolveInfo> receivers = queryIntentReceivers(intent, userId);\n        // We are setting component, so there is only one or none.\n        if (!receivers.isEmpty()) {\n            return receivers.get(0).activityInfo;\n        }\n\n        return null;\n    }\n\n    private List<ResolveInfo> queryIntentReceivers(Intent intent, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            int flags = PackageManager.GET_META_DATA;\n\n            // We really need packages to be around and parsed to know if they\n            // provide widgets.\n            flags |= PackageManager.MATCH_DEBUG_TRIAGED_MISSING;\n\n            // Widget hosts that are non-crypto aware may be hosting widgets\n            // from a profile that is still locked, so let them see those\n            // widgets.\n            if (isProfileWithUnlockedParent(userId)) {\n                flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE\n                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE;\n            }\n\n            // Widgets referencing shared libraries need to have their\n            // dependencies loaded.\n            flags |= PackageManager.GET_SHARED_LIBRARY_FILES;\n\n            return mPackageManager.queryIntentReceivers(intent,\n                    intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                    flags, userId).getList();\n        } catch (RemoteException re) {\n            return Collections.emptyList();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * This does not use the usual onUserUnlocked() listener mechanism because it is\n     * invoked at a choreographed point in the middle of the user unlock sequence,\n     * before the boot-completed broadcast is issued and the listeners notified.\n     */\n    void handleUserUnlocked(int userId) {\n        if (isProfileWithLockedParent(userId)) {\n            return;\n        }\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            Slog.w(TAG, \"User \" + userId + \" is no longer unlocked - exiting\");\n            return;\n        }\n        long time = SystemClock.elapsedRealtime();\n        synchronized (mLock) {\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget ensure\");\n            ensureGroupStateLoadedLocked(userId);\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget reload\");\n            reloadWidgetsMaskedStateForGroup(mSecurityPolicy.getGroupParent(userId));\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n\n                // Send broadcast only to the providers of the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n\n                if (provider.widgets.size() > 0) {\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,\n                            \"appwidget init \" + provider.id.componentName.getPackageName());\n                    sendEnableIntentLocked(provider);\n                    int[] appWidgetIds = getWidgetIds(provider.widgets);\n                    sendUpdateIntentLocked(provider, appWidgetIds);\n                    registerForBroadcastsLocked(provider, appWidgetIds);\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                }\n            }\n        }\n        Slog.i(TAG, \"Processing of handleUserUnlocked u\" + userId + \" took \"\n                + (SystemClock.elapsedRealtime() - time) + \" ms\");\n    }\n\n    // only call from initialization -- it assumes that the data structures are all empty\n    private void loadGroupStateLocked(int[] profileIds) {\n        // We can bind the widgets to host and providers only after\n        // reading the host and providers for all users since a widget\n        // can have a host and a provider in different users.\n        List<LoadedWidgetState> loadedWidgets = new ArrayList<>();\n\n        int version = 0;\n\n        final int profileIdCount = profileIds.length;\n        for (int i = 0; i < profileIdCount; i++) {\n            final int profileId = profileIds[i];\n\n            // No file written for this user - nothing to do.\n            AtomicFile file = getSavedStateFile(profileId);\n            try (FileInputStream stream = file.openRead()) {\n                version = readProfileStateFromFileLocked(stream, profileId, loadedWidgets);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to read state: \" + e);\n            }\n        }\n\n        if (version >= 0) {\n            // Hooke'm up...\n            bindLoadedWidgetsLocked(loadedWidgets);\n\n            // upgrade the database if needed\n            performUpgradeLocked(version);\n        } else {\n            // failed reading, clean up\n            Slog.w(TAG, \"Failed to read state, clearing widgets and hosts.\");\n            clearWidgetsLocked();\n            mHosts.clear();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                mProviders.get(i).widgets.clear();\n            }\n        }\n    }\n\n    private void bindLoadedWidgetsLocked(List<LoadedWidgetState> loadedWidgets) {\n        final int loadedWidgetCount = loadedWidgets.size();\n        for (int i = loadedWidgetCount - 1; i >= 0; i--) {\n            LoadedWidgetState loadedWidget = loadedWidgets.remove(i);\n            Widget widget = loadedWidget.widget;\n\n            widget.provider = findProviderByTag(loadedWidget.providerTag);\n            if (widget.provider == null) {\n                // This provider is gone. We just let the host figure out\n                // that this happened when it fails to load it.\n                continue;\n            }\n\n            widget.host = findHostByTag(loadedWidget.hostTag);\n            if (widget.host == null) {\n                // This host is gone.\n                continue;\n            }\n\n            widget.provider.widgets.add(widget);\n            widget.host.widgets.add(widget);\n            addWidgetLocked(widget);\n        }\n    }\n\n    private Provider findProviderByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.tag == tag) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host findHostByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            if (host.tag == tag) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n     */\n    void addWidgetLocked(Widget widget) {\n        if (DEBUG) {\n            Slog.i(TAG, \"addWidgetLocked() \" + widget);\n        }\n        ensureWidgetCountBeforeAddLocked(widget);\n        mWidgets.add(widget);\n\n        onWidgetProviderAddedOrChangedLocked(widget);\n    }\n\n    /**\n     * Ensures that the widget count for the widget's host is not greater than the maximum\n     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n     * from the host until the count is less than or equal to the maximum.\n     */\n    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n        if (widget.host == null || widget.host.id == null) {\n            return;\n        }\n        final List<Widget> widgetsInSameHost = new ArrayList<>();\n        for (Widget w : mWidgets) {\n            if (w.host != null && widget.host.id.equals(w.host.id)) {\n                widgetsInSameHost.add(w);\n            }\n        }\n        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n            removeWidgetLocked(widgetsInSameHost.remove(0));\n        }\n    }\n\n    /**\n     * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n     * that have bound widgets.\n     */\n    void onWidgetProviderAddedOrChangedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        int userId = widget.provider.getUserId();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                mWidgetPackages.put(userId, packages = new ArraySet<String>());\n            }\n            packages.add(widget.provider.id.componentName.getPackageName());\n        }\n\n        // If we are adding a widget it might be for a provider that\n        // is currently masked, if so mask the widget.\n        if (widget.provider.isMaskedLocked()) {\n            maskWidgetsViewsLocked(widget.provider, widget);\n        } else {\n            widget.clearMaskedViewsLocked();\n        }\n    }\n\n    /**\n     * Removes a widget from mWidgets and updates the cache of bound widget provider packages.\n     * If there are other widgets with the same package, leaves it in the cache, otherwise it\n     * removes the associated package from the cache.\n     */\n    void removeWidgetLocked(Widget widget) {\n        mWidgets.remove(widget);\n        onWidgetRemovedLocked(widget);\n        scheduleNotifyAppWidgetRemovedLocked(widget);\n    }\n\n    private void onWidgetRemovedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        final int userId = widget.provider.getUserId();\n        final String packageName = widget.provider.id.componentName.getPackageName();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                return;\n            }\n            // Check if there is any other widget with the same package name.\n            // Remove packageName if none.\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget w = mWidgets.get(i);\n                if (w.provider == null) continue;\n                if (w.provider.getUserId() == userId\n                        && packageName.equals(w.provider.id.componentName.getPackageName())) {\n                    return;\n                }\n            }\n            packages.remove(packageName);\n        }\n    }\n\n    /**\n     * Clears all widgets and associated cache of packages with bound widgets.\n     */\n    void clearWidgetsLocked() {\n        mWidgets.clear();\n\n        onWidgetsClearedLocked();\n    }\n\n    private void onWidgetsClearedLocked() {\n        synchronized (mWidgetPackagesLock) {\n            mWidgetPackages.clear();\n        }\n    }\n\n    @Override\n    public boolean isBoundWidgetPackage(String packageName, int userId) {\n        if (Binder.getCallingUid() != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Only the system process can call this\");\n        }\n        synchronized (mWidgetPackagesLock) {\n            final ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages != null) {\n                return packages.contains(packageName);\n            }\n        }\n        return false;\n    }\n\n    private void saveStateLocked(int userId) {\n        tagProvidersAndHosts();\n\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            AtomicFile file = getSavedStateFile(profileId);\n            FileOutputStream stream;\n            try {\n                stream = file.startWrite();\n                if (writeProfileStateToFileLocked(stream, profileId)) {\n                    file.finishWrite(stream);\n                } else {\n                    file.failWrite(stream);\n                    Slog.w(TAG, \"Failed to save state, restoring backup.\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed open state file for write: \" + e);\n            }\n        }\n    }\n\n    private void tagProvidersAndHosts() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = i;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = i;\n        }\n    }\n\n    private void clearProvidersAndHostsTagsLocked() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = TAG_UNDEFINED;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = TAG_UNDEFINED;\n        }\n    }\n\n    private boolean writeProfileStateToFileLocked(FileOutputStream stream, int userId) {\n        int N;\n\n        try {\n            TypedXmlSerializer out = Xml.resolveSerializer(stream);\n            out.startDocument(null, true);\n            out.startTag(null, \"gs\");\n            out.attributeInt(null, \"version\", CURRENT_VERSION);\n\n            N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                // Save only providers for the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n                if (provider.shouldBePersisted()) {\n                    serializeProvider(out, provider);\n                }\n            }\n\n            N = mHosts.size();\n            for (int i = 0; i < N; i++) {\n                Host host = mHosts.get(i);\n                // Save only hosts for the user.\n                if (host.getUserId() != userId) {\n                    continue;\n                }\n                serializeHost(out, host);\n            }\n\n            N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                // Save only widgets hosted by the user.\n                if (widget.host.getUserId() != userId) {\n                    continue;\n                }\n                serializeAppWidget(out, widget, true);\n            }\n\n            Iterator<Pair<Integer, String>> it = mPackagesWithBindWidgetPermission.iterator();\n            while (it.hasNext()) {\n                Pair<Integer, String> binding = it.next();\n                // Save only white listings for the user.\n                if (binding.first != userId) {\n                    continue;\n                }\n                out.startTag(null, \"b\");\n                out.attribute(null, \"packageName\", binding.second);\n                out.endTag(null, \"b\");\n            }\n\n            out.endTag(null, \"gs\");\n            out.endDocument();\n            return true;\n        } catch (IOException e) {\n            Slog.w(TAG, \"Failed to write state: \" + e);\n            return false;\n        }\n    }\n\n    private int readProfileStateFromFileLocked(FileInputStream stream, int userId,\n            List<LoadedWidgetState> outLoadedWidgets) {\n        int version = -1;\n        try {\n            TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n\n            int legacyProviderIndex = -1;\n            int legacyHostIndex = -1;\n            int type;\n            do {\n                type = parser.next();\n                if (type == XmlPullParser.START_TAG) {\n                    String tag = parser.getName();\n                    if (\"gs\".equals(tag)) {\n                        version = parser.getAttributeInt(null, \"version\", 0);\n                    } else if (\"p\".equals(tag)) {\n                        legacyProviderIndex++;\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n                        String cl = parser.getAttributeValue(null, \"cl\");\n\n                        pkg = getCanonicalPackageName(pkg, cl, userId);\n                        if (pkg == null) {\n                            continue;\n                        }\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            continue;\n                        }\n\n                        ComponentName componentName = new ComponentName(pkg, cl);\n\n                        ActivityInfo providerInfo = getProviderInfo(componentName, userId);\n                        if (providerInfo == null) {\n                            continue;\n                        }\n\n                        ProviderId providerId = new ProviderId(uid, componentName);\n                        Provider provider = lookupProviderLocked(providerId);\n\n                        if (provider == null && mSafeMode) {\n                            // if we're in safe mode, make a temporary one\n                            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                            info.provider = providerId.componentName;\n                            info.providerInfo = providerInfo;\n\n                            provider = new Provider();\n                            provider.setPartialInfoLocked(info);\n                            provider.zombie = true;\n                            provider.id = providerId;\n                            mProviders.add(provider);\n                        }\n\n                        final int providerTag = parser.getAttributeIntHex(null, \"tag\",\n                                legacyProviderIndex);\n                        provider.tag = providerTag;\n                        provider.infoTag = parser.getAttributeValue(null, \"info_tag\");\n                    } else if (\"h\".equals(tag)) {\n                        legacyHostIndex++;\n                        Host host = new Host();\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            host.zombie = true;\n                        }\n\n                        if (!host.zombie || mSafeMode) {\n                            // In safe mode, we don't discard the hosts we don't recognize\n                            // so that they're not pruned from our list. Otherwise, we do.\n                            final int hostId = parser.getAttributeIntHex(null, \"id\");\n                            final int hostTag = parser.getAttributeIntHex(null, \"tag\",\n                                    legacyHostIndex);\n\n                            host.tag = hostTag;\n                            host.id = new HostId(uid, hostId, pkg);\n                            mHosts.add(host);\n                        }\n                    } else if (\"b\".equals(tag)) {\n                        String packageName = parser.getAttributeValue(null, \"packageName\");\n                        final int uid = getUidForPackage(packageName, userId);\n                        if (uid >= 0) {\n                            Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                            mPackagesWithBindWidgetPermission.add(packageId);\n                        }\n                    } else if (\"g\".equals(tag)) {\n                        Widget widget = new Widget();\n                        widget.appWidgetId = parser.getAttributeIntHex(null, \"id\");\n                        setMinAppWidgetIdLocked(userId, widget.appWidgetId + 1);\n\n                        // restored ID is allowed to be absent\n                        widget.restoredId = parser.getAttributeIntHex(null, \"rid\", 0);\n                        widget.options = parseWidgetIdOptions(parser);\n\n                        final int hostTag = parser.getAttributeIntHex(null, \"h\");\n                        String providerString = parser.getAttributeValue(null, \"p\");\n                        final int providerTag = (providerString != null)\n                                ? parser.getAttributeIntHex(null, \"p\") : TAG_UNDEFINED;\n\n                        // We can match widgets with hosts and providers only after hosts\n                        // and providers for all users have been loaded since the widget\n                        // host and provider can be in different user profiles.\n                        LoadedWidgetState loadedWidgets = new LoadedWidgetState(widget,\n                                hostTag, providerTag);\n                        outLoadedWidgets.add(loadedWidgets);\n                    }\n                }\n            } while (type != XmlPullParser.END_DOCUMENT);\n        } catch (NullPointerException\n                | NumberFormatException\n                | XmlPullParserException\n                | IOException\n                | IndexOutOfBoundsException e) {\n            Slog.w(TAG, \"failed parsing \" + e);\n            return -1;\n        }\n\n        return version;\n    }\n\n    private void performUpgradeLocked(int fromVersion) {\n        if (fromVersion < CURRENT_VERSION) {\n            Slog.v(TAG, \"Upgrading widget database from \" + fromVersion + \" to \"\n                    + CURRENT_VERSION);\n        }\n\n        int version = fromVersion;\n\n        // Update 1: keyguard moved from package \"android\" to \"com.android.keyguard\"\n        if (version == 0) {\n            HostId oldHostId = new HostId(Process.myUid(),\n                    KEYGUARD_HOST_ID, OLD_KEYGUARD_HOST_PACKAGE);\n\n            Host host = lookupHostLocked(oldHostId);\n            if (host != null) {\n                final int uid = getUidForPackage(NEW_KEYGUARD_HOST_PACKAGE,\n                        UserHandle.USER_SYSTEM);\n                if (uid >= 0) {\n                    host.id = new HostId(uid, KEYGUARD_HOST_ID, NEW_KEYGUARD_HOST_PACKAGE);\n                }\n            }\n\n            version = 1;\n        }\n\n        if (version != CURRENT_VERSION) {\n            throw new IllegalStateException(\"Failed to upgrade widget database\");\n        }\n    }\n\n    private static File getStateFile(int userId) {\n        return new File(Environment.getUserSystemDirectory(userId), STATE_FILENAME);\n    }\n\n    private static AtomicFile getSavedStateFile(int userId) {\n        File dir = Environment.getUserSystemDirectory(userId);\n        File settingsFile = getStateFile(userId);\n        if (!settingsFile.exists() && userId == UserHandle.USER_SYSTEM) {\n            if (!dir.exists()) {\n                dir.mkdirs();\n            }\n            // Migrate old data\n            File oldFile = new File(\"/data/system/\" + STATE_FILENAME);\n            // Method doesn't throw an exception on failure. Ignore any errors\n            // in moving the file (like non-existence)\n            oldFile.renameTo(settingsFile);\n        }\n        return new AtomicFile(settingsFile);\n    }\n\n    void onUserStopped(int userId) {\n        synchronized (mLock) {\n            boolean crossProfileWidgetsChanged = false;\n\n            // Remove widgets that have both host and provider in the user.\n            final int widgetCount = mWidgets.size();\n            for (int i = widgetCount - 1; i >= 0; i--) {\n                Widget widget = mWidgets.get(i);\n\n                final boolean hostInUser = widget.host.getUserId() == userId;\n                final boolean hasProvider = widget.provider != null;\n                final boolean providerInUser = hasProvider && widget.provider.getUserId() == userId;\n\n                // If both host and provider are in the user, just drop the widgets\n                // as we do not want to make host callbacks and provider broadcasts\n                // as the host and the provider will be killed.\n                if (hostInUser && (!hasProvider || providerInUser)) {\n                    removeWidgetLocked(widget);\n                    widget.host.widgets.remove(widget);\n                    widget.host = null;\n                    if (hasProvider) {\n                        widget.provider.widgets.remove(widget);\n                        widget.provider = null;\n                    }\n                }\n            }\n\n            // Remove hosts and notify providers in other profiles.\n            final int hostCount = mHosts.size();\n            for (int i = hostCount - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n                if (host.getUserId() == userId) {\n                    crossProfileWidgetsChanged |= !host.widgets.isEmpty();\n                    deleteHostLocked(host);\n                }\n            }\n\n            // Leave the providers present as hosts will show the widgets\n            // masked while the user is stopped.\n\n            // Remove grants for this user.\n            final int grantCount = mPackagesWithBindWidgetPermission.size();\n            for (int i = grantCount - 1; i >= 0; i--) {\n                Pair<Integer, String> packageId = mPackagesWithBindWidgetPermission.valueAt(i);\n                if (packageId.first == userId) {\n                    mPackagesWithBindWidgetPermission.removeAt(i);\n                }\n            }\n\n            // Take a note we no longer have state for this user.\n            final int userIndex = mLoadedUserIds.indexOfKey(userId);\n            if (userIndex >= 0) {\n                mLoadedUserIds.removeAt(userIndex);\n            }\n\n            // Remove the widget id counter.\n            final int nextIdIndex = mNextAppWidgetIds.indexOfKey(userId);\n            if (nextIdIndex >= 0) {\n                mNextAppWidgetIds.removeAt(nextIdIndex);\n            }\n\n            // Save state if removing a profile changed the group state.\n            // Nothing will be saved if the group parent was removed.\n            if (crossProfileWidgetsChanged) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    private void applyResourceOverlaysToWidgetsLocked(Set<String> packageNames, int userId,\n            boolean updateFrameworkRes) {\n        for (int i = 0, N = mProviders.size(); i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.getUserId() != userId) {\n                continue;\n            }\n\n            final String packageName = provider.id.componentName.getPackageName();\n            if (!updateFrameworkRes && !packageNames.contains(packageName)) {\n                continue;\n            }\n\n            ApplicationInfo newAppInfo = null;\n            try {\n                newAppInfo = mPackageManager.getApplicationInfo(packageName,\n                        PackageManager.GET_SHARED_LIBRARY_FILES, userId);\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"Failed to retrieve app info for \" + packageName\n                        + \" userId=\" + userId, e);\n            }\n            if (newAppInfo == null || provider.info == null\n                    || provider.info.providerInfo == null) {\n                continue;\n            }\n            ApplicationInfo oldAppInfo = provider.info.providerInfo.applicationInfo;\n            if (oldAppInfo == null || !newAppInfo.sourceDir.equals(oldAppInfo.sourceDir)) {\n                // Overlay paths are generated against a particular version of an application.\n                // The overlays paths of a newly upgraded application are incompatible with the\n                // old version of the application.\n                continue;\n            }\n\n            // Isolate the changes relating to RROs. The app info must be copied to prevent\n            // affecting other parts of system server that may have cached this app info.\n            oldAppInfo = new ApplicationInfo(oldAppInfo);\n            oldAppInfo.overlayPaths = newAppInfo.overlayPaths.clone();\n            oldAppInfo.resourceDirs = newAppInfo.resourceDirs.clone();\n            provider.info.providerInfo.applicationInfo = oldAppInfo;\n\n            for (int j = 0, M = provider.widgets.size(); j < M; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (widget.views != null) {\n                    widget.views.updateAppInfo(oldAppInfo);\n                }\n                if (widget.maskedViews != null) {\n                    widget.maskedViews.updateAppInfo(oldAppInfo);\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates all providers with the specified package names, and records any providers that were\n     * pruned.\n     *\n     * @return whether any providers were updated\n     */\n    private boolean updateProvidersForPackageLocked(String packageName, int userId,\n            Set<ProviderId> removedProviders) {\n        boolean providersUpdated = false;\n\n        HashSet<ProviderId> keep = new HashSet<>();\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setPackage(packageName);\n        List<ResolveInfo> broadcastReceivers = queryIntentReceivers(intent, userId);\n\n        // add the missing ones and collect which ones to keep\n        int N = broadcastReceivers == null ? 0 : broadcastReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo ri = broadcastReceivers.get(i);\n            ActivityInfo ai = ri.activityInfo;\n\n            if ((ai.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n                continue;\n            }\n\n            if (packageName.equals(ai.packageName)) {\n                ProviderId providerId = new ProviderId(ai.applicationInfo.uid,\n                        new ComponentName(ai.packageName, ai.name));\n\n                Provider provider = lookupProviderLocked(providerId);\n                if (provider == null) {\n                    if (addProviderLocked(ri)) {\n                        keep.add(providerId);\n                        providersUpdated = true;\n                    }\n                } else {\n                    AppWidgetProviderInfo info =\n                            createPartialProviderInfo(providerId, ri, provider);\n                    if (info != null) {\n                        keep.add(providerId);\n                        // Use the new AppWidgetProviderInfo.\n                        provider.setPartialInfoLocked(info);\n                        // If it's enabled\n                        final int M = provider.widgets.size();\n                        if (M > 0) {\n                            int[] appWidgetIds = getWidgetIds(provider.widgets);\n                            // Reschedule for the new updatePeriodMillis (don't worry about handling\n                            // it specially if updatePeriodMillis didn't change because we just sent\n                            // an update, and the next one will be updatePeriodMillis from now).\n                            cancelBroadcastsLocked(provider);\n                            registerForBroadcastsLocked(provider, appWidgetIds);\n                            // If it's currently showing, call back with the new\n                            // AppWidgetProviderInfo.\n                            for (int j = 0; j < M; j++) {\n                                Widget widget = provider.widgets.get(j);\n                                widget.views = null;\n                                scheduleNotifyProviderChangedLocked(widget);\n                            }\n                            // Now that we've told the host, push out an update.\n                            sendUpdateIntentLocked(provider, appWidgetIds);\n                        }\n                    }\n                    providersUpdated = true;\n                }\n            }\n        }\n\n        // prune the ones we don't want to keep\n        N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (packageName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && !keep.contains(provider.id)) {\n                if (removedProviders != null) {\n                    removedProviders.add(provider.id);\n                }\n                deleteProviderLocked(provider);\n                providersUpdated = true;\n            }\n        }\n\n        return providersUpdated;\n    }\n\n    // Remove widgets for provider in userId that are hosted in parentUserId\n    private void removeWidgetsForPackageLocked(String pkgName, int userId, int parentUserId) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; ++i) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && provider.widgets.size() > 0) {\n                deleteWidgetsLocked(provider, parentUserId);\n            }\n        }\n    }\n\n    private boolean removeProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = false;\n\n        final int N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId) {\n                deleteProviderLocked(provider);\n                removed = true;\n            }\n        }\n        return removed;\n    }\n\n    private boolean removeHostsAndProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = removeProvidersForPackageLocked(pkgName, userId);\n\n        // Delete the hosts for this package too\n        // By now, we have removed any AppWidgets that were in any hosts here,\n        // so we don't need to worry about sending DISABLE broadcasts to them.\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n            if (pkgName.equals(host.id.packageName)\n                    && host.getUserId() == userId) {\n                deleteHostLocked(host);\n                removed = true;\n            }\n        }\n\n        return removed;\n    }\n\n    private String getCanonicalPackageName(String packageName, String className, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            try {\n                AppGlobals.getPackageManager().getReceiverInfo(new ComponentName(packageName,\n                        className), 0, userId);\n                return packageName;\n            } catch (RemoteException re) {\n                String[] packageNames = mContext.getPackageManager()\n                        .currentToCanonicalPackageNames(new String[]{packageName});\n                if (packageNames != null && packageNames.length > 0) {\n                    return packageNames[0];\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return null;\n    }\n\n    private void sendBroadcastAsUser(Intent intent, UserHandle userHandle) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            mContext.sendBroadcastAsUser(intent, userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void bindService(Intent intent, ServiceConnection connection,\n            UserHandle userHandle) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, connection,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void unbindService(ServiceConnection connection) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.unbindService(connection);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void onCrossProfileWidgetProvidersChanged(int userId, List<String> packages) {\n        final int parentId = mSecurityPolicy.getProfileParent(userId);\n        // We care only if the allowlisted package is in a profile of\n        // the group parent as only the parent can add widgets from the\n        // profile and not the other way around.\n        if (parentId != userId) {\n            synchronized (mLock) {\n                boolean providersChanged = false;\n\n                ArraySet<String> previousPackages = new ArraySet<String>();\n                final int providerCount = mProviders.size();\n                for (int i = 0; i < providerCount; ++i) {\n                    Provider provider = mProviders.get(i);\n                    if (provider.getUserId() == userId) {\n                        previousPackages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n\n                final int packageCount = packages.size();\n                for (int i = 0; i < packageCount; i++) {\n                    String packageName = packages.get(i);\n                    previousPackages.remove(packageName);\n                    providersChanged |= updateProvidersForPackageLocked(packageName,\n                            userId, null);\n                }\n\n                // Remove widgets from hosts in parent user for packages not in the allowlist\n                final int removedCount = previousPackages.size();\n                for (int i = 0; i < removedCount; ++i) {\n                    removeWidgetsForPackageLocked(previousPackages.valueAt(i),\n                            userId, parentId);\n                }\n\n                if (providersChanged || removedCount > 0) {\n                    saveGroupStateAsync(userId);\n                    scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                }\n            }\n        }\n    }\n\n    private boolean isProfileWithLockedParent(int userId) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            UserInfo userInfo = mUserManager.getUserInfo(userId);\n            if (userInfo != null && userInfo.isProfile()) {\n                UserInfo parentInfo = mUserManager.getProfileParent(userId);\n                if (parentInfo != null\n                        && !isUserRunningAndUnlocked(parentInfo.getUserHandle().getIdentifier())) {\n                    return true;\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return false;\n    }\n\n    private boolean isProfileWithUnlockedParent(int userId) {\n        UserInfo userInfo = mUserManager.getUserInfo(userId);\n        if (userInfo != null && userInfo.isProfile()) {\n            UserInfo parentInfo = mUserManager.getProfileParent(userId);\n            if (parentInfo != null\n                    && mUserManager.isUserUnlockingOrUnlocked(parentInfo.getUserHandle())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Note an app widget is tapped on. If a app widget is tapped, the underlying app is treated as\n     * foreground so the app can get while-in-use permission.\n     *\n     * @param callingPackage calling app's packageName.\n     * @param appWidgetId App widget id.\n     */\n    @Override\n    public void noteAppWidgetTapped(String callingPackage, int appWidgetId) {\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        final int callingUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            // The launcher must be at TOP.\n            final int procState = mActivityManagerInternal.getUidProcessState(callingUid);\n            if (procState > ActivityManager.PROCESS_STATE_TOP) {\n                return;\n            }\n            synchronized (mLock) {\n                final Widget widget = lookupWidgetLocked(appWidgetId, callingUid, callingPackage);\n                if (widget == null) {\n                    return;\n                }\n                final ProviderId providerId = widget.provider.id;\n                final String packageName = providerId.componentName.getPackageName();\n                if (packageName == null) {\n                    return;\n                }\n                final SparseArray<String> uid2PackageName = new SparseArray<String>();\n                uid2PackageName.put(providerId.uid, packageName);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(uid2PackageName, true);\n                mUsageStatsManagerInternal.reportEvent(packageName,\n                        UserHandle.getUserId(providerId.uid), UsageEvents.Event.USER_INTERACTION);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private final class CallbackHandler extends Handler {\n        public static final int MSG_NOTIFY_UPDATE_APP_WIDGET = 1;\n        public static final int MSG_NOTIFY_PROVIDER_CHANGED = 2;\n        public static final int MSG_NOTIFY_PROVIDERS_CHANGED = 3;\n        public static final int MSG_NOTIFY_VIEW_DATA_CHANGED = 4;\n        public static final int MSG_NOTIFY_APP_WIDGET_REMOVED = 5;\n\n        public CallbackHandler(Looper looper) {\n            super(looper, null, false);\n        }\n\n        @Override\n        public void handleMessage(Message message) {\n            switch (message.what) {\n                case MSG_NOTIFY_UPDATE_APP_WIDGET: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    RemoteViews views = (RemoteViews) args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyUpdateAppWidget(host, callbacks, appWidgetId, views, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDER_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    AppWidgetProviderInfo info = (AppWidgetProviderInfo)args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyProviderChanged(host, callbacks, appWidgetId, info, requestId);\n                } break;\n\n                case MSG_NOTIFY_APP_WIDGET_REMOVED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n                    handleNotifyAppWidgetRemoved(host, callbacks, appWidgetId, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDERS_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    args.recycle();\n\n                    handleNotifyProvidersChanged(host, callbacks);\n                } break;\n\n                case MSG_NOTIFY_VIEW_DATA_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    final int viewId = args.argi2;\n                    args.recycle();\n\n                    handleNotifyAppWidgetViewDataChanged(host, callbacks, appWidgetId, viewId,\n                            requestId);\n                } break;\n            }\n        }\n    }\n\n    private final class SecurityPolicy {\n\n        public boolean isEnabledGroupProfile(int profileId) {\n            final int parentId = UserHandle.getCallingUserId();\n            return isParentOrProfile(parentId, profileId) && isProfileEnabled(profileId);\n        }\n\n        public int[] getEnabledGroupProfileIds(int userId) {\n            final int parentId = getGroupParent(userId);\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mUserManager.getEnabledProfileIds(parentId);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                ComponentName componentName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                ServiceInfo serviceInfo = mPackageManager.getServiceInfo(componentName,\n                        PackageManager.GET_PERMISSIONS, userId);\n                if (serviceInfo == null) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" not installed for user \" + userId);\n                }\n                if (!android.Manifest.permission.BIND_REMOTEVIEWS.equals(serviceInfo.permission)) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" in user \" + userId + \"does not require \"\n                            + android.Manifest.permission.BIND_REMOTEVIEWS);\n                }\n            } catch (RemoteException re) {\n                // Local call - shouldn't happen.\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceModifyAppWidgetBindPermissions(String packageName) {\n            mContext.enforceCallingPermission(\n                    android.Manifest.permission.MODIFY_APPWIDGET_BIND_PERMISSIONS,\n                    \"hasBindAppWidgetPermission packageName=\" + packageName);\n        }\n\n        public boolean isCallerInstantAppLocked() {\n            final int callingUid =  Binder.getCallingUid();\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final String[] uidPackages = mPackageManager.getPackagesForUid(callingUid);\n                if (!ArrayUtils.isEmpty(uidPackages)) {\n                    return mPackageManager.isInstantApp(uidPackages[0],\n                            UserHandle.getUserId(callingUid));\n                }\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public boolean isInstantAppLocked(String packageName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mPackageManager.isInstantApp(packageName, userId);\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public void enforceCallFromPackage(String packageName) {\n            mAppOpsManager.checkPackage(Binder.getCallingUid(), packageName);\n        }\n\n        public boolean hasCallerBindPermissionOrBindWhiteListedLocked(String packageName) {\n            try {\n                mContext.enforceCallingOrSelfPermission(\n                        android.Manifest.permission.BIND_APPWIDGET, null);\n            } catch (SecurityException se) {\n                if (!isCallerBindAppWidgetWhiteListedLocked(packageName)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean isCallerBindAppWidgetWhiteListedLocked(String packageName) {\n            final int userId = UserHandle.getCallingUserId();\n            final int packageUid = getUidForPackage(packageName, userId);\n            if (packageUid < 0) {\n                throw new IllegalArgumentException(\"No package \" + packageName\n                        + \" for user \" + userId);\n            }\n            synchronized (mLock) {\n                ensureGroupStateLoadedLocked(userId);\n\n                Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                if (mPackagesWithBindWidgetPermission.contains(packageId)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        public boolean canAccessAppWidget(Widget widget, int uid, String packageName) {\n            if (isHostInPackageForUid(widget.host, uid, packageName)) {\n                // Apps hosting the AppWidget have access to it.\n                return true;\n            }\n            if (isProviderInPackageForUid(widget.provider, uid, packageName)) {\n                // Apps providing the AppWidget have access to it.\n                return true;\n            }\n            if (isHostAccessingProvider(widget.host, widget.provider, uid, packageName)) {\n                // Apps hosting the AppWidget get to bind to a remote view service in the provider.\n                return true;\n            }\n            final int userId = UserHandle.getUserId(uid);\n            if ((widget.host.getUserId() == userId || (widget.provider != null\n                    && widget.provider.getUserId() == userId))\n                && mContext.checkCallingPermission(android.Manifest.permission.BIND_APPWIDGET)\n                    == PackageManager.PERMISSION_GRANTED) {\n                // Apps that run in the same user as either the host or the provider and\n                // have the bind widget permission have access to the widget.\n                return true;\n            }\n            return false;\n        }\n\n        private boolean isParentOrProfile(int parentId, int profileId) {\n            if (parentId == profileId) {\n                return true;\n            }\n            return getProfileParent(profileId) == parentId;\n        }\n\n        public boolean isProviderInCallerOrInProfileAndWhitelListed(String packageName,\n                int profileId) {\n            final int callerId = UserHandle.getCallingUserId();\n            if (profileId == callerId) {\n                return true;\n            }\n            final int parentId = getProfileParent(profileId);\n            if (parentId != callerId) {\n                return false;\n            }\n            return isProviderWhiteListed(packageName, profileId);\n        }\n\n        public boolean isProviderWhiteListed(String packageName, int profileId) {\n            // If the policy manager is not available on the device we deny it all.\n            if (mDevicePolicyManagerInternal == null) {\n                return false;\n            }\n\n            List<String> crossProfilePackages = mDevicePolicyManagerInternal\n                    .getCrossProfileWidgetProviders(profileId);\n\n            return crossProfilePackages.contains(packageName);\n        }\n\n        public int getProfileParent(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo parent = mUserManager.getProfileParent(profileId);\n                if (parent != null) {\n                    return parent.getUserHandle().getIdentifier();\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return UNKNOWN_USER_ID;\n        }\n\n        public int getGroupParent(int profileId) {\n            final int parentId = mSecurityPolicy.getProfileParent(profileId);\n            return (parentId != UNKNOWN_USER_ID) ? parentId : profileId;\n        }\n\n        public boolean isHostInPackageForUid(Host host, int uid, String packageName) {\n            return host.id.uid == uid && host.id.packageName.equals(packageName);\n        }\n\n        public boolean isProviderInPackageForUid(Provider provider, int uid,\n                String packageName) {\n            // Packages providing the AppWidget have access to it.\n            return provider != null && provider.id.uid == uid\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        public boolean isHostAccessingProvider(Host host, Provider provider, int uid,\n                String packageName) {\n            // The host creates a package context to bind to remote views service in the provider.\n            return host.id.uid == uid && provider != null\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        private boolean isProfileEnabled(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo userInfo = mUserManager.getUserInfo(profileId);\n                if (userInfo == null || !userInfo.isEnabled()) {\n                    return false;\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return true;\n        }\n    }\n\n    private static final class Provider {\n\n        ProviderId id;\n        AppWidgetProviderInfo info;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        PendingIntent broadcast;\n        String infoTag;\n\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        boolean maskedByLockedProfile;\n        boolean maskedByQuietProfile;\n        boolean maskedBySuspendedPackage;\n\n        boolean mInfoParsed = false;\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId\n                    && id.componentName.getPackageName().equals(packageName);\n        }\n\n        // is there an instance of this provider hosted by the given app?\n        public boolean hostedByPackageForUser(String packageName, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (packageName.equals(widget.host.id.packageName)\n                        && widget.host.getUserId() == userId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getInfoLocked(Context context) {\n            if (!mInfoParsed) {\n                // parse\n                if (!zombie) {\n                    AppWidgetProviderInfo newInfo = null;\n                    if (!TextUtils.isEmpty(infoTag)) {\n                        newInfo = parseAppWidgetProviderInfo(\n                                context, id, info.providerInfo, infoTag);\n                    }\n                    if (newInfo == null) {\n                        newInfo = parseAppWidgetProviderInfo(context, id, info.providerInfo,\n                                AppWidgetManager.META_DATA_APPWIDGET_PROVIDER);\n                    }\n                    if (newInfo != null) {\n                        info = newInfo;\n                    }\n                }\n                mInfoParsed = true;\n            }\n            return info;\n        }\n\n        /**\n         * Returns the last updated AppWidgetProviderInfo for this provider. This info may not\n         * be completely parsed and only contain placeHolder information like\n         * {@link AppWidgetProviderInfo#providerInfo}\n         */\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getPartialInfoLocked() {\n            return info;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setPartialInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = true;\n        }\n\n        @Override\n        public String toString() {\n            return \"Provider{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByQuietProfileLocked(boolean masked) {\n            boolean oldState = maskedByQuietProfile;\n            maskedByQuietProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByLockedProfileLocked(boolean masked) {\n            boolean oldState = maskedByLockedProfile;\n            maskedByLockedProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedBySuspendedPackageLocked(boolean masked) {\n            boolean oldState = maskedBySuspendedPackage;\n            maskedBySuspendedPackage = masked;\n            return masked != oldState;\n        }\n\n        public boolean isMaskedLocked() {\n            return maskedByQuietProfile || maskedByLockedProfile || maskedBySuspendedPackage;\n        }\n\n        public boolean shouldBePersisted() {\n            return !widgets.isEmpty() || !TextUtils.isEmpty(infoTag);\n        }\n    }\n\n    private static final class ProviderId {\n        final int uid;\n        final ComponentName componentName;\n\n        private ProviderId(int uid, ComponentName componentName) {\n            this.uid = uid;\n            this.componentName = componentName;\n        }\n\n        public UserHandle getProfile() {\n            return UserHandle.getUserHandleForUid(uid);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            ProviderId other = (ProviderId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (componentName == null) {\n                if (other.componentName != null) {\n                    return false;\n                }\n            } else if (!componentName.equals(other.componentName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + ((componentName != null)\n                    ? componentName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"ProviderId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", cmp:\" + componentName + '}';\n        }\n    }\n\n    private static final class Host {\n        HostId id;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        IAppWidgetHost callbacks;\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n        // Sequence no for the last update successfully sent. This is updated whenever a\n        // widget update is successfully sent to the host callbacks. As all new/undelivered updates\n        // will have sequenceNo greater than this, all those updates will be sent when the host\n        // callbacks are attached again.\n        long lastWidgetUpdateSequenceNo;\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId && id.packageName.equals(packageName);\n        }\n\n        private boolean hostsPackageForUser(String pkg, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = widgets.get(i).provider;\n                if (provider != null && provider.getUserId() == userId\n                        && pkg.equals(provider.id.componentName.getPackageName())) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Adds all pending updates in {@param outUpdates} keys by the update time.\n         */\n        public void getPendingUpdatesForIdLocked(Context context, int appWidgetId,\n                LongSparseArray<PendingHostUpdate> outUpdates) {\n            long updateSequenceNo = lastWidgetUpdateSequenceNo;\n            int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (widget.appWidgetId == appWidgetId) {\n                    for (int j = widget.updateSequenceNos.size() - 1; j >= 0; j--) {\n                        long requestId = widget.updateSequenceNos.valueAt(j);\n                        if (requestId <= updateSequenceNo) {\n                            continue;\n                        }\n                        int id = widget.updateSequenceNos.keyAt(j);\n                        final PendingHostUpdate update;\n                        switch (id) {\n                            case ID_PROVIDER_CHANGED:\n                                update = PendingHostUpdate.providerChanged(\n                                        appWidgetId, widget.provider.getInfoLocked(context));\n                                break;\n                            case ID_VIEWS_UPDATE:\n                                update = PendingHostUpdate.updateAppWidget(appWidgetId,\n                                        cloneIfLocalBinder(widget.getEffectiveViewsLocked()));\n                                break;\n                            default:\n                                update = PendingHostUpdate.viewDataChanged(appWidgetId, id);\n                        }\n                        outUpdates.put(requestId, update);\n                    }\n                    return;\n                }\n            }\n            outUpdates.put(lastWidgetUpdateSequenceNo,\n                    PendingHostUpdate.appWidgetRemoved(appWidgetId));\n        }\n\n        public SparseArray<String> getWidgetUids() {\n            final SparseArray<String> uids = new SparseArray<>();\n            for (int i = widgets.size() - 1; i >= 0; i--) {\n                final Widget widget = widgets.get(i);\n                final ProviderId providerId = widget.provider.id;\n                uids.put(providerId.uid, providerId.componentName.getPackageName());\n            }\n            return uids;\n        }\n\n        @Override\n        public String toString() {\n            return \"Host{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n    }\n\n    private static final class HostId {\n        final int uid;\n        final int hostId;\n        final String packageName;\n\n        public HostId(int uid, int hostId, String packageName) {\n            this.uid = uid;\n            this.hostId = hostId;\n            this.packageName = packageName;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            HostId other = (HostId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (hostId != other.hostId) {\n                return false;\n            }\n            if (packageName == null) {\n                if (other.packageName != null) {\n                    return false;\n                }\n            } else if (!packageName.equals(other.packageName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + hostId;\n            result = 31 * result + ((packageName != null)\n                    ? packageName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"HostId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", hostId:\" + hostId\n                    + \", pkg:\" + packageName + '}';\n        }\n    }\n\n    // These can be any constants that would not collide with a resource id.\n    private static final int ID_VIEWS_UPDATE = 0;\n    private static final int ID_PROVIDER_CHANGED = 1;\n\n    private static final class Widget {\n        int appWidgetId;\n        int restoredId;  // tracking & remapping any restored state\n        Provider provider;\n        RemoteViews views;\n        RemoteViews maskedViews;\n        Bundle options;\n        Host host;\n        // Map of request type to updateSequenceNo.\n        SparseLongArray updateSequenceNos = new SparseLongArray(2);\n\n        @Override\n        public String toString() {\n            return \"AppWidgetId{\" + appWidgetId + ':' + host + ':' + provider + '}';\n        }\n\n        private boolean replaceWithMaskedViewsLocked(RemoteViews views) {\n            maskedViews = views;\n            return true;\n        }\n\n        private boolean clearMaskedViewsLocked() {\n            if (maskedViews != null) {\n                maskedViews = null;\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        public RemoteViews getEffectiveViewsLocked() {\n            return maskedViews != null ? maskedViews : views;\n        }\n    }\n\n    private class LoadedWidgetState {\n        final Widget widget;\n        final int hostTag;\n        final int providerTag;\n\n        public LoadedWidgetState(Widget widget, int hostTag, int providerTag) {\n            this.widget = widget;\n            this.hostTag = hostTag;\n            this.providerTag = providerTag;\n        }\n    }\n\n    private final class SaveStateRunnable implements Runnable {\n        final int mUserId;\n\n        public SaveStateRunnable(int userId) {\n            mUserId = userId;\n        }\n\n        @Override\n        public void run() {\n            synchronized (mLock) {\n                // No need to enforce unlocked state when there is no caller. User can be in the\n                // stopping state or removed by the time the message is processed\n                ensureGroupStateLoadedLocked(mUserId, false /* enforceUserUnlockingOrUnlocked */ );\n                saveStateLocked(mUserId);\n            }\n        }\n    }\n\n    /**\n     * This class encapsulates the backup and restore logic for a user group state.\n     */\n    private final class BackupRestoreController {\n        private static final String TAG = \"BackupRestoreController\";\n\n        private static final boolean DEBUG = true;\n\n        // Version of backed-up widget state.\n        private static final int WIDGET_STATE_VERSION = 2;\n\n        // We need to make sure to wipe the pre-restore widget state only once for\n        // a given package.  Keep track of what we've done so far here; the list is\n        // cleared at the start of every system restore pass, but preserved through\n        // any install-time restore operations.\n        private final HashSet<String> mPrunedApps = new HashSet<>();\n\n        private final HashMap<Provider, ArrayList<RestoreUpdateRecord>> mUpdatesByProvider =\n                new HashMap<>();\n        private final HashMap<Host, ArrayList<RestoreUpdateRecord>> mUpdatesByHost =\n                new HashMap<>();\n\n        @GuardedBy(\"mLock\")\n        private boolean mHasSystemRestoreFinished;\n\n        public List<String> getWidgetParticipants(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget participants for user: \" + userId);\n            }\n\n            HashSet<String> packages = new HashSet<>();\n            synchronized (mLock) {\n                final int N = mWidgets.size();\n                for (int i = 0; i < N; i++) {\n                    Widget widget = mWidgets.get(i);\n\n                    // Skip cross-user widgets.\n                    if (!isProviderAndHostInUser(widget, userId)) {\n                        continue;\n                    }\n\n                    packages.add(widget.host.id.packageName);\n                    Provider provider = widget.provider;\n                    if (provider != null) {\n                        packages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n            }\n            return new ArrayList<>(packages);\n        }\n\n        public byte[] getWidgetState(String backedupPackage, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget state for user: \" + userId);\n            }\n\n            ByteArrayOutputStream stream = new ByteArrayOutputStream();\n            synchronized (mLock) {\n                // Preflight: if this app neither hosts nor provides any live widgets\n                // we have no work to do.\n                if (!packageNeedsWidgetBackupLocked(backedupPackage, userId)) {\n                    return null;\n                }\n\n                try {\n                    TypedXmlSerializer out = Xml.newFastSerializer();\n                    out.setOutput(stream, StandardCharsets.UTF_8.name());\n                    out.startDocument(null, true);\n                    out.startTag(null, \"ws\");      // widget state\n                    out.attributeInt(null, \"version\", WIDGET_STATE_VERSION);\n                    out.attribute(null, \"pkg\", backedupPackage);\n\n                    // Remember all the providers that are currently hosted or published\n                    // by this package: that is, all of the entities related to this app\n                    // which will need to be told about id remapping.\n                    int index = 0;\n                    int N = mProviders.size();\n                    for (int i = 0; i < N; i++) {\n                        Provider provider = mProviders.get(i);\n\n                        if (provider.shouldBePersisted()\n                                && (provider.isInPackageForUser(backedupPackage, userId)\n                                || provider.hostedByPackageForUser(backedupPackage, userId))) {\n                            provider.tag = index;\n                            serializeProvider(out, provider);\n                            index++;\n                        }\n                    }\n\n                    N = mHosts.size();\n                    index = 0;\n                    for (int i = 0; i < N; i++) {\n                        Host host = mHosts.get(i);\n\n                        if (!host.widgets.isEmpty()\n                                && (host.isInPackageForUser(backedupPackage, userId)\n                                || host.hostsPackageForUser(backedupPackage, userId))) {\n                            host.tag = index;\n                            serializeHost(out, host);\n                            index++;\n                        }\n                    }\n\n                    // All widget instances involving this package,\n                    // either as host or as provider\n                    N = mWidgets.size();\n                    for (int i = 0; i < N; i++) {\n                        Widget widget = mWidgets.get(i);\n\n                        Provider provider = widget.provider;\n                        if (widget.host.isInPackageForUser(backedupPackage, userId)\n                                || (provider != null\n                                &&  provider.isInPackageForUser(backedupPackage, userId))) {\n                            serializeAppWidget(out, widget, false);\n                        }\n                    }\n\n                    out.endTag(null, \"ws\");\n                    out.endDocument();\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Unable to save widget state for \" + backedupPackage);\n                    return null;\n                }\n            }\n\n            return stream.toByteArray();\n        }\n\n        public void systemRestoreStarting(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"System restore starting for user: \" + userId);\n            }\n\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = false;\n                // We're starting a new \"system\" restore operation, so any widget restore\n                // state that we see from here on is intended to replace the current\n                // widget configuration of any/all of the affected apps.\n                mPrunedApps.clear();\n                mUpdatesByProvider.clear();\n                mUpdatesByHost.clear();\n            }\n        }\n\n        public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Restoring widget state for user:\" + userId\n                        + \" package: \" + packageName);\n            }\n\n            ByteArrayInputStream stream = new ByteArrayInputStream(restoredState);\n            try {\n                // Providers mentioned in the widget dataset by ordinal\n                ArrayList<Provider> restoredProviders = new ArrayList<>();\n\n                // Hosts mentioned in the widget dataset by ordinal\n                ArrayList<Host> restoredHosts = new ArrayList<>();\n\n                TypedXmlPullParser parser = Xml.newFastPullParser();\n                parser.setInput(stream, StandardCharsets.UTF_8.name());\n\n                synchronized (mLock) {\n                    int type;\n                    do {\n                        type = parser.next();\n                        if (type == XmlPullParser.START_TAG) {\n                            final String tag = parser.getName();\n                            if (\"ws\".equals(tag)) {\n                                final int versionNumber = parser.getAttributeInt(null, \"version\");\n                                if (versionNumber > WIDGET_STATE_VERSION) {\n                                    Slog.w(TAG, \"Unable to process state version \" + versionNumber);\n                                    return;\n                                }\n\n                                // TODO: fix up w.r.t. canonical vs current package names\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                if (!packageName.equals(pkg)) {\n                                    Slog.w(TAG, \"Package mismatch in ws\");\n                                    return;\n                                }\n                            } else if (\"p\".equals(tag)) {\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                String cl = parser.getAttributeValue(null, \"cl\");\n\n                                // hostedProviders index will match 'p' attribute in widget's\n                                // entry in the xml file being restored\n                                // If there's no live entry for this provider, add an inactive one\n                                // so that widget IDs referring to them can be properly allocated\n\n                                // Backup and resotre only for the parent profile.\n                                ComponentName componentName = new ComponentName(pkg, cl);\n\n                                Provider p = findProviderLocked(componentName, userId);\n                                if (p == null) {\n                                    AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                                    info.provider = componentName;\n\n                                    p = new Provider();\n                                    p.id = new ProviderId(UNKNOWN_UID, componentName);\n                                    p.setPartialInfoLocked(info);\n                                    p.zombie = true;\n                                    mProviders.add(p);\n                                }\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   provider \" + p.id);\n                                }\n                                restoredProviders.add(p);\n                            } else if (\"h\".equals(tag)) {\n                                // The host app may not yet exist on the device.  If it's here we\n                                // just use the existing Host entry, otherwise we create a\n                                // placeholder whose uid will be fixed up at PACKAGE_ADDED time.\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                                final int uid = getUidForPackage(pkg, userId);\n                                final int hostId = parser.getAttributeIntHex(null, \"id\");\n\n                                HostId id = new HostId(uid, hostId, pkg);\n                                Host h = lookupOrAddHostLocked(id);\n                                restoredHosts.add(h);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   host[\" + restoredHosts.size()\n                                            + \"]: {\" + h.id + \"}\");\n                                }\n                            } else if (\"g\".equals(tag)) {\n                                int restoredId = parser.getAttributeIntHex(null, \"id\");\n                                int hostIndex = parser.getAttributeIntHex(null, \"h\");\n                                Host host = restoredHosts.get(hostIndex);\n                                Provider p = null;\n                                int which = parser.getAttributeIntHex(null, \"p\", -1);\n                                if (which != -1) {\n                                    // could have been null if the app had allocated an id\n                                    // but not yet established a binding under that id\n                                    p = restoredProviders.get(which);\n                                }\n\n                                // We'll be restoring widget state for both the host and\n                                // provider sides of this widget ID, so make sure we are\n                                // beginning from a clean slate on both fronts.\n                                pruneWidgetStateLocked(host.id.packageName, userId);\n                                if (p != null) {\n                                    pruneWidgetStateLocked(p.id.componentName.getPackageName(),\n                                            userId);\n                                }\n\n                                // Have we heard about this ancestral widget instance before?\n                                Widget id = findRestoredWidgetLocked(restoredId, host, p);\n                                if (id == null) {\n                                    id = new Widget();\n                                    id.appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n                                    id.restoredId = restoredId;\n                                    id.options = parseWidgetIdOptions(parser);\n                                    id.host = host;\n                                    id.host.widgets.add(id);\n                                    id.provider = p;\n                                    if (id.provider != null) {\n                                        id.provider.widgets.add(id);\n                                    }\n                                    if (DEBUG) {\n                                        Slog.i(TAG, \"New restored id \" + restoredId\n                                                + \" now \" + id);\n                                    }\n                                    addWidgetLocked(id);\n                                }\n                                if (id.provider != null\n                                        && id.provider.getPartialInfoLocked() != null) {\n                                    stashProviderRestoreUpdateLocked(id.provider,\n                                            restoredId, id.appWidgetId);\n                                } else {\n                                    Slog.w(TAG, \"Missing provider for restored widget \" + id);\n                                }\n                                stashHostRestoreUpdateLocked(id.host, restoredId, id.appWidgetId);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   instance: \" + restoredId\n                                            + \" -> \" + id.appWidgetId\n                                            + \" :: p=\" + id.provider);\n                                }\n                            }\n                        }\n                    } while (type != XmlPullParser.END_DOCUMENT);\n\n                    // We've updated our own bookkeeping.  We'll need to notify the hosts and\n                    // providers about the changes, but we can't do that yet because the restore\n                    // target is not necessarily fully live at this moment.  Set aside the\n                    // information for now; the backup manager will call us once more at the\n                    // end of the process when all of the targets are in a known state, and we\n                    // will update at that point.\n                }\n            } catch (XmlPullParserException | IOException e) {\n                Slog.w(TAG, \"Unable to restore widget state for \" + packageName);\n            } finally {\n                saveGroupStateAsync(userId);\n            }\n        }\n\n        // Called once following the conclusion of a system restore operation.  This is when we\n        // send out updates to apps involved in widget-state restore telling them about\n        // the new widget ID space.  Apps that are not yet installed will be notifed when they are.\n        public void systemRestoreFinished(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"systemRestoreFinished for \" + userId);\n            }\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = true;\n                maybeSendWidgetRestoreBroadcastsLocked(userId);\n            }\n        }\n\n        // Called when widget components (hosts or providers) are added or changed.  If system\n        // restore has completed, we use this opportunity to tell the apps to update to the new\n        // widget ID space.  If system restore is still in progress, we delay the updates until\n        // the end, to allow all participants to restore their state before updating widget IDs.\n        public void widgetComponentsChanged(int userId) {\n            synchronized (mLock) {\n                if (mHasSystemRestoreFinished) {\n                    maybeSendWidgetRestoreBroadcastsLocked(userId);\n                }\n            }\n        }\n\n        // Called following the conclusion of a restore operation and when widget components\n        // are added or changed.  This is when we send out updates to apps involved in widget-state\n        // restore telling them about the new widget ID space.\n        @GuardedBy(\"mLock\")\n        private void maybeSendWidgetRestoreBroadcastsLocked(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"maybeSendWidgetRestoreBroadcasts for \" + userId);\n            }\n\n            final UserHandle userHandle = new UserHandle(userId);\n            // Build the providers' broadcasts and send them off\n            Set<Map.Entry<Provider, ArrayList<RestoreUpdateRecord>>> providerEntries\n                    = mUpdatesByProvider.entrySet();\n            for (Map.Entry<Provider, ArrayList<RestoreUpdateRecord>> e : providerEntries) {\n                // For each provider there's a list of affected IDs\n                Provider provider = e.getKey();\n                if (provider.zombie) {\n                    // Provider not installed, we can't send them broadcasts yet.\n                    // We'll be called again when the provider is installed.\n                    continue;\n                }\n                ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                final int pending = countPendingUpdates(updates);\n                if (DEBUG) {\n                    Slog.i(TAG, \"Provider \" + provider + \" pending: \" + pending);\n                }\n                if (pending > 0) {\n                    int[] oldIds = new int[pending];\n                    int[] newIds = new int[pending];\n                    final int N = updates.size();\n                    int nextPending = 0;\n                    for (int i = 0; i < N; i++) {\n                        RestoreUpdateRecord r = updates.get(i);\n                        if (!r.notified) {\n                            r.notified = true;\n                            oldIds[nextPending] = r.oldId;\n                            newIds[nextPending] = r.newId;\n                            nextPending++;\n                            if (DEBUG) {\n                                Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                            }\n                        }\n                    }\n                    sendWidgetRestoreBroadcastLocked(\n                            AppWidgetManager.ACTION_APPWIDGET_RESTORED,\n                            provider, null, oldIds, newIds, userHandle);\n                }\n            }\n\n            // same thing per host\n            Set<Map.Entry<Host, ArrayList<RestoreUpdateRecord>>> hostEntries\n                    = mUpdatesByHost.entrySet();\n            for (Map.Entry<Host, ArrayList<RestoreUpdateRecord>> e : hostEntries) {\n                Host host = e.getKey();\n                if (host.id.uid != UNKNOWN_UID) {\n                    ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                    final int pending = countPendingUpdates(updates);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Host \" + host + \" pending: \" + pending);\n                    }\n                    if (pending > 0) {\n                        int[] oldIds = new int[pending];\n                        int[] newIds = new int[pending];\n                        final int N = updates.size();\n                        int nextPending = 0;\n                        for (int i = 0; i < N; i++) {\n                            RestoreUpdateRecord r = updates.get(i);\n                            if (!r.notified) {\n                                r.notified = true;\n                                oldIds[nextPending] = r.oldId;\n                                newIds[nextPending] = r.newId;\n                                nextPending++;\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                                }\n                            }\n                        }\n                        sendWidgetRestoreBroadcastLocked(\n                                AppWidgetManager.ACTION_APPWIDGET_HOST_RESTORED,\n                                null, host, oldIds, newIds, userHandle);\n                    }\n                }\n            }\n        }\n\n        private Provider findProviderLocked(ComponentName componentName, int userId) {\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                if (provider.getUserId() == userId\n                        && provider.id.componentName.equals(componentName)) {\n                    return provider;\n                }\n            }\n            return null;\n        }\n\n        private Widget findRestoredWidgetLocked(int restoredId, Host host, Provider p) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Find restored widget: id=\" + restoredId\n                        + \" host=\" + host + \" provider=\" + p);\n            }\n\n            if (p == null || host == null) {\n                return null;\n            }\n\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                if (widget.restoredId == restoredId\n                        && widget.host.id.equals(host.id)\n                        && widget.provider.id.equals(p.id)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"   Found at \" + i + \" : \" + widget);\n                    }\n                    return widget;\n                }\n            }\n            return null;\n        }\n\n        private boolean packageNeedsWidgetBackupLocked(String packageName, int userId) {\n            int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n\n                // Skip cross-user widgets.\n                if (!isProviderAndHostInUser(widget, userId)) {\n                    continue;\n                }\n\n                if (widget.host.isInPackageForUser(packageName, userId)) {\n                    // this package is hosting widgets, so it knows widget IDs.\n                    return true;\n                }\n\n                Provider provider = widget.provider;\n                if (provider != null && provider.isInPackageForUser(packageName, userId)) {\n                    // someone is hosting this app's widgets, so it knows widget IDs.\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashProviderRestoreUpdateLocked(Provider provider, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByProvider.get(provider);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByProvider.put(provider, r);\n            } else {\n                // don't duplicate\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + provider);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private boolean alreadyStashed(ArrayList<RestoreUpdateRecord> stash,\n                final int oldId, final int newId) {\n            final int N = stash.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = stash.get(i);\n                if (r.oldId == oldId && r.newId == newId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashHostRestoreUpdateLocked(Host host, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByHost.get(host);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByHost.put(host, r);\n            } else {\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + host);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private void sendWidgetRestoreBroadcastLocked(String action, Provider provider,\n                Host host, int[] oldIds, int[] newIds, UserHandle userHandle) {\n            Intent intent = new Intent(action);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OLD_IDS, oldIds);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, newIds);\n            if (provider != null) {\n                intent.setComponent(provider.id.componentName);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n            if (host != null) {\n                intent.setComponent(null);\n                intent.setPackage(host.id.packageName);\n                intent.putExtra(AppWidgetManager.EXTRA_HOST_ID, host.id.hostId);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n        }\n\n        // We're restoring widget state for 'pkg', so we start by wiping (a) all widget\n        // instances that are hosted by that app, and (b) all instances in other hosts\n        // for which 'pkg' is the provider.  We assume that we'll be restoring all of\n        // these hosts & providers, so will be reconstructing a correct live state.\n        private void pruneWidgetStateLocked(String pkg, int userId) {\n            if (!mPrunedApps.contains(pkg)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"pruning widget state for restoring package \" + pkg);\n                }\n                for (int i = mWidgets.size() - 1; i >= 0; i--) {\n                    Widget widget = mWidgets.get(i);\n\n                    Host host = widget.host;\n                    Provider provider = widget.provider;\n\n                    if (host.hostsPackageForUser(pkg, userId)\n                            || (provider != null && provider.isInPackageForUser(pkg, userId))) {\n                        // 'pkg' is either the host or the provider for this instances,\n                        // so we tear it down in anticipation of it (possibly) being\n                        // reconstructed due to the restore\n                        host.widgets.remove(widget);\n                        provider.widgets.remove(widget);\n                        // Check if we need to destroy any services (if no other app widgets are\n                        // referencing the same service)\n                        decrementAppWidgetServiceRefCount(widget);\n                        removeWidgetLocked(widget);\n                    }\n                }\n                mPrunedApps.add(pkg);\n            } else {\n                if (DEBUG) {\n                    Slog.i(TAG, \"already pruned \" + pkg + \", continuing normally\");\n                }\n            }\n        }\n\n        private boolean isProviderAndHostInUser(Widget widget, int userId) {\n            // Backup only widgets hosted or provided by the owner profile.\n            return widget.host.getUserId() == userId && (widget.provider == null\n                    || widget.provider.getUserId() == userId);\n        }\n\n        private int countPendingUpdates(ArrayList<RestoreUpdateRecord> updates) {\n            int pending = 0;\n            final int N = updates.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = updates.get(i);\n                if (!r.notified) {\n                    pending++;\n                }\n            }\n            return pending;\n        }\n\n        // Accumulate a list of updates that affect the given provider for a final\n        // coalesced notification broadcast once restore is over.\n        private class RestoreUpdateRecord {\n            public int oldId;\n            public int newId;\n            public boolean notified;\n\n            public RestoreUpdateRecord(int theOldId, int theNewId) {\n                oldId = theOldId;\n                newId = theNewId;\n                notified = false;\n            }\n        }\n    }\n\n    private class AppWidgetManagerLocal extends AppWidgetManagerInternal {\n        @Override\n        public ArraySet<String> getHostedWidgetPackages(int uid) {\n            synchronized (mLock) {\n                ArraySet<String> widgetPackages = null;\n                final int widgetCount = mWidgets.size();\n                for (int i = 0; i < widgetCount; i++) {\n                    final Widget widget = mWidgets.get(i);\n                    if  (widget.host.id.uid == uid && widget.provider != null) {\n                        if (widgetPackages == null) {\n                            widgetPackages = new ArraySet<>();\n                        }\n                        widgetPackages.add(widget.provider.id.componentName.getPackageName());\n                    }\n                }\n                return widgetPackages;\n            }\n        }\n\n        @Override\n        public void unlockUser(int userId) {\n            handleUserUnlocked(userId);\n        }\n\n        @Override\n        public void applyResourceOverlaysToWidgets(Set<String> packageNames, int userId,\n                boolean updateFrameworkRes) {\n            synchronized (mLock) {\n                applyResourceOverlaysToWidgetsLocked(new HashSet<>(packageNames), userId,\n                        updateFrameworkRes);\n            }\n        }\n    }\n}\n```"
                    }
                ]
            }
        ]
    }
]