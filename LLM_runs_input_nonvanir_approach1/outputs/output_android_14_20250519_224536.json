[
    {
        "id": "ASB-A-382064697",
        "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-382064697",
        "severity": "High",
        "failures": [
            {
                "downstream_version": "14",
                "gemini_token_usage": 506245,
                "branch_used": "android14-release",
                "downstream_patch": "3461e84908b46b6fe82ac391d43a43f23c0b1d3e",
                "repo_path": "android_repos/base",
                "result": "failure",
                "downstream_patch_content": "commit 3461e84908b46b6fe82ac391d43a43f23c0b1d3e\nAuthor: Sinduran Sivarajan <sinduran@google.com>\nDate:   Mon Feb 3 07:11:37 2025 -0800\n\n    Disable \"Developer options\" by default for managed profiles.\n    \n    Bug: 382064697\n    Test: go/work-profile-creation-developer-access\n    Flag: EXEMPT bugfix\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:73b54cdf4b70831c4f952d7556274609cb46214e)\n    Merged-In: Ibe6b721f2552d9e72aba0582a2eed4ba87178c7c\n    Change-Id: Ibe6b721f2552d9e72aba0582a2eed4ba87178c7c\n\ndiff --git a/services/core/java/com/android/server/pm/UserRestrictionsUtils.java b/services/core/java/com/android/server/pm/UserRestrictionsUtils.java\nindex 8815834f6b5c..0b3f6fd87013 100644\n--- a/services/core/java/com/android/server/pm/UserRestrictionsUtils.java\n+++ b/services/core/java/com/android/server/pm/UserRestrictionsUtils.java\n@@ -282,7 +282,8 @@ public class UserRestrictionsUtils {\n      * in settings. So it is handled separately.\n      */\n     private static final Set<String> DEFAULT_ENABLED_FOR_MANAGED_PROFILES = Sets.newArraySet(\n-            UserManager.DISALLOW_BLUETOOTH_SHARING\n+            UserManager.DISALLOW_BLUETOOTH_SHARING,\n+            UserManager.DISALLOW_DEBUGGING_FEATURES\n     );\n \n     /**\ndiff --git a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\nindex 1549677fdbb2..59ca6151639b 100644\n--- a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n+++ b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n@@ -2663,13 +2663,14 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n      * Apply default restrictions that haven't been applied to a given admin yet.\n      */\n     private void maybeSetDefaultRestrictionsForAdminLocked(int userId, ActiveAdmin admin) {\n-        Set<String> defaultRestrictions =\n-                UserRestrictionsUtils.getDefaultEnabledForManagedProfiles();\n-        if (defaultRestrictions.equals(admin.defaultEnabledRestrictionsAlreadySet)) {\n+        final Set<String> restrictionsToSet =\n+            new ArraySet<>(UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n+        restrictionsToSet.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n+        if (restrictionsToSet.isEmpty()) {\n             return; // The same set of default restrictions has been already applied.\n         }\n         if (isPolicyEngineForFinanceFlagEnabled()) {\n-            for (String restriction : defaultRestrictions) {\n+            for (String restriction : restrictionsToSet) {\n                 mDevicePolicyEngine.setLocalPolicy(\n                         PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction),\n                         EnforcingAdmin.createEnterpriseEnforcingAdmin(\n@@ -2678,9 +2679,9 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                         new BooleanPolicyValue(true),\n                         userId);\n             }\n-            admin.defaultEnabledRestrictionsAlreadySet.addAll(defaultRestrictions);\n+            admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n             Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" +\n-                    defaultRestrictions);\n+                    restrictionsToSet);\n             return;\n         }\n \n@@ -2688,21 +2689,16 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n \n         if (VERBOSE_LOG) {\n             Slogf.d(LOG_TAG, \"Default enabled restrictions: \"\n-                    + defaultRestrictions\n+                    + restrictionsToSet\n                     + \". Restrictions already enabled: \"\n                     + admin.defaultEnabledRestrictionsAlreadySet);\n         }\n-\n-        final Set<String> restrictionsToSet = new ArraySet<>(defaultRestrictions);\n-        restrictionsToSet.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n-        if (!restrictionsToSet.isEmpty()) {\n-            for (final String restriction : restrictionsToSet) {\n-                admin.ensureUserRestrictions().putBoolean(restriction, true);\n-            }\n-            admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n-            Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" + restrictionsToSet);\n-            saveUserRestrictionsLocked(userId);\n+        for (final String restriction : restrictionsToSet) {\n+            admin.ensureUserRestrictions().putBoolean(restriction, true);\n         }\n+        admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n+        Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" + restrictionsToSet);\n+        saveUserRestrictionsLocked(userId);\n     }\n \n     private void setDeviceOwnershipSystemPropertyLocked() {\n@@ -10192,7 +10188,8 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                 return false;\n             }\n \n-            if (isAdb(caller)) {\n+            boolean isAdb = isAdb(caller);\n+            if (isAdb) {\n                 // Log profile owner provisioning was started using adb.\n                 MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_PROFILE_OWNER);\n                 DevicePolicyEventLogger\n@@ -10214,7 +10211,19 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                     maybeSetDefaultRestrictionsForAdminLocked(userHandle, admin);\n                     ensureUnknownSourcesRestrictionForProfileOwnerLocked(userHandle, admin,\n                             true /* newOwner */);\n+                    if (isAdb) {\n+                        // DISALLOW_DEBUGGING_FEATURES is being added to newly-created\n+                        // work profile by default due to b/382064697 . This would have\n+                        //  impacted certain CTS test flows when they interact with the\n+                        // work profile via ADB (for example installing an app into the\n+                        // work profile). Remove DISALLOW_DEBUGGING_FEATURES here to\n+                        // reduce the potential impact.\n+                        setLocalUserRestrictionInternal(\n+                            EnforcingAdmin.createEnterpriseEnforcingAdmin(who, userHandle),\n+                            UserManager.DISALLOW_DEBUGGING_FEATURES, false, userHandle);\n+                    }\n                 }\n+\n                 sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                         userHandle);\n             });\n@@ -11131,7 +11140,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         if (mOwners.hasDeviceOwner()) {\n             return false;\n         }\n-        \n+\n         final ComponentName profileOwner = getProfileOwnerAsUser(userId);\n         if (profileOwner == null) {\n             return false;\n@@ -11140,7 +11149,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         if (isManagedProfile(userId)) {\n             return false;\n         }\n-        \n+\n         return true;\n     }\n     private void enforceCanQueryLockTaskLocked(ComponentName who, String callerPackageName) {\n@@ -24460,7 +24469,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n             }\n         });\n     }\n-    \n+\n     private void migrateUserControlDisabledPackagesLocked() {\n         Binder.withCleanCallingIdentity(() -> {\n             List<UserInfo> users = mUserManager.getUsers();\n",
                "downstream_patch_tokens": {
                    "openai": 1650,
                    "general": {
                        "word_based": 572,
                        "char_based": 1925
                    },
                    "gemini": 2025
                },
                "file_conflicts": [
                    {
                        "file_name": "services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java",
                        "total_hunks": 4,
                        "failed_hunks": [
                            1,
                            2
                        ],
                        "inline_merge_conflicts": [
                            {
                                "hunk_number": 1,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n                if(isAdb) {\n                    // DISALLOW_DEBUGGING_FEATURES is being added to newly-created\n                    // work profile by default due to b/382064697 . This would have\n                    //  impacted certain CTS test flows when they interact with the\n                    // work profile via ADB (for example installing an app into the\n                    // work profile). Remove DISALLOW_DEBUGGING_FEATURES here to\n                    // reduce the potential impact.\n                    setLocalUserRestrictionInternal(\n                        EnforcingAdmin.createEnterpriseEnforcingAdmin(who, userHandle),\n                        UserManager.DISALLOW_DEBUGGING_FEATURES, false, userHandle);\n                }\n\n                sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                        userHandle);\n            });\n>>>>>>> UPSTREAM PATCH (commit 73b54cdf4b70831c4f952d7556274609cb46214e)",
                                "merge_conflict_tokens": {
                                    "openai": 189,
                                    "general": {
                                        "word_based": 71,
                                        "char_based": 249
                                    },
                                    "gemini": 233
                                }
                            }
                        ],
                        "inline_merge_token_summary": {
                            "gemini": 7689,
                            "openai": 6426,
                            "general_word": 2414,
                            "general_char": 8466
                        },
                        "rej_file_content": "```diff\n--- services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n+++ services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n@@ -2723,16 +2723,16 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         }\n     }\n \n-    /**\n-     * Apply default restrictions that haven't been applied to a given admin yet.\n-     */\n+    /** Apply default restrictions that haven't been applied to a given admin yet. */\n     private void maybeSetDefaultRestrictionsForAdminLocked(int userId, ActiveAdmin admin) {\n-        Set<String> defaultRestrictions =\n-                UserRestrictionsUtils.getDefaultEnabledForManagedProfiles();\n-        if (defaultRestrictions.equals(admin.defaultEnabledRestrictionsAlreadySet)) {\n+        Set<String> newDefaultRestrictions = new HashSet(\n+            UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n+        newDefaultRestrictions.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n+        if (newDefaultRestrictions.isEmpty()) {\n             return; // The same set of default restrictions has been already applied.\n         }\n-        for (String restriction : defaultRestrictions) {\n+\n+        for (String restriction : newDefaultRestrictions) {\n             mDevicePolicyEngine.setLocalPolicy(\n                     PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction),\n                     EnforcingAdmin.createEnterpriseEnforcingAdmin(\n@@ -2740,10 +2740,9 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                             admin.getUserHandle().getIdentifier()),\n                     new BooleanPolicyValue(true),\n                     userId);\n+            admin.defaultEnabledRestrictionsAlreadySet.add(restriction);\n+            Slogf.i(LOG_TAG, \"Enabled the following restriction by default: \" + restriction);\n         }\n-        admin.defaultEnabledRestrictionsAlreadySet.addAll(defaultRestrictions);\n-        Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \"\n-                + defaultRestrictions);\n     }\n \n     private void maybeStartSecurityLogMonitorOnActivityManagerReady() {\n```",
                        "rej_file_tokens": {
                            "openai": 425,
                            "general": {
                                "word_based": 159,
                                "char_based": 551
                            },
                            "gemini": 498
                        },
                        "patch_apply_output": "patching file services/core/java/com/android/server/pm/UserRestrictionsUtils.java\nHunk #1 succeeded at 282 (offset -27 lines).\npatching file services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\nHunk #1 FAILED at 2723.\nHunk #2 FAILED at 2740.\nHunk #3 succeeded at 10192 (offset -90 lines).\nHunk #4 succeeded at 10216 (offset -90 lines).\n2 out of 4 hunks FAILED -- saving rejects to file services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java.rej",
                        "inline_merge_output": "patching file services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\nHunk #1 already applied at 2726,2728-2731,2734-2735.\nHunk #2 already applied at 2743-2744,2746.\nHunk #3 already applied at 10284-10285.\nHunk #4 NOT MERGED at 10308-10325.",
                        "upstream_file_content": "```java\n/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.devicepolicy;\n\nimport static android.Manifest.permission.BIND_DEVICE_ADMIN;\nimport static android.Manifest.permission.LOCK_DEVICE;\nimport static android.Manifest.permission.MANAGE_CA_CERTIFICATES;\nimport static android.Manifest.permission.MANAGE_DEFAULT_APPLICATIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AIRPLANE_MODE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_APPS_CONTROL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_APP_FUNCTIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_APP_RESTRICTIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ASSIST_CONTENT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AUDIO_OUTPUT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AUDIT_LOGGING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AUTOFILL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_BLOCK_UNINSTALL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_BLUETOOTH;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CALLS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CAMERA;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CAMERA_TOGGLE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CERTIFICATES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CONTENT_PROTECTION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DEFAULT_SMS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DISPLAY;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_FACTORY_RESET;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_FUN;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_INPUT_METHODS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_KEYGUARD;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCALE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCATION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK_TASK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MANAGED_SUBSCRIPTIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MICROPHONE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MICROPHONE_TOGGLE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MOBILE_NETWORK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MODIFY_USERS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MTE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PACKAGE_STATE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PRINTING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PROFILES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PROFILE_INTERACTION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RESET_PASSWORD;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SAFE_BOOT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SCREEN_CAPTURE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SCREEN_CONTENT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SECURITY_LOGGING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SMS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_STATUS_BAR;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_STORAGE_LIMIT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SYSTEM_UPDATES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_THREAD_NETWORK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_TIME;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_VPN;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WALLPAPER;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WIFI;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WINDOWS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WIPE_DATA;\nimport static android.Manifest.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS;\nimport static android.Manifest.permission.MASTER_CLEAR;\nimport static android.Manifest.permission.NOTIFY_PENDING_SYSTEM_UPDATE;\nimport static android.Manifest.permission.QUERY_ADMIN_POLICY;\nimport static android.Manifest.permission.QUERY_DEVICE_STOLEN_STATE;\nimport static android.Manifest.permission.REQUEST_PASSWORD_COMPLEXITY;\nimport static android.Manifest.permission.SET_TIME;\nimport static android.Manifest.permission.SET_TIME_ZONE;\nimport static android.accessibilityservice.AccessibilityServiceInfo.FEEDBACK_ALL_MASK;\nimport static android.accounts.AccountManager.LOGIN_ACCOUNTS_CHANGED_ACTION;\nimport static android.app.ActivityManager.LOCK_TASK_MODE_NONE;\nimport static android.app.AppOpsManager.MODE_ALLOWED;\nimport static android.app.AppOpsManager.MODE_DEFAULT;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_HIBERNATION;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_POWER_RESTRICTIONS;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_SUSPENSION;\nimport static android.app.AppOpsManager.OP_RUN_ANY_IN_BACKGROUND;\nimport static android.app.AppOpsManager.OP_RUN_IN_BACKGROUND;\nimport static android.app.StatsManager.PULL_SUCCESS;\nimport static android.app.admin.DeviceAdminInfo.HEADLESS_DEVICE_OWNER_MODE_AFFILIATED;\nimport static android.app.admin.DeviceAdminInfo.HEADLESS_DEVICE_OWNER_MODE_SINGLE_USER;\nimport static android.app.admin.DeviceAdminInfo.HEADLESS_DEVICE_OWNER_MODE_UNSUPPORTED;\nimport static android.app.admin.DeviceAdminInfo.USES_POLICY_FORCE_LOCK;\nimport static android.app.admin.DeviceAdminInfo.USES_POLICY_WIPE_DATA;\nimport static android.app.admin.DeviceAdminReceiver.ACTION_COMPLIANCE_ACKNOWLEDGEMENT_REQUIRED;\nimport static android.app.admin.DeviceAdminReceiver.EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE;\nimport static android.app.admin.DevicePolicyIdentifiers.MEMORY_TAGGING_POLICY;\nimport static android.app.admin.DevicePolicyManager.ACTION_CHECK_POLICY_COMPLIANCE;\nimport static android.app.admin.DevicePolicyManager.ACTION_DEVICE_FINANCING_STATE_CHANGED;\nimport static android.app.admin.DevicePolicyManager.ACTION_DEVICE_POLICY_RESOURCE_UPDATED;\nimport static android.app.admin.DevicePolicyManager.ACTION_MANAGED_PROFILE_PROVISIONED;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_USER;\nimport static android.app.admin.DevicePolicyManager.ACTION_SYSTEM_UPDATE_POLICY_CHANGED;\nimport static android.app.admin.DevicePolicyManager.APP_FUNCTIONS_NOT_CONTROLLED_BY_POLICY;\nimport static android.app.admin.DevicePolicyManager.CONTENT_PROTECTION_DISABLED;\nimport static android.app.admin.DevicePolicyManager.ContentProtectionPolicy;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_APP_RESTRICTIONS;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_BLOCK_UNINSTALL;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_CERT_INSTALL;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_CERT_SELECTION;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_ENABLE_SYSTEM_APP;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_INSTALL_EXISTING_PACKAGE;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_KEEP_UNINSTALLED_PACKAGES;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_NETWORK_LOGGING;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_PACKAGE_ACCESS;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_PERMISSION_GRANT;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_SECURITY_LOGGING;\nimport static android.app.admin.DevicePolicyManager.DEVICE_OWNER_TYPE_DEFAULT;\nimport static android.app.admin.DevicePolicyManager.DEVICE_OWNER_TYPE_FINANCED;\nimport static android.app.admin.DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_PER_USER;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_HIBERNATION;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_POWER_RESTRICTIONS;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_SUSPENSION;\nimport static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_IDS;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE_DRAWABLE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE_STRING;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_BASE_INFO;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_IMEI;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_INDIVIDUAL_ATTESTATION;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_MEID;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_SERIAL;\nimport static android.app.admin.DevicePolicyManager.LEAVE_ALL_SYSTEM_APPS_ENABLED;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_GLOBAL_ACTIONS;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_HOME;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_KEYGUARD;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_NOTIFICATIONS;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_OVERVIEW;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_SYSTEM_INFO;\nimport static android.app.admin.DevicePolicyManager.NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\nimport static android.app.admin.DevicePolicyManager.NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\nimport static android.app.admin.DevicePolicyManager.OPERATION_SAFETY_REASON_NONE;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_HIGH;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_LOW;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_MEDIUM;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_NONE;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_COMPLEX;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_MANAGED;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_NUMERIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_SOMETHING;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED;\nimport static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;\nimport static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_NOT_SUSPENDED;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_SUSPENDED_EXPLICITLY;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_SUSPENDED_PROFILE_TIMEOUT;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_OFF;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_OPPORTUNISTIC;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_PROVIDER_HOSTNAME;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_UNKNOWN;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_SET_ERROR_FAILURE_SETTING;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_SET_NO_ERROR;\nimport static android.app.admin.DevicePolicyManager.PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATE_USER_SETUP_FINALIZED;\nimport static android.app.admin.DevicePolicyManager.STATE_USER_UNMANAGED;\nimport static android.app.admin.DevicePolicyManager.STATUS_ACCOUNTS_NOT_EMPTY;\nimport static android.app.admin.DevicePolicyManager.STATUS_CANNOT_ADD_MANAGED_PROFILE;\nimport static android.app.admin.DevicePolicyManager.STATUS_DEVICE_ADMIN_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_HAS_DEVICE_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATUS_HAS_PAIRED;\nimport static android.app.admin.DevicePolicyManager.STATUS_HEADLESS_ONLY_SYSTEM_USER;\nimport static android.app.admin.DevicePolicyManager.STATUS_HEADLESS_SYSTEM_USER_MODE_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_MANAGED_USERS_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_NONSYSTEM_USER_EXISTS;\nimport static android.app.admin.DevicePolicyManager.STATUS_NOT_SYSTEM_USER;\nimport static android.app.admin.DevicePolicyManager.STATUS_OK;\nimport static android.app.admin.DevicePolicyManager.STATUS_PROVISIONING_NOT_ALLOWED_FOR_NON_DEVELOPER_USERS;\nimport static android.app.admin.DevicePolicyManager.STATUS_SYSTEM_USER;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_HAS_PROFILE_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_NOT_RUNNING;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_SETUP_COMPLETED;\nimport static android.app.admin.DevicePolicyManager.WIPE_EUICC;\nimport static android.app.admin.DevicePolicyManager.WIPE_EXTERNAL_STORAGE;\nimport static android.app.admin.DevicePolicyManager.WIPE_RESET_PROTECTION_DATA;\nimport static android.app.admin.DevicePolicyManager.WIPE_SILENTLY;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.LOCATION_CHANGED_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.LOCATION_CHANGED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NETWORK_LOGGING_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NETWORK_LOGGING_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NOTIFICATION_WORK_PROFILE_CONTENT_DESCRIPTION;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_SOON_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_TURN_ON_PROFILE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PRINTING_DISABLED_NAMED_ADMIN;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_FAILED_PASSWORD_ATTEMPTS_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_GENERIC_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_ORG_OWNED_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_BODY;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_TURN_ON_BUTTON;\nimport static android.app.admin.PolicySizeVerifier.MAX_LONG_SUPPORT_MESSAGE_LENGTH;\nimport static android.app.admin.PolicySizeVerifier.MAX_ORG_NAME_LENGTH;\nimport static android.app.admin.PolicySizeVerifier.MAX_PROFILE_NAME_LENGTH;\nimport static android.app.admin.PolicySizeVerifier.MAX_SHORT_SUPPORT_MESSAGE_LENGTH;\nimport static android.app.admin.ProvisioningException.ERROR_ADMIN_PACKAGE_INSTALLATION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_PRE_CONDITION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_PROFILE_CREATION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_REMOVE_NON_REQUIRED_APPS_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_SETTING_PROFILE_OWNER_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_SET_DEVICE_OWNER_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_STARTING_PROFILE_FAILED;\nimport static android.content.Intent.ACTION_MANAGED_PROFILE_AVAILABLE;\nimport static android.content.Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.pm.PackageManager.GET_META_DATA;\nimport static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_AWARE;\nimport static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_UNAWARE;\nimport static android.content.pm.PackageManager.MATCH_UNINSTALLED_PACKAGES;\nimport static android.content.pm.PackageManager.PERMISSION_GRANTED;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_DEFAULT;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE_BLOCKING;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE_NO_FALLBACK;\nimport static android.net.NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK;\nimport static android.provider.Settings.Global.PRIVATE_DNS_SPECIFIER;\nimport static android.provider.Settings.Secure.MANAGED_PROVISIONING_DPC_DOWNLOADED;\nimport static android.provider.Settings.Secure.USER_SETUP_COMPLETE;\nimport static android.provider.Telephony.Carriers.DPC_URI;\nimport static android.provider.Telephony.Carriers.ENFORCE_KEY;\nimport static android.provider.Telephony.Carriers.ENFORCE_MANAGED_URI;\nimport static android.provider.Telephony.Carriers.INVALID_APN_ID;\nimport static android.security.keystore.AttestationUtils.USE_INDIVIDUAL_ATTESTATION;\n\nimport static com.android.internal.logging.nano.MetricsProto.MetricsEvent.PROVISIONING_ENTRY_POINT_ADB;\nimport static com.android.internal.util.ConcurrentUtils.DIRECT_EXECUTOR;\nimport static com.android.internal.widget.LockPatternUtils.CREDENTIAL_TYPE_NONE;\nimport static com.android.internal.widget.LockPatternUtils.StrongAuthTracker.SOME_AUTH_REQUIRED_AFTER_ADAPTIVE_AUTH_REQUEST;\nimport static com.android.internal.widget.LockPatternUtils.StrongAuthTracker.STRONG_AUTH_REQUIRED_AFTER_DPM_LOCK_NOW;\nimport static com.android.server.SystemTimeZone.TIME_ZONE_CONFIDENCE_HIGH;\nimport static com.android.server.am.ActivityManagerService.STOCK_PM_FLAGS;\nimport static com.android.server.devicepolicy.DevicePolicyEngine.DEFAULT_POLICY_SIZE_LIMIT;\nimport static com.android.server.devicepolicy.DevicePolicyStatsLog.DEVICE_POLICY_MANAGEMENT_MODE;\nimport static com.android.server.devicepolicy.DevicePolicyStatsLog.DEVICE_POLICY_MANAGEMENT_MODE__MANAGEMENT_MODE__COPE;\nimport static com.android.server.devicepolicy.DevicePolicyStatsLog.DEVICE_POLICY_MANAGEMENT_MODE__MANAGEMENT_MODE__DEVICE_OWNER;\nimport static com.android.server.devicepolicy.DevicePolicyStatsLog.DEVICE_POLICY_MANAGEMENT_MODE__MANAGEMENT_MODE__DEVICE_OWNER_FINANCED;\nimport static com.android.server.devicepolicy.DevicePolicyStatsLog.DEVICE_POLICY_MANAGEMENT_MODE__MANAGEMENT_MODE__MANAGEMENT_MODE_UNSPECIFIED;\nimport static com.android.server.devicepolicy.DevicePolicyStatsLog.DEVICE_POLICY_MANAGEMENT_MODE__MANAGEMENT_MODE__PROFILE_OWNER;\nimport static com.android.server.devicepolicy.DevicePolicyStatsLog.DEVICE_POLICY_STATE;\nimport static com.android.server.devicepolicy.DevicePolicyStatsLog.DEVICE_POLICY_STATE__PASSWORD_COMPLEXITY__COMPLEXITY_HIGH;\nimport static com.android.server.devicepolicy.DevicePolicyStatsLog.DEVICE_POLICY_STATE__PASSWORD_COMPLEXITY__COMPLEXITY_LEGACY;\nimport static com.android.server.devicepolicy.DevicePolicyStatsLog.DEVICE_POLICY_STATE__PASSWORD_COMPLEXITY__COMPLEXITY_LOW;\nimport static com.android.server.devicepolicy.DevicePolicyStatsLog.DEVICE_POLICY_STATE__PASSWORD_COMPLEXITY__COMPLEXITY_MEDIUM;\nimport static com.android.server.devicepolicy.DevicePolicyStatsLog.DEVICE_POLICY_STATE__PASSWORD_COMPLEXITY__COMPLEXITY_NONE;\nimport static com.android.server.devicepolicy.DevicePolicyStatsLog.DEVICE_POLICY_STATE__PASSWORD_COMPLEXITY__COMPLEXITY_UNSPECIFIED;\nimport static com.android.server.devicepolicy.TransferOwnershipMetadataManager.ADMIN_TYPE_DEVICE_OWNER;\nimport static com.android.server.devicepolicy.TransferOwnershipMetadataManager.ADMIN_TYPE_PROFILE_OWNER;\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_DEVICE_OWNER;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_PROFILE_OWNER;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE;\n\nimport android.Manifest;\nimport android.Manifest.permission;\nimport android.accessibilityservice.AccessibilityServiceInfo;\nimport android.accounts.Account;\nimport android.accounts.AccountManager;\nimport android.accounts.AuthenticatorException;\nimport android.accounts.OperationCanceledException;\nimport android.annotation.IntDef;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManager.Mode;\nimport android.app.BroadcastOptions;\nimport android.app.IActivityManager;\nimport android.app.IActivityTaskManager;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.StatsManager;\nimport android.app.StatusBarManager;\nimport android.app.admin.AccountTypePolicyKey;\nimport android.app.admin.BooleanPolicyValue;\nimport android.app.admin.BundlePolicyValue;\nimport android.app.admin.ComponentNamePolicyValue;\nimport android.app.admin.DeviceAdminInfo;\nimport android.app.admin.DeviceAdminReceiver;\nimport android.app.admin.DevicePolicyCache;\nimport android.app.admin.DevicePolicyDrawableResource;\nimport android.app.admin.DevicePolicyEventLogger;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.admin.DevicePolicyManager.AppFunctionsPolicy;\nimport android.app.admin.DevicePolicyManager.DeviceOwnerType;\nimport android.app.admin.DevicePolicyManager.DevicePolicyOperation;\nimport android.app.admin.DevicePolicyManager.OperationSafetyReason;\nimport android.app.admin.DevicePolicyManager.PasswordComplexity;\nimport android.app.admin.DevicePolicyManager.PersonalAppsSuspensionReason;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerLiteInternal;\nimport android.app.admin.DevicePolicySafetyChecker;\nimport android.app.admin.DevicePolicyState;\nimport android.app.admin.DevicePolicyStringResource;\nimport android.app.admin.DeviceStateCache;\nimport android.app.admin.FactoryResetProtectionPolicy;\nimport android.app.admin.FullyManagedDeviceProvisioningParams;\nimport android.app.admin.IAuditLogEventsCallback;\nimport android.app.admin.IDevicePolicyManager;\nimport android.app.admin.IntegerPolicyValue;\nimport android.app.admin.IntentFilterPolicyKey;\nimport android.app.admin.LockTaskPolicy;\nimport android.app.admin.LongPolicyValue;\nimport android.app.admin.ManagedProfileProvisioningParams;\nimport android.app.admin.ManagedSubscriptionsPolicy;\nimport android.app.admin.NetworkEvent;\nimport android.app.admin.PackagePolicy;\nimport android.app.admin.PackageSetPolicyValue;\nimport android.app.admin.ParcelableGranteeMap;\nimport android.app.admin.ParcelableResource;\nimport android.app.admin.PasswordMetrics;\nimport android.app.admin.PasswordPolicy;\nimport android.app.admin.PolicyKey;\nimport android.app.admin.PolicySizeVerifier;\nimport android.app.admin.PolicyValue;\nimport android.app.admin.PreferentialNetworkServiceConfig;\nimport android.app.admin.SecurityLog;\nimport android.app.admin.SecurityLog.SecurityEvent;\nimport android.app.admin.StartInstallingUpdateCallback;\nimport android.app.admin.SystemUpdateInfo;\nimport android.app.admin.SystemUpdatePolicy;\nimport android.app.admin.UnsafeStateException;\nimport android.app.admin.UserRestrictionPolicyKey;\nimport android.app.admin.WifiSsidPolicy;\nimport android.app.admin.flags.Flags;\nimport android.app.backup.IBackupManager;\nimport android.app.compat.CompatChanges;\nimport android.app.role.OnRoleHoldersChangedListener;\nimport android.app.role.RoleManager;\nimport android.app.supervision.SupervisionManagerInternal;\nimport android.app.trust.TrustManager;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.compat.annotation.ChangeId;\nimport android.compat.annotation.EnabledAfter;\nimport android.compat.annotation.EnabledSince;\nimport android.content.ActivityNotFoundException;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.IIntentReceiver;\nimport android.content.IIntentSender;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.PermissionChecker;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.CrossProfileApps;\nimport android.content.pm.CrossProfileAppsInternal;\nimport android.content.pm.IPackageDataObserver;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageInstaller;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.StringParceledListSlice;\nimport android.content.pm.UserInfo;\nimport android.content.pm.UserPackage;\nimport android.content.pm.parsing.FrameworkParsingPackageUtils;\nimport android.content.res.Resources;\nimport android.database.ContentObserver;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.hardware.usb.UsbManager;\nimport android.location.Location;\nimport android.location.LocationManager;\nimport android.media.AudioManager;\nimport android.net.ConnectivityManager;\nimport android.net.ConnectivitySettingsManager;\nimport android.net.IIpConnectivityMetrics;\nimport android.net.ProfileNetworkPreference;\nimport android.net.ProxyInfo;\nimport android.net.Uri;\nimport android.net.VpnManager;\nimport android.net.metrics.IpConnectivityLog;\nimport android.net.wifi.WifiManager;\nimport android.os.AsyncTask;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.ParcelFileDescriptor;\nimport android.os.PersistableBundle;\nimport android.os.PowerManager;\nimport android.os.PowerManagerInternal;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ServiceSpecificException;\nimport android.os.ShellCallback;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.UserManager.EnforcingUser;\nimport android.os.UserManager.UserRestrictionSource;\nimport android.os.storage.StorageManager;\nimport android.permission.AdminPermissionControlParams;\nimport android.permission.IPermissionManager;\nimport android.permission.PermissionControllerManager;\nimport android.provider.CalendarContract;\nimport android.provider.ContactsContract.QuickContact;\nimport android.provider.ContactsInternal;\nimport android.provider.Settings;\nimport android.provider.Settings.Global;\nimport android.provider.Telephony;\nimport android.security.AppUriAuthenticationPolicy;\nimport android.security.IKeyChainAliasCallback;\nimport android.security.IKeyChainService;\nimport android.security.KeyChain;\nimport android.security.KeyChain.KeyChainConnection;\nimport android.security.keymaster.KeymasterCertificateChain;\nimport android.security.keystore.AttestationUtils;\nimport android.security.keystore.KeyGenParameterSpec;\nimport android.security.keystore.KeyProperties;\nimport android.security.keystore.ParcelableKeyGenParameterSpec;\nimport android.stats.devicepolicy.DevicePolicyEnums;\nimport android.telecom.TelecomManager;\nimport android.telephony.SubscriptionInfo;\nimport android.telephony.SubscriptionManager;\nimport android.telephony.TelephonyManager;\nimport android.telephony.data.ApnSetting;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.DebugUtils;\nimport android.util.IndentingPrintWriter;\nimport android.util.IntArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.StatsEvent;\nimport android.util.Xml;\nimport android.view.IWindowManager;\nimport android.view.accessibility.AccessibilityManager;\nimport android.view.accessibility.IAccessibilityManager;\nimport android.view.inputmethod.InputMethodInfo;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.LocalePicker;\nimport com.android.internal.infra.AndroidFuture;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.net.NetworkUtilsInternal;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.statusbar.IStatusBarService;\nimport com.android.internal.telephony.SmsApplication;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.FunctionalUtils.ThrowingRunnable;\nimport com.android.internal.util.FunctionalUtils.ThrowingSupplier;\nimport com.android.internal.util.JournaledFile;\nimport com.android.internal.util.Preconditions;\nimport com.android.internal.util.StatLogger;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.internal.widget.LockSettingsInternal;\nimport com.android.internal.widget.LockscreenCredential;\nimport com.android.internal.widget.PasswordValidationError;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.net.module.util.ProxyUtils;\nimport com.android.server.AlarmManagerInternal;\nimport com.android.server.LocalManagerRegistry;\nimport com.android.server.LocalServices;\nimport com.android.server.LockGuard;\nimport com.android.server.SystemServerInitThreadPool;\nimport com.android.server.SystemService;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.devicepolicy.ActiveAdmin.TrustAgentInfo;\nimport com.android.server.inputmethod.InputMethodManagerInternal;\nimport com.android.server.net.NetworkPolicyManagerInternal;\nimport com.android.server.pdb.PersistentDataBlockManagerInternal;\nimport com.android.server.pm.DefaultCrossProfileIntentFilter;\nimport com.android.server.pm.DefaultCrossProfileIntentFiltersUtils;\nimport com.android.server.pm.PackageManagerLocal;\nimport com.android.server.pm.RestrictionsSet;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.pm.UserManagerInternal.UserRestrictionsListener;\nimport com.android.server.pm.UserRestrictionsUtils;\nimport com.android.server.pm.pkg.AndroidPackage;\nimport com.android.server.storage.DeviceStorageMonitorInternal;\nimport com.android.server.uri.NeededUriGrants;\nimport com.android.server.uri.UriGrantsManagerInternal;\nimport com.android.server.utils.Slogf;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Constructor;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.text.DateFormat;\nimport java.time.LocalDate;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * Implementation of the device policy APIs.\n */\npublic class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n\n    protected static final String LOG_TAG = \"DevicePolicyManager\";\n\n    private static final String ATTRIBUTION_TAG = \"DevicePolicyManagerService\";\n\n    static final boolean VERBOSE_LOG = false; // DO NOT SUBMIT WITH TRUE\n\n    static final String DEVICE_POLICIES_XML = \"device_policies.xml\";\n\n    static final String POLICIES_VERSION_XML = \"device_policies_version\";\n\n    private static final String TRANSFER_OWNERSHIP_PARAMETERS_XML =\n            \"transfer-ownership-parameters.xml\";\n\n    private static final String TAG_TRANSFER_OWNERSHIP_BUNDLE = \"transfer-ownership-bundle\";\n\n    private static final int REQUEST_EXPIRE_PASSWORD = 5571;\n\n    private static final int REQUEST_PROFILE_OFF_DEADLINE = 5572;\n\n    private static final long MS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n\n    private static final long EXPIRATION_GRACE_PERIOD_MS = 5 * MS_PER_DAY; // 5 days, in ms\n    private static final long MANAGED_PROFILE_MAXIMUM_TIME_OFF_THRESHOLD = 3 * MS_PER_DAY;\n    /** When to warn the user about the approaching work profile off deadline: 1 day before */\n    private static final long MANAGED_PROFILE_OFF_WARNING_PERIOD = 1 * MS_PER_DAY;\n\n    private static final String ACTION_EXPIRED_PASSWORD_NOTIFICATION =\n            \"com.android.server.ACTION_EXPIRED_PASSWORD_NOTIFICATION\";\n\n    /** Broadcast action invoked when the user taps a notification to turn the profile on. */\n    @VisibleForTesting\n    static final String ACTION_TURN_PROFILE_ON_NOTIFICATION =\n            \"com.android.server.ACTION_TURN_PROFILE_ON_NOTIFICATION\";\n\n    /** Broadcast action for tracking managed profile maximum time off. */\n    @VisibleForTesting\n    static final String ACTION_PROFILE_OFF_DEADLINE =\n            \"com.android.server.ACTION_PROFILE_OFF_DEADLINE\";\n\n    private static final String CALLED_FROM_PARENT = \"calledFromParent\";\n    private static final String NOT_CALLED_FROM_PARENT = \"notCalledFromParent\";\n\n    private static final String CREDENTIAL_MANAGEMENT_APP = \"credentialManagementApp\";\n    private static final String NOT_CREDENTIAL_MANAGEMENT_APP = \"notCredentialManagementApp\";\n\n    private static final String NULL_STRING_ARRAY = \"nullStringArray\";\n\n    private static final String ALLOW_USER_PROVISIONING_KEY = \"ro.config.allowuserprovisioning\";\n\n    // Comprehensive list of delegations.\n    private static final String DELEGATIONS[] = {\n        DELEGATION_CERT_INSTALL,\n        DELEGATION_APP_RESTRICTIONS,\n        DELEGATION_BLOCK_UNINSTALL,\n        DELEGATION_ENABLE_SYSTEM_APP,\n        DELEGATION_KEEP_UNINSTALLED_PACKAGES,\n        DELEGATION_PACKAGE_ACCESS,\n        DELEGATION_PERMISSION_GRANT,\n        DELEGATION_INSTALL_EXISTING_PACKAGE,\n        DELEGATION_KEEP_UNINSTALLED_PACKAGES,\n        DELEGATION_NETWORK_LOGGING,\n        DELEGATION_SECURITY_LOGGING,\n        DELEGATION_CERT_SELECTION,\n    };\n\n    // Subset of delegations that can only be delegated by Device Owner or Profile Owner of a\n    // managed profile.\n    private static final List<String> DEVICE_OWNER_OR_MANAGED_PROFILE_OWNER_DELEGATIONS =\n            Arrays.asList(new String[]{\n                    DELEGATION_NETWORK_LOGGING,\n            });\n\n    // Subset of delegations that can only be delegated by Device Owner or Profile Owner of an\n    // organization-owned and managed profile.\n    private static final List<String>\n            DEVICE_OWNER_OR_ORGANIZATION_OWNED_MANAGED_PROFILE_OWNER_DELEGATIONS =\n            Arrays.asList(new String[]{\n                    DELEGATION_SECURITY_LOGGING,\n            });\n\n    // Subset of delegations that only one single package within a given user can hold\n    private static final List<String> EXCLUSIVE_DELEGATIONS = Arrays.asList(new String[] {\n            DELEGATION_NETWORK_LOGGING,\n            DELEGATION_SECURITY_LOGGING,\n            DELEGATION_CERT_SELECTION,\n    });\n\n    private static final int STATUS_BAR_DISABLE_MASK =\n            StatusBarManager.DISABLE_EXPAND |\n            StatusBarManager.DISABLE_NOTIFICATION_ICONS |\n            StatusBarManager.DISABLE_NOTIFICATION_ALERTS |\n            StatusBarManager.DISABLE_SEARCH;\n\n    private static final int STATUS_BAR_DISABLE2_MASK =\n            StatusBarManager.DISABLE2_QUICK_SETTINGS;\n\n    private static final Set<String> SECURE_SETTINGS_ALLOWLIST;\n    private static final Set<String> SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST;\n    private static final Set<String> GLOBAL_SETTINGS_ALLOWLIST;\n    private static final Set<String> GLOBAL_SETTINGS_DEPRECATED;\n    private static final Set<String> SYSTEM_SETTINGS_ALLOWLIST;\n    private static final Set<Integer> DA_DISALLOWED_POLICIES;\n    private static final String AB_DEVICE_KEY = \"ro.build.ab_update\";\n    // The version of the current DevicePolicyManagerService data. This version is used\n    // to decide whether an existing policy in the {@link #DEVICE_POLICIES_XML} needs to\n    // be upgraded. See {@link PolicyVersionUpgrader} on instructions how to add an upgrade\n    // step.\n    static final int DPMS_VERSION = 6;\n\n    static {\n        SECURE_SETTINGS_ALLOWLIST = new ArraySet<>();\n        SECURE_SETTINGS_ALLOWLIST.add(Settings.Secure.DEFAULT_INPUT_METHOD);\n        SECURE_SETTINGS_ALLOWLIST.add(Settings.Secure.SKIP_FIRST_USE_HINTS);\n        SECURE_SETTINGS_ALLOWLIST.add(Settings.Secure.INSTALL_NON_MARKET_APPS);\n\n        SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST = new ArraySet<>();\n        SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST.addAll(SECURE_SETTINGS_ALLOWLIST);\n        SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST.add(Settings.Secure.LOCATION_MODE);\n\n        GLOBAL_SETTINGS_ALLOWLIST = new ArraySet<>();\n        GLOBAL_SETTINGS_ALLOWLIST.add(Global.ADB_ENABLED);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Global.ADB_WIFI_ENABLED);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Global.AUTO_TIME);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Global.AUTO_TIME_ZONE);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Global.DATA_ROAMING);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Global.USB_MASS_STORAGE_ENABLED);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Global.WIFI_SLEEP_POLICY);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Global.STAY_ON_WHILE_PLUGGED_IN);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Global.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Global.PRIVATE_DNS_MODE);\n        GLOBAL_SETTINGS_ALLOWLIST.add(PRIVATE_DNS_SPECIFIER);\n\n        GLOBAL_SETTINGS_DEPRECATED = new ArraySet<>();\n        GLOBAL_SETTINGS_DEPRECATED.add(Global.BLUETOOTH_ON);\n        GLOBAL_SETTINGS_DEPRECATED.add(Global.DEVELOPMENT_SETTINGS_ENABLED);\n        GLOBAL_SETTINGS_DEPRECATED.add(Global.MODE_RINGER);\n        GLOBAL_SETTINGS_DEPRECATED.add(Global.NETWORK_PREFERENCE);\n        GLOBAL_SETTINGS_DEPRECATED.add(Global.WIFI_ON);\n\n        SYSTEM_SETTINGS_ALLOWLIST = new ArraySet<>();\n        SYSTEM_SETTINGS_ALLOWLIST.add(Settings.System.SCREEN_BRIGHTNESS);\n        SYSTEM_SETTINGS_ALLOWLIST.add(Settings.System.SCREEN_BRIGHTNESS_MODE);\n        SYSTEM_SETTINGS_ALLOWLIST.add(Settings.System.SCREEN_OFF_TIMEOUT);\n\n        DA_DISALLOWED_POLICIES = new ArraySet<>();\n        DA_DISALLOWED_POLICIES.add(DeviceAdminInfo.USES_POLICY_DISABLE_CAMERA);\n        DA_DISALLOWED_POLICIES.add(DeviceAdminInfo.USES_POLICY_DISABLE_KEYGUARD_FEATURES);\n        DA_DISALLOWED_POLICIES.add(DeviceAdminInfo.USES_POLICY_EXPIRE_PASSWORD);\n        DA_DISALLOWED_POLICIES.add(DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD);\n    }\n\n    /**\n     * Keyguard features that when set on a profile affect the profile content or challenge only.\n     * These cannot be set on the managed profile's parent DPM instance\n     */\n    private static final int PROFILE_KEYGUARD_FEATURES_PROFILE_ONLY =\n            DevicePolicyManager.KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS\n                    | DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL;\n\n    /** Keyguard features that are allowed to be set on a managed profile */\n    private static final int PROFILE_KEYGUARD_FEATURES =\n            NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER\n                    | PROFILE_KEYGUARD_FEATURES_PROFILE_ONLY;\n\n    private static final int DEVICE_ADMIN_DEACTIVATE_TIMEOUT = 10000;\n\n    /**\n     * Minimum timeout in milliseconds after which unlocking with weak auth times out,\n     * i.e. the user has to use a strong authentication method like password, PIN or pattern.\n     */\n    private static final long MINIMUM_STRONG_AUTH_TIMEOUT_MS = TimeUnit.HOURS.toMillis(1);\n\n    /**\n     * The amount of ms that a managed kiosk must go without user interaction to be considered\n     * unattended.\n     */\n    private static final int UNATTENDED_MANAGED_KIOSK_MS = 30000;\n\n    /**\n     * Strings logged with {@link\n     * MetricsProto.MetricsEvent#PROVISIONING_ENTRY_POINT_ADB},\n     * {@link DevicePolicyEnums#PROVISIONING_ENTRY_POINT_ADB},\n     * {@link DevicePolicyEnums#SET_NETWORK_LOGGING_ENABLED} and\n     * {@link DevicePolicyEnums#RETRIEVE_NETWORK_LOGS}.\n     */\n    private static final String LOG_TAG_PROFILE_OWNER = \"profile-owner\";\n    private static final String LOG_TAG_DEVICE_OWNER = \"device-owner\";\n\n    /**\n     * For admin apps targeting R+, throw when the app sets password requirement\n     * that is not taken into account at given quality. For example when quality is set\n     * to {@link DevicePolicyManager#PASSWORD_QUALITY_UNSPECIFIED}, it doesn't\n     * make sense to require certain password length. If the intent is to require a password of\n     * certain length having at least NUMERIC quality, the admin should first call\n     * {@link DevicePolicyManager#setPasswordQuality} and only then call\n     * {@link DevicePolicyManager#setPasswordMinimumLength}.\n     *\n     * <p>Conversely when an admin app targeting R+ lowers password quality, those\n     * requirements that stop making sense are reset to default values.\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion = Build.VERSION_CODES.Q)\n    private static final long ADMIN_APP_PASSWORD_COMPLEXITY = 123562444L;\n\n    /**\n     * Admin apps targeting Android R+ may not use\n     * {@link DevicePolicyManager#setSecureSetting} to change the deprecated\n     * {@link Settings.Secure#LOCATION_MODE} setting. Instead they should use\n     * {@link DevicePolicyManager#setLocationEnabled}.\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion = Build.VERSION_CODES.Q)\n    private static final long USE_SET_LOCATION_ENABLED = 117835097L;\n\n    /**\n     * Forces wipeDataNoLock to attempt removing the user or throw an error as\n     * opposed to trying to factory reset the device first and only then falling back to user\n     * removal.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    public static final long EXPLICIT_WIPE_BEHAVIOUR = 242193913L;\n\n    /**\n     * Apps targeting V+ should now expect that attempts to grant sensor permissions without\n     * authorisation will result in a security exception.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.VANILLA_ICE_CREAM)\n    public static final long THROW_SECURITY_EXCEPTION_FOR_SENSOR_PERMISSIONS = 277035314L;\n\n    /**\n     * Allows DPCs to provisioning fully managed headless devices in single-user mode.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = 35)\n    public static final long PROVISION_SINGLE_USER_MODE = 289515470L;\n\n    // Only add to the end of the list. Do not change or rearrange these values, that will break\n    // historical data. Do not use negative numbers or zero, logger only handles positive\n    // integers.\n    private static final int COPY_ACCOUNT_SUCCEEDED = 1;\n    private static final int COPY_ACCOUNT_FAILED = 2;\n    private static final int COPY_ACCOUNT_TIMED_OUT = 3;\n    private static final int COPY_ACCOUNT_EXCEPTION = 4;\n\n    @IntDef({\n            COPY_ACCOUNT_SUCCEEDED,\n            COPY_ACCOUNT_FAILED,\n            COPY_ACCOUNT_TIMED_OUT,\n            COPY_ACCOUNT_EXCEPTION})\n    private @interface CopyAccountStatus {}\n\n    /**\n     * Mapping of {@link DevicePolicyManager.ApplicationExemptionConstants} to\n     * corresponding app-ops.\n     */\n    private static final Map<Integer, String> APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS =\n            new ArrayMap<>();\n    static {\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_SUSPENSION, OPSTR_SYSTEM_EXEMPT_FROM_SUSPENSION);\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS,\n                OPSTR_SYSTEM_EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS);\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION,\n                OPSTR_SYSTEM_EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION);\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_HIBERNATION, OPSTR_SYSTEM_EXEMPT_FROM_HIBERNATION);\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_POWER_RESTRICTIONS, OPSTR_SYSTEM_EXEMPT_FROM_POWER_RESTRICTIONS);\n    }\n\n    private static final Set<String> METERED_DATA_RESTRICTION_EXEMPT_ROLES =\n            new ArraySet<>();\n    static {\n        // TODO(b/362545319): reference role name from role manager once it's exposed.\n        final String roleDeviceLockController =\n                \"android.app.role.SYSTEM_FINANCED_DEVICE_CONTROLLER\";\n        METERED_DATA_RESTRICTION_EXEMPT_ROLES.add(roleDeviceLockController);\n        METERED_DATA_RESTRICTION_EXEMPT_ROLES.add(RoleManager.ROLE_FINANCED_DEVICE_KIOSK);\n    }\n\n    /**\n     * Admin apps targeting Android S+ may not use\n     * {@link DevicePolicyManager#setPasswordQuality} to set password quality\n     * on the {@code DevicePolicyManager} instance obtained by calling\n     * {@link DevicePolicyManager#getParentProfileInstance}.\n     * Instead, they should use\n     * {@link DevicePolicyManager#setRequiredPasswordComplexity} to set\n     * coarse-grained password requirements device-wide.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.S)\n    private static final long PREVENT_SETTING_PASSWORD_QUALITY_ON_PARENT = 165573442L;\n\n    /**\n     * For Admin Apps targeting U+\n     * If {@link IKeyChainService#setGrant} is called with an alias with no\n     * existing key, throw IllegalArgumentException.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    private static final long THROW_EXCEPTION_WHEN_KEY_MISSING = 175101461L;\n\n    private static final String CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG =\n            \"The alias provided must be contained in the aliases specified in the credential \"\n                    + \"management app's authentication policy\";\n    private static final String NOT_SYSTEM_CALLER_MSG = \"Only the system can %s\";\n\n    private static final int RETRY_COPY_ACCOUNT_ATTEMPTS = 3;\n\n    /**\n     * For apps targeting U+\n     * Enable multiple admins to coexist on the same device.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    static final long ENABLE_COEXISTENCE_CHANGE = 260560985L;\n\n    final Context mContext;\n    final Injector mInjector;\n    final PolicyPathProvider mPathProvider;\n    final IPackageManager mIPackageManager;\n    final IPermissionManager mIPermissionManager;\n    final UserManager mUserManager;\n    final UserManagerInternal mUserManagerInternal;\n    final UsageStatsManagerInternal mUsageStatsManagerInternal;\n    final TelephonyManager mTelephonyManager;\n    final RoleManager mRoleManager;\n    final SupervisionManagerInternal mSupervisionManagerInternal;\n\n    private final LockPatternUtils mLockPatternUtils;\n    private final LockSettingsInternal mLockSettingsInternal;\n    private final DeviceAdminServiceController mDeviceAdminServiceController;\n    private final OverlayPackagesProvider mOverlayPackagesProvider;\n\n    private final DevicePolicyCacheImpl mPolicyCache = new DevicePolicyCacheImpl();\n    private final DeviceStateCacheImpl mStateCache = new DeviceStateCacheImpl();\n    private final Object mESIDInitilizationLock = new Object();\n    private EnterpriseSpecificIdCalculator mEsidCalculator;\n    private final Object mSubscriptionsChangedListenerLock = new Object();\n    @GuardedBy(\"mSubscriptionsChangedListenerLock\")\n    private SubscriptionManager.OnSubscriptionsChangedListener mSubscriptionsChangedListener;\n\n    /**\n     * Contains the list of OEM Default Role Holders for Contact-related roles\n     * (DIALER, SMS, SYSTEM_CONTACTS)\n     */\n    private final Set<String> mContactSystemRoleHolders;\n\n    /**\n     * Contains (package-user) pairs to remove. An entry (p, u) implies that removal of package p\n     * is requested for user u.\n     */\n    private final Set<UserPackage> mPackagesToRemove = new ArraySet<>();\n\n    final LocalService mLocalService;\n\n    // Stores and loads state on device and profile owners.\n    @VisibleForTesting\n    final Owners mOwners;\n\n    private final Binder mToken = new Binder();\n\n    /**\n     * Whether or not device admin feature is supported. If it isn't return defaults for all\n     * public methods, unless the caller has the appropriate permission for a particular method.\n     */\n    final boolean mHasFeature;\n\n    /**\n     * Whether or not this device is a watch.\n     */\n    final boolean mIsWatch;\n\n    /**\n     * Whether or not this device is an automotive.\n     */\n    private final boolean mIsAutomotive;\n\n    /**\n     * Whether this device has the telephony feature.\n     */\n    final boolean mHasTelephonyFeature;\n\n    private final CertificateMonitor mCertificateMonitor;\n    private final SecurityLogMonitor mSecurityLogMonitor;\n    private final RemoteBugreportManager mBugreportCollectionManager;\n\n    @GuardedBy(\"getLockObject()\")\n    private NetworkLogger mNetworkLogger;\n\n    private final SetupContentObserver mSetupContentObserver;\n    private final DevicePolicyConstantsObserver mConstantsObserver;\n\n    private DevicePolicyConstants mConstants;\n\n    /**\n     * User to be switched to on {@code logoutUser()}.\n     *\n     * <p>Only used on devices with headless system user mode\n     */\n    @GuardedBy(\"getLockObject()\")\n    private @UserIdInt int mLogoutUserId = UserHandle.USER_NULL;\n\n    /**\n     * User the network logging notification was sent to.\n     */\n    // Guarded by mHandler\n    private @UserIdInt int mNetworkLoggingNotificationUserId = UserHandle.USER_NULL;\n\n    private final DeviceManagementResourcesProvider mDeviceManagementResourcesProvider;\n    private final DevicePolicyManagementRoleObserver mDevicePolicyManagementRoleObserver;\n\n    private final DevicePolicyEngine mDevicePolicyEngine;\n\n    private static final boolean ENABLE_LOCK_GUARD = true;\n\n    /**\n     * Profile off deadline is not set or more than MANAGED_PROFILE_OFF_WARNING_PERIOD away, or the\n     * user is running unlocked, no need for notification.\n     */\n    private static final int PROFILE_OFF_NOTIFICATION_NONE = 0;\n    /**\n     * Profile off deadline is closer than MANAGED_PROFILE_OFF_WARNING_PERIOD.\n     */\n    private static final int PROFILE_OFF_NOTIFICATION_WARNING = 1;\n    /**\n     * Profile off deadline reached, notify the user that personal apps blocked.\n     */\n    private static final int PROFILE_OFF_NOTIFICATION_SUSPENDED = 2;\n\n    interface Stats {\n        int LOCK_GUARD_GUARD = 0;\n\n        int COUNT = LOCK_GUARD_GUARD + 1;\n    }\n\n    private final StatLogger mStatLogger = new StatLogger(new String[] {\n            \"LockGuard.guard()\",\n    });\n\n    private final Object mLockDoNoUseDirectly = LockGuard.installNewLock(\n            LockGuard.INDEX_DPMS, /* doWtf=*/ true);\n\n    final Object getLockObject() {\n        if (ENABLE_LOCK_GUARD) {\n            final long start = mStatLogger.getTime();\n            LockGuard.guard(LockGuard.INDEX_DPMS);\n            mStatLogger.logDurationStat(Stats.LOCK_GUARD_GUARD, start);\n        }\n        return mLockDoNoUseDirectly;\n    }\n\n    /**\n     * Check if the current thread holds the DPMS lock, and if not, do a WTF.\n     *\n     * (Doing this check too much may be costly, so don't call it in a hot path.)\n     */\n    final void ensureLocked() {\n        if (Thread.holdsLock(mLockDoNoUseDirectly)) {\n            return;\n        }\n        Slogf.wtfStack(LOG_TAG, \"Not holding DPMS lock.\");\n    }\n\n    /**\n     * Calls wtfStack() if called with the DPMS lock held.\n     */\n    private void wtfIfInLock() {\n        if (Thread.holdsLock(mLockDoNoUseDirectly)) {\n            Slogf.wtfStack(LOG_TAG, \"Shouldn't be called with DPMS lock held\");\n        }\n    }\n\n    @VisibleForTesting\n    final TransferOwnershipMetadataManager mTransferOwnershipMetadataManager;\n\n    @Nullable\n    private DevicePolicySafetyChecker mSafetyChecker;\n\n    @GuardedBy(\"getLockObject()\")\n    private final ArrayList<Object> mPendingUserCreatedCallbackTokens = new ArrayList<>();\n\n    public static final class Lifecycle extends SystemService {\n        private DevicePolicyManagerService mService;\n\n        public Lifecycle(Context context) {\n            super(context);\n            String dpmsClassName = context.getResources()\n                    .getString(R.string.config_deviceSpecificDevicePolicyManagerService);\n            if (TextUtils.isEmpty(dpmsClassName)) {\n                mService = new DevicePolicyManagerService(context);\n            } else {\n                try {\n                    Class<?> serviceClass = Class.forName(dpmsClassName);\n                    Constructor<?> constructor = serviceClass.getConstructor(Context.class);\n                    mService = (DevicePolicyManagerService) constructor.newInstance(context);\n                } catch (Exception e) {\n                    throw new IllegalStateException(\n                        \"Failed to instantiate DevicePolicyManagerService with class name: \"\n                        + dpmsClassName, e);\n                }\n            }\n        }\n\n        /** Sets the {@link DevicePolicySafetyChecker}. */\n        public void setDevicePolicySafetyChecker(DevicePolicySafetyChecker safetyChecker) {\n            mService.setDevicePolicySafetyChecker(safetyChecker);\n        }\n\n        @Override\n        public void onStart() {\n            publishBinderService(Context.DEVICE_POLICY_SERVICE, mService);\n        }\n\n        @Override\n        public void onBootPhase(int phase) {\n            mService.systemReady(phase);\n        }\n\n        @Override\n        public void onUserStarting(@NonNull TargetUser user) {\n            if (user.isPreCreated()) return;\n            mService.handleStartUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserUnlocking(@NonNull TargetUser user) {\n            if (user.isPreCreated()) return;\n            mService.handleUnlockUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserStopping(@NonNull TargetUser user) {\n            if (user.isPreCreated()) return;\n            mService.handleStopUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserSwitching(@NonNull TargetUser from, @NonNull TargetUser to) {\n            if (to.isPreCreated()) return;\n            mService.handleOnUserSwitching(from.getUserIdentifier(), to.getUserIdentifier());\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    final SparseArray<DevicePolicyData> mUserData;\n\n    final Handler mHandler;\n    final Handler mBackgroundHandler;\n\n    /** Listens only if mHasFeature == true. */\n    final BroadcastReceiver mReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            final int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE,\n                    getSendingUserId());\n\n            /*\n             * Network logging would ideally be started in setDeviceOwnerSystemPropertyLocked(),\n             * however it's too early in the boot process to register with IIpConnectivityMetrics\n             * to listen for events.\n             */\n            if (Intent.ACTION_USER_STARTED.equals(action) && userHandle == UserHandle.USER_SYSTEM) {\n                synchronized (getLockObject()) {\n                    if (isNetworkLoggingEnabledInternalLocked()) {\n                        setNetworkLoggingActiveInternal(true);\n                    }\n                }\n            }\n\n            if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {\n                calculateHasIncompatibleAccounts();\n            }\n\n            if (Intent.ACTION_BOOT_COMPLETED.equals(action)\n                    && userHandle == mOwners.getDeviceOwnerUserId()) {\n                mBugreportCollectionManager.checkForPendingBugreportAfterBoot();\n\n            }\n            if (Intent.ACTION_BOOT_COMPLETED.equals(action)\n                    || ACTION_EXPIRED_PASSWORD_NOTIFICATION.equals(action)) {\n                if (VERBOSE_LOG) {\n                    Slogf.v(LOG_TAG, \"Sending password expiration notifications for action \"\n                            + action + \" for user \" + userHandle);\n                }\n                mHandler.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        handlePasswordExpirationNotification(userHandle);\n                    }\n                });\n            }\n\n            if (Intent.ACTION_USER_ADDED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_ADDED, userHandle);\n                synchronized (getLockObject()) {\n                    // It might take a while for the user to become affiliated. Make security\n                    // and network logging unavailable in the meantime.\n                    maybePauseDeviceWideLoggingLocked();\n                }\n            } else if (Intent.ACTION_USER_REMOVED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_REMOVED, userHandle);\n                synchronized (getLockObject()) {\n                    // Check whether the user is affiliated, *before* removing its data.\n                    boolean isRemovedUserAffiliated = isUserAffiliatedWithDeviceLocked(userHandle);\n                    removeUserData(userHandle);\n                    if (!isRemovedUserAffiliated) {\n                        // We discard the logs when unaffiliated users are deleted (so that the\n                        // device owner cannot retrieve data about that user after it's gone).\n                        discardDeviceWideLogsLocked();\n                        // Resume logging if all remaining users are affiliated.\n                        maybeResumeDeviceWideLoggingLocked();\n                    }\n                }\n                mDevicePolicyEngine.handleUserRemoved(userHandle);\n            } else if (Intent.ACTION_USER_STARTED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_STARTED, userHandle);\n                synchronized (getLockObject()) {\n                    maybeSendAdminEnabledBroadcastLocked(userHandle);\n                    // Reset the policy data\n                    mUserData.remove(userHandle);\n                }\n                handlePackagesChanged(null /* check all admins */, userHandle);\n                updatePersonalAppsSuspensionOnUserStart(userHandle);\n            } else if (Intent.ACTION_USER_STOPPED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_STOPPED, userHandle);\n                if (isManagedProfile(userHandle)) {\n                    Slogf.d(LOG_TAG, \"Managed profile was stopped\");\n                    updatePersonalAppsSuspension(userHandle);\n                }\n            } else if (Intent.ACTION_USER_SWITCHED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_SWITCHED, userHandle);\n            } else if (Intent.ACTION_USER_UNLOCKED.equals(action)) {\n                synchronized (getLockObject()) {\n                    maybeSendAdminEnabledBroadcastLocked(userHandle);\n                }\n                if (isManagedProfile(userHandle)) {\n                    Slogf.d(LOG_TAG, \"Managed profile became unlocked\");\n                    final boolean suspended = updatePersonalAppsSuspension(userHandle);\n                    triggerPolicyComplianceCheckIfNeeded(userHandle, suspended);\n                }\n            } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {\n                handlePackagesChanged(null /* check all admins */, userHandle);\n            } else if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {\n                handlePackagesChanged(intent.getData().getSchemeSpecificPart(), userHandle);\n            } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {\n                if (intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {\n                    handlePackagesChanged(intent.getData().getSchemeSpecificPart(), userHandle);\n                } else {\n                    handleNewPackageInstalled(intent.getData().getSchemeSpecificPart(), userHandle);\n                }\n            } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)\n                    && !intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {\n                handlePackagesChanged(intent.getData().getSchemeSpecificPart(), userHandle);\n                removeCredentialManagementApp(intent.getData().getSchemeSpecificPart());\n            } else if (Intent.ACTION_MANAGED_PROFILE_ADDED.equals(action)) {\n                clearWipeProfileNotification();\n            } else if (Intent.ACTION_DATE_CHANGED.equals(action)\n                    || Intent.ACTION_TIME_CHANGED.equals(action)) {\n                // Update freeze period record when clock naturally progresses to the next day\n                // (ACTION_DATE_CHANGED), or when manual clock adjustment is made\n                // (ACTION_TIME_CHANGED)\n                updateSystemUpdateFreezePeriodsRecord(/* saveIfChanged */ true);\n                final int userId = getManagedUserId(getMainUserId());\n                if (userId >= 0) {\n                    updatePersonalAppsSuspension(userId);\n                }\n            } else if (ACTION_PROFILE_OFF_DEADLINE.equals(action)) {\n                Slogf.i(LOG_TAG, \"Profile off deadline alarm was triggered\");\n                final int userId = getManagedUserId(getMainUserId());\n                if (userId >= 0) {\n                    updatePersonalAppsSuspension(userId);\n                } else {\n                    Slogf.wtf(LOG_TAG, \"Got deadline alarm for nonexistent profile\");\n                }\n            } else if (ACTION_TURN_PROFILE_ON_NOTIFICATION.equals(action)) {\n                Slogf.i(LOG_TAG, \"requesting to turn on the profile: \" + userHandle);\n                mUserManager.requestQuietModeEnabled(false, UserHandle.of(userHandle));\n            } else if (ACTION_MANAGED_PROFILE_UNAVAILABLE.equals(action)) {\n                notifyIfManagedSubscriptionsAreUnavailable(\n                        UserHandle.of(userHandle), /* managedProfileAvailable= */ false);\n                updatePersonalAppsSuspension(userHandle);\n            } else if (ACTION_MANAGED_PROFILE_AVAILABLE.equals(action)) {\n                notifyIfManagedSubscriptionsAreUnavailable(\n                        UserHandle.of(userHandle), /* managedProfileAvailable= */ true);\n                final boolean suspended = updatePersonalAppsSuspension(userHandle);\n                triggerPolicyComplianceCheckIfNeeded(userHandle, suspended);\n            } else if (LOGIN_ACCOUNTS_CHANGED_ACTION.equals(action)) {\n                calculateHasIncompatibleAccounts();\n            }\n        }\n\n        private void sendDeviceOwnerUserCommand(String action, int userHandle) {\n            synchronized (getLockObject()) {\n                ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n                if (deviceOwner != null) {\n                    Bundle extras = new Bundle();\n                    extras.putParcelable(Intent.EXTRA_USER, UserHandle.of(userHandle));\n                    sendAdminCommandLocked(deviceOwner, action, extras, /* result */ null,\n                            /* inForeground */ true);\n                }\n            }\n        }\n    };\n\n    protected static class RestrictionsListener implements UserRestrictionsListener {\n        private final Context mContext;\n        private final UserManagerInternal mUserManagerInternal;\n        private final DevicePolicyManagerService mDpms;\n\n        public RestrictionsListener(\n                Context context,\n                UserManagerInternal userManagerInternal,\n                DevicePolicyManagerService dpms) {\n            mContext = context;\n            mUserManagerInternal = userManagerInternal;\n            mDpms = dpms;\n        }\n\n        @Override\n        public void onUserRestrictionsChanged(int userId, Bundle newRestrictions,\n                Bundle prevRestrictions) {\n            resetCrossProfileIntentFiltersIfNeeded(userId, newRestrictions, prevRestrictions);\n            resetUserVpnIfNeeded(userId, newRestrictions, prevRestrictions);\n            removePrivateSpaceIfRestrictionIsSet(userId, newRestrictions, prevRestrictions);\n        }\n\n        private void resetUserVpnIfNeeded(\n                int userId, Bundle newRestrictions, Bundle prevRestrictions) {\n            final boolean newlyEnforced =\n                    !prevRestrictions.getBoolean(UserManager.DISALLOW_CONFIG_VPN)\n                    && newRestrictions.getBoolean(UserManager.DISALLOW_CONFIG_VPN);\n            if (newlyEnforced) {\n                mDpms.clearUserConfiguredVpns(userId);\n            }\n        }\n\n        private void resetCrossProfileIntentFiltersIfNeeded(\n                int userId, Bundle newRestrictions, Bundle prevRestrictions) {\n            if (UserRestrictionsUtils.restrictionsChanged(prevRestrictions, newRestrictions,\n                    UserManager.DISALLOW_SHARE_INTO_MANAGED_PROFILE)) {\n                final int parentId = mUserManagerInternal.getProfileParentId(userId);\n                if (parentId == userId) {\n                    return;\n                }\n\n                // Always reset filters on the parent user, which handles cross profile intent\n                // filters between the parent and its profiles.\n                Slogf.i(LOG_TAG, \"Resetting cross-profile intent filters on restriction \"\n                        + \"change\");\n                mDpms.resetDefaultCrossProfileIntentFilters(parentId);\n                mContext.sendBroadcastAsUser(\n                        new Intent(DevicePolicyManager.ACTION_DATA_SHARING_RESTRICTION_APPLIED),\n                        UserHandle.of(userId));\n            }\n        }\n        private void removePrivateSpaceIfRestrictionIsSet(\n                int userId, Bundle newRestrictions, Bundle prevRestrictions) {\n            final boolean newlyEnforced =\n                    !prevRestrictions.getBoolean(UserManager.DISALLOW_ADD_PRIVATE_PROFILE)\n                            && newRestrictions.getBoolean(UserManager.DISALLOW_ADD_PRIVATE_PROFILE);\n            if (!newlyEnforced) {\n                return;\n            }\n            mDpms.removePrivateSpaceWithinUserGroupIfExists(userId);\n        }\n\n    }\n\n    private void clearUserConfiguredVpns(int userId) {\n        final String adminConfiguredVpnPkg;\n        synchronized (getLockObject()) {\n            final ActiveAdmin owner = getDeviceOrProfileOwnerAdminLocked(userId);\n            if (owner == null) {\n                Slogf.wtf(LOG_TAG, \"Admin not found\");\n                return;\n            }\n            adminConfiguredVpnPkg = owner.mAlwaysOnVpnPackage;\n        }\n\n        // Clear always-on configuration if it wasn't set by the admin.\n        if (adminConfiguredVpnPkg == null) {\n            VpnManager vpnManager = mInjector.getVpnManager();\n            if (vpnManager != null) {\n                vpnManager.setAlwaysOnVpnPackageForUser(userId, null, false, null);\n            }\n        }\n\n        // Clear app authorizations to establish VPNs. When DISALLOW_CONFIG_VPN is enforced apps\n        // won't be able to get those authorizations unless it is configured by an admin.\n        final List<AppOpsManager.PackageOps> allVpnOps = mInjector.getAppOpsManager()\n                .getPackagesForOps(new int[] {AppOpsManager.OP_ACTIVATE_VPN});\n        if (allVpnOps == null) {\n            return;\n        }\n        for (AppOpsManager.PackageOps pkgOps : allVpnOps) {\n            if (UserHandle.getUserId(pkgOps.getUid()) != userId\n                    || pkgOps.getPackageName().equals(adminConfiguredVpnPkg)) {\n                continue;\n            }\n            if (pkgOps.getOps().size() != 1) {\n                Slogf.wtf(LOG_TAG, \"Unexpected number of ops returned\");\n                continue;\n            }\n            final @Mode int mode = pkgOps.getOps().get(0).getMode();\n            if (mode == MODE_ALLOWED) {\n                Slogf.i(LOG_TAG, String.format(\"Revoking VPN authorization for package %s uid %d\",\n                        pkgOps.getPackageName(), pkgOps.getUid()));\n                mInjector.getAppOpsManager().setMode(AppOpsManager.OP_ACTIVATE_VPN, pkgOps.getUid(),\n                        pkgOps.getPackageName(), MODE_DEFAULT);\n            }\n        }\n    }\n\n    /**\n     * Given a parent userId, try removing all private space profiles with its profile group, and\n     * post a notification if at least one private space profile is removed.\n     */\n    private void removePrivateSpaceWithinUserGroupIfExists(int userId) {\n        boolean removed = false;\n        if (mUserManager.isProfile(userId)) return;\n        for (int profileId : mUserManager.getProfileIdsWithDisabled(userId)) {\n            if (profileId == userId) continue;\n            if (mUserManager.getUserInfo(profileId).isPrivateProfile()) {\n                Slogf.i(LOG_TAG, \"Removing private space %d due to DISALLOW_ADD_PRIVATE_PROFILE\",\n                        profileId);\n                removed |= mUserManager.removeUserEvenWhenDisallowed(profileId);\n            }\n        }\n        if (removed) {\n            mHandler.post(() -> sendPrivateSpaceRemovedNotification(userId));\n        }\n    }\n\n    private void sendPrivateSpaceRemovedNotification(int parentUserId) {\n        String notification_details = mContext.getString(\n                R.string.private_space_deleted_by_admin_details);\n        Notification notification =\n                new Notification.Builder(mContext, SystemNotificationChannels.DEVICE_ADMIN)\n                        .setSmallIcon(android.R.drawable.stat_sys_warning)\n                        .setContentTitle(mContext.getString(\n                                R.string.private_space_deleted_by_admin))\n                        .setContentText(notification_details)\n                        .setColor(mContext.getColor(R.color.system_notification_accent_color))\n                        .setStyle(new Notification.BigTextStyle().bigText(notification_details))\n                        .build();\n        mInjector.getNotificationManager().notifyAsUser(/* tag= */ null,\n                SystemMessage.NOTE_PROFILE_WIPED, notification, UserHandle.of(parentUserId));\n    }\n\n    private final class UserLifecycleListener implements UserManagerInternal.UserLifecycleListener {\n\n        @Override\n        public void onUserCreated(UserInfo user, Object token) {\n            mHandler.post(() -> handleNewUserCreated(user, token));\n        }\n    }\n\n    private void handlePackagesChanged(@Nullable String packageName, int userHandle) {\n        boolean removedAdmin = false;\n        String removedAdminPackage = null;\n        if (VERBOSE_LOG) {\n            Slogf.d(LOG_TAG, \"Handling package changes package \" + packageName\n                    + \" for user \" + userHandle);\n        }\n        DevicePolicyData policy = getUserData(userHandle);\n        synchronized (getLockObject()) {\n            for (int i = policy.mAdminList.size() - 1; i >= 0; i--) {\n                ActiveAdmin aa = policy.mAdminList.get(i);\n                try {\n                    // If we're checking all packages or if the specific one we're checking matches,\n                    // then check if the package and receiver still exist.\n                    final String adminPackage = aa.info.getPackageName();\n                    if (packageName == null || packageName.equals(adminPackage)) {\n                        if (mIPackageManager.getPackageInfo(adminPackage, 0, userHandle) == null\n                                || mIPackageManager.getReceiverInfo(aa.info.getComponent(),\n                                MATCH_DIRECT_BOOT_AWARE\n                                        | MATCH_DIRECT_BOOT_UNAWARE,\n                                userHandle) == null) {\n                            Slogf.e(LOG_TAG, String.format(\n                                    \"Admin package %s not found for user %d, removing active admin\",\n                                    packageName, userHandle));\n                            removedAdmin = true;\n                            removedAdminPackage = adminPackage;\n                            policy.mAdminList.remove(i);\n                            policy.mAdminMap.remove(aa.info.getComponent());\n                            pushActiveAdminPackagesLocked(userHandle);\n                        }\n                    }\n                } catch (RemoteException re) {\n                    // Shouldn't happen.\n                    Slogf.wtf(LOG_TAG, \"Error handling package changes\", re);\n                }\n            }\n            if (removedAdmin) {\n                policy.validatePasswordOwner();\n            }\n\n            boolean removedDelegate = false;\n\n            // Check if a delegate was removed.\n            for (int i = policy.mDelegationMap.size() - 1; i >= 0; i--) {\n                final String delegatePackage = policy.mDelegationMap.keyAt(i);\n                if (isRemovedPackage(packageName, delegatePackage, userHandle)) {\n                    policy.mDelegationMap.removeAt(i);\n                    removedDelegate = true;\n                }\n            }\n\n            // If it's an owner package, we may need to refresh the bound connection.\n            final ComponentName owner = getOwnerComponent(userHandle);\n            if ((packageName != null) && (owner != null)\n                    && (owner.getPackageName().equals(packageName))) {\n                startOwnerService(userHandle, \"package-broadcast\");\n            }\n            mDevicePolicyEngine.handlePackageChanged(packageName, userHandle, removedAdminPackage);\n            // Persist updates if the removed package was an admin or delegate.\n            if (removedAdmin || removedDelegate) {\n                saveSettingsLocked(policy.mUserId);\n            }\n        }\n        if (removedAdmin) {\n            // The removed admin might have disabled camera, so update user restrictions.\n            pushMeteredDisabledPackages(userHandle);\n        }\n    }\n\n    private void removeCredentialManagementApp(String packageName) {\n        mBackgroundHandler.post(() -> {\n            try (KeyChainConnection connection = mInjector.keyChainBind()) {\n                IKeyChainService service = connection.getService();\n                if (service.hasCredentialManagementApp()\n                        && packageName.equals(service.getCredentialManagementAppPackageName())) {\n                    service.removeCredentialManagementApp();\n                }\n            } catch (RemoteException | InterruptedException | IllegalStateException\n                    | AssertionError e) {\n                Slogf.e(LOG_TAG, \"Unable to remove the credential management app\", e);\n            }\n        });\n    }\n\n    private boolean isRemovedPackage(String changedPackage, String targetPackage, int userHandle) {\n        try {\n            return targetPackage != null\n                    && (changedPackage == null || changedPackage.equals(targetPackage))\n                    && mIPackageManager.getPackageInfo(targetPackage, 0, userHandle) == null;\n        } catch (RemoteException e) {\n            // Shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Error checking isRemovedPackage\", e);\n        }\n\n        return false;\n    }\n\n    private void handleNewPackageInstalled(String packageName, int userHandle) {\n        // If personal apps were suspended by the admin, suspend the newly installed one.\n        if (!getUserData(userHandle).mAppsSuspended) {\n            return;\n        }\n        final String[] packagesToSuspend = { packageName };\n        // Check if package is considered not suspendable?\n        if (mInjector.getPackageManager(userHandle)\n                .getUnsuspendablePackages(packagesToSuspend).length != 0) {\n            Slogf.i(LOG_TAG, \"Newly installed package is unsuspendable: \" + packageName);\n            return;\n        }\n        mInjector.getPackageManagerInternal()\n                .setPackagesSuspendedByAdmin(userHandle, packagesToSuspend, true /*suspend*/);\n    }\n\n    public void setDevicePolicySafetyChecker(DevicePolicySafetyChecker safetyChecker) {\n        CallerIdentity callerIdentity = getCallerIdentity();\n        Preconditions.checkCallAuthorization(mIsAutomotive || isAdb(callerIdentity), \"can only set \"\n                + \"DevicePolicySafetyChecker on automotive builds or from ADB (but caller is %s)\",\n                callerIdentity);\n        setDevicePolicySafetyCheckerUnchecked(safetyChecker);\n    }\n\n    /**\n     * Used by {@code setDevicePolicySafetyChecker()} above and {@link OneTimeSafetyChecker}.\n     */\n    void setDevicePolicySafetyCheckerUnchecked(DevicePolicySafetyChecker safetyChecker) {\n        Slogf.i(LOG_TAG, \"Setting DevicePolicySafetyChecker as %s\", safetyChecker);\n        mSafetyChecker = safetyChecker;\n        mInjector.setDevicePolicySafetyChecker(safetyChecker);\n    }\n\n    /**\n     * Used by {@link OneTimeSafetyChecker} only.\n     */\n    DevicePolicySafetyChecker getDevicePolicySafetyChecker() {\n        return mSafetyChecker;\n    }\n\n    /**\n     * Checks if it's safe to execute the given {@code operation}.\n     *\n     * @throws UnsafeStateException if it's not safe to execute the operation.\n     */\n    private void checkCanExecuteOrThrowUnsafe(@DevicePolicyOperation int operation) {\n        int reason = getUnsafeOperationReason(operation);\n        if (reason == OPERATION_SAFETY_REASON_NONE) return;\n\n        if (mSafetyChecker == null) {\n            // Happens on CTS after it's set just once (by OneTimeSafetyChecker)\n            throw new UnsafeStateException(operation, reason);\n        }\n        // Let mSafetyChecker customize it (for example, by explaining how to retry)\n        throw mSafetyChecker.newUnsafeStateException(operation, reason);\n    }\n\n    /**\n     * Returns whether it's safe to execute the given {@code operation}, and why.\n     */\n    @OperationSafetyReason\n    int getUnsafeOperationReason(@DevicePolicyOperation int operation) {\n        return mSafetyChecker == null ? OPERATION_SAFETY_REASON_NONE\n                : mSafetyChecker.getUnsafeOperationReason(operation);\n    }\n\n    @Override\n    public void setNextOperationSafety(@DevicePolicyOperation int operation,\n            @OperationSafetyReason int reason) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n        Slogf.i(LOG_TAG, \"setNextOperationSafety(%s, %s)\",\n                DevicePolicyManager.operationToString(operation),\n                DevicePolicyManager.operationSafetyReasonToString(reason));\n        mSafetyChecker = new OneTimeSafetyChecker(this, operation, reason);\n    }\n\n    @Override\n    public boolean isSafeOperation(@OperationSafetyReason int reason) {\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"checking isSafeOperation(%s) using mSafetyChecker %s\",\n                    DevicePolicyManager.operationSafetyReasonToString(reason), mSafetyChecker);\n        }\n        return mSafetyChecker == null ? true : mSafetyChecker.isSafeOperation(reason);\n    }\n\n    // Used by DevicePolicyManagerServiceShellCommand\n    List<OwnerShellData> listAllOwners() {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            SparseArray<DevicePolicyData> userData;\n\n            // Gets the owners of \"full users\" first (device owner and profile owners)\n            List<OwnerShellData> owners = mOwners.listAllOwners();\n            synchronized (getLockObject()) {\n                for (int i = 0; i < owners.size(); i++) {\n                    OwnerShellData owner = owners.get(i);\n                    owner.isAffiliated = isUserAffiliatedWithDeviceLocked(owner.userId);\n                }\n                userData = mUserData;\n            }\n\n            // Then the owners of profile users (managed profiles)\n            for (int i = 0; i < userData.size(); i++) {\n                DevicePolicyData policyData = mUserData.valueAt(i);\n                int userId = userData.keyAt(i);\n                int parentUserId = mUserManagerInternal.getProfileParentId(userId);\n                boolean isProfile = parentUserId != userId;\n                if (!isProfile) continue;\n                for (int j = 0; j < policyData.mAdminList.size(); j++) {\n                    ActiveAdmin admin = policyData.mAdminList.get(j);\n                    OwnerShellData owner = OwnerShellData.forManagedProfileOwner(userId,\n                            parentUserId, admin.info.getComponent());\n                    owners.add(owner);\n                }\n            }\n\n            return owners;\n        });\n    }\n\n    /**\n     * Unit test will subclass it to inject mocks.\n     */\n    @VisibleForTesting\n    static class Injector {\n\n        public final Context mContext;\n\n        @Nullable private DevicePolicySafetyChecker mSafetyChecker;\n\n        Injector(Context context) {\n            mContext = context;\n        }\n\n        public boolean hasFeature() {\n            return getPackageManager().hasSystemFeature(PackageManager.FEATURE_DEVICE_ADMIN);\n        }\n\n        Context createContextAsUser(UserHandle user) throws NameNotFoundException {\n            final String packageName = mContext.getPackageName();\n            return mContext.createPackageContextAsUser(packageName, 0, user);\n        }\n\n        Resources getResources() {\n            return mContext.getResources();\n        }\n\n        UserManager getUserManager() {\n            return UserManager.get(mContext);\n        }\n\n        UserManagerInternal getUserManagerInternal() {\n            return LocalServices.getService(UserManagerInternal.class);\n        }\n\n        PackageManagerInternal getPackageManagerInternal() {\n            return LocalServices.getService(PackageManagerInternal.class);\n        }\n\n        PackageManagerLocal getPackageManagerLocal() {\n            return LocalManagerRegistry.getManager(PackageManagerLocal.class);\n        }\n\n        ActivityTaskManagerInternal getActivityTaskManagerInternal() {\n            return LocalServices.getService(ActivityTaskManagerInternal.class);\n        }\n\n        @NonNull PermissionControllerManager getPermissionControllerManager(\n                @NonNull UserHandle user) {\n            if (user.equals(mContext.getUser())) {\n                return mContext.getSystemService(PermissionControllerManager.class);\n            } else {\n                try {\n                    return mContext.createPackageContextAsUser(mContext.getPackageName(), 0,\n                            user).getSystemService(PermissionControllerManager.class);\n                } catch (NameNotFoundException notPossible) {\n                    // not possible\n                    throw new IllegalStateException(notPossible);\n                }\n            }\n        }\n\n        UsageStatsManagerInternal getUsageStatsManagerInternal() {\n            return LocalServices.getService(UsageStatsManagerInternal.class);\n        }\n\n        NetworkPolicyManagerInternal getNetworkPolicyManagerInternal() {\n            return LocalServices.getService(NetworkPolicyManagerInternal.class);\n        }\n\n        NotificationManager getNotificationManager() {\n            return mContext.getSystemService(NotificationManager.class);\n        }\n\n        IIpConnectivityMetrics getIIpConnectivityMetrics() {\n            return (IIpConnectivityMetrics) IIpConnectivityMetrics.Stub.asInterface(\n                ServiceManager.getService(IpConnectivityLog.SERVICE_NAME));\n        }\n\n        PackageManager getPackageManager() {\n            return mContext.getPackageManager();\n        }\n\n        PackageManager getPackageManager(int userId) {\n            try {\n                return createContextAsUser(UserHandle.of(userId)).getPackageManager();\n            } catch (NameNotFoundException e) {\n                throw new IllegalStateException(e);\n            }\n        }\n\n        PowerManagerInternal getPowerManagerInternal() {\n            return LocalServices.getService(PowerManagerInternal.class);\n        }\n\n        TelephonyManager getTelephonyManager() {\n            return mContext.getSystemService(TelephonyManager.class);\n        }\n\n        RoleManager getRoleManager() {\n            return mContext.getSystemService(RoleManager.class);\n        }\n\n        TrustManager getTrustManager() {\n            return (TrustManager) mContext.getSystemService(Context.TRUST_SERVICE);\n        }\n\n        AlarmManager getAlarmManager() {\n            return mContext.getSystemService(AlarmManager.class);\n        }\n\n        AlarmManagerInternal getAlarmManagerInternal() {\n            return LocalServices.getService(AlarmManagerInternal.class);\n        }\n\n        ConnectivityManager getConnectivityManager() {\n            return mContext.getSystemService(ConnectivityManager.class);\n        }\n\n        @Nullable\n        VpnManager getVpnManager() {\n            return mContext.getSystemService(VpnManager.class);\n        }\n\n        LocationManager getLocationManager() {\n            return mContext.getSystemService(LocationManager.class);\n        }\n\n        IWindowManager getIWindowManager() {\n            return IWindowManager.Stub\n                    .asInterface(ServiceManager.getService(Context.WINDOW_SERVICE));\n        }\n\n        IActivityManager getIActivityManager() {\n            return ActivityManager.getService();\n        }\n\n        IActivityTaskManager getIActivityTaskManager() {\n            return ActivityTaskManager.getService();\n        }\n\n        ActivityManagerInternal getActivityManagerInternal() {\n            return LocalServices.getService(ActivityManagerInternal.class);\n        }\n\n        IPackageManager getIPackageManager() {\n            return AppGlobals.getPackageManager();\n        }\n\n        IPermissionManager getIPermissionManager() {\n            return AppGlobals.getPermissionManager();\n        }\n\n        IBackupManager getIBackupManager() {\n            return IBackupManager.Stub.asInterface(\n                    ServiceManager.getService(Context.BACKUP_SERVICE));\n        }\n\n        PersistentDataBlockManagerInternal getPersistentDataBlockManagerInternal() {\n            return LocalServices.getService(PersistentDataBlockManagerInternal.class);\n        }\n\n        AppOpsManager getAppOpsManager() {\n            return mContext.getSystemService(AppOpsManager.class);\n        }\n\n        LockSettingsInternal getLockSettingsInternal() {\n            return LocalServices.getService(LockSettingsInternal.class);\n        }\n\n        CrossProfileApps getCrossProfileApps(@UserIdInt int userId) {\n            return mContext.createContextAsUser(UserHandle.of(userId), /* flags= */ 0)\n                    .getSystemService(CrossProfileApps.class);\n        }\n\n        boolean hasUserSetupCompleted(DevicePolicyData userData) {\n            return userData.mUserSetupComplete;\n        }\n\n        boolean isBuildDebuggable() {\n            return Build.IS_DEBUGGABLE;\n        }\n\n        LockPatternUtils newLockPatternUtils() {\n            return new LockPatternUtils(mContext);\n        }\n\n        EnterpriseSpecificIdCalculator newEnterpriseSpecificIdCalculator() {\n            return new EnterpriseSpecificIdCalculator(mContext);\n        }\n\n        boolean storageManagerIsFileBasedEncryptionEnabled() {\n            return StorageManager.isFileEncrypted();\n        }\n\n        Looper getMyLooper() {\n            return Looper.myLooper();\n        }\n\n        WifiManager getWifiManager() {\n            return mContext.getSystemService(WifiManager.class);\n        }\n\n        UsbManager getUsbManager() {\n            return mContext.getSystemService(UsbManager.class);\n        }\n\n        @SuppressWarnings(\"ResultOfClearIdentityCallNotStoredInVariable\")\n        long binderClearCallingIdentity() {\n            return Binder.clearCallingIdentity();\n        }\n\n        void binderRestoreCallingIdentity(long token) {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        int binderGetCallingUid() {\n            return Binder.getCallingUid();\n        }\n\n        int binderGetCallingPid() {\n            return Binder.getCallingPid();\n        }\n\n        UserHandle binderGetCallingUserHandle() {\n            return Binder.getCallingUserHandle();\n        }\n\n        boolean binderIsCallingUidMyUid() {\n            return getCallingUid() == Process.myUid();\n        }\n\n        void binderWithCleanCallingIdentity(@NonNull ThrowingRunnable action) {\n             Binder.withCleanCallingIdentity(action);\n        }\n\n        final <T> T binderWithCleanCallingIdentity(@NonNull ThrowingSupplier<T> action) {\n            return Binder.withCleanCallingIdentity(action);\n        }\n\n        final int userHandleGetCallingUserId() {\n            return UserHandle.getUserId(binderGetCallingUid());\n        }\n\n        void powerManagerGoToSleep(long time, int reason, int flags) {\n            mContext.getSystemService(PowerManager.class).goToSleep(time, reason, flags);\n        }\n\n        void powerManagerReboot(String reason) {\n            mContext.getSystemService(PowerManager.class).reboot(reason);\n        }\n\n        boolean recoverySystemRebootWipeUserData(boolean shutdown, String reason, boolean force,\n                boolean wipeEuicc, boolean wipeExtRequested, boolean wipeResetProtectionData)\n                        throws IOException {\n            return FactoryResetter.newBuilder(mContext).setSafetyChecker(mSafetyChecker)\n                    .setReason(reason).setShutdown(shutdown).setForce(force).setWipeEuicc(wipeEuicc)\n                    .setWipeAdoptableStorage(wipeExtRequested)\n                    .setWipeFactoryResetProtection(wipeResetProtectionData)\n                    .build().factoryReset();\n        }\n\n        boolean systemPropertiesGetBoolean(String key, boolean def) {\n            return SystemProperties.getBoolean(key, def);\n        }\n\n        long systemPropertiesGetLong(String key, long def) {\n            return SystemProperties.getLong(key, def);\n        }\n\n        String systemPropertiesGet(String key, String def) {\n            return SystemProperties.get(key, def);\n        }\n\n        String systemPropertiesGet(String key) {\n            return SystemProperties.get(key);\n        }\n\n        void systemPropertiesSet(String key, String value) {\n            SystemProperties.set(key, value);\n        }\n\n        boolean userManagerIsHeadlessSystemUserMode() {\n            return UserManager.isHeadlessSystemUserMode();\n        }\n\n        List<String> roleManagerGetRoleHoldersAsUser(String role, UserHandle userHandle) {\n            return getRoleManager().getRoleHoldersAsUser(role, userHandle);\n        }\n\n        @SuppressWarnings(\"AndroidFrameworkPendingIntentMutability\")\n        PendingIntent pendingIntentGetActivityAsUser(Context context, int requestCode,\n                @NonNull Intent intent, int flags, Bundle options, UserHandle user) {\n            return PendingIntent.getActivityAsUser(\n                    context, requestCode, intent, flags, options, user);\n        }\n\n        @SuppressWarnings(\"AndroidFrameworkPendingIntentMutability\")\n        PendingIntent pendingIntentGetBroadcast(\n                Context context, int requestCode, Intent intent, int flags) {\n            return PendingIntent.getBroadcast(context, requestCode, intent, flags);\n        }\n\n        void registerContentObserver(Uri uri, boolean notifyForDescendents,\n                ContentObserver observer, int userHandle) {\n            mContext.getContentResolver().registerContentObserver(uri, notifyForDescendents,\n                    observer, userHandle);\n        }\n\n        int settingsSecureGetIntForUser(String name, int def, int userHandle) {\n            return Settings.Secure.getIntForUser(mContext.getContentResolver(),\n                    name, def, userHandle);\n        }\n\n        String settingsSecureGetStringForUser(String name, int userHandle) {\n            return Settings.Secure.getStringForUser(mContext.getContentResolver(), name,\n                    userHandle);\n        }\n\n        void settingsSecurePutIntForUser(String name, int value, int userHandle) {\n            Settings.Secure.putIntForUser(mContext.getContentResolver(),\n                    name, value, userHandle);\n        }\n\n        void settingsSecurePutStringForUser(String name, String value, int userHandle) {\n            Settings.Secure.putStringForUser(mContext.getContentResolver(),\n                    name, value, userHandle);\n        }\n\n        void settingsGlobalPutStringForUser(String name, String value, int userHandle) {\n            Global.putStringForUser(mContext.getContentResolver(),\n                    name, value, userHandle);\n        }\n\n        int settingsGlobalGetInt(String name, int def) {\n            return Global.getInt(mContext.getContentResolver(), name, def);\n        }\n\n        @Nullable\n        String settingsGlobalGetString(String name) {\n            return Global.getString(mContext.getContentResolver(), name);\n        }\n\n        void settingsGlobalPutInt(String name, int value) {\n            Global.putInt(mContext.getContentResolver(), name, value);\n        }\n\n        void settingsGlobalPutString(String name, String value) {\n            Global.putString(mContext.getContentResolver(), name, value);\n        }\n\n        void settingsSystemPutStringForUser(String name, String value, int userId) {\n          Settings.System.putStringForUser(\n              mContext.getContentResolver(), name, value, userId);\n        }\n\n        void securityLogSetLoggingEnabledProperty(boolean enabled) {\n            SecurityLog.setLoggingEnabledProperty(enabled);\n        }\n\n        boolean securityLogGetLoggingEnabledProperty() {\n            return SecurityLog.getLoggingEnabledProperty();\n        }\n\n        boolean securityLogIsLoggingEnabled() {\n            return SecurityLog.isLoggingEnabled();\n        }\n\n        KeyChainConnection keyChainBind() throws InterruptedException {\n            return KeyChain.bind(mContext);\n        }\n\n        KeyChainConnection keyChainBindAsUser(UserHandle user) throws InterruptedException {\n            return KeyChain.bindAsUser(mContext, user);\n        }\n\n        void postOnSystemServerInitThreadPool(Runnable runnable) {\n            SystemServerInitThreadPool.submit(runnable, LOG_TAG);\n        }\n\n        public TransferOwnershipMetadataManager newTransferOwnershipMetadataManager() {\n            return new TransferOwnershipMetadataManager();\n        }\n\n        public void runCryptoSelfTest() {\n            CryptoTestHelper.runAndLogSelfTest();\n        }\n\n        public long systemCurrentTimeMillis() {\n            return System.currentTimeMillis();\n        }\n\n        public boolean isChangeEnabled(long changeId, String packageName, int userId) {\n            return CompatChanges.isChangeEnabled(changeId, packageName, UserHandle.of(userId));\n        }\n\n        void setDevicePolicySafetyChecker(DevicePolicySafetyChecker safetyChecker) {\n            mSafetyChecker = safetyChecker;\n        }\n\n        DeviceManagementResourcesProvider getDeviceManagementResourcesProvider() {\n            return new DeviceManagementResourcesProvider();\n        }\n\n        boolean isAdminInstalledCaCertAutoApproved() {\n            return false;\n        }\n\n        @Nullable\n        SupervisionManagerInternal getSupervisionManager() {\n            return LocalServices.getService(SupervisionManagerInternal.class);\n        }\n    }\n\n    /**\n     * Instantiates the service.\n     */\n    public DevicePolicyManagerService(Context context) {\n        this(new Injector(\n                context.createAttributionContext(ATTRIBUTION_TAG)), new PolicyPathProvider() {});\n    }\n\n    @VisibleForTesting\n    DevicePolicyManagerService(Injector injector, PolicyPathProvider pathProvider) {\n        DevicePolicyManager.disableLocalCaches();\n\n        mInjector = injector;\n        mPathProvider = pathProvider;\n        mContext = Objects.requireNonNull(injector.mContext);\n        mHandler = new Handler(Objects.requireNonNull(injector.getMyLooper()));\n\n        mConstantsObserver = new DevicePolicyConstantsObserver(mHandler);\n        mConstantsObserver.register();\n        mConstants = loadConstants();\n\n        mUserManager = Objects.requireNonNull(injector.getUserManager());\n        mUserManagerInternal = Objects.requireNonNull(injector.getUserManagerInternal());\n        mUsageStatsManagerInternal = Objects.requireNonNull(\n                injector.getUsageStatsManagerInternal());\n        mIPackageManager = Objects.requireNonNull(injector.getIPackageManager());\n        mIPermissionManager = Objects.requireNonNull(injector.getIPermissionManager());\n        mTelephonyManager = Objects.requireNonNull(injector.getTelephonyManager());\n        mRoleManager = Objects.requireNonNull(injector.getRoleManager());\n        if (Flags.secondaryLockscreenApiEnabled()) {\n            mSupervisionManagerInternal = injector.getSupervisionManager();\n        } else {\n            mSupervisionManagerInternal = null;\n        }\n\n        mLocalService = new LocalService();\n        mLockPatternUtils = injector.newLockPatternUtils();\n        mLockSettingsInternal = injector.getLockSettingsInternal();\n        // TODO: why does SecurityLogMonitor need to be created even when mHasFeature == false?\n        mSecurityLogMonitor = new SecurityLogMonitor(this, mHandler);\n\n        mHasFeature = mInjector.hasFeature();\n        mIsWatch = mInjector.getPackageManager()\n                .hasSystemFeature(PackageManager.FEATURE_WATCH);\n        mHasTelephonyFeature = mInjector.getPackageManager()\n                .hasSystemFeature(PackageManager.FEATURE_TELEPHONY);\n        mIsAutomotive = mInjector.getPackageManager()\n                .hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);\n        mBackgroundHandler = BackgroundThread.getHandler();\n\n        // Needed when mHasFeature == false, because it controls the certificate warning text.\n        mCertificateMonitor = new CertificateMonitor(this, mInjector, mBackgroundHandler);\n\n        mDeviceAdminServiceController = new DeviceAdminServiceController(this, mConstants);\n        mOverlayPackagesProvider = new OverlayPackagesProvider(mContext);\n        mTransferOwnershipMetadataManager = mInjector.newTransferOwnershipMetadataManager();\n        mBugreportCollectionManager = new RemoteBugreportManager(this, mInjector);\n\n        mDeviceManagementResourcesProvider = mInjector.getDeviceManagementResourcesProvider();\n        mDevicePolicyManagementRoleObserver = new DevicePolicyManagementRoleObserver(mContext);\n        mDevicePolicyManagementRoleObserver.register();\n\n        // \"Lite\" interface is available even when the device doesn't have the feature\n        LocalServices.addService(DevicePolicyManagerLiteInternal.class, mLocalService);\n\n        // Policy version upgrade must not depend on either mOwners or mUserData, so they are\n        // initialized only after performing the upgrade.\n        if (mHasFeature) {\n            performPolicyVersionUpgrade();\n        }\n\n        mUserData = new SparseArray<>();\n        mOwners = makeOwners(injector, pathProvider);\n\n        mDevicePolicyEngine = new DevicePolicyEngine(\n                mContext, mDeviceAdminServiceController, getLockObject());\n\n        if (!mHasFeature) {\n            // Skip the rest of the initialization\n            mSetupContentObserver = null;\n            mContactSystemRoleHolders = Collections.emptySet();\n            return;\n        }\n\n        loadOwners();\n\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(Intent.ACTION_BOOT_COMPLETED);\n        filter.addAction(ACTION_EXPIRED_PASSWORD_NOTIFICATION);\n        filter.addAction(ACTION_TURN_PROFILE_ON_NOTIFICATION);\n        filter.addAction(ACTION_PROFILE_OFF_DEADLINE);\n        filter.addAction(Intent.ACTION_USER_ADDED);\n        filter.addAction(Intent.ACTION_USER_REMOVED);\n        filter.addAction(Intent.ACTION_USER_STARTED);\n        filter.addAction(Intent.ACTION_USER_STOPPED);\n        filter.addAction(Intent.ACTION_USER_SWITCHED);\n        filter.addAction(Intent.ACTION_USER_UNLOCKED);\n        filter.addAction(LOGIN_ACCOUNTS_CHANGED_ACTION);\n        filter.addAction(ACTION_MANAGED_PROFILE_UNAVAILABLE);\n        filter.addAction(ACTION_MANAGED_PROFILE_AVAILABLE);\n        filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);\n        mContext.registerReceiverAsUser(mReceiver, UserHandle.ALL, filter, null, mHandler);\n        filter = new IntentFilter();\n        filter.addAction(Intent.ACTION_PACKAGE_CHANGED);\n        filter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        filter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);\n        filter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        filter.addDataScheme(\"package\");\n        mContext.registerReceiverAsUser(mReceiver, UserHandle.ALL, filter, null, mHandler);\n        filter = new IntentFilter();\n        filter.addAction(Intent.ACTION_MANAGED_PROFILE_ADDED);\n        filter.addAction(Intent.ACTION_TIME_CHANGED);\n        filter.addAction(Intent.ACTION_DATE_CHANGED);\n        mContext.registerReceiverAsUser(mReceiver, UserHandle.ALL, filter, null, mHandler);\n\n        LocalServices.addService(DevicePolicyManagerInternal.class, mLocalService);\n\n        mSetupContentObserver = new SetupContentObserver(mHandler);\n\n        mUserManagerInternal.addUserRestrictionsListener(\n                new RestrictionsListener(mContext, mUserManagerInternal, this));\n        mUserManagerInternal.addUserLifecycleListener(new UserLifecycleListener());\n\n        mDeviceManagementResourcesProvider.load();\n        mDevicePolicyEngine.load();\n\n        mContactSystemRoleHolders = fetchOemSystemHolders(/* roleResIds...= */\n                R.string.config_defaultSms,\n                R.string.config_defaultDialer,\n                R.string.config_systemContacts\n        );\n\n        // The binder caches are not enabled until the first invalidation.\n        invalidateBinderCaches();\n    }\n\n    /**\n     * Fetch the OEM System Holders for the supplied roleNames\n     *\n     * @param roleResIds the list of resource ids whose role holders are needed\n     * @return the set of packageNames that handle the requested roles\n     */\n    private @NonNull Set<String> fetchOemSystemHolders(int... roleResIds) {\n        Set<String> packageNames = new ArraySet<>();\n\n        for (int roleResId : roleResIds) {\n            String packageName = getDefaultRoleHolderPackageName(roleResId);\n            if (packageName != null) {\n                packageNames.add(packageName);\n            }\n        }\n\n        return Collections.unmodifiableSet(packageNames);\n    }\n\n    private @Nullable String getDefaultRoleHolderPackageName(int resId) {\n        String packageNameAndSignature = mContext.getString(resId);\n\n        if (TextUtils.isEmpty(packageNameAndSignature)) {\n            return null;\n        }\n\n        if (packageNameAndSignature.contains(\":\")) {\n            return packageNameAndSignature.split(\":\")[0];\n        }\n\n        return packageNameAndSignature;\n    }\n\n    private Owners makeOwners(Injector injector, PolicyPathProvider pathProvider) {\n        return new Owners(\n                injector.getUserManager(), injector.getUserManagerInternal(),\n                injector.getPackageManagerInternal(),\n                injector.getActivityTaskManagerInternal(),\n                injector.getActivityManagerInternal(), mStateCache, pathProvider);\n    }\n\n    /**\n     * Invalidate the binder API caches. The invalidation itself does not require any\n     * locking, but this specific call should be protected by getLockObject() to ensure\n     * that the invalidation is synchronous with cached queries, for those queries that\n     * are served under getLockObject().\n     */\n    static void invalidateBinderCaches() {\n        DevicePolicyManager.invalidateBinderCaches();\n    }\n\n    /**\n     * Creates and loads the policy data from xml.\n     * @param userHandle the user for whom to load the policy data\n     * @return\n     */\n    @NonNull\n    DevicePolicyData getUserData(int userHandle) {\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = mUserData.get(userHandle);\n            if (policy == null) {\n                policy = new DevicePolicyData(userHandle);\n                mUserData.append(userHandle, policy);\n                loadSettingsLocked(policy, userHandle);\n                if (userHandle == UserHandle.USER_SYSTEM) {\n                    mStateCache.setDeviceProvisioned(policy.mUserSetupComplete);\n                }\n            }\n            return policy;\n        }\n    }\n\n    /**\n     * Creates and loads the policy data from xml for data that is shared between\n     * various profiles of a user. In contrast to {@link #getUserData(int)}\n     * it allows access to data of users other than the calling user.\n     *\n     * This function should only be used for shared data, e.g. everything regarding\n     * passwords and should be removed once multiple screen locks are present.\n     * @param userHandle the user for whom to load the policy data\n     * @return\n     */\n    DevicePolicyData getUserDataUnchecked(int userHandle) {\n        return mInjector.binderWithCleanCallingIdentity(() -> getUserData(userHandle));\n    }\n\n    void removeUserData(int userHandle) {\n        final boolean isOrgOwned;\n        synchronized (getLockObject()) {\n            if (userHandle == UserHandle.USER_SYSTEM) {\n                Slogf.w(LOG_TAG, \"Tried to remove device policy file for user 0! Ignoring.\");\n                return;\n            }\n            updatePasswordQualityCacheForUserGroup(userHandle);\n            mPolicyCache.onUserRemoved(userHandle);\n\n            if (isManagedProfile(userHandle)) {\n                clearManagedProfileApnUnchecked();\n            }\n            isOrgOwned = mOwners.isProfileOwnerOfOrganizationOwnedDevice(userHandle);\n\n            // Clear any restrictions set by the a profile owner and the parent admin.\n            final ActiveAdmin admin = getProfileOwnerLocked(userHandle);\n            if (admin != null) {\n                admin.userRestrictions = null;\n                final ActiveAdmin parentAdmin = admin.getParentActiveAdmin();\n                if (parentAdmin != null) {\n                    parentAdmin.userRestrictions = null;\n                }\n            }\n            mOwners.removeProfileOwner(userHandle);\n            mOwners.writeProfileOwner(userHandle);\n\n            DevicePolicyData policy = mUserData.get(userHandle);\n            if (policy != null) {\n                mUserData.remove(userHandle);\n            }\n\n            File policyFile =\n                    new File(mPathProvider.getUserSystemDirectory(userHandle), DEVICE_POLICIES_XML);\n            policyFile.delete();\n            Slogf.i(LOG_TAG, \"Removed device policy file \" + policyFile.getAbsolutePath());\n        }\n        if (isOrgOwned) {\n            final UserInfo primaryUser = mUserManager.getPrimaryUser();\n            if (primaryUser != null) {\n                clearOrgOwnedProfileOwnerDeviceWidePolicies(primaryUser.id);\n            } else {\n                Slogf.wtf(LOG_TAG, \"Was unable to get primary user.\");\n            }\n        }\n    }\n\n    /**\n     * Load information about device and profile owners of the device, populating mOwners and\n     * pushing owner info to other system services. This is called at a fairly early stage of\n     * system server initialiation (via DevicePolicyManagerService's ctor), so care should to\n     * be taken to not interact with system services that are initialiated after DPMS.\n     * onLockSettingsReady() is a safer place to do initialization work not critical during\n     * the first boot stage.\n     * Note this only loads the list of owners, and not their actual policy (DevicePolicyData).\n     * The policy is normally loaded lazily when it's first accessed. In several occasions\n     * the list of owners is necessary for providing callers with aggregated policies across\n     * multiple owners, hence the owner list is loaded as part of DPMS's construction here.\n     */\n    void loadOwners() {\n        synchronized (getLockObject()) {\n            mOwners.load();\n            if (mOwners.hasDeviceOwner()) {\n                setGlobalSettingDeviceOwnerType(\n                        mOwners.getDeviceOwnerType(mOwners.getDeviceOwnerPackageName()));\n            }\n        }\n    }\n\n    /**\n     * Creates a new {@link CallerIdentity} object to represent the caller's identity.\n     */\n    private CallerIdentity getCallerIdentity() {\n        return getCallerIdentity(null, null);\n    }\n\n    /**\n     * Creates a new {@link CallerIdentity} object to represent the caller's identity.\n     */\n    private CallerIdentity getCallerIdentity(@Nullable String callerPackage) {\n        return getCallerIdentity(null, callerPackage);\n    }\n\n    /**\n     * Creates a new {@link CallerIdentity} object to represent the caller's identity.\n     * The component name should be an active admin for the calling user.\n     */\n    @VisibleForTesting\n    CallerIdentity getCallerIdentity(@Nullable ComponentName adminComponent) {\n        return getCallerIdentity(adminComponent, null);\n    }\n\n    /**\n     * Creates a new {@link CallerIdentity} object to represent the caller's identity.\n     * If {@code adminComponent} is provided, it's validated against the list of known\n     * active admins and caller uid. If {@code callerPackage} is provided, it's validated\n     * against the caller uid. If a valid {@code adminComponent} is provided but not\n     * {@code callerPackage}, the package name of the {@code adminComponent} is used instead.\n     */\n    @VisibleForTesting\n    CallerIdentity getCallerIdentity(@Nullable ComponentName adminComponent,\n            @Nullable String callerPackage) {\n        final int callerUid = mInjector.binderGetCallingUid();\n\n        if (callerPackage != null) {\n            if (!isCallingFromPackage(callerPackage, callerUid)) {\n                throw new SecurityException(\n                        String.format(\"Caller with uid %d is not %s\", callerUid, callerPackage));\n            }\n        }\n\n        if (adminComponent != null) {\n            final DevicePolicyData policy = getUserData(UserHandle.getUserId(callerUid));\n            ActiveAdmin admin = policy.mAdminMap.get(adminComponent);\n\n            // Throwing combined exception message for both the cases here, because from different\n            // security exceptions it could be deduced if particular package is admin package.\n            if (admin == null || admin.getUid() != callerUid) {\n                throw new SecurityException(String.format(\n                        \"Admin %s does not exist or is not owned by uid %d\", adminComponent,\n                        callerUid));\n            }\n            if (callerPackage != null) {\n                Preconditions.checkArgument(callerPackage.equals(adminComponent.getPackageName()));\n            } else {\n                callerPackage = adminComponent.getPackageName();\n            }\n        }\n\n        return new CallerIdentity(callerUid, callerPackage, adminComponent);\n    }\n\n    /**\n     * Checks if the device is in COMP mode, and if so migrates it to managed profile on a\n     * corporate owned device.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void migrateToProfileOnOrganizationOwnedDeviceIfCompLocked() {\n        if (VERBOSE_LOG) Slogf.d(LOG_TAG, \"Checking whether we need to migrate COMP \");\n        final int doUserId = mOwners.getDeviceOwnerUserId();\n        if (doUserId == UserHandle.USER_NULL) {\n            if (VERBOSE_LOG) Slogf.d(LOG_TAG, \"No DO found, skipping migration.\");\n            return;\n        }\n\n        final List<UserInfo> profiles = mUserManager.getProfiles(doUserId);\n        if (profiles.size() != 2) {\n            if (profiles.size() == 1) {\n                if (VERBOSE_LOG) Slogf.d(LOG_TAG, \"Profile not found, skipping migration.\");\n            } else {\n                Slogf.wtf(LOG_TAG, \"Found \" + profiles.size() + \" profiles, skipping migration\");\n            }\n            return;\n        }\n\n        final int poUserId = getManagedUserId(doUserId);\n        if (poUserId < 0) {\n            Slogf.wtf(LOG_TAG, \"Found DO and a profile, but it is not managed, skipping migration\");\n            return;\n        }\n\n        final ActiveAdmin doAdmin = getDeviceOwnerAdminLocked();\n        final ActiveAdmin poAdmin = getProfileOwnerAdminLocked(poUserId);\n        if (doAdmin == null || poAdmin == null) {\n            Slogf.wtf(LOG_TAG, \"Failed to get either PO or DO admin, aborting migration.\");\n            return;\n        }\n\n        final ComponentName doAdminComponent = mOwners.getDeviceOwnerComponent();\n        final ComponentName poAdminComponent = mOwners.getProfileOwnerComponent(poUserId);\n        if (doAdminComponent == null || poAdminComponent == null) {\n            Slogf.wtf(LOG_TAG, \"Cannot find PO or DO component name, aborting migration.\");\n            return;\n        }\n        if (!doAdminComponent.getPackageName().equals(poAdminComponent.getPackageName())) {\n            Slogf.e(LOG_TAG, \"DO and PO are different packages, aborting migration.\");\n            return;\n        }\n\n        Slogf.i(LOG_TAG, \"Migrating COMP to PO on a corp owned device; primary user: %d; \"\n                + \"profile: %d\", doUserId, poUserId);\n\n        Slogf.i(LOG_TAG, \"Giving the PO additional power...\");\n        setProfileOwnerOnOrganizationOwnedDeviceUncheckedLocked(poAdminComponent, poUserId, true);\n        Slogf.i(LOG_TAG, \"Migrating DO policies to PO...\");\n        moveDoPoliciesToProfileParentAdminLocked(doAdmin, poAdmin.getParentActiveAdmin());\n        migratePersonalAppSuspensionLocked(doUserId, poUserId, poAdmin);\n        saveSettingsLocked(poUserId);\n        Slogf.i(LOG_TAG, \"Clearing the DO...\");\n        final ComponentName doAdminReceiver = doAdmin.info.getComponent();\n        clearDeviceOwnerLocked(doAdmin, doUserId);\n        Slogf.i(LOG_TAG, \"Removing admin artifacts...\");\n        removeAdminArtifacts(doAdminReceiver, doUserId);\n        Slogf.i(LOG_TAG, \"Uninstalling the DO...\");\n        uninstallOrDisablePackage(doAdminComponent.getPackageName(), doUserId);\n        Slogf.i(LOG_TAG, \"Migration complete.\");\n\n        // Note: KeyChain keys are not removed and will remain accessible for the apps that have\n        // been given grants to use them.\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.COMP_TO_ORG_OWNED_PO_MIGRATED)\n                .setAdmin(poAdminComponent)\n                .write();\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void migratePersonalAppSuspensionLocked(\n            int doUserId, int poUserId, ActiveAdmin poAdmin) {\n        final PackageManagerInternal pmi = mInjector.getPackageManagerInternal();\n        if (!pmi.isAdminSuspendingAnyPackages(doUserId)) {\n            Slogf.i(LOG_TAG, \"DO is not suspending any apps.\");\n            return;\n        }\n\n        if (getTargetSdk(poAdmin.info.getPackageName(), poUserId) >= Build.VERSION_CODES.R) {\n            Slogf.i(LOG_TAG, \"PO is targeting R+, keeping personal apps suspended.\");\n            getUserData(doUserId).mAppsSuspended = true;\n            poAdmin.mSuspendPersonalApps = true;\n        } else {\n            Slogf.i(LOG_TAG, \"PO isn't targeting R+, unsuspending personal apps.\");\n            pmi.unsuspendAdminSuspendedPackages(doUserId);\n        }\n    }\n\n    private void uninstallOrDisablePackage(String packageName, @UserIdInt int userId) {\n        final ApplicationInfo appInfo;\n        try {\n            appInfo = mIPackageManager.getApplicationInfo(\n                    packageName, MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE, userId);\n        } catch (RemoteException e) {\n            // Shouldn't happen.\n            Slogf.wtf(LOG_TAG, \"Error getting application info\", e);\n            return;\n        }\n        if (appInfo == null) {\n            Slogf.wtf(LOG_TAG, \"Failed to get package info for \" + packageName);\n            return;\n        }\n        if ((appInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {\n            Slogf.i(LOG_TAG, \"Package %s is pre-installed, marking disabled until used\",\n                    packageName);\n            mContext.getPackageManager().setApplicationEnabledSetting(packageName,\n                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED, /* flags= */ 0);\n            return;\n        }\n\n        final IIntentSender.Stub mLocalSender = new IIntentSender.Stub() {\n            @Override\n            public void send(int code, Intent intent, String resolvedType, IBinder allowlistToken,\n                    IIntentReceiver finishedReceiver, String requiredPermission, Bundle options) {\n                final int status = intent.getIntExtra(\n                        PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE);\n                if (status == PackageInstaller.STATUS_SUCCESS) {\n                    Slogf.i(LOG_TAG, \"Package %s uninstalled for user %d\", packageName, userId);\n                } else {\n                    Slogf.e(LOG_TAG, \"Failed to uninstall %s; status: %d\", packageName, status);\n                }\n            }\n        };\n\n        final PackageInstaller pi = mInjector.getPackageManager(userId).getPackageInstaller();\n        pi.uninstall(packageName, /* flags= */ 0, new IntentSender((IIntentSender) mLocalSender));\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void moveDoPoliciesToProfileParentAdminLocked(\n            ActiveAdmin doAdmin, ActiveAdmin parentAdmin) {\n        // The following policies can be already controlled via parent instance, skip if so.\n        if (parentAdmin.mPasswordPolicy.quality == PASSWORD_QUALITY_UNSPECIFIED) {\n            parentAdmin.mPasswordPolicy = doAdmin.mPasswordPolicy;\n        }\n        if (parentAdmin.passwordHistoryLength == ActiveAdmin.DEF_PASSWORD_HISTORY_LENGTH) {\n            parentAdmin.passwordHistoryLength = doAdmin.passwordHistoryLength;\n        }\n        if (parentAdmin.passwordExpirationTimeout == ActiveAdmin.DEF_PASSWORD_HISTORY_LENGTH) {\n            parentAdmin.passwordExpirationTimeout = doAdmin.passwordExpirationTimeout;\n        }\n        if (parentAdmin.maximumFailedPasswordsForWipe\n                == ActiveAdmin.DEF_MAXIMUM_FAILED_PASSWORDS_FOR_WIPE) {\n            parentAdmin.maximumFailedPasswordsForWipe = doAdmin.maximumFailedPasswordsForWipe;\n        }\n        if (parentAdmin.maximumTimeToUnlock == ActiveAdmin.DEF_MAXIMUM_TIME_TO_UNLOCK) {\n            parentAdmin.maximumTimeToUnlock = doAdmin.maximumTimeToUnlock;\n        }\n        if (parentAdmin.strongAuthUnlockTimeout\n                == DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS) {\n            parentAdmin.strongAuthUnlockTimeout = doAdmin.strongAuthUnlockTimeout;\n        }\n        parentAdmin.disabledKeyguardFeatures |=\n                doAdmin.disabledKeyguardFeatures & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\n\n        parentAdmin.trustAgentInfos.putAll(doAdmin.trustAgentInfos);\n\n        // The following policies weren't available to PO, but will be available after migration.\n        parentAdmin.disableCamera = doAdmin.disableCamera;\n        parentAdmin.disableScreenCapture = doAdmin.disableScreenCapture;\n        parentAdmin.accountTypesWithManagementDisabled.addAll(\n                doAdmin.accountTypesWithManagementDisabled);\n\n        moveDoUserRestrictionsToCopeParent(doAdmin, parentAdmin);\n\n        // From Android 11, {@link setAutoTimeRequired} is no longer used. The user restriction\n        // {@link UserManager#DISALLOW_CONFIG_DATE_TIME} should be used to enforce auto time\n        // settings instead.\n        if (doAdmin.requireAutoTime) {\n            parentAdmin.ensureUserRestrictions().putBoolean(\n                    UserManager.DISALLOW_CONFIG_DATE_TIME, true);\n        }\n    }\n\n    private void moveDoUserRestrictionsToCopeParent(ActiveAdmin doAdmin, ActiveAdmin parentAdmin) {\n        if (doAdmin.userRestrictions == null) {\n            return;\n        }\n        for (final String restriction : doAdmin.userRestrictions.keySet()) {\n            if (UserRestrictionsUtils.canParentOfProfileOwnerOfOrganizationOwnedDeviceChange(\n                    restriction)) {\n                parentAdmin.ensureUserRestrictions().putBoolean(\n                        restriction, doAdmin.userRestrictions.getBoolean(restriction));\n            }\n        }\n    }\n\n    /**\n     * If the device is in Device Owner mode, apply the restriction on adding\n     * a managed profile.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void applyProfileRestrictionsIfDeviceOwnerLocked() {\n        final int doUserId = mOwners.getDeviceOwnerUserId();\n        if (doUserId == UserHandle.USER_NULL) {\n            if (VERBOSE_LOG) Slogf.d(LOG_TAG, \"No DO found, skipping application of restriction.\");\n            return;\n        }\n\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            UserHandle userHandle = userInfo.getUserHandle();\n            // Based on  CDD : https://source.android.com/compatibility/12/android-12-cdd#95_multi-user_support,\n            // creation of clone profile is not allowed in case device owner is set.\n            // Enforcing this restriction on setting up of device owner.\n            if (!mUserManager.hasUserRestriction(\n                    UserManager.DISALLOW_ADD_CLONE_PROFILE, userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE, true,\n                        userHandle);\n            }\n            // Enforcing the restriction of private profile creation in case device owner is set.\n            if (!mUserManager.hasUserRestriction(\n                    UserManager.DISALLOW_ADD_PRIVATE_PROFILE, userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_PRIVATE_PROFILE, true,\n                        userHandle);\n            }\n            // Creation of managed profile is restricted in case device owner is set, enforcing this\n            // restriction by setting user level restriction at time of device owner setup.\n            if (!mUserManager.hasUserRestriction(\n                    UserManager.DISALLOW_ADD_MANAGED_PROFILE, userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE, true,\n                        userHandle);\n            }\n        }\n    }\n\n    /** Apply default restrictions that haven't been applied to profile owners yet. */\n    private void maybeSetDefaultProfileOwnerUserRestrictions() {\n        synchronized (getLockObject()) {\n            for (final int userId : mOwners.getProfileOwnerKeys()) {\n                final ActiveAdmin profileOwner = getProfileOwnerAdminLocked(userId);\n                // The following restrictions used to be applied to managed profiles by different\n                // means (via Settings or by disabling components). Now they are proper user\n                // restrictions so we apply them to managed profile owners. Non-managed secondary\n                // users didn't have those restrictions so we skip them to keep existing behavior.\n                if (profileOwner == null || !mUserManager.isManagedProfile(userId)) {\n                    continue;\n                }\n                maybeSetDefaultRestrictionsForAdminLocked(userId, profileOwner);\n                ensureUnknownSourcesRestrictionForProfileOwnerLocked(\n                        userId, profileOwner, false /* newOwner */);\n            }\n        }\n    }\n\n    /**\n     * Checks whether {@link UserManager#DISALLOW_INSTALL_UNKNOWN_SOURCES} should be added to the\n     * set of restrictions for this profile owner.\n     */\n    private void ensureUnknownSourcesRestrictionForProfileOwnerLocked(int userId,\n            ActiveAdmin profileOwner, boolean newOwner) {\n        if (newOwner || mInjector.settingsSecureGetIntForUser(\n                Settings.Secure.UNKNOWN_SOURCES_DEFAULT_REVERSED, 0, userId) != 0) {\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.getPolicyDefinitionForUserRestriction(\n                            UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES),\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            profileOwner.info.getComponent(),\n                            profileOwner.getUserHandle().getIdentifier()),\n                    new BooleanPolicyValue(true),\n                    userId);\n            mInjector.settingsSecurePutIntForUser(\n                    Settings.Secure.UNKNOWN_SOURCES_DEFAULT_REVERSED, 0, userId);\n        }\n    }\n\n    /** Apply default restrictions that haven't been applied to a given admin yet. */\n    private void maybeSetDefaultRestrictionsForAdminLocked(int userId, ActiveAdmin admin) {\n        Set<String> newDefaultRestrictions = new HashSet(\n            UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n        newDefaultRestrictions.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n        if (newDefaultRestrictions.isEmpty()) {\n            return; // The same set of default restrictions has been already applied.\n        }\n\n        for (String restriction : newDefaultRestrictions) {\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction),\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(),\n                            admin.getUserHandle().getIdentifier()),\n                    new BooleanPolicyValue(true),\n                    userId);\n            admin.defaultEnabledRestrictionsAlreadySet.add(restriction);\n            Slogf.i(LOG_TAG, \"Enabled the following restriction by default: \" + restriction);\n        }\n    }\n\n    private void maybeStartSecurityLogMonitorOnActivityManagerReady() {\n        if (!mInjector.securityLogIsLoggingEnabled()) {\n            return;\n        }\n\n        boolean auditLoggingEnabled = Boolean.TRUE.equals(\n                mDevicePolicyEngine.getResolvedPolicy(\n                        PolicyDefinition.AUDIT_LOGGING, UserHandle.USER_ALL));\n        boolean securityLoggingEnabled = Boolean.TRUE.equals(\n                mDevicePolicyEngine.getResolvedPolicy(\n                        PolicyDefinition.SECURITY_LOGGING, UserHandle.USER_ALL));\n        setLoggingConfiguration(securityLoggingEnabled, auditLoggingEnabled);\n        mInjector.runCryptoSelfTest();\n    }\n\n    /**\n     * Fix left-over restrictions and auto-time policy during COMP -> COPE migration.\n     *\n     * When a COMP device with requireAutoTime policy set was migrated to an\n     * organization-owned profile, a DISALLOW_CONFIG_DATE_TIME restriction is set\n     * on user 0 from the DO user, which becomes unremovable by the organization-owned\n     * profile owner. Fix this by force removing that restriction. Also revert the\n     * parentAdmin.requireAutoTime bit (since the COPE PO cannot unset this bit)\n     * and replace it with DISALLOW_CONFIG_DATE_TIME on the correct\n     * admin, in line with the deprecation recommendation of setAutoTimeRequired().\n     */\n    private void fixupAutoTimeRestrictionDuringOrganizationOwnedDeviceMigration() {\n        for (UserInfo ui : mUserManager.getUsers()) {\n            final int userId = ui.id;\n            if (isProfileOwnerOfOrganizationOwnedDevice(userId)) {\n                final ActiveAdmin parent = getProfileOwnerAdminLocked(userId).parentAdmin;\n                if (parent != null && parent.requireAutoTime) {\n                    // Remove deprecated requireAutoTime\n                    parent.requireAutoTime = false;\n                    saveSettingsLocked(userId);\n\n                    // Remove user restrictions set by the device owner before the upgrade to\n                    // Android 11.\n                    mUserManagerInternal.setDevicePolicyUserRestrictions(UserHandle.USER_SYSTEM,\n                            new Bundle(), new RestrictionsSet(), /* isDeviceOwner */ false);\n\n                    // Apply user restriction to parent active admin instead\n                    parent.ensureUserRestrictions().putBoolean(\n                            UserManager.DISALLOW_CONFIG_DATE_TIME, true);\n                }\n            }\n        }\n    }\n\n    /**\n     * Set an alarm for an upcoming event - expiration warning, expiration, or post-expiration\n     * reminders.  Clears alarm if no expirations are configured.\n     */\n    private void setExpirationAlarmCheckLocked(Context context, int userHandle, boolean parent) {\n        final long expiration = getPasswordExpirationLocked(null, userHandle, parent);\n        final long now = System.currentTimeMillis();\n        final long timeToExpire = expiration - now;\n        final long alarmTime;\n        if (expiration == 0) {\n            // No expirations are currently configured:  Cancel alarm.\n            alarmTime = 0;\n        } else if (timeToExpire <= 0) {\n            // The password has already expired:  Repeat every 24 hours.\n            alarmTime = now + MS_PER_DAY;\n        } else {\n            // Selecting the next alarm time:  Roll forward to the next 24 hour multiple before\n            // the expiration time.\n            long alarmInterval = timeToExpire % MS_PER_DAY;\n            if (alarmInterval == 0) {\n                alarmInterval = MS_PER_DAY;\n            }\n            alarmTime = now + alarmInterval;\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            int affectedUserHandle = parent ? getProfileParentId(userHandle) : userHandle;\n            AlarmManager am = mInjector.getAlarmManager();\n            // Broadcast alarms sent by system are immutable\n            PendingIntent pi = PendingIntent.getBroadcastAsUser(context, REQUEST_EXPIRE_PASSWORD,\n                    new Intent(ACTION_EXPIRED_PASSWORD_NOTIFICATION),\n                    PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_UPDATE_CURRENT\n                            | PendingIntent.FLAG_IMMUTABLE,\n                    UserHandle.of(affectedUserHandle));\n            am.cancel(pi);\n            if (alarmTime != 0) {\n                am.set(AlarmManager.RTC, alarmTime, pi);\n            }\n        });\n    }\n\n    ActiveAdmin getActiveAdminUncheckedLocked(ComponentName who, int userHandle) {\n        ensureLocked();\n        ActiveAdmin admin = getUserData(userHandle).mAdminMap.get(who);\n        if (admin != null\n                && who.getPackageName().equals(admin.info.getActivityInfo().packageName)\n                && who.getClassName().equals(admin.info.getActivityInfo().name)) {\n            return admin;\n        }\n        return null;\n    }\n\n    ActiveAdmin getActiveAdminUncheckedLocked(ComponentName who, int userHandle, boolean parent) {\n        ensureLocked();\n        if (parent) {\n            Preconditions.checkCallAuthorization(isManagedProfile(userHandle),\n                    \"You can not call APIs on the parent profile outside a managed profile, \"\n                            + \"userId = %d\", userHandle);\n        }\n        ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n        if (admin != null && parent) {\n            admin = admin.getParentActiveAdmin();\n        }\n        return admin;\n    }\n\n    ActiveAdmin getActiveAdminForCallerLocked(ComponentName who, int reqPolicy)\n            throws SecurityException {\n        return getActiveAdminOrCheckPermissionForCallerLocked(who,\n                reqPolicy, /* permission= */ null);\n    }\n\n    ActiveAdmin getDeviceOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        ComponentName doComponent = mOwners.getDeviceOwnerComponent();\n        ActiveAdmin doAdmin = getUserData(userId).mAdminMap.get(doComponent);\n        return doAdmin;\n    }\n\n    ActiveAdmin getDefaultDeviceOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        ComponentName doComponent = mOwners.getDeviceOwnerComponent();\n        if (mOwners.getDeviceOwnerType(doComponent.getPackageName()) == DEFAULT_DEVICE_OWNER) {\n            ActiveAdmin doAdmin = getUserData(userId).mAdminMap.get(doComponent);\n            return doAdmin;\n        }\n        return null;\n    }\n\n    ActiveAdmin getProfileOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        final ComponentName poAdminComponent = mOwners.getProfileOwnerComponent(userId);\n        ActiveAdmin poAdmin = getUserData(userId).mAdminMap.get(poAdminComponent);\n        return poAdmin;\n    }\n\n    ActiveAdmin getProfileOwnerOrDeviceOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        // Try to find an admin which can use reqPolicy\n        final ComponentName poAdminComponent = mOwners.getProfileOwnerComponent(userId);\n\n        if (poAdminComponent != null) {\n            return getProfileOwnerLocked(userId);\n        }\n\n        return getDeviceOwnerLocked(userId);\n    }\n\n    @NonNull ActiveAdmin getParentOfAdminIfRequired(ActiveAdmin admin, boolean parent) {\n        Objects.requireNonNull(admin);\n        return parent ? admin.getParentActiveAdmin() : admin;\n    }\n\n    /**\n     * Finds an active admin for the caller then checks {@code permission} if admin check failed.\n     *\n     * @return an active admin or {@code null} if there is no active admin but\n     * {@code permission} is granted\n     * @throws SecurityException if caller neither has an active admin nor {@code permission}\n     */\n    @Nullable\n    ActiveAdmin getActiveAdminOrCheckPermissionForCallerLocked(\n            ComponentName who,\n            int reqPolicy,\n            @Nullable String permission) throws SecurityException {\n        return getActiveAdminOrCheckPermissionsForCallerLocked(\n                who, reqPolicy, permission == null ? Set.of() : Set.of(permission));\n    }\n\n    /**\n     * Finds an active admin for the caller then checks {@code permissions} if admin check failed.\n     *\n     * @return an active admin or {@code null} if there is no active admin but\n     * one of {@code permissions} is granted\n     * @throws SecurityException if caller neither has an active admin nor {@code permission}\n     */\n    @Nullable\n    ActiveAdmin getActiveAdminOrCheckPermissionsForCallerLocked(\n            ComponentName who,\n            int reqPolicy,\n            Set<String> permissions) throws SecurityException {\n        ensureLocked();\n        final CallerIdentity caller = getCallerIdentity();\n\n        ActiveAdmin result = getActiveAdminWithPolicyForUidLocked(who, reqPolicy, caller.getUid());\n        if (result != null) {\n            return result;\n        } else {\n            for (String permission : permissions) {\n                if (hasCallingPermission(permission)) {\n                    return null;\n                }\n            }\n        }\n\n        // Code for handling failure from getActiveAdminWithPolicyForUidLocked to find an admin\n        // that satisfies the required policy.\n        // Throws a security exception with the right error message.\n        if (who != null) {\n            final DevicePolicyData policy = getUserData(caller.getUserId());\n            ActiveAdmin admin = policy.mAdminMap.get(who);\n            final boolean isDeviceOwner = isDeviceOwner(admin.info.getComponent(),\n                    caller.getUserId());\n            final boolean isProfileOwner = isProfileOwner(admin.info.getComponent(),\n                    caller.getUserId());\n\n            if (DA_DISALLOWED_POLICIES.contains(reqPolicy) && !isDeviceOwner && !isProfileOwner) {\n                throw new SecurityException(\"Admin \" + admin.info.getComponent()\n                        + \" is not a device owner or profile owner, so may not use policy: \"\n                        + admin.info.getTagForPolicy(reqPolicy));\n            }\n            throw new SecurityException(\"Admin \" + admin.info.getComponent()\n                    + \" did not specify uses-policy for: \"\n                    + admin.info.getTagForPolicy(reqPolicy));\n        } else {\n            throw new SecurityException(\"No active admin owned by uid \"\n                    + caller.getUid() + \" for policy #\" + reqPolicy + (permissions.isEmpty() ? \"\"\n                    : \", which doesn't have \" + permissions));\n        }\n    }\n\n    ActiveAdmin getActiveAdminForCallerLocked(@Nullable ComponentName who, int reqPolicy,\n            boolean parent) throws SecurityException {\n        return getActiveAdminOrCheckPermissionForCallerLocked(\n                who, reqPolicy, parent, /* permission= */ null);\n    }\n\n    /**\n     * Finds an active admin for the caller then checks {@code permission} if admin check failed.\n     *\n     * @return an active admin or {@code null} if there is no active admin but\n     * {@code permission} is granted\n     * @throws SecurityException if caller neither has an active admin nor {@code permission}\n     */\n    @Nullable\n    ActiveAdmin getActiveAdminOrCheckPermissionForCallerLocked(\n            @Nullable ComponentName who,\n            int reqPolicy,\n            boolean parent,\n            @Nullable String permission) throws SecurityException {\n        return getActiveAdminOrCheckPermissionsForCallerLocked(\n                who, reqPolicy, parent, permission == null ? Set.of() : Set.of(permission));\n    }\n\n    /**\n     * Finds an active admin for the caller then checks {@code permission} if admin check failed.\n     *\n     * @return an active admin or {@code null} if there is no active admin but\n     * {@code permission} is granted\n     * @throws SecurityException if caller neither has an active admin nor {@code permission}\n     */\n    @Nullable\n    ActiveAdmin getActiveAdminOrCheckPermissionsForCallerLocked(\n            @Nullable ComponentName who,\n            int reqPolicy,\n            boolean parent,\n            Set<String> permissions) throws SecurityException {\n        ensureLocked();\n        if (parent) {\n            Preconditions.checkCallingUser(isManagedProfile(getCallerIdentity().getUserId()));\n        }\n        ActiveAdmin admin = getActiveAdminOrCheckPermissionsForCallerLocked(\n                who, reqPolicy, permissions);\n        return parent ? admin.getParentActiveAdmin() : admin;\n    }\n\n    /**\n     * Find the admin for the component and userId bit of the uid, then check\n     * the admin's uid matches the uid.\n     */\n    private ActiveAdmin getActiveAdminForUidLocked(ComponentName who, int uid) {\n        ensureLocked();\n        final int userId = UserHandle.getUserId(uid);\n        final DevicePolicyData policy = getUserData(userId);\n        ActiveAdmin admin = policy.mAdminMap.get(who);\n        if (admin == null) {\n            throw new SecurityException(\"No active admin \" + who + \" for UID \" + uid);\n        }\n        if (admin.getUid() != uid) {\n            throw new SecurityException(\"Admin \" + who + \" is not owned by uid \" + uid);\n        }\n        return admin;\n    }\n\n    /**\n     * Returns the active admin for the user of the caller as denoted by uid, which implements\n     * the {@code reqPolicy}.\n     *\n     * The {@code who} parameter is used as a hint:\n     * If provided, it must be the component name of the active admin for that user and the caller\n     * uid must match the uid of the admin.\n     * If not provided, iterate over all of the active admins in the DevicePolicyData for that user\n     * and return the one with the uid specified as parameter, and has the policy specified.\n     */\n    @Nullable\n    private ActiveAdmin getActiveAdminWithPolicyForUidLocked(ComponentName who, int reqPolicy,\n            int uid) {\n        ensureLocked();\n        // Try to find an admin which can use reqPolicy\n        final int userId = UserHandle.getUserId(uid);\n        final DevicePolicyData policy = getUserData(userId);\n        if (who != null) {\n            ActiveAdmin admin = policy.mAdminMap.get(who);\n            if (admin == null || admin.getUid() != uid) {\n                throw new SecurityException(\n                        \"Admin \" + who + \" is not active or not owned by uid \" + uid);\n            }\n            if (isActiveAdminWithPolicyForUserLocked(admin, reqPolicy, userId)) {\n                return admin;\n            }\n        } else {\n            for (ActiveAdmin admin : policy.mAdminList) {\n                if (admin.getUid() == uid && isActiveAdminWithPolicyForUserLocked(admin, reqPolicy,\n                        userId)) {\n                    return admin;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    @VisibleForTesting\n    boolean isActiveAdminWithPolicyForUserLocked(ActiveAdmin admin, int reqPolicy,\n            int userId) {\n        ensureLocked();\n        final boolean ownsDevice = isDeviceOwner(admin.info.getComponent(), userId);\n        final boolean ownsProfile = isProfileOwner(admin.info.getComponent(), userId);\n\n        boolean allowedToUsePolicy = ownsDevice || ownsProfile\n                || !DA_DISALLOWED_POLICIES.contains(reqPolicy)\n                || getTargetSdk(admin.info.getPackageName(), userId) < Build.VERSION_CODES.Q;\n        return allowedToUsePolicy && admin.info.usesPolicy(reqPolicy);\n    }\n\n    void sendAdminCommandLocked(ActiveAdmin admin, String action) {\n        sendAdminCommandLocked(admin, action, null);\n    }\n\n    void sendAdminCommandLocked(ActiveAdmin admin, String action, BroadcastReceiver result) {\n        sendAdminCommandLocked(admin, action, null, result);\n    }\n\n    void sendAdminCommandLocked(ActiveAdmin admin, String action, Bundle adminExtras,\n            BroadcastReceiver result) {\n        sendAdminCommandLocked(admin, action, adminExtras, result, false);\n    }\n\n    /**\n     * Send an update to one specific admin, get notified when that admin returns a result.\n     *\n     * @return whether the broadcast was successfully sent\n     */\n    boolean sendAdminCommandLocked(ActiveAdmin admin, String action, Bundle adminExtras,\n            BroadcastReceiver result, boolean inForeground) {\n        Intent intent = new Intent(action);\n        intent.setComponent(admin.info.getComponent());\n        if (UserManager.isDeviceInDemoMode(mContext)) {\n            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        }\n        if (action.equals(DeviceAdminReceiver.ACTION_PASSWORD_EXPIRING)) {\n            intent.putExtra(\"expiration\", admin.passwordExpirationDate);\n        }\n        if (inForeground) {\n            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        }\n        if (adminExtras != null) {\n            intent.putExtras(adminExtras);\n        }\n        if (mInjector.getPackageManager().queryBroadcastReceiversAsUser(\n                intent,\n                PackageManager.MATCH_DEBUG_TRIAGED_MISSING,\n                admin.getUserHandle()).isEmpty()) {\n            return false;\n        }\n\n        final BroadcastOptions options = BroadcastOptions.makeBasic();\n        options.setBackgroundActivityStartsAllowed(true);\n\n        if (result != null) {\n            mContext.sendOrderedBroadcastAsUser(intent, admin.getUserHandle(),\n                    null, AppOpsManager.OP_NONE, options.toBundle(),\n                    result, mHandler, Activity.RESULT_OK, null, null);\n        } else {\n            mContext.sendBroadcastAsUser(intent, admin.getUserHandle(), null, options.toBundle());\n        }\n\n        return true;\n    }\n\n    /**\n     * Send an update to all admins of a user that enforce a specified policy.\n     */\n    void sendAdminCommandLocked(String action, int reqPolicy, int userHandle, Bundle adminExtras) {\n        final DevicePolicyData policy = getUserData(userHandle);\n        final int count = policy.mAdminList.size();\n        for (int i = 0; i < count; i++) {\n            final ActiveAdmin admin = policy.mAdminList.get(i);\n            if (admin.info.usesPolicy(reqPolicy)) {\n                sendAdminCommandLocked(admin, action, adminExtras, null);\n            }\n        }\n    }\n\n    /**\n     * Send an update intent to all admins of a user and its profiles. Only send to admins that\n     * enforce a specified policy.\n     */\n    private void sendAdminCommandToSelfAndProfilesLocked(String action, int reqPolicy,\n            int userHandle, Bundle adminExtras) {\n        int[] profileIds = mUserManager.getProfileIdsWithDisabled(userHandle);\n        for (int profileId : profileIds) {\n            sendAdminCommandLocked(action, reqPolicy, profileId, adminExtras);\n        }\n    }\n\n    /**\n     * Sends a broadcast to each profile that share the password unlock with the given user id.\n     */\n    private void sendAdminCommandForLockscreenPoliciesLocked(\n            String action, int reqPolicy, int userHandle) {\n        final Bundle extras = new Bundle();\n        extras.putParcelable(Intent.EXTRA_USER, UserHandle.of(userHandle));\n        if (isSeparateProfileChallengeEnabled(userHandle)) {\n            sendAdminCommandLocked(action, reqPolicy, userHandle, extras);\n        } else {\n            sendAdminCommandToSelfAndProfilesLocked(action, reqPolicy, userHandle, extras);\n        }\n    }\n\n    void removeActiveAdminLocked(final ComponentName adminReceiver, final int userHandle) {\n        final ActiveAdmin admin = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n        DevicePolicyData policy = getUserData(userHandle);\n        if (admin != null && !policy.mRemovingAdmins.contains(adminReceiver)) {\n            Slogf.d(LOG_TAG, \"Adding \" + adminReceiver + \" for user \" + userHandle\n                    + \" to list of removing admins.\");\n            logStackTrace(\"removeActiveAdminLocked\");\n\n            policy.mRemovingAdmins.add(adminReceiver);\n            sendAdminCommandLocked(admin,\n                    DeviceAdminReceiver.ACTION_DEVICE_ADMIN_DISABLED,\n                    new BroadcastReceiver() {\n                        @Override\n                        public void onReceive(Context context, Intent intent) {\n                            removeAdminArtifacts(adminReceiver, userHandle);\n                            removePackageIfRequired(adminReceiver.getPackageName(), userHandle);\n                        }\n                    });\n        }\n    }\n\n    private DeviceAdminInfo findAdmin(final ComponentName adminName, final int userHandle,\n            boolean throwForMissingPermission) {\n        final ActivityInfo ai = mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                return mIPackageManager.getReceiverInfo(adminName,\n                        GET_META_DATA\n                        | PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS\n                        | MATCH_DIRECT_BOOT_AWARE\n                        | MATCH_DIRECT_BOOT_UNAWARE, userHandle);\n            } catch (RemoteException e) {\n                // shouldn't happen.\n                Slogf.wtf(LOG_TAG, \"Error getting receiver info\", e);\n                return null;\n            }\n        });\n        if (ai == null) {\n            throw new IllegalArgumentException(\"Unknown admin: \" + adminName);\n        }\n\n        if (!BIND_DEVICE_ADMIN.equals(ai.permission)) {\n            final String message = \"DeviceAdminReceiver \" + adminName + \" must be protected with \"\n                    + BIND_DEVICE_ADMIN;\n            Slogf.w(LOG_TAG, message);\n            if (throwForMissingPermission &&\n                    ai.applicationInfo.targetSdkVersion > Build.VERSION_CODES.M) {\n                throw new IllegalArgumentException(message);\n            }\n        }\n\n        try {\n            return new DeviceAdminInfo(mContext, ai);\n        } catch (XmlPullParserException | IOException e) {\n            Slogf.w(LOG_TAG, \"Bad device admin requested for user=\" + userHandle + \": \" + adminName,\n                    e);\n            return null;\n        }\n    }\n\n    private File getPolicyFileDirectory(@UserIdInt int userId) {\n        return userId == UserHandle.USER_SYSTEM\n                ? mPathProvider.getDataSystemDirectory()\n                : mPathProvider.getUserSystemDirectory(userId);\n    }\n\n    private JournaledFile makeJournaledFile(@UserIdInt int userId, String fileName) {\n        final String base = new File(getPolicyFileDirectory(userId), fileName)\n                .getAbsolutePath();\n        if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"Opening %s\", base);\n        return new JournaledFile(new File(base), new File(base + \".tmp\"));\n    }\n\n    private JournaledFile makeJournaledFile(@UserIdInt int userId) {\n        return makeJournaledFile(userId, DEVICE_POLICIES_XML);\n    }\n\n    /**\n     * Persist modified values to disk by calling {@link #saveSettingsLocked} for each\n     * affected user ID.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void saveSettingsForUsersLocked(Set<Integer> affectedUserIds) {\n        for (int userId : affectedUserIds) {\n            saveSettingsLocked(userId);\n        }\n    }\n\n    private void saveSettingsLocked(int userHandle) {\n        if (DevicePolicyData.store(getUserData(userHandle), makeJournaledFile(userHandle))) {\n            sendChangedNotification(userHandle);\n        }\n        invalidateBinderCaches();\n    }\n\n    private void sendChangedNotification(int userHandle) {\n        Intent intent = new Intent(DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED);\n        intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        Bundle options = new BroadcastOptions()\n                .setDeliveryGroupPolicy(BroadcastOptions.DELIVERY_GROUP_POLICY_MOST_RECENT)\n                .setDeferralPolicy(BroadcastOptions.DEFERRAL_POLICY_UNTIL_ACTIVE)\n                .toBundle();\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mContext.sendBroadcastAsUser(intent, new UserHandle(userHandle), null, options));\n    }\n\n    private void loadSettingsLocked(DevicePolicyData policy, int userHandle) {\n        DevicePolicyData.load(policy,\n                makeJournaledFile(userHandle),\n                component -> findAdmin(\n                        component, userHandle, /* throwForMissingPermission= */ false),\n                getOwnerComponent(userHandle));\n\n        policy.validatePasswordOwner();\n        updateMaximumTimeToLockLocked(userHandle);\n        if (policy.mStatusBarDisabled) {\n            setStatusBarDisabledInternal(policy.mStatusBarDisabled, userHandle);\n        }\n    }\n\n    static void updateLockTaskPackagesLocked(Context context, List<String> packages, int userId) {\n        Binder.withCleanCallingIdentity(() -> {\n\n            String[] packagesArray = null;\n            if (!packages.isEmpty()) {\n                // When adding packages, we need to include the exempt apps so they can still be\n                // launched (ideally we should use a different AM API as these apps don't need to\n                // use lock-task mode).\n                // They're not added when the packages is empty though, as in that case we're\n                // disabling lock-task mode.\n                List<String> exemptApps = listPolicyExemptAppsUnchecked(context);\n                if (!exemptApps.isEmpty()) {\n                    // TODO(b/175377361): add unit test to verify it (cannot be CTS because the\n                    //  policy-exempt apps are provided by OEM and the test would have no control\n                    //  over it) once tests are migrated to the new infra-structure\n                    HashSet<String> updatedPackages = new HashSet<>(packages);\n                    updatedPackages.addAll(exemptApps);\n                    if (VERBOSE_LOG) {\n                        Slogf.v(LOG_TAG, \"added %d policy-exempt apps to %d lock task \"\n                                + \"packages. Final list: %s\",\n                                exemptApps.size(), packages.size(), updatedPackages);\n                    }\n                    packagesArray = updatedPackages.toArray(new String[updatedPackages.size()]);\n                }\n            }\n\n            if (packagesArray == null) {\n                packagesArray = packages.toArray(new String[packages.size()]);\n            }\n            try {\n                ActivityManager.getService().updateLockTaskPackages(userId, packagesArray);\n            } catch (RemoteException e) {\n                // Shouldn't happen.\n                Slog.wtf(LOG_TAG, \"Remote Exception: \", e);\n            }\n        });\n    }\n\n    static void updateLockTaskFeaturesLocked(int flags, int userId) {\n        Binder.withCleanCallingIdentity(() -> {\n            try {\n                ActivityTaskManager.getService().updateLockTaskFeatures(userId, flags);\n            } catch (RemoteException e) {\n                // Shouldn't happen.\n                Slog.wtf(LOG_TAG, \"Remote Exception: \", e);\n            }\n        });\n    }\n\n    static void validateQualityConstant(int quality) {\n        switch (quality) {\n            case PASSWORD_QUALITY_UNSPECIFIED:\n            case PASSWORD_QUALITY_BIOMETRIC_WEAK:\n            case PASSWORD_QUALITY_SOMETHING:\n            case PASSWORD_QUALITY_NUMERIC:\n            case PASSWORD_QUALITY_NUMERIC_COMPLEX:\n            case PASSWORD_QUALITY_ALPHABETIC:\n            case PASSWORD_QUALITY_ALPHANUMERIC:\n            case PASSWORD_QUALITY_COMPLEX:\n            case PASSWORD_QUALITY_MANAGED:\n                return;\n        }\n        throw new IllegalArgumentException(\"Invalid quality constant: 0x\"\n                + Integer.toHexString(quality));\n    }\n\n    @VisibleForTesting\n    void systemReady(int phase) {\n        if (!mHasFeature) {\n            return;\n        }\n        switch (phase) {\n            case SystemService.PHASE_LOCK_SETTINGS_READY:\n                onLockSettingsReady();\n                loadAdminDataAsync();\n                mOwners.systemReady();\n                applyManagedSubscriptionsPolicyIfRequired();\n                break;\n            case SystemService.PHASE_SYSTEM_SERVICES_READY:\n                synchronized (getLockObject()) {\n                    mDevicePolicyEngine.reapplyAllPoliciesOnBootLocked();\n                }\n                if (Flags.managementModePolicyMetrics()) {\n                    registerStatsCallbacks();\n                }\n                break;\n            case SystemService.PHASE_ACTIVITY_MANAGER_READY:\n                synchronized (getLockObject()) {\n                    migrateToProfileOnOrganizationOwnedDeviceIfCompLocked();\n                    applyProfileRestrictionsIfDeviceOwnerLocked();\n\n                    // TODO: Is this the right place to trigger the migration?\n                    if (shouldMigrateV1ToDevicePolicyEngine()) {\n                        migrateV1PoliciesToDevicePolicyEngine();\n                    }\n                    maybeMigratePoliciesPostUpgradeToDevicePolicyEngineLocked();\n                    migratePoliciesToPolicyEngineLocked();\n                }\n                maybeStartSecurityLogMonitorOnActivityManagerReady();\n                break;\n            case SystemService.PHASE_BOOT_COMPLETED:\n                // Ideally it should be done earlier, but currently it relies on RecoverySystem,\n                // which would hang on earlier phases\n                factoryResetIfDelayedEarlier();\n\n                ensureDeviceOwnerUserStarted(); // TODO Consider better place to do this.\n                break;\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void maybeMigrateSecurityLoggingPolicyLocked() {\n        if (mOwners.isSecurityLoggingMigrated()) {\n            return;\n        }\n\n        try {\n            migrateSecurityLoggingPolicyInternalLocked();\n        } catch (Exception e) {\n            Slog.e(LOG_TAG, \"Failed to properly migrate security logging to policy engine\", e);\n        }\n\n        Slog.i(LOG_TAG, \"Marking security logging policy migration complete\");\n        mOwners.markSecurityLoggingMigrated();\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void migrateSecurityLoggingPolicyInternalLocked() {\n        Slog.i(LOG_TAG, \"Migrating security logging policy to policy engine\");\n        if (!mInjector.securityLogGetLoggingEnabledProperty()) {\n            Slog.i(LOG_TAG, \"Security logs not enabled, exiting\");\n            return;\n        }\n\n        // Security logging can be enabled either by DO or by COPE PO.\n        final ActiveAdmin admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n        if (admin == null) {\n            Slog.wtf(LOG_TAG, \"Security logging is enabled, but no appropriate admin found\");\n            return;\n        }\n\n        EnforcingAdmin enforcingAdmin =\n                EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                        admin.info.getComponent(),\n                        admin.getUserHandle().getIdentifier()\n                );\n        mDevicePolicyEngine.setGlobalPolicy(\n                PolicyDefinition.SECURITY_LOGGING,\n                enforcingAdmin,\n                new BooleanPolicyValue(true));\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private boolean maybeMigrateRequiredPasswordComplexityLocked(String backupId) {\n        Slog.i(LOG_TAG, \"Migrating password complexity to policy engine\");\n        if (!Flags.unmanagedModeMigration()) {\n            return false;\n        }\n        if (mOwners.isRequiredPasswordComplexityMigrated()) {\n            return false;\n        }\n        // Create backup if none exists\n        mDevicePolicyEngine.createBackup(backupId);\n        try {\n            iterateThroughDpcAdminsLocked((admin, enforcingAdmin) -> {\n                int userId = enforcingAdmin.getUserId();\n                if (admin.mPasswordComplexity != PASSWORD_COMPLEXITY_NONE) {\n                    mDevicePolicyEngine.setLocalPolicy(\n                            PolicyDefinition.PASSWORD_COMPLEXITY,\n                            enforcingAdmin,\n                            new IntegerPolicyValue(admin.mPasswordComplexity),\n                            userId);\n                }\n                ActiveAdmin parentAdmin = admin.getParentActiveAdmin();\n                if (parentAdmin != null\n                        && parentAdmin.mPasswordComplexity != PASSWORD_COMPLEXITY_NONE) {\n                    mDevicePolicyEngine.setLocalPolicy(\n                            PolicyDefinition.PASSWORD_COMPLEXITY,\n                            enforcingAdmin,\n                            new IntegerPolicyValue(parentAdmin.mPasswordComplexity),\n                            getProfileParentId(userId));\n                }\n            });\n        } catch (Exception e) {\n            Slog.wtf(LOG_TAG, \"Failed to migrate password complexity to policy engine\", e);\n        }\n\n        Slog.i(LOG_TAG, \"Marking password complexity migration complete\");\n        mOwners.markRequiredPasswordComplexityMigrated();\n        return true;\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private boolean maybeMigrateSuspendedPackagesLocked(String backupId) {\n        Slog.i(LOG_TAG, \"Migrating suspended packages to policy engine\");\n        if (!Flags.suspendPackagesCoexistence()) {\n            return false;\n        }\n        if (mOwners.isSuspendedPackagesMigrated()) {\n            return false;\n        }\n        // Create backup if none exists\n        mDevicePolicyEngine.createBackup(backupId);\n        try {\n            iterateThroughDpcAdminsLocked((admin, enforcingAdmin) -> {\n                if (admin.suspendedPackages == null || admin.suspendedPackages.size() == 0) {\n                    return;\n                }\n                int userId = enforcingAdmin.getUserId();\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.PACKAGES_SUSPENDED,\n                        enforcingAdmin,\n                        new PackageSetPolicyValue(new ArraySet<>(admin.suspendedPackages)),\n                        userId);\n            });\n        } catch (Exception e) {\n            Slog.wtf(LOG_TAG, \"Failed to migrate suspended packages to policy engine\", e);\n        }\n\n        Slog.i(LOG_TAG, \"Marking suspended packages migration complete\");\n        mOwners.markSuspendedPackagesMigrated();\n        return true;\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private boolean maybeMigrateResetPasswordTokenLocked(String backupId) {\n        if (!Flags.resetPasswordWithTokenCoexistence()) {\n            Slog.i(LOG_TAG, \"ResetPasswordWithToken not migrated because coexistence \"\n                    + \"support is not enabled.\");\n            return false;\n        }\n        if (mOwners.isResetPasswordWithTokenMigrated()) {\n            // TODO(b/359187209): Remove log after Flags.resetPasswordWithTokenCoexistence full\n            //  rollout.\n            Slog.v(LOG_TAG, \"ResetPasswordWithToken was previously migrated to \"\n                    + \"policy engine.\");\n            return false;\n        }\n\n        Slog.i(LOG_TAG, \"Migrating ResetPasswordWithToken to policy engine\");\n\n        // Create backup if none exists\n        mDevicePolicyEngine.createBackup(backupId);\n        try {\n            iterateThroughDpcAdminsLocked((admin, enforcingAdmin) -> {\n                int userId = enforcingAdmin.getUserId();\n                DevicePolicyData policy = getUserData(userId);\n                if (policy.mPasswordTokenHandle != 0) {\n                    Slog.i(LOG_TAG, \"Setting RESET_PASSWORD_TOKEN policy\");\n                    mDevicePolicyEngine.setLocalPolicy(\n                            PolicyDefinition.RESET_PASSWORD_TOKEN,\n                            enforcingAdmin,\n                            new LongPolicyValue(policy.mPasswordTokenHandle),\n                            userId);\n                }\n            });\n        } catch (Exception e) {\n            Slog.wtf(LOG_TAG,\n                    \"Failed to migrate ResetPasswordWithToken to policy engine\", e);\n        }\n\n        Slog.i(LOG_TAG, \"Marking ResetPasswordWithToken migration complete\");\n        mOwners.markResetPasswordWithTokenMigrated();\n        return true;\n    }\n\n\n\n    @GuardedBy(\"getLockObject()\")\n    private boolean maybeMigrateMemoryTaggingLocked(String backupId) {\n        if (!Flags.setMtePolicyCoexistence()) {\n            Slog.i(LOG_TAG, \"Memory Tagging not migrated because coexistence \"\n                    + \"support is disabled.\");\n            return false;\n        }\n        if (mOwners.isMemoryTaggingMigrated()) {\n            // TODO: Remove log after Flags.setMtePolicyCoexistence full rollout.\n            Slog.v(LOG_TAG, \"Memory Tagging was previously migrated to policy engine.\");\n            return false;\n        }\n\n        Slog.i(LOG_TAG, \"Migrating Memory Tagging to policy engine\");\n\n        // Create backup if none exists\n        mDevicePolicyEngine.createBackup(backupId);\n        try {\n            iterateThroughDpcAdminsLocked((admin, enforcingAdmin) -> {\n                if (admin.mtePolicy != 0) {\n                    Slog.i(LOG_TAG, \"Setting Memory Tagging policy\");\n                    mDevicePolicyEngine.setGlobalPolicy(\n                            PolicyDefinition.MEMORY_TAGGING,\n                            enforcingAdmin,\n                            new IntegerPolicyValue(admin.mtePolicy),\n                            true /* No need to re-set system properties */);\n                }\n            });\n        } catch (Exception e) {\n            Slog.wtf(LOG_TAG,\n                    \"Failed to migrate Memory Tagging to policy engine\", e);\n        }\n\n        Slog.i(LOG_TAG, \"Marking Memory Tagging migration complete\");\n        mOwners.markMemoryTaggingMigrated();\n        return true;\n    }\n\n    /** Register callbacks for statsd pulled atoms. */\n    private void registerStatsCallbacks() {\n        final StatsManager statsManager = mContext.getSystemService(StatsManager.class);\n        if (statsManager == null) {\n            Slog.wtf(LOG_TAG, \"StatsManager system service not found.\");\n            return;\n        }\n        statsManager.setPullAtomCallback(\n                DEVICE_POLICY_MANAGEMENT_MODE,\n                null, // use defaultPullAtomMetadata values\n                DIRECT_EXECUTOR,\n                this::onPullManagementModeAtom);\n        statsManager.setPullAtomCallback(\n                DEVICE_POLICY_STATE,\n                null, // use defaultPullAtomMetadata values\n                DIRECT_EXECUTOR,\n                this::onPullPolicyStateAtom);\n    }\n\n    /** Writes the pulled atoms. */\n    private int onPullManagementModeAtom(int atomTag, List<StatsEvent> statsEvents) {\n        synchronized (getLockObject()) {\n            statsEvents.add(DevicePolicyStatsLog.buildStatsEvent(\n                    DEVICE_POLICY_MANAGEMENT_MODE,\n                    getStatsManagementModeLocked().managementMode()));\n            return PULL_SUCCESS;\n        }\n    }\n\n    /** Writes the pulled atoms. */\n    private int onPullPolicyStateAtom(int atomTag, List<StatsEvent> statsEvents) {\n        synchronized (getLockObject()) {\n            StatsManagementMode statsManagementMode = getStatsManagementModeLocked();\n            if (statsManagementMode.admin() != null) {\n                statsEvents.add(DevicePolicyStatsLog.buildStatsEvent(DEVICE_POLICY_STATE,\n                        getRequiredPasswordComplexityStatsLocked(statsManagementMode.admin()),\n                        statsManagementMode.managementMode()\n                        ));\n            } else {\n                statsEvents.add(DevicePolicyStatsLog.buildStatsEvent(DEVICE_POLICY_STATE,\n                        DEVICE_POLICY_STATE__PASSWORD_COMPLEXITY__COMPLEXITY_NONE,\n                        DEVICE_POLICY_MANAGEMENT_MODE__MANAGEMENT_MODE__MANAGEMENT_MODE_UNSPECIFIED\n                ));\n            }\n            return PULL_SUCCESS;\n        }\n    }\n\n    private StatsManagementMode getStatsManagementModeLocked() {\n        int managementMode =\n                DEVICE_POLICY_MANAGEMENT_MODE__MANAGEMENT_MODE__MANAGEMENT_MODE_UNSPECIFIED;\n        ActiveAdmin admin = getDeviceOwnerAdminLocked();\n        if (admin != null) {\n            managementMode = getDeviceOwnerTypeLocked(\n                    getDeviceOwnerComponent(false).getPackageName())\n                    != DEVICE_OWNER_TYPE_FINANCED\n                    ? DEVICE_POLICY_MANAGEMENT_MODE__MANAGEMENT_MODE__DEVICE_OWNER\n                    : DEVICE_POLICY_MANAGEMENT_MODE__MANAGEMENT_MODE__DEVICE_OWNER_FINANCED;\n        } else {\n            // Find the first user with managing_app.\n            for (Integer profileUserId : mOwners.getProfileOwnerKeys()) {\n                if (isManagedProfile(profileUserId)) {\n                    admin = getProfileOwnerAdminLocked(profileUserId);\n                    managementMode = mOwners.isProfileOwnerOfOrganizationOwnedDevice(\n                            profileUserId)\n                            ? DEVICE_POLICY_MANAGEMENT_MODE__MANAGEMENT_MODE__COPE\n                            : DEVICE_POLICY_MANAGEMENT_MODE__MANAGEMENT_MODE__PROFILE_OWNER;\n                    break;\n                }\n            }\n        }\n        return new StatsManagementMode(managementMode, admin);\n    }\n\n    private record StatsManagementMode(int managementMode, ActiveAdmin admin) {\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private int getRequiredPasswordComplexityStatsLocked(ActiveAdmin admin) {\n        int userId = admin.getUserHandle().getIdentifier();\n        EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                admin.info.getComponent(),\n                userId\n        );\n\n        Integer passwordComplexity = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                PolicyDefinition.PASSWORD_COMPLEXITY,\n                enforcingAdmin,\n                userId);\n        if (passwordComplexity == null) {\n            return admin.mPasswordPolicy.quality != PASSWORD_QUALITY_UNSPECIFIED\n                    ? DEVICE_POLICY_STATE__PASSWORD_COMPLEXITY__COMPLEXITY_LEGACY\n                    : DEVICE_POLICY_STATE__PASSWORD_COMPLEXITY__COMPLEXITY_UNSPECIFIED;\n        }\n        switch (passwordComplexity) {\n            case PASSWORD_COMPLEXITY_NONE -> {\n                return DEVICE_POLICY_STATE__PASSWORD_COMPLEXITY__COMPLEXITY_NONE;\n            }\n            case PASSWORD_COMPLEXITY_LOW -> {\n                return DEVICE_POLICY_STATE__PASSWORD_COMPLEXITY__COMPLEXITY_LOW;\n            }\n            case PASSWORD_COMPLEXITY_MEDIUM -> {\n                return DEVICE_POLICY_STATE__PASSWORD_COMPLEXITY__COMPLEXITY_MEDIUM;\n            }\n            case PASSWORD_COMPLEXITY_HIGH -> {\n                return DEVICE_POLICY_STATE__PASSWORD_COMPLEXITY__COMPLEXITY_HIGH;\n            }\n            default -> {\n                Slogf.wtf(LOG_TAG, \"Unhandled password complexity: \" + passwordComplexity);\n                return DEVICE_POLICY_STATE__PASSWORD_COMPLEXITY__COMPLEXITY_UNSPECIFIED;\n            }\n        }\n    }\n\n    private void applyManagedSubscriptionsPolicyIfRequired() {\n        int copeProfileUserId = getOrganizationOwnedProfileUserId();\n        // This policy is relevant only for COPE devices.\n        if (copeProfileUserId != UserHandle.USER_NULL) {\n            unregisterOnSubscriptionsChangedListener();\n            int policyType = getManagedSubscriptionsPolicy().getPolicyType();\n            if (policyType == ManagedSubscriptionsPolicy.TYPE_ALL_PERSONAL_SUBSCRIPTIONS) {\n                clearManagedSubscriptionsPolicy();\n            } else if (policyType == ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {\n                // Add listener to assign all current and future subs to managed profile.\n                registerListenerToAssignSubscriptionsToUser(copeProfileUserId);\n            }\n        }\n    }\n\n    private void updatePersonalAppsSuspensionOnUserStart(int userHandle) {\n        final int profileUserHandle = getManagedUserId(userHandle);\n        if (profileUserHandle >= 0) {\n            // Given that the parent user has just started, profile should be locked.\n            updatePersonalAppsSuspension(profileUserHandle);\n        } else {\n            suspendPersonalAppsInternal(userHandle, profileUserHandle, false);\n        }\n    }\n\n    private void onLockSettingsReady() {\n        synchronized (getLockObject()) {\n            fixupAutoTimeRestrictionDuringOrganizationOwnedDeviceMigration();\n        }\n        getUserData(UserHandle.USER_SYSTEM);\n        cleanUpOldUsers();\n        maybeSetDefaultProfileOwnerUserRestrictions();\n        handleStartUser(UserHandle.USER_SYSTEM);\n        maybeLogStart();\n\n        // Register an observer for watching for user setup complete and settings changes.\n        mSetupContentObserver.register();\n        // Initialize the user setup state, to handle the upgrade case.\n        updateUserSetupCompleteAndPaired();\n\n        List<String> packageList;\n        synchronized (getLockObject()) {\n            packageList = getKeepUninstalledPackagesLocked();\n        }\n        if (packageList != null) {\n            mInjector.getPackageManagerInternal().setKeepUninstalledPackages(packageList);\n        }\n\n        synchronized (getLockObject()) {\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (deviceOwner != null) {\n                // Push the force-ephemeral-users policy to the user manager.\n                mUserManagerInternal.setForceEphemeralUsers(deviceOwner.forceEphemeralUsers);\n\n                // Update user switcher message to activity manager.\n                ActivityManagerInternal activityManagerInternal =\n                        mInjector.getActivityManagerInternal();\n                activityManagerInternal.setSwitchingFromSystemUserMessage(\n                        deviceOwner.startUserSessionMessage);\n                activityManagerInternal.setSwitchingToSystemUserMessage(\n                        deviceOwner.endUserSessionMessage);\n            }\n\n            revertTransferOwnershipIfNecessaryLocked();\n        }\n\n        // Check whether work apps were paused via suspension and unsuspend if necessary.\n        // TODO: move it into PolicyVersionUpgrader so that it is executed only once.\n        unsuspendWorkAppsIfNecessary();\n    }\n\n    // TODO(b/230841522) Make it static.\n    private class DpmsUpgradeDataProvider implements PolicyUpgraderDataProvider {\n        @Override\n        public JournaledFile makeDevicePoliciesJournaledFile(int userId) {\n            return DevicePolicyManagerService.this.makeJournaledFile(userId, DEVICE_POLICIES_XML);\n        }\n\n        @Override\n        public JournaledFile makePoliciesVersionJournaledFile(int userId) {\n            return DevicePolicyManagerService.this.makeJournaledFile(userId, POLICIES_VERSION_XML);\n        }\n\n        @Override\n        public Function<ComponentName, DeviceAdminInfo> getAdminInfoSupplier(int userId) {\n            return component ->\n                    findAdmin(component, userId, /* throwForMissingPermission= */ false);\n        }\n\n        @Override\n        public int[] getUsersForUpgrade() {\n            List<UserInfo> allUsers = mUserManager.getUsers();\n            return allUsers.stream().mapToInt(u -> u.id).toArray();\n        }\n\n        @Override\n        public List<String> getPlatformSuspendedPackages(int userId) {\n            PackageManagerInternal pmi = mInjector.getPackageManagerInternal();\n            return mInjector.getPackageManager(userId)\n                    .getInstalledPackages(PackageManager.PackageInfoFlags.of(\n                            MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE))\n                    .stream()\n                    .map(packageInfo -> packageInfo.packageName)\n                    .filter(pkg ->\n                            PLATFORM_PACKAGE_NAME.equals(pmi.getSuspendingPackage(pkg, userId))\n                    )\n                    .collect(Collectors.toList());\n        }\n    }\n\n    private void performPolicyVersionUpgrade() {\n        PolicyVersionUpgrader upgrader = new PolicyVersionUpgrader(\n                new DpmsUpgradeDataProvider(), mPathProvider);\n        upgrader.upgradePolicy(DPMS_VERSION);\n    }\n\n    private void revertTransferOwnershipIfNecessaryLocked() {\n        if (!mTransferOwnershipMetadataManager.metadataFileExists()) {\n            return;\n        }\n        Slogf.e(LOG_TAG, \"Owner transfer metadata file exists! Reverting transfer.\");\n        final TransferOwnershipMetadataManager.Metadata metadata =\n                mTransferOwnershipMetadataManager.loadMetadataFile();\n        // Revert transfer\n        if (metadata.adminType.equals(ADMIN_TYPE_PROFILE_OWNER)) {\n            transferProfileOwnershipLocked(metadata.targetComponent, metadata.sourceComponent,\n                    metadata.userId);\n            deleteTransferOwnershipMetadataFileLocked();\n            deleteTransferOwnershipBundleLocked(metadata.userId);\n        } else if (metadata.adminType.equals(ADMIN_TYPE_DEVICE_OWNER)) {\n            transferDeviceOwnershipLocked(metadata.targetComponent, metadata.sourceComponent,\n                    metadata.userId);\n            deleteTransferOwnershipMetadataFileLocked();\n            deleteTransferOwnershipBundleLocked(metadata.userId);\n        }\n        updateSystemUpdateFreezePeriodsRecord(/* saveIfChanged */ true);\n    }\n\n    private void maybeLogStart() {\n        if (!SecurityLog.isLoggingEnabled()) {\n            return;\n        }\n        final String verifiedBootState =\n                mInjector.systemPropertiesGet(\"ro.boot.verifiedbootstate\");\n        final String verityMode = mInjector.systemPropertiesGet(\"ro.boot.veritymode\");\n        SecurityLog.writeEvent(SecurityLog.TAG_OS_STARTUP, verifiedBootState, verityMode);\n    }\n\n    private void ensureDeviceOwnerUserStarted() {\n        final int userId;\n        synchronized (getLockObject()) {\n            if (!mOwners.hasDeviceOwner()) {\n                return;\n            }\n            userId = mOwners.getDeviceOwnerUserId();\n        }\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"Starting non-system DO user: \" + userId);\n        }\n        if (userId != UserHandle.USER_SYSTEM) {\n            try {\n                mInjector.getIActivityManager().startUserInBackground(userId);\n\n                // STOPSHIP Prevent the DO user from being killed.\n\n            } catch (RemoteException e) {\n                Slogf.w(LOG_TAG, \"Exception starting user\", e);\n            }\n        }\n    }\n\n    void handleStartUser(int userId) {\n        // When system user is started (device boot), load cache for all users.\n        // This is to mitigate the potential race between loading the cache and keyguard\n        // reading the value during user switch, due to onStartUser() being asynchronous.\n        updatePasswordQualityCacheForUserGroup(\n                userId == UserHandle.USER_SYSTEM ? UserHandle.USER_ALL : userId);\n        updatePermissionPolicyCache(userId);\n        updateAdminCanGrantSensorsPermissionCache(userId);\n        updateContentProtectionPolicyCache(userId);\n\n        final List<PreferentialNetworkServiceConfig> preferentialNetworkServiceConfigs;\n        synchronized (getLockObject()) {\n            ActiveAdmin owner = getDeviceOrProfileOwnerAdminLocked(userId);\n            preferentialNetworkServiceConfigs = owner != null\n                    ? owner.mPreferentialNetworkServiceConfigs\n                    : List.of(PreferentialNetworkServiceConfig.DEFAULT);\n        }\n        updateNetworkPreferenceForUser(userId, preferentialNetworkServiceConfigs);\n\n        if (isProfileOwnerOfOrganizationOwnedDevice(userId)\n                && getManagedSubscriptionsPolicy().getPolicyType()\n                == ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {\n            updateDialerAndSmsManagedShortcutsOverrideCache();\n        }\n\n        startOwnerService(userId, \"start-user\");\n        mDevicePolicyEngine.handleStartUser(userId);\n    }\n\n    void handleUnlockUser(int userId) {\n        startOwnerService(userId, \"unlock-user\");\n        mDevicePolicyEngine.handleUnlockUser(userId);\n    }\n\n    void handleOnUserSwitching(int fromUserId, int toUserId) {\n        showNewUserDisclaimerIfNecessary(toUserId);\n    }\n\n    void handleStopUser(int userId) {\n        updateNetworkPreferenceForUser(userId, List.of(PreferentialNetworkServiceConfig.DEFAULT));\n        mDeviceAdminServiceController.stopServicesForUser(userId, /* actionForLog= */ \"stop-user\");\n        mDevicePolicyEngine.handleStopUser(userId);\n    }\n\n    private void startOwnerService(int userId, String actionForLog) {\n        final ComponentName owner = getOwnerComponent(userId);\n        if (owner != null) {\n            mDeviceAdminServiceController.startServiceForAdmin(\n                    owner.getPackageName(), userId, actionForLog);\n            invalidateBinderCaches();\n        }\n    }\n\n    private void cleanUpOldUsers() {\n        // This is needed in case the broadcast {@link Intent.ACTION_USER_REMOVED} was not handled\n        // before reboot\n        Set<Integer> usersWithProfileOwners;\n        Set<Integer> usersWithData;\n        synchronized (getLockObject()) {\n            usersWithProfileOwners = mOwners.getProfileOwnerKeys();\n            usersWithData = new ArraySet<>();\n            for (int i = 0; i < mUserData.size(); i++) {\n                usersWithData.add(mUserData.keyAt(i));\n            }\n        }\n        List<UserInfo> allUsers = mUserManager.getUsers();\n\n        Set<Integer> deletedUsers = new ArraySet<>();\n        deletedUsers.addAll(usersWithProfileOwners);\n        deletedUsers.addAll(usersWithData);\n        for (UserInfo userInfo : allUsers) {\n            deletedUsers.remove(userInfo.id);\n        }\n        for (Integer userId : deletedUsers) {\n            removeUserData(userId);\n            mDevicePolicyEngine.handleUserRemoved(userId);\n        }\n    }\n\n    private void handlePasswordExpirationNotification(int userHandle) {\n        final Bundle adminExtras = new Bundle();\n        adminExtras.putParcelable(Intent.EXTRA_USER, UserHandle.of(userHandle));\n\n        synchronized (getLockObject()) {\n            final long now = System.currentTimeMillis();\n\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(userHandle);\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                ActiveAdmin admin = admins.get(i);\n                if ((admin.info.usesPolicy(DeviceAdminInfo.USES_POLICY_EXPIRE_PASSWORD))\n                        && admin.passwordExpirationTimeout > 0L\n                        && now >= admin.passwordExpirationDate - EXPIRATION_GRACE_PERIOD_MS\n                        && admin.passwordExpirationDate > 0L) {\n                    sendAdminCommandLocked(admin,\n                            DeviceAdminReceiver.ACTION_PASSWORD_EXPIRING, adminExtras, null);\n                }\n            }\n            setExpirationAlarmCheckLocked(mContext, userHandle, /* parent */ false);\n        }\n    }\n\n    /**\n     * Clean up internal state when the set of installed trusted CA certificates changes.\n     *\n     * @param userHandle user to check for. This must be a real user and not, for example,\n     *        {@link UserHandle#ALL}.\n     * @param installedCertificates the full set of certificate authorities currently installed for\n     *        {@param userHandle}. After calling this function, {@code mAcceptedCaCertificates} will\n     *        correspond to some subset of this.\n     */\n    protected void onInstalledCertificatesChanged(final UserHandle userHandle,\n            final @NonNull Collection<String> installedCertificates) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(userHandle.getIdentifier());\n\n            boolean changed = false;\n            changed |= policy.mAcceptedCaCertificates.retainAll(installedCertificates);\n            changed |= policy.mOwnerInstalledCaCerts.retainAll(installedCertificates);\n            if (changed) {\n                saveSettingsLocked(userHandle.getIdentifier());\n            }\n        }\n    }\n\n    /**\n     * Internal method used by {@link CertificateMonitor}.\n     */\n    protected Set<String> getAcceptedCaCertificates(final UserHandle userHandle) {\n        if (!mHasFeature) {\n            return Collections.<String> emptySet();\n        }\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(userHandle.getIdentifier());\n            return policy.mAcceptedCaCertificates;\n        }\n    }\n\n    /**\n     * @param adminReceiver The admin to add\n     * @param refreshing true = update an active admin, no error\n     * @param userHandle which user this admin will be set on\n     * @param provisioningContext additional information for debugging\n     */\n    @Override\n    public void setActiveAdmin(\n            ComponentName adminReceiver,\n            boolean refreshing,\n            int userHandle,\n            @Nullable String provisioningContext\n    ) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        DevicePolicyData policy = getUserData(userHandle);\n        DeviceAdminInfo info = findAdmin(adminReceiver, userHandle,\n                /* throwForMissingPermission= */ true);\n        synchronized (getLockObject()) {\n            checkActiveAdminPrecondition(adminReceiver, info, policy);\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                final ActiveAdmin existingAdmin\n                        = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n                if (!refreshing && existingAdmin != null) {\n                    throw new IllegalArgumentException(\"Admin is already added\");\n                }\n                ActiveAdmin newAdmin = new ActiveAdmin(info, /* parent */ false);\n                newAdmin.testOnlyAdmin =\n                        (existingAdmin != null) ? existingAdmin.testOnlyAdmin\n                                : isPackageTestOnly(adminReceiver.getPackageName(), userHandle);\n                newAdmin.setProvisioningContext(provisioningContext);\n                policy.mAdminMap.put(adminReceiver, newAdmin);\n                int replaceIndex = -1;\n                final int N = policy.mAdminList.size();\n                for (int i=0; i < N; i++) {\n                    ActiveAdmin oldAdmin = policy.mAdminList.get(i);\n                    if (oldAdmin.info.getComponent().equals(adminReceiver)) {\n                        replaceIndex = i;\n                        break;\n                    }\n                }\n                if (replaceIndex == -1) {\n                    policy.mAdminList.add(newAdmin);\n                    enableIfNecessary(info.getPackageName(), userHandle);\n                    mUsageStatsManagerInternal.onActiveAdminAdded(\n                            adminReceiver.getPackageName(), userHandle);\n                } else {\n                    policy.mAdminList.set(replaceIndex, newAdmin);\n                }\n                saveSettingsLocked(userHandle);\n                sendAdminCommandLocked(newAdmin, DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED,\n                        /* adminExtras= */ null, /* result= */ null);\n            });\n        }\n    }\n\n    private void loadAdminDataAsync() {\n        mInjector.postOnSystemServerInitThreadPool(() -> {\n            pushActiveAdminPackages();\n            mUsageStatsManagerInternal.onAdminDataAvailable();\n            pushAllMeteredRestrictedPackages();\n            mInjector.getNetworkPolicyManagerInternal().onAdminDataAvailable();\n        });\n    }\n\n    private void pushActiveAdminPackages() {\n        synchronized (getLockObject()) {\n            final List<UserInfo> users = mUserManager.getUsers();\n            for (int i = users.size() - 1; i >= 0; --i) {\n                final int userId = users.get(i).id;\n                mUsageStatsManagerInternal.setActiveAdminApps(\n                        getActiveAdminPackagesLocked(userId), userId);\n            }\n        }\n    }\n\n    private void pushAllMeteredRestrictedPackages() {\n        synchronized (getLockObject()) {\n            final List<UserInfo> users = mUserManager.getUsers();\n            for (int i = users.size() - 1; i >= 0; --i) {\n                final int userId = users.get(i).id;\n                mInjector.getNetworkPolicyManagerInternal().setMeteredRestrictedPackagesAsync(\n                        getMeteredDisabledPackages(userId), userId);\n            }\n        }\n    }\n\n    private void pushActiveAdminPackagesLocked(int userId) {\n        mUsageStatsManagerInternal.setActiveAdminApps(\n                getActiveAdminPackagesLocked(userId), userId);\n    }\n\n    private Set<String> getActiveAdminPackagesLocked(int userId) {\n        final DevicePolicyData policy = getUserData(userId);\n        Set<String> adminPkgs = null;\n        for (int i = policy.mAdminList.size() - 1; i >= 0; --i) {\n            final String pkgName = policy.mAdminList.get(i).info.getPackageName();\n            if (adminPkgs == null) {\n                adminPkgs = new ArraySet<>();\n            }\n            adminPkgs.add(pkgName);\n        }\n        return adminPkgs;\n    }\n\n    private void transferActiveAdminUncheckedLocked(ComponentName incomingReceiver,\n            ComponentName outgoingReceiver, int userHandle) {\n        final DevicePolicyData policy = getUserData(userHandle);\n        if (!policy.mAdminMap.containsKey(outgoingReceiver)\n                && policy.mAdminMap.containsKey(incomingReceiver)) {\n            // Nothing to transfer - the incoming receiver is already the active admin.\n            return;\n        }\n        final DeviceAdminInfo incomingDeviceInfo = findAdmin(incomingReceiver, userHandle,\n            /* throwForMissingPermission= */ true);\n        final ActiveAdmin adminToTransfer = policy.mAdminMap.get(outgoingReceiver);\n        final int oldAdminUid = adminToTransfer.getUid();\n\n        EnforcingAdmin oldAdmin =\n                EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                        outgoingReceiver, userHandle);\n        EnforcingAdmin newAdmin =\n                EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                        incomingReceiver, userHandle);\n\n        mDevicePolicyEngine.transferPolicies(oldAdmin, newAdmin);\n\n        adminToTransfer.transfer(incomingDeviceInfo);\n        policy.mAdminMap.remove(outgoingReceiver);\n        policy.mAdminMap.put(incomingReceiver, adminToTransfer);\n        if (policy.mPasswordOwner == oldAdminUid) {\n            policy.mPasswordOwner = adminToTransfer.getUid();\n        }\n        transferSubscriptionOwnership(outgoingReceiver, incomingReceiver);\n        saveSettingsLocked(userHandle);\n        sendAdminCommandLocked(adminToTransfer, DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED,\n                null, null);\n    }\n\n    private void checkActiveAdminPrecondition(ComponentName adminReceiver, DeviceAdminInfo info,\n            DevicePolicyData policy) {\n        if (info == null) {\n            throw new IllegalArgumentException(\"Bad admin: \" + adminReceiver);\n        }\n        if (!info.getActivityInfo().applicationInfo.isInternal()) {\n            throw new IllegalArgumentException(\"Only apps in internal storage can be active admin: \"\n                    + adminReceiver);\n        }\n        if (info.getActivityInfo().applicationInfo.isInstantApp()) {\n            throw new IllegalArgumentException(\"Instant apps cannot be device admins: \"\n                    + adminReceiver);\n        }\n        if (policy.mRemovingAdmins.contains(adminReceiver)) {\n            throw new IllegalArgumentException(\n                    \"Trying to set an admin which is being removed\");\n        }\n    }\n\n    private void checkAllUsersAreAffiliatedWithDevice() {\n        synchronized (getLockObject()) {\n            Preconditions.checkCallAuthorization(areAllUsersAffiliatedWithDeviceLocked(),\n                    \"operation not allowed when device has unaffiliated users\");\n        }\n    }\n\n    @Override\n    public boolean isAdminActive(ComponentName adminReceiver, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            return getActiveAdminUncheckedLocked(adminReceiver, userHandle) != null;\n        }\n    }\n\n    @Override\n    public boolean isRemovingAdmin(ComponentName adminReceiver, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(userHandle);\n            return policyData.mRemovingAdmins.contains(adminReceiver);\n        }\n    }\n\n    @Override\n    public boolean hasGrantedPolicy(ComponentName adminReceiver, int policyId, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(\n                isCallingFromPackage(adminReceiver.getPackageName(), caller.getUid())\n                        || isSystemUid(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin administrator = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n            if (administrator == null) {\n                throw new SecurityException(\"No active admin \" + adminReceiver);\n            }\n            return administrator.info.usesPolicy(policyId);\n        }\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public List<ComponentName> getActiveAdmins(int userHandle) {\n        if (!mHasFeature) {\n            return Collections.EMPTY_LIST;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(userHandle);\n            final int N = policy.mAdminList.size();\n            if (N <= 0) {\n                return null;\n            }\n            ArrayList<ComponentName> res = new ArrayList<ComponentName>(N);\n            for (int i=0; i<N; i++) {\n                res.add(policy.mAdminList.get(i).info.getComponent());\n            }\n            return res;\n        }\n    }\n\n    @Override\n    public boolean packageHasActiveAdmins(String packageName, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(userHandle);\n            final int N = policy.mAdminList.size();\n            for (int i=0; i<N; i++) {\n                if (policy.mAdminList.get(i).info.getPackageName().equals(packageName)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    @Override\n    public void forceRemoveActiveAdmin(ComponentName adminReceiver, int userHandle) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(adminReceiver, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isAdb(getCallerIdentity())\n                        || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS),\n                \"Caller must be shell or hold MANAGE_PROFILE_AND_DEVICE_OWNERS to call \"\n                        + \"forceRemoveActiveAdmin\");\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            boolean isOrgOwnedProfile = false;\n            synchronized (getLockObject()) {\n                if (!isAdminTestOnlyLocked(adminReceiver, userHandle)) {\n                    throw new SecurityException(\"Attempt to remove non-test admin \"\n                            + adminReceiver + \" \" + userHandle);\n                }\n\n                // If admin is a device or profile owner tidy that up first.\n                if (isDeviceOwner(adminReceiver, userHandle)) {\n                    clearDeviceOwnerLocked(getDeviceOwnerAdminLocked(), userHandle);\n                }\n                if (isProfileOwner(adminReceiver, userHandle)) {\n                    isOrgOwnedProfile = isProfileOwnerOfOrganizationOwnedDevice(userHandle);\n                    final ActiveAdmin admin = getActiveAdminUncheckedLocked(adminReceiver,\n                            userHandle, /* parent */ false);\n                    clearProfileOwnerLocked(admin, userHandle);\n                }\n            }\n            // Remove the admin skipping sending the broadcast.\n            removeAdminArtifacts(adminReceiver, userHandle);\n\n            // In case of PO on org owned device, clean device-wide policies and restrictions.\n            if (isOrgOwnedProfile) {\n                final UserHandle parentUser = UserHandle.of(getProfileParentId(userHandle));\n                clearOrgOwnedProfileOwnerUserRestrictions(parentUser);\n                clearOrgOwnedProfileOwnerDeviceWidePolicies(parentUser.getIdentifier());\n            }\n\n            Slogf.i(LOG_TAG, \"Admin \" + adminReceiver + \" removed from user \" + userHandle);\n        });\n    }\n\n    private void clearOrgOwnedProfileOwnerUserRestrictions(UserHandle parentUserHandle) {\n        mUserManager.setUserRestriction(\n                UserManager.DISALLOW_REMOVE_MANAGED_PROFILE, false, parentUserHandle);\n        if (mInjector.userManagerIsHeadlessSystemUserMode()) {\n            mUserManager.setUserRestriction(UserManager.DISALLOW_REMOVE_MANAGED_PROFILE,\n                    false, UserHandle.SYSTEM);\n        }\n        mUserManager.setUserRestriction(\n                UserManager.DISALLOW_ADD_USER, false, parentUserHandle);\n    }\n\n    private void clearDeviceOwnerUserRestriction(UserHandle userHandle) {\n        for (int userId : mUserManagerInternal.getUserIds()) {\n            UserHandle user = UserHandle.of(userId);\n            // ManagedProvisioning/DPC sets DISALLOW_ADD_USER. Clear to recover to the\n            // original state\n            if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_USER, user)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_USER,\n                        false, user);\n            }\n            // When a device owner is set, the system automatically restricts adding a\n            // managed profile.\n            // Remove this restriction when the device owner is cleared.\n            if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                    user)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                        false,\n                        user);\n            }\n            // When a device owner is set, the system automatically restricts adding a\n            // clone profile.\n            // Remove this restriction when the device owner is cleared.\n            if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE, user)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE,\n                        false, user);\n            }\n\n            // When a device owner is set, the system automatically restricts adding a\n            // private profile.\n            // Remove this restriction when the device owner is cleared.\n            if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_PRIVATE_PROFILE,\n                    user)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_PRIVATE_PROFILE,\n                        false, user);\n            }\n        }\n\n    }\n\n    /**\n     * Return if a given package has testOnly=\"true\", in which case we'll relax certain rules\n     * for CTS.\n     *\n     * DO NOT use this method except in {@link #setActiveAdmin}.  Use {@link #isAdminTestOnlyLocked}\n     * to check wehter an active admin is test-only or not.\n     *\n     * The system allows this flag to be changed when an app is updated, which is not good\n     * for us.  So we persist the flag in {@link ActiveAdmin} when an admin is first installed,\n     * and used the persisted version in actual checks. (See b/31382361 and b/28928996)\n     */\n    private boolean isPackageTestOnly(String packageName, int userHandle) {\n        final ApplicationInfo ai;\n        try {\n            ai = mInjector.getIPackageManager().getApplicationInfo(packageName,\n                    (MATCH_DIRECT_BOOT_AWARE\n                            | MATCH_DIRECT_BOOT_UNAWARE), userHandle);\n        } catch (RemoteException e) {\n            throw new IllegalStateException(e);\n        }\n        if (ai == null) {\n            throw new IllegalStateException(\"Couldn't find package: \"\n                    + packageName + \" on user \" + userHandle);\n        }\n        return (ai.flags & ApplicationInfo.FLAG_TEST_ONLY) != 0;\n    }\n\n    /**\n     * See {@link #isPackageTestOnly}.\n     */\n    private boolean isAdminTestOnlyLocked(ComponentName who, int userHandle) {\n        final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n        return (admin != null) && admin.testOnlyAdmin;\n    }\n\n    @Override\n    public void removeActiveAdmin(ComponentName adminReceiver, int userHandle) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS)\n                ? getCallerIdentity() : getCallerIdentity(adminReceiver);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_REMOVE_ACTIVE_ADMIN);\n        enforceUserUnlocked(userHandle);\n\n        ActiveAdmin admin;\n        synchronized (getLockObject()) {\n            admin = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n            if (admin == null) {\n                return;\n            }\n            // Active device/profile owners must remain active admins.\n            if (isDeviceOwner(adminReceiver, userHandle)\n                    || isProfileOwner(adminReceiver, userHandle)) {\n                Slogf.e(LOG_TAG, \"Device/profile owner cannot be removed: component=\"\n                        + adminReceiver);\n                return;\n            }\n            mInjector.binderWithCleanCallingIdentity(() ->\n                    removeActiveAdminLocked(adminReceiver, userHandle));\n        }\n        mDevicePolicyEngine.removePoliciesForAdmin(\n                EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                        adminReceiver, userHandle));\n    }\n\n    private boolean canSetPasswordQualityOnParent(String packageName, final CallerIdentity caller) {\n        return !mInjector.isChangeEnabled(\n                PREVENT_SETTING_PASSWORD_QUALITY_ON_PARENT, packageName, caller.getUserId())\n            || isProfileOwnerOfOrganizationOwnedDevice(caller);\n    }\n\n    private boolean isPasswordLimitingAdminTargetingP(CallerIdentity caller) {\n        if (!caller.hasAdminComponent()) {\n            return false;\n        }\n\n        synchronized (getLockObject()) {\n            return getActiveAdminWithPolicyForUidLocked(\n                    caller.getComponentName(), DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD,\n                    caller.getUid()) != null;\n        }\n    }\n\n    private boolean notSupportedOnAutomotive(String method) {\n        if (mIsAutomotive) {\n            Slogf.i(LOG_TAG, \"%s is not supported on automotive builds\", method);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public void setPasswordQuality(ComponentName who, int quality, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordQuality\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        validateQualityConstant(quality);\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                        || isSystemUid(caller) || isPasswordLimitingAdminTargetingP(caller));\n\n        if (parent) {\n            Preconditions.checkCallAuthorization(\n                    canSetPasswordQualityOnParent(who.getPackageName(), caller),\n                    \"Profile Owner may not apply password quality requirements device-wide\");\n        }\n\n        final int userId = caller.getUserId();\n        EnforcingAdmin enforcingAdmin = null;\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n\n            if (Flags.unmanagedModeMigration()) {\n                getActiveAdminForCallerLocked(who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD);\n                enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(who, userId);\n            }\n            // If setPasswordQuality is called on the parent, ensure that\n            // the primary admin does not have password complexity state (this is an\n            // unsupported state).\n            if (parent) {\n                final boolean hasComplexitySet;\n                if (Flags.unmanagedModeMigration()) {\n                    Integer complexity = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                            PolicyDefinition.PASSWORD_COMPLEXITY,\n                            enforcingAdmin,\n                            userId);\n                    hasComplexitySet = complexity != null && complexity != PASSWORD_COMPLEXITY_NONE;\n                } else {\n                    final ActiveAdmin primaryAdmin = getActiveAdminForCallerLocked(\n                            who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, false);\n                    hasComplexitySet = primaryAdmin.mPasswordComplexity != PASSWORD_COMPLEXITY_NONE;\n                }\n\n                Preconditions.checkState(!hasComplexitySet,\n                        \"Cannot set password quality when complexity is set on the primary admin.\"\n                        + \" Set the primary admin's complexity to NONE first.\");\n            }\n            final EnforcingAdmin enforcingAdminFinal = enforcingAdmin;\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n                if (passwordPolicy.quality != quality) {\n                    passwordPolicy.quality = quality;\n                    if (Flags.unmanagedModeMigration()) {\n                        int affectedUser = parent ? getProfileParentId(userId) : userId;\n                        mDevicePolicyEngine.removeLocalPolicy(PolicyDefinition.PASSWORD_COMPLEXITY,\n                                enforcingAdminFinal, affectedUser);\n                    } else {\n                        ap.mPasswordComplexity = PASSWORD_COMPLEXITY_NONE;\n                    }\n                    resetInactivePasswordRequirementsIfRPlus(userId, ap);\n                    updatePasswordValidityCheckpointLocked(userId, parent);\n                    updatePasswordQualityCacheForUserGroup(userId);\n                    saveSettingsLocked(userId);\n                }\n                logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n            });\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_QUALITY)\n                .setAdmin(who)\n                .setInt(quality)\n                .setStrings(parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT)\n                .write();\n    }\n\n    private boolean passwordQualityInvocationOrderCheckEnabled(String packageName, int userId) {\n        return mInjector.isChangeEnabled(ADMIN_APP_PASSWORD_COMPLEXITY, packageName, userId);\n    }\n\n    /**\n     * For admins targeting R+ reset various password constraints to default values when quality is\n     * set to a value that makes those constraints that have no effect.\n     */\n    private void resetInactivePasswordRequirementsIfRPlus(int userId, ActiveAdmin admin) {\n        if (passwordQualityInvocationOrderCheckEnabled(admin.info.getPackageName(), userId)) {\n            final PasswordPolicy policy = admin.mPasswordPolicy;\n            if (policy.quality < PASSWORD_QUALITY_NUMERIC) {\n                policy.length = PasswordPolicy.DEF_MINIMUM_LENGTH;\n            }\n            if (policy.quality < PASSWORD_QUALITY_COMPLEX) {\n                policy.letters = PasswordPolicy.DEF_MINIMUM_LETTERS;\n                policy.upperCase = PasswordPolicy.DEF_MINIMUM_UPPER_CASE;\n                policy.lowerCase = PasswordPolicy.DEF_MINIMUM_LOWER_CASE;\n                policy.numeric = PasswordPolicy.DEF_MINIMUM_NUMERIC;\n                policy.symbols = PasswordPolicy.DEF_MINIMUM_SYMBOLS;\n                policy.nonLetter = PasswordPolicy.DEF_MINIMUM_NON_LETTER;\n            }\n        }\n    }\n\n    /**\n     * Updates a flag that tells us whether the user's password currently satisfies the\n     * requirements set by all of the user's active admins.\n     * This should be called whenever the password or the admin policies have changed. The caller\n     * is responsible for calling {@link #saveSettingsLocked} to persist the change.\n     *\n     * @return the set of user IDs that have been affected\n     */\n    @GuardedBy(\"getLockObject()\")\n    private Set<Integer> updatePasswordValidityCheckpointLocked(int userHandle, boolean parent) {\n        final ArraySet<Integer> affectedUserIds = new ArraySet<>();\n        final int credentialOwner = getCredentialOwner(userHandle, parent);\n        DevicePolicyData policy = getUserData(credentialOwner);\n        PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(credentialOwner);\n        // Update the checkpoint only if the user's password metrics is known\n        if (metrics != null) {\n            final int userToCheck = getProfileParentUserIfRequested(userHandle, parent);\n            final boolean newCheckpoint = isPasswordSufficientForUserWithoutCheckpointLocked(\n                    metrics, userToCheck);\n            if (newCheckpoint != policy.mPasswordValidAtLastCheckpoint) {\n                policy.mPasswordValidAtLastCheckpoint = newCheckpoint;\n                affectedUserIds.add(credentialOwner);\n            }\n        }\n        return affectedUserIds;\n    }\n\n    /**\n     * Update password quality values in policy cache for all users in the same user group as\n     * the given user. The cached password quality for user X is the aggregated quality among all\n     * admins who have influence of user X's screenlock, i.e. it's equivalent to the return value of\n     * getPasswordQuality(null, user X, false).\n     *\n     * Caches for all users in the same user group often need to be updated alltogether because a\n     * user's admin policy can affect another's aggregated password quality in some situation.\n     * For example a managed profile's policy will affect the parent user if the profile has unified\n     * challenge. A profile can also explicitly set a parent password quality which will affect the\n     * aggregated password quality of the parent user.\n     */\n    private void updatePasswordQualityCacheForUserGroup(@UserIdInt int userId) {\n        final List<UserInfo> users;\n        if (userId == UserHandle.USER_ALL) {\n            users = mUserManager.getUsers();\n        } else {\n            users = mUserManager.getProfiles(userId);\n        }\n        for (UserInfo userInfo : users) {\n            final int currentUserId = userInfo.id;\n            mPolicyCache.setPasswordQuality(currentUserId,\n                    getPasswordQuality(null, currentUserId, false));\n        }\n    }\n\n    @Override\n    public int getPasswordQuality(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return PASSWORD_QUALITY_UNSPECIFIED;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        // System caller can query policy for a particular admin.\n        Preconditions.checkCallAuthorization(\n                who == null || isCallingFromPackage(who.getPackageName(), caller.getUid())\n                        || canQueryAdminPolicy(caller));\n\n        synchronized (getLockObject()) {\n            int mode = PASSWORD_QUALITY_UNSPECIFIED;\n\n            if (who != null) {\n                ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                return admin != null ? admin.mPasswordPolicy.quality : mode;\n            }\n\n            // Return the strictest policy across all participating admins.\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                ActiveAdmin admin = admins.get(i);\n                if (mode < admin.mPasswordPolicy.quality) {\n                    mode = admin.mPasswordPolicy.quality;\n                }\n            }\n            return mode;\n        }\n    }\n\n    /**\n     * @deprecated  use {@link #getResolvedLockscreenPolicy(PolicyDefinition, int)} for\n     * coexistable policies\n     */\n    @GuardedBy(\"getLockObject()\")\n    private List<ActiveAdmin> getActiveAdminsForLockscreenPoliciesLocked(int userHandle) {\n        if (isSeparateProfileChallengeEnabled(userHandle)) {\n            // If this user has a separate challenge, only return its restrictions.\n            return getUserDataUnchecked(userHandle).mAdminList;\n        }\n        // If isSeparateProfileChallengeEnabled is false and userHandle points to a managed profile\n        // we need to query the parent user who owns the credential.\n        return getActiveAdminsForUserAndItsManagedProfilesLocked(getProfileParentId(userHandle),\n                (user) -> !mLockPatternUtils.isSeparateProfileChallengeEnabled(user.id));\n\n    }\n\n    /**\n     * Returns a user's resolved lockscreen policy from all admins. This is different from normal\n     * policy resolution because if the specified user has a work profile with unified challenge,\n     * all policies set on the profile will also affect that user.\n     */\n    private <V> V getResolvedLockscreenPolicy(PolicyDefinition<V> policyDefinition, int userId) {\n        if (isSeparateProfileChallengeEnabled(userId)) {\n            // If this profile has a separate challenge, only return policies targeting itself.\n            return mDevicePolicyEngine.getResolvedPolicy(policyDefinition, userId);\n        }\n        // Otherwise, this user is either a full user, or it's a profile with unified challenge.\n        // In both cases we query the parent user who owns the credential (the parent user of a full\n        // user is itself), plus any profile of the parent user who has unified challenge since\n        // the policy of a unified challenge profile is enforced on the parent.\n        return getResolvedPolicyForUserAndItsManagedProfiles(policyDefinition,\n                getProfileParentId(userId),\n                (user) -> mLockPatternUtils.isProfileWithUnifiedChallenge(user.id));\n\n    }\n\n    /**\n     * Returns the list of admins on the given user, as well as parent admins for each managed\n     * profile associated with the given user. Optionally also include the admin of each managed\n     * profile.\n     * <p> Should not be called on a profile user.\n     *\n     * For coexistable policy, please use\n     * {@link #getResolvedPolicyForUserAndItsManagedProfiles(PolicyDefinition, int, Predicate)}\n     */\n    @GuardedBy(\"getLockObject()\")\n    private List<ActiveAdmin> getActiveAdminsForUserAndItsManagedProfilesLocked(int userHandle,\n            Predicate<UserInfo> shouldIncludeProfileAdmins) {\n        ArrayList<ActiveAdmin> admins = new ArrayList<>();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo userInfo : mUserManager.getProfiles(userHandle)) {\n                DevicePolicyData policy = getUserDataUnchecked(userInfo.id);\n                if (userInfo.id == userHandle) {\n                    admins.addAll(policy.mAdminList);\n                } else if (userInfo.isManagedProfile()) {\n                    for (int i = 0; i < policy.mAdminList.size(); i++) {\n                        ActiveAdmin admin = policy.mAdminList.get(i);\n                        if (admin.hasParentActiveAdmin()) {\n                            admins.add(admin.getParentActiveAdmin());\n                        }\n                        if (shouldIncludeProfileAdmins.test(userInfo)) {\n                            admins.add(admin);\n                        }\n                    }\n                }\n            }\n        });\n        return admins;\n    }\n\n    private <V> V getResolvedPolicyForUserAndItsManagedProfiles(\n            PolicyDefinition<V> policyDefinition, int userHandle,\n            Predicate<UserInfo> shouldIncludeProfile) {\n        List<Integer> users = new ArrayList<>();\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo userInfo : mUserManager.getProfiles(userHandle)) {\n                if (userInfo.id == userHandle) {\n                    users.add(userInfo.id);\n                } else if (userInfo.isManagedProfile() && shouldIncludeProfile.test(userInfo)) {\n                    users.add(userInfo.id);\n                }\n            }\n        });\n        return mDevicePolicyEngine.getResolvedPolicyAcrossUsers(policyDefinition, users);\n    }\n\n    private boolean isSeparateProfileChallengeEnabled(int userHandle) {\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mLockPatternUtils.isSeparateProfileChallengeEnabled(userHandle));\n    }\n\n    @Override\n    public void setPasswordMinimumLength(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumLength\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(userId, ap, PASSWORD_QUALITY_NUMERIC, \"setPasswordMinimumLength\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.length != length) {\n                passwordPolicy.length = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_LENGTH)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    private void ensureMinimumQuality(\n            int userId, ActiveAdmin admin, int minimumQuality, String operation) {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            // This check will also take care of the case where the password requirements\n            // are specified as complexity rather than quality: When a password complexity\n            // is set, the quality is reset to \"unspecified\" which will be below any value\n            // of minimumQuality.\n            if (admin.mPasswordPolicy.quality < minimumQuality\n                    && passwordQualityInvocationOrderCheckEnabled(admin.info.getPackageName(),\n                    userId)) {\n                throw new IllegalStateException(String.format(\n                        \"password quality should be at least %d for %s\",\n                        minimumQuality, operation));\n            }\n        });\n    }\n\n    @Override\n    public int getPasswordMinimumLength(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.length, PASSWORD_QUALITY_NUMERIC);\n    }\n\n    @Override\n    public void setPasswordHistoryLength(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            if (ap.passwordHistoryLength != length) {\n                ap.passwordHistoryLength = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            final int affectedUserId = parent ? getProfileParentId(userId) : userId;\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_HISTORY_LENGTH_SET,\n                    who.getPackageName(), userId, affectedUserId, length);\n        }\n    }\n\n    @Override\n    public int getPasswordHistoryLength(ComponentName who, int userHandle, boolean parent) {\n        if (!mLockPatternUtils.hasSecureLockScreen()) {\n            return 0;\n        }\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.passwordHistoryLength, PASSWORD_QUALITY_UNSPECIFIED);\n    }\n\n    @Override\n    public void setPasswordExpirationTimeout(ComponentName who, String callerPackageName,\n            long timeout, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        Preconditions.checkArgumentNonnegative(timeout, \"Timeout must be >= 0 ms\");\n        int userHandle = mInjector.userHandleGetCallingUserId();\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n        synchronized (getLockObject()) {\n            ActiveAdmin ap;\n            ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_EXPIRE_PASSWORD, parent);\n            // Calling this API automatically bumps the expiration date\n            final long expiration = timeout > 0L ? (timeout + System.currentTimeMillis()) : 0L;\n            ap.passwordExpirationDate = expiration;\n            ap.passwordExpirationTimeout = timeout;\n            if (timeout > 0L) {\n                Slogf.w(LOG_TAG, \"setPasswordExpiration(): password will expire on \"\n                        + DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT)\n                        .format(new Date(expiration)));\n            }\n            saveSettingsLocked(userHandle);\n\n            // in case this is the first one, set the alarm on the appropriate user.\n            setExpirationAlarmCheckLocked(mContext, userHandle, parent);\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_EXPIRATION_SET, callerPackageName,\n                    userHandle, affectedUserId, timeout);\n        }\n    }\n\n    /**\n     * Return a single admin's expiration cycle time, or the min of all cycle times.\n     * Returns 0 if not configured.\n     */\n    @Override\n    public long getPasswordExpirationTimeout(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return 0L;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            long timeout = 0L;\n\n            if (who != null) {\n                ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                return admin != null ? admin.passwordExpirationTimeout : timeout;\n            }\n\n            // Return the strictest policy across all participating admins.\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                ActiveAdmin admin = admins.get(i);\n                if (timeout == 0L || (admin.passwordExpirationTimeout != 0L\n                        && timeout > admin.passwordExpirationTimeout)) {\n                    timeout = admin.passwordExpirationTimeout;\n                }\n            }\n            return timeout;\n        }\n    }\n\n    @Override\n    public boolean addCrossProfileWidgetProvider(ComponentName admin, String callerPackageName,\n            String packageName) {\n        CallerIdentity caller = getCallerIdentity(admin);\n\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        ActiveAdmin activeAdmin;\n        synchronized (getLockObject()) {\n            activeAdmin = getProfileOwnerLocked(caller.getUserId());\n        }\n        List<String> changedProviders = null;\n\n        synchronized (getLockObject()) {\n            if (activeAdmin.crossProfileWidgetProviders == null) {\n                activeAdmin.crossProfileWidgetProviders = new ArrayList<>();\n            }\n            List<String> providers = activeAdmin.crossProfileWidgetProviders;\n            if (!providers.contains(packageName)) {\n                providers.add(packageName);\n                changedProviders = new ArrayList<>(providers);\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_CROSS_PROFILE_WIDGET_PROVIDER)\n                .setAdmin(caller.getPackageName())\n                .write();\n\n        if (changedProviders != null) {\n            mLocalService.notifyCrossProfileProvidersChanged(caller.getUserId(),\n                    changedProviders);\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean removeCrossProfileWidgetProvider(ComponentName admin, String callerPackageName,\n            String packageName) {\n        CallerIdentity caller = getCallerIdentity(admin);\n\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        ActiveAdmin activeAdmin;\n        synchronized (getLockObject()) {\n            activeAdmin = getProfileOwnerLocked(caller.getUserId());\n        }\n        List<String> changedProviders = null;\n\n        synchronized (getLockObject()) {\n            if (activeAdmin.crossProfileWidgetProviders == null\n                    || activeAdmin.crossProfileWidgetProviders.isEmpty()) {\n                return false;\n            }\n            List<String> providers = activeAdmin.crossProfileWidgetProviders;\n            if (providers.remove(packageName)) {\n                changedProviders = new ArrayList<>(providers);\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.REMOVE_CROSS_PROFILE_WIDGET_PROVIDER)\n                .setAdmin(caller.getPackageName())\n                .write();\n\n        if (changedProviders != null) {\n            mLocalService.notifyCrossProfileProvidersChanged(caller.getUserId(),\n                    changedProviders);\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public List<String> getCrossProfileWidgetProviders(ComponentName admin,\n            String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(admin);\n\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        ActiveAdmin activeAdmin;\n        synchronized (getLockObject()) {\n            activeAdmin = getProfileOwnerLocked(caller.getUserId());\n        }\n\n        synchronized (getLockObject()) {\n            if (activeAdmin.crossProfileWidgetProviders == null\n                    || activeAdmin.crossProfileWidgetProviders.isEmpty()) {\n                return null;\n            }\n            if (mInjector.binderIsCallingUidMyUid()) {\n                return new ArrayList<>(activeAdmin.crossProfileWidgetProviders);\n            } else {\n                return activeAdmin.crossProfileWidgetProviders;\n            }\n        }\n    }\n\n    /**\n     * Return a single admin's expiration date/time, or the min (soonest) for all admins.\n     * Returns 0 if not configured.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private long getPasswordExpirationLocked(ComponentName who, int userHandle, boolean parent) {\n        long timeout = 0L;\n\n        if (who != null) {\n            ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n            return admin != null ? admin.passwordExpirationDate : timeout;\n        }\n\n        // Return the strictest policy across all participating admins.\n        List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                getProfileParentUserIfRequested(userHandle, parent));\n        final int N = admins.size();\n        for (int i = 0; i < N; i++) {\n            ActiveAdmin admin = admins.get(i);\n            if (timeout == 0L || (admin.passwordExpirationDate != 0\n                    && timeout > admin.passwordExpirationDate)) {\n                timeout = admin.passwordExpirationDate;\n            }\n        }\n        return timeout;\n    }\n\n    @Override\n    public long getPasswordExpiration(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return 0L;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            return getPasswordExpirationLocked(who, userHandle, parent);\n        }\n    }\n\n    @Override\n    public void setPasswordMinimumUpperCase(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumUpperCase\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            final ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(\n                    userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumUpperCase\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.upperCase != length) {\n                passwordPolicy.upperCase = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_UPPER_CASE)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumUpperCase(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.upperCase, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumLowerCase(ComponentName who, int length, boolean parent) {\n        if (notSupportedOnAutomotive(\"setPasswordMinimumLowerCase\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(\n                    userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumLowerCase\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.lowerCase != length) {\n                passwordPolicy.lowerCase = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_LOWER_CASE)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumLowerCase(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.lowerCase, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumLetters(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumLetters\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumLetters\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.letters != length) {\n                passwordPolicy.letters = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_LETTERS)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumLetters(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.letters, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumNumeric(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumNumeric\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumNumeric\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.numeric != length) {\n                passwordPolicy.numeric = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_NUMERIC)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumNumeric(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.numeric, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumSymbols(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumSymbols\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumSymbols\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.symbols != length) {\n                ap.mPasswordPolicy.symbols = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_SYMBOLS)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumSymbols(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.symbols, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumNonLetter(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumNonLetter\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(\n                    userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumNonLetter\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.nonLetter != length) {\n                ap.mPasswordPolicy.nonLetter = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_NON_LETTER)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumNonLetter(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.nonLetter, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    /**\n     * Calculates strictest (maximum) value for a given password property enforced by admin[s].\n     */\n    private int getStrictestPasswordRequirement(ComponentName who, int userHandle,\n            boolean parent, Function<ActiveAdmin, Integer> getter, int minimumPasswordQuality) {\n        if (!mHasFeature) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            if (who != null) {\n                final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                return admin != null ? getter.apply(admin) : 0;\n            }\n\n            int maxValue = 0;\n            final List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                final ActiveAdmin admin = admins.get(i);\n                if (!isLimitPasswordAllowed(admin, minimumPasswordQuality)) {\n                    continue;\n                }\n                final Integer adminValue = getter.apply(admin);\n                if (adminValue > maxValue) {\n                    maxValue = adminValue;\n                }\n            }\n            return maxValue;\n        }\n    }\n\n    /**\n     * Calculates strictest (maximum) value for a given password property enforced by admin[s].\n     */\n    @Override\n    public PasswordMetrics getPasswordMinimumMetrics(@UserIdInt int userHandle,\n            boolean deviceWideOnly) {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle)\n                && (isSystemUid(caller)\n                    // Accept any permission that ILockSettings#setLockCredential() accepts.\n                    || hasCallingOrSelfPermission(permission.SET_INITIAL_LOCK)\n                    || hasCallingOrSelfPermission(permission.SET_AND_VERIFY_LOCKSCREEN_CREDENTIALS)\n                    || hasCallingOrSelfPermission(permission.ACCESS_KEYGUARD_SECURE_STORAGE)));\n        return getPasswordMinimumMetricsUnchecked(userHandle, deviceWideOnly);\n    }\n\n    private PasswordMetrics getPasswordMinimumMetricsUnchecked(@UserIdInt int userId) {\n        return getPasswordMinimumMetricsUnchecked(userId, false);\n    }\n\n    private PasswordMetrics getPasswordMinimumMetricsUnchecked(@UserIdInt int userId,\n            boolean deviceWideOnly) {\n        if (!mHasFeature) {\n            new PasswordMetrics(CREDENTIAL_TYPE_NONE);\n        }\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n        if (deviceWideOnly) {\n            Preconditions.checkArgument(!isManagedProfile(userId));\n        }\n\n        ArrayList<PasswordMetrics> adminMetrics = new ArrayList<>();\n        final List<ActiveAdmin> admins;\n        synchronized (getLockObject()) {\n            if (deviceWideOnly) {\n                admins = getActiveAdminsForUserAndItsManagedProfilesLocked(userId,\n                        /* shouldIncludeProfileAdmins */ (user) -> false);\n            } else {\n                admins = getActiveAdminsForLockscreenPoliciesLocked(userId);\n            }\n            for (ActiveAdmin admin : admins) {\n                adminMetrics.add(admin.mPasswordPolicy.getMinMetrics());\n            }\n        }\n        return PasswordMetrics.merge(adminMetrics);\n    }\n\n    @Override\n    public boolean isActivePasswordSufficient(\n            String callerPackageName, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        enforceUserUnlocked(userHandle, parent);\n\n        synchronized (getLockObject()) {\n            // This API can only be called by an active device admin,\n            // so try to retrieve it to check that the caller is one.\n            getActiveAdminForCallerLocked(\n                    null, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n\n            int credentialOwner = getCredentialOwner(userHandle, parent);\n            DevicePolicyData policy = getUserDataUnchecked(credentialOwner);\n            PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(credentialOwner);\n            final int userToCheck = getProfileParentUserIfRequested(userHandle, parent);\n            return isActivePasswordSufficientForUserLocked(\n                    policy.mPasswordValidAtLastCheckpoint, metrics, userToCheck);\n        }\n    }\n\n    @Override\n    public boolean isActivePasswordSufficientForDeviceRequirement() {\n        if (!mHasFeature) {\n            return true;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        final int profileUserId = caller.getUserId();\n        Preconditions.checkCallingUser(isManagedProfile(profileUserId));\n\n        // This method is always called on the parent DPM instance to check if its password (i.e.\n        // the device password) is sufficient for all explicit password requirement set on it\n        // So retrieve the parent user Id to which the device password belongs.\n        final int parentUser = getProfileParentId(profileUserId);\n        enforceUserUnlocked(parentUser);\n\n        final boolean isSufficient;\n        synchronized (getLockObject()) {\n\n            int complexity = getAggregatedPasswordComplexityLocked(parentUser, true);\n            PasswordMetrics minMetrics = getPasswordMinimumMetricsUnchecked(parentUser, true);\n\n            PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(parentUser);\n            final List<PasswordValidationError> passwordValidationErrors =\n                    PasswordMetrics.validatePasswordMetrics(minMetrics, complexity, metrics);\n            isSufficient = passwordValidationErrors.isEmpty();\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.IS_ACTIVE_PASSWORD_SUFFICIENT_FOR_DEVICE)\n                .setStrings(mOwners.getProfileOwnerComponent(caller.getUserId()).getPackageName())\n                .write();\n        return isSufficient;\n    }\n\n    @Override\n    public boolean isUsingUnifiedPassword(ComponentName admin) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isProfileOwner(caller));\n        Preconditions.checkCallingUser(isManagedProfile(caller.getUserId()));\n\n        return !isSeparateProfileChallengeEnabled(caller.getUserId());\n    }\n\n    @Override\n    public boolean isPasswordSufficientAfterProfileUnification(int userHandle, int profileUser) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(!isManagedProfile(userHandle),\n                \"You can not check password sufficiency for a managed profile, userId = %d\",\n                userHandle);\n        enforceUserUnlocked(userHandle);\n\n        synchronized (getLockObject()) {\n            PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(userHandle);\n\n            // Combine password policies across the user and its profiles. Profile admins are\n            // included if the profile is to be unified or currently has unified challenge\n            List<ActiveAdmin> admins = getActiveAdminsForUserAndItsManagedProfilesLocked(userHandle,\n                    /* shouldIncludeProfileAdmins */ (user) -> user.id == profileUser\n                    || !mLockPatternUtils.isSeparateProfileChallengeEnabled(user.id));\n            ArrayList<PasswordMetrics> adminMetrics = new ArrayList<>(admins.size());\n            if (Flags.unmanagedModeMigration()) {\n                for (ActiveAdmin admin: admins) {\n                    adminMetrics.add(admin.mPasswordPolicy.getMinMetrics());\n                }\n                Integer maxRequiredComplexity = getResolvedPolicyForUserAndItsManagedProfiles(\n                        PolicyDefinition.PASSWORD_COMPLEXITY,\n                        userHandle,\n                        /* shouldIncludeProfileAdmins */ (user) -> user.id == profileUser\n                                || !mLockPatternUtils.isSeparateProfileChallengeEnabled(user.id));\n                return PasswordMetrics.validatePasswordMetrics(\n                        PasswordMetrics.merge(adminMetrics),\n                        maxRequiredComplexity != null\n                                ? maxRequiredComplexity : PASSWORD_COMPLEXITY_NONE,\n                        metrics).isEmpty();\n            } else {\n                int maxRequiredComplexity = PASSWORD_COMPLEXITY_NONE;\n                for (ActiveAdmin admin : admins) {\n                    adminMetrics.add(admin.mPasswordPolicy.getMinMetrics());\n                    maxRequiredComplexity = Math.max(maxRequiredComplexity,\n                            admin.mPasswordComplexity);\n                }\n                return PasswordMetrics.validatePasswordMetrics(PasswordMetrics.merge(adminMetrics),\n                        maxRequiredComplexity, metrics).isEmpty();\n            }\n        }\n    }\n\n    private boolean isActivePasswordSufficientForUserLocked(\n            boolean passwordValidAtLastCheckpoint, @Nullable PasswordMetrics metrics,\n            int userHandle) {\n        if (!mInjector.storageManagerIsFileBasedEncryptionEnabled() && (metrics == null)) {\n            // Before user enters their password for the first time after a reboot, return the\n            // value of this flag, which tells us whether the password was valid the last time\n            // settings were saved.  If DPC changes password requirements on boot so that the\n            // current password no longer meets the requirements, this value will be stale until\n            // the next time the password is entered.\n            return passwordValidAtLastCheckpoint;\n        }\n\n        if (metrics == null) {\n            // Called on a FBE device when the user password exists but its metrics is unknown.\n            // This shouldn't happen since we enforce the user to be unlocked (which would result\n            // in the metrics known to the framework on a FBE device) at all call sites.\n            throw new IllegalStateException(\"isActivePasswordSufficient called on FBE-locked user\");\n        }\n\n        return isPasswordSufficientForUserWithoutCheckpointLocked(metrics, userHandle);\n    }\n\n    /**\n     * Returns {@code true} if the password represented by the {@code metrics} argument\n     * sufficiently fulfills the password requirements for the user corresponding to\n     * {@code userId}.\n     */\n    private boolean isPasswordSufficientForUserWithoutCheckpointLocked(\n            @NonNull PasswordMetrics metrics, @UserIdInt int userId) {\n        final int complexity = getAggregatedPasswordComplexityLocked(userId);\n        PasswordMetrics minMetrics = getPasswordMinimumMetricsUnchecked(userId);\n        final List<PasswordValidationError> passwordValidationErrors =\n                PasswordMetrics.validatePasswordMetrics(minMetrics, complexity, metrics);\n        return passwordValidationErrors.isEmpty();\n    }\n\n    @Override\n    @PasswordComplexity\n    public int getPasswordComplexity(boolean parent) {\n        final CallerIdentity caller = getCallerIdentity();\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.GET_USER_PASSWORD_COMPLEXITY_LEVEL)\n                .setStrings(parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT,\n                        mInjector.getPackageManager().getPackagesForUid(caller.getUid()))\n                .write();\n\n        enforceUserUnlocked(caller.getUserId());\n        if (parent) {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller) || isSystemUid(caller),\n                    \"Only profile owner, device owner and system may call this method on parent.\");\n        } else {\n            Preconditions.checkCallAuthorization(\n                    hasCallingOrSelfPermission(REQUEST_PASSWORD_COMPLEXITY)\n                            || isDefaultDeviceOwner(caller) || isProfileOwner(caller),\n                    \"Must have \" + REQUEST_PASSWORD_COMPLEXITY\n                            + \" permission, or be a profile owner or device owner.\");\n        }\n\n        synchronized (getLockObject()) {\n            final int credentialOwner = getCredentialOwner(caller.getUserId(), parent);\n            PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(credentialOwner);\n            return metrics == null ? PASSWORD_COMPLEXITY_NONE : metrics.determineComplexity();\n        }\n    }\n\n    @Override\n    public void setRequiredPasswordComplexity(\n            String callerPackageName, int passwordComplexity, boolean calledOnParent) {\n        if (!mHasFeature) {\n            return;\n        }\n        final Set<Integer> allowedModes = Set.of(PASSWORD_COMPLEXITY_NONE, PASSWORD_COMPLEXITY_LOW,\n                PASSWORD_COMPLEXITY_MEDIUM, PASSWORD_COMPLEXITY_HIGH);\n        Preconditions.checkArgument(allowedModes.contains(passwordComplexity),\n                \"Provided complexity is not one of the allowed values.\");\n\n        if (!Flags.unmanagedModeMigration()) {\n            setRequiredPasswordComplexityPreCoexistence(callerPackageName, passwordComplexity,\n                    calledOnParent);\n            return;\n        }\n\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        int affectedUser = calledOnParent\n                ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n        EnforcingAdmin admin = enforcePermissionAndGetEnforcingAdmin(null,\n                MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS, caller.getPackageName(),\n                caller.getUserId());\n        Preconditions.checkArgument(!calledOnParent || isProfileOwner(caller));\n\n        final ActiveAdmin activeAdmin;\n        if (admin.hasAuthority(EnforcingAdmin.DPC_AUTHORITY)) {\n            synchronized (getLockObject()) {\n                activeAdmin = getActiveAdminUncheckedLocked(\n                        admin.getComponentName(), admin.getUserId());\n            }\n        } else {\n            activeAdmin = null;\n        }\n\n        // We require the caller to explicitly clear any password quality requirements set\n        // on the parent DPM instance, to avoid the case where password requirements are\n        // specified in the form of quality on the parent but complexity on the profile\n        // itself.\n        if (activeAdmin != null && !calledOnParent) {\n            final boolean hasQualityRequirementsOnParent = activeAdmin.hasParentActiveAdmin()\n                    && activeAdmin.getParentActiveAdmin().mPasswordPolicy.quality\n                    != PASSWORD_QUALITY_UNSPECIFIED;\n            Preconditions.checkState(!hasQualityRequirementsOnParent,\n                    \"Password quality is set on the parent when attempting to set password\"\n                            + \"complexity. Clear the quality by setting the password quality \"\n                            + \"on the parent to PASSWORD_QUALITY_UNSPECIFIED first\");\n        }\n\n        if (passwordComplexity != PASSWORD_COMPLEXITY_NONE) {\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.PASSWORD_COMPLEXITY,\n                    admin,\n                    new IntegerPolicyValue(passwordComplexity),\n                    affectedUser);\n        } else {\n            mDevicePolicyEngine.removeLocalPolicy(\n                    PolicyDefinition.PASSWORD_COMPLEXITY,\n                    admin,\n                    affectedUser);\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (activeAdmin != null) {\n                // Reset the password policy.\n                if (calledOnParent) {\n                    activeAdmin.getParentActiveAdmin().mPasswordPolicy = new PasswordPolicy();\n                } else {\n                    activeAdmin.mPasswordPolicy = new PasswordPolicy();\n                }\n                updatePasswordQualityCacheForUserGroup(caller.getUserId());\n            }\n\n            synchronized (getLockObject()) {\n                updatePasswordValidityCheckpointLocked(caller.getUserId(), calledOnParent);\n            }\n            saveSettingsLocked(caller.getUserId());\n        });\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_COMPLEXITY)\n                .setAdmin(caller.getPackageName())\n                .setInt(passwordComplexity)\n                .setBoolean(calledOnParent)\n                .write();\n        logPasswordComplexityRequiredIfSecurityLogEnabled(caller.getPackageName(),\n                caller.getUserId(), calledOnParent, passwordComplexity);\n    }\n\n    private void setRequiredPasswordComplexityPreCoexistence(\n            String callerPackageName, int passwordComplexity, boolean calledOnParent) {\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        Preconditions.checkArgument(!calledOnParent || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            admin = getParentOfAdminIfRequired(\n                    getProfileOwnerOrDeviceOwnerLocked(caller.getUserId()), calledOnParent);\n\n            if (admin.mPasswordComplexity != passwordComplexity) {\n                // We require the caller to explicitly clear any password quality requirements set\n                // on the parent DPM instance, to avoid the case where password requirements are\n                // specified in the form of quality on the parent but complexity on the profile\n                // itself.\n                if (!calledOnParent) {\n                    final boolean hasQualityRequirementsOnParent = admin.hasParentActiveAdmin()\n                            && admin.getParentActiveAdmin().mPasswordPolicy.quality\n                            != PASSWORD_QUALITY_UNSPECIFIED;\n                    Preconditions.checkState(!hasQualityRequirementsOnParent,\n                            \"Password quality is set on the parent when attempting to set password\"\n                            + \"complexity. Clear the quality by setting the password quality \"\n                            + \"on the parent to PASSWORD_QUALITY_UNSPECIFIED first\");\n                }\n\n                mInjector.binderWithCleanCallingIdentity(() -> {\n                    admin.mPasswordComplexity = passwordComplexity;\n                    // Reset the password policy.\n                    admin.mPasswordPolicy = new PasswordPolicy();\n                    updatePasswordValidityCheckpointLocked(caller.getUserId(), calledOnParent);\n                    updatePasswordQualityCacheForUserGroup(caller.getUserId());\n                    saveSettingsLocked(caller.getUserId());\n                });\n\n\n                //TODO(b/276855301): caller.getPackageName() will be null when the coexistence flags are\n                // turned off. Change back to caller.getPackageName once this API is unflagged.\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.SET_PASSWORD_COMPLEXITY)\n                        .setAdmin(admin.info.getPackageName())\n                        .setInt(passwordComplexity)\n                        .setBoolean(calledOnParent)\n                        .write();\n            }\n            logPasswordComplexityRequiredIfSecurityLogEnabled(caller.getPackageName(),\n                    caller.getUserId(), calledOnParent, passwordComplexity);\n        }\n    }\n\n    private void logPasswordComplexityRequiredIfSecurityLogEnabled(String adminPackageName,\n            int userId,\n            boolean parent, int complexity) {\n        if (SecurityLog.isLoggingEnabled()) {\n            final int affectedUserId = parent ? getProfileParentId(userId) : userId;\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_COMPLEXITY_REQUIRED,\n                    adminPackageName, userId, affectedUserId, complexity);\n        }\n    }\n    @GuardedBy(\"getLockObject()\")\n    private int getAggregatedPasswordComplexityLocked(@UserIdInt int userHandle) {\n        return getAggregatedPasswordComplexityLocked(userHandle, false);\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private int getAggregatedPasswordComplexityLocked(@UserIdInt int userHandle,\n            boolean deviceWideOnly) {\n        if (Flags.unmanagedModeMigration()) {\n            return getAggregatedPasswordComplexity(userHandle, deviceWideOnly);\n        } else {\n            return getAggregatedPasswordComplexityPreCoexistenceLocked(userHandle, deviceWideOnly);\n        }\n    }\n\n    private int getAggregatedPasswordComplexity(@UserIdInt int userHandle, boolean deviceWideOnly) {\n        ensureLocked();\n        Integer result;\n        if (deviceWideOnly) {\n            result = getResolvedPolicyForUserAndItsManagedProfiles(\n                    PolicyDefinition.PASSWORD_COMPLEXITY,\n                    userHandle,\n                    /* shouldIncludeProfile */ (user) -> false);\n        } else {\n            result = getResolvedLockscreenPolicy(PolicyDefinition.PASSWORD_COMPLEXITY, userHandle);\n        }\n        return result != null ? result : PASSWORD_COMPLEXITY_NONE;\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private int getAggregatedPasswordComplexityPreCoexistenceLocked(@UserIdInt int userHandle,\n            boolean deviceWideOnly) {\n        ensureLocked();\n        final List<ActiveAdmin> admins;\n        if (deviceWideOnly) {\n            admins = getActiveAdminsForUserAndItsManagedProfilesLocked(userHandle,\n                    /* shouldIncludeProfileAdmins */ (user) -> false);\n        } else {\n            admins = getActiveAdminsForLockscreenPoliciesLocked(userHandle);\n        }\n        int maxRequiredComplexity = PASSWORD_COMPLEXITY_NONE;\n        for (ActiveAdmin admin : admins) {\n            maxRequiredComplexity = Math.max(maxRequiredComplexity, admin.mPasswordComplexity);\n        }\n        return maxRequiredComplexity;\n    }\n\n    @Override\n    public int getRequiredPasswordComplexity(String callerPackageName, boolean calledOnParent) {\n        if (!mHasFeature) {\n            return PASSWORD_COMPLEXITY_NONE;\n        }\n\n        if (Flags.unmanagedModeMigration()) {\n            final CallerIdentity caller = getCallerIdentity(callerPackageName);\n            int affectedUser = calledOnParent ? getProfileParentId(caller.getUserId())\n                    : caller.getUserId();\n            enforcePermission(MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                    callerPackageName, affectedUser);\n\n            Integer complexity = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.PASSWORD_COMPLEXITY,\n                    affectedUser);\n            return complexity != null ? complexity : PASSWORD_COMPLEXITY_NONE;\n        } else {\n            final CallerIdentity caller = getCallerIdentity();\n\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n            Preconditions.checkArgument(!calledOnParent || isProfileOwner(caller));\n\n            synchronized (getLockObject()) {\n                final ActiveAdmin requiredAdmin = getParentOfAdminIfRequired(\n                        getDeviceOrProfileOwnerAdminLocked(caller.getUserId()), calledOnParent);\n                return requiredAdmin.mPasswordComplexity;\n            }\n        }\n    }\n\n    @Override\n    public int getAggregatedPasswordComplexityForUser(int userId, boolean deviceWideOnly) {\n        if (!mHasFeature) {\n            return PASSWORD_COMPLEXITY_NONE;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            return getAggregatedPasswordComplexityLocked(userId, deviceWideOnly);\n        }\n    }\n\n\n    @Override\n    public int getCurrentFailedPasswordAttempts(\n            String callerPackageName, int userHandle, boolean parent) {\n        if (!mLockPatternUtils.hasSecureLockScreen()) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            if (!isSystemUid(caller)) {\n                // This API can be called by an active device admin or by keyguard code.\n                if (!hasCallingPermission(permission.ACCESS_KEYGUARD_SECURE_STORAGE)) {\n                    getActiveAdminForCallerLocked(\n                            null, DeviceAdminInfo.USES_POLICY_WATCH_LOGIN, parent);\n                }\n            }\n\n            DevicePolicyData policy = getUserDataUnchecked(getCredentialOwner(userHandle, parent));\n\n            return policy.mFailedPasswordAttempts;\n        }\n    }\n\n    @Override\n    public void setMaximumFailedPasswordsForWipe(\n            ComponentName who, String callerPackageName, int num, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        int userId = mInjector.userHandleGetCallingUserId();\n        int affectedUserId = parent ? getProfileParentId(userId) : userId;\n\n        synchronized (getLockObject()) {\n            // This API can only be called by an active device admin,\n            // so try to retrieve it to check that the caller is one.\n            getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_WIPE_DATA, parent);\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_WATCH_LOGIN, parent);\n\n            if (ap.maximumFailedPasswordsForWipe != num) {\n                ap.maximumFailedPasswordsForWipe = num;\n                saveSettingsLocked(userId);\n            }\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_MAX_PASSWORD_ATTEMPTS_SET, callerPackageName,\n                    userId, affectedUserId, num);\n        }\n    }\n\n    @Override\n    public int getMaximumFailedPasswordsForWipe(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        // System caller can query policy for a particular admin.\n        Preconditions.checkCallAuthorization(\n                who == null || isCallingFromPackage(who.getPackageName(), caller.getUid())\n                        || canQueryAdminPolicy(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = (who != null)\n                    ? getActiveAdminUncheckedLocked(who, userHandle, parent)\n                    : getAdminWithMinimumFailedPasswordsForWipeLocked(userHandle, parent);\n            return admin != null ? admin.maximumFailedPasswordsForWipe : 0;\n        }\n    }\n\n    @Override\n    public int getProfileWithMinimumFailedPasswordsForWipe(int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return UserHandle.USER_NULL;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getAdminWithMinimumFailedPasswordsForWipeLocked(\n                    userHandle, parent);\n            return admin != null ? getUserIdToWipeForFailedPasswords(admin) : UserHandle.USER_NULL;\n        }\n    }\n\n    /**\n     * Returns the admin with the strictest policy on maximum failed passwords for:\n     * <ul>\n     *   <li>this user if it has a separate profile challenge, or\n     *   <li>this user and all profiles that don't have their own challenge otherwise.\n     * </ul>\n     * <p>If the policy for the primary and any other profile are equal, it returns the admin for\n     * the primary profile. Policy of a PO on an organization-owned device applies to the primary\n     * profile.\n     * Returns {@code null} if no participating admin has that policy set.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private ActiveAdmin getAdminWithMinimumFailedPasswordsForWipeLocked(\n            int userHandle, boolean parent) {\n        int count = 0;\n        ActiveAdmin strictestAdmin = null;\n\n        // Return the strictest policy across all participating admins.\n        List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                getProfileParentUserIfRequested(userHandle, parent));\n        final int N = admins.size();\n        for (int i = 0; i < N; i++) {\n            ActiveAdmin admin = admins.get(i);\n            if (admin.maximumFailedPasswordsForWipe ==\n                    ActiveAdmin.DEF_MAXIMUM_FAILED_PASSWORDS_FOR_WIPE) {\n                continue;  // No max number of failed passwords policy set for this profile.\n            }\n\n            // We always favor the primary profile if several profiles have the same value set.\n            final int userId = getUserIdToWipeForFailedPasswords(admin);\n            if (count == 0 ||\n                    count > admin.maximumFailedPasswordsForWipe ||\n                    (count == admin.maximumFailedPasswordsForWipe &&\n                            getUserInfo(userId).isPrimary())) {\n                count = admin.maximumFailedPasswordsForWipe;\n                strictestAdmin = admin;\n            }\n        }\n        return strictestAdmin;\n    }\n\n    private UserInfo getUserInfo(@UserIdInt int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() -> mUserManager.getUserInfo(userId));\n    }\n\n    private boolean setPasswordPrivileged(@NonNull String password, int flags,\n            CallerIdentity caller) {\n        // Only allow setting password on an unsecured user\n        if (isLockScreenSecureUnchecked(caller.getUserId())) {\n            throw new SecurityException(\"Cannot change current password\");\n        }\n        return resetPasswordInternal(password, 0, null, flags, caller);\n    }\n\n    @Override\n    public boolean resetPassword(@Nullable String password, int flags) throws RemoteException {\n        if (!mLockPatternUtils.hasSecureLockScreen()) {\n            Slogf.w(LOG_TAG, \"Cannot reset password when the device has no lock screen\");\n            return false;\n        }\n        if (password == null) password = \"\";\n        final CallerIdentity caller = getCallerIdentity();\n        final int userHandle = caller.getUserId();\n\n        // As of R, only privileged caller holding RESET_PASSWORD can call resetPassword() to\n        // set password to an unsecured user.\n        if (hasCallingPermission(permission.RESET_PASSWORD)) {\n            final boolean result = setPasswordPrivileged(password, flags, caller);\n            if (result) {\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.RESET_PASSWORD)\n                        .write();\n            }\n            return result;\n        }\n\n        // If caller has PO (or DO) throw or fail silently depending on its target SDK level.\n        if (isDefaultDeviceOwner(caller) || isProfileOwner(caller)) {\n            synchronized (getLockObject()) {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n                if (getTargetSdk(admin.info.getPackageName(), userHandle) < Build.VERSION_CODES.O) {\n                    Slogf.e(LOG_TAG, \"DPC can no longer call resetPassword()\");\n                    return false;\n                }\n                throw new SecurityException(\"Device admin can no longer call resetPassword()\");\n            }\n        }\n\n        // Caller is not DO or PO, could either be unauthorized or Device Admin.\n        synchronized (getLockObject()) {\n            // Legacy device admin cannot call resetPassword either\n            ActiveAdmin admin = getActiveAdminForCallerLocked(\n                    null, DeviceAdminInfo.USES_POLICY_RESET_PASSWORD, false);\n            Preconditions.checkCallAuthorization(admin != null,\n                    \"Unauthorized caller cannot call resetPassword.\");\n            if (getTargetSdk(admin.info.getPackageName(),\n                    userHandle) <= Build.VERSION_CODES.M) {\n                Slogf.e(LOG_TAG, \"Device admin can no longer call resetPassword()\");\n                return false;\n            }\n            throw new SecurityException(\"Device admin can no longer call resetPassword()\");\n        }\n    }\n\n    private boolean resetPasswordInternal(String password, long tokenHandle, byte[] token,\n            int flags, CallerIdentity caller) {\n        final int callingUid = caller.getUid();\n        final int userHandle = UserHandle.getUserId(callingUid);\n        final boolean isPin = PasswordMetrics.isNumericOnly(password);\n        final LockscreenCredential newCredential;\n        if (isPin) {\n            newCredential = LockscreenCredential.createPin(password);\n        } else {\n            newCredential = LockscreenCredential.createPasswordOrNone(password);\n        }\n        synchronized (getLockObject()) {\n            final PasswordMetrics minMetrics = getPasswordMinimumMetricsUnchecked(userHandle);\n            final int complexity = getAggregatedPasswordComplexityLocked(userHandle);\n            final List<PasswordValidationError> validationErrors =\n                    PasswordMetrics.validateCredential(minMetrics, complexity, newCredential);\n            if (!validationErrors.isEmpty()) {\n                Slogf.w(LOG_TAG, \"Failed to reset password due to constraint violation: %s\",\n                        validationErrors.get(0));\n                return false;\n            }\n        }\n\n        DevicePolicyData policy = getUserData(userHandle);\n        if (policy.mPasswordOwner >= 0 && policy.mPasswordOwner != callingUid) {\n            Slogf.w(LOG_TAG, \"resetPassword: already set by another uid and not entered by user\");\n            return false;\n        }\n\n        boolean callerIsDeviceOwnerAdmin = isDefaultDeviceOwner(caller);\n        boolean doNotAskCredentialsOnBoot =\n                (flags & DevicePolicyManager.RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT) != 0;\n        if (callerIsDeviceOwnerAdmin && doNotAskCredentialsOnBoot) {\n            setDoNotAskCredentialsOnBoot();\n        }\n\n        // Don't do this with the lock held, because it is going to call\n        // back in to the service.\n        final long ident = mInjector.binderClearCallingIdentity();\n        try {\n            if (tokenHandle == 0 || token == null) {\n                if (!mLockPatternUtils.setLockCredential(newCredential,\n                        LockscreenCredential.createNone(), userHandle)) {\n                    return false;\n                }\n            } else {\n                if (!mLockPatternUtils.setLockCredentialWithToken(newCredential, tokenHandle,\n                        token, userHandle)) {\n                    return false;\n                }\n            }\n            boolean requireEntry = (flags & DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY) != 0;\n            if (requireEntry) {\n                mLockPatternUtils.requireStrongAuth(STRONG_AUTH_REQUIRED_AFTER_DPM_LOCK_NOW,\n                        UserHandle.USER_ALL);\n            }\n            synchronized (getLockObject()) {\n                int newOwner = requireEntry ? callingUid : -1;\n                if (policy.mPasswordOwner != newOwner) {\n                    policy.mPasswordOwner = newOwner;\n                    saveSettingsLocked(userHandle);\n                }\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n        return true;\n    }\n\n    private boolean isLockScreenSecureUnchecked(int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() -> mLockPatternUtils.isSecure(userId));\n    }\n\n    private void setDoNotAskCredentialsOnBoot() {\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(UserHandle.USER_SYSTEM);\n            if (!policyData.mDoNotAskCredentialsOnBoot) {\n                policyData.mDoNotAskCredentialsOnBoot = true;\n                saveSettingsLocked(UserHandle.USER_SYSTEM);\n            }\n        }\n    }\n\n    @Override\n    public boolean getDoNotAskCredentialsOnBoot() {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.QUERY_DO_NOT_ASK_CREDENTIALS_ON_BOOT));\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(UserHandle.USER_SYSTEM);\n            return policyData.mDoNotAskCredentialsOnBoot;\n        }\n    }\n\n    @Override\n    public void setMaximumTimeToLock(ComponentName who, String callerPackageName,\n            long timeMs, boolean parent) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        int userHandle = mInjector.userHandleGetCallingUserId();\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_FORCE_LOCK, parent);\n\n            if (ap.maximumTimeToUnlock != timeMs) {\n                ap.maximumTimeToUnlock = timeMs;\n                saveSettingsLocked(userHandle);\n                updateMaximumTimeToLockLocked(userHandle);\n            }\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_MAX_SCREEN_LOCK_TIMEOUT_SET,\n                    callerPackageName, userHandle, affectedUserId, timeMs);\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void updateMaximumTimeToLockLocked(@UserIdInt int userId) {\n        // Update the profile's timeout\n        if (isManagedProfile(userId)) {\n            updateProfileLockTimeoutLocked(userId);\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            // Update the device timeout\n            final int parentId = getProfileParentId(userId);\n            final long timeMs = getMaximumTimeToLockPolicyFromAdmins(\n                    getActiveAdminsForLockscreenPoliciesLocked(parentId));\n\n            final DevicePolicyData policy = getUserDataUnchecked(parentId);\n            if (policy.mLastMaximumTimeToLock == timeMs) {\n                return;\n            }\n            policy.mLastMaximumTimeToLock = timeMs;\n\n            if (policy.mLastMaximumTimeToLock != Long.MAX_VALUE) {\n                // Make sure KEEP_SCREEN_ON is disabled, since that\n                // would allow bypassing of the maximum time to lock.\n                mInjector.settingsGlobalPutInt(Global.STAY_ON_WHILE_PLUGGED_IN, 0);\n            }\n            getPowerManagerInternal().setMaximumScreenOffTimeoutFromDeviceAdmin(parentId, timeMs);\n        });\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void updateProfileLockTimeoutLocked(@UserIdInt int userId) {\n        final long timeMs;\n        if (isSeparateProfileChallengeEnabled(userId)) {\n            timeMs = getMaximumTimeToLockPolicyFromAdmins(\n                    getActiveAdminsForLockscreenPoliciesLocked(userId));\n        } else {\n            timeMs = Long.MAX_VALUE;\n        }\n\n        final DevicePolicyData policy = getUserDataUnchecked(userId);\n        if (policy.mLastMaximumTimeToLock == timeMs) {\n            return;\n        }\n        policy.mLastMaximumTimeToLock = timeMs;\n\n        mInjector.binderWithCleanCallingIdentity(() ->\n                getPowerManagerInternal().setMaximumScreenOffTimeoutFromDeviceAdmin(\n                        userId, policy.mLastMaximumTimeToLock));\n    }\n\n    @Override\n    public long getMaximumTimeToLock(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        // System caller can query policy for a particular admin.\n        Preconditions.checkCallAuthorization(\n                who == null || isCallingFromPackage(who.getPackageName(), caller.getUid())\n                        || canQueryAdminPolicy(caller));\n\n        synchronized (getLockObject()) {\n            if (who != null) {\n                final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                return admin != null ? admin.maximumTimeToUnlock : 0;\n            }\n            // Return the strictest policy across all participating admins.\n            final List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            final long timeMs = getMaximumTimeToLockPolicyFromAdmins(admins);\n            return timeMs == Long.MAX_VALUE ? 0 : timeMs;\n        }\n    }\n\n    private long getMaximumTimeToLockPolicyFromAdmins(List<ActiveAdmin> admins) {\n        long time = Long.MAX_VALUE;\n        for (final ActiveAdmin admin : admins) {\n            if (admin.maximumTimeToUnlock > 0 && admin.maximumTimeToUnlock < time) {\n                time = admin.maximumTimeToUnlock;\n            }\n        }\n        return time;\n    }\n\n    @Override\n    public void setRequiredStrongAuthTimeout(ComponentName who, String callerPackageName, long timeoutMs,\n            boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n\n        Preconditions.checkArgument(timeoutMs >= 0, \"Timeout must not be a negative number.\");\n        CallerIdentity caller = getCallerIdentity(who);\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        // timeoutMs with value 0 means that the admin doesn't participate\n        // timeoutMs is clamped to the interval in case the internal constants change in the future\n        final long minimumStrongAuthTimeout = getMinimumStrongAuthTimeoutMs();\n        if (timeoutMs != 0 && timeoutMs < minimumStrongAuthTimeout) {\n            timeoutMs = minimumStrongAuthTimeout;\n        }\n        if (timeoutMs > DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS) {\n            timeoutMs = DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS;\n        }\n\n        final int userHandle = caller.getUserId();\n        boolean changed = false;\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getParentOfAdminIfRequired(\n                    getProfileOwnerOrDeviceOwnerLocked(caller.getUserId()), parent);\n            if (ap.strongAuthUnlockTimeout != timeoutMs) {\n                ap.strongAuthUnlockTimeout = timeoutMs;\n                saveSettingsLocked(userHandle);\n                changed = true;\n            }\n        }\n        if (changed) {\n            mLockSettingsInternal.refreshStrongAuthTimeout(userHandle);\n            // Refreshes the parent if profile has unified challenge, since the timeout would\n            // also affect the parent user in this case.\n            if (isManagedProfile(userHandle) && !isSeparateProfileChallengeEnabled(userHandle)) {\n                mLockSettingsInternal.refreshStrongAuthTimeout(getProfileParentId(userHandle));\n            }\n        }\n    }\n\n    /**\n     * Return a single admin's strong auth unlock timeout or minimum value (strictest) of all\n     * admins if who is null.\n     * Returns 0 if not configured for the provided admin.\n     */\n    @Override\n    public long getRequiredStrongAuthTimeout(ComponentName who, int userId, boolean parent) {\n        if (!mHasFeature) {\n            return DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS;\n        }\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userId));\n\n        if (!mLockPatternUtils.hasSecureLockScreen()) {\n            // No strong auth timeout on devices not supporting the\n            // {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature\n            return 0;\n        }\n        synchronized (getLockObject()) {\n            if (who != null) {\n                ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userId, parent);\n                return admin != null ? admin.strongAuthUnlockTimeout : 0;\n            }\n\n            // Return the strictest policy across all participating admins.\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userId, parent));\n\n            long strongAuthUnlockTimeout = DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS;\n            for (int i = 0; i < admins.size(); i++) {\n                final long timeout = admins.get(i).strongAuthUnlockTimeout;\n                if (timeout != 0) { // take only participating admins into account\n                    strongAuthUnlockTimeout = Math.min(timeout, strongAuthUnlockTimeout);\n                }\n            }\n            return Math.max(strongAuthUnlockTimeout, getMinimumStrongAuthTimeoutMs());\n        }\n    }\n\n    private long getMinimumStrongAuthTimeoutMs() {\n        if (!mInjector.isBuildDebuggable()) {\n            return MINIMUM_STRONG_AUTH_TIMEOUT_MS;\n        }\n        // ideally the property was named persist.sys.min_strong_auth_timeout, but system property\n        // name cannot be longer than 31 characters\n        return Math.min(mInjector.systemPropertiesGetLong(\"persist.sys.min_str_auth_timeo\",\n                MINIMUM_STRONG_AUTH_TIMEOUT_MS),\n                MINIMUM_STRONG_AUTH_TIMEOUT_MS);\n    }\n\n    @Override\n    public void lockNow(int flags, String callerPackageName, boolean parent) {\n        CallerIdentity caller;\n        if (Flags.lockNowCoexistence()) {\n            caller = getCallerIdentity(callerPackageName);\n        } else {\n            caller = getCallerIdentity();\n        }\n\n        final int callingUserId = caller.getUserId();\n        ComponentName adminComponent = null;\n        synchronized (getLockObject()) {\n            // Make sure the caller has any active admin with the right policy or\n            // the required permission.\n            if (Flags.lockNowCoexistence()) {\n                EnforcingAdmin enforcingAdmin = enforcePermissionsAndGetEnforcingAdmin(\n                        /* admin= */ null,\n                        /* permissions= */ new String[]{MANAGE_DEVICE_POLICY_LOCK, LOCK_DEVICE},\n                        /* deviceAdminPolicy= */ USES_POLICY_FORCE_LOCK,\n                        caller.getPackageName(),\n                        getAffectedUser(parent)\n                );\n                adminComponent = enforcingAdmin.getComponentName();\n            } else {\n                ActiveAdmin admin = getActiveAdminOrCheckPermissionForCallerLocked(\n                        null,\n                        USES_POLICY_FORCE_LOCK,\n                        parent,\n                        LOCK_DEVICE);\n                adminComponent = admin == null ? null : admin.info.getComponent();\n            }\n            checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_LOCK_NOW);\n            final long ident = mInjector.binderClearCallingIdentity();\n            try {\n                if (adminComponent != null) {\n                    // For Profile Owners only, callers with only permission not allowed.\n                    if ((flags & DevicePolicyManager.FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY) != 0) {\n                        // Evict key\n                        Preconditions.checkCallingUser(isManagedProfile(callingUserId));\n                        Preconditions.checkArgument(!parent,\n                                \"Cannot set FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY for the parent\");\n                        if (!isProfileOwner(adminComponent, callingUserId)) {\n                            throw new SecurityException(\"Only profile owner admins can set \"\n                                    + \"FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY\");\n                        }\n                        if (!mInjector.storageManagerIsFileBasedEncryptionEnabled()) {\n                            throw new UnsupportedOperationException(\n                                    \"FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY only applies to FBE\"\n                                        + \" devices\");\n                        }\n                        mUserManager.evictCredentialEncryptionKey(callingUserId);\n                    }\n                }\n\n                // Lock all users unless this is a managed profile with a separate challenge\n                final int userToLock = (parent || !isSeparateProfileChallengeEnabled(callingUserId)\n                        ? UserHandle.USER_ALL : callingUserId);\n                mLockPatternUtils.requireStrongAuth(\n                        STRONG_AUTH_REQUIRED_AFTER_DPM_LOCK_NOW, userToLock);\n\n                // Require authentication for the device or profile\n                if (userToLock == UserHandle.USER_ALL) {\n                    if (mIsAutomotive) {\n                        if (VERBOSE_LOG) {\n                            Slogf.v(LOG_TAG, \"lockNow(): not powering off display on automotive\"\n                                    + \" build\");\n                        }\n                    } else {\n                        // Power off the display\n                        mInjector.powerManagerGoToSleep(SystemClock.uptimeMillis(),\n                                PowerManager.GO_TO_SLEEP_REASON_DEVICE_ADMIN, 0);\n                    }\n                    mInjector.getIWindowManager().lockNow(null);\n                } else {\n                    mInjector.getTrustManager().setDeviceLockedForUser(userToLock, true);\n                }\n\n                if (SecurityLog.isLoggingEnabled() && adminComponent != null) {\n                    final int affectedUserId =\n                            parent ? getProfileParentId(callingUserId) : callingUserId;\n                    SecurityLog.writeEvent(SecurityLog.TAG_REMOTE_LOCK,\n                            adminComponent.getPackageName(), callingUserId, affectedUserId);\n                }\n            } catch (RemoteException e) {\n            } finally {\n                mInjector.binderRestoreCallingIdentity(ident);\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.LOCK_NOW)\n                .setAdmin(adminComponent)\n                .setInt(flags)\n                .write();\n    }\n\n    @Override\n    public void enforceCanManageCaCerts(ComponentName who, String callerPackage) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization(canManageCaCerts(caller));\n    }\n\n    private boolean canManageCaCerts(CallerIdentity caller) {\n        return (caller.hasAdminComponent() && (isDefaultDeviceOwner(caller)\n                || isProfileOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_CERT_INSTALL))\n                || hasCallingOrSelfPermission(MANAGE_CA_CERTIFICATES);\n    }\n\n    @Override\n    public boolean approveCaCert(String alias, int userId, boolean approval) {\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            Set<String> certs = getUserData(userId).mAcceptedCaCertificates;\n            boolean changed = (approval ? certs.add(alias) : certs.remove(alias));\n            if (!changed) {\n                return false;\n            }\n            saveSettingsLocked(userId);\n        }\n        mCertificateMonitor.onCertificateApprovalsChanged(userId);\n        return true;\n    }\n\n    @Override\n    public boolean isCaCertApproved(String alias, int userId) {\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            return getUserData(userId).mAcceptedCaCertificates.contains(alias);\n        }\n    }\n\n    private Set<Integer> removeCaApprovalsIfNeeded(int userId) {\n        final ArraySet<Integer> affectedUserIds = new ArraySet<>();\n        for (UserInfo userInfo : mUserManager.getProfiles(userId)) {\n            boolean isSecure = mLockPatternUtils.isSecure(userInfo.id);\n            if (userInfo.isManagedProfile()){\n                isSecure |= mLockPatternUtils.isSecure(getProfileParentId(userInfo.id));\n            }\n            if (!isSecure) {\n                synchronized (getLockObject()) {\n                    getUserData(userInfo.id).mAcceptedCaCertificates.clear();\n                    affectedUserIds.add(userInfo.id);\n                }\n                mCertificateMonitor.onCertificateApprovalsChanged(userId);\n            }\n        }\n        return affectedUserIds;\n    }\n\n    @Override\n    public boolean installCaCert(ComponentName admin, String callerPackage, byte[] certBuffer) {\n        if (!mHasFeature) {\n            return false;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        Preconditions.checkCallAuthorization(canManageCaCerts(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_INSTALL_CA_CERT);\n\n        final String alias = mInjector.binderWithCleanCallingIdentity(() -> {\n            String installedAlias = mCertificateMonitor.installCaCert(\n                    caller.getUserHandle(), certBuffer);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.INSTALL_CA_CERT)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ admin == null)\n                    .write();\n\n            if (mInjector.isAdminInstalledCaCertAutoApproved()\n                    && installedAlias != null\n                    && admin != null) {\n                // If device admin called this, approve cert to avoid notifications\n                Slogf.i(LOG_TAG, \"Approving admin installed cert\");\n                approveCaCert(\n                        installedAlias,\n                        caller.getUserId(),\n                        /* approved */ true);\n            }\n\n            return installedAlias;\n        });\n\n        if (alias == null) {\n            Slogf.w(LOG_TAG, \"Problem installing cert\");\n            return false;\n        }\n\n        synchronized (getLockObject()) {\n            getUserData(caller.getUserId()).mOwnerInstalledCaCerts.add(alias);\n            saveSettingsLocked(caller.getUserId());\n        }\n        return true;\n    }\n\n    @Override\n    public void uninstallCaCerts(ComponentName admin, String callerPackage, String[] aliases) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        Preconditions.checkCallAuthorization(canManageCaCerts(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_UNINSTALL_CA_CERT);\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            mCertificateMonitor.uninstallCaCerts(caller.getUserHandle(), aliases);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.UNINSTALL_CA_CERTS)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ admin == null)\n                    .write();\n        });\n\n        synchronized (getLockObject()) {\n            if (getUserData(caller.getUserId()).mOwnerInstalledCaCerts.removeAll(\n                    Arrays.asList(aliases))) {\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public boolean installKeyPair(ComponentName who, String callerPackage, byte[] privKey,\n            byte[] cert, byte[] chain, String alias, boolean requestAccess,\n            boolean isUserSelectable) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        final boolean isCallerDelegate = isCallerDelegate(caller, DELEGATION_CERT_INSTALL);\n        final boolean isCredentialManagementApp = isCredentialManagementApp(caller);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && (isCallerDelegate || isCredentialManagementApp)));\n        if (isCredentialManagementApp) {\n            Preconditions.checkCallAuthorization(!isUserSelectable, \"The credential \"\n                    + \"management app is not allowed to install a user selectable key pair\");\n            Preconditions.checkCallAuthorization(\n                    isAliasInCredentialManagementAppPolicy(caller, alias),\n                    CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG);\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_INSTALL_KEY_PAIR);\n\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            try (KeyChainConnection keyChainConnection =\n                         KeyChain.bindAsUser(mContext, caller.getUserHandle())) {\n                IKeyChainService keyChain = keyChainConnection.getService();\n                if (!keyChain.installKeyPair(privKey, cert, chain, alias, KeyProperties.UID_SELF)) {\n                    logInstallKeyPairFailure(caller, isCredentialManagementApp);\n                    return false;\n                }\n                if (requestAccess) {\n                    keyChain.setGrant(caller.getUid(), alias, true);\n                }\n                keyChain.setUserSelectable(alias, isUserSelectable);\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.INSTALL_KEY_PAIR)\n                        .setAdmin(caller.getPackageName())\n                        .setBoolean(/* isDelegate */ isCallerDelegate)\n                        .setStrings(isCredentialManagementApp\n                                ? CREDENTIAL_MANAGEMENT_APP : NOT_CREDENTIAL_MANAGEMENT_APP)\n                        .write();\n                return true;\n            } catch (RemoteException | AssertionError e) {\n                Slogf.e(LOG_TAG, \"Installing certificate\", e);\n            }\n        } catch (InterruptedException e) {\n            Slogf.w(LOG_TAG, \"Interrupted while installing certificate\", e);\n            Thread.currentThread().interrupt();\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        logInstallKeyPairFailure(caller, isCredentialManagementApp);\n        return false;\n    }\n\n    private void logInstallKeyPairFailure(CallerIdentity caller,\n            boolean isCredentialManagementApp) {\n        if (!isCredentialManagementApp) {\n            return;\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.CREDENTIAL_MANAGEMENT_APP_INSTALL_KEY_PAIR_FAILED)\n                .setStrings(caller.getPackageName())\n                .write();\n    }\n\n    @Override\n    public boolean removeKeyPair(ComponentName who, String callerPackage, String alias) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        final boolean isCallerDelegate = isCallerDelegate(caller, DELEGATION_CERT_INSTALL);\n        final boolean isCredentialManagementApp = isCredentialManagementApp(caller);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && (isCallerDelegate || isCredentialManagementApp)));\n        if (isCredentialManagementApp) {\n            Preconditions.checkCallAuthorization(\n                    isAliasInCredentialManagementAppPolicy(caller, alias),\n                    CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG);\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_REMOVE_KEY_PAIR);\n\n        final long id = Binder.clearCallingIdentity();\n        try {\n            try (KeyChainConnection keyChainConnection =\n                         KeyChain.bindAsUser(mContext, caller.getUserHandle())) {\n                IKeyChainService keyChain = keyChainConnection.getService();\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.REMOVE_KEY_PAIR)\n                        .setAdmin(caller.getPackageName())\n                        .setBoolean(/* isDelegate */ isCallerDelegate)\n                        .setStrings(isCredentialManagementApp\n                                ? CREDENTIAL_MANAGEMENT_APP : NOT_CREDENTIAL_MANAGEMENT_APP)\n                        .write();\n                return keyChain.removeKeyPair(alias);\n            } catch (RemoteException | AssertionError e) {\n                Slogf.e(LOG_TAG, \"Removing keypair\", e);\n            }\n        } catch (InterruptedException e) {\n            Slogf.w(LOG_TAG, \"Interrupted while removing keypair\", e);\n            Thread.currentThread().interrupt();\n        } finally {\n            Binder.restoreCallingIdentity(id);\n        }\n        return false;\n    }\n\n    @Override\n    public boolean hasKeyPair(String callerPackage, String alias) {\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        final boolean isCredentialManagementApp = isCredentialManagementApp(caller);\n        Preconditions.checkCallAuthorization(canInstallCertificates(caller)\n                || isCredentialManagementApp);\n        if (isCredentialManagementApp) {\n            Preconditions.checkCallAuthorization(\n                    isAliasInCredentialManagementAppPolicy(caller, alias),\n                    CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG);\n        }\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try (KeyChainConnection keyChainConnection =\n                         KeyChain.bindAsUser(mContext, caller.getUserHandle())) {\n                return keyChainConnection.getService().containsKeyPair(alias);\n            } catch (RemoteException | AssertionError e) {\n                Slogf.e(LOG_TAG, \"Querying keypair\", e);\n            } catch (InterruptedException e) {\n                Slogf.w(LOG_TAG, \"Interrupted while querying keypair\", e);\n                Thread.currentThread().interrupt();\n            }\n            return false;\n        });\n    }\n\n    private boolean canInstallCertificates(CallerIdentity caller) {\n        return isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                || isCallerDelegate(caller, DELEGATION_CERT_INSTALL);\n    }\n\n    private boolean canChooseCertificates(CallerIdentity caller) {\n        return isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                || isCallerDelegate(caller, DELEGATION_CERT_SELECTION);\n    }\n\n    @Override\n    public boolean setKeyGrantToWifiAuth(String callerPackage, String alias, boolean hasGrant) {\n        Preconditions.checkStringNotEmpty(alias, \"Alias to grant cannot be empty\");\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(canChooseCertificates(caller));\n        try {\n            return setKeyChainGrantInternal(\n                    alias, hasGrant, Process.WIFI_UID, caller.getUserHandle());\n        } catch (IllegalArgumentException e) {\n            if (mInjector.isChangeEnabled(THROW_EXCEPTION_WHEN_KEY_MISSING, caller.getPackageName(),\n                    caller.getUserId())) {\n                throw e;\n            }\n            return false;\n        }\n    }\n\n    @Override\n    public boolean isKeyPairGrantedToWifiAuth(String callerPackage, String alias) {\n        Preconditions.checkStringNotEmpty(alias, \"Alias to check cannot be empty\");\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(canChooseCertificates(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try (KeyChainConnection keyChainConnection =\n                         KeyChain.bindAsUser(mContext, caller.getUserHandle())) {\n                final List<String> result = new ArrayList<>();\n                final int[] granteeUids = keyChainConnection.getService().getGrants(alias);\n\n                for (final int uid : granteeUids) {\n                    if (uid == Process.WIFI_UID) {\n                        return true;\n                    }\n                }\n                return false;\n            } catch (RemoteException | AssertionError e) {\n                Slogf.e(LOG_TAG, \"Querying grant to wifi auth.\", e);\n                return false;\n            }\n        });\n    }\n\n    @Override\n    public boolean setKeyGrantForApp(ComponentName who, String callerPackage, String alias,\n            String packageName, boolean hasGrant) {\n        Preconditions.checkStringNotEmpty(alias, \"Alias to grant cannot be empty\");\n        Preconditions.checkStringNotEmpty(packageName, \"Package to grant to cannot be empty\");\n\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_CERT_SELECTION)));\n\n        final int granteeUid;\n        try {\n            ApplicationInfo ai = mInjector.getIPackageManager().getApplicationInfo(\n                    packageName, 0, caller.getUserId());\n            Preconditions.checkArgument(ai != null,\n                    \"Provided package %s is not installed\", packageName);\n            granteeUid = ai.uid;\n        } catch (RemoteException e) {\n            throw new IllegalStateException(\"Failure getting grantee uid\", e);\n        }\n        try {\n            return setKeyChainGrantInternal(alias, hasGrant, granteeUid, caller.getUserHandle());\n        } catch (IllegalArgumentException e) {\n            if (mInjector.isChangeEnabled(THROW_EXCEPTION_WHEN_KEY_MISSING, callerPackage,\n                    caller.getUserId())) {\n                throw e;\n            }\n            return false;\n        }\n    }\n\n    private boolean setKeyChainGrantInternal(String alias, boolean hasGrant, int granteeUid,\n            UserHandle userHandle) {\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            try (KeyChainConnection keyChainConnection =\n                         KeyChain.bindAsUser(mContext, userHandle)) {\n                IKeyChainService keyChain = keyChainConnection.getService();\n                return keyChain.setGrant(granteeUid, alias, hasGrant);\n            } catch (RemoteException | AssertionError e) {\n                Slogf.e(LOG_TAG, \"Setting grant for package.\", e);\n                return false;\n            }\n        } catch (InterruptedException e) {\n            Slogf.w(LOG_TAG, \"Interrupted while setting key grant\", e);\n            Thread.currentThread().interrupt();\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        return false;\n    }\n\n    @Override\n    public ParcelableGranteeMap getKeyPairGrants(String callerPackage, String alias) {\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(canChooseCertificates(caller));\n\n        final ArrayMap<Integer, Set<String>> result = new ArrayMap<>();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            try (KeyChainConnection keyChainConnection =\n                         KeyChain.bindAsUser(mContext, caller.getUserHandle())) {\n                final int[] granteeUids = keyChainConnection.getService().getGrants(alias);\n                final PackageManager pm = mInjector.getPackageManager(caller.getUserId());\n\n                for (final int uid : granteeUids) {\n                    final String[] packages = pm.getPackagesForUid(uid);\n                    if (packages == null) {\n                        Slogf.wtf(LOG_TAG, \"No packages found for uid \" + uid);\n                        continue;\n                    }\n                    result.put(uid, new ArraySet<String>(packages));\n                }\n            } catch (RemoteException | AssertionError e) {\n                Slogf.e(LOG_TAG, \"Querying keypair grants\", e);\n            } catch (InterruptedException e) {\n                Slogf.w(LOG_TAG, \"Interrupted while querying keypair grants\", e);\n                Thread.currentThread().interrupt();\n            }\n        });\n        return new ParcelableGranteeMap(result);\n    }\n\n    @VisibleForTesting\n    public static int[] translateIdAttestationFlags(\n            int idAttestationFlags) {\n        Map<Integer, Integer> idTypeToAttestationFlag = new HashMap();\n        idTypeToAttestationFlag.put(ID_TYPE_SERIAL, AttestationUtils.ID_TYPE_SERIAL);\n        idTypeToAttestationFlag.put(ID_TYPE_IMEI, AttestationUtils.ID_TYPE_IMEI);\n        idTypeToAttestationFlag.put(ID_TYPE_MEID, AttestationUtils.ID_TYPE_MEID);\n        idTypeToAttestationFlag.put(\n                ID_TYPE_INDIVIDUAL_ATTESTATION, USE_INDIVIDUAL_ATTESTATION);\n\n        int numFlagsSet = Integer.bitCount(idAttestationFlags);\n        // No flags are set - return null to indicate no device ID attestation information should\n        // be included in the attestation record.\n        if (numFlagsSet == 0) {\n            return null;\n        }\n\n        // If the ID_TYPE_BASE_INFO is set, make sure that a non-null array is returned, even if\n        // no other flag is set. That will lead to inclusion of general device make data in the\n        // attestation record, but no specific device identifiers.\n        if ((idAttestationFlags & ID_TYPE_BASE_INFO) != 0) {\n            numFlagsSet -= 1;\n            idAttestationFlags = idAttestationFlags & (~ID_TYPE_BASE_INFO);\n        }\n\n        int[] attestationUtilsFlags = new int[numFlagsSet];\n        int i = 0;\n        for (Integer idType: idTypeToAttestationFlag.keySet()) {\n            if ((idType & idAttestationFlags) != 0) {\n                attestationUtilsFlags[i++] = idTypeToAttestationFlag.get(idType);\n            }\n        }\n\n        return attestationUtilsFlags;\n    }\n\n    @Override\n    public boolean generateKeyPair(ComponentName who, String callerPackage, String algorithm,\n            ParcelableKeyGenParameterSpec parcelableKeySpec, int idAttestationFlags,\n            KeymasterCertificateChain attestationChain) {\n        // Get attestation flags, if any.\n        final int[] attestationUtilsFlags = translateIdAttestationFlags(idAttestationFlags);\n        final boolean deviceIdAttestationRequired = attestationUtilsFlags != null;\n        KeyGenParameterSpec keySpec = parcelableKeySpec.getSpec();\n        final String alias = keySpec.getKeystoreAlias();\n        Preconditions.checkStringNotEmpty(alias, \"Empty alias provided\");\n        Preconditions.checkArgument(\n                !deviceIdAttestationRequired || keySpec.getAttestationChallenge() != null,\n                \"Requested Device ID attestation but challenge is empty\");\n\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        final boolean isCallerDelegate = isCallerDelegate(caller, DELEGATION_CERT_INSTALL);\n        final boolean isCredentialManagementApp = isCredentialManagementApp(caller);\n        if (deviceIdAttestationRequired && attestationUtilsFlags.length > 0) {\n            Preconditions.checkCallAuthorization(hasDeviceIdAccessUnchecked(\n                    caller.getPackageName(), caller.getUid()));\n            enforceIndividualAttestationSupportedIfRequested(attestationUtilsFlags);\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent() && (isProfileOwner(\n                    caller) || isDefaultDeviceOwner(caller))) || (caller.hasPackage() && (\n                    isCallerDelegate || isCredentialManagementApp)));\n            if (isCredentialManagementApp) {\n                Preconditions.checkCallAuthorization(\n                        isAliasInCredentialManagementAppPolicy(caller, alias),\n                        CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG);\n            }\n        }\n\n        if (TextUtils.isEmpty(alias)) {\n            throw new IllegalArgumentException(\"Empty alias provided.\");\n        }\n        // As the caller will be granted access to the key, ensure no UID was specified, as\n        // it will not have the desired effect.\n        if (keySpec.getUid() != KeyProperties.UID_SELF) {\n            Slogf.e(LOG_TAG, \"Only the caller can be granted access to the generated keypair.\");\n            logGenerateKeyPairFailure(caller, isCredentialManagementApp);\n            return false;\n        }\n\n        if (deviceIdAttestationRequired) {\n            if (keySpec.getAttestationChallenge() == null) {\n                throw new IllegalArgumentException(\n                        \"Requested Device ID attestation but challenge is empty.\");\n            }\n            KeyGenParameterSpec.Builder specBuilder = new KeyGenParameterSpec.Builder(keySpec);\n            specBuilder.setAttestationIds(attestationUtilsFlags);\n            specBuilder.setDevicePropertiesAttestationIncluded(true);\n            keySpec = specBuilder.build();\n        }\n\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            try (KeyChainConnection keyChainConnection =\n                    KeyChain.bindAsUser(mContext, caller.getUserHandle())) {\n                IKeyChainService keyChain = keyChainConnection.getService();\n\n                final int generationResult = keyChain.generateKeyPair(algorithm,\n                        new ParcelableKeyGenParameterSpec(keySpec));\n                if (generationResult != KeyChain.KEY_GEN_SUCCESS) {\n                    Slogf.e(LOG_TAG, \"KeyChain failed to generate a keypair, error %d.\",\n                            generationResult);\n                    logGenerateKeyPairFailure(caller, isCredentialManagementApp);\n                    switch (generationResult) {\n                        case KeyChain.KEY_GEN_STRONGBOX_UNAVAILABLE:\n                            throw new ServiceSpecificException(\n                                    DevicePolicyManager.KEY_GEN_STRONGBOX_UNAVAILABLE,\n                                    String.format(\"KeyChain error: %d\", generationResult));\n                        case KeyChain.KEY_ATTESTATION_CANNOT_ATTEST_IDS:\n                            throw new UnsupportedOperationException(\n                                \"Device does not support Device ID attestation.\");\n                        default:\n                            return false;\n                    }\n                }\n\n                // Set a grant for the caller here so that when the client calls\n                // requestPrivateKey, it will be able to get the key from Keystore.\n                // Note the use of the calling  UID, since the request for the private\n                // key will come from the client's process, so the grant has to be for\n                // that UID.\n                keyChain.setGrant(caller.getUid(), alias, true);\n\n                try {\n                    final List<byte[]> encodedCerts = new ArrayList();\n                    final CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n                    final byte[] certChainBytes = keyChain.getCaCertificates(alias);\n                    encodedCerts.add(keyChain.getCertificate(alias));\n                    if (certChainBytes != null) {\n                        final Collection<X509Certificate> certs =\n                                (Collection<X509Certificate>) certFactory.generateCertificates(\n                                    new ByteArrayInputStream(certChainBytes));\n                        for (X509Certificate cert : certs) {\n                            encodedCerts.add(cert.getEncoded());\n                        }\n                    }\n\n                    attestationChain.shallowCopyFrom(new KeymasterCertificateChain(encodedCerts));\n                } catch (CertificateException e) {\n                    logGenerateKeyPairFailure(caller, isCredentialManagementApp);\n                    Slogf.e(LOG_TAG, \"While retrieving certificate chain.\", e);\n                    return false;\n                }\n\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.GENERATE_KEY_PAIR)\n                        .setAdmin(caller.getPackageName())\n                        .setBoolean(/* isDelegate */ isCallerDelegate)\n                        .setInt(idAttestationFlags)\n                        .setStrings(algorithm, isCredentialManagementApp\n                                ? CREDENTIAL_MANAGEMENT_APP : NOT_CREDENTIAL_MANAGEMENT_APP)\n                        .write();\n                return true;\n            }\n        } catch (RemoteException | AssertionError e) {\n            Slogf.e(LOG_TAG, \"KeyChain error while generating a keypair\", e);\n        } catch (InterruptedException e) {\n            Slogf.w(LOG_TAG, \"Interrupted while generating keypair\", e);\n            Thread.currentThread().interrupt();\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        logGenerateKeyPairFailure(caller, isCredentialManagementApp);\n        return false;\n    }\n\n    private void logGenerateKeyPairFailure(CallerIdentity caller,\n            boolean isCredentialManagementApp) {\n        if (!isCredentialManagementApp) {\n            return;\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.CREDENTIAL_MANAGEMENT_APP_GENERATE_KEY_PAIR_FAILED)\n                .setStrings(caller.getPackageName())\n                .write();\n    }\n\n    private void enforceIndividualAttestationSupportedIfRequested(int[] attestationUtilsFlags) {\n        for (int attestationFlag : attestationUtilsFlags) {\n            if (attestationFlag == USE_INDIVIDUAL_ATTESTATION\n                    && !mInjector.getPackageManager().hasSystemFeature(\n                    PackageManager.FEATURE_DEVICE_UNIQUE_ATTESTATION)) {\n                throw new UnsupportedOperationException(\"Device Individual attestation is not \"\n                        + \"supported on this device.\");\n            }\n        }\n    }\n\n    @Override\n    public boolean setKeyPairCertificate(ComponentName who, String callerPackage, String alias,\n            byte[] cert, byte[] chain, boolean isUserSelectable) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        final boolean isCallerDelegate = isCallerDelegate(caller, DELEGATION_CERT_INSTALL);\n        final boolean isCredentialManagementApp = isCredentialManagementApp(caller);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && (isCallerDelegate || isCredentialManagementApp)));\n        if (isCredentialManagementApp) {\n            Preconditions.checkCallAuthorization(\n                    isAliasInCredentialManagementAppPolicy(caller, alias),\n                    CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG);\n        }\n\n        final long id = mInjector.binderClearCallingIdentity();\n        try (final KeyChainConnection keyChainConnection =\n                KeyChain.bindAsUser(mContext, caller.getUserHandle())) {\n            IKeyChainService keyChain = keyChainConnection.getService();\n            if (!keyChain.setKeyPairCertificate(alias, cert, chain)) {\n                return false;\n            }\n            keyChain.setUserSelectable(alias, isUserSelectable);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_KEY_PAIR_CERTIFICATE)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ isCallerDelegate)\n                    .setStrings(isCredentialManagementApp\n                            ? CREDENTIAL_MANAGEMENT_APP : NOT_CREDENTIAL_MANAGEMENT_APP)\n                    .write();\n            return true;\n        } catch (InterruptedException e) {\n            Slogf.w(LOG_TAG, \"Interrupted while setting keypair certificate\", e);\n            Thread.currentThread().interrupt();\n        } catch (RemoteException | AssertionError e) {\n            Slogf.e(LOG_TAG, \"Failed setting keypair certificate\", e);\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        return false;\n    }\n\n    @Override\n    public void choosePrivateKeyAlias(final int uid, final Uri uri, final String alias,\n            final IBinder response) {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isSystemUid(caller),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"choose private key alias\"));\n\n        // If there is a profile owner, redirect to that; otherwise query the device owner.\n        ComponentName aliasChooser = getProfileOwnerAsUser(caller.getUserId());\n        boolean isDoUser = caller.getUserId() == getDeviceOwnerUserId();\n        if (aliasChooser == null && isDoUser) {\n            synchronized (getLockObject()) {\n                final ActiveAdmin deviceOwnerAdmin = getDeviceOwnerAdminLocked();\n                if (deviceOwnerAdmin != null) {\n                    aliasChooser = deviceOwnerAdmin.info.getComponent();\n                }\n            }\n        }\n        if (aliasChooser == null) {\n            sendPrivateKeyAliasResponse(null, response);\n            return;\n        }\n\n        Intent intent = new Intent(DeviceAdminReceiver.ACTION_CHOOSE_PRIVATE_KEY_ALIAS);\n        intent.putExtra(DeviceAdminReceiver.EXTRA_CHOOSE_PRIVATE_KEY_SENDER_UID, uid);\n        intent.putExtra(DeviceAdminReceiver.EXTRA_CHOOSE_PRIVATE_KEY_URI, uri);\n        intent.putExtra(DeviceAdminReceiver.EXTRA_CHOOSE_PRIVATE_KEY_ALIAS, alias);\n        intent.putExtra(DeviceAdminReceiver.EXTRA_CHOOSE_PRIVATE_KEY_RESPONSE, response);\n        intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n\n        final ComponentName delegateReceiver;\n        delegateReceiver = resolveDelegateReceiver(DELEGATION_CERT_SELECTION,\n                DeviceAdminReceiver.ACTION_CHOOSE_PRIVATE_KEY_ALIAS, caller.getUserId());\n\n        final boolean isDelegate;\n        if (delegateReceiver != null) {\n            intent.setComponent(delegateReceiver);\n            isDelegate = true;\n        } else {\n            intent.setComponent(aliasChooser);\n            isDelegate = false;\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            mContext.sendOrderedBroadcastAsUser(intent, caller.getUserHandle(), null,\n                    new BroadcastReceiver() {\n                @Override\n                public void onReceive(Context context, Intent intent) {\n                    final String chosenAlias = getResultData();\n                    sendPrivateKeyAliasResponse(chosenAlias, response);\n                }\n            }, null, Activity.RESULT_OK, null, null);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.CHOOSE_PRIVATE_KEY_ALIAS)\n                    .setAdmin(intent.getComponent())\n                    .setBoolean(isDelegate)\n                    .write();\n        });\n    }\n\n    private void sendPrivateKeyAliasResponse(final String alias, final IBinder responseBinder) {\n        final IKeyChainAliasCallback keyChainAliasResponse =\n                IKeyChainAliasCallback.Stub.asInterface(responseBinder);\n        // Send the response. It's OK to do this from the main thread because IKeyChainAliasCallback\n        // is oneway, which means it won't block if the recipient lives in another process.\n        try {\n            keyChainAliasResponse.alias(alias);\n        } catch (Exception e) {\n            // Caller could throw RuntimeException or RemoteException back across processes. Catch\n            // everything just to be sure.\n            Slogf.e(LOG_TAG, \"error while responding to callback\", e);\n        }\n    }\n\n    /**\n     * Determine whether DPMS should check if a delegate package is already installed before\n     * granting it new delegations via {@link #setDelegatedScopes}.\n     */\n    private static boolean shouldCheckIfDelegatePackageIsInstalled(String delegatePackage,\n            int targetSdk, List<String> scopes) {\n        // 1) Never skip is installed check from N.\n        if (targetSdk >= Build.VERSION_CODES.N) {\n            return true;\n        }\n        // 2) Skip if DELEGATION_CERT_INSTALL is the only scope being given.\n        if (scopes.size() == 1 && scopes.get(0).equals(DELEGATION_CERT_INSTALL)) {\n            return false;\n        }\n        // 3) Skip if all previously granted scopes are being cleared.\n        if (scopes.isEmpty()) {\n            return false;\n        }\n        // Otherwise it should check that delegatePackage is installed.\n        return true;\n    }\n\n    /**\n     * Set the scopes of a device owner or profile owner delegate.\n     *\n     * @param who the device owner or profile owner.\n     * @param delegatePackage the name of the delegate package.\n     * @param scopeList the list of delegation scopes to be given to the delegate package.\n     */\n    @Override\n    public void setDelegatedScopes(ComponentName who, String delegatePackage,\n            List<String> scopeList) throws SecurityException {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkStringNotEmpty(delegatePackage, \"Delegate package is null or empty\");\n        Preconditions.checkCollectionElementsNotNull(scopeList, \"Scopes\");\n        final CallerIdentity caller = getCallerIdentity(who);\n\n        // Remove possible duplicates.\n        final ArrayList<String> scopes = new ArrayList(new ArraySet(scopeList));\n        // Ensure given scopes are valid.\n        if (scopes.retainAll(Arrays.asList(DELEGATIONS))) {\n            throw new IllegalArgumentException(\"Unexpected delegation scopes\");\n        }\n        // Retrieve the user ID of the calling process.\n        final int userId = caller.getUserId();\n        // Ensure calling process is device/profile owner.\n        if (!Collections.disjoint(scopes, DEVICE_OWNER_OR_MANAGED_PROFILE_OWNER_DELEGATIONS)) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || (isProfileOwner(caller) && isManagedProfile(caller.getUserId())));\n        } else if (!Collections.disjoint(\n                scopes, DEVICE_OWNER_OR_ORGANIZATION_OWNED_MANAGED_PROFILE_OWNER_DELEGATIONS)) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        }\n\n        synchronized (getLockObject()) {\n            // Ensure the delegate is installed (skip this for DELEGATION_CERT_INSTALL in pre-N).\n            if (shouldCheckIfDelegatePackageIsInstalled(delegatePackage,\n                        getTargetSdk(who.getPackageName(), userId), scopes)) {\n                // Throw when the delegate package is not installed.\n                if (!isPackageInstalledForUser(delegatePackage, userId)) {\n                    throw new IllegalArgumentException(\"Package \" + delegatePackage\n                            + \" is not installed on the current user\");\n                }\n            }\n\n            // Set the new delegate in user policies.\n            final DevicePolicyData policy = getUserData(userId);\n            List<String> exclusiveScopes = null;\n            if (!scopes.isEmpty()) {\n                policy.mDelegationMap.put(delegatePackage, new ArrayList<>(scopes));\n                exclusiveScopes = new ArrayList<>(scopes);\n                exclusiveScopes.retainAll(EXCLUSIVE_DELEGATIONS);\n            } else {\n                // Remove any delegation info if the given scopes list is empty.\n                policy.mDelegationMap.remove(delegatePackage);\n            }\n            sendDelegationChangedBroadcast(delegatePackage, scopes, userId);\n\n            // If set, remove exclusive scopes from all other delegates\n            if (exclusiveScopes != null && !exclusiveScopes.isEmpty()) {\n                for (int i = policy.mDelegationMap.size() - 1; i >= 0; --i) {\n                    final String currentPackage = policy.mDelegationMap.keyAt(i);\n                    final List<String> currentScopes = policy.mDelegationMap.valueAt(i);\n\n                    if (!currentPackage.equals(delegatePackage)) {\n                        // Iterate through all other delegates\n                        if (currentScopes.removeAll(exclusiveScopes)) {\n                            // And if this delegate had some exclusive scopes which are now moved\n                            // to the new delegate, notify about its delegation changes.\n                            if (currentScopes.isEmpty()) {\n                                policy.mDelegationMap.removeAt(i);\n                            }\n                            sendDelegationChangedBroadcast(currentPackage,\n                                    new ArrayList<>(currentScopes), userId);\n                        }\n                    }\n                }\n            }\n            // Persist updates.\n            saveSettingsLocked(userId);\n        }\n    }\n\n    private void sendDelegationChangedBroadcast(String delegatePackage, ArrayList<String> scopes,\n            int userId) {\n        // Notify delegate package of updates.\n        final Intent intent = new Intent(\n                DevicePolicyManager.ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED);\n        // Only call receivers registered with Context#registerReceiver (don\u2019t wake delegate).\n        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        // Limit components this intent resolves to to the delegate package.\n        intent.setPackage(delegatePackage);\n        // Include the list of delegated scopes as an extra.\n        intent.putStringArrayListExtra(DevicePolicyManager.EXTRA_DELEGATION_SCOPES, scopes);\n        // Send the broadcast.\n        mContext.sendBroadcastAsUser(intent, UserHandle.of(userId));\n    }\n\n    /**\n     * Get the delegation scopes given to a delegate package by a device owner or profile owner.\n     *\n     * A DO/PO can get the scopes of any package. A non DO/PO package can get its own scopes by\n     * passing in {@code null} as the {@code who} parameter and its own name as the\n     * {@code delegatepackage}.\n     *\n     * @param who the device owner or profile owner, or {@code null} if the caller is\n     *            {@code delegatePackage}.\n     * @param delegatePackage the name of the delegate package whose scopes are to be retrieved.\n     * @return a list of the delegation scopes currently given to {@code delegatePackage}.\n     */\n    @Override\n    @NonNull\n    public List<String> getDelegatedScopes(ComponentName who,\n            String delegatePackage) throws SecurityException {\n        Objects.requireNonNull(delegatePackage, \"Delegate package is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n\n        // Ensure the caller may call this method:\n        // * Either it's a profile owner / device owner, if componentName is provided\n        // * Or it's an app querying its own delegation scopes\n        if (caller.hasAdminComponent()) {\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        } else {\n            Preconditions.checkCallAuthorization(isPackage(caller, delegatePackage),\n                    String.format(\"Caller with uid %d is not %s\", caller.getUid(),\n                            delegatePackage));\n        }\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(caller.getUserId());\n            // Retrieve the scopes assigned to delegatePackage, or null if no scope was given.\n            final List<String> scopes = policy.mDelegationMap.get(delegatePackage);\n            return scopes == null ? Collections.EMPTY_LIST : scopes;\n        }\n    }\n\n    /**\n     * Get a list of  packages that were given a specific delegation scopes by a device owner or\n     * profile owner.\n     *\n     * @param who the device owner or profile owner.\n     * @param scope the scope whose delegates are to be retrieved.\n     * @return a list of the delegate packages currently given the {@code scope} delegation.\n     */\n    @NonNull\n    public List<String> getDelegatePackages(ComponentName who, String scope)\n            throws SecurityException {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(scope, \"Scope is null\");\n        if (!Arrays.asList(DELEGATIONS).contains(scope)) {\n            throw new IllegalArgumentException(\"Unexpected delegation scope: \" + scope);\n        }\n\n        // Retrieve the user ID of the calling process.\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        synchronized (getLockObject()) {\n            return getDelegatePackagesInternalLocked(scope, caller.getUserId());\n        }\n    }\n\n    private List<String> getDelegatePackagesInternalLocked(String scope, int userId) {\n        final DevicePolicyData policy = getUserData(userId);\n\n        // Create a list to hold the resulting delegate packages.\n        final List<String> delegatePackagesWithScope = new ArrayList<>();\n        // Add all delegations containing scope to the result list.\n        for (int i = 0; i < policy.mDelegationMap.size(); i++) {\n            if (policy.mDelegationMap.valueAt(i).contains(scope)) {\n                delegatePackagesWithScope.add(policy.mDelegationMap.keyAt(i));\n            }\n        }\n        return delegatePackagesWithScope;\n    }\n\n    /**\n     * Return the ComponentName of the receiver that handles the given broadcast action, from\n     * the app that holds the given delegation capability. If the app defines multiple receivers\n     * with the same intent action filter, will return any one of them nondeterministically.\n     *\n     * @return ComponentName of the receiver or {@null} if none exists.\n     */\n    private ComponentName resolveDelegateReceiver(String scope, String action, int userId) {\n\n        final List<String> delegates;\n        synchronized (getLockObject()) {\n            delegates = getDelegatePackagesInternalLocked(scope, userId);\n        }\n        if (delegates.size() == 0) {\n            return null;\n        } else if (delegates.size() > 1) {\n            Slogf.wtf(LOG_TAG, \"More than one delegate holds \" + scope);\n            return null;\n        }\n        final String pkg = delegates.get(0);\n        Intent intent = new Intent(action);\n        intent.setPackage(pkg);\n        final List<ResolveInfo> receivers;\n        try {\n            receivers = mIPackageManager.queryIntentReceivers(\n                    intent, null, 0, userId).getList();\n        } catch (RemoteException e) {\n            return null;\n        }\n        final int count = receivers.size();\n        if (count >= 1) {\n            if (count > 1) {\n                Slogf.w(LOG_TAG, pkg + \" defines more than one delegate receiver for \" + action);\n            }\n            return receivers.get(0).activityInfo.getComponentName();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Check whether a caller application has been delegated a given scope via\n     * {@link #setDelegatedScopes} to access privileged APIs on the behalf of a profile owner or\n     * device owner.\n     * <p>\n     * This is done by checking that {@code callerPackage} was granted {@code scope} delegation and\n     * then comparing the calling UID with the UID of {@code callerPackage} as reported by\n     * {@link PackageManager#getPackageUidAsUser}.\n     *\n     * @param callerPackage the name of the package that is trying to invoke a function in the DPMS.\n     * @param scope the delegation scope to be checked.\n     * @return {@code true} if the calling process is a delegate of {@code scope}.\n     */\n    private boolean isCallerDelegate(String callerPackage, int callerUid, String scope) {\n        Objects.requireNonNull(callerPackage, \"callerPackage is null\");\n        if (!Arrays.asList(DELEGATIONS).contains(scope)) {\n            throw new IllegalArgumentException(\"Unexpected delegation scope: \" + scope);\n        }\n\n        // Retrieve the UID and user ID of the calling process.\n        final int userId = UserHandle.getUserId(callerUid);\n        synchronized (getLockObject()) {\n            // Retrieve user policy data.\n            final DevicePolicyData policy = getUserData(userId);\n            // Retrieve the list of delegation scopes granted to callerPackage.\n            final List<String> scopes = policy.mDelegationMap.get(callerPackage);\n            // Check callingUid only if callerPackage has the required scope delegation.\n            if (scopes != null && scopes.contains(scope)) {\n                // Return true if the caller is actually callerPackage.\n                return isCallingFromPackage(callerPackage, callerUid);\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Check whether a caller application has been delegated a given scope via\n     * {@link #setDelegatedScopes} to access privileged APIs on the behalf of a profile owner or\n     * device owner.\n     * <p>\n     * This is done by checking that the calling package was granted {@code scope} delegation and\n     * then comparing the calling UID with the UID of the calling package as reported by\n     * {@link PackageManager#getPackageUidAsUser}.\n     *\n     * @param caller the calling identity\n     * @param scope the delegation scope to be checked.\n     * @return {@code true} if the calling process is a delegate of {@code scope}.\n     */\n    private boolean isCallerDelegate(CallerIdentity caller, String scope) {\n        if (caller.getPackageName() == null) {\n            return false;\n        }\n        Preconditions.checkArgument(Arrays.asList(DELEGATIONS).contains(scope),\n                \"Unexpected delegation scope: %s\", scope);\n\n        synchronized (getLockObject()) {\n            // Retrieve user policy data.\n            final DevicePolicyData policy = getUserData(caller.getUserId());\n            // Retrieve the list of delegation scopes granted to callerPackage.\n            final List<String> scopes = policy.mDelegationMap.get(caller.getPackageName());\n            // Check callingUid only if callerPackage has the required scope delegation.\n            return scopes != null && scopes.contains(scope);\n        }\n    }\n\n    /**\n     * Check whether a caller application has been delegated any scope via\n     * {@link #setDelegatedScopes} to access privileged APIs on the behalf of a profile owner or\n     * device owner.\n     * <p>\n     * This is done by checking that the calling package was granted any scope delegations and\n     * then comparing the calling UID with the UID of the calling package as reported by\n     * {@link PackageManager#getPackageUidAsUser}.\n     *\n     * @param caller the calling identity\n     * @return {@code true} if the calling process is a delegate of any scope.\n     */\n    private boolean isCallerDelegate(CallerIdentity caller) {\n        Objects.requireNonNull(caller.getPackageName(), \"callerPackage is null\");\n\n        synchronized (getLockObject()) {\n            // Retrieve user policy data.\n            final DevicePolicyData policy = getUserData(caller.getUserId());\n            // Retrieve the list of delegation scopes granted to callerPackage.\n            final List<String> scopes = policy.mDelegationMap.get(caller.getPackageName());\n            // Check callingUid only if callerPackage has the required scope delegation.\n            return scopes != null;\n        }\n    }\n\n    /**\n     * Helper function to preserve delegation behavior pre-O when using the deprecated functions\n     * {@code #setCertInstallerPackage} and {@code #setApplicationRestrictionsManagingPackage}.\n     */\n    private void setDelegatedScopePreO(ComponentName who,\n            String delegatePackage, String scope) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        // Ensure calling process is device/profile owner.\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(caller.getUserId());\n\n            if (delegatePackage != null) {\n                // Set package as a delegate for scope if it is not already one.\n                List<String> scopes = policy.mDelegationMap.get(delegatePackage);\n                if (scopes == null) {\n                    scopes = new ArrayList<>();\n                }\n                if (!scopes.contains(scope)) {\n                    scopes.add(scope);\n                    setDelegatedScopes(who, delegatePackage, scopes);\n                }\n            }\n\n            // Clear any existing scope delegates.\n            for (int i = 0; i < policy.mDelegationMap.size(); i++) {\n                final String currentPackage = policy.mDelegationMap.keyAt(i);\n                final List<String> currentScopes = policy.mDelegationMap.valueAt(i);\n\n                if (!currentPackage.equals(delegatePackage) && currentScopes.contains(scope)) {\n                    final List<String> newScopes = new ArrayList(currentScopes);\n                    newScopes.remove(scope);\n                    setDelegatedScopes(who, currentPackage, newScopes);\n                }\n            }\n        }\n    }\n\n    /**\n     * Check whether a caller application is the credential management app, which can access\n     * privileged APIs.\n     * <p>\n     * This is done by checking that the calling package is authorized to perform the app operation\n     * {@link AppOpsManager#OP_MANAGE_CREDENTIALS}.\n     *\n     * @param caller the calling identity\n     * @return {@code true} if the calling process is the credential management app.\n     */\n    private boolean isCredentialManagementApp(CallerIdentity caller) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            AppOpsManager appOpsManager = mInjector.getAppOpsManager();\n            if (appOpsManager == null) return false;\n            return appOpsManager.noteOpNoThrow(AppOpsManager.OP_MANAGE_CREDENTIALS, caller.getUid(),\n                    caller.getPackageName(), null, null) == MODE_ALLOWED;\n        });\n    }\n\n    /**\n     * If the caller is the credential management app, the alias provided must be contained\n     * in the aliases specified in the credential management app's authentication policy.\n     */\n    private boolean isAliasInCredentialManagementAppPolicy(CallerIdentity caller, String alias) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try (KeyChainConnection connection = KeyChain.bindAsUser(mContext,\n                    caller.getUserHandle())) {\n                // The policy will be null if there is no credential management app\n                AppUriAuthenticationPolicy policy =\n                        connection.getService().getCredentialManagementAppPolicy();\n                return policy != null && !policy.getAppAndUriMappings().isEmpty()\n                        && containsAlias(policy, alias);\n            } catch (RemoteException | InterruptedException | AssertionError e) {\n                return false;\n            }\n        });\n    }\n\n    private static boolean containsAlias(AppUriAuthenticationPolicy policy, String alias) {\n        for (Map.Entry<String, Map<Uri, String>> appsToUris :\n                policy.getAppAndUriMappings().entrySet()) {\n            for (Map.Entry<Uri, String> urisToAliases : appsToUris.getValue().entrySet()) {\n                if (urisToAliases.getValue().equals(alias)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void setCertInstallerPackage(ComponentName who, String installerPackage)\n            throws SecurityException {\n        setDelegatedScopePreO(who, installerPackage, DELEGATION_CERT_INSTALL);\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CERT_INSTALLER_PACKAGE)\n                .setAdmin(who)\n                .setStrings(installerPackage)\n                .write();\n    }\n\n    @Override\n    public String getCertInstallerPackage(ComponentName who) throws SecurityException {\n        final List<String> delegatePackages = getDelegatePackages(who, DELEGATION_CERT_INSTALL);\n        return delegatePackages.size() > 0 ? delegatePackages.get(0) : null;\n    }\n\n    /**\n     * @return {@code true} if the package is installed and set as always-on, {@code false} if it is\n     * not installed and therefore not available.\n     *\n     * @throws SecurityException if the caller is not a profile or device owner.\n     * @throws UnsupportedOperationException if the package does not support being set as always-on.\n     */\n    @Override\n    public boolean setAlwaysOnVpnPackage(ComponentName who, String vpnPackage, boolean lockdown,\n            List<String> lockdownAllowlist)\n            throws SecurityException {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_ALWAYS_ON_VPN_PACKAGE);\n\n        if (vpnPackage == null) {\n            final String prevVpnPackage;\n            synchronized (getLockObject()) {\n                prevVpnPackage = getProfileOwnerOrDeviceOwnerLocked(\n                        caller.getUserId()).mAlwaysOnVpnPackage;\n                // If the admin is clearing VPN package but hasn't configure any VPN previously,\n                // ignore it so that it doesn't interfere with user-configured VPNs.\n                if (TextUtils.isEmpty(prevVpnPackage)) {\n                    return true;\n                }\n            }\n            revokeVpnAuthorizationForPackage(prevVpnPackage, caller.getUserId());\n        }\n\n        final int userId = caller.getUserId();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (vpnPackage != null && !isPackageInstalledForUser(vpnPackage, userId)) {\n                Slogf.w(LOG_TAG, \"Non-existent VPN package specified: \" + vpnPackage);\n                throw new ServiceSpecificException(\n                        DevicePolicyManager.ERROR_VPN_PACKAGE_NOT_FOUND, vpnPackage);\n            }\n\n            if (vpnPackage != null && lockdown && lockdownAllowlist != null) {\n                for (String packageName : lockdownAllowlist) {\n                    if (!isPackageInstalledForUser(packageName, userId)) {\n                        Slogf.w(LOG_TAG, \"Non-existent package in VPN allowlist: \" + packageName);\n                        throw new ServiceSpecificException(\n                                DevicePolicyManager.ERROR_VPN_PACKAGE_NOT_FOUND, packageName);\n                    }\n                }\n            }\n            // If some package is uninstalled after the check above, it will be ignored by CM.\n            VpnManager vpnManager = mInjector.getVpnManager();\n            if (vpnManager == null\n                    || !mInjector.getVpnManager().setAlwaysOnVpnPackageForUser(\n                            userId, vpnPackage, lockdown, lockdownAllowlist)) {\n                throw new UnsupportedOperationException();\n            }\n        });\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_ALWAYS_ON_VPN_PACKAGE)\n                .setAdmin(caller.getComponentName())\n                .setStrings(vpnPackage)\n                .setBoolean(lockdown)\n                .setInt(lockdownAllowlist != null ? lockdownAllowlist.size() : 0)\n                .write();\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (!TextUtils.equals(vpnPackage, admin.mAlwaysOnVpnPackage)\n                    || lockdown != admin.mAlwaysOnVpnLockdown) {\n                admin.mAlwaysOnVpnPackage = vpnPackage;\n                admin.mAlwaysOnVpnLockdown = lockdown;\n                saveSettingsLocked(userId);\n            }\n        }\n        return true;\n    }\n\n    private void revokeVpnAuthorizationForPackage(String vpnPackage, int userId) {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                final ApplicationInfo ai = mIPackageManager.getApplicationInfo(\n                        vpnPackage, /* flags= */ 0, userId);\n                if (ai == null) {\n                    Slogf.w(LOG_TAG, \"Non-existent VPN package: \" + vpnPackage);\n                } else {\n                    mInjector.getAppOpsManager().setMode(AppOpsManager.OP_ACTIVATE_VPN,\n                            ai.uid, vpnPackage, MODE_DEFAULT);\n                }\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Can't talk to package managed\", e);\n            }\n        });\n    }\n\n    @Override\n    public String getAlwaysOnVpnPackage(ComponentName admin) throws SecurityException {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        VpnManager vpnManager = mInjector.getVpnManager();\n        if (vpnManager == null) {\n            return null;\n        }\n        return mInjector.binderWithCleanCallingIdentity(\n                () -> vpnManager.getAlwaysOnVpnPackageForUser(caller.getUserId()));\n    }\n\n    @Override\n    public String getAlwaysOnVpnPackageForUser(int userHandle) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"call getAlwaysOnVpnPackageForUser\"));\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userHandle);\n            return admin != null ? admin.mAlwaysOnVpnPackage : null;\n        }\n    }\n\n    @Override\n    public boolean isAlwaysOnVpnLockdownEnabled(ComponentName admin) throws SecurityException {\n        final CallerIdentity caller;\n        if (hasCallingPermission(PERMISSION_MAINLINE_NETWORK_STACK)) {\n            // TODO: CaptivePortalLoginActivity erroneously calls this method with a non-admin\n            // ComponentName, so we have to use a separate code path for it:\n            // getCallerIdentity(admin) will throw if the admin is not in the known admin list.\n            caller = getCallerIdentity();\n        } else {\n            caller = getCallerIdentity(admin);\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        }\n\n        VpnManager vpnManager = mInjector.getVpnManager();\n        if (vpnManager == null) {\n            return false;\n        }\n        return mInjector.binderWithCleanCallingIdentity(\n                () -> vpnManager.isVpnLockdownEnabled(caller.getUserId()));\n    }\n\n    @Override\n    public boolean isAlwaysOnVpnLockdownEnabledForUser(int userHandle) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"call isAlwaysOnVpnLockdownEnabledForUser\"));\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userHandle);\n            return admin != null && admin.mAlwaysOnVpnLockdown;\n        }\n    }\n\n    @Override\n    public List<String> getAlwaysOnVpnLockdownAllowlist(ComponentName admin)\n            throws SecurityException {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        VpnManager vpnManager = mInjector.getVpnManager();\n        if (vpnManager == null) {\n            return null;\n        }\n        return mInjector.binderWithCleanCallingIdentity(\n                () -> vpnManager.getVpnLockdownAllowlist(caller.getUserId()));\n    }\n\n    private void forceWipeDeviceNoLock(boolean wipeExtRequested, String reason, boolean wipeEuicc,\n            boolean wipeResetProtectionData) {\n        wtfIfInLock();\n        boolean success = false;\n\n        try {\n            boolean delayed = !mInjector.recoverySystemRebootWipeUserData(\n                    /* shutdown= */ false, reason, /* force= */ true, /* wipeEuicc= */ wipeEuicc,\n                    wipeExtRequested, wipeResetProtectionData);\n            if (delayed) {\n                // Persist the request so the device is automatically factory-reset on next start if\n                // the system crashes or reboots before the {@code DevicePolicySafetyChecker} calls\n                // its callback.\n                Slogf.i(LOG_TAG, \"Persisting factory reset request as it could be delayed by %s\",\n                        mSafetyChecker);\n                synchronized (getLockObject()) {\n                    DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n                    policy.setDelayedFactoryReset(reason, wipeExtRequested, wipeEuicc,\n                            wipeResetProtectionData);\n                    saveSettingsLocked(UserHandle.USER_SYSTEM);\n                }\n            }\n            success = true;\n        } catch (IOException | SecurityException e) {\n            Slogf.w(LOG_TAG, \"Failed requesting data wipe\", e);\n        } finally {\n            if (!success) SecurityLog.writeEvent(SecurityLog.TAG_WIPE_FAILURE);\n        }\n    }\n\n    private void factoryResetIfDelayedEarlier() {\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n\n            if (policy.mFactoryResetFlags == 0) return;\n\n            if (policy.mFactoryResetReason == null) {\n                // Shouldn't happen.\n                Slogf.e(LOG_TAG, \"no persisted reason for factory resetting\");\n                policy.mFactoryResetReason = \"requested before boot\";\n            }\n            FactoryResetter factoryResetter = FactoryResetter.newBuilder(mContext)\n                    .setReason(policy.mFactoryResetReason).setForce(true)\n                    .setWipeEuicc((policy.mFactoryResetFlags & DevicePolicyData\n                            .FACTORY_RESET_FLAG_WIPE_EUICC) != 0)\n                    .setWipeAdoptableStorage((policy.mFactoryResetFlags & DevicePolicyData\n                            .FACTORY_RESET_FLAG_WIPE_EXTERNAL_STORAGE) != 0)\n                    .setWipeFactoryResetProtection((policy.mFactoryResetFlags & DevicePolicyData\n                            .FACTORY_RESET_FLAG_WIPE_FACTORY_RESET_PROTECTION) != 0)\n                    .build();\n            Slogf.i(LOG_TAG, \"Factory resetting on boot using \" + factoryResetter);\n            try {\n                if (!factoryResetter.factoryReset()) {\n                    // Shouldn't happen because FactoryResetter was created without a\n                    // DevicePolicySafetyChecker.\n                    Slogf.wtf(LOG_TAG, \"Factory reset using \" + factoryResetter + \" failed.\");\n                }\n            } catch (IOException e) {\n                // Shouldn't happen.\n                Slogf.wtf(LOG_TAG, \"Could not factory reset using \" + factoryResetter, e);\n            }\n        }\n    }\n\n    private void forceWipeUser(int userId, String wipeReasonForUser, boolean wipeSilently) {\n        boolean success = false;\n        try {\n            if (getCurrentForegroundUserId() == userId) {\n                // TODO: We need to special case headless here as we can't switch to the system user\n                mInjector.getIActivityManager().switchUser(UserHandle.USER_SYSTEM);\n            }\n\n            success = mUserManagerInternal.removeUserEvenWhenDisallowed(userId);\n            if (!success) {\n                Slogf.w(LOG_TAG, \"Couldn't remove user \" + userId);\n            } else if (isManagedProfile(userId) && !wipeSilently) {\n                sendWipeProfileNotification(wipeReasonForUser,\n                        UserHandle.of(getProfileParentId(userId)));\n            }\n        } catch (RemoteException re) {\n            // Shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Error forcing wipe user\", re);\n        } finally {\n            if (!success) SecurityLog.writeEvent(SecurityLog.TAG_WIPE_FAILURE);\n        }\n    }\n\n    @Override\n    public void wipeDataWithReason(String callerPackageName, int flags,\n            @NonNull String wipeReasonForUser, boolean calledOnParentInstance,\n            boolean factoryReset) {\n        if (!mHasFeature && !hasCallingOrSelfPermission(MASTER_CLEAR)) {\n            return;\n        }\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n\n        boolean calledByProfileOwnerOnOrgOwnedDevice =\n                isProfileOwnerOfOrganizationOwnedDevice(caller.getUserId());\n        EnforcingAdmin enforcingAdmin = enforcePermissionsAndGetEnforcingAdmin(\n                /*admin=*/ null,\n                /*permission=*/ new String[]{MANAGE_DEVICE_POLICY_WIPE_DATA, MASTER_CLEAR},\n                USES_POLICY_WIPE_DATA,\n                caller.getPackageName(),\n                factoryReset ? UserHandle.USER_ALL : getAffectedUser(calledOnParentInstance));\n\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_WIPE_DATA);\n\n        if (TextUtils.isEmpty(wipeReasonForUser)) {\n            wipeReasonForUser = getGenericWipeReason(\n                    calledByProfileOwnerOnOrgOwnedDevice, calledOnParentInstance);\n        }\n\n        int userId = enforcingAdmin.getUserId();\n        Slogf.i(LOG_TAG, \"wipeDataWithReason(%s): admin=%s, user=%d\", wipeReasonForUser,\n                enforcingAdmin, userId);\n\n        if (calledByProfileOwnerOnOrgOwnedDevice) {\n            // When wipeData is called on the parent instance, it implies wiping the entire device.\n            if (calledOnParentInstance) {\n                userId = UserHandle.USER_SYSTEM;\n            } else {\n                // when wipeData is _not_ called on the parent instance, it implies relinquishing\n                // control over the device, wiping only the work profile. So the user restriction\n                // on profile removal needs to be removed first.\n                final UserHandle parentUser = UserHandle.of(getProfileParentId(userId));\n                mInjector.binderWithCleanCallingIdentity(\n                        () -> clearOrgOwnedProfileOwnerUserRestrictions(parentUser));\n            }\n        }\n        DevicePolicyEventLogger event = DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.WIPE_DATA_WITH_REASON)\n                .setInt(flags)\n                .setStrings(calledOnParentInstance ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT);\n\n        final String adminName;\n        final ComponentName adminComp;\n        adminComp = enforcingAdmin.getComponentName();\n        adminName = adminComp != null\n                ? adminComp.flattenToShortString()\n                : enforcingAdmin.getPackageName();\n        event.setAdmin(enforcingAdmin.getPackageName());\n        // Not including any HSUM handling here because the \"else\" branch in the \"flag off\"\n        // case below is unreachable under normal circumstances and for permission-based\n        // callers admin won't be null.\n        event.write();\n\n        String internalReason = String.format(\n                \"DevicePolicyManager.wipeDataWithReason() from %s, organization-owned? %s\",\n                adminName, calledByProfileOwnerOnOrgOwnedDevice);\n\n        wipeDataNoLock(adminComp, flags, internalReason, wipeReasonForUser, userId, factoryReset);\n    }\n\n    private String getGenericWipeReason(\n            boolean calledByProfileOwnerOnOrgOwnedDevice, boolean calledOnParentInstance) {\n        return calledByProfileOwnerOnOrgOwnedDevice && !calledOnParentInstance\n                ? getUpdatableString(\n                        WORK_PROFILE_DELETED_ORG_OWNED_MESSAGE,\n                        R.string.device_ownership_relinquished)\n                : getUpdatableString(\n                        WORK_PROFILE_DELETED_GENERIC_MESSAGE,\n                        R.string.work_profile_deleted_description_dpm_wipe);\n    }\n\n    /**\n     * Clears device wide policies enforced by COPE PO when relinquishing the device. This method\n     * should be invoked once the admin is gone, so that all methods that rely on calculating\n     * aggregate policy (e.g. strong auth timeout) from all admins aren't affected by its policies.\n     * This method assumes that there is no other device or profile owners left on the device.\n     * Shouldn't be called from binder thread without clearing identity.\n     */\n    private void clearOrgOwnedProfileOwnerDeviceWidePolicies(@UserIdInt int parentId) {\n        Slogf.i(LOG_TAG, \"Cleaning up device-wide policies left over from org-owned profile...\");\n        // Lockscreen message\n        mLockPatternUtils.setDeviceOwnerInfo(null);\n        // Wifi config lockdown\n        mInjector.settingsGlobalPutInt(Global.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN, 0);\n        // Security logging\n        if (mInjector.securityLogGetLoggingEnabledProperty()) {\n            mSecurityLogMonitor.stop();\n            mInjector.securityLogSetLoggingEnabledProperty(false);\n        }\n        // Network logging\n        setNetworkLoggingActiveInternal(false);\n\n        // System update policy.\n        final boolean hasSystemUpdatePolicy;\n        synchronized (getLockObject()) {\n            hasSystemUpdatePolicy = mOwners.getSystemUpdatePolicy() != null;\n            if (hasSystemUpdatePolicy) {\n                mOwners.clearSystemUpdatePolicy();\n                mOwners.writeDeviceOwner();\n            }\n        }\n        if (hasSystemUpdatePolicy) {\n            mContext.sendBroadcastAsUser(\n                    new Intent(ACTION_SYSTEM_UPDATE_POLICY_CHANGED), UserHandle.SYSTEM);\n        }\n\n        // Unsuspend personal apps if needed.\n        suspendPersonalAppsInternal(parentId, getManagedUserId(parentId), false);\n\n        // Notify FRP agent, LSS and WindowManager to ensure they don't hold on to stale policies.\n        final int frpAgentUid = getFrpManagementAgentUid();\n        if (frpAgentUid > 0) {\n            notifyResetProtectionPolicyChanged(frpAgentUid);\n        }\n        mLockSettingsInternal.refreshStrongAuthTimeout(parentId);\n\n        clearManagedSubscriptionsPolicy();\n        clearLauncherShortcutOverrides();\n        updateTelephonyCrossProfileIntentFilters(parentId, UserHandle.USER_NULL, false);\n\n        Slogf.i(LOG_TAG, \"Cleaning up device-wide policies done.\");\n    }\n\n    private void clearManagedSubscriptionsPolicy() {\n        unregisterOnSubscriptionsChangedListener();\n\n        SubscriptionManager subscriptionManager = mContext.getSystemService(\n                SubscriptionManager.class);\n        //Iterate over all the subscriptions and remove association with any user.\n        int[] subscriptionIds = subscriptionManager.getActiveSubscriptionIdList(false);\n        for (int subId : subscriptionIds) {\n            subscriptionManager.setSubscriptionUserHandle(subId, null);\n        }\n    }\n\n    private void clearLauncherShortcutOverrides() {\n        mPolicyCache.setLauncherShortcutOverrides(new ArrayMap<>());\n    }\n\n    private void updateTelephonyCrossProfileIntentFilters(int parentUserId, int profileUserId,\n            boolean enableWorkTelephony) {\n        try {\n            // This should only occur when managed profile is being removed.\n            if (!enableWorkTelephony && profileUserId == UserHandle.USER_NULL) {\n                mIPackageManager.clearCrossProfileIntentFilters(parentUserId,\n                        mContext.getPackageName());\n                return;\n            }\n            for (DefaultCrossProfileIntentFilter filter :\n                    DefaultCrossProfileIntentFiltersUtils\n                            .getDefaultCrossProfileTelephonyIntentFilters(!enableWorkTelephony)) {\n                if (removeCrossProfileIntentFilter(filter, parentUserId, profileUserId)) {\n                    Slogf.w(LOG_TAG,\n                            \"Failed to remove cross-profile intent filter: \"\n                                    + filter.filter.getIntentFilter() + \", enableWorkTelephony: \"\n                                    + enableWorkTelephony);\n                }\n            }\n            for (DefaultCrossProfileIntentFilter filter :\n                    DefaultCrossProfileIntentFiltersUtils\n                            .getDefaultCrossProfileTelephonyIntentFilters(enableWorkTelephony)) {\n                addCrossProfileIntentFilter(filter, parentUserId, profileUserId);\n            }\n        } catch (RemoteException re) {\n            Slogf.wtf(LOG_TAG, \"Error updating telephony cross profile intent filters\", re);\n        }\n    }\n\n    void addCrossProfileIntentFilter(DefaultCrossProfileIntentFilter filter, int parentUserId,\n            int profileUserId)\n            throws RemoteException {\n        if (filter.direction == DefaultCrossProfileIntentFilter.Direction.TO_PROFILE) {\n            mIPackageManager.addCrossProfileIntentFilter(\n                    filter.filter.getIntentFilter(),\n                    mContext.getOpPackageName(),\n                    parentUserId,\n                    profileUserId,\n                    filter.flags);\n        } else {\n            mIPackageManager.addCrossProfileIntentFilter(\n                    filter.filter.getIntentFilter(),\n                    mContext.getOpPackageName(),\n                    profileUserId,\n                    parentUserId,\n                    filter.flags);\n        }\n    }\n\n    boolean removeCrossProfileIntentFilter(DefaultCrossProfileIntentFilter filter, int parentUserId,\n            int profileUserId)\n            throws RemoteException {\n        if (filter.direction == DefaultCrossProfileIntentFilter.Direction.TO_PROFILE) {\n            return mIPackageManager.removeCrossProfileIntentFilter(\n                    filter.filter.getIntentFilter(),\n                    mContext.getOpPackageName(),\n                    parentUserId,\n                    profileUserId,\n                    filter.flags);\n        } else {\n            return mIPackageManager.removeCrossProfileIntentFilter(\n                    filter.filter.getIntentFilter(),\n                    mContext.getOpPackageName(),\n                    profileUserId,\n                    parentUserId,\n                    filter.flags);\n        }\n    }\n\n    /**\n     * @param factoryReset null: legacy behaviour, false: attempt to remove user, true: attempt to\n     *                     factory reset\n     */\n    private void wipeDataNoLock(@Nullable ComponentName admin, int flags, String internalReason,\n            String wipeReasonForUser, int userId, @Nullable Boolean factoryReset) {\n        wtfIfInLock();\n        final String adminPackage;\n        if (admin != null) {\n            adminPackage = admin.getPackageName();\n        } else {\n            int callerUid = mInjector.binderGetCallingUid();\n            String[] adminPackages = mInjector.getPackageManager().getPackagesForUid(callerUid);\n            Preconditions.checkState(adminPackages.length > 0,\n                    \"Caller %s does not have any associated packages\", callerUid);\n            adminPackage = adminPackages[0];\n        }\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            // First check whether the admin is allowed to wipe the device/user/profile.\n            final String restriction;\n            boolean shouldFactoryReset = userId == UserHandle.USER_SYSTEM;\n            if (getHeadlessDeviceOwnerModeForDeviceOwner()\n                    == HEADLESS_DEVICE_OWNER_MODE_SINGLE_USER) {\n                shouldFactoryReset = userId == getMainUserId();\n            }\n            if (shouldFactoryReset) {\n                restriction = UserManager.DISALLOW_FACTORY_RESET;\n            } else if (isManagedProfile(userId)) {\n                restriction = UserManager.DISALLOW_REMOVE_MANAGED_PROFILE;\n            } else {\n                restriction = UserManager.DISALLOW_REMOVE_USER;\n            }\n            if (isAdminAffectedByRestriction(admin, restriction, userId)) {\n                throw new SecurityException(\"Cannot wipe data. \" + restriction\n                        + \" restriction is set for user \" + userId);\n            }\n\n            boolean isSystemUser = userId == UserHandle.USER_SYSTEM;\n            boolean isMainUser = userId == getMainUserId();\n            boolean wipeDevice;\n            if (factoryReset == null || !mInjector.isChangeEnabled(EXPLICIT_WIPE_BEHAVIOUR,\n                    adminPackage,\n                    userId)) {\n                // Legacy mode\n                wipeDevice = getHeadlessDeviceOwnerModeForDeviceOwner()\n                        == HEADLESS_DEVICE_OWNER_MODE_SINGLE_USER ? isMainUser : isSystemUser;\n            } else {\n                // Explicit behaviour\n                if (factoryReset) {\n                    wipeDevice = true;\n                } else {\n                    Preconditions.checkState(!isSystemUser,\n                            \"User %s is a system user and cannot be removed\", userId);\n                    boolean isLastNonHeadlessUser = getUserInfo(userId).isFull()\n                            && mUserManager.getAliveUsers().stream()\n                            .filter((it) -> it.getUserHandle().getIdentifier() != userId)\n                            .noneMatch(UserInfo::isFull);\n                    Preconditions.checkState(!isLastNonHeadlessUser,\n                            \"Removing user %s would leave the device without any active users. \"\n                                    + \"Consider factory resetting the device instead.\", userId);\n                    wipeDevice = false;\n                }\n            }\n\n            if (wipeDevice) {\n                forceWipeDeviceNoLock(\n                        (flags & WIPE_EXTERNAL_STORAGE) != 0,\n                        internalReason,\n                        (flags & WIPE_EUICC) != 0,\n                        (flags & WIPE_RESET_PROTECTION_DATA) != 0);\n            } else {\n                forceWipeUser(userId, wipeReasonForUser, (flags & WIPE_SILENTLY) != 0);\n            }\n        });\n    }\n\n    private void sendWipeProfileNotification(String wipeReasonForUser, UserHandle user) {\n        Notification notification =\n                new Notification.Builder(mContext, SystemNotificationChannels.DEVICE_ADMIN)\n                        .setSmallIcon(android.R.drawable.stat_sys_warning)\n                        .setContentTitle(getWorkProfileDeletedTitle())\n                        .setContentText(wipeReasonForUser)\n                        .setColor(mContext.getColor(R.color.system_notification_accent_color))\n                        .setStyle(new Notification.BigTextStyle().bigText(wipeReasonForUser))\n                        .build();\n        mInjector.getNotificationManager().notifyAsUser(\n                /* tag= */ null, SystemMessage.NOTE_PROFILE_WIPED, notification, user);\n    }\n\n    private String getWorkProfileDeletedTitle() {\n        return getUpdatableString(WORK_PROFILE_DELETED_TITLE, R.string.work_profile_deleted);\n    }\n\n    private void clearWipeProfileNotification() {\n        mInjector.getNotificationManager().cancel(SystemMessage.NOTE_PROFILE_WIPED);\n    }\n\n    @Override\n    public void setFactoryResetProtectionPolicy(ComponentName who, String callerPackageName,\n            @Nullable FactoryResetProtectionPolicy policy) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        Preconditions.checkNotNull(who, \"ComponentName is null\");\n\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller)\n                        || isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager\n                .OPERATION_SET_FACTORY_RESET_PROTECTION_POLICY);\n\n        final int frpManagementAgentUid = getFrpManagementAgentUidOrThrow();\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            admin.mFactoryResetProtectionPolicy = policy;\n            saveSettingsLocked(caller.getUserId());\n        }\n\n        mInjector.binderWithCleanCallingIdentity(\n                () -> notifyResetProtectionPolicyChanged(frpManagementAgentUid));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_FACTORY_RESET_PROTECTION)\n                .setAdmin(caller.getPackageName())\n                .write();\n    }\n\n    // Shouldn't be called from binder thread without clearing identity.\n    private void notifyResetProtectionPolicyChanged(int frpManagementAgentUid) {\n        final Intent intent = new Intent(\n                DevicePolicyManager.ACTION_RESET_PROTECTION_POLICY_CHANGED).addFlags(\n                Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND | Intent.FLAG_RECEIVER_FOREGROUND);\n        mContext.sendBroadcastAsUser(intent,\n                UserHandle.getUserHandleForUid(frpManagementAgentUid),\n                permission.MANAGE_FACTORY_RESET_PROTECTION);\n    }\n\n    @Override\n    public FactoryResetProtectionPolicy getFactoryResetProtectionPolicy(\n            @Nullable ComponentName who) {\n        if (!mHasFeature) {\n            return null;\n        }\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        final int frpManagementAgentUid = getFrpManagementAgentUidOrThrow();\n        final ActiveAdmin admin;\n        synchronized (getLockObject()) {\n            if (who == null) {\n                Preconditions.checkCallAuthorization(frpManagementAgentUid == caller.getUid()\n                                || hasCallingPermission(MASTER_CLEAR)\n                                || hasCallingPermission(MANAGE_DEVICE_POLICY_FACTORY_RESET),\n                        \"Must be called by the FRP management agent on device\");\n                admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n            } else {\n                Preconditions.checkCallAuthorization(\n                        isDefaultDeviceOwner(caller)\n                                || isProfileOwnerOfOrganizationOwnedDevice(caller));\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n        }\n\n        return admin != null ? admin.mFactoryResetProtectionPolicy : null;\n    }\n\n    private int getFrpManagementAgentUid() {\n        PersistentDataBlockManagerInternal pdb = mInjector.getPersistentDataBlockManagerInternal();\n        return pdb != null ? pdb.getAllowedUid() : -1;\n    }\n\n    private int getFrpManagementAgentUidOrThrow() {\n        int uid = getFrpManagementAgentUid();\n        if (uid == -1) {\n            throw new UnsupportedOperationException(\n                    \"The persistent data block service is not supported on this device\");\n        }\n        return uid;\n    }\n\n    @Override\n    public boolean isFactoryResetProtectionPolicySupported() {\n        return getFrpManagementAgentUid() != -1;\n    }\n\n    @Override\n    public void sendLostModeLocationUpdate(AndroidFuture<Boolean> future) {\n        if (!mHasFeature) {\n            future.complete(false);\n            return;\n        }\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.TRIGGER_LOST_MODE));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n\n            Preconditions.checkState(admin != null,\n                    \"Lost mode location updates can only be sent on an organization-owned device.\");\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                String[] providers = {LocationManager.FUSED_PROVIDER,\n                        LocationManager.NETWORK_PROVIDER, LocationManager.GPS_PROVIDER};\n                tryRetrieveAndSendLocationUpdate(admin, future, providers, /* index= */ 0);\n            });\n        }\n    }\n\n    /** Send lost mode location updates recursively, in order of the list of location providers. */\n    private void tryRetrieveAndSendLocationUpdate(ActiveAdmin admin,\n            AndroidFuture<Boolean> future, String[] providers, int index) {\n        // None of the providers were able to get location, return false\n        if (index == providers.length) {\n            future.complete(false);\n            return;\n        }\n        if (mInjector.getLocationManager().isProviderEnabled(providers[index])) {\n            mInjector.getLocationManager().getCurrentLocation(providers[index],\n                    /* cancellationSignal= */ null, mContext.getMainExecutor(), location -> {\n                        if (location != null) {\n                            mContext.sendBroadcastAsUser(\n                                    newLostModeLocationUpdateIntent(admin, location),\n                                    admin.getUserHandle());\n                            future.complete(true);\n                        } else {\n                            tryRetrieveAndSendLocationUpdate(admin, future, providers, index + 1);\n                        }\n                    }\n            );\n        } else {\n           tryRetrieveAndSendLocationUpdate(admin, future, providers, index + 1);\n        }\n    }\n\n    private Intent newLostModeLocationUpdateIntent(ActiveAdmin admin, Location location) {\n        final Intent intent = new Intent(\n                DevicePolicyManager.ACTION_LOST_MODE_LOCATION_UPDATE);\n        intent.putExtra(DevicePolicyManager.EXTRA_LOST_MODE_LOCATION, location);\n        intent.setPackage(admin.info.getPackageName());\n        return intent;\n    }\n\n    /**\n     * Called by a privileged caller holding {@code BIND_DEVICE_ADMIN} permission to retrieve\n     * the remove warning for the given device admin.\n     */\n    @Override\n    public void getRemoveWarning(ComponentName comp, final RemoteCallback result, int userHandle) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminUncheckedLocked(comp, userHandle);\n            if (admin == null) {\n                result.sendResult(null);\n                return;\n            }\n            Intent intent = new Intent(DeviceAdminReceiver.ACTION_DEVICE_ADMIN_DISABLE_REQUESTED);\n            intent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.setComponent(admin.info.getComponent());\n            mContext.sendOrderedBroadcastAsUser(intent, new UserHandle(userHandle),\n                    null, new BroadcastReceiver() {\n                @Override\n                public void onReceive(Context context, Intent intent) {\n                    result.sendResult(getResultExtras(false));\n                }\n            }, null, Activity.RESULT_OK, null, null);\n        }\n    }\n\n    @Override\n    public void reportPasswordChanged(PasswordMetrics metrics, @UserIdInt int userId) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isSystemUid(caller));\n        // Managed Profile password can only be changed when it has a separate challenge.\n        if (!isSeparateProfileChallengeEnabled(userId)) {\n            Preconditions.checkCallAuthorization(!isManagedProfile(userId), \"You can \"\n                    + \"not set the active password for a managed profile, userId = %d\", userId);\n        }\n\n        DevicePolicyData policy = getUserData(userId);\n        final ArraySet<Integer> affectedUserIds = new ArraySet<>();\n\n        synchronized (getLockObject()) {\n            policy.mFailedPasswordAttempts = 0;\n            affectedUserIds.add(userId);\n            affectedUserIds.addAll(updatePasswordValidityCheckpointLocked(\n                    userId, /* parent */ false));\n            affectedUserIds.addAll(updatePasswordExpirationsLocked(userId));\n            setExpirationAlarmCheckLocked(mContext, userId, /* parent */ false);\n\n            // Send a broadcast to each profile using this password as its primary unlock.\n            sendAdminCommandForLockscreenPoliciesLocked(\n                    DeviceAdminReceiver.ACTION_PASSWORD_CHANGED,\n                    DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, userId);\n\n            affectedUserIds.addAll(removeCaApprovalsIfNeeded(userId));\n            saveSettingsForUsersLocked(affectedUserIds);\n        }\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_CHANGED,\n                    /* complexity */ metrics.determineComplexity(), /*user*/ userId);\n        }\n    }\n\n    /**\n     * Called any time the device password is updated. Resets all password expiration clocks.\n     *\n     * @return the set of user IDs that have been affected\n     */\n    @GuardedBy(\"getLockObject()\")\n    private Set<Integer> updatePasswordExpirationsLocked(int userHandle) {\n        final ArraySet<Integer> affectedUserIds = new ArraySet<>();\n        List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(userHandle);\n        for (int i = 0; i < admins.size(); i++) {\n            ActiveAdmin admin = admins.get(i);\n            if (admin.info.usesPolicy(DeviceAdminInfo.USES_POLICY_EXPIRE_PASSWORD)) {\n                affectedUserIds.add(admin.getUserHandle().getIdentifier());\n                long timeout = admin.passwordExpirationTimeout;\n                admin.passwordExpirationDate =\n                        timeout > 0L ? (timeout + System.currentTimeMillis()) : 0L;\n            }\n        }\n        return affectedUserIds;\n    }\n\n    @Override\n    public void reportFailedPasswordAttempt(int userHandle, boolean parent) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n        if (!isSeparateProfileChallengeEnabled(userHandle)) {\n            Preconditions.checkCallAuthorization(!isManagedProfile(userHandle),\n                    \"You can not report failed password attempt if separate profile challenge is \"\n                            + \"not in place for a managed profile, userId = %d\", userHandle);\n        }\n\n        boolean wipeData = false;\n        ActiveAdmin strictestAdmin = null;\n        final long ident = mInjector.binderClearCallingIdentity();\n        try {\n            synchronized (getLockObject()) {\n                DevicePolicyData policy = getUserData(userHandle);\n                policy.mFailedPasswordAttempts++;\n                saveSettingsLocked(userHandle);\n                if (mHasFeature) {\n                    strictestAdmin = getAdminWithMinimumFailedPasswordsForWipeLocked(\n                            userHandle, /* parent= */ false);\n                    int max = strictestAdmin != null\n                            ? strictestAdmin.maximumFailedPasswordsForWipe : 0;\n\n                    if (max > 0 && policy.mFailedPasswordAttempts >= max) {\n                        wipeData = true;\n                    }\n\n                    sendAdminCommandForLockscreenPoliciesLocked(\n                            DeviceAdminReceiver.ACTION_PASSWORD_FAILED,\n                            DeviceAdminInfo.USES_POLICY_WATCH_LOGIN, userHandle);\n                }\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n\n        if (wipeData && strictestAdmin != null) {\n            final int userId = getUserIdToWipeForFailedPasswords(strictestAdmin);\n            Slogf.i(LOG_TAG, \"Max failed password attempts policy reached for admin: \"\n                    + strictestAdmin.info.getComponent().flattenToShortString()\n                    + \". Calling wipeData for user \" + userId);\n\n            // Attempt to wipe the device/user/profile associated with the admin, as if the\n            // admin had called wipeData(). That way we can check whether the admin is actually\n            // allowed to wipe the device (e.g. a regular device admin shouldn't be able to wipe the\n            // device if the device owner has set DISALLOW_FACTORY_RESET, but the DO should be\n            // able to do so).\n            // IMPORTANT: Call without holding the lock to prevent deadlock.\n            try {\n                wipeDataNoLock(strictestAdmin.info.getComponent(),\n                        /* flags= */ 0,\n                        /* reason= */ \"reportFailedPasswordAttempt()\",\n                        getFailedPasswordAttemptWipeMessage(),\n                        userId,\n                        // factoryReset=null to enable U- behaviour\n                        /* factoryReset= */ null);\n            } catch (SecurityException e) {\n                Slogf.w(LOG_TAG, \"Failed to wipe user \" + userId\n                        + \" after max failed password attempts reached.\", e);\n            }\n        }\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT,\n                    /* result= */ 0, /* method strength= */ 1);\n        }\n    }\n\n    private String getFailedPasswordAttemptWipeMessage() {\n        return getUpdatableString(\n                WORK_PROFILE_DELETED_FAILED_PASSWORD_ATTEMPTS_MESSAGE,\n               R.string.work_profile_deleted_reason_maximum_password_failure);\n    }\n\n    /**\n     * Returns which user should be wiped if this admin's maximum filed password attempts policy is\n     * violated.\n     */\n    private int getUserIdToWipeForFailedPasswords(ActiveAdmin admin) {\n        final int userId = admin.getUserHandle().getIdentifier();\n        final ComponentName component = admin.info.getComponent();\n        return isProfileOwnerOfOrganizationOwnedDevice(component, userId)\n                ? getProfileParentId(userId) : userId;\n    }\n\n    @Override\n    public void reportSuccessfulPasswordAttempt(int userHandle) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(userHandle);\n            if (policy.mFailedPasswordAttempts != 0 || policy.mPasswordOwner >= 0) {\n                mInjector.binderWithCleanCallingIdentity(() -> {\n                    policy.mFailedPasswordAttempts = 0;\n                    policy.mPasswordOwner = -1;\n                    saveSettingsLocked(userHandle);\n                    if (mHasFeature) {\n                        sendAdminCommandForLockscreenPoliciesLocked(\n                                DeviceAdminReceiver.ACTION_PASSWORD_SUCCEEDED,\n                                DeviceAdminInfo.USES_POLICY_WATCH_LOGIN, userHandle);\n                    }\n                });\n            }\n        }\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT, /*result*/ 1,\n                    /*method strength*/ 1);\n        }\n    }\n\n    @Override\n    public void reportFailedBiometricAttempt(int userHandle) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT, /*result*/ 0,\n                    /*method strength*/ 0);\n        }\n    }\n\n    @Override\n    public void reportSuccessfulBiometricAttempt(int userHandle) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT, /*result*/ 1,\n                    /*method strength*/ 0);\n        }\n    }\n\n    @Override\n    public void reportKeyguardDismissed(int userHandle) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISMISSED);\n        }\n    }\n\n    @Override\n    public void reportKeyguardSecured(int userHandle) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_SECURED);\n        }\n    }\n\n    @Override\n    public ComponentName setGlobalProxy(ComponentName who, String proxySpec,\n            String exclusionList) {\n        if (!mHasFeature) {\n            return null;\n        }\n        synchronized (getLockObject()) {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n\n            // Only check if system user has set global proxy. We don't allow other users to set it.\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            ActiveAdmin admin = getActiveAdminForCallerLocked(who,\n                    DeviceAdminInfo.USES_POLICY_SETS_GLOBAL_PROXY);\n\n            // Scan through active admins and find if anyone has already\n            // set the global proxy.\n            Set<ComponentName> compSet = policy.mAdminMap.keySet();\n            for (ComponentName component : compSet) {\n                ActiveAdmin ap = policy.mAdminMap.get(component);\n                if ((ap.specifiesGlobalProxy) && (!component.equals(who))) {\n                    // Another admin already sets the global proxy\n                    // Return it to the caller.\n                    return component;\n                }\n            }\n\n            // If the user is not system, don't set the global proxy. Fail silently.\n            if (UserHandle.getCallingUserId() != UserHandle.USER_SYSTEM) {\n                Slogf.w(LOG_TAG, \"Only the owner is allowed to set the global proxy. User \"\n                        + UserHandle.getCallingUserId() + \" is not permitted.\");\n                return null;\n            }\n            if (proxySpec == null) {\n                admin.specifiesGlobalProxy = false;\n                admin.globalProxySpec = null;\n                admin.globalProxyExclusionList = null;\n            } else {\n\n                admin.specifiesGlobalProxy = true;\n                admin.globalProxySpec = proxySpec;\n                admin.globalProxyExclusionList = exclusionList;\n            }\n\n            // Reset the global proxy accordingly\n            // Do this using system permissions, as apps cannot write to secure settings\n            mInjector.binderWithCleanCallingIdentity(() -> resetGlobalProxyLocked(policy));\n            return null;\n        }\n    }\n\n    @Override\n    public ComponentName getGlobalProxyAdmin(int userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasFullCrossUsersPermission(caller, userHandle) && canQueryAdminPolicy(caller));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            // Scan through active admins and find if anyone has already\n            // set the global proxy.\n            final int N = policy.mAdminList.size();\n            for (int i = 0; i < N; i++) {\n                ActiveAdmin ap = policy.mAdminList.get(i);\n                if (ap.specifiesGlobalProxy) {\n                    // Device admin sets the global proxy\n                    // Return it to the caller.\n                    return ap.info.getComponent();\n                }\n            }\n        }\n        // No device admin sets the global proxy.\n        return null;\n    }\n\n    @Override\n    public void setRecommendedGlobalProxy(ComponentName who, ProxyInfo proxyInfo) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkAllUsersAreAffiliatedWithDevice();\n        mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getConnectivityManager().setGlobalProxy(proxyInfo));\n    }\n\n    private void resetGlobalProxyLocked(DevicePolicyData policy) {\n        final int N = policy.mAdminList.size();\n        for (int i = 0; i < N; i++) {\n            ActiveAdmin ap = policy.mAdminList.get(i);\n            if (ap.specifiesGlobalProxy) {\n                saveGlobalProxyLocked(ap.globalProxySpec, ap.globalProxyExclusionList);\n                return;\n            }\n        }\n        // No device admins defining global proxies - reset global proxy settings to none\n        saveGlobalProxyLocked(null, null);\n    }\n\n    private void saveGlobalProxyLocked(String proxySpec, String exclusionList) {\n        if (exclusionList == null) {\n            exclusionList = \"\";\n        }\n        if (proxySpec == null) {\n            proxySpec = \"\";\n        }\n        // Remove white spaces\n        proxySpec = proxySpec.trim();\n        String data[] = proxySpec.split(\":\");\n        int proxyPort = 8080;\n        if (data.length > 1) {\n            try {\n                proxyPort = Integer.parseInt(data[1]);\n            } catch (NumberFormatException e) {}\n        }\n        exclusionList = exclusionList.trim();\n\n        ProxyInfo proxyProperties = ProxyInfo.buildDirectProxy(data[0], proxyPort,\n                ProxyUtils.exclusionStringAsList(exclusionList));\n        if (!proxyProperties.isValid()) {\n            Slogf.e(LOG_TAG, \"Invalid proxy properties, ignoring: \" + proxyProperties.toString());\n            return;\n        }\n        mInjector.settingsGlobalPutString(Global.GLOBAL_HTTP_PROXY_HOST, data[0]);\n        mInjector.settingsGlobalPutInt(Global.GLOBAL_HTTP_PROXY_PORT, proxyPort);\n        mInjector.settingsGlobalPutString(Global.GLOBAL_HTTP_PROXY_EXCLUSION_LIST,\n                exclusionList);\n    }\n\n    /**\n     * Called by an application that is administering the device to request that the storage system\n     * be encrypted. Does nothing if the caller is on a secondary user or a managed profile.\n     *\n     * @return the new total request status (for all admins), or {@link\n     *         DevicePolicyManager#ENCRYPTION_STATUS_UNSUPPORTED} if called for a non-system user\n     */\n    @Override\n    public int setStorageEncryption(ComponentName who, boolean encrypt) {\n        if (!mHasFeature) {\n            return DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userHandle = UserHandle.getCallingUserId();\n        synchronized (getLockObject()) {\n            // Check for permissions\n            // Only system user can set storage encryption\n            if (userHandle != UserHandle.USER_SYSTEM) {\n                Slogf.w(LOG_TAG, \"Only owner/system user is allowed to set storage encryption. \"\n                        + \"User \" + UserHandle.getCallingUserId() + \" is not permitted.\");\n                return DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n            }\n\n            ActiveAdmin ap = getActiveAdminForCallerLocked(who,\n                    DeviceAdminInfo.USES_ENCRYPTED_STORAGE);\n\n            // Quick exit:  If the filesystem does not support encryption, we can exit early.\n            if (!isEncryptionSupported()) {\n                return DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n            }\n\n            // (1) Record the value for the admin so it's sticky\n            if (ap.encryptionRequested != encrypt) {\n                ap.encryptionRequested = encrypt;\n                saveSettingsLocked(userHandle);\n            }\n\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            // (2) Compute \"max\" for all admins\n            boolean newRequested = false;\n            final int N = policy.mAdminList.size();\n            for (int i = 0; i < N; i++) {\n                newRequested |= policy.mAdminList.get(i).encryptionRequested;\n            }\n\n            // Notify OS of new request\n            setEncryptionRequested(newRequested);\n\n            // Return the new global request status\n            return newRequested\n                    ? DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE\n                    : DevicePolicyManager.ENCRYPTION_STATUS_INACTIVE;\n        }\n    }\n\n    /**\n     * Get the current storage encryption request status for a given admin, or aggregate of all\n     * active admins.\n     */\n    @Override\n    public boolean getStorageEncryption(@Nullable ComponentName who, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            // Check for permissions if a particular caller is specified\n            if (caller.hasAdminComponent()) {\n                // When checking for a single caller, status is based on caller's request\n                ActiveAdmin ap = getActiveAdminUncheckedLocked(who, userHandle);\n                return ap != null ? ap.encryptionRequested : false;\n            }\n\n            // If no particular caller is specified, return the aggregate set of requests.\n            // This is short circuited by returning true on the first hit.\n            DevicePolicyData policy = getUserData(userHandle);\n            final int N = policy.mAdminList.size();\n            for (int i = 0; i < N; i++) {\n                if (policy.mAdminList.get(i).encryptionRequested) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Get the current encryption status of the device.\n     */\n    @Override\n    public int getStorageEncryptionStatus(@Nullable String callerPackage, int userHandle) {\n        if (!mHasFeature) {\n            // Ok to return current status.\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n\n        final ApplicationInfo ai;\n        try {\n            ai = mIPackageManager.getApplicationInfo(callerPackage, 0, userHandle);\n        } catch (RemoteException e) {\n            throw new SecurityException(e);\n        }\n\n        boolean legacyApp = false;\n        if (ai.targetSdkVersion <= Build.VERSION_CODES.M) {\n            legacyApp = true;\n        }\n\n        final int rawStatus = getEncryptionStatus();\n        if ((rawStatus == ENCRYPTION_STATUS_ACTIVE_PER_USER) && legacyApp) {\n            return DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE;\n        }\n        return rawStatus;\n    }\n\n    /**\n     * Hook to low-levels:  This should report if the filesystem supports encrypted storage.\n     */\n    private boolean isEncryptionSupported() {\n        // Note, this can be implemented as\n        //   return getEncryptionStatus() != DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n        // But is provided as a separate internal method if there's a faster way to do a\n        // simple check for supported-or-not.\n        return getEncryptionStatus() != DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n    }\n\n    /**\n     * Hook to low-levels:  Reporting the current status of encryption.\n     * @return Either {@link DevicePolicyManager#ENCRYPTION_STATUS_UNSUPPORTED}\n     * or {@link DevicePolicyManager#ENCRYPTION_STATUS_ACTIVE_PER_USER}.\n     */\n    private int getEncryptionStatus() {\n        if (mInjector.storageManagerIsFileBasedEncryptionEnabled()) {\n            return ENCRYPTION_STATUS_ACTIVE_PER_USER;\n        } else {\n            return DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n        }\n    }\n\n    /**\n     * Hook to low-levels:  If needed, record the new admin setting for encryption.\n     */\n    private void setEncryptionRequested(boolean encrypt) {\n    }\n\n    /**\n     * Set whether the screen capture is disabled for the user managed by the specified admin.\n     */\n    @Override\n    public void setScreenCaptureDisabled(\n            ComponentName who, String callerPackage, boolean disabled, boolean parent) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        int callerUserId = Binder.getCallingUserHandle().getIdentifier();\n        int targetUserId = parent ? getProfileParentId(callerUserId) : callerUserId;\n        EnforcingAdmin admin = enforcePermissionAndGetEnforcingAdmin(\n                who, MANAGE_DEVICE_POLICY_SCREEN_CAPTURE, caller.getPackageName(),\n                targetUserId);\n        if ((parent && isProfileOwnerOfOrganizationOwnedDevice(caller))\n                || isDefaultDeviceOwner(caller)) {\n            if (disabled) {\n                mDevicePolicyEngine.setGlobalPolicy(\n                        PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                        admin,\n                        new BooleanPolicyValue(disabled));\n            } else {\n                mDevicePolicyEngine.removeGlobalPolicy(\n                        PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                        admin);\n            }\n        } else {\n            if (disabled) {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                        admin,\n                        new BooleanPolicyValue(disabled),\n                        callerUserId);\n            } else {\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                        admin,\n                        callerUserId);\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SCREEN_CAPTURE_DISABLED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(disabled)\n                .write();\n    }\n\n    /**\n     * Returns whether or not screen capture is disabled for  any active admin.\n     */\n    @Override\n    public boolean getScreenCaptureDisabled(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return false;\n        }\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        if (parent) {\n            Preconditions.checkCallAuthorization(\n                    isProfileOwnerOfOrganizationOwnedDevice(caller.getUserId()));\n            // If a DPC is querying on the parent instance, make sure it's only querying the parent\n            // user of itself. Querying any other user is not allowed.\n            Preconditions.checkArgument(caller.getUserId() == userHandle);\n        }\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n        Boolean disallowed = mDevicePolicyEngine.getResolvedPolicy(\n                PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                affectedUserId);\n        return disallowed != null && disallowed;\n    }\n\n    private void updateScreenCaptureDisabled() {\n        mHandler.post(() -> {\n            try {\n                mInjector.getIWindowManager().refreshScreenCaptureDisabled();\n            } catch (RemoteException e) {\n                Slogf.w(LOG_TAG, \"Unable to notify WindowManager.\", e);\n            }\n        });\n    }\n\n    @Override\n    public void setNearbyNotificationStreamingPolicy(int policy) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (admin.mNearbyNotificationStreamingPolicy != policy) {\n                admin.mNearbyNotificationStreamingPolicy = policy;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public int getNearbyNotificationStreamingPolicy(final int userId) {\n        if (!mHasFeature) {\n            return NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                        || hasCallingOrSelfPermission(permission.READ_NEARBY_STREAMING_POLICY));\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userId);\n            return admin != null\n                    ? admin.mNearbyNotificationStreamingPolicy\n                    : NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\n        }\n    }\n\n    @Override\n    public void setNearbyAppStreamingPolicy(int policy) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (admin.mNearbyAppStreamingPolicy != policy) {\n                admin.mNearbyAppStreamingPolicy = policy;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public int getNearbyAppStreamingPolicy(final int userId) {\n        if (!mHasFeature) {\n            return NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                        || hasCallingOrSelfPermission(permission.READ_NEARBY_STREAMING_POLICY));\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userId);\n            return admin != null\n                    ? admin.mNearbyAppStreamingPolicy\n                    : NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\n        }\n    }\n\n    /**\n     * Set whether auto time is required by the specified admin (must be device or profile owner).\n     */\n    @Override\n    public void setAutoTimeRequired(ComponentName who, boolean required) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDeviceOwner(caller) || isProfileOwner(caller));\n\n        boolean requireAutoTimeChanged = false;\n        synchronized (getLockObject()) {\n            Preconditions.checkCallAuthorization(!isManagedProfile(caller.getUserId()),\n                    \"Managed profile cannot set auto time required\");\n\n            EnforcingAdmin admin = getEnforcingAdminForCaller(who, who.getPackageName());\n            setGlobalUserRestrictionInternal(\n                    admin, UserManager.DISALLOW_CONFIG_DATE_TIME, required);\n        }\n        // Turn AUTO_TIME on in settings if it is required\n        if (required) {\n            mInjector.binderWithCleanCallingIdentity(\n                    () -> mInjector.settingsGlobalPutInt(Global.AUTO_TIME,\n                            1 /* AUTO_TIME on */));\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_AUTO_TIME_REQUIRED)\n                .setAdmin(who)\n                .setBoolean(required)\n                .write();\n    }\n\n    /**\n     * Returns whether or not auto time is required by the device owner or any profile owner.\n     */\n    @Override\n    public boolean getAutoTimeRequired() {\n        if (!mHasFeature) {\n            return false;\n        }\n        Boolean required = mDevicePolicyEngine.getResolvedPolicy(\n                PolicyDefinition.getPolicyDefinitionForUserRestriction(\n                        UserManager.DISALLOW_CONFIG_DATE_TIME),\n                mInjector.binderGetCallingUserHandle().getIdentifier());\n        return required != null && required;\n    }\n\n    /**\n     * Set whether auto time is enabled on the device.\n     */\n    @Override\n    public void setAutoTimeEnabled(@Nullable ComponentName who, String callerPackageName,\n            boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        CallerIdentity caller = getCallerIdentity(who);\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isProfileOwnerOnUser0(caller)\n                || isProfileOwnerOfOrganizationOwnedDevice(caller) || isDefaultDeviceOwner(\n                caller));\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.settingsGlobalPutInt(Settings.Global.AUTO_TIME, enabled ? 1 : 0));\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_AUTO_TIME)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(enabled)\n                .write();\n    }\n\n    /**\n     * Returns whether auto time is used on the device or not.\n     */\n    @Override\n    public boolean getAutoTimeEnabled(@Nullable ComponentName who, String callerPackageName) {\n        if (!mHasFeature) {\n            return false;\n        }\n        CallerIdentity caller = getCallerIdentity(who);\n\n        if (Flags.setAutoTimeEnabledCoexistence()) {\n            Preconditions.checkCallAuthorization(hasPermission(SET_TIME, callerPackageName));\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwnerOnUser0(caller)\n                || isProfileOwnerOfOrganizationOwnedDevice(caller) || isDefaultDeviceOwner(caller));\n        }\n\n        return mInjector.settingsGlobalGetInt(Global.AUTO_TIME, 0) > 0;\n    }\n\n    /**\n     * Set whether auto time is enabled on the device.\n     */\n    @Override\n    public void setAutoTimePolicy(String callerPackageName, int policy) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        final Set<Integer> allowedValues =\n                Set.of(\n                        DevicePolicyManager.AUTO_TIME_ENABLED,\n                        DevicePolicyManager.AUTO_TIME_DISABLED,\n                        DevicePolicyManager.AUTO_TIME_NOT_CONTROLLED_BY_POLICY);\n        Preconditions.checkArgument(\n                allowedValues.contains(policy), \"Provided mode is not one of the allowed values.\");\n\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        // The effect of this policy is device-wide.\n        EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                /* who */ null,\n                SET_TIME,\n                caller.getPackageName(),\n                UserHandle.USER_ALL\n        );\n        if (policy == DevicePolicyManager.AUTO_TIME_NOT_CONTROLLED_BY_POLICY) {\n            mDevicePolicyEngine.removeGlobalPolicy(PolicyDefinition.AUTO_TIME, enforcingAdmin);\n        } else {\n            mDevicePolicyEngine.setGlobalPolicy(\n                    PolicyDefinition.AUTO_TIME,\n                    enforcingAdmin,\n                    new IntegerPolicyValue(policy));\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_AUTO_TIME)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(policy == DevicePolicyManager.AUTO_TIME_ENABLED)\n                    .write();\n        }\n    }\n\n    /**\n     * Returns whether auto time is used on the device or not.\n     */\n    @Override\n    public int getAutoTimePolicy(String callerPackageName) {\n        if (!mHasFeature) {\n            return DevicePolicyManager.AUTO_TIME_NOT_CONTROLLED_BY_POLICY;\n        }\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        // The effect of this policy is device-wide.\n        EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                /* who */ null,\n                SET_TIME,\n                callerPackageName,\n                UserHandle.USER_ALL\n        );\n        Integer state = mDevicePolicyEngine.getGlobalPolicySetByAdmin(\n                PolicyDefinition.AUTO_TIME, enforcingAdmin);\n        return state != null ? state : DevicePolicyManager.AUTO_TIME_NOT_CONTROLLED_BY_POLICY;\n    }\n\n    /**\n     * Set whether auto time zone is enabled on the device.\n     */\n    @Override\n    public void setAutoTimeZoneEnabled(@Nullable ComponentName who, String callerPackageName,\n            boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        CallerIdentity caller = getCallerIdentity(who);\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isProfileOwnerOnUser0(caller)\n                || isProfileOwnerOfOrganizationOwnedDevice(caller) || isDefaultDeviceOwner(\n                caller));\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.settingsGlobalPutInt(Global.AUTO_TIME_ZONE, enabled ? 1 : 0));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_AUTO_TIME_ZONE)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(enabled)\n                .write();\n    }\n\n    /**\n     * Returns whether auto time zone is used on the device or not.\n     */\n    @Override\n    public boolean getAutoTimeZoneEnabled(@Nullable ComponentName who, String callerPackageName) {\n        if (!mHasFeature) {\n            return false;\n        }\n\n        CallerIdentity caller = getCallerIdentity(who);\n        if (Flags.setAutoTimeZoneEnabledCoexistence()) {\n            Preconditions.checkCallAuthorization(\n                hasPermission(SET_TIME_ZONE, callerPackageName));\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwnerOnUser0(caller)\n                || isProfileOwnerOfOrganizationOwnedDevice(caller) || isDefaultDeviceOwner(\n                caller));\n        }\n        return mInjector.settingsGlobalGetInt(Global.AUTO_TIME_ZONE, 0) > 0;\n    }\n\n    /**\n     * Set auto time zone state.\n     */\n    public void setAutoTimeZonePolicy(String callerPackageName, int policy) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        // The effect of this policy is device-wide.\n        EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                /* who */ null,\n                SET_TIME_ZONE,\n                caller.getPackageName(),\n                UserHandle.USER_ALL\n        );\n\n        if (policy != DevicePolicyManager.AUTO_TIME_ZONE_NOT_CONTROLLED_BY_POLICY) {\n            mDevicePolicyEngine.setGlobalPolicy(\n                    PolicyDefinition.AUTO_TIME_ZONE,\n                    enforcingAdmin,\n                    new IntegerPolicyValue(policy));\n\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_AUTO_TIME_ZONE)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(policy == DevicePolicyManager.AUTO_TIME_ZONE_ENABLED)\n                    .write();\n        } else {\n            mDevicePolicyEngine.removeGlobalPolicy(\n                    PolicyDefinition.AUTO_TIME_ZONE,\n                    enforcingAdmin);\n        }\n    }\n\n    /**\n     * Returns whether auto time zone is used on the device or not.\n     */\n    @Override\n    public int getAutoTimeZonePolicy(String callerPackageName) {\n        if (!mHasFeature) {\n            return DevicePolicyManager.AUTO_TIME_ZONE_NOT_CONTROLLED_BY_POLICY;\n        }\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        // The effect of this policy is device-wide.\n        EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                /* who */ null,\n                SET_TIME_ZONE,\n                callerPackageName,\n                UserHandle.USER_ALL\n        );\n        Integer state = mDevicePolicyEngine.getGlobalPolicySetByAdmin(\n                PolicyDefinition.AUTO_TIME_ZONE, enforcingAdmin);\n        return state != null ? state : DevicePolicyManager.AUTO_TIME_ZONE_NOT_CONTROLLED_BY_POLICY;\n    }\n\n    // TODO (b/137101239): remove this method in follow-up CL\n    // since it's only used for split system user.\n    @Override\n    public void setForceEphemeralUsers(ComponentName who, boolean forceEphemeralUsers) {\n        throw new UnsupportedOperationException(\"This method was used by split system user only.\");\n    }\n\n    // TODO (b/137101239): remove this method in follow-up CL\n    // since it's only used for split system user.\n    @Override\n    public boolean getForceEphemeralUsers(ComponentName who) {\n        throw new UnsupportedOperationException(\"This method was used by split system user only.\");\n    }\n\n    @Override\n    public boolean requestBugreport(ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        // TODO: If an unaffiliated user is removed, the admin will be able to request a bugreport\n        // which could still contain data related to that user. Should we disallow that, e.g. until\n        // next boot? Might not be needed given that this still requires user consent.\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkAllUsersAreAffiliatedWithDevice();\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_REQUEST_BUGREPORT);\n\n        if (mBugreportCollectionManager.requestBugreport()) {\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.REQUEST_BUGREPORT)\n                    .setAdmin(who)\n                    .write();\n\n            final long currentTime = System.currentTimeMillis();\n            synchronized (getLockObject()) {\n                DevicePolicyData policyData = getUserData(UserHandle.USER_SYSTEM);\n                if (currentTime > policyData.mLastBugReportRequestTime) {\n                    policyData.mLastBugReportRequestTime = currentTime;\n                    saveSettingsLocked(UserHandle.USER_SYSTEM);\n                }\n            }\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    void sendDeviceOwnerCommand(String action, Bundle extras) {\n        final int deviceOwnerUserId;\n        final ComponentName receiverComponent;\n        synchronized (getLockObject()) {\n            deviceOwnerUserId = mOwners.getDeviceOwnerUserId();\n            receiverComponent = mOwners.getDeviceOwnerComponent();\n        }\n        sendActiveAdminCommand(action, extras, deviceOwnerUserId, receiverComponent,\n                /* inForeground */ false);\n    }\n\n    void sendDeviceOwnerOrProfileOwnerCommand(String action, Bundle extras, int userId) {\n        if (userId == UserHandle.USER_ALL) {\n            if (getHeadlessDeviceOwnerModeForDeviceOwner()\n                    == HEADLESS_DEVICE_OWNER_MODE_SINGLE_USER) {\n                userId = mOwners.getDeviceOwnerUserId();\n            } else {\n                userId = UserHandle.USER_SYSTEM;\n            }\n        }\n        boolean inForeground = false;\n        ComponentName receiverComponent = null;\n        if (action.equals(DeviceAdminReceiver.ACTION_NETWORK_LOGS_AVAILABLE)) {\n            inForeground = true;\n            receiverComponent = resolveDelegateReceiver(DELEGATION_NETWORK_LOGGING, action, userId);\n        }\n        if (action.equals(DeviceAdminReceiver.ACTION_SECURITY_LOGS_AVAILABLE)) {\n            inForeground = true;\n            receiverComponent = resolveDelegateReceiver(\n                DELEGATION_SECURITY_LOGGING, action, userId);\n        }\n        if (receiverComponent == null) {\n            receiverComponent = getOwnerComponent(userId);\n        }\n        sendActiveAdminCommand(action, extras, userId, receiverComponent, inForeground);\n    }\n\n    private void sendProfileOwnerCommand(String action, Bundle extras, @UserIdInt int userId) {\n        sendActiveAdminCommand(action, extras, userId, mOwners.getProfileOwnerComponent(userId),\n                /* inForeground */ false);\n    }\n\n    private void sendActiveAdminCommand(String action, Bundle extras,\n            @UserIdInt int userId, ComponentName receiverComponent, boolean inForeground) {\n        final Intent intent = new Intent(action);\n        intent.setComponent(receiverComponent);\n        if (extras != null) {\n            intent.putExtras(extras);\n        }\n        if (inForeground) {\n            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        }\n\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"sendActiveAdminCommand(): broadcasting \" + action + \" to \"\n                    + receiverComponent.flattenToShortString() + \" on user \" + userId);\n        }\n        mContext.sendBroadcastAsUser(intent, UserHandle.of(userId));\n    }\n\n    private void sendOwnerChangedBroadcast(String broadcast, int userId) {\n        final Intent intent = new Intent(broadcast)\n                .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        mContext.sendBroadcastAsUser(intent, UserHandle.of(userId));\n    }\n\n    void sendBugreportToDeviceOwner(Uri bugreportUri, String bugreportHash) {\n        synchronized (getLockObject()) {\n            final Intent intent = new Intent(DeviceAdminReceiver.ACTION_BUGREPORT_SHARE);\n            intent.setComponent(mOwners.getDeviceOwnerComponent());\n            intent.setDataAndType(bugreportUri, RemoteBugreportManager.BUGREPORT_MIMETYPE);\n            intent.putExtra(DeviceAdminReceiver.EXTRA_BUGREPORT_HASH, bugreportHash);\n            intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n\n            final UriGrantsManagerInternal ugm = LocalServices\n                    .getService(UriGrantsManagerInternal.class);\n            final NeededUriGrants needed = ugm.checkGrantUriPermissionFromIntent(intent,\n                    Process.SHELL_UID, mOwners.getDeviceOwnerComponent().getPackageName(),\n                    mOwners.getDeviceOwnerUserId());\n            ugm.grantUriPermissionUncheckedFromIntent(needed, null);\n\n            mContext.sendBroadcastAsUser(intent, UserHandle.of(mOwners.getDeviceOwnerUserId()));\n        }\n    }\n\n    void setDeviceOwnerRemoteBugreportUriAndHash(String bugreportUri, String bugreportHash) {\n        synchronized (getLockObject()) {\n            mOwners.setDeviceOwnerRemoteBugreportUriAndHash(bugreportUri, bugreportHash);\n        }\n    }\n\n    Pair<String, String> getDeviceOwnerRemoteBugreportUriAndHash() {\n        synchronized (getLockObject()) {\n            final String uri = mOwners.getDeviceOwnerRemoteBugreportUri();\n            return uri == null ? null\n                    : new Pair<>(uri, mOwners.getDeviceOwnerRemoteBugreportHash());\n        }\n    }\n\n    /**\n     * Disables all device cameras according to the specified admin.\n     */\n    @Override\n    public void setCameraDisabled(ComponentName who, String callerPackageName, boolean disabled,\n            boolean parent) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        final int userId = caller.getUserId();\n\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_CAMERA_DISABLED);\n        EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                who,\n                MANAGE_DEVICE_POLICY_CAMERA,\n                caller.getPackageName(),\n                getProfileParentUserIfRequested(userId, parent));\n        try {\n            setBackwardCompatibleUserRestriction(\n                    caller, enforcingAdmin, UserManager.DISALLOW_CAMERA, disabled, parent);\n        } catch (IllegalStateException e) {\n            throw new IllegalStateException(\n                    \"Please use addUserRestriction or addUserRestrictionGlobally using the key\"\n                            + \" UserManager.DISALLOW_CAMERA to disable the camera locally or\"\n                            + \" globally, respectively\");\n        }\n\n        final int affectedUserId = parent ? getProfileParentId(userId) : userId;\n        if (SecurityLog.isLoggingEnabled() && who != null) {\n            SecurityLog.writeEvent(SecurityLog.TAG_CAMERA_POLICY_SET,\n                    who.getPackageName(), userId, affectedUserId, disabled ? 1 : 0);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CAMERA_DISABLED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(disabled)\n                .setStrings(parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT)\n                .write();\n    }\n\n    /**\n     * Gets whether or not all device cameras are disabled for a given admin, or disabled for any\n     * active admins.\n     */\n    @Override\n    public boolean getCameraDisabled(ComponentName who, String callerPackageName, int userHandle,\n            boolean parent) {\n        if (!mHasFeature) {\n            return false;\n        }\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        Preconditions.checkCallAuthorization(\n                hasFullCrossUsersPermission(caller, userHandle)\n                        || isCameraServerUid(caller)\n                        || hasPermission(MANAGE_DEVICE_POLICY_CAMERA,\n                            caller.getPackageName(), userHandle)\n                        || hasPermission(QUERY_ADMIN_POLICY, caller.getPackageName()));\n\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n        PolicyDefinition<Boolean> policy =\n                PolicyDefinition.getPolicyDefinitionForUserRestriction(\n                        UserManager.DISALLOW_CAMERA);\n        if (who != null) {\n            EnforcingAdmin admin = getEnforcingAdminForCaller(who, callerPackageName);\n            Boolean value = null;\n            if (isDeviceOwner(caller)) {\n                value = mDevicePolicyEngine.getGlobalPolicySetByAdmin(policy, admin);\n            } else {\n                value = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                        policy, admin, affectedUserId);\n            }\n            return Boolean.TRUE.equals(value);\n\n        } else {\n            return Boolean.TRUE.equals(\n                    mDevicePolicyEngine.getResolvedPolicy(policy, affectedUserId));\n        }\n    }\n\n    @Override\n    public void setKeyguardDisabledFeatures(\n            ComponentName who, String callerPackageName, int which, boolean parent) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        CallerIdentity caller;\n        if (Flags.setKeyguardDisabledFeaturesCoexistence()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n        }\n\n        final int userHandle = caller.getUserId();\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n        synchronized (getLockObject()) {\n            if (Flags.setKeyguardDisabledFeaturesCoexistence()) {\n                // SUPPORT USES_POLICY_DISABLE_KEYGUARD_FEATURES\n                EnforcingAdmin admin = enforcePermissionAndGetEnforcingAdmin(\n                        who, MANAGE_DEVICE_POLICY_KEYGUARD, caller.getPackageName(),\n                        affectedUserId);\n                if (which == 0) {\n                    mDevicePolicyEngine.removeLocalPolicy(\n                            PolicyDefinition.KEYGUARD_DISABLED_FEATURES, admin, affectedUserId);\n                } else {\n                    // TODO(b/273723433): revisit silent masking of features\n                    if (isManagedProfile(userHandle)) {\n                        if (parent) {\n                            if (isProfileOwnerOfOrganizationOwnedDevice(caller)) {\n                                which = which & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\n                            } else {\n                                which = which\n                                        & NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\n                            }\n                        } else {\n                            which = which & PROFILE_KEYGUARD_FEATURES;\n                        }\n                    }\n                    mDevicePolicyEngine.setLocalPolicy(PolicyDefinition.KEYGUARD_DISABLED_FEATURES,\n                            admin, new IntegerPolicyValue(which), affectedUserId);\n                }\n                invalidateBinderCaches();\n            } else {\n                ActiveAdmin ap = getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_DISABLE_KEYGUARD_FEATURES, parent);\n                if (isManagedProfile(userHandle)) {\n                    if (parent) {\n                        if (isProfileOwnerOfOrganizationOwnedDevice(caller)) {\n                            which = which & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\n                        } else {\n                            which = which & NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\n                        }\n                    } else {\n                        which = which & PROFILE_KEYGUARD_FEATURES;\n                    }\n                }\n                if (ap.disabledKeyguardFeatures != which) {\n                    ap.disabledKeyguardFeatures = which;\n                    saveSettingsLocked(userHandle);\n                }\n            }\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISABLED_FEATURES_SET,\n                    caller.getPackageName(), userHandle, affectedUserId, which);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_KEYGUARD_DISABLED_FEATURES)\n                .setAdmin(caller.getPackageName())\n                .setInt(which)\n                .setStrings(parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT)\n                .write();\n    }\n\n    /**\n     * Gets the disabled state for features in keyguard for the given admin,\n     * or the aggregate of all active admins if who is null.\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public int getKeyguardDisabledFeatures(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(\n                who == null || isCallingFromPackage(who.getPackageName(), caller.getUid())\n                        || isSystemUid(caller));\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n\n        synchronized (getLockObject()) {\n            if (who != null) {\n                if (Flags.setKeyguardDisabledFeaturesCoexistence()) {\n                    EnforcingAdmin admin = getEnforcingAdminForPackage(\n                            who, who.getPackageName(), userHandle);\n                    Integer features = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                            PolicyDefinition.KEYGUARD_DISABLED_FEATURES,\n                            admin,\n                            affectedUserId);\n\n                    return features == null ? 0 : features;\n                } else {\n                    ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                    return (admin != null) ? admin.disabledKeyguardFeatures : 0;\n                }\n            }\n\n            // TODO: with a quick glance this logic seems incomplete that it doesn't properly handle\n            // the different behaviour between a profile with separate challenge vs a profile with\n            // unified challenge, which was part of getActiveAdminsForLockscreenPoliciesLocked()\n            // before the migration.\n            if (Flags.setKeyguardDisabledFeaturesCoexistence()) {\n                Integer features = mDevicePolicyEngine.getResolvedPolicy(\n                        PolicyDefinition.KEYGUARD_DISABLED_FEATURES,\n                        affectedUserId);\n\n                return Binder.withCleanCallingIdentity(() -> {\n                    int combinedFeatures = features == null ? 0 : features;\n                    List<UserInfo> profiles = mUserManager.getProfiles(affectedUserId);\n                    for (UserInfo profile : profiles) {\n                        int profileId = profile.id;\n                        if (profileId == affectedUserId) {\n                            continue;\n                        }\n                        Integer profileFeatures = mDevicePolicyEngine.getResolvedPolicy(\n                                PolicyDefinition.KEYGUARD_DISABLED_FEATURES,\n                                profileId);\n                        if (profileFeatures != null) {\n                            combinedFeatures |= (profileFeatures\n                                    & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER);\n                        }\n                    }\n                    return combinedFeatures;\n                });\n            }\n\n            final long ident = mInjector.binderClearCallingIdentity();\n            try {\n                final List<ActiveAdmin> admins;\n                if (!parent && isManagedProfile(userHandle)) {\n                    // If we are being asked about a managed profile, just return keyguard features\n                    // disabled by admins in the profile.\n                    admins = getUserDataUnchecked(userHandle).mAdminList;\n                } else {\n                    // Otherwise return those set by admins in the user and its profiles.\n                    admins = getActiveAdminsForLockscreenPoliciesLocked(\n                            getProfileParentUserIfRequested(userHandle, parent));\n                }\n\n                int which = DevicePolicyManager.KEYGUARD_DISABLE_FEATURES_NONE;\n                final int N = admins.size();\n                for (int i = 0; i < N; i++) {\n                    ActiveAdmin admin = admins.get(i);\n                    int userId = admin.getUserHandle().getIdentifier();\n                    boolean isRequestedUser = !parent && (userId == userHandle);\n                    if (isRequestedUser || !isManagedProfile(userId)) {\n                        // If we are being asked explicitly about this user\n                        // return all disabled features even if its a managed profile.\n                        which |= admin.disabledKeyguardFeatures;\n                    } else {\n                        // Otherwise a managed profile is only allowed to disable\n                        // some features on the parent user.\n                        which |= (admin.disabledKeyguardFeatures\n                                & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER);\n                    }\n                }\n                return which;\n            } finally {\n                mInjector.binderRestoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public void setKeepUninstalledPackages(ComponentName who, String callerPackage,\n            List<String> packageList) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(packageList, \"packageList is null\");\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                &&  isDefaultDeviceOwner(caller))\n                || (caller.hasPackage()\n                && isCallerDelegate(caller, DELEGATION_KEEP_UNINSTALLED_PACKAGES)));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_KEEP_UNINSTALLED_PACKAGES);\n\n        synchronized (getLockObject()) {\n            // Get the device owner\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            // Set list of packages to be kept even if uninstalled.\n            deviceOwner.keepUninstalledPackages = packageList;\n            // Save settings.\n            saveSettingsLocked(caller.getUserId());\n            // Notify package manager.\n            mInjector.getPackageManagerInternal().setKeepUninstalledPackages(packageList);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_KEEP_UNINSTALLED_PACKAGES)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ who == null)\n                .setStrings(packageList.toArray(new String[0]))\n                .write();\n    }\n\n    @Override\n    public List<String> getKeepUninstalledPackages(ComponentName who, String callerPackage) {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                &&  isDefaultDeviceOwner(caller))\n                || (caller.hasPackage()\n                && isCallerDelegate(caller, DELEGATION_KEEP_UNINSTALLED_PACKAGES)));\n\n        synchronized (getLockObject()) {\n            return getKeepUninstalledPackagesLocked();\n        }\n    }\n\n    private List<String> getKeepUninstalledPackagesLocked() {\n        ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n        return (deviceOwner != null) ? deviceOwner.keepUninstalledPackages : null;\n    }\n\n    /**\n     * Logs a warning when the device doesn't have {@code PackageManager.FEATURE_DEVICE_ADMIN}.\n     *\n     * @param message action that was not executed; should not end with a period because the missing\n     * feature will be appended to it.\n     */\n    private void logMissingFeatureAction(String message) {\n        Slogf.w(LOG_TAG, message + \" because device does not have the \"\n                + PackageManager.FEATURE_DEVICE_ADMIN + \" feature.\");\n    }\n\n    @Override\n    public boolean setDeviceOwner(ComponentName admin, int userId,\n            boolean setProfileOwnerOnCurrentUserIfNecessary) {\n        if (!mHasFeature) {\n            logMissingFeatureAction(\"Cannot set \" + ComponentName.flattenToShortString(admin)\n                    + \" as device owner for user \" + userId);\n            return false;\n        }\n        Preconditions.checkArgument(admin != null);\n\n        final CallerIdentity caller = getCallerIdentity();\n\n        boolean hasIncompatibleAccountsOrNonAdb =\n                !isAdb(caller) || hasIncompatibleAccountsOnAnyUser();\n\n        if (!hasIncompatibleAccountsOrNonAdb) {\n            synchronized (getLockObject()) {\n                if (!isAdminTestOnlyLocked(admin, userId) && hasAccountsOnAnyUser()) {\n                    Slogf.w(LOG_TAG,\n                            \"Non test-only owner can't be installed with existing accounts.\");\n                    return false;\n                }\n            }\n        }\n\n        synchronized (getLockObject()) {\n            enforceCanSetDeviceOwnerLocked(caller, admin, userId, hasIncompatibleAccountsOrNonAdb);\n\n            Preconditions.checkArgument(isPackageInstalledForUser(admin.getPackageName(), userId),\n                    \"Invalid component \" + admin + \" for device owner\");\n            final ActiveAdmin activeAdmin = getActiveAdminUncheckedLocked(admin, userId);\n            Preconditions.checkArgument(activeAdmin != null && !getUserData(\n                    userId).mRemovingAdmins.contains(admin), \"Not active admin: \" + admin);\n\n            // Shutting down backup manager service permanently.\n            toggleBackupServiceActive(UserHandle.USER_SYSTEM, /* makeActive= */ false);\n            if (isAdb(caller)) {\n                // Log device owner provisioning was started using adb.\n                MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_DEVICE_OWNER);\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.PROVISIONING_ENTRY_POINT_ADB)\n                        .setAdmin(admin)\n                        .setStrings(LOG_TAG_DEVICE_OWNER)\n                        .write();\n            }\n\n            mOwners.setDeviceOwner(admin, userId);\n            mOwners.writeDeviceOwner();\n\n            //TODO(b/180371154): when provisionFullyManagedDevice is used in tests, remove this\n            // hard-coded default value setting.\n            if (isAdb(caller)) {\n                activeAdmin.mAdminCanGrantSensorsPermissions = true;\n                mPolicyCache.setAdminCanGrantSensorsPermissions(true);\n                saveSettingsLocked(userId);\n            }\n\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                // Restrict adding a managed profile when a device owner is set on the device.\n                // That is to prevent the co-existence of a managed profile and a device owner\n                // on the same device.\n                // Instead, the device may be provisioned with an organization-owned managed\n                // profile, such that the admin on that managed profile has extended management\n                // capabilities that can affect the entire device (but not access private data\n                // on the primary profile).\n                for (int u : mUserManagerInternal.getUserIds()) {\n                    mUserManager.setUserRestriction(\n                            UserManager.DISALLOW_ADD_MANAGED_PROFILE, true,\n                            UserHandle.of(u));\n                    // Restrict adding a clone profile when a device owner is set on the device.\n                    // That is to prevent the co-existence of a clone profile and a device owner\n                    // on the same device.\n                    // CDD for reference : https://source.android.com/compatibility/12/android-12-cdd#95_multi-user_support\n                    mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE,\n                            true,\n                            UserHandle.of(u));\n\n                    // Restrict adding a private profile when a device owner is set.\n                    mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_PRIVATE_PROFILE,\n                            true,\n                            UserHandle.of(u));\n                }\n\n                // TODO Send to system too?\n                sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_DEVICE_OWNER_CHANGED, userId);\n            });\n            mDeviceAdminServiceController.startServiceForAdmin(\n                    admin.getPackageName(), userId, \"set-device-owner\");\n\n            Slogf.i(LOG_TAG, \"Device owner set: \" + admin + \" on user \" + userId);\n        }\n\n        if (setProfileOwnerOnCurrentUserIfNecessary\n                && mInjector.userManagerIsHeadlessSystemUserMode()\n                && getHeadlessDeviceOwnerModeForDeviceOwner()\n                == HEADLESS_DEVICE_OWNER_MODE_AFFILIATED) {\n            int currentForegroundUser;\n            synchronized (getLockObject()) {\n                currentForegroundUser = getCurrentForegroundUserId();\n            }\n            Slogf.i(LOG_TAG, \"setDeviceOwner(): setting \" + admin\n                    + \" as profile owner on user \" + currentForegroundUser);\n            // Sets profile owner on current foreground user since\n            // the human user will complete the DO setup workflow from there.\n            manageUserUnchecked(/* deviceOwner= */ admin, /* profileOwner= */ admin,\n                    /* managedUser= */ currentForegroundUser, /* adminExtras= */ null,\n                    /* showDisclaimer= */ false);\n        }\n        return true;\n    }\n\n    private int getHeadlessDeviceOwnerModeForDeviceOwner() {\n        synchronized (getLockObject()) {\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (deviceOwner == null) {\n                return HEADLESS_DEVICE_OWNER_MODE_UNSUPPORTED;\n            }\n            return deviceOwner.info.getHeadlessDeviceOwnerMode();\n        }\n    }\n\n    private int getHeadlessDeviceOwnerModeForDeviceAdmin(\n            @Nullable ComponentName deviceAdmin, int userId) {\n        synchronized (getLockObject()) {\n            if (deviceAdmin == null) {\n                return HEADLESS_DEVICE_OWNER_MODE_UNSUPPORTED;\n            }\n            DeviceAdminInfo adminInfo = findAdmin(\n                    deviceAdmin, userId, /* throwForMissingPermission= */ false);\n            if (adminInfo == null) {\n                return HEADLESS_DEVICE_OWNER_MODE_UNSUPPORTED;\n            }\n            return adminInfo.getHeadlessDeviceOwnerMode();\n        }\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public boolean hasDeviceOwner() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || canManageUsers(caller) || isFinancedDeviceOwner(\n                        caller) || hasCallingOrSelfPermission(\n                        MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        return mOwners.hasDeviceOwner();\n    }\n\n    boolean isDeviceOwner(ActiveAdmin admin) {\n        return isDeviceOwner(admin.info.getComponent(), admin.getUserHandle().getIdentifier());\n    }\n\n    /**\n     * Check if the user is a Device Owner\n     *\n     * @param who    component to check against\n     * @param userId user to check\n     * @return if the user is a Device Owner\n     */\n    public boolean isDeviceOwner(@Nullable ComponentName who, int userId) {\n        synchronized (getLockObject()) {\n            return mOwners.hasDeviceOwner() && mOwners.getDeviceOwnerUserId() == userId\n                    && mOwners.getDeviceOwnerComponent().equals(who);\n        }\n    }\n\n    /**\n     * Returns {@code true} <b>only if</b> the caller is the device owner and the device owner type\n     * is {@link DevicePolicyManager#DEVICE_OWNER_TYPE_DEFAULT}. {@code false} is returned for the\n     * case where the caller is not the device owner, there is no device owner, or the device owner\n     * type is not {@link DevicePolicyManager#DEVICE_OWNER_TYPE_DEFAULT}.\n     *\n     */\n    private boolean isDefaultDeviceOwner(CallerIdentity caller) {\n        synchronized (getLockObject()) {\n            return isDeviceOwnerLocked(caller) && getDeviceOwnerTypeLocked(\n                    mOwners.getDeviceOwnerPackageName()) == DEVICE_OWNER_TYPE_DEFAULT;\n        }\n    }\n\n    /**\n     * Returns {@code true} if the provided caller identity is of a device owner.\n     * @param caller identity of caller.\n     * @return true if {@code identity} is a device owner, false otherwise.\n     */\n    public boolean isDeviceOwner(CallerIdentity caller) {\n        synchronized (getLockObject()) {\n            return isDeviceOwnerLocked(caller);\n        }\n    }\n\n    private boolean isDeviceOwnerLocked(CallerIdentity caller) {\n        if (!mOwners.hasDeviceOwner() || mOwners.getDeviceOwnerUserId() != caller.getUserId()) {\n            return false;\n        }\n\n        if (caller.hasAdminComponent()) {\n            return mOwners.getDeviceOwnerComponent().equals(caller.getComponentName());\n        } else {\n            return isUidDeviceOwnerLocked(caller.getUid());\n        }\n    }\n\n    private boolean isDeviceOwnerUserId(int userId) {\n        synchronized (getLockObject()) {\n            return mOwners.getDeviceOwnerComponent() != null\n                    && mOwners.getDeviceOwnerUserId() == userId;\n        }\n    }\n\n    /**\n     * Check if {@link userId} is a Profile Owner\n     *\n     * @param who    component to check against\n     * @param userId user to check\n     * @return if the user is a Profile Owner\n     */\n    public boolean isProfileOwner(@Nullable ComponentName who, int userId) {\n        final ComponentName profileOwner = mInjector.binderWithCleanCallingIdentity(\n                () -> getProfileOwnerAsUser(userId));\n        return who != null && who.equals(profileOwner);\n    }\n\n    /**\n     * Returns {@code true} if the provided caller identity is of a profile owner.\n     * @param caller identity of caller.\n     * @return true if {@code identity} is a profile owner, false otherwise.\n     */\n    public boolean isProfileOwner(CallerIdentity caller) {\n        synchronized (getLockObject()) {\n            final ComponentName profileOwner = mInjector.binderWithCleanCallingIdentity(() ->\n                    getProfileOwnerAsUser(caller.getUserId()));\n            // No profile owner.\n            if (profileOwner == null) {\n                return false;\n            }\n            // The admin ComponentName was specified, check it directly.\n            if (caller.hasAdminComponent()) {\n                return profileOwner.equals(caller.getComponentName());\n            } else {\n                return isUidProfileOwnerLocked(caller.getUid());\n            }\n        }\n    }\n\n    /**\n     * Checks if the app uid provided is the profile owner. This method should only be called\n     * if no componentName is available.\n     *\n     * @param appUid UID of the caller.\n     * @return true if the caller is the profile owner\n     */\n    private boolean isUidProfileOwnerLocked(int appUid) {\n        ensureLocked();\n\n        final int userId = UserHandle.getUserId(appUid);\n        final ComponentName profileOwnerComponent = mOwners.getProfileOwnerComponent(userId);\n        if (profileOwnerComponent == null) {\n            return false;\n        }\n        for (ActiveAdmin admin : getUserData(userId).mAdminList) {\n            final ComponentName currentAdminComponent = admin.info.getComponent();\n            if (admin.getUid() == appUid && profileOwnerComponent.equals(currentAdminComponent)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean hasProfileOwner(int userId) {\n        synchronized (getLockObject()) {\n            return mOwners.hasProfileOwner(userId);\n        }\n    }\n\n    /**\n     * Returns {@code true} if the provided caller identity is of a profile owner of an organization\n     * owned device.\n     *\n     * @param caller identity of caller\n     * @return true if {@code identity} is a profile owner of an organization owned device, false\n     * otherwise.\n     */\n    private boolean isProfileOwnerOfOrganizationOwnedDevice(CallerIdentity caller) {\n        return isProfileOwner(caller) && isProfileOwnerOfOrganizationOwnedDevice(\n                caller.getUserId());\n    }\n\n    private boolean isProfileOwnerOfOrganizationOwnedDevice(int userId) {\n        synchronized (getLockObject()) {\n            return mOwners.isProfileOwnerOfOrganizationOwnedDevice(userId);\n        }\n    }\n\n    private boolean isProfileOwnerOfOrganizationOwnedDevice(ComponentName who, int userId) {\n        return isProfileOwner(who, userId) && isProfileOwnerOfOrganizationOwnedDevice(userId);\n    }\n\n    private boolean isProfileOwnerOnUser0(CallerIdentity caller) {\n        return isProfileOwner(caller) && caller.getUserHandle().isSystem();\n    }\n\n    private boolean isPackage(CallerIdentity caller, String packageName) {\n        return isCallingFromPackage(packageName, caller.getUid());\n    }\n\n    @Override\n    public ComponentName getDeviceOwnerComponent(boolean callingUserOnly) {\n        if (!mHasFeature) {\n            return null;\n        }\n        if (!callingUserOnly) {\n            Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                    || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        }\n        synchronized (getLockObject()) {\n            if (!mOwners.hasDeviceOwner()) {\n                return null;\n            }\n            if (callingUserOnly && mInjector.userHandleGetCallingUserId() !=\n                    mOwners.getDeviceOwnerUserId()) {\n                return null;\n            }\n            return mOwners.getDeviceOwnerComponent();\n        }\n    }\n\n    @Override\n    public ComponentName getDeviceOwnerComponentOnUser(int userId) {\n        if (!mHasFeature) {\n            return null;\n        }\n        if (mInjector.userHandleGetCallingUserId() != userId) {\n            Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                    || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        }\n        synchronized (getLockObject()) {\n            // There is only ever one device owner on a device so if the passed userId is the same\n            // as the device owner userId we know that the componentName returned by\n            // getDeviceOwnerComponent will be the correct one.\n            if (mOwners.getDeviceOwnerUserId() == userId || userId == UserHandle.USER_ALL) {\n                return mOwners.getDeviceOwnerComponent();\n            }\n        }\n        return null;\n    }\n\n    private int getDeviceOwnerUserIdUncheckedLocked() {\n        return mOwners.hasDeviceOwner() ? mOwners.getDeviceOwnerUserId() : UserHandle.USER_NULL;\n    }\n\n    @Override\n    public int getDeviceOwnerUserId() {\n        if (!mHasFeature) {\n            return UserHandle.USER_NULL;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            return getDeviceOwnerUserIdUncheckedLocked();\n        }\n    }\n\n    private @UserIdInt int getMainUserId() {\n        int mainUserId = mUserManagerInternal.getMainUserId();\n        if (mainUserId == UserHandle.USER_NULL) {\n            Slogf.d(LOG_TAG, \"getMainUserId(): no main user, returning USER_SYSTEM\");\n            return UserHandle.USER_SYSTEM;\n        }\n        return mainUserId;\n    }\n\n    // TODO(b/240562946): Remove api as owner name is not used.\n    /**\n     * Returns the \"name\" of the device owner.  It'll work for non-DO users too, but requires\n     * MANAGE_USERS.\n     */\n    @Override\n    public String getDeviceOwnerName() {\n        if (!mHasFeature) {\n            return null;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        synchronized (getLockObject()) {\n            if (!mOwners.hasDeviceOwner()) {\n                return null;\n            }\n            // TODO This totally ignores the name passed to setDeviceOwner (change for b/20679292)\n            // Should setDeviceOwner/ProfileOwner still take a name?\n            String deviceOwnerPackage = mOwners.getDeviceOwnerPackageName();\n            return getApplicationLabel(deviceOwnerPackage, UserHandle.USER_SYSTEM);\n        }\n    }\n\n    /** Returns the active device owner or {@code null} if there is no device owner. */\n    @VisibleForTesting\n    ActiveAdmin getDeviceOwnerAdminLocked() {\n        ensureLocked();\n        ComponentName component = mOwners.getDeviceOwnerComponent();\n        if (component == null) {\n            return null;\n        }\n\n        DevicePolicyData policy = getUserData(mOwners.getDeviceOwnerUserId());\n        final int n = policy.mAdminList.size();\n        for (int i = 0; i < n; i++) {\n            ActiveAdmin admin = policy.mAdminList.get(i);\n            if (component.equals(admin.info.getComponent())) {\n                return admin;\n            }\n        }\n        Slogf.wtf(LOG_TAG, \"Active admin for device owner not found. component=\" + component);\n        return null;\n    }\n\n    /**\n     * @deprecated Use the version which does not take a user id.\n     */\n    @Deprecated\n    ActiveAdmin getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked(int userId) {\n        ensureLocked();\n        ActiveAdmin admin = getDeviceOwnerAdminLocked();\n        if (admin == null) {\n            admin = getProfileOwnerOfOrganizationOwnedDeviceLocked(userId);\n        }\n        return admin;\n    }\n\n    ActiveAdmin getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked() {\n        ensureLocked();\n        ActiveAdmin admin = getDeviceOwnerAdminLocked();\n        if (admin == null) {\n            admin = getProfileOwnerOfOrganizationOwnedDeviceLocked();\n        }\n        return admin;\n    }\n\n    @Override\n    public void clearDeviceOwner(String packageName) {\n        Objects.requireNonNull(packageName, \"packageName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(packageName);\n        synchronized (getLockObject()) {\n            final ComponentName deviceOwnerComponent = mOwners.getDeviceOwnerComponent();\n            final int deviceOwnerUserId = mOwners.getDeviceOwnerUserId();\n            if (!mOwners.hasDeviceOwner()\n                    || !deviceOwnerComponent.getPackageName().equals(packageName)\n                    || (deviceOwnerUserId != caller.getUserId())) {\n                throw new SecurityException(\n                        \"clearDeviceOwner can only be called by the device owner\");\n            }\n            enforceUserUnlocked(deviceOwnerUserId);\n\n            final ActiveAdmin admin = getDeviceOwnerAdminLocked();\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                clearDeviceOwnerLocked(admin, deviceOwnerUserId);\n                removeActiveAdminLocked(deviceOwnerComponent, deviceOwnerUserId);\n                sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_DEVICE_OWNER_CHANGED,\n                        deviceOwnerUserId);\n            });\n            Slogf.i(LOG_TAG, \"Device owner removed: \" + deviceOwnerComponent);\n        }\n    }\n\n    private void clearOverrideApnUnchecked() {\n        if (!mHasTelephonyFeature) {\n            return;\n        }\n        // Disable Override APNs and remove them from database.\n        setOverrideApnsEnabledUnchecked(false);\n        final List<ApnSetting> apns = getOverrideApnsUnchecked();\n        for (int i = 0; i < apns.size(); i ++) {\n            removeOverrideApnUnchecked(apns.get(i).getId());\n        }\n    }\n\n    private void clearManagedProfileApnUnchecked() {\n        if (!mHasTelephonyFeature) {\n            return;\n        }\n        if (!LocalServices.getService(SystemServiceManager.class).isBootCompleted()) {\n            Slogf.i(LOG_TAG, \"Skip clearing managed profile Apn before boot completed\");\n            // Cannot talk to APN content provider before system boots\n            // Ideally we should delay the cleanup post boot_completed, not just\n            // skipping  it altogether.\n            return;\n        }\n        final List<ApnSetting> apns = getOverrideApnsUnchecked();\n        for (ApnSetting apn : apns) {\n            if (apn.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE) {\n                removeOverrideApnUnchecked(apn.getId());\n            }\n        }\n    }\n\n    private void clearDeviceOwnerLocked(ActiveAdmin admin, int userId) {\n        String ownersPackage = mOwners.getDeviceOwnerPackageName();\n        if (ownersPackage != null) {\n            mDeviceAdminServiceController.stopServiceForAdmin(\n                    ownersPackage, userId, \"clear-device-owner\");\n        }\n\n        if (admin != null) {\n            admin.disableCamera = false;\n            admin.userRestrictions = null;\n            admin.defaultEnabledRestrictionsAlreadySet.clear();\n            admin.forceEphemeralUsers = false;\n            admin.isNetworkLoggingEnabled = false;\n            admin.requireAutoTime = false;\n            mUserManagerInternal.setForceEphemeralUsers(admin.forceEphemeralUsers);\n        }\n        final DevicePolicyData policyData = getUserData(userId);\n        policyData.mCurrentInputMethodSet = false;\n        if (policyData.mPasswordTokenHandle != 0) {\n            mLockPatternUtils.removeEscrowToken(policyData.mPasswordTokenHandle, userId);\n            policyData.mPasswordTokenHandle = 0;\n        }\n        saveSettingsLocked(userId);\n        mPolicyCache.onUserRemoved(userId);\n        final DevicePolicyData systemPolicyData = getUserData(UserHandle.USER_SYSTEM);\n        systemPolicyData.mLastSecurityLogRetrievalTime = -1;\n        systemPolicyData.mLastBugReportRequestTime = -1;\n        systemPolicyData.mLastNetworkLogsRetrievalTime = -1;\n        saveSettingsLocked(UserHandle.USER_SYSTEM);\n        clearUserPoliciesLocked(userId);\n        clearOverrideApnUnchecked();\n        clearApplicationRestrictions(userId);\n\n        mOwners.clearDeviceOwner();\n        mOwners.writeDeviceOwner();\n\n        updateAdminCanGrantSensorsPermissionCache(userId);\n        clearDeviceOwnerUserRestriction(UserHandle.of(userId));\n        mInjector.securityLogSetLoggingEnabledProperty(false);\n        mSecurityLogMonitor.stop();\n        setNetworkLoggingActiveInternal(false);\n        deleteTransferOwnershipBundleLocked(userId);\n        toggleBackupServiceActive(UserHandle.USER_SYSTEM, true);\n        setGlobalSettingDeviceOwnerType(DEVICE_OWNER_TYPE_DEFAULT);\n\n        mDevicePolicyEngine.removePoliciesForAdmin(\n                EnforcingAdmin.createEnterpriseEnforcingAdmin(admin.info.getComponent(), userId));\n    }\n\n    private void clearApplicationRestrictions(int userId) {\n        // Changing app restrictions involves disk IO, offload it to the background thread.\n        mBackgroundHandler.post(() -> {\n            final List<PackageInfo> installedPackageInfos = mInjector.getPackageManager(userId)\n                    .getInstalledPackages(MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE);\n            final UserHandle userHandle = UserHandle.of(userId);\n            for (final PackageInfo packageInfo : installedPackageInfos) {\n                mInjector.getUserManager().setApplicationRestrictions(\n                        packageInfo.packageName, null /* restrictions */, userHandle);\n            }\n        });\n    }\n\n    @Override\n    public boolean setProfileOwner(ComponentName who, int userHandle) {\n        if (!mHasFeature) {\n            logMissingFeatureAction(\"Cannot set \" + ComponentName.flattenToShortString(who)\n                    + \" as profile owner for user \" + userHandle);\n            return false;\n        }\n        Preconditions.checkArgument(who != null);\n\n        final CallerIdentity caller = getCallerIdentity();\n        // Cannot be called while holding the lock:\n        final boolean hasIncompatibleAccountsOrNonAdb =\n                hasIncompatibleAccountsOrNonAdbNoLock(caller, userHandle, who);\n        synchronized (getLockObject()) {\n            enforceCanSetProfileOwnerLocked(\n                    caller, who, userHandle, hasIncompatibleAccountsOrNonAdb);\n            final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n            Preconditions.checkArgument(\n                    isPackageInstalledForUser(who.getPackageName(), userHandle)\n                            && admin != null\n                            && !getUserData(userHandle).mRemovingAdmins.contains(who),\n                    \"Not active admin: \" + who);\n\n            final int parentUserId = getProfileParentId(userHandle);\n            // When trying to set a profile owner on a new user, it may be that this user is\n            // a profile - but it may not be a managed profile if there's a restriction on the\n            // parent to add managed profiles (e.g. if the device has a device owner).\n            if (parentUserId != userHandle && mUserManager.hasUserRestriction(\n                    UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                    UserHandle.of(parentUserId))) {\n                Slogf.i(LOG_TAG, \"Cannot set profile owner because of restriction.\");\n                return false;\n            }\n\n            boolean isAdb = isAdb(caller);\n            if (isAdb) {\n                // Log profile owner provisioning was started using adb.\n                MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_PROFILE_OWNER);\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.PROVISIONING_ENTRY_POINT_ADB)\n                        .setAdmin(who)\n                        .setStrings(LOG_TAG_PROFILE_OWNER)\n                        .write();\n            }\n\n            // Shutting down backup manager service permanently.\n            toggleBackupServiceActive(userHandle, /* makeActive= */ false);\n\n            mOwners.setProfileOwner(who, userHandle);\n            mOwners.writeProfileOwner(userHandle);\n            Slogf.i(LOG_TAG, \"Profile owner set: \" + who + \" on user \" + userHandle);\n\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                if (mUserManager.isManagedProfile(userHandle)) {\n                    maybeSetDefaultRestrictionsForAdminLocked(userHandle, admin);\n                    ensureUnknownSourcesRestrictionForProfileOwnerLocked(userHandle, admin,\n                            true /* newOwner */);\n                }\n                if(isAdb) {\n                    // DISALLOW_DEBUGGING_FEATURES is being added to newly-created\n                    // work profile by default due to b/382064697 . This would have\n                    //  impacted certain CTS test flows when they interact with the\n                    // work profile via ADB (for example installing an app into the\n                    // work profile). Remove DISALLOW_DEBUGGING_FEATURES here to\n                    // reduce the potential impact.\n                    setLocalUserRestrictionInternal(\n                        EnforcingAdmin.createEnterpriseEnforcingAdmin(who, userHandle),\n                        UserManager.DISALLOW_DEBUGGING_FEATURES, false, userHandle);\n                }\n\n                sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                        userHandle);\n            });\n            mDeviceAdminServiceController.startServiceForAdmin(\n                    who.getPackageName(), userHandle, \"set-profile-owner\");\n            return true;\n        }\n    }\n\n    private void toggleBackupServiceActive(int userId, boolean makeActive) {\n        long ident = mInjector.binderClearCallingIdentity();\n        try {\n            if (mInjector.getIBackupManager() != null) {\n                mInjector.getIBackupManager()\n                        .setBackupServiceActive(userId, makeActive);\n            }\n        } catch (RemoteException e) {\n            throw new IllegalStateException(String.format(\"Failed %s backup service.\",\n                    makeActive ? \"activating\" : \"deactivating\"), e);\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n\n    }\n\n    @Override\n    public void clearProfileOwner(ComponentName who) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        final int userId = caller.getUserId();\n        Preconditions.checkCallingUser(!isManagedProfile(userId));\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        enforceUserUnlocked(userId);\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                clearProfileOwnerLocked(admin, userId);\n                removeActiveAdminLocked(who, userId);\n                sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                        userId);\n            });\n            Slogf.i(LOG_TAG, \"Profile owner \" + who + \" removed from user \" + userId);\n        }\n    }\n\n    public void clearProfileOwnerLocked(ActiveAdmin admin, int userId) {\n        String ownersPackage = mOwners.getProfileOwnerPackage(userId);\n        if (ownersPackage != null) {\n            mDeviceAdminServiceController.stopServiceForAdmin(\n                    ownersPackage, userId, \"clear-profile-owner\");\n        }\n\n        if (admin != null) {\n            admin.disableCamera = false;\n            admin.userRestrictions = null;\n            admin.defaultEnabledRestrictionsAlreadySet.clear();\n        }\n        final DevicePolicyData policyData = getUserData(userId);\n        policyData.mCurrentInputMethodSet = false;\n        policyData.mOwnerInstalledCaCerts.clear();\n        saveSettingsLocked(userId);\n        clearUserPoliciesLocked(userId);\n        clearApplicationRestrictions(userId);\n        mOwners.removeProfileOwner(userId);\n        mOwners.writeProfileOwner(userId);\n        deleteTransferOwnershipBundleLocked(userId);\n        toggleBackupServiceActive(userId, true);\n        applyProfileRestrictionsIfDeviceOwnerLocked();\n        setNetworkLoggingActiveInternal(false);\n\n        mDevicePolicyEngine.removePoliciesForAdmin(\n                EnforcingAdmin.createEnterpriseEnforcingAdmin(admin.info.getComponent(), userId));\n    }\n\n    @Override\n    public void setDeviceOwnerLockScreenInfo(ComponentName who, CharSequence info) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mLockPatternUtils.setDeviceOwnerInfo(info != null ? info.toString() : null));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_DEVICE_OWNER_LOCK_SCREEN_INFO)\n                .setAdmin(caller.getComponentName())\n                .write();\n    }\n\n    @Override\n    public CharSequence getDeviceOwnerLockScreenInfo() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        return mInjector.binderWithCleanCallingIdentity(() ->\n            mLockPatternUtils.getDeviceOwnerInfo());\n    }\n\n    private void clearUserPoliciesLocked(int userId) {\n        // Reset some of the user-specific policies.\n        final DevicePolicyData policy = getUserData(userId);\n        policy.mPermissionPolicy = DevicePolicyManager.PERMISSION_POLICY_PROMPT;\n        mPolicyCache.setPermissionPolicy(userId, policy.mPermissionPolicy);\n        // Clear delegations.\n        policy.mDelegationMap.clear();\n        policy.mStatusBarDisabled = false;\n        policy.mSecondaryLockscreenEnabled = false;\n        policy.mUserProvisioningState = STATE_USER_UNMANAGED;\n        policy.mAffiliationIds.clear();\n        resetAffiliationCacheLocked();\n        policy.mLockTaskPackages.clear();\n        policy.mLockTaskFeatures = DevicePolicyManager.LOCK_TASK_FEATURE_NONE;\n        saveSettingsLocked(userId);\n\n        try {\n            mIPermissionManager.updatePermissionFlagsForAllApps(\n                    PackageManager.FLAG_PERMISSION_POLICY_FIXED,\n                    0  /* flagValues */, userId);\n        } catch (RemoteException re) {\n            // Shouldn't happen.\n            Slogf.wtf(LOG_TAG, \"Failing in updatePermissionFlagsForAllApps\", re);\n        }\n    }\n\n    @Override\n    public boolean hasUserSetupCompleted() {\n        return hasUserSetupCompleted(mInjector.userHandleGetCallingUserId());\n    }\n\n    // This checks only if the Setup Wizard has run.  Since Wear devices pair before\n    // completing Setup Wizard, and pairing involves transferring user data, calling\n    // logic may want to check mIsWatch or mPaired in addition to hasUserSetupCompleted().\n    private boolean hasUserSetupCompleted(int userHandle) {\n        if (!mHasFeature) {\n            return true;\n        }\n        return mInjector.hasUserSetupCompleted(getUserData(userHandle));\n    }\n\n    @Override\n    public int getUserProvisioningState(int userHandle) {\n        if (!mHasFeature) {\n            return STATE_USER_UNMANAGED;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(caller)\n                || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        if (userHandle != caller.getUserId()) {\n            Preconditions.checkCallAuthorization(canManageUsers(caller)\n                    || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n        }\n\n        return getUserData(userHandle).mUserProvisioningState;\n    }\n\n    @Override\n    public void setUserProvisioningState(int newState, int userId) {\n        if (!mHasFeature) {\n            logMissingFeatureAction(\"Cannot set provisioning state \" + newState + \" for user \"\n                    + userId);\n            return;\n        }\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        final CallerIdentity caller = getCallerIdentity();\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            int deviceOwnerUserId = mOwners.getDeviceOwnerUserId();\n            // NOTE: multiple if statements are nested below so it can log more info on error\n            if (userId != deviceOwnerUserId) {\n                boolean hasProfileOwner = mOwners.hasProfileOwner(userId);\n                if (!hasProfileOwner) {\n                    int managedUserId = getManagedUserId(userId);\n                    if (managedUserId < 0 && newState != STATE_USER_UNMANAGED) {\n                        // No managed device, user or profile, so setting provisioning state makes\n                        // no sense.\n                        String error = \"Not allowed to change provisioning state unless a \"\n                                + \"device or profile owner is set.\";\n                        Slogf.w(LOG_TAG, \"setUserProvisioningState(newState=%d, userId=%d) failed: \"\n                                + \"deviceOwnerId=%d, hasProfileOwner=%b, managedUserId=%d, err=%s\",\n                                newState, userId, deviceOwnerUserId, hasProfileOwner,\n                                managedUserId, error);\n                        throw new IllegalStateException(error);\n                    }\n                }\n            }\n\n            synchronized (getLockObject()) {\n                boolean transitionCheckNeeded = true;\n\n                // Calling identity/permission checks.\n                if (isAdb(caller)) {\n                    // ADB shell can only move directly from un-managed to finalized as part of\n                    // directly setting profile-owner or device-owner.\n                    if (getUserProvisioningState(userId)\n                            != STATE_USER_UNMANAGED\n                            || newState != STATE_USER_SETUP_FINALIZED) {\n                        throw new IllegalStateException(\"Not allowed to change provisioning state \"\n                                + \"unless current provisioning state is unmanaged, and new state\"\n                                + \"is finalized.\");\n                    }\n                    transitionCheckNeeded = false;\n                }\n\n                final DevicePolicyData policyData = getUserData(userId);\n                if (transitionCheckNeeded) {\n                    // Optional state transition check for non-ADB case.\n                    try {\n                        checkUserProvisioningStateTransition(\n                                policyData.mUserProvisioningState,\n                                newState);\n\n                    } catch (IllegalStateException e) {\n                        Slogf.e(LOG_TAG,\n                                \"Exception caught while changing provisioning state\", e);\n                        throw e;\n                    }\n                }\n                policyData.mUserProvisioningState = newState;\n                saveSettingsLocked(userId);\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    private void checkUserProvisioningStateTransition(int currentState, int newState) {\n        if (Flags.userProvisioningSameState()) {\n            Preconditions.checkState(newState != currentState, \"New state cannot\"\n                    + \" be the same as the current state: [\" + newState + \"]\");\n        }\n        // Valid transitions for normal use-cases.\n        switch (currentState) {\n            case STATE_USER_UNMANAGED:\n                // Can move to any state from unmanaged (except itself as an edge case)..\n                if (newState != STATE_USER_UNMANAGED) {\n                    return;\n                }\n                break;\n            case DevicePolicyManager.STATE_USER_SETUP_INCOMPLETE:\n            case DevicePolicyManager.STATE_USER_SETUP_COMPLETE:\n                // Can only move to finalized from these states.\n                if (newState == STATE_USER_SETUP_FINALIZED) {\n                    return;\n                }\n                break;\n            case DevicePolicyManager.STATE_USER_PROFILE_COMPLETE:\n                // Current user has a managed-profile, but current user is not managed, so\n                // rather than moving to finalized state, go back to unmanaged once\n                // profile provisioning is complete.\n                if (newState == DevicePolicyManager.STATE_USER_PROFILE_FINALIZED) {\n                    return;\n                }\n                break;\n            case STATE_USER_SETUP_FINALIZED:\n                // Cannot transition out of finalized.\n                break;\n            case DevicePolicyManager.STATE_USER_PROFILE_FINALIZED:\n                // Should only move to an unmanaged state after removing the work profile.\n                if (newState == STATE_USER_UNMANAGED) {\n                    return;\n                }\n                break;\n        }\n\n        // Didn't meet any of the accepted state transition checks above, throw appropriate error.\n        throw new IllegalStateException(\"Cannot move to user provisioning state [\" + newState + \"] \"\n                + \"from state [\" + currentState + \"]\");\n    }\n\n    @Override\n    public void setProfileEnabled(ComponentName who) {\n        if (!mHasFeature) {\n            logMissingFeatureAction(\"Cannot enable profile for \"\n                    + ComponentName.flattenToShortString(who));\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        final int userId = caller.getUserId();\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        Preconditions.checkCallingUser(isManagedProfile(userId));\n\n        synchronized (getLockObject()) {\n            // Check if the profile is already enabled.\n            UserInfo managedProfile = getUserInfo(userId);\n            if (managedProfile.isEnabled()) {\n                Slogf.e(LOG_TAG,\n                        \"setProfileEnabled is called when the profile is already enabled\");\n                return;\n            }\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                mUserManager.setUserEnabled(userId);\n                UserInfo parent = mUserManager.getProfileParent(userId);\n                Intent intent = new Intent(Intent.ACTION_MANAGED_PROFILE_ADDED);\n                intent.putExtra(Intent.EXTRA_USER, new UserHandle(userId));\n                UserHandle parentHandle = new UserHandle(parent.id);\n                mLocalService.broadcastIntentToManifestReceivers(intent,\n                        parentHandle, /* requiresPermission= */ true);\n                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY |\n                        Intent.FLAG_RECEIVER_FOREGROUND);\n                mContext.sendBroadcastAsUser(intent, parentHandle);\n            });\n        }\n    }\n\n    @Override\n    public void setProfileName(ComponentName who, String profileName) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        final String truncatedProfileName =\n                profileName.substring(0, Math.min(profileName.length(), MAX_PROFILE_NAME_LENGTH));\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            mUserManager.setUserName(caller.getUserId(), truncatedProfileName);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_PROFILE_NAME)\n                    .setAdmin(caller.getComponentName())\n                    .write();\n        });\n    }\n\n    @Override\n    public ComponentName getProfileOwnerAsUser(int userId) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId)\n                || hasFullCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            return mOwners.getProfileOwnerComponent(userId);\n        }\n    }\n\n    // Returns the active profile owner for this user or null if the current user has no\n    // profile owner.\n    @VisibleForTesting\n    ActiveAdmin getProfileOwnerAdminLocked(int userHandle) {\n        ComponentName profileOwner = mOwners.getProfileOwnerComponent(userHandle);\n        if (profileOwner == null) {\n            return null;\n        }\n        DevicePolicyData policy = getUserData(userHandle);\n        final int n = policy.mAdminList.size();\n        for (int i = 0; i < n; i++) {\n            ActiveAdmin admin = policy.mAdminList.get(i);\n            if (profileOwner.equals(admin.info.getComponent())) {\n                return admin;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the ActiveAdmin associated with the PO or DO on the given user.\n     */\n    private @Nullable ActiveAdmin getDeviceOrProfileOwnerAdminLocked(int userHandle) {\n        ActiveAdmin admin = getProfileOwnerAdminLocked(userHandle);\n        if (admin == null && getDeviceOwnerUserIdUncheckedLocked() == userHandle) {\n            admin = getDeviceOwnerAdminLocked();\n        }\n        return admin;\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    ActiveAdmin getProfileOwnerOfOrganizationOwnedDeviceLocked(int userHandle) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo userInfo : mUserManager.getProfiles(userHandle)) {\n                if (userInfo.isManagedProfile()) {\n                    if (getProfileOwnerAsUser(userInfo.id) != null\n                            && isProfileOwnerOfOrganizationOwnedDevice(userInfo.id)) {\n                        ComponentName who = getProfileOwnerAsUser(userInfo.id);\n                        return getActiveAdminUncheckedLocked(who, userInfo.id);\n                    }\n                }\n            }\n            return null;\n        });\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    ActiveAdmin getProfileOwnerOfOrganizationOwnedDeviceLocked() {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo userInfo : mUserManager.getUsers()) {\n                if (userInfo.isManagedProfile()) {\n                    if (getProfileOwnerAsUser(userInfo.id) != null\n                            && isProfileOwnerOfOrganizationOwnedDevice(userInfo.id)) {\n                        ComponentName who = getProfileOwnerAsUser(userInfo.id);\n                        return getActiveAdminUncheckedLocked(who, userInfo.id);\n                    }\n                }\n            }\n            return null;\n        });\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public @Nullable ComponentName getProfileOwnerOrDeviceOwnerSupervisionComponent(\n            @NonNull UserHandle userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        synchronized (getLockObject()) {\n            final ComponentName doComponent = mOwners.getDeviceOwnerComponent();\n            final ComponentName poComponent =\n                    mOwners.getProfileOwnerComponent(userHandle.getIdentifier());\n            // Return test only admin if configured to do so.\n            // TODO(b/182994391): Replace with more generic solution to override the supervision\n            // component.\n            if (mConstants.USE_TEST_ADMIN_AS_SUPERVISION_COMPONENT) {\n                if (isAdminTestOnlyLocked(doComponent, userHandle.getIdentifier())) {\n                    return doComponent;\n                } else if (isAdminTestOnlyLocked(poComponent, userHandle.getIdentifier())) {\n                    return poComponent;\n                }\n            }\n\n            // Check profile owner first as that is what most likely is set.\n            if (isSupervisionComponentLocked(poComponent)) {\n                return poComponent;\n            }\n\n            if (isSupervisionComponentLocked(doComponent)) {\n                return doComponent;\n            }\n\n            return null;\n        }\n    }\n\n    /**\n     * Returns if the specified component is the supervision component.\n     */\n    @Override\n    public boolean isSupervisionComponent(@NonNull ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        synchronized (getLockObject()) {\n            if (mConstants.USE_TEST_ADMIN_AS_SUPERVISION_COMPONENT) {\n                final CallerIdentity caller = getCallerIdentity();\n                if (isAdminTestOnlyLocked(who, caller.getUserId())) {\n                    return true;\n                }\n            }\n            return isSupervisionComponentLocked(who);\n        }\n    }\n\n    private boolean isSupervisionComponentLocked(@Nullable ComponentName who) {\n        if (who == null) {\n            return false;\n        }\n\n        final String configComponent = mContext.getResources().getString(\n                R.string.config_defaultSupervisionProfileOwnerComponent);\n        if (configComponent != null) {\n            final ComponentName componentName = ComponentName.unflattenFromString(configComponent);\n            if (who.equals(componentName)) {\n                return true;\n            }\n        }\n\n        // Check the system supervision role.\n        final String configPackage = mContext.getResources().getString(\n                R.string.config_systemSupervision);\n\n        return who.getPackageName().equals(configPackage);\n    }\n\n    // TODO(b/240562946): Remove api as owner name is not used.\n    @Override\n    public String getProfileOwnerName(int userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        return getProfileOwnerNameUnchecked(userHandle);\n    }\n\n    private String getProfileOwnerNameUnchecked(int userHandle) {\n        ComponentName profileOwner = getProfileOwnerAsUser(userHandle);\n        if (profileOwner == null) {\n            return null;\n        }\n        return getApplicationLabel(profileOwner.getPackageName(), userHandle);\n    }\n\n    private @UserIdInt int getOrganizationOwnedProfileUserId() {\n        for (UserInfo ui : mUserManagerInternal.getUserInfos()) {\n            if (ui.isManagedProfile() && isProfileOwnerOfOrganizationOwnedDevice(ui.id)) {\n                return ui.id;\n            }\n        }\n        return UserHandle.USER_NULL;\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public boolean isOrganizationOwnedDeviceWithManagedProfile() {\n        if (!mHasFeature) {\n            return false;\n        }\n        return getOrganizationOwnedProfileUserId() != UserHandle.USER_NULL;\n    }\n\n    @Override\n    public boolean checkDeviceIdentifierAccess(String packageName, int pid, int uid) {\n        final CallerIdentity caller = getCallerIdentity();\n        ensureCallerIdentityMatchesIfNotSystem(packageName, pid, uid, caller);\n\n        // Verify that the specified packages matches the provided uid.\n        if (!doesPackageMatchUid(packageName, uid)) {\n            return false;\n        }\n        // A device or profile owner must also have the READ_PHONE_STATE permission to access device\n        // identifiers. If the package being checked does not have this permission then deny access.\n        if (!hasPermission(permission.READ_PHONE_STATE, pid, uid)) {\n            return false;\n        }\n        return hasDeviceIdAccessUnchecked(packageName, uid);\n    }\n\n    /**\n     * Check if one the following conditions hold:\n     * (1) The device has a Device Owner, and one of the following holds:\n     *   (1.1) The caller is the Device Owner\n     *   (1.2) The caller is another app in the same user as the device owner, AND\n     *         The caller is the delegated certificate installer.\n     *   (1.3) The caller is a Profile Owner and the calling user is affiliated.\n     * (2) The user has a profile owner, AND:\n     *   (2.1) The profile owner has been granted access to Device IDs and one of the following\n     *         holds:\n     *     (2.1.1) The caller is the profile owner.\n     *     (2.1.2) The caller is from another app in the same user as the profile owner, AND\n     *             the caller is the delegated cert installer.\n     *\n     *  For the device owner case, simply check that the caller is the device owner or the\n     *  delegated certificate installer.\n     *\n     *  For the profile owner case, first check that the caller is the profile owner or can\n     *  manage the DELEGATION_CERT_INSTALL scope.\n     *  If that check succeeds, ensure the profile owner was granted access to device\n     *  identifiers. The grant is transitive: The delegated cert installer is implicitly allowed\n     *  access to device identifiers in this case as part of the delegation.\n     */\n    @VisibleForTesting\n    boolean hasDeviceIdAccessUnchecked(String packageName, int uid) {\n        final int userId = UserHandle.getUserId(uid);\n        ComponentName deviceOwner = getDeviceOwnerComponent(true);\n        if (deviceOwner != null && (deviceOwner.getPackageName().equals(packageName)\n                || isCallerDelegate(packageName, uid, DELEGATION_CERT_INSTALL))) {\n            return true;\n        }\n        ComponentName profileOwner = getProfileOwnerAsUser(userId);\n        final boolean isCallerProfileOwnerOrDelegate = profileOwner != null\n                && (profileOwner.getPackageName().equals(packageName)\n                || isCallerDelegate(packageName, uid, DELEGATION_CERT_INSTALL));\n        if (isCallerProfileOwnerOrDelegate && (isProfileOwnerOfOrganizationOwnedDevice(userId)\n                || isUserAffiliatedWithDevice(userId))) {\n            return true;\n        }\n        return false;\n    }\n\n    private boolean doesPackageMatchUid(String packageName, int uid) {\n        final int userId = UserHandle.getUserId(uid);\n        try {\n            ApplicationInfo appInfo = mIPackageManager.getApplicationInfo(packageName, 0, userId);\n            // Since this call goes directly to PackageManagerService a NameNotFoundException is not\n            // thrown but null data can be returned; if the appInfo for the specified package cannot\n            // be found then return false to prevent crashing the app.\n            if (appInfo == null) {\n                Slogf.w(LOG_TAG, \"appInfo could not be found for package %s\", packageName);\n                return false;\n            } else if (uid != appInfo.uid) {\n                String message = String.format(\"Package %s (uid=%d) does not match provided uid %d\",\n                        packageName, appInfo.uid, uid);\n                Slogf.w(LOG_TAG, message);\n                throw new SecurityException(message);\n            }\n        } catch (RemoteException e) {\n            // If an exception is caught obtaining the appInfo just return false to prevent crashing\n            // apps due to an internal error.\n            Slogf.e(LOG_TAG, e, \"Exception caught obtaining appInfo for package %s\", packageName);\n            return false;\n        }\n        return true;\n    }\n\n    private void ensureCallerIdentityMatchesIfNotSystem(String packageName, int pid, int uid,\n            CallerIdentity caller) {\n        // If the caller is not a system app then it should only be able to check its own device\n        // identifier access.\n        int callingUid = caller.getUid();\n        int callingPid = mInjector.binderGetCallingPid();\n        if (UserHandle.getAppId(callingUid) >= Process.FIRST_APPLICATION_UID\n                && (callingUid != uid || callingPid != pid)) {\n            String message = String.format(\n                    \"Calling uid %d, pid %d cannot check device identifier access for package %s \"\n                            + \"(uid=%d, pid=%d)\", callingUid, callingPid, packageName, uid, pid);\n            Slogf.w(LOG_TAG, message);\n            throw new SecurityException(message);\n        }\n    }\n\n    /**\n     * Canonical name for a given package.\n     */\n    private String getApplicationLabel(String packageName, @UserIdInt int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            final Context userContext;\n            try {\n                UserHandle userHandle = UserHandle.of(userId);\n                userContext = mContext.createPackageContextAsUser(packageName, /* flags= */ 0,\n                        userHandle);\n            } catch (NameNotFoundException nnfe) {\n                Slogf.w(LOG_TAG, nnfe, \"%s is not installed for user %d\", packageName, userId);\n                return null;\n            }\n            ApplicationInfo appInfo = userContext.getApplicationInfo();\n            CharSequence result = null;\n            if (appInfo != null) {\n                result = appInfo.loadUnsafeLabel(userContext.getPackageManager());\n            }\n            return result != null ? result.toString() : null;\n        });\n    }\n\n    /**\n     * The profile owner can only be set by adb or an app with the MANAGE_PROFILE_AND_DEVICE_OWNERS\n     * permission.\n     * The profile owner can only be set before the user setup phase has completed,\n     * except for:\n     * - SYSTEM_UID\n     * - adb unless hasIncompatibleAccountsOrNonAdb is true.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void enforceCanSetProfileOwnerLocked(\n            CallerIdentity caller, @Nullable ComponentName owner, @UserIdInt int userId,\n            boolean hasIncompatibleAccountsOrNonAdb) {\n        UserInfo info = getUserInfo(userId);\n        if (info == null) {\n            // User doesn't exist.\n            throw new IllegalArgumentException(\n                    \"Attempted to set profile owner for invalid userId: \" + userId);\n        }\n        if (info.isGuest()) {\n            throw new IllegalStateException(\"Cannot set a profile owner on a guest\");\n        }\n        if (mOwners.hasProfileOwner(userId)) {\n            StringBuilder errorMessage = new StringBuilder(\"Trying to set the profile owner\");\n            if (!hasIncompatibleAccountsOrNonAdb) {\n                append(errorMessage, owner).append(\" on user \").append(userId);\n            }\n            errorMessage.append(\", but profile owner\");\n            if (!hasIncompatibleAccountsOrNonAdb) {\n                appendProfileOwnerLocked(errorMessage, userId);\n            }\n\n            throw new IllegalStateException(errorMessage.append(\" is already set.\").toString());\n        }\n        if (mOwners.hasDeviceOwner() && mOwners.getDeviceOwnerUserId() == userId) {\n            StringBuilder errorMessage = new StringBuilder(\"Trying to set the profile owner\");\n            if (!hasIncompatibleAccountsOrNonAdb) {\n                append(errorMessage, owner).append(\" on user \").append(userId);\n            }\n            errorMessage.append(\", but the user already has a device owner\");\n            if (!hasIncompatibleAccountsOrNonAdb) {\n                appendDeviceOwnerLocked(errorMessage);\n            }\n            throw new IllegalStateException(errorMessage.append('.').toString());\n        }\n        if (isAdb(caller)) {\n            if ((mIsWatch || hasUserSetupCompleted(userId))\n                    && hasIncompatibleAccountsOrNonAdb) {\n                StringBuilder errorMessage = new StringBuilder(\"Not allowed to set the profile \"\n                        + \"owner\");\n                if (!hasIncompatibleAccountsOrNonAdb) {\n                    append(errorMessage, owner).append(\" on user \").append(userId).append(' ');\n                }\n                throw new IllegalStateException(errorMessage.append(\" because there are already \"\n                        + \"some accounts on the profile.\").toString());\n            }\n            return;\n        }\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        if ((mIsWatch || hasUserSetupCompleted(userId))) {\n            Preconditions.checkState(isSystemUid(caller),\n                    \"Cannot set the profile owner on a user which is already set-up\");\n\n            if (!mIsWatch) {\n                if (!isSupervisionComponentLocked(owner)) {\n                    throw new IllegalStateException(\"Unable to set non-default profile owner\"\n                            + \" post-setup \" + owner);\n                }\n            }\n        }\n    }\n\n    /**\n     * The Device owner can only be set by adb or an app with the MANAGE_PROFILE_AND_DEVICE_OWNERS\n     * permission.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void enforceCanSetDeviceOwnerLocked(\n            CallerIdentity caller, @Nullable ComponentName owner, @UserIdInt int deviceOwnerUserId,\n            boolean hasIncompatibleAccountsOrNonAdb) {\n        boolean showComponentOnError = false;\n        if (!isAdb(caller)) {\n            Preconditions.checkCallAuthorization(\n                    hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        } else {\n            showComponentOnError = true;\n        }\n\n        final int code = checkDeviceOwnerProvisioningPreConditionLocked(owner,\n                /* deviceOwnerUserId= */ deviceOwnerUserId, /* callingUserId*/ caller.getUserId(),\n                isAdb(caller), hasIncompatibleAccountsOrNonAdb);\n        if (code != STATUS_OK) {\n            final String provisioningErrorStringLocked = computeProvisioningErrorStringLocked(code,\n                    deviceOwnerUserId, owner, showComponentOnError);\n            if (code == STATUS_HEADLESS_SYSTEM_USER_MODE_NOT_SUPPORTED) {\n                throw new ServiceSpecificException(code, provisioningErrorStringLocked);\n            } else {\n                throw new IllegalStateException(provisioningErrorStringLocked);\n            }\n        }\n    }\n\n    private String computeProvisioningErrorString(int code, @UserIdInt int userId) {\n        synchronized (getLockObject()) {\n            return computeProvisioningErrorStringLocked(code, userId, /* newOwner= */ null,\n                    /* showComponentOnError= */ false);\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private String computeProvisioningErrorStringLocked(int code, @UserIdInt int userId,\n            @Nullable ComponentName newOwner, boolean showComponentOnError) {\n        switch (code) {\n            case STATUS_OK:\n                return \"OK\";\n            case STATUS_HAS_DEVICE_OWNER: {\n                StringBuilder error = new StringBuilder(\"Trying to set the device owner\");\n                if (showComponentOnError && newOwner != null) {\n                    append(error, newOwner);\n                }\n                error.append(\", but device owner\");\n                if (showComponentOnError) {\n                    appendDeviceOwnerLocked(error);\n                }\n                return error.append(\" is already set.\").toString();\n            }\n            case STATUS_USER_HAS_PROFILE_OWNER: {\n                StringBuilder error = new StringBuilder(\"Trying to set the device owner\");\n                if (showComponentOnError && newOwner != null) {\n                    append(error, newOwner);\n                }\n                error.append(\", but the user already has a profile owner\");\n                if (showComponentOnError) {\n                    appendProfileOwnerLocked(error, userId);\n                }\n                return error.append(\".\").toString();\n            }\n            case STATUS_USER_NOT_RUNNING:\n                return \"User \" + userId + \" not running.\";\n            case STATUS_NOT_SYSTEM_USER:\n                return \"User \" + userId + \" is not system user.\";\n            case STATUS_USER_SETUP_COMPLETED:\n                return  \"Cannot set the device owner if the device is already set-up.\";\n            case STATUS_NONSYSTEM_USER_EXISTS:\n                return \"Not allowed to set the device owner because there are already several\"\n                        + \" users on the device.\";\n            case STATUS_ACCOUNTS_NOT_EMPTY:\n                return \"Not allowed to set the device owner because there are already some accounts\"\n                        + \" on the device.\";\n            case STATUS_HAS_PAIRED:\n                return \"Not allowed to set the device owner because this device has already \"\n                        + \"paired.\";\n            case STATUS_HEADLESS_SYSTEM_USER_MODE_NOT_SUPPORTED:\n                return \"Cannot provision an unsupported DPC into DO on a\"\n                        + \" headless device\";\n            default:\n                return \"Unexpected @ProvisioningPreCondition: \" + code;\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void appendDeviceOwnerLocked(StringBuilder string) {\n        ComponentName deviceOwner = getDeviceOwnerComponent(/* callingUserOnly= */ false);\n        if (deviceOwner == null) {\n            // Shouldn't happen, but it doesn't hurt to check...\n            Slogf.wtf(LOG_TAG, \"appendDeviceOwnerLocked(): device has no DO set\");\n            return;\n        }\n        append(string, deviceOwner);\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void appendProfileOwnerLocked(StringBuilder string, @UserIdInt int userId) {\n        ComponentName profileOwner = mOwners.getProfileOwnerComponent(userId);\n        if (profileOwner == null) {\n            // Shouldn't happen, but it doesn't hurt to check...\n            Slogf.wtf(LOG_TAG, \"profileOwner(%d): PO not set\", userId);\n            return;\n        }\n        append(string, profileOwner);\n    }\n\n    private static StringBuilder append(StringBuilder string, ComponentName component) {\n        return string.append(\" (\").append(component.flattenToShortString()).append(')');\n    }\n\n    private void enforceUserUnlocked(int userId) {\n        // Since we're doing this operation on behalf of an app, we only\n        // want to use the actual \"unlocked\" state.\n        Preconditions.checkState(mUserManager.isUserUnlocked(userId),\n                \"User must be running and unlocked\");\n    }\n\n    private void enforceUserUnlocked(@UserIdInt int userId, boolean parent) {\n        if (parent) {\n            enforceUserUnlocked(getProfileParentId(userId));\n        } else {\n            enforceUserUnlocked(userId);\n        }\n    }\n\n    private boolean canManageUsers(CallerIdentity caller) {\n        return hasCallingOrSelfPermission(permission.MANAGE_USERS);\n    }\n\n    private boolean canQueryAdminPolicy(CallerIdentity caller) {\n        return hasCallingOrSelfPermission(QUERY_ADMIN_POLICY);\n    }\n\n    private boolean hasPermission(String permission, int pid, int uid) {\n        return mContext.checkPermission(permission, pid, uid) == PERMISSION_GRANTED;\n    }\n\n    private boolean hasCallingPermission(String permission) {\n        return mContext.checkCallingPermission(permission) == PERMISSION_GRANTED;\n    }\n\n    private boolean hasCallingOrSelfPermission(String permission) {\n        return mContext.checkCallingOrSelfPermission(permission)\n                == PERMISSION_GRANTED;\n    }\n\n    private boolean hasPermissionForPreflight(CallerIdentity caller, String permission) {\n        final int callingPid = mInjector.binderGetCallingPid();\n        final String packageName = mContext.getPackageName();\n\n        return PermissionChecker.checkPermissionForPreflight(mContext, permission, callingPid,\n                caller.getUid(), packageName) == PermissionChecker.PERMISSION_GRANTED;\n    }\n\n    private boolean hasFullCrossUsersPermission(CallerIdentity caller, int userHandle) {\n        return (userHandle == caller.getUserId()) || isSystemUid(caller) || isRootUid(caller)\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS_FULL);\n    }\n\n    private boolean hasCrossUsersPermission(CallerIdentity caller, int userHandle) {\n        return (userHandle == caller.getUserId()) || isSystemUid(caller) || isRootUid(caller)\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS);\n    }\n\n    private boolean canDPCManagedUserUseLockTaskLocked(int userId) {\n        if (isUserAffiliatedWithDeviceLocked(userId)) {\n            return true;\n        }\n\n        // Unaffiliated profile owners are not allowed to use lock when there is a device owner.\n        if (mOwners.hasDeviceOwner()) {\n            return false;\n        }\n\n        final ComponentName profileOwner = getProfileOwnerAsUser(userId);\n        if (profileOwner == null) {\n            return false;\n        }\n        // Managed profiles are not allowed to use lock task\n        if (isManagedProfile(userId)) {\n            return false;\n        }\n\n        return true;\n    }\n    private void enforceCanQueryLockTaskLocked(ComponentName who, String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        final int userId = caller.getUserId();\n\n        enforceCanQuery(MANAGE_DEVICE_POLICY_LOCK_TASK, caller.getPackageName(), userId);\n        if ((isDeviceOwner(caller) || isProfileOwner(caller))\n                && !canDPCManagedUserUseLockTaskLocked(userId)) {\n            throw new SecurityException(\"User \" + userId + \" is not allowed to use lock task\");\n        }\n    }\n\n    private EnforcingAdmin enforceCanCallLockTaskLocked(ComponentName who,\n            String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        final int userId =  caller.getUserId();\n\n        EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                who,\n                MANAGE_DEVICE_POLICY_LOCK_TASK,\n                caller.getPackageName(),\n                userId\n        );\n        if ((isDeviceOwner(caller) || isProfileOwner(caller))\n                && !canDPCManagedUserUseLockTaskLocked(userId)) {\n            throw new SecurityException(\"User \" + userId + \" is not allowed to use lock task\");\n        }\n        return enforcingAdmin;\n    }\n\n    private boolean isSystemUid(CallerIdentity caller) {\n        return UserHandle.isSameApp(caller.getUid(), Process.SYSTEM_UID);\n    }\n\n    private boolean isRootUid(CallerIdentity caller) {\n        return UserHandle.isSameApp(caller.getUid(), Process.ROOT_UID);\n    }\n\n    private boolean isShellUid(CallerIdentity caller) {\n        return UserHandle.isSameApp(caller.getUid(), Process.SHELL_UID);\n    }\n\n    private boolean isCameraServerUid(CallerIdentity caller) {\n        return UserHandle.isSameApp(caller.getUid(), Process.CAMERASERVER_UID);\n    }\n\n    private @UserIdInt int getCurrentForegroundUserId() {\n        try {\n            UserInfo currentUser = mInjector.getIActivityManager().getCurrentUser();\n            if (currentUser == null) {\n                // TODO(b/206107460): should not happen on production, but it's happening on unit\n                // tests that are not properly setting the expectation (because they don't need it)\n                Slogf.wtf(LOG_TAG, \"getCurrentForegroundUserId(): mInjector.getIActivityManager()\"\n                        + \".getCurrentUser() returned null, please ignore when running unit tests\");\n                return ActivityManager.getCurrentUser();\n            }\n            return currentUser.id;\n        } catch (RemoteException e) {\n            Slogf.wtf(LOG_TAG, \"cannot get current user\", e);\n        }\n        return UserHandle.USER_NULL;\n    }\n\n    @Override\n    public List<UserHandle> listForegroundAffiliatedUsers() {\n        checkIsDeviceOwner(getCallerIdentity());\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            int userId = getCurrentForegroundUserId();\n            boolean isAffiliated;\n            synchronized (getLockObject()) {\n                isAffiliated = isUserAffiliatedWithDeviceLocked(userId);\n            }\n\n            if (!isAffiliated) return Collections.emptyList();\n\n            List<UserHandle> users = new ArrayList<>(1);\n            users.add(UserHandle.of(userId));\n\n            return users;\n        });\n    }\n\n    protected int getProfileParentId(int userHandle) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            UserInfo parentUser = mUserManager.getProfileParent(userHandle);\n            return parentUser != null ? parentUser.id : userHandle;\n        });\n    }\n\n    private int getProfileParentUserIfRequested(int userHandle, boolean parent) {\n        if (parent) {\n            return getProfileParentId(userHandle);\n        }\n\n        return userHandle;\n    }\n\n    private int getCredentialOwner(final int userHandle, final boolean parent) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            int effectiveUserHandle = userHandle;\n            if (parent) {\n                UserInfo parentProfile = mUserManager.getProfileParent(userHandle);\n                if (parentProfile != null) {\n                    effectiveUserHandle = parentProfile.id;\n                }\n            }\n            return mUserManager.getCredentialOwnerProfile(effectiveUserHandle);\n        });\n    }\n\n    private boolean isManagedProfile(int userHandle) {\n        final UserInfo user = getUserInfo(userHandle);\n        return user != null && user.isManagedProfile();\n    }\n\n    private void enableIfNecessary(String packageName, int userId) {\n        try {\n            final ApplicationInfo ai = mIPackageManager.getApplicationInfo(packageName,\n                    PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, userId);\n            if (ai.enabledSetting\n                    == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED) {\n                mIPackageManager.setApplicationEnabledSetting(packageName,\n                        PackageManager.COMPONENT_ENABLED_STATE_DEFAULT,\n                        PackageManager.DONT_KILL_APP, userId, \"DevicePolicyManager\");\n            }\n        } catch (RemoteException e) {\n        }\n    }\n\n    private void dumpPersonalAppInfoForSystemUserNoLock(IndentingPrintWriter pw) {\n        wtfIfInLock();\n        PersonalAppsSuspensionHelper.forUser(mContext, UserHandle.USER_SYSTEM).dump(pw);\n    }\n\n    private void dumpPerUserPolicyData(IndentingPrintWriter pw) {\n        int userCount = mUserData.size();\n        for (int i = 0; i < userCount; i++) {\n            int userId = mUserData.keyAt(i);\n            DevicePolicyData policy = getUserData(userId);\n            policy.dump(pw);\n            pw.println();\n        }\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter printWriter, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, LOG_TAG, printWriter)) return;\n\n        try (IndentingPrintWriter pw = new IndentingPrintWriter(printWriter, \"  \")) {\n            pw.println(\"Current Device Policy Manager state:\");\n            pw.increaseIndent();\n\n            dumpImmutableState(pw);\n            synchronized (getLockObject()) {\n                mOwners.dump(pw);\n                pw.println();\n                mDeviceAdminServiceController.dump(pw);\n                pw.println();\n                dumpPerUserPolicyData(pw);\n                pw.println();\n                mConstants.dump(pw);\n                pw.println();\n                mStatLogger.dump(pw);\n                pw.println();\n                mDevicePolicyEngine.dump(pw);\n                pw.println();\n                pw.println(\"Encryption Status: \" + getEncryptionStatusName(getEncryptionStatus()));\n                pw.println(\"Logout user: \" + getLogoutUserIdUnchecked());\n                pw.println();\n\n                if (mPendingUserCreatedCallbackTokens.isEmpty()) {\n                    pw.println(\"no pending user created callback tokens\");\n                } else {\n                    int size = mPendingUserCreatedCallbackTokens.size();\n                    pw.printf(\"%d pending user created callback token%s\\n\", size,\n                            (size == 1 ? \"\" : \"s\"));\n                }\n                pw.println();\n\n                mPolicyCache.dump(pw);\n                pw.println();\n                mStateCache.dump(pw);\n                pw.println();\n            }\n            dumpPersonalAppInfoForSystemUserNoLock(pw);\n\n            synchronized (mSubscriptionsChangedListenerLock) {\n                pw.println(\"Subscription changed listener : \" + mSubscriptionsChangedListener);\n            }\n\n            pw.println(\"DPM global setting ALLOW_WORK_PROFILE_TELEPHONY_FOR_NON_DPM_ROLE_HOLDERS : \"\n                    + mInjector.settingsGlobalGetString(\n                    Global.ALLOW_WORK_PROFILE_TELEPHONY_FOR_NON_DPM_ROLE_HOLDERS));\n            mHandler.post(() -> handleDump(pw));\n            dumpResources(pw);\n        }\n    }\n\n    // Dump state that is guarded by the handler\n    private void handleDump(IndentingPrintWriter pw) {\n        if (mNetworkLoggingNotificationUserId != UserHandle.USER_NULL) {\n            pw.println(\"mNetworkLoggingNotificationUserId:  \" + mNetworkLoggingNotificationUserId);\n        }\n    }\n\n    private void dumpImmutableState(IndentingPrintWriter pw) {\n        pw.println(\"Immutable state:\");\n        pw.increaseIndent();\n        pw.printf(\"mHasFeature=%b\\n\", mHasFeature);\n        pw.printf(\"mIsWatch=%b\\n\", mIsWatch);\n        pw.printf(\"mIsAutomotive=%b\\n\", mIsAutomotive);\n        pw.printf(\"mHasTelephonyFeature=%b\\n\", mHasTelephonyFeature);\n        pw.printf(\"mSafetyChecker=%s\\n\", mSafetyChecker);\n        pw.decreaseIndent();\n    }\n\n    private void dumpResources(IndentingPrintWriter pw) {\n        mOverlayPackagesProvider.dump(pw);\n        pw.println();\n\n        pw.println(\"Other overlayable app resources\");\n        pw.increaseIndent();\n        dumpResources(pw, mContext, \"cross_profile_apps\", R.array.cross_profile_apps);\n        dumpResources(pw, mContext, \"vendor_cross_profile_apps\", R.array.vendor_cross_profile_apps);\n        dumpResources(pw, mContext, \"config_packagesExemptFromSuspension\",\n                R.array.config_packagesExemptFromSuspension);\n        dumpResources(pw, mContext, \"policy_exempt_apps\", R.array.policy_exempt_apps);\n        dumpResources(pw, mContext, \"vendor_policy_exempt_apps\", R.array.vendor_policy_exempt_apps);\n        pw.decreaseIndent();\n        pw.println();\n    }\n\n    static void dumpResources(IndentingPrintWriter pw, Context context, String resName, int resId) {\n        dumpApps(pw, resName, context.getResources().getStringArray(resId));\n    }\n\n    static void dumpApps(IndentingPrintWriter pw, String name, String[] apps) {\n        dumpApps(pw, name, Arrays.asList(apps));\n    }\n\n    static void dumpApps(IndentingPrintWriter pw, String name, List apps) {\n        if (apps == null || apps.isEmpty()) {\n            pw.printf(\"%s: empty\\n\", name);\n            return;\n        }\n        int size = apps.size();\n        pw.printf(\"%s: %d app%s\\n\", name, size, size == 1 ? \"\" : \"s\");\n        pw.increaseIndent();\n        for (int i = 0; i < size; i++) {\n            pw.printf(\"%d: %s\\n\", i, apps.get(i));\n        }\n        pw.decreaseIndent();\n    }\n\n    @Override\n    public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n            String[] args, ShellCallback callback, ResultReceiver resultReceiver) {\n        new DevicePolicyManagerServiceShellCommand(DevicePolicyManagerService.this).exec(\n                this, in, out, err, args, callback, resultReceiver);\n\n    }\n\n    private String getEncryptionStatusName(int encryptionStatus) {\n        switch (encryptionStatus) {\n            case ENCRYPTION_STATUS_ACTIVE_PER_USER:\n                return \"per-user\";\n            case DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED:\n                return \"unsupported\";\n            default:\n                return \"unknown\";\n        }\n    }\n\n    @Override\n    public void addPersistentPreferredActivity(ComponentName who, String callerPackageName,\n            IntentFilter filter, ComponentName activity) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n\n        final int userId = caller.getUserId();\n        EnforcingAdmin enforcingAdmin;\n        if (who == null) {\n            enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_LOCK_TASK,\n                    caller.getPackageName(),\n                    userId);\n        } else {\n            Preconditions.checkCallAuthorization(isProfileOwner(caller)\n                    || isDefaultDeviceOwner(caller) || isFinancedDeviceOwner(caller));\n            enforcingAdmin = getEnforcingAdminForCaller(who, callerPackageName);\n        }\n        if (!isPackageInstalledForUser(activity.getPackageName(), userId)) {\n            // Fail early as packageManager doesn't persist the activity if its not installed.\n            return;\n        }\n        mDevicePolicyEngine.setLocalPolicy(\n                PolicyDefinition.PERSISTENT_PREFERRED_ACTIVITY(filter),\n                enforcingAdmin,\n                new ComponentNamePolicyValue(activity),\n                userId);\n        final String activityPackage =\n                (activity != null ? activity.getPackageName() : null);\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_PERSISTENT_PREFERRED_ACTIVITY)\n                .setAdmin(caller.getPackageName())\n                .setStrings(activityPackage, getIntentFilterActions(filter))\n                .write();\n    }\n\n    @Override\n    public void clearPackagePersistentPreferredActivities(ComponentName who,\n            String callerPackageName, String packageName) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        final int userId = caller.getUserId();\n\n        EnforcingAdmin enforcingAdmin;\n        if (who == null) {\n            enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_LOCK_TASK,\n                    caller.getPackageName(),\n                    userId);\n        } else {\n            Preconditions.checkCallAuthorization(isProfileOwner(caller)\n                    || isDefaultDeviceOwner(caller) || isFinancedDeviceOwner(caller));\n            enforcingAdmin = getEnforcingAdminForCaller(who, callerPackageName);\n        }\n        clearPackagePersistentPreferredActivitiesFromPolicyEngine(\n                enforcingAdmin,\n                packageName,\n                userId);\n    }\n\n    /**\n     * Remove all persistent intent handler preferences associated with the given package that were\n     * set by this admin, note that is doesn't remove preferences set by other admins for the same\n     * package.\n     */\n    private void clearPackagePersistentPreferredActivitiesFromPolicyEngine(\n            EnforcingAdmin admin, String packageName, int userId) {\n        Set<PolicyKey> keys = mDevicePolicyEngine.getLocalPolicyKeysSetByAdmin(\n                PolicyDefinition.GENERIC_PERSISTENT_PREFERRED_ACTIVITY,\n                admin,\n                userId);\n        for (PolicyKey key : keys) {\n            if (!(key instanceof IntentFilterPolicyKey)) {\n                throw new IllegalStateException(\"PolicyKey for PERSISTENT_PREFERRED_ACTIVITY is not\"\n                        + \"of type IntentFilterPolicyKey\");\n            }\n            IntentFilterPolicyKey parsedKey =\n                    (IntentFilterPolicyKey) key;\n            IntentFilter filter = Objects.requireNonNull(parsedKey.getIntentFilter());\n\n            ComponentName preferredActivity = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.PERSISTENT_PREFERRED_ACTIVITY(filter),\n                    admin,\n                    userId);\n            if (preferredActivity != null\n                    && preferredActivity.getPackageName().equals(packageName)) {\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.PERSISTENT_PREFERRED_ACTIVITY(filter),\n                        admin,\n                        userId);\n            }\n        }\n    }\n\n    @Override\n    public void setDefaultSmsApplication(ComponentName admin, String callerPackageName,\n            String packageName, boolean parent) {\n        CallerIdentity caller = getCallerIdentity(admin);\n\n\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        if (!parent && isManagedProfile(caller.getUserId())\n                && getManagedSubscriptionsPolicy().getPolicyType()\n                != ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {\n            throw new IllegalStateException(\n                    \"Default sms application can only be set on the profile, when \"\n                            + \"ManagedSubscriptions policy is set\");\n        }\n\n        final int userId;\n        if (parent) {\n            userId = getProfileParentId(mInjector.userHandleGetCallingUserId());\n            mInjector.binderWithCleanCallingIdentity(() -> enforcePackageIsSystemPackage(\n                    packageName, userId));\n        } else {\n            userId = mInjector.userHandleGetCallingUserId();\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() ->\n                SmsApplication.setDefaultApplicationAsUser(packageName, mContext, userId));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin activeAdmin = getParentOfAdminIfRequired(\n                    getProfileOwnerOrDeviceOwnerLocked(caller.getUserId()), parent);\n\n            if (isManagedProfile(userId)) {\n                mInjector.binderWithCleanCallingIdentity(\n                        () -> updateDialerAndSmsManagedShortcutsOverrideCache());\n            }\n\n            if (!Objects.equals(activeAdmin.mSmsPackage, packageName)) {\n                activeAdmin.mSmsPackage = packageName;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public void setDefaultDialerApplication(String packageName) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        final int callerUserId = caller.getUserId();\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            CompletableFuture<Void> future = new CompletableFuture<>();\n            Consumer<Boolean> callback = successful -> {\n                if (successful) {\n                    future.complete(null);\n                } else {\n                    future.completeExceptionally(new IllegalArgumentException(\n                            packageName +  \" cannot be set as the dialer\"));\n                }\n            };\n            mRoleManager.addRoleHolderAsUser(\n                    RoleManager.ROLE_DIALER, packageName, 0, UserHandle.of(callerUserId),\n                    AsyncTask.THREAD_POOL_EXECUTOR, callback);\n            try {\n                future.get(20, TimeUnit.SECONDS);\n            } catch (TimeoutException e) {\n                throw new IllegalArgumentException(\"Timeout when setting the app as the dialer\", e);\n            } catch (ExecutionException e) {\n                Throwable cause = e.getCause();\n                if (cause instanceof IllegalArgumentException) {\n                    throw (IllegalArgumentException) cause;\n                } else {\n                    throw new IllegalStateException(cause);\n                }\n            }\n        });\n        // Only save the package when the setting the role succeeded without exception.\n        synchronized (getLockObject()) {\n            if (isManagedProfile(callerUserId)) {\n                mInjector.binderWithCleanCallingIdentity(\n                        () -> updateDialerAndSmsManagedShortcutsOverrideCache());\n            }\n\n            final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(callerUserId);\n            if (!Objects.equals(admin.mDialerPackage, packageName)) {\n                admin.mDialerPackage = packageName;\n                saveSettingsLocked(callerUserId);\n            }\n        }\n    }\n\n    @Override\n    public boolean setApplicationRestrictionsManagingPackage(ComponentName admin,\n            String packageName) {\n        try {\n            setDelegatedScopePreO(admin, packageName, DELEGATION_APP_RESTRICTIONS);\n        } catch (IllegalArgumentException e) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public String getApplicationRestrictionsManagingPackage(ComponentName admin) {\n        final List<String> delegatePackages = getDelegatePackages(admin,\n                DELEGATION_APP_RESTRICTIONS);\n        return delegatePackages.size() > 0 ? delegatePackages.get(0) : null;\n    }\n\n    @Override\n    public boolean isCallerApplicationRestrictionsManagingPackage(String callerPackage) {\n        return isCallerDelegate(callerPackage, getCallerIdentity().getUid(),\n                DELEGATION_APP_RESTRICTIONS);\n    }\n\n    @Override\n    public void setApplicationRestrictions(ComponentName who, String callerPackage,\n            String packageName, Bundle restrictions, boolean parent) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_APPLICATION_RESTRICTIONS);\n\n        // This check is eventually made in UMS, checking here to fail early.\n        String validationResult =\n                FrameworkParsingPackageUtils.validateName(packageName, false, false);\n        if (validationResult != null) {\n            throw new IllegalArgumentException(\"Invalid package name: \" + validationResult);\n        }\n\n        final boolean isRoleHolder;\n        if (who != null) {\n            // DO or PO\n            Preconditions.checkCallAuthorization(\n                    (isProfileOwner(caller) || isDefaultDeviceOwner(caller)));\n            Preconditions.checkCallAuthorization(!parent,\n                    \"DO or PO cannot call this on parent\");\n            // Caller has opted to be treated as DPC (by passing a non-null who), so don't\n            // consider it as the DMRH, even if the caller is both the DPC and the DMRH.\n            isRoleHolder = false;\n        } else {\n            // Delegates, or the DMRH. Only DMRH can call this on COPE parent\n            isRoleHolder = isCallerDevicePolicyManagementRoleHolder(caller);\n            if (parent) {\n                Preconditions.checkCallAuthorization(isRoleHolder);\n                Preconditions.checkState(isOrganizationOwnedDeviceWithManagedProfile(),\n                        \"Role Holder can only operate parent app restriction on COPE devices\");\n            } else {\n                Preconditions.checkCallAuthorization(isRoleHolder\n                        || isCallerDelegate(caller, DELEGATION_APP_RESTRICTIONS));\n            }\n        }\n        // DMRH caller uses policy engine, others still use legacy code path\n        if (isRoleHolder) {\n            EnforcingAdmin enforcingAdmin = getEnforcingAdminForCaller(/* who */ null,\n                    caller.getPackageName());\n            int affectedUserId = parent\n                    ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n            if (restrictions == null || restrictions.isEmpty()) {\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.APPLICATION_RESTRICTIONS(packageName),\n                        enforcingAdmin,\n                        affectedUserId);\n            } else {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.APPLICATION_RESTRICTIONS(packageName),\n                        enforcingAdmin,\n                        new BundlePolicyValue(restrictions),\n                        affectedUserId);\n            }\n        } else {\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                mUserManager.setApplicationRestrictions(packageName, restrictions,\n                        caller.getUserHandle());\n            });\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_APPLICATION_RESTRICTIONS)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ isCallerDelegate(caller))\n                .setStrings(packageName)\n                .write();\n    }\n\n    private Bundle getAppRestrictionsSetByAnyAdmin(String packageName, UserHandle userHandle) {\n        LinkedHashMap<EnforcingAdmin, PolicyValue<Bundle>> policies =\n                mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                        PolicyDefinition.APPLICATION_RESTRICTIONS(packageName),\n                        userHandle.getIdentifier());\n        return policies.isEmpty()\n                ? null : policies.entrySet().stream().findAny().get().getValue().getValue();\n    }\n\n    private int getUidForPackage(String packageName, int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                return mContext.getPackageManager().getApplicationInfoAsUser(\n                        packageName, /* flags= */ 0, userId).uid;\n            } catch (NameNotFoundException exception) {\n                return -1;\n            }\n        });\n    }\n\n    @Override\n    public void setTrustAgentConfiguration(\n            ComponentName admin, String callerPackageName, ComponentName agent,\n            PersistableBundle args, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n\n        Objects.requireNonNull(admin, \"admin is null\");\n        Objects.requireNonNull(agent, \"agent is null\");\n\n        PolicySizeVerifier.enforceMaxPackageNameLength(agent.getPackageName());\n        final String agentAsString = agent.flattenToString();\n        PolicySizeVerifier.enforceMaxStringLength(agentAsString, \"agent name\");\n        if (args != null) {\n            PolicySizeVerifier.enforceMaxStringLength(args, \"args\");\n        }\n\n        int userHandle = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(admin,\n                    DeviceAdminInfo.USES_POLICY_DISABLE_KEYGUARD_FEATURES, parent);\n            checkCanExecuteOrThrowUnsafe(\n                    DevicePolicyManager.OPERATION_SET_TRUST_AGENT_CONFIGURATION);\n\n            ap.trustAgentInfos.put(agentAsString, new TrustAgentInfo(args));\n            saveSettingsLocked(userHandle);\n        }\n    }\n\n    @Override\n    public List<PersistableBundle> getTrustAgentConfiguration(ComponentName admin,\n            ComponentName agent, int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return null;\n        }\n        Objects.requireNonNull(agent, \"agent null\");\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            final String componentName = agent.flattenToString();\n            if (admin != null) {\n                final ActiveAdmin ap = getActiveAdminUncheckedLocked(admin, userHandle, parent);\n                if (ap == null) return null;\n                TrustAgentInfo trustAgentInfo = ap.trustAgentInfos.get(componentName);\n                if (trustAgentInfo == null || trustAgentInfo.options == null) return null;\n                List<PersistableBundle> result = new ArrayList<>();\n                result.add(trustAgentInfo.options);\n                return result;\n            }\n\n            // Return strictest policy for this user and profiles that are visible from this user.\n            List<PersistableBundle> result = null;\n            // Search through all admins that use KEYGUARD_DISABLE_TRUST_AGENTS and keep track\n            // of the options. If any admin doesn't have options, discard options for the rest\n            // and return null.\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            boolean allAdminsHaveOptions = true;\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                final ActiveAdmin active = admins.get(i);\n\n                final boolean disablesTrust = (active.disabledKeyguardFeatures\n                        & DevicePolicyManager.KEYGUARD_DISABLE_TRUST_AGENTS) != 0;\n                final TrustAgentInfo info = active.trustAgentInfos.get(componentName);\n                if (info != null && info.options != null && !info.options.isEmpty()) {\n                    if (disablesTrust) {\n                        if (result == null) {\n                            result = new ArrayList<>();\n                        }\n                        result.add(info.options);\n                    } else {\n                        Slogf.w(LOG_TAG, \"Ignoring admin %s because it has trust options but \"\n                                + \"doesn't declare KEYGUARD_DISABLE_TRUST_AGENTS\", active.info);\n                    }\n                } else if (disablesTrust) {\n                    allAdminsHaveOptions = false;\n                    break;\n                }\n            }\n            return allAdminsHaveOptions ? result : null;\n        }\n    }\n\n    @Override\n    public void setRestrictionsProvider(ComponentName who, ComponentName permissionProvider) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_RESTRICTIONS_PROVIDER);\n\n        synchronized (getLockObject()) {\n            int userHandle = caller.getUserId();\n            DevicePolicyData userData = getUserData(userHandle);\n            userData.mRestrictionsProvider = permissionProvider;\n            saveSettingsLocked(userHandle);\n        }\n    }\n\n    @Override\n    public ComponentName getRestrictionsProvider(int userHandle) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"query the permission provider\"));\n        synchronized (getLockObject()) {\n            DevicePolicyData userData = getUserData(userHandle);\n            return userData != null ? userData.mRestrictionsProvider : null;\n        }\n    }\n\n    @Override\n    public void addCrossProfileIntentFilter(ComponentName who, String callerPackageName,\n            IntentFilter filter, int flags) {\n        CallerIdentity caller = getCallerIdentity(who);\n\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                int callingUserId = caller.getUserId();\n                UserInfo parent = mUserManager.getProfileParent(callingUserId);\n                if (parent == null) {\n                    Slogf.e(LOG_TAG, \"Cannot call addCrossProfileIntentFilter if there is no \"\n                            + \"parent\");\n                    return;\n                }\n                if ((flags & DevicePolicyManager.FLAG_PARENT_CAN_ACCESS_MANAGED) != 0) {\n                    mIPackageManager.addCrossProfileIntentFilter(\n                            filter, who.getPackageName(), callingUserId, parent.id, 0);\n                }\n                if ((flags & DevicePolicyManager.FLAG_MANAGED_CAN_ACCESS_PARENT) != 0) {\n                    mIPackageManager.addCrossProfileIntentFilter(filter, who.getPackageName(),\n                            parent.id, callingUserId, 0);\n                }\n            } catch (RemoteException re) {\n                // Shouldn't happen\n                Slogf.wtf(LOG_TAG, \"Error adding cross profile intent filter\", re);\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_CROSS_PROFILE_INTENT_FILTER)\n                .setAdmin(caller.getPackageName())\n                .setStrings(getIntentFilterActions(filter))\n                .setInt(flags)\n                .write();\n    }\n\n    private static String[] getIntentFilterActions(IntentFilter filter) {\n        if (filter == null) {\n            return null;\n        }\n        final int actionsCount = filter.countActions();\n        final String[] actions = new String[actionsCount];\n        for (int i = 0; i < actionsCount; i++) {\n            actions[i] = filter.getAction(i);\n        }\n        return actions;\n    }\n\n    @Override\n    public void clearCrossProfileIntentFilters(ComponentName who, String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(who);\n\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                int callingUserId = caller.getUserId();\n                UserInfo parent = mUserManager.getProfileParent(callingUserId);\n                if (parent == null) {\n                    Slogf.e(LOG_TAG, \"Cannot call clearCrossProfileIntentFilter if there is no \"\n                            + \"parent\");\n                    return;\n                }\n                // Removing those that go from the managed profile to the parent.\n                mIPackageManager.clearCrossProfileIntentFilters(\n                        callingUserId, who.getPackageName());\n                // And those that go from the parent to the managed profile.\n                // If we want to support multiple managed profiles, we will have to only remove\n                // those that have callingUserId as their target.\n                mIPackageManager.clearCrossProfileIntentFilters(parent.id, who.getPackageName());\n            } catch (RemoteException re) {\n                // Shouldn't happen\n                Slogf.wtf(LOG_TAG, \"Error clearing cross profile intent filters\", re);\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n    }\n\n    /**\n     * @return true if all packages in enabledPackages are either in the list\n     * permittedList or are a system app.\n     */\n    private boolean checkPackagesInPermittedListOrSystem(List<String> enabledPackages,\n            List<String> permittedList, int userId) {\n        long id = mInjector.binderClearCallingIdentity();\n        try {\n            for (String enabledPackage : enabledPackages) {\n                if (permittedList.contains(enabledPackage)) {\n                    continue;\n                }\n                try {\n                    ApplicationInfo applicationInfo = mIPackageManager.getApplicationInfo(\n                            enabledPackage, PackageManager.MATCH_ANY_USER, userId);\n\n                    if (applicationInfo == null) {\n                        Slogf.wtf(LOG_TAG, \"Can't find ApplicationInfo for %s\", enabledPackage);\n                        return false;\n                    }\n\n                    if (!applicationInfo.isSystemApp()) {\n                        Slogf.w(LOG_TAG,\n                                \"Enabled package neither permitted nor system: %s\", enabledPackage);\n                        return false;\n                    }\n                } catch (RemoteException e) {\n                    Slogf.i(LOG_TAG, \"Can't talk to package managed\", e);\n                }\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        return true;\n    }\n\n    /**\n     * Invoke a method in AccessibilityManager ensuring the client is removed.\n     */\n    private <T> T withAccessibilityManager(\n            int userId, Function<AccessibilityManager, T> function) {\n        // Not using AccessibilityManager.getInstance because that guesses\n        // at the user you require based on callingUid and caches for a given\n        // process.\n        final IBinder iBinder = ServiceManager.getService(Context.ACCESSIBILITY_SERVICE);\n        final IAccessibilityManager service = iBinder == null\n                ? null : IAccessibilityManager.Stub.asInterface(iBinder);\n        final AccessibilityManager am = new AccessibilityManager(mContext, service, userId);\n        try {\n            return function.apply(am);\n        } finally {\n            am.removeClient();\n        }\n    }\n\n    @Override\n    public boolean setPermittedAccessibilityServices(ComponentName who, List<String> packageList) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        if (packageList != null) {\n            for (String pkg : packageList) {\n                PolicySizeVerifier.enforceMaxPackageNameLength(pkg);\n            }\n\n            int userId = caller.getUserId();\n            final List<AccessibilityServiceInfo> enabledServices;\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                UserInfo user = getUserInfo(userId);\n                if (user.isManagedProfile()) {\n                    userId = user.profileGroupId;\n                }\n                enabledServices = withAccessibilityManager(userId,\n                        am -> am.getEnabledAccessibilityServiceList(FEEDBACK_ALL_MASK));\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n\n            if (enabledServices != null) {\n                List<String> enabledPackages = new ArrayList<>();\n                for (AccessibilityServiceInfo service : enabledServices) {\n                    enabledPackages.add(service.getResolveInfo().serviceInfo.packageName);\n                }\n                if (!checkPackagesInPermittedListOrSystem(enabledPackages, packageList,\n                        userId)) {\n                    Slogf.e(LOG_TAG, \"Cannot set permitted accessibility services, \"\n                            + \"because it contains already enabled accesibility services.\");\n                    return false;\n                }\n            }\n        }\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            admin.permittedAccessiblityServices = packageList;\n            saveSettingsLocked(UserHandle.getCallingUserId());\n        }\n        final String[] packageArray =\n                packageList != null ? ((List<String>) packageList).toArray(new String[0]) : null;\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PERMITTED_ACCESSIBILITY_SERVICES)\n                .setAdmin(who)\n                .setStrings(packageArray)\n                .write();\n        return true;\n    }\n\n    @Override\n    public List<String> getPermittedAccessibilityServices(ComponentName who) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            return admin.permittedAccessiblityServices;\n        }\n    }\n\n    @Override\n    public List<String> getPermittedAccessibilityServicesForUser(int userId) {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(caller) || canQueryAdminPolicy(caller));\n\n        List<String> result = null;\n\n        synchronized (getLockObject()) {\n            // If we have multiple profiles we return the intersection of the\n            // permitted lists. This can happen in cases where we have a device\n            // and profile owner.\n            int[] profileIds = mUserManager.getProfileIdsWithDisabled(userId);\n            for (int profileId : profileIds) {\n                // Just loop though all admins, only device or profiles\n                // owners can have permitted lists set.\n                DevicePolicyData policy = getUserDataUnchecked(profileId);\n                final int N = policy.mAdminList.size();\n                for (int j = 0; j < N; j++) {\n                    ActiveAdmin admin = policy.mAdminList.get(j);\n                    List<String> fromAdmin = admin.permittedAccessiblityServices;\n                    if (fromAdmin != null) {\n                        if (result == null) {\n                            result = new ArrayList<>(fromAdmin);\n                        } else {\n                            result.retainAll(fromAdmin);\n                        }\n                    }\n                }\n            }\n        }\n\n        // If we have a permitted list add all system accessibility services.\n        if (result != null) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                UserInfo user = getUserInfo(userId);\n                if (user.isManagedProfile()) {\n                    userId = user.profileGroupId;\n                }\n                // Move AccessibilityManager out of {@link getLockObject} to prevent potential\n                // deadlock.\n                final List<AccessibilityServiceInfo> installedServices =\n                        withAccessibilityManager(userId,\n                                AccessibilityManager::getInstalledAccessibilityServiceList);\n\n                if (installedServices != null) {\n                    for (AccessibilityServiceInfo service : installedServices) {\n                        ServiceInfo serviceInfo = service.getResolveInfo().serviceInfo;\n                        ApplicationInfo applicationInfo = serviceInfo.applicationInfo;\n                        if ((applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {\n                            result.add(serviceInfo.packageName);\n                        }\n                    }\n                }\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n\n        return result;\n    }\n\n    @Override\n    public boolean isAccessibilityServicePermittedByAdmin(ComponentName who, String packageName,\n            int userHandle) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkStringNotEmpty(packageName, \"packageName is null\");\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG,\n                        \"query if an accessibility service is disabled by admin\"));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n            if (admin == null) {\n                return false;\n            }\n            if (admin.permittedAccessiblityServices == null) {\n                return true;\n            }\n            return checkPackagesInPermittedListOrSystem(Collections.singletonList(packageName),\n                    admin.permittedAccessiblityServices, userHandle);\n        }\n    }\n\n    @Override\n    public boolean setPermittedInputMethods(ComponentName who, String callerPackageName,\n            List<String> packageList, boolean calledOnParentInstance) {\n        if (!mHasFeature) {\n            return false;\n        }\n\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n\n        int userId = getProfileParentUserIfRequested(\n                caller.getUserId(), calledOnParentInstance);\n        if (calledOnParentInstance) {\n            Preconditions.checkArgument(packageList == null || packageList.isEmpty(),\n                    \"Permitted input methods must allow all input methods or only \"\n                            + \"system input methods when called on the parent instance of an \"\n                            + \"organization-owned device\");\n        }\n\n        if (packageList != null) {\n            List<InputMethodInfo> enabledImes = mInjector.binderWithCleanCallingIdentity(() ->\n                    InputMethodManagerInternal.get().getEnabledInputMethodListAsUser(userId));\n            if (enabledImes != null) {\n                List<String> enabledPackages = new ArrayList<String>();\n                for (InputMethodInfo ime : enabledImes) {\n                    enabledPackages.add(ime.getPackageName());\n                }\n                if (!checkPackagesInPermittedListOrSystem(enabledPackages, packageList,\n                        userId)) {\n                    Slogf.e(LOG_TAG, \"Cannot set permitted input methods, because the list of \"\n                            + \"permitted input methods excludes an already-enabled input method.\");\n                    return false;\n                }\n            }\n        }\n\n        synchronized (getLockObject()) {\n            EnforcingAdmin admin = enforcePermissionAndGetEnforcingAdmin(\n                    who, MANAGE_DEVICE_POLICY_INPUT_METHODS,\n                    caller.getPackageName(), userId);\n            if (packageList == null) {\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.PERMITTED_INPUT_METHODS,\n                        admin,\n                        userId);\n            } else {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.PERMITTED_INPUT_METHODS,\n                        admin,\n                        new PackageSetPolicyValue(new HashSet<>(packageList)),\n                        userId);\n            }\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PERMITTED_INPUT_METHODS)\n                .setAdmin(caller.getPackageName())\n                .setStrings(getStringArrayForLogging(packageList, calledOnParentInstance))\n                .write();\n        return true;\n    }\n\n    private String[] getStringArrayForLogging(List list, boolean calledOnParentInstance) {\n        List<String> stringList = new ArrayList<String>();\n        stringList.add(calledOnParentInstance ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT);\n        if (list == null) {\n            stringList.add(NULL_STRING_ARRAY);\n        } else {\n            stringList.addAll((List<String>) list);\n        }\n        return stringList.toArray(new String[0]);\n    }\n\n    @Override\n    public List<String> getPermittedInputMethods(ComponentName who, String callerPackageName,\n            boolean calledOnParentInstance) {\n        if (!mHasFeature) {\n            return null;\n        }\n\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n\n        synchronized (getLockObject()) {\n            int affectedUser = calledOnParentInstance ? getProfileParentId(\n                    caller.getUserId()) : caller.getUserId();\n            Set<String> policy = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.PERMITTED_INPUT_METHODS, affectedUser);\n            return policy == null ? null : new ArrayList<>(policy);\n        }\n    }\n\n    @Override\n    public @Nullable List<String> getPermittedInputMethodsAsUser(@UserIdInt int userId) {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userId));\n        Preconditions.checkCallAuthorization(canManageUsers(caller) || canQueryAdminPolicy(caller));\n        final long callingIdentity = Binder.clearCallingIdentity();\n        try {\n            return getPermittedInputMethodsUnchecked(userId);\n        } finally {\n            Binder.restoreCallingIdentity(callingIdentity);\n        }\n    }\n\n    private @Nullable List<String> getPermittedInputMethodsUnchecked(@UserIdInt int userId) {\n        Set<String> policy = mDevicePolicyEngine.getResolvedPolicy(\n                PolicyDefinition.PERMITTED_INPUT_METHODS, userId);\n        List<String> result = policy == null ? null : new ArrayList<>(policy);\n\n        // If we have a permitted list add all system input methods.\n        if (result != null) {\n            List<InputMethodInfo> imes = InputMethodManagerInternal\n                    .get().getInputMethodListAsUser(userId);\n            if (imes != null) {\n                for (InputMethodInfo ime : imes) {\n                    ServiceInfo serviceInfo = ime.getServiceInfo();\n                    ApplicationInfo applicationInfo = serviceInfo.applicationInfo;\n                    if ((applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {\n                        result.add(serviceInfo.packageName);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isInputMethodPermittedByAdmin(ComponentName who, String packageName,\n            int userHandle, boolean calledOnParentInstance) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkStringNotEmpty(packageName, \"packageName is null\");\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG,\n                        \"query if an input method is disabled by admin\"));\n\n        int affectedUser = calledOnParentInstance ? getProfileParentId(userHandle) : userHandle;\n        Map<EnforcingAdmin, PolicyValue<Set<String>>> policies =\n                mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                        PolicyDefinition.PERMITTED_INPUT_METHODS, affectedUser);\n        for (EnforcingAdmin a : policies.keySet()) {\n            if (a.getPackageName().equals(who.getPackageName())) {\n                if (policies.get(a).getValue() == null) {\n                    return true;\n                } else {\n                    return checkPackagesInPermittedListOrSystem(\n                            Collections.singletonList(packageName),\n                            new ArrayList<>(policies.get(a).getValue()), affectedUser);\n                }\n            }\n        }\n        // Admin didn't set a policy\n        return false;\n    }\n\n    @Override\n    public boolean setPermittedCrossProfileNotificationListeners(\n            ComponentName who, List<String> packageList) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n\n        if (!isManagedProfile(caller.getUserId())) {\n            return false;\n        }\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            admin.permittedNotificationListeners = packageList;\n            saveSettingsLocked(caller.getUserId());\n        }\n        return true;\n    }\n\n    @Override\n    public List<String> getPermittedCrossProfileNotificationListeners(ComponentName who) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            // API contract is to return null if there are no permitted cross-profile notification\n            // listeners, including in Device Owner mode.\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            return admin.permittedNotificationListeners;\n        }\n    }\n\n    @Override\n    public boolean isNotificationListenerServicePermitted(String packageName, int userId) {\n        if (!mHasFeature) {\n            return true;\n        }\n\n        Preconditions.checkStringNotEmpty(packageName, \"packageName is null or empty\");\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG,\n                        \"query if a notification listener service is permitted\"));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin profileOwner = getProfileOwnerAdminLocked(userId);\n            if (profileOwner == null || profileOwner.permittedNotificationListeners == null) {\n                return true;\n            }\n            return checkPackagesInPermittedListOrSystem(Collections.singletonList(packageName),\n                    profileOwner.permittedNotificationListeners, userId);\n\n        }\n    }\n\n    private void maybeSendAdminEnabledBroadcastLocked(int userHandle) {\n        DevicePolicyData policyData = getUserData(userHandle);\n        if (policyData.mAdminBroadcastPending) {\n            // Send the initialization data to profile owner and delete the data\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userHandle);\n            boolean clearInitBundle = true;\n            if (admin != null) {\n                PersistableBundle initBundle = policyData.mInitBundle;\n                clearInitBundle = sendAdminCommandLocked(admin,\n                        DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED,\n                        initBundle == null ? null : new Bundle(initBundle),\n                        /* result= */ null ,\n                        /* inForeground= */ true);\n            }\n            if (clearInitBundle) {\n                // If there's no admin or we've successfully called the admin, clear the init bundle\n                // otherwise, keep it around\n                policyData.mInitBundle = null;\n                policyData.mAdminBroadcastPending = false;\n                saveSettingsLocked(userHandle);\n            }\n        }\n    }\n\n    @Override\n    public UserHandle createAndManageUser(ComponentName admin, String name,\n            ComponentName profileOwner, PersistableBundle adminExtras, int flags) {\n        Objects.requireNonNull(admin, \"admin is null\");\n        Objects.requireNonNull(profileOwner, \"profileOwner is null\");\n        if (!admin.getPackageName().equals(profileOwner.getPackageName())) {\n            throw new IllegalArgumentException(\"profileOwner \" + profileOwner + \" and admin \"\n                    + admin + \" are not in the same package\");\n        }\n        final CallerIdentity caller = getCallerIdentity(admin);\n\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_CREATE_AND_MANAGE_USER);\n\n        // Block this method if the device is in headless main user mode\n        Preconditions.checkCallAuthorization(\n                !mInjector.userManagerIsHeadlessSystemUserMode()\n                        || getHeadlessDeviceOwnerModeForDeviceOwner()\n                        != HEADLESS_DEVICE_OWNER_MODE_SINGLE_USER,\n                \"createAndManageUser was called while in headless single user mode\");\n\n        // Only allow the system user to use this method\n        Preconditions.checkCallAuthorization(caller.getUserHandle().isSystem(),\n                \"createAndManageUser was called from non-system user\");\n\n        final boolean ephemeral = (flags & DevicePolicyManager.MAKE_USER_EPHEMERAL) != 0;\n        final boolean demo = (flags & DevicePolicyManager.MAKE_USER_DEMO) != 0\n                && UserManager.isDeviceInDemoMode(mContext);\n        final boolean leaveAllSystemAppsEnabled = (flags & LEAVE_ALL_SYSTEM_APPS_ENABLED) != 0;\n        final int targetSdkVersion;\n\n        // Create user.\n        UserHandle user = null;\n        synchronized (getLockObject()) {\n            final long id = mInjector.binderClearCallingIdentity();\n            try {\n                targetSdkVersion = mInjector.getPackageManagerInternal().getUidTargetSdkVersion(\n                        caller.getUid());\n\n                // Return detail error code for checks inside\n                // UserManagerService.createUserInternalUnchecked.\n                DeviceStorageMonitorInternal deviceStorageMonitorInternal =\n                        LocalServices.getService(DeviceStorageMonitorInternal.class);\n                if (deviceStorageMonitorInternal.isMemoryLow()) {\n                    if (targetSdkVersion >= Build.VERSION_CODES.P) {\n                        throw new ServiceSpecificException(\n                                UserManager.USER_OPERATION_ERROR_LOW_STORAGE, \"low device storage\");\n                    } else {\n                        return null;\n                    }\n                }\n\n                String userType = demo ? UserManager.USER_TYPE_FULL_DEMO\n                        : UserManager.USER_TYPE_FULL_SECONDARY;\n                int userInfoFlags = ephemeral ? UserInfo.FLAG_EPHEMERAL : 0;\n\n                if (!mUserManager.canAddMoreUsers(userType)) {\n                    if (targetSdkVersion >= Build.VERSION_CODES.P) {\n                        throw new ServiceSpecificException(\n                                UserManager.USER_OPERATION_ERROR_MAX_USERS, \"user limit reached\");\n                    } else {\n                        return null;\n                    }\n                }\n\n                String[] disallowedPackages = null;\n                if (!leaveAllSystemAppsEnabled) {\n                    disallowedPackages = mOverlayPackagesProvider.getNonRequiredApps(admin,\n                            UserHandle.myUserId(), ACTION_PROVISION_MANAGED_USER).toArray(\n                            new String[0]);\n                }\n\n                Object token = new Object();\n                Slogf.d(LOG_TAG, \"Adding new pending token: \" + token);\n                mPendingUserCreatedCallbackTokens.add(token);\n                try {\n                    UserInfo userInfo = mUserManagerInternal.createUserEvenWhenDisallowed(name,\n                            userType, userInfoFlags, disallowedPackages, token);\n                    if (userInfo != null) {\n                        user = userInfo.getUserHandle();\n                    }\n                } catch (UserManager.CheckedUserOperationException e) {\n                    Slogf.e(LOG_TAG, \"Couldn't createUserEvenWhenDisallowed\", e);\n                }\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        } // synchronized\n\n        if (user == null) {\n            if (targetSdkVersion >= Build.VERSION_CODES.P) {\n                throw new ServiceSpecificException(UserManager.USER_OPERATION_ERROR_UNKNOWN,\n                        \"failed to create user\");\n            } else {\n                return null;\n            }\n        }\n\n        final int userHandle = user.getIdentifier();\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            maybeInstallDevicePolicyManagementRoleHolderInUser(userHandle);\n\n            manageUserUnchecked(admin, profileOwner, userHandle, adminExtras,\n                    /* showDisclaimer= */ true);\n\n            if ((flags & DevicePolicyManager.SKIP_SETUP_WIZARD) != 0) {\n                Settings.Secure.putIntForUser(mContext.getContentResolver(),\n                        USER_SETUP_COMPLETE, 1, userHandle);\n            }\n\n            sendProvisioningCompletedBroadcast(\n                    userHandle, ACTION_PROVISION_MANAGED_USER, leaveAllSystemAppsEnabled);\n\n            return user;\n        } catch (Throwable re) {\n            mUserManager.removeUser(userHandle);\n            if (targetSdkVersion >= Build.VERSION_CODES.P) {\n                throw new ServiceSpecificException(UserManager.USER_OPERATION_ERROR_UNKNOWN,\n                        re.getMessage());\n            } else {\n                return null;\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    private void sendProvisioningCompletedBroadcast(\n            int user, String action, boolean leaveAllSystemAppsEnabled) {\n        final Intent intent = new Intent(DevicePolicyManager.ACTION_PROVISIONING_COMPLETED)\n                .putExtra(Intent.EXTRA_USER_HANDLE, user)\n                .putExtra(Intent.EXTRA_USER, UserHandle.of(user))\n                .putExtra(\n                        DevicePolicyManager.EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED,\n                        leaveAllSystemAppsEnabled)\n                .putExtra(DevicePolicyManager.EXTRA_PROVISIONING_ACTION,\n                        action)\n                .setPackage(getManagedProvisioningPackage(mContext))\n                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        mContext.sendBroadcastAsUser(intent, UserHandle.SYSTEM);\n    }\n\n    private void manageUserUnchecked(ComponentName admin, ComponentName profileOwner,\n            @UserIdInt int userId, @Nullable PersistableBundle adminExtras,\n            boolean showDisclaimer) {\n        synchronized (getLockObject()) {\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"manageUserUnchecked(): admin=\" + admin + \", po=\" + profileOwner\n                        + \", userId=\" + userId + \", hasAdminExtras=\" + (adminExtras != null)\n                        + \", showDisclaimer=\" + showDisclaimer);\n            }\n        }\n        final String adminPkg = admin.getPackageName();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                // Install the profile owner if not present.\n                if (!mIPackageManager.isPackageAvailable(adminPkg, userId)) {\n                    mIPackageManager.installExistingPackageAsUser(adminPkg, userId,\n                            PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                            PackageManager.INSTALL_REASON_POLICY,\n                            /* allowlistedRestrictedPermissions= */ null);\n                }\n            } catch (RemoteException e) {\n                // Does not happen, same process\n                Slogf.wtf(LOG_TAG, e, \"Failed to install admin package %s for user %d\",\n                        adminPkg, userId);\n            }\n        });\n\n        // Set admin.\n        setActiveAdmin(profileOwner, /* refreshing= */ true, userId, null);\n        setProfileOwner(profileOwner, userId);\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(userId);\n            policyData.mInitBundle = adminExtras;\n            policyData.mAdminBroadcastPending = true;\n            policyData.mNewUserDisclaimer = showDisclaimer\n                    ? DevicePolicyData.NEW_USER_DISCLAIMER_NEEDED\n                    : DevicePolicyData.NEW_USER_DISCLAIMER_NOT_NEEDED;\n            saveSettingsLocked(userId);\n\n        }\n    }\n\n    private void handleNewUserCreated(UserInfo user, @Nullable Object token) {\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"handleNewUserCreated(): user=\" + user.toFullString()\n                    + \", token=\" + token);\n        }\n\n        mDevicePolicyEngine.handleUserCreated(user);\n\n        final int userId = user.id;\n        if (token != null) {\n            synchronized (getLockObject()) {\n                if (mPendingUserCreatedCallbackTokens.contains(token)) {\n                    // Ignore because it was triggered by createAndManageUser()\n                    Slogf.d(LOG_TAG, \"handleNewUserCreated(): ignoring for user \" + userId\n                            + \" due to token \" + token);\n                    mPendingUserCreatedCallbackTokens.remove(token);\n                    return;\n                }\n            }\n        }\n\n        if (!mOwners.hasDeviceOwner() || !user.isFull() || user.isManagedProfile()\n                || user.isGuest()) {\n            return;\n        }\n\n        if (mInjector.userManagerIsHeadlessSystemUserMode()) {\n            ComponentName admin = mOwners.getDeviceOwnerComponent();\n            Slogf.i(LOG_TAG, \"Automatically setting profile owner (\" + admin + \") on new user \"\n                    + userId);\n            manageUserUnchecked(/* deviceOwner= */ admin, /* profileOwner= */ admin,\n                    /* managedUser= */ userId, /* adminExtras= */ null, /* showDisclaimer= */ true);\n        } else {\n            Slogf.i(LOG_TAG, \"User %d added on DO mode; setting ShowNewUserDisclaimer\", userId);\n            setShowNewUserDisclaimer(userId, DevicePolicyData.NEW_USER_DISCLAIMER_NEEDED);\n        }\n    }\n\n    @Override\n    public void acknowledgeNewUserDisclaimer(@UserIdInt int userId) {\n        CallerIdentity callerIdentity = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(callerIdentity)\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n\n        setShowNewUserDisclaimer(userId, DevicePolicyData.NEW_USER_DISCLAIMER_ACKNOWLEDGED);\n    }\n\n    private void setShowNewUserDisclaimer(@UserIdInt int userId, String value) {\n        Slogf.i(LOG_TAG, \"Setting new user disclaimer for user \" + userId + \" as \" + value);\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(userId);\n            policyData.mNewUserDisclaimer = value;\n            saveSettingsLocked(userId);\n        }\n    }\n\n    private void showNewUserDisclaimerIfNecessary(@UserIdInt int userId) {\n        boolean mustShow;\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(userId);\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"showNewUserDisclaimerIfNecessary(\" + userId + \"): \"\n                        + policyData.mNewUserDisclaimer + \")\");\n            }\n            mustShow = DevicePolicyData.NEW_USER_DISCLAIMER_NEEDED\n                    .equals(policyData.mNewUserDisclaimer);\n        }\n        if (!mustShow) return;\n\n        Intent intent = new Intent(DevicePolicyManager.ACTION_SHOW_NEW_USER_DISCLAIMER);\n\n        // TODO(b/172691310): add CTS tests to make sure disclaimer is shown\n        Slogf.i(LOG_TAG, \"Dispatching ACTION_SHOW_NEW_USER_DISCLAIMER intent\");\n        mContext.sendBroadcastAsUser(intent, UserHandle.of(userId));\n    }\n\n    @Override\n    public boolean isNewUserDisclaimerAcknowledged(@UserIdInt int userId) {\n        CallerIdentity callerIdentity = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(callerIdentity)\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(userId);\n            return policyData.isNewUserDisclaimerAcknowledged();\n        }\n    }\n\n    @Override\n    public boolean removeUser(ComponentName who, UserHandle userHandle) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(userHandle, \"UserHandle is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_REMOVE_USER);\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            String restriction = isManagedProfile(userHandle.getIdentifier())\n                    ? UserManager.DISALLOW_REMOVE_MANAGED_PROFILE\n                    : UserManager.DISALLOW_REMOVE_USER;\n            if (isAdminAffectedByRestriction(who, restriction, caller.getUserId())) {\n                Slogf.w(LOG_TAG, \"The device owner cannot remove a user because %s is enabled, and \"\n                        + \"was not set by the device owner\", restriction);\n                return false;\n            }\n            return mUserManagerInternal.removeUserEvenWhenDisallowed(userHandle.getIdentifier());\n        });\n    }\n\n    private boolean isAdminAffectedByRestriction(\n            @Nullable ComponentName admin, String userRestriction, int userId) {\n        switch (mUserManager.getUserRestrictionSource(userRestriction, UserHandle.of(userId))) {\n            case UserManager.RESTRICTION_NOT_SET:\n                return false;\n            case UserManager.RESTRICTION_SOURCE_DEVICE_OWNER:\n            case UserManager.RESTRICTION_SOURCE_PROFILE_OWNER:\n                return !(isDeviceOwner(admin, userId) || isProfileOwner(admin, userId));\n            default:\n                return true;\n        }\n    }\n\n    @Override\n    public boolean switchUser(ComponentName who, UserHandle userHandle) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SWITCH_USER);\n\n        boolean switched = false;\n        // Save previous logout user id in case of failure\n        int logoutUserId = getLogoutUserIdUnchecked();\n        synchronized (getLockObject()) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                int userId = UserHandle.USER_SYSTEM;\n                if (userHandle != null) {\n                    userId = userHandle.getIdentifier();\n                }\n                Slogf.i(LOG_TAG, \"Switching to user %d (logout user is %d)\", userId, logoutUserId);\n                setLogoutUserIdLocked(UserHandle.USER_CURRENT);\n                switched = mInjector.getIActivityManager().switchUser(userId);\n                if (!switched) {\n                    Slogf.w(LOG_TAG, \"Failed to switch to user %d\", userId);\n                } else {\n                    Slogf.d(LOG_TAG, \"Switched\");\n                }\n                return switched;\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Couldn't switch user\", e);\n                return false;\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n                if (!switched) {\n                    setLogoutUserIdLocked(logoutUserId);\n                }\n            }\n        }\n    }\n\n    @Override\n    public int getLogoutUserId() {\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n\n        return getLogoutUserIdUnchecked();\n    }\n\n    private @UserIdInt int getLogoutUserIdUnchecked() {\n        synchronized (getLockObject()) {\n            return mLogoutUserId;\n        }\n    }\n\n    private void clearLogoutUser() {\n        synchronized (getLockObject()) {\n            setLogoutUserIdLocked(UserHandle.USER_NULL);\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void setLogoutUserIdLocked(@UserIdInt int userId) {\n        if (userId == UserHandle.USER_CURRENT) {\n            userId = getCurrentForegroundUserId();\n        }\n\n        Slogf.d(LOG_TAG, \"setLogoutUserId(): %d -> %d\", mLogoutUserId, userId);\n        mLogoutUserId = userId;\n    }\n\n    @Override\n    public int startUserInBackground(ComponentName who, UserHandle userHandle) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(userHandle, \"UserHandle is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_START_USER_IN_BACKGROUND);\n\n        final int userId = userHandle.getIdentifier();\n        if (isManagedProfile(userId)) {\n            Slogf.w(LOG_TAG, \"Managed profile cannot be started in background\");\n            return UserManager.USER_OPERATION_ERROR_MANAGED_PROFILE;\n        }\n\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            if (!mInjector.getActivityManagerInternal().canStartMoreUsers()) {\n                Slogf.w(LOG_TAG, \"Cannot start user %d, too many users in background\", userId);\n                return UserManager.USER_OPERATION_ERROR_MAX_RUNNING_USERS;\n            }\n\n            Slogf.i(LOG_TAG, \"Starting user %d in background\", userId);\n            if (mInjector.getIActivityManager().startUserInBackground(userId)) {\n                return UserManager.USER_OPERATION_SUCCESS;\n            } else {\n                Slogf.w(LOG_TAG, \"failed to start user %d in background\", userId);\n                return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n            }\n        } catch (RemoteException e) {\n            // Same process, should not happen.\n            return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    @Override\n    public int stopUser(ComponentName who, UserHandle userHandle) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(userHandle, \"UserHandle is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_STOP_USER);\n\n        final int userId = userHandle.getIdentifier();\n        if (isManagedProfile(userId)) {\n            Slogf.w(LOG_TAG, \"Managed profile cannot be stopped\");\n            return UserManager.USER_OPERATION_ERROR_MANAGED_PROFILE;\n        }\n\n        return stopUserUnchecked(userId);\n    }\n\n    @Override\n    public int logoutUser(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_LOGOUT_USER);\n\n        final int callingUserId = caller.getUserId();\n        synchronized (getLockObject()) {\n            if (!isUserAffiliatedWithDeviceLocked(callingUserId)) {\n                throw new SecurityException(\"Admin \" + who +\n                        \" is neither the device owner or affiliated user's profile owner.\");\n            }\n        }\n\n        if (isManagedProfile(callingUserId)) {\n            Slogf.w(LOG_TAG, \"Managed profile cannot be logout\");\n            return UserManager.USER_OPERATION_ERROR_MANAGED_PROFILE;\n        }\n\n        if (callingUserId != mInjector\n                .binderWithCleanCallingIdentity(() -> getCurrentForegroundUserId())) {\n            Slogf.d(LOG_TAG, \"logoutUser(): user %d is in background, just stopping, not switching\",\n                    callingUserId);\n            return stopUserUnchecked(callingUserId);\n        }\n\n        return logoutUserUnchecked(/* userIdToStop= */ callingUserId);\n    }\n\n    @Override\n    public int logoutUserInternal() {\n        CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(caller)\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n\n        int currentUserId = getCurrentForegroundUserId();\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"logout() called by uid %d; current user is %d\", caller.getUid(),\n                    currentUserId);\n        }\n        int result = logoutUserUnchecked(currentUserId);\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"Result of logout(): %d\", result);\n        }\n        return result;\n    }\n\n    private int logoutUserUnchecked(@UserIdInt int userIdToStop) {\n        int logoutUserId = getLogoutUserIdUnchecked();\n        if (logoutUserId == UserHandle.USER_NULL) {\n            // Could happen on devices using headless system user mode when called before calling\n            // switchUser() or startUserInBackground() first\n            Slogf.w(LOG_TAG, \"logoutUser(): could not determine which user to switch to\");\n            return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n        }\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            Slogf.i(LOG_TAG, \"logoutUser(): switching to user %d\", logoutUserId);\n            if (!mInjector.getIActivityManager().switchUser(logoutUserId)) {\n                Slogf.w(LOG_TAG, \"Failed to switch to user %d\", logoutUserId);\n                // This should never happen as target user is determined by getPreviousUserId()\n                return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n            }\n            clearLogoutUser();\n        } catch (RemoteException e) {\n            // Same process, should not happen.\n            return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n\n        return stopUserUnchecked(userIdToStop);\n    }\n\n    private int stopUserUnchecked(@UserIdInt int userId) {\n        Slogf.i(LOG_TAG, \"Stopping user %d\", userId);\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            switch (mInjector.getIActivityManager().stopUserWithCallback(userId, null)) {\n                case ActivityManager.USER_OP_SUCCESS:\n                    return UserManager.USER_OPERATION_SUCCESS;\n                case ActivityManager.USER_OP_IS_CURRENT:\n                    return UserManager.USER_OPERATION_ERROR_CURRENT_USER;\n                default:\n                    return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n            }\n        } catch (RemoteException e) {\n            // Same process, should not happen.\n            return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    @Override\n    public List<UserHandle> getSecondaryUsers(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            final List<UserInfo> userInfos = mInjector.getUserManager().getAliveUsers();\n            final List<UserHandle> userHandles = new ArrayList<>();\n            for (UserInfo userInfo : userInfos) {\n                UserHandle userHandle = userInfo.getUserHandle();\n                if (!userHandle.isSystem() && !isManagedProfile(userHandle.getIdentifier())) {\n                    userHandles.add(userInfo.getUserHandle());\n                }\n            }\n            return userHandles;\n        });\n    }\n\n    @Override\n    public boolean isEphemeralUser(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getUserManager().isUserEphemeral(caller.getUserId()));\n    }\n\n    @Override\n    public Bundle getApplicationRestrictions(ComponentName who, String callerPackage,\n            String packageName, boolean parent) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n\n        final boolean isRoleHolder;\n        if (who != null) {\n            // Caller is DO or PO. They cannot call this on parent\n            Preconditions.checkCallAuthorization(!parent\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)));\n            // Caller has opted to be treated as DPC (by passing a non-null who), so don't\n            // consider it as the DMRH, even if the caller is both the DPC and the DMRH.\n            isRoleHolder = false;\n        } else {\n            // Caller is delegates or the DMRH. Only DMRH can call this on parent\n            isRoleHolder = isCallerDevicePolicyManagementRoleHolder(caller);\n            if (parent) {\n                Preconditions.checkCallAuthorization(isRoleHolder);\n                Preconditions.checkState(isOrganizationOwnedDeviceWithManagedProfile(),\n                        \"Role Holder can only operate parent app restriction on COPE devices\");\n            } else {\n                Preconditions.checkCallAuthorization(isRoleHolder\n                        || isCallerDelegate(caller, DELEGATION_APP_RESTRICTIONS));\n            }\n        }\n        if (isRoleHolder) {\n            EnforcingAdmin enforcingAdmin = getEnforcingAdminForCaller(/* who */ null,\n                    caller.getPackageName());\n            int affectedUserId = parent\n                    ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n            LinkedHashMap<EnforcingAdmin, PolicyValue<Bundle>> policies =\n                    mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                            PolicyDefinition.APPLICATION_RESTRICTIONS(packageName),\n                            affectedUserId);\n            if (!policies.containsKey(enforcingAdmin)) {\n                return Bundle.EMPTY;\n            }\n            return policies.get(enforcingAdmin).getValue();\n        } else {\n            return mInjector.binderWithCleanCallingIdentity(() -> {\n                Bundle bundle = mUserManager.getApplicationRestrictions(packageName,\n                        caller.getUserHandle());\n                // if no restrictions were saved, mUserManager.getApplicationRestrictions\n                // returns null, but DPM method should return an empty Bundle as per JavaDoc\n                return bundle != null ? bundle : Bundle.EMPTY;\n            });\n        }\n    }\n\n    /**\n     * Returns the apps that are non-exempt from some policies (such as suspension), and populates\n     * the given set with the apps that are exempt.\n     *\n     * @param packageNames apps to check\n     * @param outputExemptApps will be populate with subset of {@code packageNames} that is exempt\n     * from some policy restrictions\n     *\n     * @return subset of {@code packageNames} that is affected by some policy restrictions.\n     */\n    private String[] populateNonExemptAndExemptFromPolicyApps(String[] packageNames,\n            Set<String> outputExemptApps) {\n        Preconditions.checkArgument(outputExemptApps.isEmpty(), \"outputExemptApps is not empty\");\n        List<String> exemptAppsList = listPolicyExemptAppsUnchecked(mContext);\n        if (exemptAppsList.isEmpty()) {\n            return packageNames;\n        }\n        // Using a set so contains() is O(1)\n        Set<String> exemptApps = new HashSet<>(exemptAppsList);\n        List<String> nonExemptApps = new ArrayList<>(packageNames.length);\n        for (int i = 0; i < packageNames.length; i++) {\n            String app = packageNames[i];\n            if (exemptApps.contains(app)) {\n                outputExemptApps.add(app);\n            } else {\n                nonExemptApps.add(app);\n            }\n        }\n        String[] result = new String[nonExemptApps.size()];\n        nonExemptApps.toArray(result);\n        return result;\n    }\n\n    private String[] setPackagesSuspendedPreCoexistence(ComponentName who, String callerPackage,\n            String[] packageNames, boolean suspended) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        ActiveAdmin admin;\n\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller,\n                DELEGATION_PACKAGE_ACCESS)));\n        synchronized (getLockObject()) {\n            admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_PACKAGES_SUSPENDED);\n\n        // Must remove the exempt apps from the input before calling PM, then add them back to\n        // the array returned to the caller\n        Set<String> exemptApps = new HashSet<>();\n        packageNames = populateNonExemptAndExemptFromPolicyApps(packageNames, exemptApps);\n\n        String[] nonSuspendedPackages = null;\n        synchronized (getLockObject()) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                nonSuspendedPackages = mInjector.getPackageManagerInternal()\n                        .setPackagesSuspendedByAdmin(caller.getUserId(), packageNames, suspended);\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PACKAGES_SUSPENDED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ who == null)\n                .setStrings(packageNames)\n                .write();\n\n        if (nonSuspendedPackages == null) {\n            Slogf.w(LOG_TAG, \"PM failed to suspend packages (%s)\", Arrays.toString(packageNames));\n            return packageNames;\n        }\n\n        ArraySet<String> changed = new ArraySet<>(packageNames);\n        if (suspended) {\n            // Only save those packages that are actually suspended. If a package is exempt or is\n            // unsuspendable, it is skipped.\n            changed.removeAll(List.of(nonSuspendedPackages));\n        } else {\n            // If an admin tries to unsuspend a package that is either exempt or is not\n            // suspendable, drop it from the stored list assuming it must be already unsuspended.\n            changed.addAll(exemptApps);\n        }\n\n        synchronized (getLockObject()) {\n            ArraySet<String> current = new ArraySet<>(admin.suspendedPackages);\n            if (suspended) {\n                current.addAll(changed);\n            } else {\n                current.removeAll(changed);\n            }\n            admin.suspendedPackages = current.isEmpty() ? null : new ArrayList<>(current);\n            saveSettingsLocked(caller.getUserId());\n        }\n\n        if (exemptApps.isEmpty()) {\n            return nonSuspendedPackages;\n        }\n\n        String[] result = buildNonSuspendedPackagesUnionArray(nonSuspendedPackages, exemptApps);\n        if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"Returning %s\", Arrays.toString(result));\n        return result;\n    }\n\n    @Override\n    public String[] setPackagesSuspended(ComponentName who, String callerPackage,\n            String[] packageNames, boolean suspended) {\n        if (!Flags.suspendPackagesCoexistence()) {\n            return setPackagesSuspendedPreCoexistence(who, callerPackage, packageNames, suspended);\n        }\n\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n\n        EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                who,\n                MANAGE_DEVICE_POLICY_PACKAGE_STATE,\n                caller.getPackageName(),\n                caller.getUserId());\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_PACKAGES_SUSPENDED);\n\n        Set<String> packages = new ArraySet<>(packageNames);\n        Set<String> suspendedPackagesBefore = mDevicePolicyEngine.getResolvedPolicy(\n                PolicyDefinition.PACKAGES_SUSPENDED, caller.getUserId());\n\n        Set<String> currentPackages = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                PolicyDefinition.PACKAGES_SUSPENDED,\n                enforcingAdmin,\n                caller.getUserId());\n        if (currentPackages == null) currentPackages = new ArraySet<>();\n        if (suspended) {\n            currentPackages.addAll(packages);\n        } else {\n            currentPackages.removeAll(packages);\n        }\n        if (currentPackages.isEmpty()) {\n            mDevicePolicyEngine.removeLocalPolicy(\n                    PolicyDefinition.PACKAGES_SUSPENDED,\n                    enforcingAdmin,\n                    caller.getUserId());\n        } else {\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.PACKAGES_SUSPENDED,\n                    enforcingAdmin,\n                    new PackageSetPolicyValue(currentPackages),\n                    caller.getUserId());\n        }\n\n        Set<String> suspendedPackagesAfter = mDevicePolicyEngine.getResolvedPolicy(\n                PolicyDefinition.PACKAGES_SUSPENDED, caller.getUserId());\n\n        PackageSuspender suspender = new PackageSuspender(\n                suspendedPackagesBefore, suspendedPackagesAfter,\n                listPolicyExemptAppsUnchecked(mContext),\n                mInjector.getPackageManagerInternal(), caller.getUserId());\n\n        String[] result;\n        synchronized (getLockObject()) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                result = suspended ? suspender.suspend(packages) : suspender.unsuspend(packages);\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PACKAGES_SUSPENDED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ who == null)\n                .setStrings(packageNames)\n                .write();\n\n        if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"Returning %s\", Arrays.toString(result));\n        return result;\n    }\n\n    /**\n     * Returns an array containing the union of the given non-suspended packages and\n     * exempt apps. Assumes both parameters are non-null and non-empty.\n     */\n    private String[] buildNonSuspendedPackagesUnionArray(String[] nonSuspendedPackages,\n            Set<String> exemptApps) {\n        String[] result = new String[nonSuspendedPackages.length + exemptApps.size()];\n        int index = 0;\n        for (String app : nonSuspendedPackages) {\n            result[index++] = app;\n        }\n        for (String app : exemptApps) {\n            result[index++] = app;\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isPackageSuspended(ComponentName who, String callerPackage, String packageName) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n\n        if (Flags.suspendPackagesCoexistence()) {\n            enforcePermission(\n                    MANAGE_DEVICE_POLICY_PACKAGE_STATE,\n                    caller.getPackageName(),\n                    caller.getUserId());\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(caller,\n                    DELEGATION_PACKAGE_ACCESS)));\n        }\n\n        synchronized (getLockObject()) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                return mIPackageManager.isPackageSuspendedForUser(packageName, caller.getUserId());\n            } catch (RemoteException re) {\n                // Shouldn't happen.\n                Slogf.e(LOG_TAG, \"Failed talking to the package manager\", re);\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n            return false;\n        }\n    }\n\n    @Override\n    public List<String> listPolicyExemptApps() {\n        CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS)\n                        || isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        return listPolicyExemptAppsUnchecked(mContext);\n    }\n\n    private static List<String> listPolicyExemptAppsUnchecked(Context context) {\n        // TODO(b/181238156): decide whether it should only list the apps set by the resources,\n        // or also the \"critical\" apps defined by PersonalAppsSuspensionHelper (like SMS app).\n        // If it's the latter, refactor PersonalAppsSuspensionHelper so it (or a superclass) takes\n        // the resources on constructor.\n        String[] core = context.getResources().getStringArray(R.array.policy_exempt_apps);\n        String[] vendor = context.getResources().getStringArray(R.array.vendor_policy_exempt_apps);\n\n        int size = core.length + vendor.length;\n        Set<String> apps = new ArraySet<>(size);\n        for (String app : core) {\n            apps.add(app);\n        }\n        for (String app : vendor) {\n            apps.add(app);\n        }\n\n        return new ArrayList<>(apps);\n    }\n\n    @Override\n    public void setUserRestriction(\n            ComponentName who, String callerPackage, String key, boolean enabledFromThisOwner,\n            boolean parent) {\n\n        CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        int userId = caller.getUserId();\n        int affectedUserId = parent ? getProfileParentId(userId) : userId;\n\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_USER_RESTRICTION);\n\n        if (!isDeviceOwner(caller) && !isProfileOwner(caller)) {\n            EnforcingAdmin admin = enforcePermissionForUserRestriction(\n                    who,\n                    key,\n                    caller.getPackageName(),\n                    affectedUserId);\n            if (!mInjector.isChangeEnabled(ENABLE_COEXISTENCE_CHANGE, callerPackage, userId)) {\n                throw new IllegalStateException(\"Calling package is not targeting Android U.\");\n            }\n            if (!UserRestrictionsUtils.isValidRestriction(key)) {\n                throw new IllegalArgumentException(\"Invalid restriction key: \" + key);\n            }\n            PolicyDefinition<Boolean> policyDefinition =\n                    PolicyDefinition.getPolicyDefinitionForUserRestriction(key);\n            if (enabledFromThisOwner) {\n                setLocalUserRestrictionInternal(\n                        admin, key, /* enabled= */ true, affectedUserId);\n            } else {\n                // Remove any local and global policy that was set by the admin\n                if (!policyDefinition.isLocalOnlyPolicy()) {\n                    setGlobalUserRestrictionInternal(admin, key, /* enabled= */ false);\n                }\n                if (!policyDefinition.isGlobalOnlyPolicy()) {\n                    setLocalUserRestrictionInternal(admin, key, /* enabled= */ false,\n                            userId);\n\n                    int parentUserId = getProfileParentId(userId);\n                    if (parentUserId != userId) {\n                        setLocalUserRestrictionInternal(\n                                admin, key, /* enabled= */ false, parentUserId);\n                    }\n                }\n            }\n        } else {\n            if (!UserRestrictionsUtils.isValidRestriction(key)) {\n                return;\n            }\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            EnforcingAdmin admin = getEnforcingAdminForCaller(who, callerPackage);\n            checkAdminCanSetRestriction(caller, parent, key);\n            setBackwardCompatibleUserRestriction(\n                    caller, admin, key, enabledFromThisOwner, parent);\n        }\n        logUserRestrictionCall(key, enabledFromThisOwner, parent, caller, affectedUserId);\n    }\n\n    @Override\n    public void setUserRestrictionForUser(\n            @NonNull String systemEntity, String key, boolean enabled, @UserIdInt int targetUser) {\n        Objects.requireNonNull(systemEntity);\n\n        CallerIdentity caller = getCallerIdentity();\n        if (!isSystemUid(caller)) {\n            throw new SecurityException(\"Only system services can call setUserRestrictionForUser\"\n                    + \" on a target user: \" + targetUser);\n        }\n        if (!UserRestrictionsUtils.isValidRestriction(key)) {\n            throw new IllegalArgumentException(\"Invalid restriction key: \" + key);\n        }\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"Creating SystemEnforcingAdmin %s for calling package %s\",\n                    systemEntity, caller.getPackageName());\n        }\n        EnforcingAdmin admin = EnforcingAdmin.createSystemEnforcingAdmin(systemEntity);\n\n        setLocalUserRestrictionInternal(admin, key, enabled, targetUser);\n\n        logUserRestrictionCall(key, enabled, /* parent= */ false, caller, targetUser);\n    }\n\n    private void checkAdminCanSetRestriction(CallerIdentity caller, boolean parent, String key) {\n        boolean isProfileOwnerOfOrganizationOwnedDevice =\n                isProfileOwnerOfOrganizationOwnedDevice(caller);\n        if (parent) {\n            Preconditions.checkCallAuthorization(\n                    isProfileOwnerOfOrganizationOwnedDevice);\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isDeviceOwner(caller) || isProfileOwner(caller));\n        }\n        synchronized (getLockObject()) {\n            if (isDefaultDeviceOwner(caller)) {\n                if (!UserRestrictionsUtils.canDeviceOwnerChange(key)) {\n                    throw new SecurityException(\"Device owner cannot set user restriction \"\n                            + key);\n                }\n                Preconditions.checkArgument(!parent,\n                        \"Cannot use the parent instance in Device Owner mode\");\n            } else if (isFinancedDeviceOwner(caller)) {\n                if (!UserRestrictionsUtils.canFinancedDeviceOwnerChange(key)) {\n                    throw new SecurityException(\"Cannot set user restriction \" + key\n                            + \" when managing a financed device\");\n                }\n                Preconditions.checkArgument(!parent,\n                        \"Cannot use the parent instance in Financed Device Owner\"\n                                + \" mode\");\n            } else {\n                boolean profileOwnerCanChangeOnItself = !parent\n                        && UserRestrictionsUtils.canProfileOwnerChange(\n                            key,\n                            caller.getUserId() == getMainUserId(),\n                            isProfileOwnerOfOrganizationOwnedDevice);\n                boolean orgOwnedProfileOwnerCanChangeGlobally = parent\n                        && isProfileOwnerOfOrganizationOwnedDevice\n                        && UserRestrictionsUtils\n                            .canParentOfProfileOwnerOfOrganizationOwnedDeviceChange(key);\n\n                if (!profileOwnerCanChangeOnItself && !orgOwnedProfileOwnerCanChangeGlobally) {\n                    throw new SecurityException(\"Profile owner cannot set user restriction \"\n                            + key);\n                }\n            }\n        }\n    }\n    private void setBackwardCompatibleUserRestriction(\n            CallerIdentity caller, EnforcingAdmin admin, String key, boolean enabled,\n            boolean parent) {\n        synchronized (getLockObject()) {\n\n            int ownerType;\n            if (isDeviceOwner(caller)) {\n                ownerType = OWNER_TYPE_DEVICE_OWNER;\n            } else if (isProfileOwnerOfOrganizationOwnedDevice(caller)) {\n                ownerType = OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE;\n            } else if (isProfileOwner(caller)) {\n                ownerType = OWNER_TYPE_PROFILE_OWNER;\n            } else {\n                throw new IllegalStateException(\"Non-DO/Non-PO cannot set restriction \" + key\n                        + \" while targetSdkVersion is less than UPSIDE_DOWN_CAKE\");\n            }\n            setBackwardCompatibleUserRestrictionLocked(ownerType, admin, caller.getUserId(), key,\n                    enabled, parent);\n        }\n    }\n\n    private void setBackwardCompatibleUserRestrictionLocked(\n            int ownerType, EnforcingAdmin admin, int userId, String key, boolean enabled,\n            boolean parent) {\n        if (ownerType == OWNER_TYPE_DEVICE_OWNER) {\n            if (UserRestrictionsUtils.isGlobal(OWNER_TYPE_DEVICE_OWNER, key)) {\n                setGlobalUserRestrictionInternal(admin, key, enabled);\n            } else {\n                setLocalUserRestrictionInternal(admin, key, enabled, userId);\n            }\n        } else if (ownerType == OWNER_TYPE_PROFILE_OWNER\n                || ownerType == OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE) {\n            if (UserRestrictionsUtils.isGlobal(OWNER_TYPE_PROFILE_OWNER, key)\n                    || (parent && ownerType == OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE\n                    && UserRestrictionsUtils.isGlobal(\n                    OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE, key))) {\n                setGlobalUserRestrictionInternal(admin, key, enabled);\n            } else {\n                int affectedUserId = parent\n                        ? getProfileParentId(userId) : userId;\n                setLocalUserRestrictionInternal(admin, key, enabled, affectedUserId);\n            }\n        } else {\n            throw new IllegalStateException(\"Non-DO/Non-PO cannot set restriction \" + key\n                    + \" while targetSdkVersion is less than UPSIDE_DOWN_CAKE\");\n        }\n    }\n\n    @Override\n    public void setUserRestrictionGlobally(String callerPackage, String key) {\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n\n        EnforcingAdmin admin = enforcePermissionForUserRestriction(\n                /* who= */ null,\n                key,\n                caller.getPackageName(),\n                UserHandle.USER_ALL\n        );\n\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_USER_RESTRICTION);\n\n        if (isDeviceOwner(caller) || isProfileOwner(caller)) {\n            throw new SecurityException(\"Admins are not allowed to call this API.\");\n        }\n        if (!mInjector.isChangeEnabled(\n                ENABLE_COEXISTENCE_CHANGE, callerPackage, caller.getUserId())) {\n            throw new IllegalStateException(\"Calling package is not targeting Android U.\");\n        }\n        if (!UserRestrictionsUtils.isValidRestriction(key)) {\n            throw new IllegalArgumentException(\"Invalid restriction key: \" + key);\n        }\n\n        setGlobalUserRestrictionInternal(admin, key, /* enabled= */ true);\n\n        logUserRestrictionCall(key, /* enabled= */ true, /* parent= */ false, caller,\n                UserHandle.USER_ALL);\n    }\n\n    @Override\n    public void setUserRestrictionGloballyFromSystem(@NonNull String systemEntity, String key,\n            boolean enabled) {\n        Objects.requireNonNull(systemEntity);\n\n        CallerIdentity caller = getCallerIdentity();\n        if (!isSystemUid(caller)) {\n            throw new SecurityException(\"Only system services can call\"\n                    + \" setUserRestrictionGloballyFromSystem\");\n        }\n        if (!UserRestrictionsUtils.isValidRestriction(key)) {\n            throw new IllegalArgumentException(\"Invalid restriction key: \" + key);\n        }\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"Creating SystemEnforcingAdmin %s for calling package %s\",\n                    systemEntity, caller.getPackageName());\n        }\n        EnforcingAdmin admin = EnforcingAdmin.createSystemEnforcingAdmin(systemEntity);\n\n        setGlobalUserRestrictionInternal(admin, key, enabled);\n\n        logUserRestrictionCall(key, enabled, /* parent= */ false, caller, UserHandle.USER_ALL);\n    }\n\n    private void setLocalUserRestrictionInternal(\n            EnforcingAdmin admin, String key, boolean enabled, int userId) {\n        PolicyDefinition<Boolean> policyDefinition =\n                PolicyDefinition.getPolicyDefinitionForUserRestriction(key);\n        if (enabled) {\n            mDevicePolicyEngine.setLocalPolicy(\n                    policyDefinition,\n                    admin,\n                    new BooleanPolicyValue(true),\n                    userId);\n        } else {\n            mDevicePolicyEngine.removeLocalPolicy(\n                    policyDefinition,\n                    admin,\n                    userId);\n        }\n    }\n\n    private void setGlobalUserRestrictionInternal(\n            EnforcingAdmin admin, String key, boolean enabled) {\n        PolicyDefinition<Boolean> policyDefinition =\n                PolicyDefinition.getPolicyDefinitionForUserRestriction(key);\n        if (enabled) {\n            mDevicePolicyEngine.setGlobalPolicy(\n                    PolicyDefinition.getPolicyDefinitionForUserRestriction(key),\n                    admin,\n                    new BooleanPolicyValue(true));\n        } else {\n            mDevicePolicyEngine.removeGlobalPolicy(\n                    policyDefinition,\n                    admin);\n        }\n    }\n\n    private void logUserRestrictionCall(\n            String key, boolean enabled, boolean parent, CallerIdentity caller, int targetUserId) {\n        final int eventId = enabled\n                ? DevicePolicyEnums.ADD_USER_RESTRICTION\n                : DevicePolicyEnums.REMOVE_USER_RESTRICTION;\n        DevicePolicyEventLogger\n                .createEvent(eventId)\n                .setAdmin(caller.getComponentName())\n                .setStrings(key, parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT)\n                .write();\n        if (SecurityLog.isLoggingEnabled()) {\n            final int eventTag = enabled\n                    ? SecurityLog.TAG_USER_RESTRICTION_ADDED\n                    : SecurityLog.TAG_USER_RESTRICTION_REMOVED;\n            SecurityLog.writeEvent(eventTag, caller.getPackageName(), caller.getUserId(), key);\n        }\n\n        Slogf.i(LOG_TAG, \"Changing user restriction %s on %s to: %b caller: %s\",\n                key, (targetUserId == UserHandle.USER_ALL ? \"all users\" : (\"user \" + targetUserId)),\n                enabled, caller.toString());\n    }\n\n    @Override\n    public Bundle getUserRestrictions(ComponentName who, String callerPackage, boolean parent) {\n        if (!mHasFeature) {\n            return null;\n        }\n        CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        int targetUserId = parent\n                ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n        EnforcingAdmin admin = getEnforcingAdminForCaller(who, callerPackage);\n        if (isDeviceOwner(caller) || isProfileOwner(caller)) {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isFinancedDeviceOwner(caller)\n                    || isProfileOwner(caller)\n                    || (parent && isProfileOwnerOfOrganizationOwnedDevice(caller)));\n\n            Bundle restrictions = getUserRestrictionsFromPolicyEngine(admin, targetUserId);\n            // Add global restrictions set by the admin as well.\n            restrictions.putAll(\n                    getUserRestrictionsFromPolicyEngine(admin, UserHandle.USER_ALL));\n            return restrictions;\n        } else {\n            if (!mInjector.isChangeEnabled(\n                    ENABLE_COEXISTENCE_CHANGE, callerPackage, caller.getUserId())) {\n                throw new IllegalStateException(\"Calling package is not targeting Android U.\");\n            }\n            return getUserRestrictionsFromPolicyEngine(admin, targetUserId);\n        }\n    }\n\n    // Map of user restriction to permission.\n    private static final HashMap<String, String[]> USER_RESTRICTION_PERMISSIONS = new HashMap<>();\n    {\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.ALLOW_PARENT_PROFILE_APP_LINKING, new String[]{MANAGE_DEVICE_POLICY_PROFILES});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_ADD_CLONE_PROFILE, new String[]{MANAGE_DEVICE_POLICY_PROFILES});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_ADD_PRIVATE_PROFILE, new String[]{MANAGE_DEVICE_POLICY_PROFILES});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_ADD_USER, new String[]{MANAGE_DEVICE_POLICY_MODIFY_USERS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_ADD_WIFI_CONFIG, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_ADJUST_VOLUME, new String[]{MANAGE_DEVICE_POLICY_AUDIO_OUTPUT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_AIRPLANE_MODE, new String[]{MANAGE_DEVICE_POLICY_AIRPLANE_MODE});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_AMBIENT_DISPLAY, new String[]{MANAGE_DEVICE_POLICY_DISPLAY});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_APPS_CONTROL, new String[]{MANAGE_DEVICE_POLICY_APPS_CONTROL});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_AUTOFILL, new String[]{MANAGE_DEVICE_POLICY_AUTOFILL});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_BLUETOOTH, new String[]{MANAGE_DEVICE_POLICY_BLUETOOTH});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_BLUETOOTH_SHARING, new String[]{MANAGE_DEVICE_POLICY_BLUETOOTH});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CAMERA, new String[]{MANAGE_DEVICE_POLICY_CAMERA});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CAMERA_TOGGLE, new String[]{MANAGE_DEVICE_POLICY_CAMERA_TOGGLE});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CELLULAR_2G, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CHANGE_WIFI_STATE, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_BLUETOOTH, new String[]{MANAGE_DEVICE_POLICY_BLUETOOTH});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_BRIGHTNESS, new String[]{MANAGE_DEVICE_POLICY_DISPLAY});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_CELL_BROADCASTS, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_CREDENTIALS, new String[]{MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_DATE_TIME, new String[]{MANAGE_DEVICE_POLICY_TIME});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_DEFAULT_APPS, new String[]{MANAGE_DEFAULT_APPLICATIONS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_LOCALE, new String[]{MANAGE_DEVICE_POLICY_LOCALE});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_LOCATION, new String[]{MANAGE_DEVICE_POLICY_LOCATION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_PRIVATE_DNS, new String[]{MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_SCREEN_TIMEOUT, new String[]{MANAGE_DEVICE_POLICY_DISPLAY});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_TETHERING, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_VPN, new String[]{MANAGE_DEVICE_POLICY_VPN});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_WIFI, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONTENT_CAPTURE, new String[]{MANAGE_DEVICE_POLICY_SCREEN_CONTENT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONTENT_SUGGESTIONS, new String[]{MANAGE_DEVICE_POLICY_SCREEN_CONTENT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CREATE_WINDOWS, new String[]{MANAGE_DEVICE_POLICY_WINDOWS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CROSS_PROFILE_COPY_PASTE, new String[]{MANAGE_DEVICE_POLICY_PROFILE_INTERACTION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_DATA_ROAMING, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_DEBUGGING_FEATURES, new String[]{MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_FACTORY_RESET, new String[]{MANAGE_DEVICE_POLICY_FACTORY_RESET});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_FUN, new String[]{MANAGE_DEVICE_POLICY_FUN});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_INSTALL_APPS, new String[]{MANAGE_DEVICE_POLICY_APPS_CONTROL});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES, new String[]{MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY, new String[]{MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_MICROPHONE_TOGGLE, new String[]{MANAGE_DEVICE_POLICY_MICROPHONE_TOGGLE});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_MODIFY_ACCOUNTS, new String[]{MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA, new String[]{MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_NETWORK_RESET, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_OUTGOING_BEAM, new String[]{MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_OUTGOING_CALLS, new String[]{MANAGE_DEVICE_POLICY_CALLS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_PRINTING, new String[]{MANAGE_DEVICE_POLICY_PRINTING});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_REMOVE_USER, new String[]{MANAGE_DEVICE_POLICY_MODIFY_USERS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_RUN_IN_BACKGROUND, new String[]{MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SAFE_BOOT, new String[]{MANAGE_DEVICE_POLICY_SAFE_BOOT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SET_USER_ICON, new String[]{MANAGE_DEVICE_POLICY_MODIFY_USERS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SET_WALLPAPER, new String[]{MANAGE_DEVICE_POLICY_WALLPAPER});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SHARE_INTO_MANAGED_PROFILE, new String[]{MANAGE_DEVICE_POLICY_PROFILE_INTERACTION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SHARE_LOCATION, new String[]{MANAGE_DEVICE_POLICY_LOCATION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SHARING_ADMIN_CONFIGURED_WIFI, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SMS, new String[]{MANAGE_DEVICE_POLICY_SMS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SYSTEM_ERROR_DIALOGS, new String[]{MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS});\n        if (com.android.net.thread.platform.flags.Flags.threadUserRestrictionEnabled()) {\n            USER_RESTRICTION_PERMISSIONS.put(\n                    UserManager.DISALLOW_THREAD_NETWORK,\n                    new String[]{MANAGE_DEVICE_POLICY_THREAD_NETWORK});\n        }\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_ASSIST_CONTENT,\n                new String[]{MANAGE_DEVICE_POLICY_ASSIST_CONTENT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_ULTRA_WIDEBAND_RADIO, new String[]{MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_NEAR_FIELD_COMMUNICATION_RADIO, new String[]{MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_UNIFIED_PASSWORD, new String[]{MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_UNINSTALL_APPS, new String[]{MANAGE_DEVICE_POLICY_APPS_CONTROL});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_UNMUTE_DEVICE, new String[]{MANAGE_DEVICE_POLICY_AUDIO_OUTPUT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_UNMUTE_MICROPHONE, new String[]{MANAGE_DEVICE_POLICY_MICROPHONE});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_USB_FILE_TRANSFER, new String[]{MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_USER_SWITCH, new String[]{MANAGE_DEVICE_POLICY_MODIFY_USERS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_WIFI_DIRECT, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_WIFI_TETHERING, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.ENSURE_VERIFY_APPS, new String[]{MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SIM_GLOBALLY,\n                new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n\n        // Restrictions not allowed to be set by admins.\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_RECORD_AUDIO, null);\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_WALLPAPER, null);\n    }\n\n    private EnforcingAdmin enforcePermissionForUserRestriction(ComponentName who,\n            String userRestriction, String callerPackageName, int userId) {\n        String[] permissions = USER_RESTRICTION_PERMISSIONS.get(userRestriction);\n        if (permissions.length > 0) {\n            try {\n                return enforcePermissionsAndGetEnforcingAdmin(who, permissions, callerPackageName,\n                        userId);\n            } catch (SecurityException e) {\n                throw new SecurityException(\"Caller does not hold the required permission for this \"\n                        + \"user restriction: \" + userRestriction + \".\\n\" + e.getMessage());\n            }\n         }\n        throw new SecurityException(\"Admins are not permitted to set User Restriction: \"\n                + userRestriction);\n    }\n\n    @Override\n    public Bundle getUserRestrictionsGlobally(String callerPackage) {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        EnforcingAdmin admin = getEnforcingAdminForCaller(/*who=*/ null, caller.getPackageName());\n\n        return getUserRestrictionsFromPolicyEngine(admin,\n                UserHandle.USER_ALL);\n    }\n\n    /**\n     * Returns user restrictions set by the given admin for the provided {@code userId}.\n     *\n     * <p>Pass in {@link UserHandle#USER_ALL} for {@code userId} to get global restrictions set by\n     * the admin\n     */\n    private Bundle getUserRestrictionsFromPolicyEngine(EnforcingAdmin admin, int userId) {\n        Set<UserRestrictionPolicyKey> restrictionKeys =\n                mDevicePolicyEngine.getUserRestrictionPolicyKeysForAdmin(\n                        admin,\n                        userId);\n        Bundle restrictions = new Bundle();\n        for (UserRestrictionPolicyKey key : restrictionKeys) {\n            restrictions.putBoolean(key.getRestriction(), true);\n        }\n        return restrictions;\n    }\n\n    @Override\n    public boolean setApplicationHidden(ComponentName who, String callerPackage, String packageName,\n            boolean hidden, boolean parent) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        final int userId = parent ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n        enforcePermission(MANAGE_DEVICE_POLICY_PACKAGE_STATE, caller.getPackageName(), userId);\n\n        List<String> exemptApps = listPolicyExemptAppsUnchecked(mContext);\n        if (exemptApps.contains(packageName)) {\n            Slogf.d(LOG_TAG, \"setApplicationHidden(): ignoring %s as it's on policy-exempt list\",\n                    packageName);\n            return false;\n        }\n\n        boolean result;\n        synchronized (getLockObject()) {\n            if (parent) {\n                // Ensure the package provided is a system package, this is to ensure that this\n                // API cannot be used to leak if certain non-system package exists in the person\n                // profile.\n                mInjector.binderWithCleanCallingIdentity(() ->\n                        enforcePackageIsSystemPackage(packageName, userId));\n            }\n            checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_APPLICATION_HIDDEN);\n\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"calling pm.setApplicationHiddenSettingAsUser(%s, %b, %d)\",\n                        packageName, hidden, userId);\n            }\n            EnforcingAdmin admin = getEnforcingAdminForCaller(who, callerPackage);\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.APPLICATION_HIDDEN(packageName),\n                    admin,\n                    new BooleanPolicyValue(hidden),\n                    userId);\n            result = mInjector.binderWithCleanCallingIdentity(() -> {\n                try {\n                    // This is a best effort to continue returning the same value that was\n                    // returned before the policy engine migration.\n                    return mInjector.getIPackageManager().getPackageInfo(\n                            packageName, MATCH_UNINSTALLED_PACKAGES, userId) != null\n                            && (mIPackageManager.getApplicationHiddenSettingAsUser(\n                                    packageName, userId) == hidden);\n                } catch (RemoteException e) {\n                    return false;\n                }\n            });\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_APPLICATION_HIDDEN)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ isCallerDelegate(caller))\n                .setStrings(packageName, hidden ? \"hidden\" : \"not_hidden\",\n                        parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT)\n                .write();\n        return result;\n    }\n\n    @Override\n    public boolean isApplicationHidden(ComponentName who, String callerPackage,\n            String packageName, boolean parent) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        int userId = parent ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n        // TODO: Also support DELEGATION_PACKAGE_ACCESS\n        enforcePermission(MANAGE_DEVICE_POLICY_PACKAGE_STATE, caller.getPackageName(), userId);\n\n        synchronized (getLockObject()) {\n            if (parent) {\n                // Ensure the package provided is a system package.\n                mInjector.binderWithCleanCallingIdentity(() ->\n                        enforcePackageIsSystemPackage(packageName, userId));\n            }\n\n            return mInjector.binderWithCleanCallingIdentity(\n                    () -> mIPackageManager.getApplicationHiddenSettingAsUser(packageName, userId));\n        }\n    }\n\n    private void enforcePackageIsSystemPackage(String packageName, int userId)\n            throws RemoteException {\n        boolean isSystem;\n        try {\n            isSystem = isSystemApp(mIPackageManager, packageName, userId);\n        } catch (IllegalArgumentException e) {\n            isSystem = false;\n        }\n        if (!isSystem) {\n            throw new IllegalArgumentException(\"The provided package is not a system package\");\n        }\n    }\n\n    @Override\n    public void enableSystemApp(ComponentName who, String callerPackage, String packageName) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_ENABLE_SYSTEM_APP)));\n\n        final boolean isDemo = isCurrentUserDemo();\n        int userId = caller.getUserId();\n        long id = mInjector.binderClearCallingIdentity();\n        try {\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"installing \" + packageName + \" for \" + userId);\n            }\n\n            Preconditions.checkArgument(isDemo || isSystemApp(mIPackageManager, packageName,\n                    getProfileParentId(userId)), \"Only system apps can be enabled this way\");\n\n            // Install the app.\n            mIPackageManager.installExistingPackageAsUser(packageName, userId,\n                    PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                    PackageManager.INSTALL_REASON_POLICY, null);\n            if (isDemo) {\n                // Ensure the app is also ENABLED for demo users.\n                mIPackageManager.setApplicationEnabledSetting(packageName,\n                        PackageManager.COMPONENT_ENABLED_STATE_ENABLED,\n                        PackageManager.DONT_KILL_APP, userId, \"DevicePolicyManager\");\n            }\n        } catch (RemoteException re) {\n            // shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Failed to install \" + packageName, re);\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ENABLE_SYSTEM_APP)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ who == null)\n                .setStrings(packageName)\n                .write();\n    }\n\n    @Override\n    public int enableSystemAppWithIntent(ComponentName who, String callerPackage, Intent intent) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_ENABLE_SYSTEM_APP)));\n\n        int numberOfAppsInstalled = 0;\n        long id = mInjector.binderClearCallingIdentity();\n        try {\n            final int parentUserId = getProfileParentId(caller.getUserId());\n            List<ResolveInfo> activitiesToEnable = mIPackageManager\n                    .queryIntentActivities(intent,\n                            intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                            MATCH_DIRECT_BOOT_AWARE\n                                    | MATCH_DIRECT_BOOT_UNAWARE,\n                            parentUserId)\n                    .getList();\n\n            if (VERBOSE_LOG) {\n                Slogf.d(LOG_TAG, \"Enabling system activities: \" + activitiesToEnable);\n            }\n            if (activitiesToEnable != null) {\n                for (ResolveInfo info : activitiesToEnable) {\n                    if (info.activityInfo != null) {\n                        String packageName = info.activityInfo.packageName;\n                        if (isSystemApp(mIPackageManager, packageName, parentUserId)) {\n                            numberOfAppsInstalled++;\n                            mIPackageManager.installExistingPackageAsUser(packageName,\n                                    caller.getUserId(),\n                                    PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                                    PackageManager.INSTALL_REASON_POLICY, null);\n                        } else {\n                            Slogf.d(LOG_TAG, \"Not enabling \" + packageName + \" since is not a\"\n                                    + \" system app\");\n                        }\n                    }\n                }\n            }\n        } catch (RemoteException e) {\n            // shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Failed to resolve intent for: \" + intent, e);\n            return 0;\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ENABLE_SYSTEM_APP_WITH_INTENT)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ who == null)\n                .setStrings(intent.getAction())\n                .write();\n        return numberOfAppsInstalled;\n    }\n\n    private boolean isSystemApp(IPackageManager pm, String packageName, int userId)\n            throws RemoteException {\n        ApplicationInfo appInfo = pm.getApplicationInfo(packageName, MATCH_UNINSTALLED_PACKAGES,\n                userId);\n        if (appInfo == null) {\n            throw new IllegalArgumentException(\"The application \" + packageName +\n                    \" is not present on this device\");\n        }\n        return (appInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;\n    }\n\n    @Override\n    public boolean installExistingPackage(ComponentName who, String callerPackage,\n            String packageName) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage()\n                && isCallerDelegate(caller, DELEGATION_INSTALL_EXISTING_PACKAGE)));\n\n        boolean result;\n        synchronized (getLockObject()) {\n            Preconditions.checkCallAuthorization(\n                    isUserAffiliatedWithDeviceLocked(caller.getUserId()),\n                            \"Admin %s is neither the device owner or \"\n                                    + \"affiliated user's profile owner.\", who);\n            final long id = mInjector.binderClearCallingIdentity();\n            try {\n                if (VERBOSE_LOG) {\n                    Slogf.v(LOG_TAG, \"installing \" + packageName + \" for \" + caller.getUserId());\n                }\n\n                // Install the package.\n                result = mIPackageManager.installExistingPackageAsUser(packageName,\n                        caller.getUserId(),\n                        PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                        PackageManager.INSTALL_REASON_POLICY, null)\n                        == PackageManager.INSTALL_SUCCEEDED;\n            } catch (RemoteException re) {\n                // shouldn't happen\n                Slogf.wtf(LOG_TAG, \"Error installing package\", re);\n                return false;\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n        if (result) {\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.INSTALL_EXISTING_PACKAGE)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ who == null)\n                    .setStrings(packageName)\n                    .write();\n        }\n        return result;\n    }\n\n    @Override\n    public void setAccountManagementDisabled(ComponentName who, String callerPackageName,\n            String accountType, boolean disabled, boolean parent) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        synchronized (getLockObject()) {\n            int affectedUser = getAffectedUser(parent);\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT,\n                    caller.getPackageName(),\n                    affectedUser\n            );\n            if (disabled) {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(accountType),\n                        enforcingAdmin,\n                        new BooleanPolicyValue(disabled),\n                        affectedUser);\n            } else {\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(accountType),\n                        enforcingAdmin,\n                        affectedUser);\n            }\n        }\n    }\n\n    @Override\n    public String[] getAccountTypesWithManagementDisabled(String callerPackageName) {\n        return getAccountTypesWithManagementDisabledAsUser(UserHandle.getCallingUserId(),\n                callerPackageName, false);\n    }\n\n    @Override\n    public String[] getAccountTypesWithManagementDisabledAsUser(int userId,\n            String callerPackageName, boolean parent) {\n        if (!mHasFeature) {\n            return null;\n        }\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n        final ArraySet<String> resultSet = new ArraySet<>();\n        int affectedUser = parent ? getProfileParentId(userId) : userId;\n        if (!hasPermission(MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT,\n                callerPackageName, affectedUser)\n                && !hasFullCrossUsersPermission(caller, userId)) {\n            throw new SecurityException(\"Caller does not have permission to call this on user: \"\n                    + affectedUser);\n        }\n        Set<PolicyKey> keys = mDevicePolicyEngine.getLocalPolicyKeysSetByAllAdmins(\n                PolicyDefinition.GENERIC_ACCOUNT_MANAGEMENT_DISABLED,\n                affectedUser);\n\n        for (PolicyKey key : keys) {\n            if (!(key instanceof AccountTypePolicyKey)) {\n                throw new IllegalStateException(\"PolicyKey for \"\n                        + \"MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT is not of type \"\n                        + \"AccountTypePolicyKey\");\n            }\n            AccountTypePolicyKey parsedKey =\n                    (AccountTypePolicyKey) key;\n            String accountType = Objects.requireNonNull(parsedKey.getAccountType());\n\n            Boolean disabled = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(accountType),\n                    affectedUser);\n            if (disabled != null && disabled) {\n                resultSet.add(accountType);\n            }\n        }\n        return resultSet.toArray(new String[resultSet.size()]);\n    }\n\n    @Override\n    public void setUninstallBlocked(ComponentName who, String callerPackage, String packageName,\n            boolean uninstallBlocked) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n\n        EnforcingAdmin enforcingAdmin = enforcePermissionsAndGetEnforcingAdmin(\n                who,\n                new String[]{\n                        MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                        MANAGE_DEVICE_POLICY_BLOCK_UNINSTALL\n                },\n                caller.getPackageName(),\n                caller.getUserId());\n        mDevicePolicyEngine.setLocalPolicy(\n                PolicyDefinition.PACKAGE_UNINSTALL_BLOCKED(packageName),\n                enforcingAdmin,\n                new BooleanPolicyValue(uninstallBlocked),\n                caller.getUserId());\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_UNINSTALL_BLOCKED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ isCallerDelegate(caller))\n                .setStrings(packageName)\n                .write();\n    }\n\n    static void setUninstallBlockedUnchecked(\n            String packageName, boolean uninstallBlocked, int userId) {\n        Binder.withCleanCallingIdentity(() -> {\n            try {\n                AppGlobals.getPackageManager().setBlockUninstallForUser(\n                        packageName, uninstallBlocked, userId);\n            } catch (RemoteException re) {\n                // Shouldn't happen.\n                Slogf.e(LOG_TAG, \"Failed to setBlockUninstallForUser\", re);\n            }\n        });\n        if (uninstallBlocked) {\n            final PackageManagerInternal pmi = LocalServices.getService(\n                    PackageManagerInternal.class);\n            pmi.removeNonSystemPackageSuspensions(packageName, userId);\n            pmi.removeDistractingPackageRestrictions(packageName, userId);\n            pmi.flushPackageRestrictions(userId);\n        }\n    }\n\n    @Override\n    public boolean isUninstallBlocked(String packageName) {\n        // This function should return true if and only if the package is blocked by\n        // setUninstallBlocked(). It should still return false for other cases of blocks, such as\n        // when the package is a system app, or when it is an active device admin.\n        final int userId = UserHandle.getCallingUserId();\n\n        synchronized (getLockObject()) {\n            try {\n                return mIPackageManager.getBlockUninstallForUser(packageName, userId);\n            } catch (RemoteException re) {\n                // Shouldn't happen.\n                Slogf.e(LOG_TAG, \"Failed to getBlockUninstallForUser\", re);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void setCrossProfileCallerIdDisabled(ComponentName who, boolean disabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (disabled) {\n                admin.mManagedProfileCallerIdAccess =\n                        new PackagePolicy(PackagePolicy.PACKAGE_POLICY_ALLOWLIST);\n            } else {\n                admin.mManagedProfileCallerIdAccess =\n                        new PackagePolicy(PackagePolicy.PACKAGE_POLICY_BLOCKLIST);\n            }\n            saveSettingsLocked(caller.getUserId());\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CROSS_PROFILE_CALLER_ID_DISABLED)\n                .setAdmin(who)\n                .setBoolean(disabled)\n                .write();\n    }\n\n    @Override\n    public boolean getCrossProfileCallerIdDisabled(ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (admin == null) {\n                return false;\n            }\n\n            if (admin.mManagedProfileCallerIdAccess == null) {\n                return admin.disableCallerId;\n            }\n\n            if (admin.mManagedProfileCallerIdAccess.getPolicyType()\n                    == PackagePolicy.PACKAGE_POLICY_ALLOWLIST_AND_SYSTEM) {\n                Slogf.w(LOG_TAG, \"Denying callerId due to PACKAGE_POLICY_SYSTEM policyType\");\n            }\n\n            return admin.mManagedProfileCallerIdAccess.getPolicyType()\n                    != PackagePolicy.PACKAGE_POLICY_BLOCKLIST;\n        }\n    }\n\n    @Override\n    public boolean getCrossProfileCallerIdDisabledForUser(int userId) {\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            if (admin == null) {\n                return false;\n            }\n\n            if (admin.mManagedProfileCallerIdAccess == null) {\n                return admin.disableCallerId;\n            }\n\n            return admin.mManagedProfileCallerIdAccess.getPolicyType()\n                    == PackagePolicy.PACKAGE_POLICY_ALLOWLIST;\n        }\n    }\n\n    @Override\n    public void setManagedProfileCallerIdAccessPolicy(PackagePolicy policy) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId())));\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            admin.disableCallerId = false;\n            admin.mManagedProfileCallerIdAccess = policy;\n            saveSettingsLocked(caller.getUserId());\n        }\n    }\n\n    @Override\n    public PackagePolicy getManagedProfileCallerIdAccessPolicy() {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId())));\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return (admin != null) ? admin.mManagedProfileCallerIdAccess : null;\n        }\n    }\n\n    @Override\n    public boolean hasManagedProfileCallerIdAccess(int userId, String packageName) {\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            if (admin != null) {\n                if (admin.mManagedProfileCallerIdAccess == null) {\n                    return !admin.disableCallerId;\n                }\n                return admin.mManagedProfileCallerIdAccess.isPackageAllowed(packageName,\n                        mContactSystemRoleHolders);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void setManagedProfileContactsAccessPolicy(PackagePolicy policy) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId())));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            admin.disableContactsSearch = false;\n            admin.mManagedProfileContactsAccess = policy;\n            saveSettingsLocked(caller.getUserId());\n        }\n    }\n\n    @Override\n    public PackagePolicy getManagedProfileContactsAccessPolicy() {\n        if (!mHasFeature) {\n            return null;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId())));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return (admin != null) ? admin.mManagedProfileContactsAccess : null;\n        }\n    }\n\n    @Override\n    public boolean hasManagedProfileContactsAccess(int userId, String packageName) {\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            if (admin != null) {\n                if (admin.mManagedProfileContactsAccess == null) {\n                    return !admin.disableContactsSearch;\n                }\n\n                return admin.mManagedProfileContactsAccess.isPackageAllowed(packageName,\n                        mContactSystemRoleHolders);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void setCrossProfileContactsSearchDisabled(ComponentName who, boolean disabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (disabled) {\n                admin.mManagedProfileContactsAccess =\n                        new PackagePolicy(PackagePolicy.PACKAGE_POLICY_ALLOWLIST);\n            } else {\n                admin.mManagedProfileContactsAccess =\n                        new PackagePolicy(PackagePolicy.PACKAGE_POLICY_BLOCKLIST);\n            }\n            saveSettingsLocked(caller.getUserId());\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CROSS_PROFILE_CONTACTS_SEARCH_DISABLED)\n                .setAdmin(who)\n                .setBoolean(disabled)\n                .write();\n    }\n\n    @Override\n    public boolean getCrossProfileContactsSearchDisabled(ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (admin == null) {\n                return false;\n            }\n            if (admin.mManagedProfileContactsAccess == null) {\n                return admin.disableContactsSearch;\n            }\n            return admin.mManagedProfileContactsAccess.getPolicyType()\n                    != PackagePolicy.PACKAGE_POLICY_BLOCKLIST;\n        }\n    }\n\n    @Override\n    public boolean getCrossProfileContactsSearchDisabledForUser(int userId) {\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            if (admin == null) {\n                return false;\n            }\n\n            if (admin.mManagedProfileContactsAccess == null) {\n                return admin.disableContactsSearch;\n            }\n            if (admin.mManagedProfileContactsAccess.getPolicyType()\n                    == PackagePolicy.PACKAGE_POLICY_ALLOWLIST_AND_SYSTEM) {\n                Slogf.w(LOG_TAG, \"Denying contacts due to PACKAGE_POLICY_SYSTEM policyType\");\n            }\n            return admin.mManagedProfileContactsAccess.getPolicyType()\n                    != PackagePolicy.PACKAGE_POLICY_BLOCKLIST;\n        }\n    }\n\n    @Override\n    public void startManagedQuickContact(String actualLookupKey, long actualContactId,\n            boolean isContactIdIgnored, long actualDirectoryId, Intent originalIntent) {\n        final Intent intent = QuickContact.rebuildManagedQuickContactsIntent(actualLookupKey,\n                actualContactId, isContactIdIgnored, actualDirectoryId, originalIntent);\n        final int callingUserId = UserHandle.getCallingUserId();\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            synchronized (getLockObject()) {\n                final int managedUserId = getManagedUserId(callingUserId);\n                if (managedUserId < 0) {\n                    return;\n                }\n                if (isCrossProfileQuickContactDisabled(managedUserId)) {\n                    if (VERBOSE_LOG) {\n                        Slogf.v(LOG_TAG, \"Cross-profile contacts access disabled for user %d\",\n                                managedUserId);\n                    }\n                    return;\n                }\n                ContactsInternal.startQuickContactWithErrorToastForUser(\n                        mContext, intent, new UserHandle(managedUserId));\n            }\n        });\n    }\n\n    /**\n     * @return true if cross-profile QuickContact is disabled\n     */\n    private boolean isCrossProfileQuickContactDisabled(@UserIdInt int userId) {\n        return getCrossProfileCallerIdDisabledForUser(userId)\n                && getCrossProfileContactsSearchDisabledForUser(userId);\n    }\n\n    /**\n     * @return the user ID of the managed user that is linked to the current user, if any.\n     * Otherwise UserHandle.USER_NULL (-10000).\n     */\n    public int getManagedUserId(@UserIdInt int callingUserId) {\n        if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"getManagedUserId: callingUserId=%d\", callingUserId);\n\n        for (UserInfo ui : mUserManager.getProfiles(callingUserId)) {\n            if (ui.id == callingUserId || !ui.isManagedProfile()) {\n                continue; // Caller user self, or not a managed profile.  Skip.\n            }\n            if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"Managed user=%d\", ui.id);\n            return ui.id;\n        }\n        if (VERBOSE_LOG)  Slogf.v(LOG_TAG, \"Managed user not found.\");\n        return UserHandle.USER_NULL;\n    }\n\n    /**\n     * Returns the userId of the managed profile on the device.\n     * If none exists, return {@link UserHandle#USER_NULL}.\n     *\n     * We assume there is only one managed profile across all users\n     * on the device, which is true for now (HSUM or not) but could\n     * change in future.\n     */\n    private @UserIdInt int getManagedUserId() {\n        // On HSUM, there is only one main user and only the main user\n        // can have a managed profile (for now). On non-HSUM, only user 0\n        // can host the managed profile and user 0 is the main user.\n        // So in both cases, we could just get the main user and\n        // search for the profile user under it.\n        UserHandle mainUser = mUserManager.getMainUser();\n        if (mainUser == null) return UserHandle.USER_NULL;\n        return getManagedUserId(mainUser.getIdentifier());\n    }\n\n    @Override\n    public void setBluetoothContactSharingDisabled(ComponentName who, boolean disabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (admin.disableBluetoothContactSharing != disabled) {\n                admin.disableBluetoothContactSharing = disabled;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_BLUETOOTH_CONTACT_SHARING_DISABLED)\n                .setAdmin(who)\n                .setBoolean(disabled)\n                .write();\n    }\n\n    @Override\n    public boolean getBluetoothContactSharingDisabled(ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            return admin.disableBluetoothContactSharing;\n        }\n    }\n\n    @Override\n    public boolean getBluetoothContactSharingDisabledForUser(int userId) {\n        // TODO: Should there be a check to make sure this relationship is\n        // within a profile group?\n        // enforceSystemProcess(\"getCrossProfileCallerIdDisabled can only be called by system\");\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            return (admin != null) ? admin.disableBluetoothContactSharing : false;\n        }\n    }\n\n    private boolean hasActiveSupervisionTestAdminLocked(@UserIdInt int userId) {\n        ensureLocked();\n        if (mConstants.USE_TEST_ADMIN_AS_SUPERVISION_COMPONENT) {\n            final DevicePolicyData policy = getUserData(userId);\n            for (ActiveAdmin admin : policy.mAdminMap.values()) {\n                if (admin != null && admin.testOnlyAdmin) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void setSecondaryLockscreenEnabled(ComponentName who, boolean enabled,\n            PersistableBundle options) {\n        if (Flags.secondaryLockscreenApiEnabled() && mSupervisionManagerInternal != null) {\n            final CallerIdentity caller = getCallerIdentity();\n            final boolean isRoleHolder = isCallerSystemSupervisionRoleHolder(caller);\n            synchronized (getLockObject()) {\n                // TODO(b/378102594): Remove access for test admins.\n                final boolean isTestAdmin = hasActiveSupervisionTestAdminLocked(caller.getUserId());\n                Preconditions.checkCallAuthorization(isRoleHolder || isTestAdmin,\n                        \"Caller (%d) is not the SYSTEM_SUPERVISION role holder\",\n                        caller.getUserId());\n            }\n\n            mSupervisionManagerInternal.setSupervisionLockscreenEnabledForUser(\n                    caller.getUserId(), enabled, options);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n\n            // Check can set secondary lockscreen enabled\n            final CallerIdentity caller = getCallerIdentity(who);\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n            Preconditions.checkCallAuthorization(!isManagedProfile(caller.getUserId()),\n                    \"User %d is not allowed to call setSecondaryLockscreenEnabled\",\n                            caller.getUserId());\n\n            synchronized (getLockObject()) {\n                // Allow testOnly admins to bypass supervision config requirement.\n                Preconditions.checkCallAuthorization(isAdminTestOnlyLocked(who, caller.getUserId())\n                        || isSupervisionComponentLocked(caller.getComponentName()),\n                        \"Admin %s is not the default supervision component\",\n                        caller.getComponentName());\n                DevicePolicyData policy = getUserData(caller.getUserId());\n                policy.mSecondaryLockscreenEnabled = enabled;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public boolean isSecondaryLockscreenEnabled(@NonNull UserHandle userHandle) {\n        if (Flags.secondaryLockscreenApiEnabled() && mSupervisionManagerInternal != null) {\n            return mSupervisionManagerInternal.isSupervisionLockscreenEnabledForUser(\n                    userHandle.getIdentifier());\n        } else {\n            synchronized (getLockObject()) {\n                return getUserData(userHandle.getIdentifier()).mSecondaryLockscreenEnabled;\n            }\n        }\n    }\n\n    private boolean isManagedProfileOwner(CallerIdentity caller) {\n        return isProfileOwner(caller) && isManagedProfile(caller.getUserId());\n    }\n\n    @Override\n    public void setPreferentialNetworkServiceConfigs(\n            List<PreferentialNetworkServiceConfig> preferentialNetworkServiceConfigs) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                        && isManagedProfile(caller.getUserId()))\n                        || isDefaultDeviceOwner(caller),\n                \"Caller is not managed profile owner or device owner;\"\n                        + \" only managed profile owner or device owner may control the preferential\"\n                        + \" network service\");\n\n        try {\n            updateNetworkPreferenceForUser(caller.getUserId(), preferentialNetworkServiceConfigs);\n            synchronized (getLockObject()) {\n                final ActiveAdmin requiredAdmin = getDeviceOrProfileOwnerAdminLocked(\n                        caller.getUserId());\n                if (!requiredAdmin.mPreferentialNetworkServiceConfigs.equals(\n                        preferentialNetworkServiceConfigs)) {\n                    requiredAdmin.mPreferentialNetworkServiceConfigs =\n                            new ArrayList<>(preferentialNetworkServiceConfigs);\n                    saveSettingsLocked(caller.getUserId());\n                }\n            }\n        } catch (Exception e) {\n            Slogf.e(LOG_TAG, \"Failed to set preferential network service configs\");\n            throw e;\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PREFERENTIAL_NETWORK_SERVICE_ENABLED)\n                .setBoolean(preferentialNetworkServiceConfigs\n                        .stream().anyMatch(c -> c.isEnabled()))\n                .write();\n    }\n\n    @Override\n    public List<PreferentialNetworkServiceConfig> getPreferentialNetworkServiceConfigs() {\n        if (!mHasFeature) {\n            return List.of(PreferentialNetworkServiceConfig.DEFAULT);\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                        && isManagedProfile(caller.getUserId()))\n                        || isDefaultDeviceOwner(caller),\n                \"Caller is not managed profile owner or device owner;\"\n                        + \" only managed profile owner or device owner may retrieve the \"\n                        + \"preferential network service configurations\");\n        synchronized (getLockObject()) {\n            final ActiveAdmin requiredAdmin = getDeviceOrProfileOwnerAdminLocked(\n                    caller.getUserId());\n            return requiredAdmin.mPreferentialNetworkServiceConfigs;\n        }\n    }\n\n    @Override\n    public void setLockTaskPackages(ComponentName who, String callerPackageName, String[] packages)\n            throws SecurityException {\n        Objects.requireNonNull(packages, \"packages is null\");\n\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_LOCK_TASK_PACKAGES);\n\n        EnforcingAdmin enforcingAdmin;\n        synchronized (getLockObject()) {\n            enforcingAdmin = enforceCanCallLockTaskLocked(who, caller.getPackageName());\n        }\n        LockTaskPolicy currentPolicy = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                PolicyDefinition.LOCK_TASK,\n                enforcingAdmin,\n                caller.getUserId());\n        LockTaskPolicy policy;\n        if (currentPolicy == null) {\n            policy = new LockTaskPolicy(Set.of(packages));\n        } else {\n            policy = new LockTaskPolicy(currentPolicy);\n            policy.setPackages(Set.of(packages));\n        }\n        if (policy.getPackages().isEmpty()) {\n            mDevicePolicyEngine.removeLocalPolicy(\n                    PolicyDefinition.LOCK_TASK,\n                    enforcingAdmin,\n                    caller.getUserId());\n        } else {\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.LOCK_TASK,\n                    enforcingAdmin,\n                    policy,\n                    caller.getUserId());\n        }\n    }\n\n    @Override\n    public String[] getLockTaskPackages(ComponentName who, String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        final int userHandle = caller.getUserId();\n\n        synchronized (getLockObject()) {\n            enforceCanQueryLockTaskLocked(who, caller.getPackageName());\n        }\n        LockTaskPolicy policy = mDevicePolicyEngine.getResolvedPolicy(\n                PolicyDefinition.LOCK_TASK, userHandle);\n        if (policy == null) {\n            return new String[0];\n        } else {\n            return policy.getPackages().toArray(new String[policy.getPackages().size()]);\n        }\n    }\n\n    @Override\n    public boolean isLockTaskPermitted(String pkg) {\n        // Check policy-exempt apps first, as it doesn't require the lock\n        if (listPolicyExemptAppsUnchecked(mContext).contains(pkg)) {\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"isLockTaskPermitted(%s): returning true for policy-exempt app\",\n                            pkg);\n            }\n            return true;\n        }\n\n        final int userId = mInjector.userHandleGetCallingUserId();\n        LockTaskPolicy policy = mDevicePolicyEngine.getResolvedPolicy(\n                PolicyDefinition.LOCK_TASK, userId);\n        if (policy == null) {\n            return false;\n        }\n        return policy.getPackages().contains(pkg);\n    }\n\n    @Override\n    public void setLockTaskFeatures(ComponentName who, String callerPackageName, int flags) {\n        // Throw if Overview is used without Home.\n        boolean hasHome = (flags & LOCK_TASK_FEATURE_HOME) != 0;\n        boolean hasOverview = (flags & LOCK_TASK_FEATURE_OVERVIEW) != 0;\n        Preconditions.checkArgument(hasHome || !hasOverview,\n                \"Cannot use LOCK_TASK_FEATURE_OVERVIEW without LOCK_TASK_FEATURE_HOME\");\n        boolean hasNotification = (flags & LOCK_TASK_FEATURE_NOTIFICATIONS) != 0;\n        Preconditions.checkArgument(hasHome || !hasNotification,\n            \"Cannot use LOCK_TASK_FEATURE_NOTIFICATIONS without LOCK_TASK_FEATURE_HOME\");\n\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        synchronized (getLockObject()) {\n            checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_LOCK_TASK_FEATURES);\n        }\n\n        EnforcingAdmin enforcingAdmin;\n        synchronized (getLockObject()) {\n            enforcingAdmin = enforceCanCallLockTaskLocked(who, caller.getPackageName());\n            enforceCanSetLockTaskFeaturesOnFinancedDevice(caller, flags);\n        }\n        LockTaskPolicy currentPolicy = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                PolicyDefinition.LOCK_TASK,\n                enforcingAdmin,\n                caller.getUserId());\n        LockTaskPolicy policy;\n        if (currentPolicy == null) {\n            policy = new LockTaskPolicy(flags);\n        } else {\n            policy = new LockTaskPolicy(currentPolicy);\n            policy.setFlags(flags);\n        }\n        if (policy.getPackages().isEmpty()\n                && policy.getFlags() == DevicePolicyManager.LOCK_TASK_FEATURE_NONE) {\n            mDevicePolicyEngine.removeLocalPolicy(\n                    PolicyDefinition.LOCK_TASK,\n                    enforcingAdmin,\n                    caller.getUserId());\n        } else {\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.LOCK_TASK,\n                    enforcingAdmin,\n                    policy,\n                    caller.getUserId());\n        }\n    }\n\n    @Override\n    public int getLockTaskFeatures(ComponentName who, String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        final int userHandle = caller.getUserId();\n\n        synchronized (getLockObject()) {\n            enforceCanQueryLockTaskLocked(who, caller.getPackageName());\n        }\n        LockTaskPolicy policy = mDevicePolicyEngine.getResolvedPolicy(\n                PolicyDefinition.LOCK_TASK, userHandle);\n        if (policy == null) {\n            // We default on the power button menu, in order to be consistent with pre-P\n            // behaviour.\n            return LOCK_TASK_FEATURE_GLOBAL_ACTIONS;\n        }\n        return policy.getFlags();\n    }\n\n    private void maybeClearLockTaskPolicyLocked() {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            final List<UserInfo> userInfos = mUserManager.getAliveUsers();\n            for (int i = userInfos.size() - 1; i >= 0; i--) {\n                int userId = userInfos.get(i).id;\n                if (canDPCManagedUserUseLockTaskLocked(userId)) {\n                    continue;\n                }\n                Map<EnforcingAdmin, PolicyValue<LockTaskPolicy>> policies =\n                        mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                                PolicyDefinition.LOCK_TASK, userId);\n                Set<EnforcingAdmin> admins = new HashSet<>(policies.keySet());\n                for (EnforcingAdmin admin : admins) {\n                    if (admin.hasAuthority(EnforcingAdmin.DPC_AUTHORITY)) {\n                        mDevicePolicyEngine.removeLocalPolicy(\n                                PolicyDefinition.LOCK_TASK, admin, userId);\n                    }\n                }\n            }\n        });\n    }\n\n    private void enforceCanSetLockTaskFeaturesOnFinancedDevice(CallerIdentity caller, int flags) {\n        int allowedFlags = LOCK_TASK_FEATURE_SYSTEM_INFO | LOCK_TASK_FEATURE_KEYGUARD\n                | LOCK_TASK_FEATURE_HOME | LOCK_TASK_FEATURE_GLOBAL_ACTIONS\n                | LOCK_TASK_FEATURE_NOTIFICATIONS | LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK;\n\n        if (!isFinancedDeviceOwner(caller)) {\n            return;\n        }\n\n        if ((flags & ~(allowedFlags)) != 0) {\n            throw new SecurityException(\n                    \"Permitted lock task features when managing a financed device: \"\n                            + \"LOCK_TASK_FEATURE_SYSTEM_INFO, LOCK_TASK_FEATURE_KEYGUARD, \"\n                            + \"LOCK_TASK_FEATURE_HOME, LOCK_TASK_FEATURE_GLOBAL_ACTIONS, \"\n                            + \"LOCK_TASK_FEATURE_NOTIFICATIONS\"\n                            + \" or LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK\");\n        }\n    }\n\n    @Override\n    public void notifyLockTaskModeChanged(boolean isEnabled, String pkg, int userHandle) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"call notifyLockTaskModeChanged\"));\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(userHandle);\n\n            if (policy.mStatusBarDisabled) {\n                // Status bar is managed by LockTaskController during LockTask, so we cancel this\n                // policy when LockTask starts, and reapply it when LockTask ends\n                setStatusBarDisabledInternal(!isEnabled, userHandle);\n            }\n\n            Bundle adminExtras = new Bundle();\n            adminExtras.putString(DeviceAdminReceiver.EXTRA_LOCK_TASK_PACKAGE, pkg);\n            for (ActiveAdmin admin : policy.mAdminList) {\n                final boolean ownsDevice = isDeviceOwner(admin.info.getComponent(), userHandle);\n                final boolean ownsProfile = isProfileOwner(admin.info.getComponent(), userHandle);\n                // TODO(b/281738975): Should we be logging this for all admins?\n                if (ownsDevice || ownsProfile) {\n                    if (isEnabled) {\n                        sendAdminCommandLocked(admin, DeviceAdminReceiver.ACTION_LOCK_TASK_ENTERING,\n                                adminExtras, null);\n                    } else {\n                        sendAdminCommandLocked(admin, DeviceAdminReceiver.ACTION_LOCK_TASK_EXITING);\n                    }\n                    DevicePolicyEventLogger\n                            .createEvent(DevicePolicyEnums.SET_LOCKTASK_MODE_ENABLED)\n                            .setAdmin(admin.info == null ? null : admin.info.getPackageName())\n                            .setBoolean(isEnabled)\n                            .setStrings(pkg)\n                            .write();\n                }\n            }\n        }\n        // TODO(b/281738975): Should we be logging this for all admins?\n        for(EnforcingAdmin admin : mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                PolicyDefinition.LOCK_TASK, userHandle).keySet()) {\n            if (admin.hasAuthority(EnforcingAdmin.DPC_AUTHORITY)) {\n                // already handled above\n                continue;\n            }\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_LOCKTASK_MODE_ENABLED)\n                    .setAdmin(admin.getPackageName())\n                    .setBoolean(isEnabled)\n                    .setStrings(pkg)\n                    .write();\n        }\n    }\n\n    @Override\n    public void setGlobalSetting(ComponentName who, String setting, String value) {\n        final CallerIdentity caller = getCallerIdentity(who);\n        if (Global.ALLOW_WORK_PROFILE_TELEPHONY_FOR_NON_DPM_ROLE_HOLDERS.equals(setting)) {\n            Preconditions.checkCallAuthorization(isCallerDevicePolicyManagementRoleHolder(caller));\n            mInjector.binderWithCleanCallingIdentity(\n                    () -> mInjector.settingsGlobalPutString(setting, value));\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_GLOBAL_SETTING)\n                .setAdmin(who)\n                .setStrings(setting, value)\n                .write();\n\n        synchronized (getLockObject()) {\n            // Some settings are no supported any more. However we do not want to throw a\n            // SecurityException to avoid breaking apps.\n            if (GLOBAL_SETTINGS_DEPRECATED.contains(setting)) {\n                Slogf.i(LOG_TAG, \"Global setting no longer supported: %s\", setting);\n                return;\n            }\n\n            if (!GLOBAL_SETTINGS_ALLOWLIST.contains(setting)\n                    && !UserManager.isDeviceInDemoMode(mContext)) {\n                throw new SecurityException(String.format(\n                        \"Permission denial: device owners cannot update %1$s\", setting));\n            }\n\n            if (Global.STAY_ON_WHILE_PLUGGED_IN.equals(setting)) {\n                // ignore if it contradicts an existing policy\n                long timeMs = getMaximumTimeToLock(\n                        who, mInjector.userHandleGetCallingUserId(), /* parent */ false);\n                if (timeMs > 0 && timeMs < Long.MAX_VALUE) {\n                    return;\n                }\n            }\n\n            mInjector.binderWithCleanCallingIdentity(\n                    () -> mInjector.settingsGlobalPutString(setting, value));\n        }\n    }\n\n    @Override\n    public void setSystemSetting(ComponentName who, String setting, String value, boolean parent) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkStringNotEmpty(setting, \"String setting is null or empty\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        if (parent) {\n            Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_SYSTEM_SETTING);\n\n        synchronized (getLockObject()) {\n            if (!SYSTEM_SETTINGS_ALLOWLIST.contains(setting)) {\n                throw new SecurityException(String.format(\n                        \"Permission denial: device owners cannot update %1$s\", setting));\n            }\n            int affectedUser;\n            if (parent) {\n                affectedUser = getProfileParentId(caller.getUserId());\n            } else {\n                affectedUser = caller.getUserId();\n            }\n            mInjector.binderWithCleanCallingIdentity(() ->\n                    mInjector.settingsSystemPutStringForUser(setting, value, affectedUser));\n        }\n    }\n\n    @Override\n    public void setConfiguredNetworksLockdownState(\n            ComponentName who, String callerPackageName, boolean lockdown) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkNotNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller)\n                        || isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.settingsGlobalPutInt(Global.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN,\n                        lockdown ? 1 : 0));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ALLOW_MODIFICATION_OF_ADMIN_CONFIGURED_NETWORKS)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(lockdown)\n                .write();\n    }\n\n    @Override\n    public boolean hasLockdownAdminConfiguredNetworks(ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkNotNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller)\n                        || isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.settingsGlobalGetInt(Global.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN, 0) > 0);\n    }\n\n    @Override\n    public void setLocationEnabled(ComponentName who, boolean locationEnabled) {\n        Preconditions.checkNotNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        UserHandle userHandle = caller.getUserHandle();\n        if (mIsAutomotive && !locationEnabled) {\n            Slogf.i(LOG_TAG, \"setLocationEnabled(%s, %b): ignoring for user %s on automotive build\",\n                    who.flattenToShortString(), locationEnabled, userHandle);\n            return;\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            boolean wasLocationEnabled = mInjector.getLocationManager().isLocationEnabledForUser(\n                    userHandle);\n            Slogf.v(LOG_TAG, \"calling locationMgr.setLocationEnabledForUser(%b, %s) when it was %b\",\n                    locationEnabled, userHandle, wasLocationEnabled);\n            mInjector.getLocationManager().setLocationEnabledForUser(locationEnabled, userHandle);\n\n            // make a best effort to only show the notification if the admin is actually enabling\n            // location. this is subject to race conditions with settings changes, but those are\n            // unlikely to realistically interfere\n            if (locationEnabled && !wasLocationEnabled) {\n                showLocationSettingsEnabledNotification(userHandle);\n            }\n        });\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SECURE_SETTING)\n                .setAdmin(who)\n                .setStrings(Settings.Secure.LOCATION_MODE, Integer.toString(\n                        locationEnabled ? Settings.Secure.LOCATION_MODE_ON\n                                : Settings.Secure.LOCATION_MODE_OFF))\n                .write();\n    }\n\n    private void showLocationSettingsEnabledNotification(UserHandle user) {\n        Intent intent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS)\n                .addFlags(FLAG_ACTIVITY_NEW_TASK);\n        // Fill the component explicitly to prevent the PendingIntent from being intercepted\n        // and fired with crafted target. b/155183624\n        ActivityInfo targetInfo = intent.resolveActivityInfo(\n                mInjector.getPackageManager(user.getIdentifier()),\n                PackageManager.MATCH_SYSTEM_ONLY);\n        if (targetInfo != null) {\n            intent.setComponent(targetInfo.getComponentName());\n        } else {\n            Slogf.wtf(LOG_TAG, \"Failed to resolve intent for location settings\");\n        }\n\n        // Simple notification clicks are immutable\n        PendingIntent locationSettingsIntent = mInjector.pendingIntentGetActivityAsUser(mContext, 0,\n                intent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE, null,\n                user);\n        Notification notification = new Notification.Builder(mContext,\n                SystemNotificationChannels.DEVICE_ADMIN)\n                .setSmallIcon(R.drawable.ic_info_outline)\n                .setContentTitle(getLocationChangedTitle())\n                .setContentText(getLocationChangedText())\n                .setColor(mContext.getColor(R.color.system_notification_accent_color))\n                .setShowWhen(true)\n                .setContentIntent(locationSettingsIntent)\n                .setAutoCancel(true)\n                .build();\n        mHandler.post(() -> mInjector.getNotificationManager().notify(\n                SystemMessage.NOTE_LOCATION_CHANGED, notification));\n    }\n\n    private String getLocationChangedTitle() {\n        return getUpdatableString(\n                LOCATION_CHANGED_TITLE, R.string.location_changed_notification_title);\n    }\n\n    private String getLocationChangedText() {\n        return getUpdatableString(\n                LOCATION_CHANGED_MESSAGE, R.string.location_changed_notification_text);\n    }\n\n    @Override\n    public boolean setTime(@Nullable ComponentName who, String callerPackageName, long millis) {\n        CallerIdentity caller = getCallerIdentity(who);\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller)\n                        || isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        // Don't allow set time when auto time is on.\n        if (mInjector.settingsGlobalGetInt(Global.AUTO_TIME, 0) == 1) {\n            return false;\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_TIME)\n                .setAdmin(caller.getPackageName())\n                .write();\n        mInjector.binderWithCleanCallingIdentity(() -> mInjector.getAlarmManager().setTime(millis));\n        return true;\n    }\n\n    @Override\n    public boolean setTimeZone(@Nullable ComponentName who, String callerPackageName,\n            String timeZone) {\n        CallerIdentity caller = getCallerIdentity(who);\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller)\n                        || isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        // Don't allow set timezone when auto timezone is on.\n        if (mInjector.settingsGlobalGetInt(Global.AUTO_TIME_ZONE, 0) == 1) {\n            return false;\n        }\n        String logInfo = \"DevicePolicyManager.setTimeZone()\";\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.getAlarmManagerInternal()\n                        .setTimeZone(timeZone, TIME_ZONE_CONFIDENCE_HIGH, logInfo));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_TIME_ZONE)\n                .setAdmin(caller.getPackageName())\n                .write();\n        return true;\n    }\n\n    @Override\n    public void setSecureSetting(ComponentName who, String setting, String value) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        int callingUserId = caller.getUserId();\n        synchronized (getLockObject()) {\n            if (isDeviceOwner(who, callingUserId)) {\n                if (!SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST.contains(setting)\n                        && !isCurrentUserDemo()) {\n                    throw new SecurityException(String.format(\n                            \"Permission denial: Device owners cannot update %1$s\", setting));\n                }\n            } else if (!SECURE_SETTINGS_ALLOWLIST.contains(setting) && !isCurrentUserDemo()) {\n                throw new SecurityException(String.format(\n                        \"Permission denial: Profile owners cannot update %1$s\", setting));\n            }\n            if (setting.equals(Settings.Secure.LOCATION_MODE)\n                    && isSetSecureSettingLocationModeCheckEnabled(who.getPackageName(),\n                    callingUserId)) {\n                throw new UnsupportedOperationException(Settings.Secure.LOCATION_MODE + \" is \"\n                        + \"deprecated. Please use setLocationEnabled() instead.\");\n            }\n            if (setting.equals(Settings.Secure.INSTALL_NON_MARKET_APPS)) {\n                if (getTargetSdk(who.getPackageName(), callingUserId) >= Build.VERSION_CODES.O) {\n                    throw new UnsupportedOperationException(Settings.Secure.INSTALL_NON_MARKET_APPS\n                            + \" is deprecated. Please use one of the user restrictions \"\n                            + UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES + \" or \"\n                            + UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY + \" instead.\");\n                }\n                if (!mUserManager.isManagedProfile(callingUserId)) {\n                    Slogf.e(LOG_TAG, \"Ignoring setSecureSetting request for \"\n                            + setting + \". User restriction \"\n                            + UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES + \" or \"\n                            + UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY\n                            + \" should be used instead.\");\n                } else {\n                    try {\n                        setUserRestriction(who, who.getPackageName(),\n                                UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES,\n                                (Integer.parseInt(value) == 0) ? true : false, /* parent */ false);\n                        DevicePolicyEventLogger\n                                .createEvent(DevicePolicyEnums.SET_SECURE_SETTING)\n                                .setAdmin(who)\n                                .setStrings(setting, value)\n                                .write();\n                    } catch (NumberFormatException exc) {\n                        Slogf.e(LOG_TAG, \"Invalid value: \" + value + \" for setting \" + setting);\n                    }\n                }\n                return;\n            }\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                if (Settings.Secure.DEFAULT_INPUT_METHOD.equals(setting)) {\n                    final String currentValue = mInjector.settingsSecureGetStringForUser(\n                            Settings.Secure.DEFAULT_INPUT_METHOD, callingUserId);\n                    if (!TextUtils.equals(currentValue, value)) {\n                        // Tell the content observer that the next change will be due to the owner\n                        // changing the value. There is a small race condition here that we cannot\n                        // avoid: Change notifications are sent asynchronously, so it is possible\n                        // that there are prior notifications queued up before the one we are about\n                        // to trigger. This is a corner case that will have no impact in practice.\n                        mSetupContentObserver.addPendingChangeByOwnerLocked(callingUserId);\n                    }\n                    getUserData(callingUserId).mCurrentInputMethodSet = true;\n                    saveSettingsLocked(callingUserId);\n                }\n                mInjector.settingsSecurePutStringForUser(setting, value, callingUserId);\n                // Notify the user if it's the location mode setting that's been set, to any value\n                // other than 'off'.\n                if (setting.equals(Settings.Secure.LOCATION_MODE)\n                        && (Integer.parseInt(value) != 0)) {\n                    showLocationSettingsEnabledNotification(UserHandle.of(callingUserId));\n                }\n            });\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SECURE_SETTING)\n                .setAdmin(who)\n                .setStrings(setting, value)\n                .write();\n    }\n\n    private boolean isSetSecureSettingLocationModeCheckEnabled(String packageName, int userId) {\n        return mInjector.isChangeEnabled(USE_SET_LOCATION_ENABLED, packageName, userId);\n    }\n\n    @Override\n    public void setMasterVolumeMuted(ComponentName who, boolean on) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_MASTER_VOLUME_MUTED);\n\n        synchronized (getLockObject()) {\n            setUserRestriction(who, who.getPackageName(), UserManager.DISALLOW_UNMUTE_DEVICE, on,\n                    /* parent */ false);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_MASTER_VOLUME_MUTED)\n                    .setAdmin(who)\n                    .setBoolean(on)\n                    .write();\n        }\n    }\n\n    @Override\n    public boolean isMasterVolumeMuted(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            AudioManager audioManager =\n                    (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);\n            return audioManager.isMasterMute();\n        }\n    }\n\n    @Override\n    public void setUserIcon(ComponentName who, Bitmap icon) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            mInjector.binderWithCleanCallingIdentity(\n                    () -> mUserManagerInternal.setUserIcon(caller.getUserId(), icon));\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_USER_ICON)\n                .setAdmin(who)\n                .write();\n    }\n\n    @Override\n    public boolean setKeyguardDisabled(ComponentName who, boolean disabled) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        final int userId = caller.getUserId();\n        synchronized (getLockObject()) {\n            Preconditions.checkCallAuthorization(isUserAffiliatedWithDeviceLocked(userId),\n                    String.format(\n                            \"Admin %s is neither the device owner or affiliated user's profile \"\n                                    + \"owner.\", who));\n        }\n        if (isManagedProfile(userId)) {\n            throw new SecurityException(\"Managed profile cannot disable keyguard\");\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_KEYGUARD_DISABLED);\n\n        long ident = mInjector.binderClearCallingIdentity();\n        try {\n            // disallow disabling the keyguard if a password is currently set\n            if (disabled && mLockPatternUtils.isSecure(userId)) {\n                return false;\n            }\n            mLockPatternUtils.setLockScreenDisabled(disabled, userId);\n            if (disabled) {\n                mInjector\n                        .getIWindowManager()\n                        .dismissKeyguard(null /* callback */, null /* message */);\n            }\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_KEYGUARD_DISABLED)\n                    .setAdmin(who)\n                    .setBoolean(disabled)\n                    .write();\n        } catch (RemoteException e) {\n            // Same process, does not happen.\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n        return true;\n    }\n\n    @Override\n    public boolean setStatusBarDisabled(ComponentName who, String callerPackageName,\n            boolean disabled) {\n        CallerIdentity caller;\n        if (isSetStatusBarDisabledCoexistenceEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        if (isSetStatusBarDisabledCoexistenceEnabled()) {\n            enforcePermission(MANAGE_DEVICE_POLICY_STATUS_BAR, caller.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        }\n\n        int userId = caller.getUserId();\n        synchronized (getLockObject()) {\n            if (!isSetStatusBarDisabledCoexistenceEnabled()) {\n                Preconditions.checkCallAuthorization(isUserAffiliatedWithDeviceLocked(userId),\n                        \"Admin \" + who + \" is neither the device owner or affiliated \"\n                                + \"user's profile owner.\");\n                if (isManagedProfile(userId)) {\n                    throw new SecurityException(\"Managed profile cannot disable status bar\");\n                }\n            }\n            checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_STATUS_BAR_DISABLED);\n\n            DevicePolicyData policy = getUserData(userId);\n            if (policy.mStatusBarDisabled != disabled) {\n                boolean isLockTaskMode = false;\n                try {\n                    isLockTaskMode = mInjector.getIActivityTaskManager().getLockTaskModeState()\n                            != LOCK_TASK_MODE_NONE;\n                } catch (RemoteException e) {\n                    Slogf.e(LOG_TAG, \"Failed to get LockTask mode\");\n                }\n                if (!isLockTaskMode) {\n                    if (!setStatusBarDisabledInternal(disabled, userId)) {\n                        return false;\n                    }\n                }\n                policy.mStatusBarDisabled = disabled;\n                saveSettingsLocked(userId);\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_STATUS_BAR_DISABLED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(disabled)\n                .write();\n        return true;\n    }\n\n    private boolean setStatusBarDisabledInternal(boolean disabled, int userId) {\n        long ident = mInjector.binderClearCallingIdentity();\n        try {\n            IStatusBarService statusBarService = IStatusBarService.Stub.asInterface(\n                    ServiceManager.checkService(Context.STATUS_BAR_SERVICE));\n            if (statusBarService != null) {\n                int flags1 = disabled ? STATUS_BAR_DISABLE_MASK : StatusBarManager.DISABLE_NONE;\n                int flags2 = disabled ? STATUS_BAR_DISABLE2_MASK : StatusBarManager.DISABLE2_NONE;\n                statusBarService.disableForUser(flags1, mToken, mContext.getPackageName(), userId);\n                statusBarService.disable2ForUser(flags2, mToken, mContext.getPackageName(), userId);\n                return true;\n            }\n        } catch (RemoteException e) {\n            Slogf.e(LOG_TAG, \"Failed to disable the status bar\", e);\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n        return false;\n    }\n\n    @Override\n    public boolean isStatusBarDisabled(String callerPackage) {\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        if (isSetStatusBarDisabledCoexistenceEnabled()) {\n            enforceCanQuery(\n                    MANAGE_DEVICE_POLICY_STATUS_BAR, caller.getPackageName(), caller.getUserId());\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        }\n\n        int userId = caller.getUserId();\n        synchronized (getLockObject()) {\n            if (!isSetStatusBarDisabledCoexistenceEnabled()) {\n                Preconditions.checkCallAuthorization(isUserAffiliatedWithDeviceLocked(userId),\n                        \"Admin \" + callerPackage\n                                + \" is neither the device owner or affiliated user's profile owner.\");\n                if (isManagedProfile(userId)) {\n                    throw new SecurityException(\"Managed profile cannot disable status bar\");\n                }\n            }\n            DevicePolicyData policy = getUserData(userId);\n            return policy.mStatusBarDisabled;\n        }\n    }\n\n    /**\n     * We need to update the internal state of whether a user has completed setup or a\n     * device has paired once. After that, we ignore any changes that reset the\n     * Settings.Secure.USER_SETUP_COMPLETE or Settings.Secure.DEVICE_PAIRED change\n     * as we don't trust any apps that might try to reset them.\n     * <p>\n     * Unfortunately, we don't know which user's setup state was changed, so we write all of\n     * them.\n     */\n    void updateUserSetupCompleteAndPaired() {\n        List<UserInfo> users = mUserManager.getAliveUsers();\n        final int N = users.size();\n        for (int i = 0; i < N; i++) {\n            int userHandle = users.get(i).id;\n            if (mInjector.settingsSecureGetIntForUser(USER_SETUP_COMPLETE, 0,\n                    userHandle) != 0) {\n                DevicePolicyData policy = getUserData(userHandle);\n                if (!policy.mUserSetupComplete) {\n                    policy.mUserSetupComplete = true;\n                    if (userHandle == UserHandle.USER_SYSTEM) {\n                        mStateCache.setDeviceProvisioned(true);\n                    }\n                    synchronized (getLockObject()) {\n                        saveSettingsLocked(userHandle);\n                    }\n                }\n            }\n            if (mIsWatch && mInjector.settingsSecureGetIntForUser(Settings.Secure.DEVICE_PAIRED, 0,\n                    userHandle) != 0) {\n                DevicePolicyData policy = getUserData(userHandle);\n                if (!policy.mPaired) {\n                    policy.mPaired = true;\n                    synchronized (getLockObject()) {\n                        saveSettingsLocked(userHandle);\n                    }\n                }\n            }\n        }\n    }\n\n    private class SetupContentObserver extends ContentObserver {\n        private final Uri mUserSetupComplete = Settings.Secure.getUriFor(\n                USER_SETUP_COMPLETE);\n        private final Uri mPaired = Settings.Secure.getUriFor(Settings.Secure.DEVICE_PAIRED);\n        private final Uri mDefaultImeChanged = Settings.Secure.getUriFor(\n                Settings.Secure.DEFAULT_INPUT_METHOD);\n\n        @GuardedBy(\"getLockObject()\")\n        private Set<Integer> mUserIdsWithPendingChangesByOwner = new ArraySet<>();\n\n        public SetupContentObserver(Handler handler) {\n            super(handler);\n        }\n\n        void register() {\n            mInjector.registerContentObserver(mUserSetupComplete, false, this, UserHandle.USER_ALL);\n            if (mIsWatch) {\n                mInjector.registerContentObserver(mPaired, false, this, UserHandle.USER_ALL);\n            }\n            mInjector.registerContentObserver(mDefaultImeChanged, false, this, UserHandle.USER_ALL);\n        }\n\n        @GuardedBy(\"getLockObject()\")\n        private void addPendingChangeByOwnerLocked(int userId) {\n            mUserIdsWithPendingChangesByOwner.add(userId);\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri, int userId) {\n            if (mUserSetupComplete.equals(uri) || (mIsWatch && mPaired.equals(uri))) {\n                updateUserSetupCompleteAndPaired();\n            } else if (mDefaultImeChanged.equals(uri)) {\n                synchronized (getLockObject()) {\n                    if (mUserIdsWithPendingChangesByOwner.contains(userId)) {\n                        // This change notification was triggered by the owner changing the current\n                        // IME. Ignore it.\n                        mUserIdsWithPendingChangesByOwner.remove(userId);\n                    } else {\n                        // This change notification was triggered by the user manually changing the\n                        // current IME.\n                        getUserData(userId).mCurrentInputMethodSet = false;\n                        saveSettingsLocked(userId);\n                    }\n                }\n            }\n        }\n    }\n\n    private class DevicePolicyConstantsObserver extends ContentObserver {\n        final Uri mConstantsUri =\n                Global.getUriFor(Global.DEVICE_POLICY_CONSTANTS);\n\n        DevicePolicyConstantsObserver(Handler handler) {\n            super(handler);\n        }\n\n        void register() {\n            mInjector.registerContentObserver(\n                    mConstantsUri, /* notifyForDescendents= */ false, this, UserHandle.USER_ALL);\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri, int userId) {\n            mConstants = loadConstants();\n            invalidateBinderCaches();\n\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                final Intent intent = new Intent(\n                        DevicePolicyManager.ACTION_DEVICE_POLICY_CONSTANTS_CHANGED);\n                intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n                final List<UserInfo> users = mUserManager.getAliveUsers();\n                for (int i = 0; i < users.size(); i++) {\n                    mContext.sendBroadcastAsUser(intent, UserHandle.of(users.get(i).id));\n                }\n            });\n        }\n    }\n\n    @VisibleForTesting\n    final class LocalService extends DevicePolicyManagerInternal\n            implements DevicePolicyManagerLiteInternal {\n        private List<OnCrossProfileWidgetProvidersChangeListener> mWidgetProviderListeners;\n\n        @Override\n        public List<String> getCrossProfileWidgetProviders(int profileId) {\n            synchronized (getLockObject()) {\n                if (mOwners == null) {\n                    return Collections.emptyList();\n                }\n                ComponentName ownerComponent = mOwners.getProfileOwnerComponent(profileId);\n                if (ownerComponent == null) {\n                    return Collections.emptyList();\n                }\n\n                DevicePolicyData policy = getUserDataUnchecked(profileId);\n                ActiveAdmin admin = policy.mAdminMap.get(ownerComponent);\n\n                if (admin == null || admin.crossProfileWidgetProviders == null\n                        || admin.crossProfileWidgetProviders.isEmpty()) {\n                    return Collections.emptyList();\n                }\n\n                return admin.crossProfileWidgetProviders;\n            }\n        }\n\n        @Override\n        public void addOnCrossProfileWidgetProvidersChangeListener(\n                OnCrossProfileWidgetProvidersChangeListener listener) {\n            synchronized (getLockObject()) {\n                if (mWidgetProviderListeners == null) {\n                    mWidgetProviderListeners = new ArrayList<>();\n                }\n                if (!mWidgetProviderListeners.contains(listener)) {\n                    mWidgetProviderListeners.add(listener);\n                }\n            }\n        }\n\n        @Override\n        public @Nullable ComponentName getProfileOwnerOrDeviceOwnerSupervisionComponent(\n                @NonNull UserHandle userHandle) {\n            return DevicePolicyManagerService.this.getProfileOwnerOrDeviceOwnerSupervisionComponent(\n                    userHandle);\n        }\n\n        @Override\n        public boolean isActiveDeviceOwner(int uid) {\n            return isDefaultDeviceOwner(new CallerIdentity(uid, null, null));\n        }\n\n        @Override\n        public boolean isActiveProfileOwner(int uid) {\n            return isProfileOwner(new CallerIdentity(uid, null, null));\n        }\n\n        @Override\n        public boolean isActiveSupervisionApp(int uid) {\n            if (!isProfileOwner(new CallerIdentity(uid, null, null))) {\n                return false;\n            }\n            synchronized (getLockObject()) {\n                final ActiveAdmin admin = getProfileOwnerAdminLocked(UserHandle.getUserId(uid));\n                if (admin == null) {\n                    return false;\n                }\n\n                return isSupervisionComponentLocked(admin.info.getComponent());\n            }\n        }\n\n        private void notifyCrossProfileProvidersChanged(int userId, List<String> packages) {\n            final List<OnCrossProfileWidgetProvidersChangeListener> listeners;\n            synchronized (getLockObject()) {\n                listeners = new ArrayList<>(mWidgetProviderListeners);\n            }\n            final int listenerCount = listeners.size();\n            for (int i = 0; i < listenerCount; i++) {\n                OnCrossProfileWidgetProvidersChangeListener listener = listeners.get(i);\n                listener.onCrossProfileWidgetProvidersChanged(userId, packages);\n            }\n        }\n\n        @Override\n        public Intent createShowAdminSupportIntent(int userId, boolean useDefaultIfNoAdmin) {\n            // This method is called from AM with its lock held, so don't take the DPMS lock.\n            // b/29242568\n\n            if (getEnforcingAdminAndUserDetailsInternal(userId, null) != null\n                    || useDefaultIfNoAdmin) {\n                return DevicePolicyManagerService.this.createShowAdminSupportIntent(userId);\n            }\n            return null;\n        }\n\n        @Override\n        public Intent createUserRestrictionSupportIntent(int userId, String userRestriction) {\n            Intent intent = null;\n            if (getEnforcingAdminAndUserDetailsInternal(userId, userRestriction) != null) {\n                intent = DevicePolicyManagerService.this.createShowAdminSupportIntent(userId);\n                intent.putExtra(DevicePolicyManager.EXTRA_RESTRICTION, userRestriction);\n            }\n            return intent;\n        }\n\n        @Override\n        public boolean isUserAffiliatedWithDevice(int userId) {\n            return DevicePolicyManagerService.this.isUserAffiliatedWithDeviceLocked(userId);\n        }\n\n        @Override\n        public boolean canSilentlyInstallPackage(String callerPackage, int callerUid) {\n            if (callerPackage == null) {\n                return false;\n            }\n\n            CallerIdentity caller = new CallerIdentity(callerUid, null, null);\n            if (isUserAffiliatedWithDevice(UserHandle.getUserId(callerUid))\n                    && (isActiveProfileOwner(callerUid)\n                    || isDefaultDeviceOwner(caller) || isFinancedDeviceOwner(caller))) {\n                // device owner or a profile owner affiliated with the device owner\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void reportSeparateProfileChallengeChanged(@UserIdInt int userId) {\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                synchronized (getLockObject()) {\n                    updateMaximumTimeToLockLocked(userId);\n                    updatePasswordQualityCacheForUserGroup(userId);\n                }\n            });\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SEPARATE_PROFILE_CHALLENGE_CHANGED)\n                    .setBoolean(isSeparateProfileChallengeEnabled(userId))\n                    .write();\n            invalidateBinderCaches();\n        }\n\n        @Override\n        public CharSequence getPrintingDisabledReasonForUser(@UserIdInt int userId) {\n            synchronized (getLockObject()) {\n                if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_PRINTING,\n                        UserHandle.of(userId))) {\n                    Slogf.e(LOG_TAG, \"printing is enabled for user %d\", userId);\n                    return null;\n                }\n                String ownerPackage = mOwners.getProfileOwnerPackage(userId);\n                if (ownerPackage == null) {\n                    ownerPackage = mOwners.getDeviceOwnerPackageName();\n                }\n                final String packageName = ownerPackage;\n                PackageManager pm = mInjector.getPackageManager();\n                PackageInfo packageInfo = mInjector.binderWithCleanCallingIdentity(() -> {\n                    try {\n                        return pm.getPackageInfo(packageName, 0);\n                    } catch (NameNotFoundException e) {\n                        Slogf.e(LOG_TAG, \"getPackageInfo error\", e);\n                        return null;\n                    }\n                });\n                if (packageInfo == null) {\n                    Slogf.e(LOG_TAG, \"packageInfo is inexplicably null\");\n                    return null;\n                }\n                ApplicationInfo appInfo = packageInfo.applicationInfo;\n                if (appInfo == null) {\n                    Slogf.e(LOG_TAG, \"appInfo is inexplicably null\");\n                    return null;\n                }\n                CharSequence appLabel = pm.getApplicationLabel(appInfo);\n                if (appLabel == null) {\n                    Slogf.e(LOG_TAG, \"appLabel is inexplicably null\");\n                    return null;\n                }\n                return getUpdatableString(\n                        PRINTING_DISABLED_NAMED_ADMIN,\n                        R.string.printing_disabled_by,\n                        appLabel);\n            }\n        }\n\n        @Override\n        protected DevicePolicyCache getDevicePolicyCache() {\n            return mPolicyCache;\n        }\n\n        @Override\n        protected DeviceStateCache getDeviceStateCache() {\n            return mStateCache;\n        }\n\n        @Override\n        public List<String> getAllCrossProfilePackages(int userId) {\n            return DevicePolicyManagerService.this.getAllCrossProfilePackages(userId);\n        }\n\n        @Override\n        public List<String> getDefaultCrossProfilePackages() {\n            return DevicePolicyManagerService.this.getDefaultCrossProfilePackages();\n        }\n\n        @Override\n        public void broadcastIntentToManifestReceivers(\n                Intent intent, UserHandle parentHandle, boolean requiresPermission) {\n            Objects.requireNonNull(intent);\n            Objects.requireNonNull(parentHandle);\n            Slogf.i(LOG_TAG, \"Sending %s broadcast to manifest receivers.\", intent.getAction());\n            broadcastIntentToCrossProfileManifestReceivers(\n                    intent, parentHandle, requiresPermission);\n            broadcastExplicitIntentToRoleHolder(\n                    intent, RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT, parentHandle);\n        }\n\n        @Override\n        public void enforcePermission(String callerPackage, String permission, int targetUserId) {\n            DevicePolicyManagerService.this.enforcePermission(permission, callerPackage,\n                    targetUserId);\n        }\n\n        @Override\n        public boolean hasPermission(String callerPackage, String permission, int targetUserId) {\n            return DevicePolicyManagerService.this.hasPermission(permission, callerPackage,\n                    targetUserId);\n        }\n\n        private void broadcastIntentToCrossProfileManifestReceivers(\n                Intent intent, UserHandle userHandle, boolean requiresPermission) {\n            final int userId = userHandle.getIdentifier();\n            try {\n                final List<ResolveInfo> receivers = mIPackageManager.queryIntentReceivers(\n                        intent, /* resolvedType= */ null,\n                        STOCK_PM_FLAGS, userId).getList();\n                for (ResolveInfo receiver : receivers) {\n                    final String packageName = receiver.getComponentInfo().packageName;\n                    if (checkCrossProfilePackagePermissions(packageName, userId,\n                            requiresPermission)\n                            || checkModifyQuietModePermission(packageName, userId)) {\n                        Slogf.i(LOG_TAG, \"Sending %s broadcast to %s.\", intent.getAction(),\n                                packageName);\n                        final Intent packageIntent = new Intent(intent)\n                                .setComponent(receiver.getComponentInfo().getComponentName())\n                                .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n                        mContext.sendBroadcastAsUser(packageIntent, userHandle);\n                    }\n                }\n            } catch (RemoteException ex) {\n                Slogf.w(LOG_TAG, \"Cannot get list of broadcast receivers for %s because: %s.\",\n                        intent.getAction(), ex);\n            }\n        }\n\n        /**\n         * Checks whether the package {@code packageName} has the {@code MODIFY_QUIET_MODE}\n         * permission granted for the user {@code userId}.\n         */\n        private boolean checkModifyQuietModePermission(String packageName, @UserIdInt int userId) {\n            try {\n                final int uid = Objects.requireNonNull(\n                        mInjector.getPackageManager().getApplicationInfoAsUser(\n                                Objects.requireNonNull(packageName), /* flags= */ 0, userId)).uid;\n                return PERMISSION_GRANTED\n                        == ActivityManager.checkComponentPermission(\n                        permission.MODIFY_QUIET_MODE, uid, /* owningUid= */\n                        -1, /* exported= */ true);\n            } catch (NameNotFoundException ex) {\n                Slogf.w(LOG_TAG, \"Cannot find the package %s to check for permissions.\",\n                        packageName);\n                return false;\n            }\n        }\n\n        /**\n         * Checks whether the package {@code packageName} has the required permissions to receive\n         * cross-profile broadcasts on behalf of the user {@code userId}.\n         */\n        private boolean checkCrossProfilePackagePermissions(String packageName,\n                @UserIdInt int userId, boolean requiresPermission) {\n            final PackageManagerInternal pmInternal = LocalServices.getService(\n                    PackageManagerInternal.class);\n            final AndroidPackage androidPackage = pmInternal.getPackage(packageName);\n            if (androidPackage == null || !androidPackage.isCrossProfile()) {\n                return false;\n            }\n            if (!requiresPermission) {\n                return true;\n            }\n            if (!isPackageEnabled(packageName, userId)) {\n                return false;\n            }\n            try {\n                final CrossProfileAppsInternal crossProfileAppsService = LocalServices.getService(\n                        CrossProfileAppsInternal.class);\n                return crossProfileAppsService.verifyPackageHasInteractAcrossProfilePermission(\n                        packageName, userId);\n            } catch (NameNotFoundException ex) {\n                Slogf.w(LOG_TAG, \"Cannot find the package %s to check for permissions.\",\n                        packageName);\n                return false;\n            }\n        }\n\n        private boolean isPackageEnabled(String packageName, @UserIdInt int userId) {\n            final int callingUid = Binder.getCallingUid();\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                final PackageInfo info = mInjector.getPackageManagerInternal()\n                        .getPackageInfo(\n                                packageName,\n                                MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE,\n                                callingUid,\n                                userId);\n                return info != null && info.applicationInfo.enabled;\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n\n        @Override\n        public ComponentName getProfileOwnerAsUser(@UserIdInt int userId) {\n            return DevicePolicyManagerService.this.getProfileOwnerAsUser(userId);\n        }\n\n        @Override\n        public ComponentName getDeviceOwnerComponent(boolean callingUserOnly) {\n            return DevicePolicyManagerService.this.getDeviceOwnerComponent(callingUserOnly);\n        }\n\n        @Override\n        public int getDeviceOwnerUserId() {\n            return DevicePolicyManagerService.this.getDeviceOwnerUserId();\n        }\n\n        @Override\n        public boolean isDeviceOrProfileOwnerInCallingUser(String packageName) {\n            return isDeviceOwnerInCallingUser(packageName)\n                    || isProfileOwnerInCallingUser(packageName);\n        }\n\n        private boolean isDeviceOwnerInCallingUser(String packageName) {\n            final ComponentName deviceOwnerInCallingUser =\n                    DevicePolicyManagerService.this.getDeviceOwnerComponent(\n                            /* callingUserOnly= */ true);\n            return deviceOwnerInCallingUser != null\n                    && packageName.equals(deviceOwnerInCallingUser.getPackageName());\n        }\n\n        private boolean isProfileOwnerInCallingUser(String packageName) {\n            final ComponentName profileOwnerInCallingUser =\n                    getProfileOwnerAsUser(UserHandle.getCallingUserId());\n            return profileOwnerInCallingUser != null\n                    && packageName.equals(profileOwnerInCallingUser.getPackageName());\n        }\n\n        @Override\n        public boolean supportsResetOp(int op) {\n            return op == AppOpsManager.OP_INTERACT_ACROSS_PROFILES\n                    && LocalServices.getService(CrossProfileAppsInternal.class) != null;\n        }\n\n        @Override\n        public void resetOp(int op, String packageName, @UserIdInt int userId) {\n            if (op != AppOpsManager.OP_INTERACT_ACROSS_PROFILES) {\n                throw new IllegalArgumentException(\"Unsupported op for DPM reset: \" + op);\n            }\n            LocalServices.getService(CrossProfileAppsInternal.class)\n                    .setInteractAcrossProfilesAppOp(\n                            packageName, findInteractAcrossProfilesResetMode(packageName), userId);\n        }\n\n        @Override\n        public void notifyUnsafeOperationStateChanged(DevicePolicySafetyChecker checker, int reason,\n                boolean isSafe) {\n            // TODO(b/178494483): use EventLog instead\n            // TODO(b/178494483): log metrics?\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"notifyUnsafeOperationStateChanged(): %s=%b\",\n                        DevicePolicyManager.operationSafetyReasonToString(reason), isSafe);\n            }\n            Preconditions.checkArgument(mSafetyChecker == checker,\n                    \"invalid checker: should be %s, was %s\", mSafetyChecker, checker);\n\n            Bundle extras = new Bundle();\n            extras.putInt(DeviceAdminReceiver.EXTRA_OPERATION_SAFETY_REASON, reason);\n            extras.putBoolean(DeviceAdminReceiver.EXTRA_OPERATION_SAFETY_STATE, isSafe);\n\n            if (mOwners.hasDeviceOwner()) {\n                if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"Notifying DO\");\n                sendDeviceOwnerCommand(DeviceAdminReceiver.ACTION_OPERATION_SAFETY_STATE_CHANGED,\n                        extras);\n            }\n            for (int profileOwnerId : mOwners.getProfileOwnerKeys()) {\n                if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"Notifying PO for user \" + profileOwnerId);\n                sendProfileOwnerCommand(DeviceAdminReceiver.ACTION_OPERATION_SAFETY_STATE_CHANGED,\n                        extras, profileOwnerId);\n            }\n        }\n\n        private @Mode int findInteractAcrossProfilesResetMode(String packageName) {\n            return getDefaultCrossProfilePackages().contains(packageName)\n                    ? MODE_ALLOWED\n                    : AppOpsManager.opToDefaultMode(AppOpsManager.OP_INTERACT_ACROSS_PROFILES);\n        }\n\n        @Override\n        public boolean isUserOrganizationManaged(@UserIdInt int userHandle) {\n            return getDeviceStateCache().isUserOrganizationManaged(userHandle);\n        }\n\n        @Override\n        public List<Bundle> getApplicationRestrictionsPerAdminForUser(\n                String packageName, @UserIdInt int userId) {\n            if (UserHandle.getCallingUserId() != userId\n                    || !UserHandle.isSameApp(\n                    Binder.getCallingUid(), getUidForPackage(packageName, userId))) {\n                final int uid = Binder.getCallingUid();\n                if (!UserHandle.isSameApp(uid, Process.SYSTEM_UID) && uid != Process.ROOT_UID) {\n                    throw new SecurityException(\"Only system may: get application restrictions for \"\n                            + \"other user/app \" + packageName);\n                }\n            }\n            LinkedHashMap<EnforcingAdmin, PolicyValue<Bundle>> policies =\n                    mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                            PolicyDefinition.APPLICATION_RESTRICTIONS(packageName),\n                            userId);\n            List<Bundle> restrictions = new ArrayList<>();\n            for (PolicyValue<Bundle> policyValue: policies.values()) {\n                Bundle value = policyValue.getValue();\n                // Probably not necessary since setApplicationRestrictions only sets non-empty\n                // Bundle, but just in case.\n                if (value != null && !value.isEmpty()) {\n                    restrictions.add(value);\n                }\n            }\n\n            return mInjector.binderWithCleanCallingIdentity(() -> {\n                // Could be a device that has a DPC that hasn't migrated yet, so also return any\n                // restrictions saved in userManager.\n                Bundle bundle = mUserManager.getApplicationRestrictions(\n                        packageName, UserHandle.of(userId));\n                if (bundle != null && !bundle.isEmpty()) {\n                    restrictions.add(bundle);\n                }\n                return restrictions;\n            });\n        }\n\n        public List<EnforcingUser> getUserRestrictionSources(String restriction,\n                @UserIdInt int userId) {\n            PolicyDefinition<Boolean> policy =\n                    PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction);\n\n            Set<EnforcingAdmin> localAdmins =\n                    mDevicePolicyEngine.getLocalPoliciesSetByAdmins(policy, userId).keySet();\n\n            Set<EnforcingAdmin> globalAdmins =\n                    mDevicePolicyEngine.getGlobalPoliciesSetByAdmins(policy).keySet();\n\n            List<EnforcingUser> enforcingUsers = new ArrayList();\n            enforcingUsers.addAll(getEnforcingUsers(localAdmins));\n            enforcingUsers.addAll(getEnforcingUsers(globalAdmins));\n            return enforcingUsers;\n        }\n\n        @Override\n        public void enforceSecurityLoggingPolicy(boolean enabled) {\n            Boolean auditLoggingEnabled = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.AUDIT_LOGGING, UserHandle.USER_ALL);\n            enforceLoggingPolicy(enabled, Boolean.TRUE.equals(auditLoggingEnabled));\n        }\n\n        @Override\n        public void enforceAuditLoggingPolicy(boolean enabled) {\n            Boolean securityLoggingEnabled = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.SECURITY_LOGGING, UserHandle.USER_ALL);\n            enforceLoggingPolicy(Boolean.TRUE.equals(securityLoggingEnabled), enabled);\n        }\n\n        @Override\n        public void setInternalEventsCallback(\n                @Nullable Consumer<List<SecurityEvent>> callback) {\n            mSecurityLogMonitor.setInternalEventsCallback(callback);\n        }\n\n        private List<EnforcingUser> getEnforcingUsers(Set<EnforcingAdmin> admins) {\n            List<EnforcingUser> enforcingUsers = new ArrayList();\n            ComponentName deviceOwner = mOwners.getDeviceOwnerComponent();\n            for (EnforcingAdmin admin : admins) {\n                if (deviceOwner != null\n                        && deviceOwner.getPackageName().equals(admin.getPackageName())) {\n                    enforcingUsers.add(new EnforcingUser(admin.getUserId(),\n                            UserManager.RESTRICTION_SOURCE_DEVICE_OWNER));\n                } else {\n                    enforcingUsers.add(new EnforcingUser(admin.getUserId(),\n                            UserManager.RESTRICTION_SOURCE_PROFILE_OWNER));\n                }\n            }\n            return enforcingUsers;\n        }\n    }\n\n    private void enforceLoggingPolicy(\n            boolean securityLogEnabled, boolean auditLogEnabled) {\n        Slogf.i(LOG_TAG, \"Enforcing logging policy, security: %b audit: %b\",\n                securityLogEnabled, auditLogEnabled);\n        mInjector.securityLogSetLoggingEnabledProperty(securityLogEnabled || auditLogEnabled);\n        setLoggingConfiguration(securityLogEnabled, auditLogEnabled);\n    }\n\n    private void setLoggingConfiguration(\n            boolean securityLoggingEnabled, boolean auditLoggingEnabled) {\n        final int loggingEnabledUser = getSecurityLoggingEnabledUser();\n        mSecurityLogMonitor.setLoggingParams(\n                loggingEnabledUser, securityLoggingEnabled, auditLoggingEnabled);\n        if (securityLoggingEnabled || auditLoggingEnabled) {\n            synchronized (getLockObject()) {\n                maybePauseDeviceWideLoggingLocked();\n            }\n        }\n    }\n\n    private Intent createShowAdminSupportIntent(int userId) {\n        // This method is called with AMS lock held, so don't take DPMS lock\n        final Intent intent = new Intent(Settings.ACTION_SHOW_ADMIN_SUPPORT_DETAILS);\n        intent.putExtra(Intent.EXTRA_USER_ID, userId);\n        intent.setFlags(FLAG_ACTIVITY_NEW_TASK);\n        return intent;\n    }\n\n    /**\n     * @param restriction The restriction enforced by admin. It could be any user restriction or\n     *                    policy like {@link DevicePolicyManager#POLICY_DISABLE_CAMERA},\n     *                    {@link DevicePolicyManager#POLICY_DISABLE_SCREEN_CAPTURE} and  {@link\n     *                    DevicePolicyManager#POLICY_SUSPEND_PACKAGES}.\n     */\n    private Bundle getEnforcingAdminAndUserDetailsInternal(int userId, String restriction) {\n        Bundle result = null;\n\n        // For POLICY_SUSPEND_PACKAGES return PO or DO to keep the behavior same as\n        // before the bug fix for b/192245204.\n        if (restriction == null || DevicePolicyManager.POLICY_SUSPEND_PACKAGES.equals(\n                restriction)) {\n            ComponentName profileOwner = mOwners.getProfileOwnerComponent(userId);\n            if (profileOwner != null) {\n                result = new Bundle();\n                result.putInt(Intent.EXTRA_USER_ID, userId);\n                result.putParcelable(DevicePolicyManager.EXTRA_DEVICE_ADMIN,\n                        profileOwner);\n                return result;\n            }\n            final Pair<Integer, ComponentName> deviceOwner =\n                    mOwners.getDeviceOwnerUserIdAndComponent();\n            if (deviceOwner != null && deviceOwner.first == userId) {\n                result = new Bundle();\n                result.putInt(Intent.EXTRA_USER_ID, userId);\n                result.putParcelable(DevicePolicyManager.EXTRA_DEVICE_ADMIN,\n                        deviceOwner.second);\n                return result;\n            }\n        } else if (DevicePolicyManager.POLICY_DISABLE_SCREEN_CAPTURE.equals(restriction)) {\n            Boolean value = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.SCREEN_CAPTURE_DISABLED, userId);\n            if (value != null && value) {\n                result = new Bundle();\n                result.putInt(Intent.EXTRA_USER_ID, userId);\n                return result;\n            }\n        } else if (DevicePolicyManager.POLICY_DISABLE_CAMERA.equals(restriction)) {\n            PolicyDefinition<Boolean> policyDefinition =\n                    PolicyDefinition.getPolicyDefinitionForUserRestriction(\n                            UserManager.DISALLOW_CAMERA);\n            Boolean value = mDevicePolicyEngine.getResolvedPolicy(policyDefinition, userId);\n            if (value != null && value) {\n                result = new Bundle();\n                result.putInt(Intent.EXTRA_USER_ID, userId);\n                return result;\n            }\n        } else {\n            long ident = mInjector.binderClearCallingIdentity();\n            try {\n                if (getEnforcingAdminsForRestrictionInternal(userId, restriction).size() == 0) {\n                    return null;\n                }\n\n                ActiveAdmin admin = getMostProbableDPCAdminForLocalPolicy(userId);\n                if (admin != null) {\n                    result = new Bundle();\n                    result.putInt(Intent.EXTRA_USER_ID, admin.getUserHandle().getIdentifier());\n                    result.putParcelable(DevicePolicyManager.EXTRA_DEVICE_ADMIN,\n                            admin.info.getComponent());\n                    return result;\n                } else if (android.security.Flags.aapmApi()) {\n                    result = new Bundle();\n                    result.putInt(Intent.EXTRA_USER_ID, userId);\n                    return result;\n                }\n                return null;\n            } finally {\n                mInjector.binderRestoreCallingIdentity(ident);\n            }\n        }\n        return null;\n    }\n\n    private android.app.admin.EnforcingAdmin getEnforcingAdminInternal(int userId,\n            String identifier) {\n        Objects.requireNonNull(identifier);\n\n        Set<EnforcingAdmin> admins = getEnforcingAdminsForIdentifier(userId, identifier);\n        if (admins.isEmpty()) {\n            return null;\n        }\n\n        final EnforcingAdmin admin;\n        if (admins.size() == 1) {\n            admin = admins.iterator().next();\n        } else {\n            Optional<EnforcingAdmin> dpc = admins.stream()\n                    .filter(a -> a.hasAuthority(EnforcingAdmin.DPC_AUTHORITY)).findFirst();\n            admin = dpc.orElseGet(() -> admins.stream().findFirst().get());\n        }\n        return admin == null ? null : admin.getParcelableAdmin();\n    }\n\n    private <V> Set<EnforcingAdmin> getEnforcingAdminsForIdentifier(int userId, String identifier) {\n        // For POLICY_SUSPEND_PACKAGES return PO or DO to keep the behavior same as\n        // before the bug fix for b/192245204.\n        if (DevicePolicyManager.POLICY_SUSPEND_PACKAGES.equals(identifier)) {\n            EnforcingAdmin admin = getProfileOrDeviceOwnerEnforcingAdmin(userId);\n            return admin == null ? Collections.emptySet() : Collections.singleton(admin);\n        }\n\n        long ident = mInjector.binderClearCallingIdentity();\n        try {\n            final PolicyDefinition<V> policyDefinition = getPolicyDefinitionForIdentifier(\n                    identifier);\n            V value = mDevicePolicyEngine.getResolvedPolicy(policyDefinition, userId);\n            if (value == null) {\n                return Collections.emptySet();\n            }\n            return Stream.concat(mDevicePolicyEngine.getGlobalPoliciesSetByAdmins(policyDefinition)\n                                    .entrySet().stream(),\n                            mDevicePolicyEngine.getLocalPoliciesSetByAdmins(policyDefinition,\n                                    userId).entrySet().stream())\n                    .filter(entry -> value.equals(entry.getValue().getValue()))\n                    .map(Map.Entry::getKey)\n                    .collect(Collectors.toSet());\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n    }\n\n    /**\n     * @param restriction The restriction enforced by admin. It could be any user restriction or\n     *                    policy like {@link DevicePolicyManager#POLICY_DISABLE_CAMERA},\n     *                    {@link DevicePolicyManager#POLICY_DISABLE_SCREEN_CAPTURE} and  {@link\n     *                    DevicePolicyManager#POLICY_SUSPEND_PACKAGES}.\n     */\n    private Set<android.app.admin.EnforcingAdmin> getEnforcingAdminsForRestrictionInternal(\n            int userId, @NonNull String restriction) {\n        Objects.requireNonNull(restriction);\n        Set<android.app.admin.EnforcingAdmin> admins = new HashSet<>();\n        // For POLICY_SUSPEND_PACKAGES return PO or DO to keep the behavior same as\n        // before the bug fix for b/192245204.\n        if (DevicePolicyManager.POLICY_SUSPEND_PACKAGES.equals(\n                restriction)) {\n            EnforcingAdmin admin = getProfileOrDeviceOwnerEnforcingAdmin(userId);\n            if (admin != null) {\n                admins.add(admin.getParcelableAdmin());\n            }\n        } else {\n            long ident = mInjector.binderClearCallingIdentity();\n            try {\n                PolicyDefinition<Boolean> policyDefinition = getPolicyDefinitionForRestriction(\n                        restriction);\n                Boolean value = mDevicePolicyEngine.getResolvedPolicy(policyDefinition, userId);\n                if (value != null && value) {\n                    Map<EnforcingAdmin, PolicyValue<Boolean>> globalPolicies =\n                            mDevicePolicyEngine.getGlobalPoliciesSetByAdmins(policyDefinition);\n                    for (EnforcingAdmin admin : globalPolicies.keySet()) {\n                        if (globalPolicies.get(admin) != null\n                                && Boolean.TRUE.equals(globalPolicies.get(admin).getValue())) {\n                            admins.add(admin.getParcelableAdmin());\n                        }\n                    }\n\n                    Map<EnforcingAdmin, PolicyValue<Boolean>> localPolicies =\n                            mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                                    policyDefinition, userId);\n                    for (EnforcingAdmin admin : localPolicies.keySet()) {\n                        if (localPolicies.get(admin) != null\n                                && Boolean.TRUE.equals(localPolicies.get(admin).getValue())) {\n                            admins.add(admin.getParcelableAdmin());\n                        }\n                    }\n                    return admins;\n                }\n            } finally {\n                mInjector.binderRestoreCallingIdentity(ident);\n            }\n        }\n        return admins;\n    }\n\n    private static PolicyDefinition<Boolean> getPolicyDefinitionForRestriction(\n            @NonNull String restriction) {\n        Objects.requireNonNull(restriction);\n        if (DevicePolicyManager.POLICY_DISABLE_CAMERA.equals(restriction)) {\n            return PolicyDefinition.getPolicyDefinitionForUserRestriction(\n                    UserManager.DISALLOW_CAMERA);\n        } else if (DevicePolicyManager.POLICY_DISABLE_SCREEN_CAPTURE.equals(restriction)) {\n            return PolicyDefinition.SCREEN_CAPTURE_DISABLED;\n        } else {\n            return PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction);\n        }\n    }\n\n    private static <V> PolicyDefinition<V> getPolicyDefinitionForIdentifier(\n            @NonNull String identifier) {\n        Objects.requireNonNull(identifier);\n        if (Flags.setMtePolicyCoexistence() && MEMORY_TAGGING_POLICY.equals(identifier)) {\n            return (PolicyDefinition<V>) PolicyDefinition.MEMORY_TAGGING;\n        } else {\n            return (PolicyDefinition<V>) getPolicyDefinitionForRestriction(identifier);\n        }\n    }\n\n    private EnforcingAdmin getProfileOrDeviceOwnerEnforcingAdmin(int userId) {\n        ComponentName profileOwner = mOwners.getProfileOwnerComponent(userId);\n        if (profileOwner != null) {\n            return EnforcingAdmin.createEnterpriseEnforcingAdmin(profileOwner, userId);\n        }\n        final Pair<Integer, ComponentName> deviceOwner = mOwners.getDeviceOwnerUserIdAndComponent();\n        if (deviceOwner != null && deviceOwner.first == userId) {\n            return EnforcingAdmin.createEnterpriseEnforcingAdmin(deviceOwner.second,\n                    deviceOwner.first);\n        }\n        return null;\n    }\n\n    private static String userRestrictionSourceToString(@UserRestrictionSource int source) {\n        return DebugUtils.flagsToString(UserManager.class, \"RESTRICTION_\", source);\n    }\n\n    /**\n     * @param restriction The restriction enforced by admin. It could be any user restriction or\n     *                    policy like {@link DevicePolicyManager#POLICY_DISABLE_CAMERA} and\n     *                    {@link DevicePolicyManager#POLICY_DISABLE_SCREEN_CAPTURE}.\n     * @return Details of admin and user which enforced the restriction for the userId.\n     */\n    @Override\n    public Bundle getEnforcingAdminAndUserDetails(int userId, String restriction) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()));\n        return getEnforcingAdminAndUserDetailsInternal(userId, restriction);\n    }\n\n    @Override\n    public android.app.admin.EnforcingAdmin getEnforcingAdmin(int userId, String identifier) {\n        Preconditions.checkCallAuthorization(canQueryAdminPolicy(getCallerIdentity()));\n        return getEnforcingAdminInternal(userId, identifier);\n    }\n\n    @Override\n    public List<android.app.admin.EnforcingAdmin> getEnforcingAdminsForRestriction(\n            int userId, String restriction) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()));\n        return new ArrayList<>(getEnforcingAdminsForRestrictionInternal(userId, restriction));\n    }\n\n    /**\n     * @param restriction The restriction enforced by admin. It could be any user restriction or\n     *                    policy like {@link DevicePolicyManager#POLICY_DISABLE_CAMERA} and\n     *                    {@link DevicePolicyManager#POLICY_DISABLE_SCREEN_CAPTURE}.\n     */\n    @Override\n    public Intent createAdminSupportIntent(String restriction) {\n        Objects.requireNonNull(restriction);\n        final CallerIdentity caller = getCallerIdentity();\n        final int userId = caller.getUserId();\n        Intent intent = null;\n        if (getEnforcingAdminAndUserDetailsInternal(userId, restriction) != null) {\n            intent = createShowAdminSupportIntent(userId);\n            intent.putExtra(DevicePolicyManager.EXTRA_RESTRICTION, restriction);\n        }\n        return intent;\n    }\n\n    /**\n     * Returns true if specified admin is allowed to limit passwords and has a\n     * {@code mPasswordPolicy.quality} of at least {@code minPasswordQuality}\n     */\n    private static boolean isLimitPasswordAllowed(ActiveAdmin admin, int minPasswordQuality) {\n        if (admin.mPasswordPolicy.quality < minPasswordQuality) {\n            return false;\n        }\n        return admin.info.usesPolicy(DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD);\n    }\n\n    @Override\n    public void setCredentialManagerPolicy(PackagePolicy policy) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canWriteCredentialManagerPolicy(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (Objects.equals(admin.mCredentialManagerPolicy, policy)) {\n                return;\n            }\n\n            admin.mCredentialManagerPolicy = policy;\n            saveSettingsLocked(caller.getUserId());\n        }\n    }\n\n    private boolean canWriteCredentialManagerPolicy(CallerIdentity caller) {\n        return (isProfileOwner(caller) && isManagedProfile(caller.getUserId()))\n                        || isDefaultDeviceOwner(caller)\n                        || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS);\n    }\n\n    @Override\n    public PackagePolicy getCredentialManagerPolicy(int userId) {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                canWriteCredentialManagerPolicy(caller) || canQueryAdminPolicy(caller));\n        if (userId != caller.getUserId()) {\n            Preconditions.checkCallAuthorization(\n                    hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n        }\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(userId);\n            return (admin != null) ? admin.mCredentialManagerPolicy : null;\n        }\n    }\n\n    @Override\n    public void setSystemUpdatePolicy(\n            ComponentName who, String callerPackageName, SystemUpdatePolicy policy) {\n        if (policy != null) {\n            // throws exception if policy type is invalid\n            policy.validateType();\n            // throws exception if freeze period is invalid\n            policy.validateFreezePeriods();\n            Pair<LocalDate, LocalDate> record = mOwners.getSystemUpdateFreezePeriodRecord();\n            // throws exception if freeze period is incompatible with previous freeze period record\n            policy.validateAgainstPreviousFreezePeriod(record.first, record.second,\n                    LocalDate.now());\n        }\n\n        CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwnerOfOrganizationOwnedDevice(caller)\n                        || isDefaultDeviceOwner(caller));\n\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_SYSTEM_UPDATE_POLICY);\n\n        synchronized (getLockObject()) {\n            if (policy == null) {\n                mOwners.clearSystemUpdatePolicy();\n            } else {\n                mOwners.setSystemUpdatePolicy(policy);\n                updateSystemUpdateFreezePeriodsRecord(/* saveIfChanged */ false);\n            }\n            mOwners.writeDeviceOwner();\n        }\n        mInjector.binderWithCleanCallingIdentity(() -> mContext.sendBroadcastAsUser(\n                new Intent(ACTION_SYSTEM_UPDATE_POLICY_CHANGED), UserHandle.SYSTEM));\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SYSTEM_UPDATE_POLICY)\n                .setAdmin(caller.getPackageName())\n                .setInt(policy != null ? policy.getPolicyType() : 0)\n                .write();\n    }\n\n    @Override\n    public SystemUpdatePolicy getSystemUpdatePolicy() {\n        synchronized (getLockObject()) {\n            SystemUpdatePolicy policy =  mOwners.getSystemUpdatePolicy();\n            if (policy != null && !policy.isValid()) {\n                Slogf.w(LOG_TAG, \"Stored system update policy is invalid, return null instead.\");\n                return null;\n            }\n            return policy;\n        }\n    }\n\n    private static boolean withinRange(Pair<LocalDate, LocalDate> range, LocalDate date) {\n        return (!date.isBefore(range.first) && !date.isAfter(range.second));\n    }\n\n    /**\n     * keeps track of the last continuous period when the system is under OTA freeze.\n     *\n     * DPMS keeps track of the previous dates during which OTA was freezed as a result of an\n     * system update policy with freeze periods in effect. This is needed to make robust\n     * validation on new system update polices, for example to prevent the OTA from being\n     * frozen for more than 90 days if the DPC keeps resetting a new 24-hour freeze period\n     * on midnight everyday, or having freeze periods closer than 60 days apart by DPC resetting\n     * a new freeze period after a few days.\n     *\n     * @param saveIfChanged whether to persist the result on disk if freeze period record is\n     *            updated. This should only be set to {@code false} if there is a guaranteed\n     *            mOwners.writeDeviceOwner() later in the control flow to reduce the number of\n     *            disk writes. Otherwise you risk inconsistent on-disk state.\n     *\n     * @see SystemUpdatePolicy#validateAgainstPreviousFreezePeriod\n     */\n    private void updateSystemUpdateFreezePeriodsRecord(boolean saveIfChanged) {\n        Slogf.d(LOG_TAG, \"updateSystemUpdateFreezePeriodsRecord\");\n        synchronized (getLockObject()) {\n            final SystemUpdatePolicy policy = mOwners.getSystemUpdatePolicy();\n            if (policy == null) {\n                return;\n            }\n            final LocalDate now = LocalDate.now();\n            final Pair<LocalDate, LocalDate> currentPeriod = policy.getCurrentFreezePeriod(now);\n            if (currentPeriod == null) {\n                return;\n            }\n            final Pair<LocalDate, LocalDate> record = mOwners.getSystemUpdateFreezePeriodRecord();\n            final LocalDate start = record.first;\n            final LocalDate end = record.second;\n            final boolean changed;\n            if (end == null || start == null) {\n                // Start a new period if there is none at the moment\n                changed = mOwners.setSystemUpdateFreezePeriodRecord(now, now);\n            } else if (now.equals(end.plusDays(1))) {\n                // Extend the existing period\n                changed = mOwners.setSystemUpdateFreezePeriodRecord(start, now);\n            } else if (now.isAfter(end.plusDays(1))) {\n                if (withinRange(currentPeriod, start) && withinRange(currentPeriod, end)) {\n                    // The device might be off for some period. If the past freeze record\n                    // is within range of the current freeze period, assume the device was off\n                    // during the period [end, now] and extend the freeze record to [start, now].\n                    changed = mOwners.setSystemUpdateFreezePeriodRecord(start, now);\n                } else {\n                    changed = mOwners.setSystemUpdateFreezePeriodRecord(now, now);\n                }\n            } else if (now.isBefore(start)) {\n                // Systm clock was adjusted backwards, restart record\n                changed = mOwners.setSystemUpdateFreezePeriodRecord(now, now);\n            } else /* start <= now <= end */ {\n                changed = false;\n            }\n            if (changed && saveIfChanged) {\n                mOwners.writeDeviceOwner();\n            }\n        }\n    }\n\n    @Override\n    public void clearSystemUpdatePolicyFreezePeriodRecord() {\n        Preconditions.checkCallAuthorization(isAdb(getCallerIdentity())\n                        || hasCallingOrSelfPermission(permission.CLEAR_FREEZE_PERIOD),\n                \"Caller must be shell, or hold CLEAR_FREEZE_PERIOD permission to call \"\n                        + \"clearSystemUpdatePolicyFreezePeriodRecord\");\n        synchronized (getLockObject()) {\n            // Print out current record to help diagnosed CTS failures\n            Slogf.i(LOG_TAG, \"Clear freeze period record: \"\n                    + mOwners.getSystemUpdateFreezePeriodRecordAsString());\n            if (mOwners.setSystemUpdateFreezePeriodRecord(null, null)) {\n                mOwners.writeDeviceOwner();\n            }\n        }\n    }\n\n    /**\n     * Checks if any of the packages associated with the UID of the app provided is that\n     * of the device owner.\n     * @param appUid UID of the app to check.\n     * @return {@code true} if any of the packages are the device owner, {@code false} otherwise.\n     */\n    private boolean isUidDeviceOwnerLocked(int appUid) {\n        ensureLocked();\n        final String deviceOwnerPackageName = mOwners.getDeviceOwnerComponent()\n                .getPackageName();\n        try {\n            String[] pkgs = mInjector.getIPackageManager().getPackagesForUid(appUid);\n            if (pkgs == null) {\n                return false;\n            }\n\n            for (String pkg : pkgs) {\n                if (deviceOwnerPackageName.equals(pkg)) {\n                    return true;\n                }\n            }\n        } catch (RemoteException e) {\n            return false;\n        }\n        return false;\n    }\n\n    @Override\n    public void notifyPendingSystemUpdate(@Nullable SystemUpdateInfo info) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(NOTIFY_PENDING_SYSTEM_UPDATE),\n                \"Only the system update service can broadcast update information\");\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (!mUserManager.getUserInfo(UserHandle.getCallingUserId()).isMain()) {\n                Slogf.w(LOG_TAG, \"Only the system update service in the main user can broadcast \"\n                        + \"update information.\");\n            }\n        });\n\n        if (!mOwners.saveSystemUpdateInfo(info)) {\n            // Pending system update hasn't changed, don't send duplicate notification.\n            return;\n        }\n\n        final Intent intent = new Intent(DeviceAdminReceiver.ACTION_NOTIFY_PENDING_SYSTEM_UPDATE)\n                .putExtra(DeviceAdminReceiver.EXTRA_SYSTEM_UPDATE_RECEIVED_TIME,\n                        info == null ? -1 : info.getReceivedTime());\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            synchronized (getLockObject()) {\n                // Broadcast to device owner first if there is one.\n                if (mOwners.hasDeviceOwner()) {\n                    final UserHandle deviceOwnerUser =\n                            UserHandle.of(mOwners.getDeviceOwnerUserId());\n                    intent.setComponent(mOwners.getDeviceOwnerComponent());\n                    mContext.sendBroadcastAsUser(intent, deviceOwnerUser);\n                }\n            }\n            // Get running users.\n            final int[] runningUserIds;\n            try {\n                runningUserIds = mInjector.getIActivityManager().getRunningUserIds();\n            } catch (RemoteException e) {\n                // Shouldn't happen.\n                Slogf.e(LOG_TAG, \"Could not retrieve the list of running users\", e);\n                return;\n            }\n            // Send broadcasts to corresponding profile owners if any.\n            for (final int userId : runningUserIds) {\n                final ComponentName profileOwnerPackage;\n                synchronized (getLockObject()) {\n                    profileOwnerPackage = mOwners.getProfileOwnerComponent(userId);\n                }\n                if (profileOwnerPackage != null) {\n                    intent.setComponent(profileOwnerPackage);\n                    mContext.sendBroadcastAsUser(intent, UserHandle.of(userId));\n                }\n\n                final UserHandle user = UserHandle.of(userId);\n                final String roleHolderPackage = getRoleHolderPackageNameOnUser(\n                        RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT, userId);\n                if (roleHolderPackage != null) {\n                    broadcastExplicitIntentToPackage(intent, roleHolderPackage, user);\n                }\n            }\n        });\n    }\n\n    @Override\n    public SystemUpdateInfo getPendingSystemUpdate(ComponentName admin, String callerPackage) {\n        CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        enforcePermissions(new String[] {NOTIFY_PENDING_SYSTEM_UPDATE,\n                MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES}, caller.getPackageName(),\n                caller.getUserId());\n        return mOwners.getSystemUpdateInfo();\n    }\n\n    @Override\n    public void setPermissionPolicy(ComponentName admin, String callerPackage, int policy) {\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller,\n                DELEGATION_PERMISSION_GRANT)));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_PERMISSION_POLICY);\n\n        final int forUser = caller.getUserId();\n        synchronized (getLockObject()) {\n            DevicePolicyData userPolicy = getUserData(forUser);\n            if (userPolicy.mPermissionPolicy != policy) {\n                userPolicy.mPermissionPolicy = policy;\n                mPolicyCache.setPermissionPolicy(forUser, policy);\n                saveSettingsLocked(forUser);\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PERMISSION_POLICY)\n                .setAdmin(caller.getPackageName())\n                .setInt(policy)\n                .setBoolean(/* isDelegate */ admin == null)\n                .write();\n    }\n\n    private void updatePermissionPolicyCache(int userId) {\n        synchronized (getLockObject()) {\n            DevicePolicyData userPolicy = getUserData(userId);\n            mPolicyCache.setPermissionPolicy(userId, userPolicy.mPermissionPolicy);\n        }\n    }\n\n    @Override\n    public int getPermissionPolicy(ComponentName admin) throws RemoteException {\n        int userId = UserHandle.getCallingUserId();\n        return mPolicyCache.getPermissionPolicy(userId);\n    }\n\n    @Override\n    public void setPermissionGrantState(ComponentName admin, String callerPackage,\n            String packageName, String permission, int grantState, RemoteCallback callback)\n            throws RemoteException {\n        Objects.requireNonNull(callback);\n\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_PERMISSION_GRANT_STATE);\n\n        synchronized (getLockObject()) {\n            if (isFinancedDeviceOwner(caller)) {\n                enforcePermissionGrantStateOnFinancedDevice(packageName, permission);\n            }\n        }\n        EnforcingAdmin enforcingAdmin;\n\n        // TODO(b/370472975): enable when we stop policy enforecer callback from blocking the main\n        //  thread\n        if (Flags.setPermissionGrantStateCoexistence()) {\n            enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,\n                    callerPackage,\n                    caller.getUserId());\n            if (SENSOR_PERMISSIONS.contains(permission)\n                    && grantState == PERMISSION_GRANT_STATE_GRANTED\n                    && !canAdminGrantSensorsPermissions()) {\n                if (mInjector.isChangeEnabled(THROW_SECURITY_EXCEPTION_FOR_SENSOR_PERMISSIONS,\n                        caller.getPackageName(), caller.getUserId())) {\n                    throw new SecurityException(\n                            \"Caller not permitted to grant sensor permissions.\");\n                } else {\n                    // This is to match the legacy behaviour.\n                    callback.sendResult(Bundle.EMPTY);\n                    return;\n                }\n            }\n            // Check all the states where Exceptions aren't thrown but the permission\n            // isn't granted either.\n            if (!canGrantPermission(caller, permission, packageName)) {\n                callback.sendResult(null);\n                return;\n            }\n\n            // TODO(b/266924257): decide how to handle the internal state if the package doesn't\n            //  exist, or the permission isn't requested by the app, because we could end up with\n            //  inconsistent state between the policy engine and package manager. Also a package\n            //  might get removed or has it's permission updated after we've set the policy.\n            if (grantState == PERMISSION_GRANT_STATE_DEFAULT) {\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.PERMISSION_GRANT(packageName, permission),\n                        enforcingAdmin,\n                        caller.getUserId());\n            } else {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.PERMISSION_GRANT(packageName, permission),\n                        enforcingAdmin,\n                        new IntegerPolicyValue(grantState),\n                        caller.getUserId());\n            }\n            int newState = mInjector.binderWithCleanCallingIdentity(() ->\n                    getPermissionGrantStateForUser(\n                            packageName, permission, caller, caller.getUserId()));\n            if (newState == grantState) {\n                callback.sendResult(Bundle.EMPTY);\n            } else {\n                callback.sendResult(null);\n            }\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                    || isFinancedDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(caller,\n                    DELEGATION_PERMISSION_GRANT)));\n            if (SENSOR_PERMISSIONS.contains(permission)\n                    && grantState == PERMISSION_GRANT_STATE_GRANTED\n                    && !canAdminGrantSensorsPermissions()) {\n                if (mInjector.isChangeEnabled(THROW_SECURITY_EXCEPTION_FOR_SENSOR_PERMISSIONS,\n                        caller.getPackageName(), caller.getUserId())) {\n                    throw new SecurityException(\n                            \"Caller not permitted to grant sensor permissions.\");\n                } else {\n                    Slogf.e(LOG_TAG, \"Caller attempted to grant sensor permissions but denied\");\n                    // This is to match the legacy behaviour.\n                    callback.sendResult(Bundle.EMPTY);\n                    return;\n                }\n            }\n            synchronized (getLockObject()) {\n                long ident = mInjector.binderClearCallingIdentity();\n                boolean isPostQAdmin = getTargetSdk(caller.getPackageName(), caller.getUserId())\n                        >= Build.VERSION_CODES.Q;\n\n                try {\n                    if (!isPostQAdmin) {\n                        // Legacy admins assume that they cannot control pre-M apps\n                        if (getTargetSdk(packageName, caller.getUserId())\n                                < Build.VERSION_CODES.M) {\n                            callback.sendResult(null);\n                            return;\n                        }\n                    }\n                    if (!isRuntimePermission(permission)) {\n                        callback.sendResult(null);\n                        return;\n                    }\n                    if (grantState == PERMISSION_GRANT_STATE_GRANTED\n                            || grantState == DevicePolicyManager.PERMISSION_GRANT_STATE_DENIED\n                            || grantState == PERMISSION_GRANT_STATE_DEFAULT) {\n                        AdminPermissionControlParams permissionParams =\n                                new AdminPermissionControlParams(packageName, permission,\n                                        grantState,\n                                        canAdminGrantSensorsPermissions());\n                        mInjector.getPermissionControllerManager(caller.getUserHandle())\n                                .setRuntimePermissionGrantStateByDeviceAdmin(\n                                        caller.getPackageName(),\n                                        permissionParams, mContext.getMainExecutor(),\n                                        (permissionWasSet) -> {\n                                            if (isPostQAdmin && !permissionWasSet) {\n                                                callback.sendResult(null);\n                                                return;\n                                            }\n                                            callback.sendResult(Bundle.EMPTY);\n                                        });\n                    }\n                } catch (SecurityException e) {\n                    Slogf.e(LOG_TAG, \"Could not set permission grant state\", e);\n                    callback.sendResult(null);\n                } finally {\n                    mInjector.binderRestoreCallingIdentity(ident);\n                }\n            }\n        }\n        DevicePolicyEventLogger.createEvent(DevicePolicyEnums.SET_PERMISSION_GRANT_STATE)\n                .setAdmin(caller.getPackageName())\n                .setStrings(permission)\n                .setInt(grantState)\n                .setBoolean(/* isDelegate */ isCallerDelegate(caller))\n                .write();\n    }\n\n    private static final List<String> SENSOR_PERMISSIONS = new ArrayList<>();\n    {\n        SENSOR_PERMISSIONS.add(permission.ACCESS_FINE_LOCATION);\n        SENSOR_PERMISSIONS.add(permission.ACCESS_BACKGROUND_LOCATION);\n        SENSOR_PERMISSIONS.add(permission.ACCESS_COARSE_LOCATION);\n        SENSOR_PERMISSIONS.add(permission.CAMERA);\n        SENSOR_PERMISSIONS.add(permission.RECORD_AUDIO);\n        SENSOR_PERMISSIONS.add(permission.ACTIVITY_RECOGNITION);\n        SENSOR_PERMISSIONS.add(permission.BODY_SENSORS);\n        SENSOR_PERMISSIONS.add(permission.BACKGROUND_CAMERA);\n        SENSOR_PERMISSIONS.add(permission.RECORD_BACKGROUND_AUDIO);\n        SENSOR_PERMISSIONS.add(permission.BODY_SENSORS_BACKGROUND);\n    }\n\n    private boolean canGrantPermission(CallerIdentity caller, String permission,\n            String targetPackageName) {\n        boolean isPostQAdmin = getTargetSdk(caller.getPackageName(), caller.getUserId())\n                >= Build.VERSION_CODES.Q;\n        if (!isPostQAdmin) {\n            // Legacy admins assume that they cannot control pre-M apps\n            if (getTargetSdk(targetPackageName, caller.getUserId())\n                    < Build.VERSION_CODES.M) {\n                return false;\n            }\n        }\n        return isRuntimePermission(permission);\n    }\n\n    private void enforcePermissionGrantStateOnFinancedDevice(\n            String packageName, String permission) {\n        if (!Manifest.permission.READ_PHONE_STATE.equals(permission)) {\n            throw new SecurityException(permission + \" cannot be used when managing a financed\"\n                    + \" device for permission grant state\");\n        } else if (!mOwners.getDeviceOwnerPackageName().equals(packageName)) {\n            throw new SecurityException(\"Device owner package is the only package that can be used\"\n                    + \" for permission grant state when managing a financed device\");\n        }\n    }\n\n    @Override\n    public int getPermissionGrantState(ComponentName admin, String callerPackage,\n            String packageName, String permission) throws RemoteException {\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        if (Flags.setPermissionGrantStateCoexistence()) {\n            enforceCanQuery(MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS, caller.getPackageName(),\n                    caller.getUserId());\n        } else {\n            Preconditions.checkCallAuthorization(isSystemUid(caller) || (caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                    || isFinancedDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(caller,\n                    DELEGATION_PERMISSION_GRANT)));\n        }\n\n        synchronized (getLockObject()) {\n            if (isFinancedDeviceOwner(caller)) {\n                enforcePermissionGrantStateOnFinancedDevice(packageName, permission);\n            }\n            return mInjector.binderWithCleanCallingIdentity(() -> getPermissionGrantStateForUser(\n                    packageName, permission, caller, caller.getUserId()));\n        }\n    }\n\n    private int getPermissionGrantStateForUser(\n            String packageName, String permission, CallerIdentity caller, int userId)\n            throws RemoteException {\n        int granted;\n        if (getTargetSdk(caller.getPackageName(), caller.getUserId())\n                < Build.VERSION_CODES.Q) {\n            // The per-Q behavior was to not check the app-ops state.\n            granted = mIPackageManager.checkPermission(permission, packageName, userId);\n        } else {\n            try (var snapshot = mInjector.getPackageManagerLocal().withUnfilteredSnapshot()) {\n                var packageState = snapshot.getPackageStates().get(packageName);\n                if (packageState == null) {\n                    Slog.w(LOG_TAG, \"Can't get permission state for missing package \"\n                            + packageName);\n                    return PERMISSION_GRANT_STATE_DEFAULT;\n                } else if (!packageState.getUserStateOrDefault(userId).isInstalled()) {\n                    Slog.w(LOG_TAG, \"Can't get permission state for uninstalled package \"\n                            + packageName);\n                    return PERMISSION_GRANT_STATE_DEFAULT;\n                } else {\n                    if (PermissionChecker.checkPermissionForPreflight(mContext, permission,\n                            PermissionChecker.PID_UNKNOWN,\n                            UserHandle.getUid(userId, packageState.getAppId()), packageName)\n                            != PermissionChecker.PERMISSION_GRANTED) {\n                        granted = PackageManager.PERMISSION_DENIED;\n                    } else {\n                        granted = PERMISSION_GRANTED;\n                    }\n\n                }\n            }\n        }\n        int permFlags = mInjector.getPackageManager().getPermissionFlags(\n                permission, packageName, UserHandle.of(userId));\n        if ((permFlags & PackageManager.FLAG_PERMISSION_POLICY_FIXED)\n                != PackageManager.FLAG_PERMISSION_POLICY_FIXED) {\n            // Not controlled by policy\n            return PERMISSION_GRANT_STATE_DEFAULT;\n        } else {\n            // Policy controlled so return result based on permission grant state\n            return granted == PERMISSION_GRANTED\n                    ? PERMISSION_GRANT_STATE_GRANTED\n                    : DevicePolicyManager.PERMISSION_GRANT_STATE_DENIED;\n        }\n    }\n\n    boolean isPackageInstalledForUser(String packageName, int userHandle) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                PackageInfo pi = mInjector.getIPackageManager().getPackageInfo(packageName, 0,\n                        userHandle);\n                return (pi != null) && (pi.applicationInfo.flags != 0);\n            } catch (RemoteException re) {\n                throw new RuntimeException(\"Package manager has died\", re);\n            }\n        });\n    }\n\n    private boolean isRuntimePermission(String permissionName) {\n        try {\n            final PackageManager packageManager = mInjector.getPackageManager();\n            PermissionInfo permissionInfo = packageManager.getPermissionInfo(permissionName, 0);\n            return (permissionInfo.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE)\n                    == PermissionInfo.PROTECTION_DANGEROUS;\n        } catch (NameNotFoundException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public boolean isProvisioningAllowed(String action, String packageName) {\n        Objects.requireNonNull(packageName);\n        final CallerIdentity caller = getCallerIdentity();\n        final long ident = mInjector.binderClearCallingIdentity();\n        try {\n            final List<String> callerUidPackageNames = Arrays.asList(\n                    mInjector.getPackageManager().getPackagesForUid(caller.getUid()));\n            Preconditions.checkArgument(callerUidPackageNames.contains(packageName),\n                    \"Caller uid doesn't match the one for the provided package.\");\n\n            return checkProvisioningPreconditionSkipPermission(action, packageName, caller.getUserId())\n                    == STATUS_OK;\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int checkProvisioningPrecondition(String action, String packageName) {\n        Objects.requireNonNull(packageName, \"packageName is null\");\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        long originalId = mInjector.binderClearCallingIdentity();\n        try {\n            return checkProvisioningPreconditionSkipPermission(\n                    action, packageName, caller.getUserId());\n        } finally {\n            mInjector.binderRestoreCallingIdentity(originalId);\n        }\n\n    }\n\n    private int checkProvisioningPreconditionSkipPermission(\n            String action, String packageName, int userId) {\n        return checkProvisioningPreconditionSkipPermission(\n                action, packageName, /* componentName = */ null, userId);\n    }\n\n    private int checkProvisioningPreconditionSkipPermission(\n            String action, ComponentName componentName, int userId) {\n        return checkProvisioningPreconditionSkipPermission(\n                action, componentName.getPackageName(), componentName, userId);\n    }\n\n    private int checkProvisioningPreconditionSkipPermission(\n            String action, String packageName, @Nullable ComponentName componentName, int userId) {\n        if (!mHasFeature) {\n            logMissingFeatureAction(\"Cannot check provisioning for action \" + action);\n            return STATUS_DEVICE_ADMIN_NOT_SUPPORTED;\n        }\n        if (!isProvisioningAllowed()) {\n            return STATUS_PROVISIONING_NOT_ALLOWED_FOR_NON_DEVELOPER_USERS;\n        }\n        final int code = checkProvisioningPreConditionSkipPermissionNoLog(\n                action, packageName, componentName, userId);\n        if (code != STATUS_OK) {\n            Slogf.d(LOG_TAG, \"checkProvisioningPreCondition(\" + action + \", \" + packageName\n                    + \") failed: \" + computeProvisioningErrorString(\n                            code, mInjector.userHandleGetCallingUserId()));\n        }\n        return code;\n    }\n\n    /**\n     *  Checks if provisioning is allowed during regular usage (non-developer/CTS). This could\n     *  return {@code false} if the device has an overlaid config value set to false. If not set,\n     *  the default is true.\n     */\n    private boolean isProvisioningAllowed() {\n        boolean isDeveloperMode = isDeveloperMode(mContext);\n        boolean isProvisioningAllowedForNormalUsers = SystemProperties.getBoolean(\n                ALLOW_USER_PROVISIONING_KEY, /* defValue= */ true);\n\n        return isDeveloperMode || isProvisioningAllowedForNormalUsers;\n    }\n\n    private static boolean isDeveloperMode(Context context) {\n        return Global.getInt(context.getContentResolver(), Global.ADB_ENABLED, 0) > 0;\n    }\n\n    private int checkProvisioningPreConditionSkipPermissionNoLog(String action,\n            String packageName, @Nullable ComponentName componentName, int userId) {\n        if (packageName != null && componentName != null\n                && !packageName.equals(componentName.getPackageName())) {\n            throw new IllegalArgumentException(\"PackageName: \" + packageName + \" is not the same as\"\n                    + \" the package provided in componentName: \" + componentName);\n        }\n        if (action != null) {\n            switch (action) {\n                case ACTION_PROVISION_MANAGED_PROFILE:\n                    return checkManagedProfileProvisioningPreCondition(packageName, userId);\n                case ACTION_PROVISION_MANAGED_DEVICE:\n                case DevicePolicyManager.ACTION_PROVISION_FINANCED_DEVICE:\n                    return checkDeviceOwnerProvisioningPreCondition(componentName, userId);\n            }\n        }\n        throw new IllegalArgumentException(\"Unknown provisioning action \" + action);\n    }\n\n    /**\n     * The device owner can only be set before the setup phase of the primary user has completed,\n     * except for adb command if no accounts or additional users are present on the device.\n     */\n    private int checkDeviceOwnerProvisioningPreConditionLocked(@Nullable ComponentName owner,\n            @UserIdInt int deviceOwnerUserId, @UserIdInt int callingUserId, boolean isAdb,\n            boolean hasIncompatibleAccountsOrNonAdb) {\n        if (mOwners.hasDeviceOwner()) {\n            return STATUS_HAS_DEVICE_OWNER;\n        }\n        if (mOwners.hasProfileOwner(deviceOwnerUserId)) {\n            return STATUS_USER_HAS_PROFILE_OWNER;\n        }\n\n        if (!mUserManager.isUserRunning(new UserHandle(deviceOwnerUserId))) {\n            return STATUS_USER_NOT_RUNNING;\n        }\n\n        DeviceAdminInfo adminInfo = null;\n\n        boolean isHeadlessModeAffiliated = false;\n\n        boolean isHeadlessModeSingleUser = false;\n\n        boolean isHeadlessSystemUserMode = mInjector.userManagerIsHeadlessSystemUserMode();\n\n        int ensureSetUpUser = UserHandle.USER_SYSTEM;\n        if (isHeadlessSystemUserMode) {\n            if (owner != null) {\n                int headlessDeviceOwnerMode = getHeadlessDeviceOwnerModeForDeviceAdmin(\n                        owner, deviceOwnerUserId);\n\n                isHeadlessModeAffiliated =\n                        headlessDeviceOwnerMode == HEADLESS_DEVICE_OWNER_MODE_AFFILIATED;\n\n                isHeadlessModeSingleUser =\n                        headlessDeviceOwnerMode == HEADLESS_DEVICE_OWNER_MODE_SINGLE_USER;\n\n                if (!isHeadlessModeAffiliated && !isHeadlessModeSingleUser) {\n                    return STATUS_HEADLESS_SYSTEM_USER_MODE_NOT_SUPPORTED;\n                }\n\n                if (isHeadlessModeSingleUser) {\n                    ensureSetUpUser = mUserManagerInternal.getMainUserId();\n                    if (ensureSetUpUser == UserHandle.USER_NULL) {\n                        return STATUS_HEADLESS_ONLY_SYSTEM_USER;\n                    }\n                }\n            }\n\n            if (isHeadlessModeAffiliated && deviceOwnerUserId != UserHandle.USER_SYSTEM) {\n                Slogf.e(LOG_TAG, \"In headless system user mode, \"\n                        + \"device owner can only be set on headless system user.\");\n                return STATUS_NOT_SYSTEM_USER;\n            }\n\n        }\n\n        if (isAdb) {\n            // If shell command runs after user setup completed check device status. Otherwise, OK.\n            if (hasUserSetupCompleted(ensureSetUpUser)) {\n                // DO can be setup only if there are no users which are neither created by default\n                // nor marked as FOR_TESTING\n\n                if (nonTestNonPrecreatedUsersExist()) {\n                    return STATUS_NONSYSTEM_USER_EXISTS;\n                }\n\n                int currentForegroundUser = getCurrentForegroundUserId();\n                if (callingUserId != currentForegroundUser\n                        && mInjector.userManagerIsHeadlessSystemUserMode()\n                        && currentForegroundUser == UserHandle.USER_SYSTEM) {\n                    Slogf.wtf(LOG_TAG, \"In headless system user mode, \"\n                            + \"current user cannot be system user when setting device owner\");\n                    return STATUS_SYSTEM_USER;\n                }\n                if (hasIncompatibleAccountsOrNonAdb) {\n                    return STATUS_ACCOUNTS_NOT_EMPTY;\n                }\n            }\n            return STATUS_OK;\n        } else {\n            // DO has to be user 0 if setting affiliated DO\n            if ((!isHeadlessSystemUserMode || isHeadlessModeAffiliated)\n                    && deviceOwnerUserId != UserHandle.USER_SYSTEM) {\n                return STATUS_NOT_SYSTEM_USER;\n            }\n            // Only provision DO before setup wizard completes\n            if (hasUserSetupCompleted(ensureSetUpUser)) {\n                return STATUS_USER_SETUP_COMPLETED;\n            }\n            return STATUS_OK;\n        }\n    }\n\n    /**\n     * True if there are any users on the device which were not setup by default (1 usually, 2 for\n     * devices with a headless system user) and also are not marked as FOR_TESTING.\n     */\n    private boolean nonTestNonPrecreatedUsersExist() {\n        int allowedUsers = UserManager.isHeadlessSystemUserMode() ? 2 : 1;\n        return mUserManagerInternal.getUsers(/* excludeDying= */ true).stream()\n                .filter(u -> !u.isForTesting())\n                .count() > allowedUsers;\n    }\n\n    private int checkDeviceOwnerProvisioningPreCondition(\n            @Nullable ComponentName componentName, @UserIdInt int callingUserId) {\n        synchronized (getLockObject()) {\n            int deviceOwnerUserId = -1;\n            deviceOwnerUserId = mInjector.userManagerIsHeadlessSystemUserMode()\n                    && getHeadlessDeviceOwnerModeForDeviceAdmin(componentName, callingUserId)\n                    == HEADLESS_DEVICE_OWNER_MODE_AFFILIATED\n                    ? UserHandle.USER_SYSTEM : callingUserId;\n            Slogf.i(LOG_TAG, \"Calling user %d, device owner will be set on user %d\",\n                    callingUserId, deviceOwnerUserId);\n            // hasIncompatibleAccountsOrNonAdb doesn't matter since the caller is not adb.\n            return checkDeviceOwnerProvisioningPreConditionLocked(componentName,\n                    deviceOwnerUserId, callingUserId, /* isAdb= */ false,\n                    /* hasIncompatibleAccountsOrNonAdb=*/ true);\n        }\n    }\n\n    private int checkManagedProfileProvisioningPreCondition(String packageName,\n            @UserIdInt int callingUserId) {\n        if (!hasFeatureManagedUsers()) {\n            return STATUS_MANAGED_USERS_NOT_SUPPORTED;\n        }\n        if (getProfileOwnerAsUser(callingUserId) != null) {\n            // Managed user cannot have a managed profile.\n            return STATUS_USER_HAS_PROFILE_OWNER;\n        }\n\n        final long ident = mInjector.binderClearCallingIdentity();\n        try {\n            final UserHandle callingUserHandle = UserHandle.of(callingUserId);\n            final boolean hasDeviceOwner;\n            synchronized (getLockObject()) {\n                hasDeviceOwner = getDeviceOwnerAdminLocked() != null;\n            }\n\n            final boolean addingProfileRestricted = mUserManager.hasUserRestriction(\n                    UserManager.DISALLOW_ADD_MANAGED_PROFILE, callingUserHandle);\n\n            if (mUserManager.getUserInfo(callingUserId).isProfile()) {\n                Slogf.i(LOG_TAG, \"Calling user %d is a profile, cannot add another.\",\n                        callingUserId);\n                // The check is called from inside a managed profile. A managed profile cannot\n                // be provisioned from within another managed profile.\n                return STATUS_CANNOT_ADD_MANAGED_PROFILE;\n            }\n\n            // If there's a device owner, the restriction on adding a managed profile must be set.\n            if (hasDeviceOwner && !addingProfileRestricted) {\n                Slogf.wtf(LOG_TAG, \"Has a device owner but no restriction on adding a profile.\");\n            }\n\n            // Do not allow adding a managed profile if there's a restriction.\n            if (addingProfileRestricted) {\n                Slogf.i(LOG_TAG, \"Adding a profile is restricted: User %s Has device owner? %b\",\n                        callingUserHandle, hasDeviceOwner);\n                return STATUS_CANNOT_ADD_MANAGED_PROFILE;\n            }\n\n            // Bail out if we are trying to provision a work profile but one already exists.\n            if (!mUserManager.canAddMoreManagedProfiles(\n                    callingUserId, /* allowedToRemoveOne= */ false)) {\n                Slogf.i(LOG_TAG, \"Cannot add more managed profiles.\");\n                return STATUS_CANNOT_ADD_MANAGED_PROFILE;\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n        return STATUS_OK;\n    }\n\n    private void checkIsDeviceOwner(CallerIdentity caller) {\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller), caller.getUid()\n                + \" is not device owner\");\n    }\n\n    /**\n     * Return device owner or profile owner set on a given user.\n     */\n    private @Nullable ComponentName getOwnerComponent(int userId) {\n        synchronized (getLockObject()) {\n            if (mOwners.getDeviceOwnerUserId() == userId) {\n                return mOwners.getDeviceOwnerComponent();\n            }\n            if (mOwners.hasProfileOwner(userId)) {\n                return mOwners.getProfileOwnerComponent(userId);\n            }\n        }\n        return null;\n    }\n\n    private boolean hasFeatureManagedUsers() {\n        try {\n            return mIPackageManager.hasSystemFeature(PackageManager.FEATURE_MANAGED_USERS, 0);\n        } catch (RemoteException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public String getWifiMacAddress(ComponentName admin, String callerPackageName) {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackageName);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller)\n                        || isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            String[] macAddresses = mInjector.getWifiManager().getFactoryMacAddresses();\n            if (macAddresses == null) {\n                return null;\n            }\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.GET_WIFI_MAC_ADDRESS)\n                    .setAdmin(caller.getPackageName())\n                    .write();\n            return macAddresses.length > 0 ? macAddresses[0] : null;\n        });\n    }\n\n    /**\n     * Returns the target sdk version number that the given packageName was built for\n     * in the given user.\n     */\n    private int getTargetSdk(String packageName, int userId) {\n        final ApplicationInfo ai;\n        try {\n            ai = mIPackageManager.getApplicationInfo(packageName, 0, userId);\n            return ai == null ? 0 : ai.targetSdkVersion;\n        } catch (RemoteException e) {\n            // Shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Error getting application info\", e);\n            return 0;\n        }\n    }\n\n    @Override\n    public boolean isManagedProfile(ComponentName admin) {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        return isManagedProfile(caller.getUserId());\n    }\n\n    @Override\n    public void reboot(ComponentName admin) {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_REBOOT);\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            // Make sure there are no ongoing calls on the device.\n            if (mTelephonyManager.getCallState() != TelephonyManager.CALL_STATE_IDLE) {\n                throw new IllegalStateException(\"Cannot be called with ongoing call on the device\");\n            }\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.REBOOT)\n                    .setAdmin(admin)\n                    .write();\n            mInjector.powerManagerReboot(PowerManager.REBOOT_REQUESTED_BY_DEVICE_OWNER);\n        });\n    }\n\n    @Override\n    public void setShortSupportMessage(@Nullable ComponentName who, String callerPackageName,\n            CharSequence message) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        message = PolicySizeVerifier.truncateIfLonger(message, MAX_SHORT_SUPPORT_MESSAGE_LENGTH);\n\n        CallerIdentity caller = getCallerIdentity(who);\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        ActiveAdmin admin;\n        synchronized (getLockObject()) {\n            admin = getActiveAdminForUidLocked(who, caller.getUid());\n        }\n\n        synchronized (getLockObject()) {\n            if (!TextUtils.equals(admin.shortSupportMessage, message)) {\n                admin.shortSupportMessage = message;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SHORT_SUPPORT_MESSAGE)\n                .setAdmin(caller.getPackageName())\n                .write();\n    }\n\n    @Override\n    public CharSequence getShortSupportMessage(@Nullable ComponentName who,\n            String callerPackageName) {\n        if (!mHasFeature) {\n            return null;\n        }\n\n        CallerIdentity caller = getCallerIdentity(who);\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        ActiveAdmin admin;\n        synchronized (getLockObject()) {\n            admin = getActiveAdminForUidLocked(who, caller.getUid());\n        }\n        return admin.shortSupportMessage;\n    }\n\n    @Override\n    public void setLongSupportMessage(@NonNull ComponentName who, CharSequence message) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        message = PolicySizeVerifier.truncateIfLonger(message, MAX_LONG_SUPPORT_MESSAGE_LENGTH);\n\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminForUidLocked(who, caller.getUid());\n            if (!TextUtils.equals(admin.longSupportMessage, message)) {\n                admin.longSupportMessage = message;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_LONG_SUPPORT_MESSAGE)\n                .setAdmin(who)\n                .write();\n    }\n\n    @Override\n    public CharSequence getLongSupportMessage(@NonNull ComponentName who) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminForUidLocked(who, caller.getUid());\n            return admin.longSupportMessage;\n        }\n    }\n\n    @Override\n    public CharSequence getShortSupportMessageForUser(@NonNull ComponentName who, int userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"query support message for user\"));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n            if (admin != null) {\n                return admin.shortSupportMessage;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public CharSequence getLongSupportMessageForUser(@NonNull ComponentName who, int userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"query support message for user\"));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n            if (admin != null) {\n                return admin.longSupportMessage;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void setOrganizationColor(@NonNull ComponentName who, int color) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallingUser(isManagedProfile(caller.getUserId()));\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            admin.organizationColor = color;\n            saveSettingsLocked(caller.getUserId());\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_ORGANIZATION_COLOR)\n                .setAdmin(caller.getComponentName())\n                .write();\n    }\n\n    @Override\n    public void setOrganizationColorForUser(int color, int userId) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userId));\n        Preconditions.checkCallAuthorization(canManageUsers(caller));\n        Preconditions.checkCallAuthorization(isManagedProfile(userId), \"You can not \"\n                + \"set organization color outside a managed profile, userId = %d\", userId);\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            admin.organizationColor = color;\n            saveSettingsLocked(userId);\n        }\n    }\n\n    @Override\n    public int getOrganizationColor(@NonNull ComponentName who) {\n        if (!mHasFeature) {\n            return ActiveAdmin.DEF_ORGANIZATION_COLOR;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallingUser(isManagedProfile(caller.getUserId()));\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return admin.organizationColor;\n        }\n    }\n\n    @Override\n    public int getOrganizationColorForUser(int userHandle) {\n        if (!mHasFeature) {\n            return ActiveAdmin.DEF_ORGANIZATION_COLOR;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(isManagedProfile(userHandle), \"You can \"\n                + \"not get organization color outside a managed profile, userId = %d\", userHandle);\n\n        synchronized (getLockObject()) {\n            ActiveAdmin profileOwner = getProfileOwnerAdminLocked(userHandle);\n            return (profileOwner != null)\n                    ? profileOwner.organizationColor\n                    : ActiveAdmin.DEF_ORGANIZATION_COLOR;\n        }\n    }\n\n    @Override\n    public void setOrganizationName(@Nullable ComponentName who, String callerPackageName,\n            CharSequence text) {\n        if (!mHasFeature) {\n            return;\n        }\n        CallerIdentity caller = getCallerIdentity(who);\n\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isDeviceOwner(caller) || isProfileOwner(caller));\n\n        text = PolicySizeVerifier.truncateIfLonger(text, MAX_ORG_NAME_LENGTH);\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (!TextUtils.equals(admin.organizationName, text)) {\n                admin.organizationName = (text == null || text.length() == 0)\n                        ? null : text.toString();\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public CharSequence getOrganizationName(@Nullable ComponentName who, String callerPackageName) {\n        if (!mHasFeature) {\n            return null;\n        }\n        CallerIdentity caller = getCallerIdentity(who);\n\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallingUser(isManagedProfile(caller.getUserId()));\n        Preconditions.checkCallAuthorization(isDeviceOwner(caller) || isProfileOwner(caller));\n\n        ActiveAdmin admin;\n        synchronized (getLockObject()) {\n            admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n        }\n\n        return admin.organizationName;\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public CharSequence getDeviceOwnerOrganizationName() {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || canManageUsers(caller) || isFinancedDeviceOwner(caller));\n        synchronized (getLockObject()) {\n            final ActiveAdmin deviceOwnerAdmin = getDeviceOwnerAdminLocked();\n            return deviceOwnerAdmin == null ? null : deviceOwnerAdmin.organizationName;\n        }\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public CharSequence getOrganizationNameForUser(int userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(canManageUsers(caller));\n        Preconditions.checkCallAuthorization(isManagedProfile(userHandle),\n                \"You can not get organization name outside a managed profile, userId = %d\",\n                userHandle);\n\n        synchronized (getLockObject()) {\n            ActiveAdmin profileOwner = getProfileOwnerAdminLocked(userHandle);\n            return (profileOwner != null)\n                    ? profileOwner.organizationName\n                    : null;\n        }\n    }\n\n    @Override\n    public List<String> setMeteredDataDisabledPackages(ComponentName who, List<String> packageNames) {\n        Objects.requireNonNull(who);\n        Objects.requireNonNull(packageNames);\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller),\n                \"Admin %s does not own the profile\", caller.getComponentName());\n\n        if (!mHasFeature) {\n            return packageNames;\n        }\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            final List<String> excludedPkgs = removeInvalidPkgsForMeteredDataRestriction(\n                    caller.getUserId(), packageNames);\n\n            synchronized (getLockObject()) {\n                final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n                admin.meteredDisabledPackages = packageNames;\n                saveSettingsLocked(caller.getUserId());\n            }\n            pushMeteredDisabledPackages(caller.getUserId());\n            return excludedPkgs;\n        });\n    }\n\n    private Set<String> getMeteredDataRestrictionExemptPackages(int userId) {\n        final Set<String> exemptPkgs = new ArraySet<>();\n        for (String role: METERED_DATA_RESTRICTION_EXEMPT_ROLES) {\n            String pkg = getRoleHolderPackageNameOnUser(role, userId);\n            if (pkg != null) {\n                exemptPkgs.add(pkg);\n            }\n        }\n\n        return exemptPkgs;\n    }\n\n    private List<String> removeInvalidPkgsForMeteredDataRestriction(\n            int userId, List<String> pkgNames) {\n        final Set<String> exemptRolePkgs = getMeteredDataRestrictionExemptPackages(userId);\n        synchronized (getLockObject()) {\n            final Set<String> activeAdmins = getActiveAdminPackagesLocked(userId);\n            final List<String> excludedPkgs = new ArrayList<>();\n            for (int i = pkgNames.size() - 1; i >= 0; --i) {\n                final String pkgName = pkgNames.get(i);\n                // If the package is an active admin or exempt role, don't restrict it.\n                if (activeAdmins.contains(pkgName) || exemptRolePkgs.contains(pkgName)) {\n                    excludedPkgs.add(pkgName);\n                    continue;\n                }\n                // If the package doesn't exist, don't restrict it.\n                try {\n                    if (!mInjector.getIPackageManager().isPackageAvailable(pkgName, userId)) {\n                        excludedPkgs.add(pkgName);\n                    }\n                } catch (RemoteException e) {\n                    // Should not happen\n                }\n            }\n            pkgNames.removeAll(excludedPkgs);\n            return excludedPkgs;\n        }\n    }\n\n    @Override\n    public List<String> getMeteredDataDisabledPackages(ComponentName who) {\n        Objects.requireNonNull(who);\n\n        if (!mHasFeature) {\n            return new ArrayList<>();\n        }\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller),\n                \"Admin %s does not own the profile\", caller.getComponentName());\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            return admin.meteredDisabledPackages == null\n                    ? new ArrayList<>() : admin.meteredDisabledPackages;\n        }\n    }\n\n    @Override\n    public boolean isMeteredDataDisabledPackageForUser(ComponentName who,\n            String packageName, int userId) {\n        Objects.requireNonNull(who);\n\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"query restricted pkgs for a specific user\"));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userId);\n            if (admin != null && admin.meteredDisabledPackages != null) {\n                return admin.meteredDisabledPackages.contains(packageName);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void setProfileOwnerOnOrganizationOwnedDevice(ComponentName who, int userId,\n            boolean isProfileOwnerOnOrganizationOwnedDevice) {\n        if (!mHasFeature) {\n            return;\n        }\n        // As the caller is the system, it must specify the component name of the profile owner\n        // as a safety check.\n        Objects.requireNonNull(who);\n\n        final CallerIdentity caller = getCallerIdentity();\n        // Only adb or system apps with the right permission can mark a profile owner on\n        // organization-owned device.\n        if (!(isAdb(caller) || hasCallingPermission(permission.MARK_DEVICE_ORGANIZATION_OWNED)\n                || hasCallingPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS))) {\n            throw new SecurityException(\n                    \"Only the system can mark a profile owner of organization-owned device.\");\n        }\n        // Only a test admin can be unmarked as a profile owner on an organization-owned device.\n        synchronized (getLockObject()) {\n            if (!isProfileOwnerOnOrganizationOwnedDevice && !isAdminTestOnlyLocked(who, userId)) {\n                throw new SecurityException(\"Only a test admin can be unmarked as a \"\n                        + \"profile owner of organization-owned device.\");\n            }\n        }\n\n        if (isAdb(caller)) {\n            if (hasIncompatibleAccountsOrNonAdbNoLock(caller, userId, who)) {\n                throw new SecurityException(\n                        \"Can only be called from ADB if the device has no accounts.\");\n            }\n        } else {\n            if (hasUserSetupCompleted(UserHandle.USER_SYSTEM)) {\n                throw new IllegalStateException(\n                        \"Cannot mark profile owner as managing an organization-owned device after\"\n                                + \" set-up\");\n            }\n        }\n\n        // Grant access under lock.\n        synchronized (getLockObject()) {\n            setProfileOwnerOnOrganizationOwnedDeviceUncheckedLocked(who, userId,\n                    isProfileOwnerOnOrganizationOwnedDevice);\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void setProfileOwnerOnOrganizationOwnedDeviceUncheckedLocked(\n            ComponentName who, int userId, boolean isProfileOwnerOnOrganizationOwnedDevice) {\n        // Make sure that the user has a profile owner and that the specified\n        // component is the profile owner of that user.\n        if (!isProfileOwner(who, userId)) {\n            throw new IllegalArgumentException(String.format(\n                    \"Component %s is not a Profile Owner of user %d\",\n                    who.flattenToString(), userId));\n        }\n\n        Slogf.i(LOG_TAG, \"%s %s as profile owner on organization-owned device for user %d\",\n                isProfileOwnerOnOrganizationOwnedDevice ? \"Marking\" : \"Unmarking\",\n                who.flattenToString(), userId);\n\n        // First, set restriction on removing the profile.\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            // Clear restriction as user.\n            final UserHandle parentUser = mUserManager.getProfileParent(UserHandle.of(userId));\n            if (parentUser == null) {\n                throw new IllegalStateException(String.format(\"User %d is not a profile\", userId));\n            }\n\n            mUserManager.setUserRestriction(UserManager.DISALLOW_REMOVE_MANAGED_PROFILE,\n                    isProfileOwnerOnOrganizationOwnedDevice,\n                    parentUser);\n            if (mInjector.userManagerIsHeadlessSystemUserMode()) {\n                // For HSUM, additionally set this on user 0 to block ADB from removing the profile.\n                mUserManager.setUserRestriction(UserManager.DISALLOW_REMOVE_MANAGED_PROFILE,\n                        isProfileOwnerOnOrganizationOwnedDevice,\n                        UserHandle.SYSTEM);\n            }\n            mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_USER,\n                    isProfileOwnerOnOrganizationOwnedDevice,\n                    parentUser);\n        });\n\n        // setProfileOwnerOfOrganizationOwnedDevice will trigger writing of the profile owner\n        // data, no need to do it manually.\n        mOwners.setProfileOwnerOfOrganizationOwnedDevice(userId,\n                isProfileOwnerOnOrganizationOwnedDevice);\n    }\n\n    private void pushMeteredDisabledPackages(int userId) {\n        wtfIfInLock();\n        mInjector.getNetworkPolicyManagerInternal().setMeteredRestrictedPackages(\n                getMeteredDisabledPackages(userId), userId);\n    }\n\n    private Set<String> getMeteredDisabledPackages(int userId) {\n        synchronized (getLockObject()) {\n            final Set<String> restrictedPkgs = new ArraySet<>();\n            final ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userId);\n            if (admin != null && admin.meteredDisabledPackages != null) {\n                restrictedPkgs.addAll(admin.meteredDisabledPackages);\n            }\n\n            return restrictedPkgs;\n        }\n    }\n\n    @Override\n    public void setAffiliationIds(ComponentName admin, List<String> ids) {\n        if (!mHasFeature) {\n            return;\n        }\n        if (ids == null) {\n            throw new IllegalArgumentException(\"ids must not be null\");\n        }\n        for (String id : ids) {\n            Preconditions.checkArgument(!TextUtils.isEmpty(id), \"ids must not have empty string\");\n            PolicySizeVerifier.enforceMaxStringLength(id, \"affiliation id\");\n        }\n\n        final Set<String> affiliationIds = new ArraySet<>(ids);\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        final int callingUserId = caller.getUserId();\n\n        synchronized (getLockObject()) {\n            getUserData(callingUserId).mAffiliationIds = affiliationIds;\n            saveSettingsLocked(callingUserId);\n            mStateCache.setHasAffiliationWithDevice(callingUserId,\n                    isUserAffiliatedWithDeviceLocked(callingUserId));\n            if (callingUserId == UserHandle.USER_SYSTEM) {\n                resetAffiliationCacheLocked();\n            } else if (callingUserId != UserHandle.USER_SYSTEM && isDeviceOwner(admin,\n                    callingUserId)) {\n                // Affiliation ids specified by the device owner are additionally stored in\n                // UserHandle.USER_SYSTEM's DevicePolicyData.\n                getUserData(UserHandle.USER_SYSTEM).mAffiliationIds = affiliationIds;\n                mStateCache.setHasAffiliationWithDevice(UserHandle.USER_SYSTEM, true);\n                saveSettingsLocked(UserHandle.USER_SYSTEM);\n            }\n\n            // Affiliation status for any user, not just the calling user, might have changed.\n            // The device owner user will still be affiliated after changing its affiliation ids,\n            // but as a result of that other users might become affiliated or un-affiliated.\n            maybePauseDeviceWideLoggingLocked();\n            maybeResumeDeviceWideLoggingLocked();\n            maybeClearLockTaskPolicyLocked();\n            updateAdminCanGrantSensorsPermissionCache(callingUserId);\n        }\n    }\n\n    private void resetAffiliationCacheLocked() {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo user : mUserManager.getUsers()) {\n                mStateCache.setHasAffiliationWithDevice(user.id,\n                        isUserAffiliatedWithDeviceLocked(user.id));\n            }\n        });\n    }\n\n    @Override\n    public List<String> getAffiliationIds(ComponentName admin) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n\n        Objects.requireNonNull(admin);\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            return new ArrayList<String>(getUserData(caller.getUserId()).mAffiliationIds);\n        }\n    }\n\n    @Override\n    public boolean isCallingUserAffiliated() {\n        if (!mHasFeature) {\n            return false;\n        }\n\n        synchronized (getLockObject()) {\n            return isUserAffiliatedWithDeviceLocked(mInjector.userHandleGetCallingUserId());\n        }\n    }\n\n    @Override\n    public boolean isAffiliatedUser(@UserIdInt int userId) {\n        if (!mHasFeature) {\n            return false;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        return isUserAffiliatedWithDevice(userId);\n    }\n\n    private boolean isUserAffiliatedWithDevice(@UserIdInt int userId) {\n        synchronized (getLockObject()) {\n            return isUserAffiliatedWithDeviceLocked(userId);\n        }\n    }\n\n    private boolean isUserAffiliatedWithDeviceLocked(@UserIdInt int userId) {\n        if (!mOwners.hasDeviceOwner()) {\n            return false;\n        }\n        if (userId == UserHandle.USER_SYSTEM) {\n            // The system user is always affiliated in a DO device,\n            // even if in headless system user mode.\n            return true;\n        }\n        if (userId == mOwners.getDeviceOwnerUserId()) {\n            // The user that the DO is installed on is always affiliated with the device.\n            return true;\n        }\n\n        final ComponentName profileOwner = getProfileOwnerAsUser(userId);\n        if (profileOwner == null) {\n            return false;\n        }\n\n        final Set<String> userAffiliationIds = getUserData(userId).mAffiliationIds;\n        final Set<String> deviceAffiliationIds =\n                getUserData(UserHandle.USER_SYSTEM).mAffiliationIds;\n        for (String id : userAffiliationIds) {\n            if (deviceAffiliationIds.contains(id)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private boolean areAllUsersAffiliatedWithDeviceLocked() {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            final List<UserInfo> userInfos = mUserManager.getAliveUsers();\n            for (int i = 0; i < userInfos.size(); i++) {\n                int userId = userInfos.get(i).id;\n                if (!isUserAffiliatedWithDeviceLocked(userId)) {\n                    Slogf.d(LOG_TAG, \"User id \" + userId + \" not affiliated.\");\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n    private @UserIdInt int getSecurityLoggingEnabledUser() {\n        synchronized (getLockObject()) {\n            if (mOwners.hasDeviceOwner()) {\n                return UserHandle.USER_ALL;\n            }\n        }\n        // TODO: Add check for permission-based\n        return getOrganizationOwnedProfileUserId();\n    }\n\n    @Override\n    public void setSecurityLoggingEnabled(ComponentName who, String packageName,\n            boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity(who, packageName);\n\n        EnforcingAdmin admin = enforcePermissionAndGetEnforcingAdmin(\n                who,\n                MANAGE_DEVICE_POLICY_SECURITY_LOGGING,\n                caller.getPackageName(),\n                caller.getUserId());\n        if (enabled) {\n            mDevicePolicyEngine.setGlobalPolicy(\n                    PolicyDefinition.SECURITY_LOGGING,\n                    admin,\n                    new BooleanPolicyValue(true));\n        } else {\n            mDevicePolicyEngine.removeGlobalPolicy(\n                    PolicyDefinition.SECURITY_LOGGING,\n                    admin);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SECURITY_LOGGING_ENABLED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(enabled)\n                .write();\n    }\n\n    @Override\n    public boolean isSecurityLoggingEnabled(ComponentName admin, String packageName) {\n        if (!mHasFeature) {\n            return false;\n        }\n\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n        if (isSystemUid(caller)) {\n            // Settings uses this for privacy transparency.\n            // TODO: create a separate @hidden API for settings.\n            return mInjector.securityLogGetLoggingEnabledProperty();\n        }\n\n        final EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                admin,\n                MANAGE_DEVICE_POLICY_SECURITY_LOGGING,\n                caller.getPackageName(),\n                caller.getUserId());\n        final Boolean policy = mDevicePolicyEngine.getGlobalPolicySetByAdmin(\n                PolicyDefinition.SECURITY_LOGGING, enforcingAdmin);\n        return Boolean.TRUE.equals(policy);\n    }\n\n    private void recordSecurityLogRetrievalTime() {\n        synchronized (getLockObject()) {\n            final long currentTime = System.currentTimeMillis();\n            DevicePolicyData policyData = getUserData(UserHandle.USER_SYSTEM);\n            if (currentTime > policyData.mLastSecurityLogRetrievalTime) {\n                policyData.mLastSecurityLogRetrievalTime = currentTime;\n                saveSettingsLocked(UserHandle.USER_SYSTEM);\n            }\n        }\n    }\n\n    @Override\n    public ParceledListSlice<SecurityEvent> retrievePreRebootSecurityLogs(ComponentName admin,\n            String packageName) {\n        if (!mHasFeature) {\n            return null;\n        }\n\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n        if (admin != null) {\n            Preconditions.checkCallAuthorization(\n                    isProfileOwnerOfOrganizationOwnedDevice(caller)\n                            || isDefaultDeviceOwner(caller));\n        } else {\n            // A delegate app passes a null admin component, which is expected\n            Preconditions.checkCallAuthorization(\n                    isCallerDelegate(caller, DELEGATION_SECURITY_LOGGING));\n        }\n\n        synchronized (getLockObject()) {\n            Preconditions.checkCallAuthorization(isOrganizationOwnedDeviceWithManagedProfile()\n                    || areAllUsersAffiliatedWithDeviceLocked());\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.RETRIEVE_PRE_REBOOT_SECURITY_LOGS)\n                .setAdmin(caller.getPackageName())\n                .write();\n\n        if (!mContext.getResources().getBoolean(R.bool.config_supportPreRebootSecurityLogs)\n                || !mInjector.securityLogGetLoggingEnabledProperty()) {\n            return null;\n        }\n\n        recordSecurityLogRetrievalTime();\n        ArrayList<SecurityEvent> output = new ArrayList<SecurityEvent>();\n        try {\n            SecurityLog.readPreviousEvents(output);\n            int enabledUser = getSecurityLoggingEnabledUser();\n            if (enabledUser != UserHandle.USER_ALL) {\n                SecurityLog.redactEvents(output, enabledUser);\n            }\n            return new ParceledListSlice<SecurityEvent>(output);\n        } catch (IOException e) {\n            Slogf.w(LOG_TAG, \"Fail to read previous events\" , e);\n            return new ParceledListSlice<SecurityEvent>(Collections.emptyList());\n        }\n    }\n\n    @Override\n    public ParceledListSlice<SecurityEvent> retrieveSecurityLogs(ComponentName admin,\n            String packageName) {\n        if (!mHasFeature) {\n            return null;\n        }\n\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n\n        EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                admin,\n                MANAGE_DEVICE_POLICY_SECURITY_LOGGING,\n                caller.getPackageName(),\n                caller.getUserId());\n\n        synchronized (getLockObject()) {\n            Preconditions.checkCallAuthorization(isOrganizationOwnedDeviceWithManagedProfile()\n                    || areAllUsersAffiliatedWithDeviceLocked());\n        }\n\n        Boolean policy = mDevicePolicyEngine.getGlobalPolicySetByAdmin(\n                PolicyDefinition.SECURITY_LOGGING, enforcingAdmin);\n\n        if (!Boolean.TRUE.equals(policy)) {\n            Slogf.e(LOG_TAG, \"%s hasn't enabled security logging but tries to retrieve logs\",\n                    caller.getPackageName());\n            return null;\n        }\n\n        recordSecurityLogRetrievalTime();\n\n        List<SecurityEvent> logs = mSecurityLogMonitor.retrieveLogs();\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.RETRIEVE_SECURITY_LOGS)\n                .setAdmin(caller.getPackageName())\n                .write();\n        return logs != null ? new ParceledListSlice<>(logs) : null;\n    }\n\n    @Override\n    public void setAuditLogEnabled(String callingPackage, boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity(callingPackage);\n\n        EnforcingAdmin admin = enforcePermissionAndGetEnforcingAdmin(\n                null /* admin */,\n                MANAGE_DEVICE_POLICY_AUDIT_LOGGING,\n                caller.getPackageName(),\n                caller.getUserId());\n        if (enabled) {\n            mDevicePolicyEngine.setGlobalPolicy(\n                    PolicyDefinition.AUDIT_LOGGING,\n                    admin,\n                    new BooleanPolicyValue(true));\n        } else {\n            mDevicePolicyEngine.removeGlobalPolicy(\n                    PolicyDefinition.AUDIT_LOGGING,\n                    admin);\n            mSecurityLogMonitor.setAuditLogEventsCallback(caller.getUid(), null /* callback */);\n        }\n    }\n\n    @Override\n    public boolean isAuditLogEnabled(String callingPackage) {\n        if (!mHasFeature) {\n            return false;\n        }\n\n        final CallerIdentity caller = getCallerIdentity(callingPackage);\n        EnforcingAdmin admin = enforcePermissionAndGetEnforcingAdmin(\n                null /* admin */,\n                MANAGE_DEVICE_POLICY_AUDIT_LOGGING,\n                caller.getPackageName(),\n                caller.getUserId());\n\n        Boolean policy = mDevicePolicyEngine.getGlobalPolicySetByAdmin(\n                PolicyDefinition.AUDIT_LOGGING, admin);\n\n        return Boolean.TRUE.equals(policy);\n    }\n\n    @Override\n    public void setAuditLogEventsCallback(String callingPackage, IAuditLogEventsCallback callback) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        final CallerIdentity caller = getCallerIdentity(callingPackage);\n        EnforcingAdmin admin = enforcePermissionAndGetEnforcingAdmin(\n                null /* admin */,\n                MANAGE_DEVICE_POLICY_AUDIT_LOGGING,\n                caller.getPackageName(),\n                caller.getUserId());\n\n        Boolean policy = mDevicePolicyEngine.getGlobalPolicySetByAdmin(\n                PolicyDefinition.AUDIT_LOGGING, admin);\n\n        if (!Boolean.TRUE.equals(policy)) {\n            throw new IllegalStateException(\n                    \"Managing app has to enable audit log before setting events callback\");\n        }\n\n        mSecurityLogMonitor.setAuditLogEventsCallback(caller.getUid(), callback);\n    }\n\n    @Override\n    public long forceSecurityLogs() {\n        Preconditions.checkCallAuthorization(isAdb(getCallerIdentity())\n                        || hasCallingOrSelfPermission(permission.FORCE_DEVICE_POLICY_MANAGER_LOGS),\n                \"Caller must be shell or hold FORCE_DEVICE_POLICY_MANAGER_LOGS to call \"\n                        + \"forceSecurityLogs\");\n        if (!mInjector.securityLogGetLoggingEnabledProperty()) {\n            throw new IllegalStateException(\"logging is not available\");\n        }\n        return mSecurityLogMonitor.forceLogs();\n    }\n\n    @Override\n    public boolean isUninstallInQueue(final String packageName) {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n\n        UserPackage packageUserPair = UserPackage.of(caller.getUserId(), packageName);\n        synchronized (getLockObject()) {\n            return mPackagesToRemove.contains(packageUserPair);\n        }\n    }\n\n    @Override\n    public void uninstallPackageWithActiveAdmins(final String packageName) {\n        Preconditions.checkArgument(!TextUtils.isEmpty(packageName));\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n\n        final int userId = caller.getUserId();\n        enforceUserUnlocked(userId);\n\n        final ComponentName profileOwner = getProfileOwnerAsUser(userId);\n        if (profileOwner != null && packageName.equals(profileOwner.getPackageName())) {\n            throw new IllegalArgumentException(\"Cannot uninstall a package with a profile owner\");\n        }\n\n        final ComponentName deviceOwner = getDeviceOwnerComponent(/* callingUserOnly= */ false);\n        if (getDeviceOwnerUserId() == userId && deviceOwner != null\n                && packageName.equals(deviceOwner.getPackageName())) {\n            throw new IllegalArgumentException(\"Cannot uninstall a package with a device owner\");\n        }\n\n        final UserPackage packageUserPair = UserPackage.of(userId, packageName);\n        synchronized (getLockObject()) {\n            mPackagesToRemove.add(packageUserPair);\n        }\n\n        // All active admins on the user.\n        final List<ComponentName> allActiveAdmins = getActiveAdmins(userId);\n\n        // Active admins in the target package.\n        final List<ComponentName> packageActiveAdmins = new ArrayList<>();\n        if (allActiveAdmins != null) {\n            for (ComponentName activeAdmin : allActiveAdmins) {\n                if (packageName.equals(activeAdmin.getPackageName())) {\n                    packageActiveAdmins.add(activeAdmin);\n                    removeActiveAdmin(activeAdmin, userId);\n                }\n            }\n        }\n        if (packageActiveAdmins.size() == 0) {\n            startUninstallIntent(packageName, userId);\n        } else {\n            mHandler.postDelayed(new Runnable() {\n                @Override\n                public void run() {\n                    for (ComponentName activeAdmin : packageActiveAdmins) {\n                        removeAdminArtifacts(activeAdmin, userId);\n                    }\n                    startUninstallIntent(packageName, userId);\n                }\n            }, DEVICE_ADMIN_DEACTIVATE_TIMEOUT); // Start uninstall after timeout anyway.\n        }\n    }\n\n    @Override\n    public boolean isDeviceProvisioned() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(caller));\n\n        synchronized (getLockObject()) {\n            return getUserDataUnchecked(UserHandle.USER_SYSTEM).mUserSetupComplete;\n        }\n    }\n\n    private boolean isCurrentUserDemo() {\n        if (UserManager.isDeviceInDemoMode(mContext)) {\n            final int userId = mInjector.userHandleGetCallingUserId();\n            return mInjector.binderWithCleanCallingIdentity(\n                    () -> mUserManager.getUserInfo(userId).isDemo());\n        }\n        return false;\n    }\n\n    private void removePackageIfRequired(final String packageName, final int userId) {\n        if (!packageHasActiveAdmins(packageName, userId)) {\n            // Will not do anything if uninstall was not requested or was already started.\n            startUninstallIntent(packageName, userId);\n        }\n    }\n\n    private void startUninstallIntent(final String packageName, final int userId) {\n        final UserPackage packageUserPair = UserPackage.of(userId, packageName);\n        synchronized (getLockObject()) {\n            if (!mPackagesToRemove.contains(packageUserPair)) {\n                // Do nothing if uninstall was not requested or was already started.\n                return;\n            }\n            mPackagesToRemove.remove(packageUserPair);\n        }\n        if (!isPackageInstalledForUser(packageName, userId)) {\n            // Package does not exist. Nothing to do.\n            return;\n        }\n\n        try { // force stop the package before uninstalling\n            mInjector.getIActivityManager().forceStopPackage(packageName, userId);\n        } catch (RemoteException re) {\n            Slogf.e(LOG_TAG, \"Failure talking to ActivityManager while force stopping package\");\n        }\n        final Uri packageURI = Uri.parse(\"package:\" + packageName);\n        final Intent uninstallIntent = new Intent(Intent.ACTION_UNINSTALL_PACKAGE, packageURI);\n        uninstallIntent.setFlags(FLAG_ACTIVITY_NEW_TASK);\n        mContext.startActivityAsUser(uninstallIntent, UserHandle.of(userId));\n    }\n\n    /**\n     * Removes the admin from the policy. Ideally called after the admin's\n     * {@link DeviceAdminReceiver#onDisabled(Context, Intent)} has been successfully completed.\n     *\n     * @param adminReceiver The admin to remove\n     * @param userHandle The user for which this admin has to be removed.\n     */\n    private void removeAdminArtifacts(final ComponentName adminReceiver, final int userHandle) {\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n            if (admin == null) {\n                return;\n            }\n            final DevicePolicyData policy = getUserData(userHandle);\n            final boolean doProxyCleanup = admin.info.usesPolicy(\n                    DeviceAdminInfo.USES_POLICY_SETS_GLOBAL_PROXY);\n            policy.mAdminList.remove(admin);\n            policy.mAdminMap.remove(adminReceiver);\n            policy.validatePasswordOwner();\n            if (doProxyCleanup) {\n                resetGlobalProxyLocked(policy);\n            }\n            pushActiveAdminPackagesLocked(userHandle);\n            saveSettingsLocked(userHandle);\n            updateMaximumTimeToLockLocked(userHandle);\n\n            Slogf.d(LOG_TAG,\n                    \"Removing device admin \" + adminReceiver + \" from user \" + userHandle);\n            logStackTrace(\"removeAdminArtifacts\");\n\n            policy.mRemovingAdmins.remove(adminReceiver);\n            Slogf.d(LOG_TAG, \"Current state of DevicePolicyData#mRemovingAdmins for user \"\n                    + userHandle + \": \" + policy.mRemovingAdmins);\n\n            Slogf.i(LOG_TAG, \"Device admin \" + adminReceiver + \" removed from user \" + userHandle);\n        }\n        pushMeteredDisabledPackages(userHandle);\n    }\n\n    @Override\n    public void setDeviceProvisioningConfigApplied() {\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            policy.mDeviceProvisioningConfigApplied = true;\n            saveSettingsLocked(UserHandle.USER_SYSTEM);\n        }\n    }\n\n    @Override\n    public boolean isDeviceProvisioningConfigApplied() {\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            return policy.mDeviceProvisioningConfigApplied;\n        }\n    }\n\n    /**\n     * Force update internal persistent state from Settings.Secure.USER_SETUP_COMPLETE.\n     *\n     * It's added for testing only. Please use this API carefully if it's used by other system app\n     * and bare in mind Settings.Secure.USER_SETUP_COMPLETE can be modified by user and other system\n     * apps.\n     */\n    @Override\n    public void forceUpdateUserSetupComplete(@UserIdInt int userId) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        boolean isUserCompleted = mInjector.settingsSecureGetIntForUser(\n                USER_SETUP_COMPLETE, 0, userId) != 0;\n        DevicePolicyData policy = getUserData(userId);\n        policy.mUserSetupComplete = isUserCompleted;\n        mStateCache.setDeviceProvisioned(isUserCompleted);\n        synchronized (getLockObject()) {\n            saveSettingsLocked(userId);\n        }\n    }\n\n    @Override\n    public void setBackupServiceEnabled(ComponentName admin, boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isProfileOwner(caller) || isFinancedDeviceOwner(caller));\n\n        // Backup service has to be enabled on the main user in order for it to be enabled on\n        // secondary users.\n        if (isDeviceOwner(caller) && getHeadlessDeviceOwnerModeForDeviceOwner()\n                == HEADLESS_DEVICE_OWNER_MODE_SINGLE_USER) {\n            toggleBackupServiceActive(UserHandle.USER_SYSTEM, enabled);\n        }\n\n        toggleBackupServiceActive(caller.getUserId(), enabled);\n\n        if (SecurityLog.isLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_BACKUP_SERVICE_TOGGLED,\n                    caller.getPackageName(), caller.getUserId(), enabled ? 1 : 0);\n        }\n    }\n\n    @Override\n    public boolean isBackupServiceEnabled(ComponentName admin) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isProfileOwner(caller) || isFinancedDeviceOwner(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            synchronized (getLockObject()) {\n                try {\n                    IBackupManager ibm = mInjector.getIBackupManager();\n                    return ibm != null && ibm.isBackupServiceActive(caller.getUserId());\n                } catch (RemoteException e) {\n                    throw new IllegalStateException(\"Failed requesting backup service state.\", e);\n                }\n            }\n        });\n    }\n\n    @Override\n    public boolean bindDeviceAdminServiceAsUser(\n            @NonNull ComponentName admin, @NonNull IApplicationThread caller,\n            @Nullable IBinder activtiyToken, @NonNull Intent serviceIntent,\n            @NonNull IServiceConnection connection, long flags, @UserIdInt int targetUserId) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(admin);\n        Objects.requireNonNull(caller);\n        Objects.requireNonNull(serviceIntent);\n        Preconditions.checkArgument(\n                serviceIntent.getComponent() != null || serviceIntent.getPackage() != null,\n                \"Service intent must be explicit (with a package name or component): \"\n                        + serviceIntent);\n        Objects.requireNonNull(connection);\n        Preconditions.checkArgument(mInjector.userHandleGetCallingUserId() != targetUserId,\n                \"target user id must be different from the calling user id\");\n\n        if (!getBindDeviceAdminTargetUsers(admin).contains(UserHandle.of(targetUserId))) {\n            throw new SecurityException(\"Not allowed to bind to target user id\");\n        }\n\n        final String targetPackage;\n        synchronized (getLockObject()) {\n            targetPackage = getOwnerPackageNameForUserLocked(targetUserId);\n        }\n\n        final long callingIdentity = mInjector.binderClearCallingIdentity();\n        try {\n            // Validate and sanitize the incoming service intent.\n            final Intent sanitizedIntent =\n                    createCrossUserServiceIntent(serviceIntent, targetPackage, targetUserId);\n            if (sanitizedIntent == null) {\n                // Fail, cannot lookup the target service.\n                return false;\n            }\n            // Ask ActivityManager to bind it. Notice that we are binding the service with the\n            // caller app instead of DevicePolicyManagerService.\n            return mInjector.getIActivityManager().bindService(\n                    caller, activtiyToken, serviceIntent,\n                    serviceIntent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                    connection, flags, mContext.getOpPackageName(),\n                    targetUserId) != 0;\n        } catch (RemoteException ex) {\n            // Same process, should not happen.\n        } finally {\n            mInjector.binderRestoreCallingIdentity(callingIdentity);\n        }\n\n        // Failed to bind.\n        return false;\n    }\n\n    @Override\n    public @NonNull List<UserHandle> getBindDeviceAdminTargetUsers(@NonNull ComponentName admin) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n        Objects.requireNonNull(admin);\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            final int callingUserId = caller.getUserId();\n            return mInjector.binderWithCleanCallingIdentity(() -> {\n                ArrayList<UserHandle> targetUsers = new ArrayList<>();\n                if (!isDeviceOwner(admin, callingUserId)) {\n                    // Profile owners can only bind to the device owner.\n                    if (canUserBindToDeviceOwnerLocked(callingUserId)) {\n                        targetUsers.add(UserHandle.of(mOwners.getDeviceOwnerUserId()));\n                    }\n                } else {\n                    // Caller is the device owner: Look for profile owners that it can bind to.\n                    final List<UserInfo> userInfos = mUserManager.getAliveUsers();\n                    for (int i = 0; i < userInfos.size(); i++) {\n                        final int userId = userInfos.get(i).id;\n                        if (userId != callingUserId && canUserBindToDeviceOwnerLocked(userId)) {\n                            targetUsers.add(UserHandle.of(userId));\n                        }\n                    }\n                }\n\n                return targetUsers;\n            });\n        }\n    }\n\n    private boolean canUserBindToDeviceOwnerLocked(int userId) {\n        // There has to be a device owner, under another user id.\n        if (!mOwners.hasDeviceOwner() || userId == mOwners.getDeviceOwnerUserId()) {\n            return false;\n        }\n\n        // The user must have a profile owner that belongs to the same package as the device owner.\n        if (!mOwners.hasProfileOwner(userId) || !TextUtils.equals(\n                mOwners.getDeviceOwnerPackageName(), mOwners.getProfileOwnerPackage(userId))) {\n            return false;\n        }\n\n        // The user must be affiliated.\n        return isUserAffiliatedWithDeviceLocked(userId);\n    }\n\n    private boolean hasIncompatibleAccountsOnAnyUser() {\n        if (mHasIncompatibleAccounts == null) {\n            // Hasn't loaded for the first time yet - assume the worst\n            return true;\n        }\n\n        for (boolean hasIncompatible : mHasIncompatibleAccounts.values()) {\n            if (hasIncompatible) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private boolean hasIncompatibleAccounts(int userId) {\n        return mHasIncompatibleAccounts == null || mHasIncompatibleAccounts.getOrDefault(\n                userId, /* default= */ false);\n    }\n\n    /**\n     * Return true if a given user has any accounts that'll prevent installing a device or profile\n     * owner {@code owner}.\n     * - If the user has no accounts, then return false.\n     * - Otherwise, if the owner is unknown (== null), or is not test-only, then return true.\n     * - Otherwise, if there's any account that does not have ..._ALLOWED, or does have\n     *   ..._DISALLOWED, return true.\n     * - Otherwise return false.\n     *\n     * If the caller is *not* ADB, it also returns true.  The returned value shouldn't be used\n     * when the caller is not ADB.\n     *\n     * DO NOT CALL IT WITH THE DPMS LOCK HELD.\n     */\n    private boolean hasIncompatibleAccountsOrNonAdbNoLock(CallerIdentity caller,\n            int userId, @Nullable ComponentName owner) {\n        if (!isAdb(caller)) {\n            return true;\n        }\n        wtfIfInLock();\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            AccountManager am =\n                    mContext.createContextAsUser(UserHandle.of(userId), /* flags= */ 0)\n                            .getSystemService(AccountManager.class);\n            Account[] accounts = am.getAccounts();\n            if (accounts.length == 0) {\n                return false;\n            }\n            synchronized (getLockObject()) {\n                if (owner == null || !isAdminTestOnlyLocked(owner, userId)) {\n                    Slogf.w(LOG_TAG,\n                            \"Non test-only owner can't be installed with existing accounts.\");\n                    return true;\n                }\n            }\n\n            boolean compatible = !hasIncompatibleAccounts(userId);\n            if (compatible) {\n                Slogf.w(LOG_TAG, \"All accounts are compatible\");\n            } else {\n                Slogf.e(LOG_TAG, \"Found incompatible accounts\");\n            }\n            return !compatible;\n        });\n    }\n\n    ThreadPoolExecutor calculateHasIncompatibleAccountsExecutor = new ThreadPoolExecutor(\n            1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>());\n\n    @Override\n    public void calculateHasIncompatibleAccounts() {\n        if (calculateHasIncompatibleAccountsExecutor.getQueue().size() > 1) {\n            return;\n        }\n        new CalculateHasIncompatibleAccountsTask().executeOnExecutor(\n                calculateHasIncompatibleAccountsExecutor);\n    }\n\n    @Nullable\n    private volatile Map<Integer, Boolean> mHasIncompatibleAccounts;\n\n    class CalculateHasIncompatibleAccountsTask extends AsyncTask<\n            Void, Void, Map<Integer, Boolean>> {\n        private static final String[] FEATURE_ALLOW =\n                {DevicePolicyManager.ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED};\n        private static final String[] FEATURE_DISALLOW =\n                {DevicePolicyManager.ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED};\n\n        @Override\n        protected Map<Integer, Boolean> doInBackground(Void... args) {\n            List<UserInfo> users = mUserManagerInternal.getUsers(/* excludeDying= */ true);\n            Map<Integer, Boolean> results = new HashMap<>();\n            for (UserInfo userInfo : users) {\n                results.put(userInfo.id, userHasIncompatibleAccounts(userInfo.id));\n            }\n\n            return results;\n        }\n\n        private boolean userHasIncompatibleAccounts(int id) {\n            AccountManager am = mContext.createContextAsUser(UserHandle.of(id), /* flags= */ 0)\n                    .getSystemService(AccountManager.class);\n            Account[] accounts = am.getAccounts();\n\n            for (Account account : accounts) {\n                if (hasAccountFeatures(am, account, FEATURE_DISALLOW)) {\n                    return true;\n                }\n                if (!hasAccountFeatures(am, account, FEATURE_ALLOW)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        @Override\n        protected void onPostExecute(Map<Integer, Boolean> results) {\n            mHasIncompatibleAccounts = Collections.unmodifiableMap(results);\n\n            Slogf.i(LOG_TAG, \"Finished calculating hasIncompatibleAccountsTask\");\n        }\n\n        private static boolean hasAccountFeatures(AccountManager am, Account account,\n                String[] features) {\n            try {\n                return am.hasFeatures(account, features, null, null)\n                        .getResult(30, TimeUnit.SECONDS);\n            } catch (Exception e) {\n                Slogf.w(LOG_TAG, \"Failed to get account feature\", e);\n                return false;\n            }\n        }\n    }\n\n    private boolean isAdb(CallerIdentity caller) {\n        return isShellUid(caller) || isRootUid(caller);\n    }\n\n    @Override\n    public void setNetworkLoggingEnabled(@Nullable ComponentName admin,\n            @NonNull String packageName, boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n        final boolean isManagedProfileOwner = isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId());\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isDefaultDeviceOwner(caller) || isManagedProfileOwner))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_NETWORK_LOGGING)));\n\n        synchronized (getLockObject()) {\n            if (enabled == isNetworkLoggingEnabledInternalLocked()) {\n                // already in the requested state\n                return;\n            }\n            final ActiveAdmin activeAdmin = getDeviceOrProfileOwnerAdminLocked(caller.getUserId());\n            activeAdmin.isNetworkLoggingEnabled = enabled;\n            if (!enabled) {\n                activeAdmin.numNetworkLoggingNotifications = 0;\n                activeAdmin.lastNetworkLoggingNotificationTimeMs = 0;\n            }\n            saveSettingsLocked(caller.getUserId());\n            setNetworkLoggingActiveInternal(enabled);\n\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_NETWORK_LOGGING_ENABLED)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ admin == null)\n                    .setInt(enabled ? 1 : 0)\n                    .setStrings(isManagedProfileOwner\n                            ? LOG_TAG_PROFILE_OWNER : LOG_TAG_DEVICE_OWNER)\n                    .write();\n        }\n    }\n\n    private void setNetworkLoggingActiveInternal(boolean active) {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            boolean shouldSendNotification = false;\n            synchronized (getLockObject()) {\n                if (active) {\n                    if (mNetworkLogger == null) {\n                        final int affectedUserId = getNetworkLoggingAffectedUser();\n                        mNetworkLogger = new NetworkLogger(this,\n                                mInjector.getPackageManagerInternal(),\n                                affectedUserId == UserHandle.USER_SYSTEM\n                                        ? UserHandle.USER_ALL : affectedUserId);\n                    }\n                    if (!mNetworkLogger.startNetworkLogging()) {\n                        mNetworkLogger = null;\n                        Slogf.wtf(LOG_TAG, \"Network logging could not be started due to the logging\"\n                                + \" service not being available yet.\");\n                    }\n                    maybePauseDeviceWideLoggingLocked();\n                    shouldSendNotification = shouldSendNetworkLoggingNotificationLocked();\n                } else {\n                    if (mNetworkLogger != null && !mNetworkLogger.stopNetworkLogging()) {\n                        Slogf.wtf(LOG_TAG, \"Network logging could not be stopped due to the logging\"\n                                + \" service not being available yet.\");\n                    }\n                    mNetworkLogger = null;\n                }\n            }\n            if (active) {\n                if (shouldSendNotification) {\n                    mHandler.post(() -> handleSendNetworkLoggingNotification());\n                }\n            } else {\n                mHandler.post(() -> handleCancelNetworkLoggingNotification());\n            }\n        });\n    }\n\n    private @UserIdInt int getNetworkLoggingAffectedUser() {\n        synchronized (getLockObject()) {\n            if (mOwners.hasDeviceOwner()) {\n                return mOwners.getDeviceOwnerUserId();\n            } else {\n                return mInjector.binderWithCleanCallingIdentity(\n                        () -> getManagedUserId());\n            }\n        }\n    }\n\n    private ActiveAdmin getNetworkLoggingControllingAdminLocked() {\n        int affectedUserId = getNetworkLoggingAffectedUser();\n        if (affectedUserId < 0) {\n            return null;\n        }\n        return getDeviceOrProfileOwnerAdminLocked(affectedUserId);\n    }\n\n    @Override\n    public long forceNetworkLogs() {\n        Preconditions.checkCallAuthorization(isAdb(getCallerIdentity())\n                || hasCallingOrSelfPermission(permission.FORCE_DEVICE_POLICY_MANAGER_LOGS),\n                \"Caller must be shell or hold FORCE_DEVICE_POLICY_MANAGER_LOGS to call \"\n                        + \"forceNetworkLogs\");\n        synchronized (getLockObject()) {\n            if (!isNetworkLoggingEnabledInternalLocked()) {\n                throw new IllegalStateException(\"logging is not available\");\n            }\n            if (mNetworkLogger != null) {\n                return mInjector.binderWithCleanCallingIdentity(\n                        () -> mNetworkLogger.forceBatchFinalization());\n            }\n            return 0;\n        }\n    }\n\n    /** Pauses security and network logging if there are unaffiliated users on the device */\n    @GuardedBy(\"getLockObject()\")\n    private void maybePauseDeviceWideLoggingLocked() {\n        if (!areAllUsersAffiliatedWithDeviceLocked()) {\n            if (mOwners.hasDeviceOwner()) {\n                Slogf.i(LOG_TAG, \"There are unaffiliated users, network logging will be \"\n                        + \"paused if enabled.\");\n                if (mNetworkLogger != null) {\n                    mNetworkLogger.pause();\n                }\n            }\n            // TODO: We need to also enable this when someone is managing using permission\n            if (!isOrganizationOwnedDeviceWithManagedProfile()) {\n                Slogf.i(LOG_TAG,\n                        \"Not org-owned managed profile device, security logging will be \"\n                                + \"paused if enabled.\");\n                mSecurityLogMonitor.pause();\n            }\n        }\n    }\n\n    /** Resumes security and network logging (if they are enabled) if all users are affiliated */\n    @GuardedBy(\"getLockObject()\")\n    private void maybeResumeDeviceWideLoggingLocked() {\n        boolean allUsersAffiliated = areAllUsersAffiliatedWithDeviceLocked();\n        boolean orgOwnedProfileDevice = isOrganizationOwnedDeviceWithManagedProfile();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (allUsersAffiliated || orgOwnedProfileDevice) {\n                mSecurityLogMonitor.resume();\n            }\n            // If there is no device owner, then per-user network logging may be enabled for the\n            // managed profile. In which case, all users do not need to be affiliated.\n            if (allUsersAffiliated || !mOwners.hasDeviceOwner()) {\n                if (mNetworkLogger != null) {\n                    mNetworkLogger.resume();\n                }\n            }\n        });\n    }\n\n    /** Deletes any security and network logs that might have been collected so far */\n    @GuardedBy(\"getLockObject()\")\n    private void discardDeviceWideLogsLocked() {\n        mSecurityLogMonitor.discardLogs();\n        if (mNetworkLogger != null) {\n            mNetworkLogger.discardLogs();\n        }\n        // TODO: We should discard pre-boot security logs here too, as otherwise those\n        // logs (which might contain data from the user just removed) will be\n        // available after next boot.\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public boolean isNetworkLoggingEnabled(@Nullable ComponentName admin,\n            @NonNull String packageName) {\n        if (!mHasFeature) {\n            return false;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                &&  (isDefaultDeviceOwner(caller)\n                || (isProfileOwner(caller) && isManagedProfile(caller.getUserId()))))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_NETWORK_LOGGING))\n                || hasCallingOrSelfPermission(permission.MANAGE_USERS));\n\n        synchronized (getLockObject()) {\n            return isNetworkLoggingEnabledInternalLocked();\n        }\n    }\n\n    private boolean isNetworkLoggingEnabledInternalLocked() {\n        ActiveAdmin activeAdmin = getNetworkLoggingControllingAdminLocked();\n        return (activeAdmin != null) && activeAdmin.isNetworkLoggingEnabled;\n    }\n\n    /*\n     * A maximum of 1200 events are returned, and the total marshalled size is in the order of\n     * 100kB, so returning a List instead of ParceledListSlice is acceptable.\n     * Ideally this would be done with ParceledList, however it only supports homogeneous types.\n     *\n     * @see NetworkLoggingHandler#MAX_EVENTS_PER_BATCH\n     */\n    @Override\n    public List<NetworkEvent> retrieveNetworkLogs(@Nullable ComponentName admin,\n            @NonNull String packageName, long batchToken) {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n        final boolean isManagedProfileOwner = isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId());\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                &&  (isDefaultDeviceOwner(caller) || isManagedProfileOwner))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_NETWORK_LOGGING)));\n        if (mOwners.hasDeviceOwner()) {\n            checkAllUsersAreAffiliatedWithDevice();\n        }\n\n        synchronized (getLockObject()) {\n            if (mNetworkLogger == null || !isNetworkLoggingEnabledInternalLocked()) {\n                return null;\n            }\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.RETRIEVE_NETWORK_LOGS)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ admin == null)\n                    .setStrings(isManagedProfileOwner\n                            ? LOG_TAG_PROFILE_OWNER : LOG_TAG_DEVICE_OWNER)\n                    .write();\n\n            final long currentTime = System.currentTimeMillis();\n            DevicePolicyData policyData = getUserData(caller.getUserId());\n            if (currentTime > policyData.mLastNetworkLogsRetrievalTime) {\n                policyData.mLastNetworkLogsRetrievalTime = currentTime;\n                saveSettingsLocked(caller.getUserId());\n            }\n            return mNetworkLogger.retrieveLogs(batchToken);\n        }\n    }\n\n    /**\n     * Returns whether it's time to post another network logging notification. When returning true,\n     * this method has the side-effect of updating the recorded last network logging notification\n     * time to now.\n     */\n    private boolean shouldSendNetworkLoggingNotificationLocked() {\n        ensureLocked();\n        // Send a network logging notification if the admin is a device owner, not profile owner.\n        final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n        if (deviceOwner == null || !deviceOwner.isNetworkLoggingEnabled) {\n            return false;\n        }\n        if (deviceOwner.numNetworkLoggingNotifications\n                >= ActiveAdmin.DEF_MAXIMUM_NETWORK_LOGGING_NOTIFICATIONS_SHOWN) {\n            return false;\n        }\n        final long now = System.currentTimeMillis();\n        if (now - deviceOwner.lastNetworkLoggingNotificationTimeMs < MS_PER_DAY) {\n            return false;\n        }\n        deviceOwner.numNetworkLoggingNotifications++;\n        if (deviceOwner.numNetworkLoggingNotifications\n                >= ActiveAdmin.DEF_MAXIMUM_NETWORK_LOGGING_NOTIFICATIONS_SHOWN) {\n            deviceOwner.lastNetworkLoggingNotificationTimeMs = 0;\n        } else {\n            deviceOwner.lastNetworkLoggingNotificationTimeMs = now;\n        }\n        saveSettingsLocked(deviceOwner.getUserHandle().getIdentifier());\n        return true;\n    }\n\n    private void handleSendNetworkLoggingNotification() {\n        final PackageManagerInternal pm = mInjector.getPackageManagerInternal();\n        final Intent intent = new Intent(DevicePolicyManager.ACTION_SHOW_DEVICE_MONITORING_DIALOG);\n        intent.setPackage(pm.getSystemUiServiceComponent().getPackageName());\n        mNetworkLoggingNotificationUserId = getCurrentForegroundUserId();\n        // Simple notification clicks are immutable\n        final PendingIntent pendingIntent = PendingIntent.getBroadcastAsUser(mContext, 0, intent,\n                PendingIntent.FLAG_IMMUTABLE, UserHandle.CURRENT);\n\n        final String title = getNetworkLoggingTitle();\n        final String text = getNetworkLoggingText();\n        Notification notification =\n                new Notification.Builder(mContext, SystemNotificationChannels.DEVICE_ADMIN)\n                .setSmallIcon(R.drawable.ic_info_outline)\n                .setContentTitle(title)\n                .setContentText(text)\n                .setTicker(title)\n                .setShowWhen(true)\n                .setContentIntent(pendingIntent)\n                .setStyle(new Notification.BigTextStyle().bigText(text))\n                .build();\n        Slogf.i(LOG_TAG, \"Sending network logging notification to user %d\",\n                mNetworkLoggingNotificationUserId);\n        mInjector.getNotificationManager().notifyAsUser(/* tag= */ null,\n                SystemMessage.NOTE_NETWORK_LOGGING, notification,\n                UserHandle.of(mNetworkLoggingNotificationUserId));\n    }\n\n    private String getNetworkLoggingTitle() {\n        return getUpdatableString(\n                NETWORK_LOGGING_TITLE, R.string.network_logging_notification_title);\n    }\n\n    private String getNetworkLoggingText() {\n        return getUpdatableString(\n                NETWORK_LOGGING_MESSAGE, R.string.network_logging_notification_text);\n    }\n\n    private void handleCancelNetworkLoggingNotification() {\n        if (mNetworkLoggingNotificationUserId == UserHandle.USER_NULL) {\n            // Happens when setNetworkLoggingActive(false) is called before called with true\n            Slogf.d(LOG_TAG, \"Not cancelling network logging notification for USER_NULL\");\n            return;\n        }\n\n        Slogf.i(LOG_TAG, \"Cancelling network logging notification for user %d\",\n                mNetworkLoggingNotificationUserId);\n        mInjector.getNotificationManager().cancelAsUser(/* tag= */ null,\n                SystemMessage.NOTE_NETWORK_LOGGING,\n                UserHandle.of(mNetworkLoggingNotificationUserId));\n        mNetworkLoggingNotificationUserId = UserHandle.USER_NULL;\n    }\n\n    /**\n     * Return the package name of owner in a given user.\n     */\n    private String getOwnerPackageNameForUserLocked(int userId) {\n        return mOwners.getDeviceOwnerUserId() == userId\n                ? mOwners.getDeviceOwnerPackageName()\n                : mOwners.getProfileOwnerPackage(userId);\n    }\n\n    /**\n     * @param rawIntent Original service intent specified by caller. It must be explicit.\n     * @param expectedPackageName The expected package name of the resolved service.\n     * @return Intent that have component explicitly set. {@code null} if no service is resolved\n     *     with the given intent.\n     * @throws SecurityException if the intent is resolved to an invalid service.\n     */\n    private Intent createCrossUserServiceIntent(\n            @NonNull Intent rawIntent, @NonNull String expectedPackageName,\n            @UserIdInt int targetUserId) throws RemoteException, SecurityException {\n        ResolveInfo info = mIPackageManager.resolveService(\n                rawIntent,\n                rawIntent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                0,  // flags\n                targetUserId);\n        if (info == null || info.serviceInfo == null) {\n            Slogf.e(LOG_TAG, \"Fail to look up the service: %s or user %d is not running\", rawIntent,\n                    targetUserId);\n            return null;\n        }\n        if (!expectedPackageName.equals(info.serviceInfo.packageName)) {\n            throw new SecurityException(\"Only allow to bind service in \" + expectedPackageName);\n        }\n        // STOPSHIP(b/37624960): Remove info.serviceInfo.exported before release.\n        if (info.serviceInfo.exported && !BIND_DEVICE_ADMIN.equals(info.serviceInfo.permission)) {\n            throw new SecurityException(\n                    \"Service must be protected by BIND_DEVICE_ADMIN permission\");\n        }\n        // It is the system server to bind the service, it would be extremely dangerous if it\n        // can be exploited to bind any service. Set the component explicitly to make sure we\n        // do not bind anything accidentally.\n        rawIntent.setComponent(info.serviceInfo.getComponentName());\n        return rawIntent;\n    }\n\n    @Override\n    public long getLastSecurityLogRetrievalTime() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || canManageUsers(caller));\n        return getUserData(UserHandle.USER_SYSTEM).mLastSecurityLogRetrievalTime;\n     }\n\n    @Override\n    public long getLastBugReportRequestTime() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || canManageUsers(caller));\n        return getUserData(UserHandle.USER_SYSTEM).mLastBugReportRequestTime;\n     }\n\n    @Override\n    public long getLastNetworkLogRetrievalTime() {\n        final CallerIdentity caller = getCallerIdentity();\n\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || (isProfileOwner(caller) && isManagedProfile(caller.getUserId()))\n                || canManageUsers(caller));\n        final int affectedUserId = getNetworkLoggingAffectedUser();\n        return affectedUserId >= 0 ? getUserData(affectedUserId).mLastNetworkLogsRetrievalTime : -1;\n    }\n\n    @Override\n    public boolean setResetPasswordToken(ComponentName admin, String callerPackageName,\n            byte[] token) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return false;\n        }\n        if (token == null || token.length < 32) {\n            throw new IllegalArgumentException(\"token must be at least 32-byte long\");\n        }\n        CallerIdentity caller;\n        if (Flags.resetPasswordWithTokenCoexistence()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n        final int userId = caller.getUserId();\n\n        if (Flags.resetPasswordWithTokenCoexistence()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                    caller.getPackageName(),\n                    userId);\n            Long currentTokenHandle = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.RESET_PASSWORD_TOKEN,\n                    enforcingAdmin,\n                    userId);\n            long tokenHandle = addEscrowToken(\n                    token, currentTokenHandle == null ? 0 : currentTokenHandle, userId);\n            if (tokenHandle == 0) {\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.RESET_PASSWORD_TOKEN,\n                        enforcingAdmin,\n                        userId);\n                return false;\n            }\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.RESET_PASSWORD_TOKEN,\n                    enforcingAdmin,\n                    new LongPolicyValue(tokenHandle),\n                    userId);\n            return true;\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                DevicePolicyData policy = getUserData(userId);\n                policy.mPasswordTokenHandle = addEscrowToken(\n                        token, policy.mPasswordTokenHandle, userId);\n                saveSettingsLocked(userId);\n                return policy.mPasswordTokenHandle != 0;\n            }\n        }\n    }\n\n    private long addEscrowToken(byte[] token, long currentPasswordTokenHandle, int userId) {\n        resetEscrowToken(currentPasswordTokenHandle, userId);\n        return mInjector.binderWithCleanCallingIdentity(() -> mLockPatternUtils.addEscrowToken(\n                token, userId, /* EscrowTokenStateChangeCallback= */ null));\n    }\n\n    private boolean resetEscrowToken(long tokenHandle, int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            if (tokenHandle != 0) {\n                return mLockPatternUtils.removeEscrowToken(tokenHandle, userId);\n            }\n            return false;\n        });\n    }\n\n    @Override\n    public boolean clearResetPasswordToken(ComponentName admin, String callerPackageName) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return false;\n        }\n        CallerIdentity caller;\n        if (Flags.resetPasswordWithTokenCoexistence()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n        final int userId = caller.getUserId();\n        boolean result = false;\n\n        if (Flags.resetPasswordWithTokenCoexistence()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                    caller.getPackageName(),\n                    userId);\n            Long currentTokenHandle = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.RESET_PASSWORD_TOKEN,\n                    enforcingAdmin,\n                    userId);\n            if (currentTokenHandle != null) {\n                result = resetEscrowToken(currentTokenHandle, userId);\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.RESET_PASSWORD_TOKEN,\n                        enforcingAdmin,\n                        userId);\n            }\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                DevicePolicyData policy = getUserData(userId);\n                if (policy.mPasswordTokenHandle != 0) {\n                    result = resetEscrowToken(policy.mPasswordTokenHandle, userId);\n                    policy.mPasswordTokenHandle = 0;\n                    saveSettingsLocked(userId);\n                }\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isResetPasswordTokenActive(ComponentName admin, String callerPackageName) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return false;\n        }\n        CallerIdentity caller;\n        if (Flags.resetPasswordWithTokenCoexistence()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n        int userId = caller.getUserId();\n\n        if (Flags.resetPasswordWithTokenCoexistence()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                    caller.getPackageName(),\n                    userId);\n            Long currentTokenHandle = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.RESET_PASSWORD_TOKEN,\n                    enforcingAdmin,\n                    userId);\n            return isResetPasswordTokenActiveForUserLocked(\n                    currentTokenHandle == null ? 0 : currentTokenHandle, userId);\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                DevicePolicyData policy = getUserData(userId);\n                return isResetPasswordTokenActiveForUserLocked(policy.mPasswordTokenHandle, userId);\n            }\n        }\n    }\n\n    private boolean isAnyResetPasswordTokenActiveForUserLocked(int userId) {\n        return mDevicePolicyEngine\n                .getLocalPoliciesSetByAdmins(PolicyDefinition.RESET_PASSWORD_TOKEN, userId)\n                .entrySet()\n                .stream()\n                .anyMatch((e) -> {\n                    EnforcingAdmin admin = e.getKey();\n                    PolicyValue<Long> policyValue = e.getValue();\n                    return isResetPasswordTokenActiveForUserLocked(policyValue.getValue(), userId)\n                              && isEncryptionAware(admin.getPackageName(), userId);\n                });\n    }\n\n    private boolean isResetPasswordTokenActiveForUserLocked(\n            long passwordTokenHandle, int userHandle) {\n        return passwordTokenHandle != 0 && mInjector.binderWithCleanCallingIdentity(() ->\n                    mLockPatternUtils.isEscrowTokenActive(passwordTokenHandle, userHandle));\n    }\n\n    @Override\n    public boolean resetPasswordWithToken(ComponentName admin, String callerPackageName,\n            String passwordOrNull, byte[] token,\n            int flags) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return false;\n        }\n        Objects.requireNonNull(token);\n\n        CallerIdentity caller;\n        if (Flags.resetPasswordWithTokenCoexistence()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n\n        int userId = caller.getUserId();\n        boolean result = false;\n        final String password = passwordOrNull != null ? passwordOrNull : \"\";\n\n        if (Flags.resetPasswordWithTokenCoexistence()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                    caller.getPackageName(),\n                    userId);\n            Long currentTokenHandle = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.RESET_PASSWORD_TOKEN,\n                    enforcingAdmin,\n                    userId);\n            if (currentTokenHandle != null && currentTokenHandle != 0) {\n                result = resetPasswordInternal(password, currentTokenHandle, token, flags, caller);\n            } else {\n                Slogf.w(LOG_TAG, \"No saved token handle\");\n            }\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                DevicePolicyData policy = getUserData(userId);\n                if (policy.mPasswordTokenHandle != 0) {\n                    result = resetPasswordInternal(\n                            password, policy.mPasswordTokenHandle, token, flags, caller);\n                } else {\n                    Slogf.w(LOG_TAG, \"No saved token handle\");\n                }\n            }\n        }\n\n        if (result) {\n            if (Flags.resetPasswordWithTokenCoexistence()) {\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.RESET_PASSWORD_WITH_TOKEN)\n                        .setAdmin(callerPackageName)\n                        .write();\n            } else {\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.RESET_PASSWORD_WITH_TOKEN)\n                        .setAdmin(caller.getComponentName())\n                        .write();\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isCurrentInputMethodSetByOwner() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isProfileOwner(caller) || canQueryAdminPolicy(caller) || isSystemUid(caller),\n                \"Only profile owner, device owner, a caller with QUERY_ADMIN_POLICY \"\n                        + \"permission or system may call this method.\");\n        return getUserData(caller.getUserId()).mCurrentInputMethodSet;\n    }\n\n    @Override\n    public StringParceledListSlice getOwnerInstalledCaCerts(@NonNull UserHandle user) {\n        final int userId = user.getIdentifier();\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                (isProfileOwner(caller) || isDefaultDeviceOwner(caller) || canQueryAdminPolicy(\n                        caller)) && hasFullCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            return new StringParceledListSlice(\n                    new ArrayList<>(getUserData(userId).mOwnerInstalledCaCerts));\n        }\n    }\n\n    @Override\n    public void clearApplicationUserData(ComponentName admin, String packageName,\n            IPackageDataObserver callback) {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        Objects.requireNonNull(packageName, \"packageName is null\");\n        Objects.requireNonNull(callback, \"callback is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_CLEAR_APPLICATION_USER_DATA);\n\n        long ident = mInjector.binderClearCallingIdentity();\n        try {\n            ActivityManager.getService().clearApplicationUserData(packageName, false, callback,\n                    caller.getUserId());\n        } catch(RemoteException re) {\n            // Same process, should not happen.\n        } catch (SecurityException se) {\n            // This can happen e.g. for device admin packages, do not throw out the exception,\n            // because callers have no means to know beforehand for which packages this might\n            // happen. If so, we send back that removal failed.\n            Slogf.w(LOG_TAG, \"Not allowed to clear application user data for package \"\n                    + packageName, se);\n            try {\n                callback.onRemoveCompleted(packageName, false);\n            } catch (RemoteException re) {\n                // Caller is no longer available, ignore\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void setLogoutEnabled(ComponentName admin, boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_LOGOUT_ENABLED);\n\n        synchronized (getLockObject()) {\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (deviceOwner.isLogoutEnabled == enabled) {\n                // already in the requested state\n                return;\n            }\n            deviceOwner.isLogoutEnabled = enabled;\n            saveSettingsLocked(caller.getUserId());\n        }\n    }\n\n    @Override\n    public boolean isLogoutEnabled() {\n        if (!mHasFeature) {\n            return false;\n        }\n        synchronized (getLockObject()) {\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            return (deviceOwner != null) && deviceOwner.isLogoutEnabled;\n        }\n    }\n\n    @Override\n    public List<String> getDisallowedSystemApps(ComponentName admin, int userId,\n            String provisioningAction) throws RemoteException {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        return new ArrayList<>(\n                mOverlayPackagesProvider.getNonRequiredApps(admin, userId, provisioningAction));\n    }\n\n    @Override\n    public void transferOwnership(@NonNull ComponentName admin, @NonNull ComponentName target,\n            @Nullable PersistableBundle bundle) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        Objects.requireNonNull(target, \"Target cannot be null.\");\n        Preconditions.checkArgument(!admin.equals(target),\n                \"Provided administrator and target are the same object.\");\n        Preconditions.checkArgument(!admin.getPackageName().equals(target.getPackageName()),\n                \"Provided administrator and target have the same package name.\");\n        if (bundle != null) {\n            PolicySizeVerifier.enforceMaxStringLength(bundle, \"bundle\");\n        }\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        final int callingUserId = caller.getUserId();\n        final DevicePolicyData policy = getUserData(callingUserId);\n        final DeviceAdminInfo incomingDeviceInfo = findAdmin(target, callingUserId,\n                /* throwForMissingPermission= */ true);\n        checkActiveAdminPrecondition(target, incomingDeviceInfo, policy);\n        Preconditions.checkArgument(incomingDeviceInfo.supportsTransferOwnership(),\n                \"Provided target does not support ownership transfer.\");\n\n        final long id = mInjector.binderClearCallingIdentity();\n        String ownerType = null;\n        try {\n            synchronized (getLockObject()) {\n                /*\n                * We must ensure the whole process is atomic to prevent the device from ending up\n                * in an invalid state (e.g. no active admin). This could happen if the device\n                * is rebooted or work mode is turned off mid-transfer.\n                * In order to guarantee atomicity, we:\n                *\n                * 1. Save an atomic journal file describing the transfer process\n                * 2. Perform the transfer itself\n                * 3. Delete the journal file\n                *\n                * That way if the journal file exists on device boot, we know that the transfer\n                * must be reverted back to the original administrator. This logic is implemented in\n                * revertTransferOwnershipIfNecessaryLocked.\n                * */\n                if (bundle == null) {\n                    bundle = new PersistableBundle();\n                }\n                if (isProfileOwner(caller)) {\n                    ownerType = ADMIN_TYPE_PROFILE_OWNER;\n                    prepareTransfer(admin, target, bundle, callingUserId,\n                            ADMIN_TYPE_PROFILE_OWNER);\n                    transferProfileOwnershipLocked(admin, target, callingUserId);\n                    sendProfileOwnerCommand(DeviceAdminReceiver.ACTION_TRANSFER_OWNERSHIP_COMPLETE,\n                            getTransferOwnershipAdminExtras(bundle), callingUserId);\n                    postTransfer(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED, callingUserId);\n                    if (isUserAffiliatedWithDeviceLocked(callingUserId)) {\n                        notifyAffiliatedProfileTransferOwnershipComplete(callingUserId);\n                    }\n                } else if (isDefaultDeviceOwner(caller)) {\n                    ownerType = ADMIN_TYPE_DEVICE_OWNER;\n                    prepareTransfer(admin, target, bundle, callingUserId,\n                            ADMIN_TYPE_DEVICE_OWNER);\n                    transferDeviceOwnershipLocked(admin, target, callingUserId);\n                    sendDeviceOwnerCommand(DeviceAdminReceiver.ACTION_TRANSFER_OWNERSHIP_COMPLETE,\n                            getTransferOwnershipAdminExtras(bundle));\n                    postTransfer(DevicePolicyManager.ACTION_DEVICE_OWNER_CHANGED, callingUserId);\n                }\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.TRANSFER_OWNERSHIP)\n                .setAdmin(admin)\n                .setStrings(target.getPackageName(), ownerType)\n                .write();\n    }\n\n    private void transferSubscriptionOwnership(ComponentName admin, ComponentName target) {\n        SubscriptionManager subscriptionManager = mContext.getSystemService(\n                SubscriptionManager.class);\n        for (int subId : getSubscriptionIdsInternal(admin.getPackageName()).toArray()) {\n            try {\n                subscriptionManager.setGroupOwner(subId, target.getPackageName());\n            } catch (Exception e) {\n                // Shouldn't happen.\n                Slogf.e(LOG_TAG, e, \"Error setting group owner for subId: \" + subId);\n            }\n        }\n    }\n\n    private void prepareTransfer(ComponentName admin, ComponentName target,\n            PersistableBundle bundle, int callingUserId, String adminType) {\n        saveTransferOwnershipBundleLocked(bundle, callingUserId);\n        mTransferOwnershipMetadataManager.saveMetadataFile(\n                new TransferOwnershipMetadataManager.Metadata(admin, target,\n                        callingUserId, adminType));\n    }\n\n    private void postTransfer(String broadcast, int callingUserId) {\n        deleteTransferOwnershipMetadataFileLocked();\n        sendOwnerChangedBroadcast(broadcast, callingUserId);\n    }\n\n    private void notifyAffiliatedProfileTransferOwnershipComplete(int callingUserId) {\n        final Bundle extras = new Bundle();\n        extras.putParcelable(Intent.EXTRA_USER, UserHandle.of(callingUserId));\n        sendDeviceOwnerCommand(\n                DeviceAdminReceiver.ACTION_AFFILIATED_PROFILE_TRANSFER_OWNERSHIP_COMPLETE, extras);\n    }\n\n    /**\n     * Transfers the profile owner for user with id profileOwnerUserId from admin to target.\n     */\n    private void transferProfileOwnershipLocked(ComponentName admin, ComponentName target,\n            int profileOwnerUserId) {\n        transferActiveAdminUncheckedLocked(target, admin, profileOwnerUserId);\n        mOwners.transferProfileOwner(target, profileOwnerUserId);\n        Slogf.i(LOG_TAG, \"Profile owner set: \" + target + \" on user \" + profileOwnerUserId);\n        mOwners.writeProfileOwner(profileOwnerUserId);\n        mDeviceAdminServiceController.startServiceForAdmin(\n                target.getPackageName(), profileOwnerUserId, \"transfer-profile-owner\");\n    }\n\n    /**\n     * Transfers the device owner for user with id userId from admin to target.\n     */\n    private void transferDeviceOwnershipLocked(ComponentName admin, ComponentName target, int userId) {\n        transferActiveAdminUncheckedLocked(target, admin, userId);\n        mOwners.transferDeviceOwnership(target);\n        Slogf.i(LOG_TAG, \"Device owner set: \" + target + \" on user \" + userId);\n        mOwners.writeDeviceOwner();\n        mDeviceAdminServiceController.startServiceForAdmin(\n                target.getPackageName(), userId, \"transfer-device-owner\");\n    }\n\n    private Bundle getTransferOwnershipAdminExtras(PersistableBundle bundle) {\n        Bundle extras = new Bundle();\n        if (bundle != null) {\n            extras.putParcelable(EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE, bundle);\n        }\n        return extras;\n    }\n\n    @Override\n    public void setStartUserSessionMessage(\n            ComponentName admin, CharSequence startUserSessionMessage) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        final String startUserSessionMessageString =\n                startUserSessionMessage != null ? startUserSessionMessage.toString() : null;\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (TextUtils.equals(deviceOwner.startUserSessionMessage, startUserSessionMessage)) {\n                return;\n            }\n            deviceOwner.startUserSessionMessage = startUserSessionMessageString;\n            saveSettingsLocked(caller.getUserId());\n        }\n\n        mInjector.getActivityManagerInternal()\n                .setSwitchingFromSystemUserMessage(startUserSessionMessageString);\n    }\n\n    @Override\n    public void setEndUserSessionMessage(ComponentName admin, CharSequence endUserSessionMessage) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        final String endUserSessionMessageString =\n                endUserSessionMessage != null ? endUserSessionMessage.toString() : null;\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (TextUtils.equals(deviceOwner.endUserSessionMessage, endUserSessionMessage)) {\n                return;\n            }\n            deviceOwner.endUserSessionMessage = endUserSessionMessageString;\n            saveSettingsLocked(caller.getUserId());\n        }\n\n        mInjector.getActivityManagerInternal()\n                .setSwitchingToSystemUserMessage(endUserSessionMessageString);\n    }\n\n    @Override\n    public String getStartUserSessionMessage(ComponentName admin) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            return deviceOwner.startUserSessionMessage;\n        }\n    }\n\n    @Override\n    public String getEndUserSessionMessage(ComponentName admin) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            return deviceOwner.endUserSessionMessage;\n        }\n    }\n\n    private void deleteTransferOwnershipMetadataFileLocked() {\n        mTransferOwnershipMetadataManager.deleteMetadataFile();\n    }\n\n    @Override\n    @Nullable\n    public PersistableBundle getTransferOwnershipBundle() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            final int callingUserId = caller.getUserId();\n            final File bundleFile = new File(\n                    mPathProvider.getUserSystemDirectory(callingUserId),\n                    TRANSFER_OWNERSHIP_PARAMETERS_XML);\n            if (!bundleFile.exists()) {\n                return null;\n            }\n            try (FileInputStream stream = new FileInputStream(bundleFile)) {\n                TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n                parser.next();\n                return PersistableBundle.restoreFromXml(parser);\n            } catch (IOException | XmlPullParserException | IllegalArgumentException e) {\n                Slogf.e(LOG_TAG, \"Caught exception while trying to load the \"\n                        + \"owner transfer parameters from file \" + bundleFile, e);\n                return null;\n            }\n        }\n    }\n\n    @Override\n    public int addOverrideApn(@NonNull ComponentName who, @NonNull ApnSetting apnSetting) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return -1;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(apnSetting, \"ApnSetting is null in addOverrideApn\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        if (apnSetting.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isManagedProfileOwner(caller));\n        } else {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        }\n\n        TelephonyManager tm = mContext.getSystemService(TelephonyManager.class);\n        if (tm != null) {\n            return mInjector.binderWithCleanCallingIdentity(\n                    () -> tm.addDevicePolicyOverrideApn(mContext, apnSetting));\n        } else {\n            Slogf.w(LOG_TAG, \"TelephonyManager is null when trying to add override apn\");\n            return INVALID_APN_ID;\n        }\n    }\n\n    @Override\n    public boolean updateOverrideApn(@NonNull ComponentName who, int apnId,\n            @NonNull ApnSetting apnSetting) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(apnSetting, \"ApnSetting is null in updateOverrideApn\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        ApnSetting apn = getApnSetting(apnId);\n        if (apn != null && apn.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE\n                && apnSetting.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isManagedProfileOwner(caller));\n        } else {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        }\n\n        if (apnId < 0) {\n            return false;\n        }\n        TelephonyManager tm = mContext.getSystemService(TelephonyManager.class);\n        if (tm != null) {\n            return mInjector.binderWithCleanCallingIdentity(\n                    () -> tm.modifyDevicePolicyOverrideApn(mContext, apnId, apnSetting));\n        } else {\n            Slogf.w(LOG_TAG, \"TelephonyManager is null when trying to modify override apn\");\n            return false;\n        }\n    }\n\n    @Override\n    public boolean removeOverrideApn(@NonNull ComponentName who, int apnId) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        ApnSetting apn = getApnSetting(apnId);\n        if (apn != null && apn.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isManagedProfileOwner(caller));\n        } else {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        }\n        return removeOverrideApnUnchecked(apnId);\n    }\n\n    private boolean removeOverrideApnUnchecked(int apnId) {\n        if(apnId < 0) {\n            return false;\n        }\n        int numDeleted = mInjector.binderWithCleanCallingIdentity(\n                () -> mContext.getContentResolver().delete(\n                        Uri.withAppendedPath(DPC_URI, Integer.toString(apnId)), null, null));\n        return numDeleted > 0;\n    }\n\n    private ApnSetting getApnSetting(int apnId) {\n        if (apnId < 0) {\n            return null;\n        }\n        ApnSetting apnSetting = null;\n        Cursor cursor = mInjector.binderWithCleanCallingIdentity(\n                () -> mContext.getContentResolver().query(\n                        Uri.withAppendedPath(DPC_URI, Integer.toString(apnId)), null, null, null,\n                        Telephony.Carriers.DEFAULT_SORT_ORDER));\n        if (cursor != null) {\n            while (cursor.moveToNext()) {\n                apnSetting = ApnSetting.makeApnSetting(cursor);\n                if (apnSetting != null) {\n                    break;\n                }\n            }\n            cursor.close();\n        }\n        return apnSetting;\n    }\n\n    @Override\n    public List<ApnSetting> getOverrideApns(@NonNull ComponentName who) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return Collections.emptyList();\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isManagedProfileOwner(caller));\n        List<ApnSetting> apnSettings = getOverrideApnsUnchecked();\n        if (isProfileOwner(caller)) {\n            List<ApnSetting> apnSettingList = new ArrayList<>();\n            for (ApnSetting apnSetting : apnSettings) {\n                if (apnSetting.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE) {\n                    apnSettingList.add(apnSetting);\n                }\n            }\n            return apnSettingList;\n        } else {\n            return apnSettings;\n        }\n    }\n\n    private List<ApnSetting> getOverrideApnsUnchecked() {\n        TelephonyManager tm = mContext.getSystemService(TelephonyManager.class);\n        if (tm != null) {\n            return mInjector.binderWithCleanCallingIdentity(\n                    () -> tm.getDevicePolicyOverrideApns(mContext));\n        }\n        Slogf.w(LOG_TAG, \"TelephonyManager is null when trying to get override apns\");\n        return Collections.emptyList();\n    }\n\n    @Override\n    public void setOverrideApnsEnabled(@NonNull ComponentName who, boolean enabled) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_OVERRIDE_APNS_ENABLED);\n\n        setOverrideApnsEnabledUnchecked(enabled);\n    }\n\n    private void setOverrideApnsEnabledUnchecked(boolean enabled) {\n        ContentValues value = new ContentValues();\n        value.put(ENFORCE_KEY, enabled);\n        mInjector.binderWithCleanCallingIdentity(() -> mContext.getContentResolver().update(\n                    ENFORCE_MANAGED_URI, value, null, null));\n    }\n\n    @Override\n    public boolean isOverrideApnEnabled(@NonNull ComponentName who) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        Cursor enforceCursor = mInjector.binderWithCleanCallingIdentity(\n                () -> mContext.getContentResolver().query(\n                        ENFORCE_MANAGED_URI, null, null, null, null));\n\n        if (enforceCursor == null) {\n            return false;\n        }\n        try {\n            if (enforceCursor.moveToFirst()) {\n                return enforceCursor.getInt(enforceCursor.getColumnIndex(ENFORCE_KEY)) == 1;\n            }\n        } catch (IllegalArgumentException e) {\n            Slogf.e(LOG_TAG, \"Cursor returned from ENFORCE_MANAGED_URI doesn't contain \"\n                    + \"correct info.\", e);\n        } finally {\n            enforceCursor.close();\n        }\n        return false;\n    }\n\n    @VisibleForTesting\n    void saveTransferOwnershipBundleLocked(PersistableBundle bundle, int userId) {\n        final File parametersFile = new File(\n                mPathProvider.getUserSystemDirectory(userId),\n                TRANSFER_OWNERSHIP_PARAMETERS_XML);\n        final AtomicFile atomicFile = new AtomicFile(parametersFile);\n        FileOutputStream stream = null;\n        try {\n            stream = atomicFile.startWrite();\n            final TypedXmlSerializer serializer = Xml.resolveSerializer(stream);\n            serializer.startDocument(null, true);\n            serializer.startTag(null, TAG_TRANSFER_OWNERSHIP_BUNDLE);\n            bundle.saveToXml(serializer);\n            serializer.endTag(null, TAG_TRANSFER_OWNERSHIP_BUNDLE);\n            serializer.endDocument();\n            atomicFile.finishWrite(stream);\n        } catch (IOException | XmlPullParserException e) {\n            Slogf.e(LOG_TAG, \"Caught exception while trying to save the \"\n                    + \"owner transfer parameters to file \" + parametersFile, e);\n            parametersFile.delete();\n            atomicFile.failWrite(stream);\n        }\n    }\n\n    void deleteTransferOwnershipBundleLocked(int userId) {\n        final File parametersFile = new File(mPathProvider.getUserSystemDirectory(userId),\n                TRANSFER_OWNERSHIP_PARAMETERS_XML);\n        parametersFile.delete();\n    }\n\n    private void logPasswordQualitySetIfSecurityLogEnabled(ComponentName who, int userId,\n            boolean parent, PasswordPolicy passwordPolicy) {\n        if (SecurityLog.isLoggingEnabled()) {\n            final int affectedUserId = parent ? getProfileParentId(userId) : userId;\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_COMPLEXITY_SET, who.getPackageName(),\n                    userId, affectedUserId, passwordPolicy.length, passwordPolicy.quality,\n                    passwordPolicy.letters, passwordPolicy.nonLetter, passwordPolicy.numeric,\n                    passwordPolicy.upperCase, passwordPolicy.lowerCase, passwordPolicy.symbols);\n        }\n    }\n\n    private static String getManagedProvisioningPackage(Context context) {\n        return context.getResources().getString(R.string.config_managed_provisioning_package);\n    }\n\n    private void putPrivateDnsSettings(int mode, @Nullable String host) {\n        // Set Private DNS settings using system permissions, as apps cannot write\n        // to global settings.\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            ConnectivitySettingsManager.setPrivateDnsMode(mContext, mode);\n            ConnectivitySettingsManager.setPrivateDnsHostname(mContext, host);\n        });\n    }\n\n    @Override\n    public int setGlobalPrivateDns(@NonNull ComponentName who, int mode, String privateDnsHost) {\n        if (!mHasFeature) {\n            return PRIVATE_DNS_SET_ERROR_FAILURE_SETTING;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkAllUsersAreAffiliatedWithDevice();\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_GLOBAL_PRIVATE_DNS);\n\n        switch (mode) {\n            case PRIVATE_DNS_MODE_OPPORTUNISTIC:\n                if (!TextUtils.isEmpty(privateDnsHost)) {\n                    throw new IllegalArgumentException(\n                            \"Host provided for opportunistic mode, but is not needed.\");\n                }\n                putPrivateDnsSettings(ConnectivitySettingsManager.PRIVATE_DNS_MODE_OPPORTUNISTIC,\n                        null);\n                return PRIVATE_DNS_SET_NO_ERROR;\n            case PRIVATE_DNS_MODE_PROVIDER_HOSTNAME:\n                if (TextUtils.isEmpty(privateDnsHost)\n                        || !NetworkUtilsInternal.isWeaklyValidatedHostname(privateDnsHost)) {\n                    throw new IllegalArgumentException(\n                            String.format(\"Provided hostname %s is not valid\", privateDnsHost));\n                }\n\n                // Connectivity check will have been performed in the DevicePolicyManager before\n                // the call here.\n                putPrivateDnsSettings(\n                        ConnectivitySettingsManager.PRIVATE_DNS_MODE_PROVIDER_HOSTNAME,\n                        privateDnsHost);\n                return PRIVATE_DNS_SET_NO_ERROR;\n            default:\n                throw new IllegalArgumentException(\n                        String.format(\"Provided mode, %d, is not a valid mode.\", mode));\n        }\n    }\n\n    @Override\n    public int getGlobalPrivateDnsMode(@NonNull ComponentName who) {\n        if (!mHasFeature) {\n            return PRIVATE_DNS_MODE_UNKNOWN;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        final int currentMode = ConnectivitySettingsManager.getPrivateDnsMode(mContext);\n        switch (currentMode) {\n            case ConnectivitySettingsManager.PRIVATE_DNS_MODE_OFF:\n                return PRIVATE_DNS_MODE_OFF;\n            case ConnectivitySettingsManager.PRIVATE_DNS_MODE_OPPORTUNISTIC:\n                return PRIVATE_DNS_MODE_OPPORTUNISTIC;\n            case ConnectivitySettingsManager.PRIVATE_DNS_MODE_PROVIDER_HOSTNAME:\n                return PRIVATE_DNS_MODE_PROVIDER_HOSTNAME;\n        }\n\n        return PRIVATE_DNS_MODE_UNKNOWN;\n    }\n\n    @Override\n    public String getGlobalPrivateDnsHost(@NonNull ComponentName who) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        return mInjector.settingsGlobalGetString(PRIVATE_DNS_SPECIFIER);\n    }\n\n    @Override\n    public void installUpdateFromFile(ComponentName admin, String callerPackageName,\n            ParcelFileDescriptor updateFileDescriptor, StartInstallingUpdateCallback callback) {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller)\n                        || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_INSTALL_SYSTEM_UPDATE);\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.INSTALL_SYSTEM_UPDATE)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(isDeviceAB())\n                .write();\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            UpdateInstaller updateInstaller;\n            if (isDeviceAB()) {\n                updateInstaller = new AbUpdateInstaller(\n                        mContext, updateFileDescriptor, callback, mInjector, mConstants);\n            } else {\n                updateInstaller = new NonAbUpdateInstaller(\n                        mContext, updateFileDescriptor, callback, mInjector, mConstants);\n            }\n            updateInstaller.startInstallUpdate();\n        });\n    }\n\n    private boolean isDeviceAB() {\n        return \"true\".equalsIgnoreCase(SystemProperties\n                .get(AB_DEVICE_KEY, \"\"));\n    }\n\n    @Override\n    public void setCrossProfileCalendarPackages(ComponentName who, List<String> packageNames) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            admin.mCrossProfileCalendarPackages = packageNames;\n            saveSettingsLocked(caller.getUserId());\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CROSS_PROFILE_CALENDAR_PACKAGES)\n                .setAdmin(who)\n                .setStrings(packageNames == null ? null\n                        : packageNames.toArray(new String[packageNames.size()]))\n                .write();\n    }\n\n    @Override\n    public List<String> getCrossProfileCalendarPackages(ComponentName who) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return admin.mCrossProfileCalendarPackages;\n        }\n    }\n\n    @Override\n    public boolean isPackageAllowedToAccessCalendarForUser(String packageName,\n            @UserIdInt int userId) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkStringNotEmpty(packageName, \"Package name is null or empty\");\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final int packageUid;\n        try (var snapshot = mInjector.getPackageManagerLocal().withUnfilteredSnapshot()) {\n            var packageState = snapshot.getPackageStates().get(packageName);\n            if (packageState == null) {\n                Slogf.w(LOG_TAG, \"Couldn't find package %s in user %d\", packageName,\n                        userId);\n                return false;\n            } else if (!packageState.getUserStateOrDefault(userId).isInstalled()) {\n                Slogf.w(LOG_TAG, \"Couldn't find installed package %s in user %d\", packageName,\n                        userId);\n                return false;\n            } else {\n                packageUid = UserHandle.getUid(userId, packageState.getAppId());\n            }\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        if (caller.getUid() != packageUid) {\n            Preconditions.checkCallAuthorization(\n                    hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS)\n                            || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS_FULL));\n        }\n\n        synchronized (getLockObject()) {\n            if (mInjector.settingsSecureGetIntForUser(\n                    Settings.Secure.CROSS_PROFILE_CALENDAR_ENABLED, 0, userId) == 0) {\n                return false;\n            }\n            final ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            if (admin != null) {\n                if (admin.mCrossProfileCalendarPackages == null) {\n                    return true;\n                }\n                return admin.mCrossProfileCalendarPackages.contains(packageName);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public List<String> getCrossProfileCalendarPackagesForUser(int userHandle) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS)\n                        || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS_FULL));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerAdminLocked(userHandle);\n            if (admin != null) {\n                return admin.mCrossProfileCalendarPackages;\n            }\n        }\n        return Collections.emptyList();\n    }\n\n    @Override\n    public void setCrossProfilePackages(ComponentName who, List<String> packageNames) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(packageNames, \"Package names is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        final List<String> previousCrossProfilePackages;\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            previousCrossProfilePackages = admin.mCrossProfilePackages;\n            if (packageNames.equals(previousCrossProfilePackages)) {\n                return;\n            }\n            admin.mCrossProfilePackages = packageNames;\n            saveSettingsLocked(caller.getUserId());\n        }\n        logSetCrossProfilePackages(who, packageNames);\n        final CrossProfileApps crossProfileApps =\n                mContext.createContextAsUser(\n                        caller.getUserHandle(), /* flags= */ 0)\n                        .getSystemService(CrossProfileApps.class);\n        mInjector.binderWithCleanCallingIdentity(\n        () -> crossProfileApps.resetInteractAcrossProfilesAppOps(\n                        previousCrossProfilePackages, new HashSet<>(packageNames)));\n    }\n\n    private void logSetCrossProfilePackages(ComponentName who, List<String> packageNames) {\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CROSS_PROFILE_PACKAGES)\n                .setAdmin(who)\n                .setStrings(packageNames.toArray(new String[packageNames.size()]))\n                .write();\n    }\n\n    @Override\n    public List<String> getCrossProfilePackages(ComponentName who) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return admin.mCrossProfilePackages;\n        }\n    }\n\n    @Override\n    public List<String> getAllCrossProfilePackages(int userId) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isSystemUid(caller) || isRootUid(caller) || hasCallingPermission(\n                        permission.INTERACT_ACROSS_USERS) || hasCallingPermission(\n                        permission.INTERACT_ACROSS_USERS_FULL) || hasPermissionForPreflight(\n                                                caller, permission.INTERACT_ACROSS_PROFILES));\n\n        synchronized (getLockObject()) {\n            final List<ActiveAdmin> admins = getProfileOwnerAdminsForProfileGroup(userId);\n            final List<String> packages = getCrossProfilePackagesForAdmins(admins);\n\n            packages.addAll(getDefaultCrossProfilePackages());\n\n            return packages;\n        }\n    }\n\n    private List<String> getCrossProfilePackagesForAdmins(List<ActiveAdmin> admins) {\n        final List<String> packages = new ArrayList<>();\n        for (int i = 0; i < admins.size(); i++) {\n            packages.addAll(admins.get(i).mCrossProfilePackages);\n        }\n        return packages;\n    }\n\n    @Override\n    public List<String> getDefaultCrossProfilePackages() {\n        Set<String> crossProfilePackages = new HashSet<>();\n\n        Collections.addAll(crossProfilePackages, mContext.getResources()\n                .getStringArray(R.array.cross_profile_apps));\n        Collections.addAll(crossProfilePackages, mContext.getResources()\n                .getStringArray(R.array.vendor_cross_profile_apps));\n\n        return new ArrayList<>(crossProfilePackages);\n    }\n\n    private List<ActiveAdmin> getProfileOwnerAdminsForProfileGroup(int userId) {\n        synchronized (getLockObject()) {\n            final List<ActiveAdmin> admins = new ArrayList<>();\n            int[] users = mUserManager.getProfileIdsWithDisabled(userId);\n            for (int i = 0; i < users.length; i++) {\n                final ComponentName componentName = getProfileOwnerAsUser(users[i]);\n                if (componentName != null) {\n                    ActiveAdmin admin = getActiveAdminUncheckedLocked(componentName, users[i]);\n                    if (admin != null) {\n                        admins.add(admin);\n                    }\n                }\n            }\n            return admins;\n        }\n    }\n\n    @Override\n    public boolean isManagedKiosk() {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        long id = mInjector.binderClearCallingIdentity();\n        try {\n            return isManagedKioskInternal();\n        } catch (RemoteException e) {\n            throw new IllegalStateException(e);\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    private boolean isUnattendedManagedKioskUnchecked() {\n        try {\n            return isManagedKioskInternal()\n                    && getPowerManagerInternal().wasDeviceIdleFor(UNATTENDED_MANAGED_KIOSK_MS);\n        } catch (RemoteException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    @Override\n    public boolean isUnattendedManagedKiosk() {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        return mInjector.binderWithCleanCallingIdentity(() -> isUnattendedManagedKioskUnchecked());\n    }\n\n    /**\n     * Returns whether the device is currently being used as a publicly-accessible dedicated device.\n     * Assumes that feature checks and permission checks have already been performed, and that the\n     * calling identity has been cleared.\n     */\n    private boolean isManagedKioskInternal() throws RemoteException {\n        return mOwners.hasDeviceOwner()\n                && mInjector.getIActivityManager().getLockTaskModeState()\n                        == ActivityManager.LOCK_TASK_MODE_LOCKED\n                && !isLockTaskFeatureEnabled(LOCK_TASK_FEATURE_SYSTEM_INFO)\n                && !deviceHasKeyguard()\n                && !inEphemeralUserSession();\n    }\n\n    private boolean isLockTaskFeatureEnabled(int lockTaskFeature) throws RemoteException {\n        LockTaskPolicy policy = mDevicePolicyEngine.getResolvedPolicy(\n                PolicyDefinition.LOCK_TASK, getCurrentForegroundUserId());\n        int lockTaskFeatures = policy == null\n                // We default on the power button menu, in order to be consistent with pre-P\n                // behaviour.\n                ? LOCK_TASK_FEATURE_GLOBAL_ACTIONS\n                : policy.getFlags();\n        return (lockTaskFeatures & lockTaskFeature) == lockTaskFeature;\n    }\n\n    private boolean deviceHasKeyguard() {\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            if (mLockPatternUtils.isSecure(userInfo.id)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean inEphemeralUserSession() {\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            if (mInjector.getUserManager().isUserEphemeral(userInfo.id)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private PowerManagerInternal getPowerManagerInternal() {\n        return mInjector.getPowerManagerInternal();\n    }\n\n    @Override\n    public boolean startViewCalendarEventInManagedProfile(String packageName, long eventId,\n            long start, long end, boolean allDay, int flags) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkStringNotEmpty(packageName, \"Package name is empty\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        if (!isCallingFromPackage(packageName, caller.getUid())) {\n            throw new SecurityException(\"Input package name doesn't align with actual \"\n                    + \"calling package.\");\n        }\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            final int workProfileUserId = getManagedUserId(caller.getUserId());\n            if (workProfileUserId < 0) {\n                return false;\n            }\n            if (!isPackageAllowedToAccessCalendarForUser(packageName, workProfileUserId)) {\n                Slogf.d(LOG_TAG, \"Package %s is not allowed to access cross-profile calendar APIs\",\n                        packageName);\n                return false;\n            }\n            final Intent intent = new Intent(\n                    CalendarContract.ACTION_VIEW_MANAGED_PROFILE_CALENDAR_EVENT);\n            intent.setPackage(packageName);\n            intent.putExtra(CalendarContract.EXTRA_EVENT_ID, eventId);\n            intent.putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, start);\n            intent.putExtra(CalendarContract.EXTRA_EVENT_END_TIME, end);\n            intent.putExtra(CalendarContract.EXTRA_EVENT_ALL_DAY, allDay);\n            intent.setFlags(flags);\n            try {\n                mContext.startActivityAsUser(intent, UserHandle.of(workProfileUserId));\n            } catch (ActivityNotFoundException e) {\n                Slogf.e(LOG_TAG, \"View event activity not found\", e);\n                return false;\n            }\n            return true;\n        });\n    }\n\n    @Override\n    public void setApplicationExemptions(String callerPackage, String packageName,\n            int[] exemptions) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkStringNotEmpty(packageName, \"Package name cannot be empty.\");\n        Objects.requireNonNull(exemptions, \"Application exemptions must not be null.\");\n        Preconditions.checkArgument(areApplicationExemptionsValid(exemptions),\n                \"Invalid application exemption constant found in application exemptions set.\");\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_POLICY_APP_EXEMPTIONS));\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        final AppOpsManager appOpsMgr = mInjector.getAppOpsManager();\n        final ApplicationInfo appInfo = getPackageInfoWithNullCheck(packageName, caller);\n        final int uid = appInfo.uid;\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.forEach((exemption, appOp) -> {\n                int currentMode = appOpsMgr.unsafeCheckOpNoThrow(appOp, uid, packageName);\n                int newMode = ArrayUtils.contains(exemptions, exemption)\n                        ? MODE_ALLOWED : MODE_DEFAULT;\n                if (currentMode != newMode) {\n                    appOpsMgr.setMode(appOp, uid, packageName, newMode);\n\n                    // If the user has already disabled background usage for the package, it won't\n                    // have OP_RUN_ANY_IN_BACKGROUND app op and won't execute in the background. The\n                    // code below grants that app op, and once the exemption is in place, the user\n                    // won't be able to disable background usage anymore.\n                    if (exemption == EXEMPT_FROM_POWER_RESTRICTIONS && newMode == MODE_ALLOWED) {\n                        setBgUsageAppOp(appOpsMgr, appInfo);\n                    }\n                }\n            });\n        });\n\n        String[] appOpExemptions = new String[exemptions.length];\n        for (int i = 0; i < exemptions.length; i++) {\n            appOpExemptions[i] = APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.get(exemptions[i]);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_APPLICATION_EXEMPTIONS)\n                .setAdmin(caller.getPackageName())\n                .setStrings(packageName, appOpExemptions)\n                .write();\n    }\n\n    static void setBgUsageAppOp(AppOpsManager appOpsMgr, ApplicationInfo appInfo) {\n        appOpsMgr.setMode(OP_RUN_ANY_IN_BACKGROUND, appInfo.uid, appInfo.packageName, MODE_ALLOWED);\n        if (appInfo.targetSdkVersion < Build.VERSION_CODES.O) {\n            appOpsMgr.setMode(OP_RUN_IN_BACKGROUND, appInfo.uid, appInfo.packageName, MODE_ALLOWED);\n        }\n    }\n\n    @Override\n    public int[] getApplicationExemptions(String packageName) {\n        if (!mHasFeature) {\n            return new int[0];\n        }\n        Preconditions.checkStringNotEmpty(packageName, \"Package name cannot be empty.\");\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_POLICY_APP_EXEMPTIONS));\n\n        final CallerIdentity caller = getCallerIdentity();\n        final ApplicationInfo packageInfo;\n        packageInfo = getPackageInfoWithNullCheck(packageName, caller);\n\n        IntArray appliedExemptions = new IntArray(0);\n        for (Map.Entry<Integer, String> entry :\n                APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.entrySet()) {\n            if (mInjector.getAppOpsManager().unsafeCheckOpNoThrow(\n                    entry.getValue(), packageInfo.uid, packageInfo.packageName) == MODE_ALLOWED) {\n                appliedExemptions.add(entry.getKey());\n            }\n        }\n        return appliedExemptions.toArray();\n    }\n\n    private ApplicationInfo getPackageInfoWithNullCheck(String packageName, CallerIdentity caller) {\n        final ApplicationInfo packageInfo =\n                mInjector.getPackageManagerInternal().getApplicationInfo(\n                        packageName,\n                        /* flags= */ 0,\n                        caller.getUid(),\n                        caller.getUserId());\n        if (packageInfo == null) {\n            throw new ServiceSpecificException(\n                    DevicePolicyManager.ERROR_PACKAGE_NAME_NOT_FOUND,\n                    \"Package name not found.\");\n        }\n        return packageInfo;\n    }\n\n    private boolean areApplicationExemptionsValid(int[] exemptions) {\n        for (int exemption : exemptions) {\n            if (!APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.containsKey(exemption)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean isCallingFromPackage(String packageName, int callingUid) {\n        try (var snapshot = mInjector.getPackageManagerLocal().withUnfilteredSnapshot()) {\n            var packageState = snapshot.getPackageStates().get(packageName);\n            var userId = UserHandle.getUserId(callingUid);\n            if (packageState == null) {\n                Slogf.d(LOG_TAG, \"Calling UID \" + callingUid + \" not found\");\n                return false;\n            } else if (!packageState.getUserStateOrDefault(userId).isInstalled()) {\n                Slogf.d(LOG_TAG, \"Calling UID \" + callingUid + \" not installed\");\n                return false;\n            } else {\n                return callingUid == UserHandle.getUid(userId, packageState.getAppId());\n            }\n        }\n    }\n\n    private DevicePolicyConstants loadConstants() {\n        return DevicePolicyConstants.loadFromString(\n                mInjector.settingsGlobalGetString(Global.DEVICE_POLICY_CONSTANTS));\n    }\n\n    @Override\n    public void setUserControlDisabledPackages(ComponentName who, String callerPackageName,\n            List<String> packages) {\n        Objects.requireNonNull(packages, \"packages is null\");\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        checkCanExecuteOrThrowUnsafe(\n                DevicePolicyManager.OPERATION_SET_USER_CONTROL_DISABLED_PACKAGES);\n\n        EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                who,\n                MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                caller.getPackageName(),\n                caller.getUserId());\n        Binder.withCleanCallingIdentity(() -> {\n            if (packages.isEmpty()) {\n                removeUserControlDisabledPackages(caller, enforcingAdmin);\n            } else {\n                addUserControlDisabledPackages(caller, enforcingAdmin, new HashSet<>(packages));\n            }\n        });\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_USER_CONTROL_DISABLED_PACKAGES)\n                .setAdmin(caller.getPackageName())\n                .setStrings(packages.toArray(new String[packages.size()]))\n                .write();\n    }\n\n    private void addUserControlDisabledPackages(CallerIdentity caller,\n            EnforcingAdmin enforcingAdmin, Set<String> packages) {\n        if (isDeviceOwner(caller)) {\n            mDevicePolicyEngine.setGlobalPolicy(\n                    PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                    enforcingAdmin,\n                    new PackageSetPolicyValue(packages));\n        } else {\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                    enforcingAdmin,\n                    new PackageSetPolicyValue(packages),\n                    caller.getUserId());\n        }\n    }\n\n    private void removeUserControlDisabledPackages(CallerIdentity caller,\n            EnforcingAdmin enforcingAdmin) {\n        if (isDeviceOwner(caller)) {\n            mDevicePolicyEngine.removeGlobalPolicy(\n                    PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                    enforcingAdmin);\n        } else {\n            mDevicePolicyEngine.removeLocalPolicy(\n                    PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                    enforcingAdmin,\n                    caller.getUserId());\n        }\n    }\n\n    @Override\n    public List<String> getUserControlDisabledPackages(ComponentName who,\n            String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        enforceCanQuery(\n                MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                caller.getPackageName(),\n                caller.getUserId());\n        // This retrieves the policy for the calling user only, DOs for example can't know\n        // what's enforced globally or on another user.\n        Set<String> packages = mDevicePolicyEngine.getResolvedPolicy(\n                PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                caller.getUserId());\n        return packages == null ? Collections.emptyList() : packages.stream().toList();\n    }\n\n    @Override\n    public void setCommonCriteriaModeEnabled(ComponentName who, String callerPackageName,\n            boolean enabled) {\n        CallerIdentity caller = getCallerIdentity(who);\n\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller),\n                \"Common Criteria mode can only be controlled by a device owner or \"\n                        + \"a profile owner on an organization-owned device.\");\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            admin.mCommonCriteriaMode = enabled;\n            saveSettingsLocked(caller.getUserId());\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_COMMON_CRITERIA_MODE)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(enabled)\n                .write();\n    }\n\n    @Override\n    public boolean isCommonCriteriaModeEnabled(ComponentName who) {\n        if (who != null) {\n            final CallerIdentity caller = getCallerIdentity(who);\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller),\n                    \"Common Criteria mode can only be controlled by a device owner or \"\n                            + \"a profile owner on an organization-owned device.\");\n\n            synchronized (getLockObject()) {\n                final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n                return admin.mCommonCriteriaMode;\n            }\n        }\n\n        // Return aggregated state if caller is not admin (who == null).\n        synchronized (getLockObject()) {\n            // Only DO or COPE PO can turn on CC mode, so take a shortcut here and only look at\n            // their ActiveAdmin, instead of iterating through all admins.\n            ActiveAdmin admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n\n            return admin != null && admin.mCommonCriteriaMode;\n        }\n    }\n\n    @Override\n    public @PersonalAppsSuspensionReason int getPersonalAppsSuspendedReasons(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        // DO shouldn't be able to use this method.\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            final long deadline = admin.mProfileOffDeadline;\n            final int result = makeSuspensionReasons(admin.mSuspendPersonalApps,\n                    deadline != 0 && mInjector.systemCurrentTimeMillis() > deadline);\n            Slogf.d(LOG_TAG, \"getPersonalAppsSuspendedReasons user: %d; result: %d\",\n                    mInjector.userHandleGetCallingUserId(), result);\n            return result;\n        }\n    }\n\n    private @PersonalAppsSuspensionReason int makeSuspensionReasons(\n            boolean explicit, boolean timeout) {\n        int result = PERSONAL_APPS_NOT_SUSPENDED;\n        if (explicit) {\n            result |= PERSONAL_APPS_SUSPENDED_EXPLICITLY;\n        }\n        if (timeout) {\n            result |= PERSONAL_APPS_SUSPENDED_PROFILE_TIMEOUT;\n        }\n        return result;\n    }\n\n    @Override\n    public void setPersonalAppsSuspended(ComponentName who, boolean suspended) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n        Preconditions.checkState(canHandleCheckPolicyComplianceIntent(caller));\n\n        final int callingUserId = caller.getUserId();\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(callingUserId);\n            boolean shouldSaveSettings = false;\n            if (admin.mSuspendPersonalApps != suspended) {\n                admin.mSuspendPersonalApps = suspended;\n                shouldSaveSettings = true;\n            }\n            if (admin.mProfileOffDeadline != 0) {\n                admin.mProfileOffDeadline = 0;\n                shouldSaveSettings = true;\n            }\n            if (shouldSaveSettings) {\n                saveSettingsLocked(callingUserId);\n            }\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> updatePersonalAppsSuspension(\n                callingUserId));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PERSONAL_APPS_SUSPENDED)\n                .setAdmin(caller.getComponentName())\n                .setBoolean(suspended)\n                .write();\n    }\n\n    /** Starts an activity to check policy compliance or request compliance acknowledgement. */\n    private void triggerPolicyComplianceCheckIfNeeded(int profileUserId, boolean suspended) {\n        synchronized (getLockObject()) {\n            final ActiveAdmin profileOwner = getProfileOwnerAdminLocked(profileUserId);\n            if (profileOwner == null) {\n                Slogf.wtf(LOG_TAG, \"Profile owner not found for compliance check\");\n                return;\n            }\n            if (suspended) {\n                // If suspended, DPC will need to show an activity.\n                final Intent intent = new Intent(ACTION_CHECK_POLICY_COMPLIANCE);\n                intent.setPackage(profileOwner.info.getPackageName());\n                mContext.startActivityAsUser(intent, UserHandle.of(profileUserId));\n            } else if (profileOwner.mProfileOffDeadline > 0) {\n                // If not suspended, but deadline set, DPC needs to acknowledge compliance so that\n                // the deadline can be reset.\n                sendAdminCommandLocked(profileOwner, ACTION_COMPLIANCE_ACKNOWLEDGEMENT_REQUIRED,\n                        /* adminExtras= */ null, /* receiver= */ null, /* inForeground = */ true);\n            }\n        }\n    }\n\n    /**\n     * Checks whether personal apps should be suspended according to the policy and applies the\n     * change if needed.\n     */\n    private boolean updatePersonalAppsSuspension(int profileUserId) {\n        final boolean shouldSuspend;\n        synchronized (getLockObject()) {\n            final ActiveAdmin profileOwner = getProfileOwnerAdminLocked(profileUserId);\n            if (profileOwner != null) {\n                // Profile is considered \"off\" when it is either not running or is running locked\n                // or is in quiet mode, i.e. when the admin cannot sync policies or show UI.\n                boolean profileUserOff =\n                        !mUserManagerInternal.isUserUnlockingOrUnlocked(profileUserId)\n                        || mUserManager.isQuietModeEnabled(UserHandle.of(profileUserId));\n                final int notificationState = updateProfileOffDeadlineLocked(\n                        profileUserId, profileOwner, profileUserOff);\n                final boolean suspendedExplicitly = profileOwner.mSuspendPersonalApps;\n                final boolean suspendedByTimeout = profileOwner.mProfileOffDeadline == -1;\n                Slogf.d(LOG_TAG,\n                        \"Personal apps suspended explicitly: %b, by timeout: %b, notification: %d\",\n                        suspendedExplicitly, suspendedByTimeout, notificationState);\n                updateProfileOffDeadlineNotificationLocked(\n                        profileUserId, profileOwner, notificationState);\n                shouldSuspend = suspendedExplicitly || suspendedByTimeout;\n            } else {\n                shouldSuspend = false;\n            }\n        }\n\n        final int parentUserId = getProfileParentId(profileUserId);\n        suspendPersonalAppsInternal(parentUserId, profileUserId, shouldSuspend);\n        return shouldSuspend;\n    }\n\n    /**\n     * Checks work profile time off policy, scheduling personal apps suspension via alarm if\n     * necessary.\n     * @return notification state\n     */\n    private int updateProfileOffDeadlineLocked(\n            int profileUserId, ActiveAdmin profileOwner, boolean off) {\n        final long now = mInjector.systemCurrentTimeMillis();\n        if (profileOwner.mProfileOffDeadline != 0 && now > profileOwner.mProfileOffDeadline) {\n            Slogf.i(LOG_TAG, \"Profile off deadline has been reached, off: \" + off);\n            if (profileOwner.mProfileOffDeadline != -1) {\n                // Move the deadline far to the past so that it cannot be rolled back by TZ change.\n                profileOwner.mProfileOffDeadline = -1;\n                saveSettingsLocked(profileUserId);\n            }\n            return off ? PROFILE_OFF_NOTIFICATION_SUSPENDED : PROFILE_OFF_NOTIFICATION_NONE;\n        }\n        boolean shouldSaveSettings = false;\n        if (profileOwner.mSuspendPersonalApps) {\n            // When explicit suspension is active, deadline shouldn't be set.\n            if (profileOwner.mProfileOffDeadline != 0) {\n                profileOwner.mProfileOffDeadline = 0;\n                shouldSaveSettings = true;\n            }\n        } else if (profileOwner.mProfileOffDeadline != 0\n                && (profileOwner.mProfileMaximumTimeOffMillis == 0)) {\n            // There is a deadline but either there is no policy -> clear\n            // the deadline.\n            Slogf.i(LOG_TAG, \"Profile off deadline is reset to zero\");\n            profileOwner.mProfileOffDeadline = 0;\n            shouldSaveSettings = true;\n        } else if (profileOwner.mProfileOffDeadline == 0\n                && (profileOwner.mProfileMaximumTimeOffMillis != 0 && off)) {\n            // There profile is locked and there is a policy, but the deadline is not set -> set the\n            // deadline.\n            Slogf.i(LOG_TAG, \"Profile off deadline is set.\");\n            profileOwner.mProfileOffDeadline = now + profileOwner.mProfileMaximumTimeOffMillis;\n            shouldSaveSettings = true;\n        }\n\n        if (shouldSaveSettings) {\n            saveSettingsLocked(profileUserId);\n        }\n\n        final long alarmTime;\n        final int notificationState;\n        if (!off || profileOwner.mProfileOffDeadline == 0) {\n            alarmTime = 0;\n            notificationState = PROFILE_OFF_NOTIFICATION_NONE;\n        } else if (profileOwner.mProfileOffDeadline - now < MANAGED_PROFILE_OFF_WARNING_PERIOD) {\n            // The deadline is close, upon the alarm personal apps should be suspended.\n            alarmTime = profileOwner.mProfileOffDeadline;\n            notificationState = PROFILE_OFF_NOTIFICATION_WARNING;\n        } else {\n            // The deadline is quite far, upon the alarm we should warn the user first, so the\n            // alarm is scheduled earlier than the actual deadline.\n            alarmTime = profileOwner.mProfileOffDeadline - MANAGED_PROFILE_OFF_WARNING_PERIOD;\n            notificationState = PROFILE_OFF_NOTIFICATION_NONE;\n        }\n\n        final AlarmManager am = mInjector.getAlarmManager();\n        final Intent intent = new Intent(ACTION_PROFILE_OFF_DEADLINE);\n        intent.setPackage(mContext.getPackageName());\n        // Broadcast alarms sent by system are immutable\n        final PendingIntent pi = mInjector.pendingIntentGetBroadcast(\n                mContext, REQUEST_PROFILE_OFF_DEADLINE, intent,\n                PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_UPDATE_CURRENT\n                        | PendingIntent.FLAG_IMMUTABLE);\n\n        if (alarmTime == 0) {\n            Slogf.i(LOG_TAG, \"Profile off deadline alarm is removed.\");\n            am.cancel(pi);\n        } else {\n            Slogf.i(LOG_TAG, \"Profile off deadline alarm is set.\");\n            am.set(AlarmManager.RTC, alarmTime, pi);\n        }\n\n        return notificationState;\n    }\n\n    private void suspendPersonalAppsInternal(\n            int parentUserId, int profileUserId, boolean suspended) {\n        if (getUserData(parentUserId).mAppsSuspended == suspended) {\n            return;\n        }\n        Slogf.i(LOG_TAG, \"%s personal apps for user %d\", suspended ? \"Suspending\" : \"Unsuspending\",\n                parentUserId);\n\n        // TODO(b/280602237): migrate properly\n        ActiveAdmin profileOwner = getProfileOwnerAdminLocked(profileUserId);\n        if (profileOwner != null) {\n            EnforcingAdmin admin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                    profileOwner.info.getComponent(),\n                    profileUserId);\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.PERSONAL_APPS_SUSPENDED,\n                    admin,\n                    new BooleanPolicyValue(suspended),\n                    parentUserId);\n        }\n\n        synchronized (getLockObject()) {\n            getUserData(parentUserId).mAppsSuspended = suspended;\n            saveSettingsLocked(parentUserId);\n        }\n    }\n\n    private void notifyIfManagedSubscriptionsAreUnavailable(\n            UserHandle managedProfile, boolean managedProfileAvailable) {\n        if (!isManagedProfile(managedProfile.getIdentifier())) {\n            Slog.wtf(\n                    LOG_TAG,\n                    \"Expected managed profile when notified of profile availability change.\");\n        }\n        if (getManagedSubscriptionsPolicy().getPolicyType()\n                != ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {\n            // There may be a subscription in the personal profile, in which case calls and\n            // texts may still be available. No need to notify the user.\n            return;\n        }\n        if (managedProfileAvailable) {\n            // When quiet mode is switched off calls and texts then become available to the user,\n            // so no need to keep showing the notification.\n            mInjector\n                    .getNotificationManager()\n                    .cancel(SystemMessage.NOTE_ALL_MANAGED_SUBSCRIPTIONS_AND_MANAGED_PROFILE_OFF);\n            return;\n        }\n        final Intent intent = new Intent(ACTION_TURN_PROFILE_ON_NOTIFICATION);\n        intent.putExtra(Intent.EXTRA_USER_HANDLE, managedProfile.getIdentifier());\n        final PendingIntent pendingIntent =\n                mInjector.pendingIntentGetBroadcast(\n                        mContext,\n                        /* requestCode= */ 0,\n                        intent,\n                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n        final Notification.Action turnProfileOnButton =\n                new Notification.Action.Builder(\n                        /* icon= */ null, getUnpauseWorkAppsButtonText(), pendingIntent)\n                        .build();\n\n        final Bundle extras = new Bundle();\n        extras.putString(\n                Notification.EXTRA_SUBSTITUTE_APP_NAME, getWorkProfileContentDescription());\n        final Notification notification =\n                new Notification.Builder(mContext, SystemNotificationChannels.DEVICE_ADMIN)\n                        .setSmallIcon(R.drawable.ic_phone_disabled)\n                        .setContentTitle(getUnpauseWorkAppsForTelephonyTitle())\n                        .setContentText(getUnpauseWorkAppsForTelephonyText())\n                        .setStyle(new Notification.BigTextStyle().bigText(\n                                getUnpauseWorkAppsForTelephonyText()))\n                        .addAction(turnProfileOnButton)\n                        .addExtras(extras)\n                        .setOngoing(false)\n                        .setShowWhen(true)\n                        .setAutoCancel(true)\n                        .build();\n\n        mInjector\n                .getNotificationManager()\n                .notifyAsUser(\n                        /* tag= */ null,\n                        SystemMessage.NOTE_ALL_MANAGED_SUBSCRIPTIONS_AND_MANAGED_PROFILE_OFF,\n                        notification,\n                        UserHandle.of(getProfileParentId(managedProfile.getIdentifier())));\n    }\n\n    private String getUnpauseWorkAppsButtonText() {\n        return getUpdatableString(\n                WORK_PROFILE_TELEPHONY_PAUSED_TURN_ON_BUTTON,\n                R.string.work_profile_telephony_paused_turn_on_button);\n    }\n\n    private String getUnpauseWorkAppsForTelephonyTitle() {\n        return getUpdatableString(\n                WORK_PROFILE_TELEPHONY_PAUSED_TITLE, R.string.work_profile_telephony_paused_title);\n    }\n\n    private String getUnpauseWorkAppsForTelephonyText() {\n        return getUpdatableString(\n                WORK_PROFILE_TELEPHONY_PAUSED_BODY,\n                R.string.work_profile_telephony_paused_text);\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void updateProfileOffDeadlineNotificationLocked(\n            int profileUserId, ActiveAdmin profileOwner, int notificationState) {\n        if (notificationState == PROFILE_OFF_NOTIFICATION_NONE) {\n            mInjector.getNotificationManager().cancel(SystemMessage.NOTE_PERSONAL_APPS_SUSPENDED);\n            return;\n        }\n\n        final Intent intent = new Intent(ACTION_TURN_PROFILE_ON_NOTIFICATION);\n        intent.setPackage(mContext.getPackageName());\n        intent.putExtra(Intent.EXTRA_USER_HANDLE, profileUserId);\n\n        // Simple notification action button clicks are immutable\n        final PendingIntent pendingIntent = mInjector.pendingIntentGetBroadcast(mContext,\n                0 /* requestCode */, intent,\n                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n\n        final Notification.Action turnProfileOnButton = new Notification.Action.Builder(\n                /* icon= */ null, getPersonalAppSuspensionButtonText(), pendingIntent).build();\n\n        final String text;\n        final boolean ongoing;\n        if (notificationState == PROFILE_OFF_NOTIFICATION_WARNING) {\n            // Round to the closest integer number of days.\n            final int maxDays = (int)\n                    ((profileOwner.mProfileMaximumTimeOffMillis + MS_PER_DAY / 2) / MS_PER_DAY);\n            final String date = DateUtils.formatDateTime(\n                    mContext, profileOwner.mProfileOffDeadline, DateUtils.FORMAT_SHOW_DATE);\n            final String time = DateUtils.formatDateTime(\n                    mContext, profileOwner.mProfileOffDeadline, DateUtils.FORMAT_SHOW_TIME);\n            text = getPersonalAppSuspensionSoonText(date, time, maxDays);\n            ongoing = false;\n        } else {\n            text = getPersonalAppSuspensionText();\n            ongoing = true;\n        }\n        final int color = mContext.getColor(R.color.personal_apps_suspension_notification_color);\n        final Bundle extras = new Bundle();\n        // TODO: Create a separate string for this.\n        extras.putString(\n                Notification.EXTRA_SUBSTITUTE_APP_NAME, getWorkProfileContentDescription());\n\n        final Notification notification =\n                new Notification.Builder(mContext, SystemNotificationChannels.DEVICE_ADMIN)\n                        .setSmallIcon(R.drawable.ic_corp_badge_no_background)\n                        .setOngoing(ongoing)\n                        .setAutoCancel(false)\n                        .setContentTitle(getPersonalAppSuspensionTitle())\n                        .setContentText(text)\n                        .setStyle(new Notification.BigTextStyle().bigText(text))\n                        .setColor(color)\n                        .addAction(turnProfileOnButton)\n                        .addExtras(extras)\n                        .build();\n\n        mHandler.post(() -> mInjector.getNotificationManager().notifyAsUser(\n                null, SystemMessage.NOTE_PERSONAL_APPS_SUSPENDED, notification,\n                UserHandle.of(getProfileParentId(profileUserId))));\n    }\n\n    private String getPersonalAppSuspensionButtonText() {\n        return getUpdatableString(\n                PERSONAL_APP_SUSPENSION_TURN_ON_PROFILE,\n                R.string.personal_apps_suspended_turn_profile_on);\n    }\n\n    private String getPersonalAppSuspensionTitle() {\n        return getUpdatableString(\n                PERSONAL_APP_SUSPENSION_TITLE, R.string.personal_apps_suspension_title);\n    }\n\n    private String getPersonalAppSuspensionText() {\n        return getUpdatableString(\n                PERSONAL_APP_SUSPENSION_MESSAGE, R.string.personal_apps_suspension_text);\n    }\n\n    private String getPersonalAppSuspensionSoonText(String date, String time, int maxDays) {\n        return getUpdatableString(\n                PERSONAL_APP_SUSPENSION_SOON_MESSAGE, R.string.personal_apps_suspension_soon_text,\n                date, time, maxDays);\n    }\n\n    private String getWorkProfileContentDescription() {\n        return getUpdatableString(\n                NOTIFICATION_WORK_PROFILE_CONTENT_DESCRIPTION,\n                R.string.notification_work_profile_content_description);\n    }\n\n    @Override\n    public void setManagedProfileMaximumTimeOff(ComponentName who, long timeoutMillis) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkArgumentNonnegative(timeoutMillis, \"Timeout must be non-negative.\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        // DO shouldn't be able to use this method.\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n        Preconditions.checkState(canHandleCheckPolicyComplianceIntent(caller));\n\n        final int userId = caller.getUserId();\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(userId);\n\n            // Ensure the timeout is long enough to avoid having bad user experience.\n            if (timeoutMillis > 0 && timeoutMillis < MANAGED_PROFILE_MAXIMUM_TIME_OFF_THRESHOLD\n                    && !isAdminTestOnlyLocked(who, userId)) {\n                timeoutMillis = MANAGED_PROFILE_MAXIMUM_TIME_OFF_THRESHOLD;\n            }\n            if (admin.mProfileMaximumTimeOffMillis == timeoutMillis) {\n                return;\n            }\n            admin.mProfileMaximumTimeOffMillis = timeoutMillis;\n            saveSettingsLocked(userId);\n        }\n\n        mInjector.binderWithCleanCallingIdentity(\n                () -> updatePersonalAppsSuspension(userId));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_MANAGED_PROFILE_MAXIMUM_TIME_OFF)\n                .setAdmin(caller.getComponentName())\n                .setTimePeriod(timeoutMillis)\n                .write();\n    }\n\n    private boolean canHandleCheckPolicyComplianceIntent(CallerIdentity caller) {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            final Intent intent = new Intent(ACTION_CHECK_POLICY_COMPLIANCE);\n            intent.setPackage(caller.getPackageName());\n            final List<ResolveInfo> handlers =\n                    mInjector.getPackageManager().queryIntentActivitiesAsUser(intent, /* flags= */\n                            0, caller.getUserId());\n            return !handlers.isEmpty();\n        });\n        return true;\n    }\n\n    @Override\n    public long getManagedProfileMaximumTimeOff(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return admin.mProfileMaximumTimeOffMillis;\n        }\n    }\n\n    @Override\n    public void acknowledgeDeviceCompliant() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n        enforceUserUnlocked(caller.getUserId());\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (admin.mProfileOffDeadline > 0) {\n                admin.mProfileOffDeadline = 0;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public boolean isComplianceAcknowledgementRequired() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n        enforceUserUnlocked(caller.getUserId());\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return admin.mProfileOffDeadline != 0;\n        }\n    }\n\n    @Override\n    public boolean canProfileOwnerResetPasswordWhenLocked(int userId) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG,\n                        \"call canProfileOwnerResetPasswordWhenLocked\"));\n        synchronized (getLockObject()) {\n            if (Flags.resetPasswordWithTokenCoexistence()) {\n                return isAnyResetPasswordTokenActiveForUserLocked(userId);\n            }\n            final ActiveAdmin poAdmin = getProfileOwnerAdminLocked(userId);\n            DevicePolicyData policy = getUserData(userId);\n            if (poAdmin == null\n                    || getEncryptionStatus() != ENCRYPTION_STATUS_ACTIVE_PER_USER\n                    || !isResetPasswordTokenActiveForUserLocked(\n                            policy.mPasswordTokenHandle, userId)) {\n                return false;\n            }\n            return isEncryptionAware(poAdmin.info.getPackageName(), userId);\n        }\n    }\n\n    private boolean isEncryptionAware(String packageName, int userId) {\n        final ApplicationInfo poAppInfo;\n        try {\n            poAppInfo = mIPackageManager.getApplicationInfo(packageName, 0 /* flags */, userId);\n        } catch (RemoteException e) {\n            Slogf.e(LOG_TAG, \"Failed to query PO / role holder's app info\", e);\n            return false;\n        }\n        if (poAppInfo == null) {\n            Slogf.wtf(LOG_TAG, \"Cannot find AppInfo for PO / role holder\");\n            return false;\n        }\n        if (!poAppInfo.isEncryptionAware()) {\n            return false;\n        }\n        Slogf.d(LOG_TAG, \"PO / role holder should be able to reset password from direct boot\");\n        return true;\n    }\n\n    @Override\n    public String getEnrollmentSpecificId(String callerPackage) {\n        if (!mHasFeature) {\n            return \"\";\n        }\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n\n        enforcePermission(MANAGE_DEVICE_POLICY_CERTIFICATES, caller.getPackageName());\n        synchronized (getLockObject()) {\n            final ActiveAdmin requiredAdmin = getDeviceOrProfileOwnerAdminLocked(\n                    caller.getUserId());\n            final String esid = requiredAdmin != null ? requiredAdmin.mEnrollmentSpecificId : null;\n            return esid != null ? esid : \"\";\n        }\n    }\n\n    @Override\n    public void setOrganizationIdForUser(\n            @NonNull String callerPackage, @NonNull String organizationId, int userId) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(callerPackage);\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        // Only the DPC can set this ID.\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller) || isProfileOwner(caller),\n                \"Only a Device Owner or Profile Owner may set the Enterprise ID.\");\n        // Empty enterprise ID must not be provided in calls to this method.\n        Preconditions.checkArgument(!TextUtils.isEmpty(organizationId),\n                \"Enterprise ID may not be empty.\");\n\n        Slogf.i(LOG_TAG, \"Setting Enterprise ID to %s for user %d\", organizationId, userId);\n\n        synchronized (mESIDInitilizationLock) {\n            if (mEsidCalculator == null) {\n                mInjector.binderWithCleanCallingIdentity(() -> {\n                    mEsidCalculator = mInjector.newEnterpriseSpecificIdCalculator();\n                });\n            }\n        }\n\n        final String ownerPackage;\n        synchronized (getLockObject()) {\n            final ActiveAdmin owner = getDeviceOrProfileOwnerAdminLocked(userId);\n            // As the caller is the system, it must specify the component name of the profile owner\n            // as a safety check.\n            Preconditions.checkCallAuthorization(\n                    owner != null && owner.getUserHandle().getIdentifier() == userId,\n                    String.format(\"The Profile Owner or Device Owner may only set the Enterprise ID\"\n                            + \" on its own user, called on user %d but owner user is %d\", userId,\n                            owner.getUserHandle().getIdentifier()));\n            ownerPackage = owner.info.getPackageName();\n            Preconditions.checkState(\n                    TextUtils.isEmpty(owner.mOrganizationId) || owner.mOrganizationId.equals(\n                            organizationId),\n                    \"The organization ID has been previously set to a different value and cannot \"\n                            + \"be changed\");\n            final String dpcPackage = owner.info.getPackageName();\n            final String esid = mEsidCalculator.calculateEnterpriseId(dpcPackage,\n                    organizationId);\n            owner.mOrganizationId = organizationId;\n            owner.mEnrollmentSpecificId = esid;\n            saveSettingsLocked(userId);\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_ORGANIZATION_ID)\n                .setAdmin(ownerPackage)\n                .setBoolean(isManagedProfile(userId))\n                .write();\n    }\n\n    @Override\n    public void clearOrganizationIdForUser(int userHandle) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin owner = getDeviceOrProfileOwnerAdminLocked(userHandle);\n            owner.mOrganizationId = null;\n            owner.mEnrollmentSpecificId = null;\n            saveSettingsLocked(userHandle);\n        }\n    }\n\n    @Override\n    public boolean removeManagedProfile(int userId) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        if (!isManagedProfile(userId)){\n            throw new IllegalArgumentException(\"Cannot remove user as it is not a managed profile\");\n        }\n\n        boolean success = false;\n        final long identity = Binder.clearCallingIdentity();\n        try{\n            success = mUserManager.removeUserEvenWhenDisallowed(userId);\n        } catch (Exception e) {\n            Slogf.e(LOG_TAG, \"Remove managed profile failed due to: \", e);\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return success;\n    }\n\n    @Override\n    public UserHandle createAndProvisionManagedProfile(\n            @NonNull ManagedProfileProvisioningParams provisioningParams,\n            @NonNull String callerPackage) {\n        Objects.requireNonNull(provisioningParams, \"provisioningParams is null\");\n        Objects.requireNonNull(callerPackage, \"callerPackage is null\");\n\n        final ComponentName admin = provisioningParams.getProfileAdminComponentName();\n        Objects.requireNonNull(admin, \"admin is null\");\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        if (Flags.splitCreateManagedProfileEnabled()) {\n            return mInjector.binderWithCleanCallingIdentity(() -> {\n                UserHandle managedProfileUser =\n                        createManagedProfileInternal(provisioningParams, caller);\n                maybeMigrateAccount(managedProfileUser.getIdentifier(), caller.getUserId(),\n                        provisioningParams.getAccountToMigrate(),\n                        provisioningParams.isKeepingAccountOnMigration(), callerPackage);\n                finalizeCreateManagedProfileInternal(provisioningParams, managedProfileUser);\n                return managedProfileUser;\n            });\n        }\n        provisioningParams.logParams(callerPackage);\n\n        UserInfo userInfo = null;\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int result = checkProvisioningPreconditionSkipPermission(\n                    ACTION_PROVISION_MANAGED_PROFILE, admin, caller.getUserId());\n            if (result != STATUS_OK) {\n                throw new ServiceSpecificException(\n                        ERROR_PRE_CONDITION_FAILED,\n                        \"Provisioning preconditions failed with result: \" + result);\n            }\n\n            final long startTime = SystemClock.elapsedRealtime();\n\n            onCreateAndProvisionManagedProfileStarted(provisioningParams);\n\n            final Set<String> nonRequiredApps = provisioningParams.isLeaveAllSystemAppsEnabled()\n                    ? Collections.emptySet()\n                    : mOverlayPackagesProvider.getNonRequiredApps(\n                            admin, caller.getUserId(), ACTION_PROVISION_MANAGED_PROFILE);\n            if (nonRequiredApps.isEmpty()) {\n                Slogf.i(LOG_TAG, \"No disallowed packages for the managed profile.\");\n            } else {\n                for (String packageName : nonRequiredApps) {\n                    Slogf.i(LOG_TAG, \"Disallowed package [\" + packageName + \"]\");\n                }\n            }\n\n            userInfo = mUserManager.createProfileForUserEvenWhenDisallowed(\n                    provisioningParams.getProfileName(),\n                    UserManager.USER_TYPE_PROFILE_MANAGED,\n                    UserInfo.FLAG_DISABLED,\n                    caller.getUserId(),\n                    nonRequiredApps.toArray(new String[nonRequiredApps.size()]));\n            if (userInfo == null) {\n                throw new ServiceSpecificException(\n                        ERROR_PROFILE_CREATION_FAILED,\n                        \"Error creating profile, createProfileForUserEvenWhenDisallowed \"\n                                + \"returned null.\");\n            }\n            resetInteractAcrossProfilesAppOps(caller.getUserId());\n            logEventDuration(\n                    DevicePolicyEnums.PLATFORM_PROVISIONING_CREATE_PROFILE_MS,\n                    startTime,\n                    callerPackage);\n\n            maybeInstallDevicePolicyManagementRoleHolderInUser(userInfo.id);\n\n            installExistingAdminPackage(userInfo.id, admin.getPackageName());\n            if (!enableAdminAndSetProfileOwner(userInfo.id, caller.getUserId(), admin)) {\n                throw new ServiceSpecificException(\n                        ERROR_SETTING_PROFILE_OWNER_FAILED,\n                        \"Error setting profile owner.\");\n            }\n            setUserSetupComplete(userInfo.id);\n\n            startProfileForSetup(userInfo.id, callerPackage);\n            maybeMigrateAccount(\n                    userInfo.id, caller.getUserId(), provisioningParams.getAccountToMigrate(),\n                    provisioningParams.isKeepingAccountOnMigration(), callerPackage);\n\n            if (provisioningParams.isOrganizationOwnedProvisioning()) {\n                synchronized (getLockObject()) {\n                    setProfileOwnerOnOrganizationOwnedDeviceUncheckedLocked(admin, userInfo.id,\n                            true);\n                }\n            }\n\n            onCreateAndProvisionManagedProfileCompleted(provisioningParams);\n\n            sendProvisioningCompletedBroadcast(\n                    userInfo.id,\n                    ACTION_PROVISION_MANAGED_PROFILE,\n                    provisioningParams.isLeaveAllSystemAppsEnabled());\n\n            return userInfo.getUserHandle();\n        } catch (Exception e) {\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.PLATFORM_PROVISIONING_ERROR)\n                    .setStrings(callerPackage)\n                    .write();\n            // In case of any errors during provisioning, remove the newly created profile.\n            if (userInfo != null) {\n                mUserManager.removeUserEvenWhenDisallowed(userInfo.id);\n            }\n            throw e;\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public UserHandle createManagedProfile(\n            @NonNull ManagedProfileProvisioningParams provisioningParams,\n            @NonNull String callerPackage) {\n        Objects.requireNonNull(provisioningParams, \"provisioningParams is null\");\n        Objects.requireNonNull(callerPackage, \"callerPackage is null\");\n        Objects.requireNonNull(provisioningParams.getProfileAdminComponentName(), \"admin is null\");\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        CallerIdentity caller = getCallerIdentity(callerPackage);\n\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                createManagedProfileInternal(provisioningParams, caller));\n    }\n\n    private UserHandle createManagedProfileInternal(\n            @NonNull ManagedProfileProvisioningParams provisioningParams,\n            @NonNull CallerIdentity caller) {\n        provisioningParams.logParams(caller.getPackageName());\n        final ComponentName admin = provisioningParams.getProfileAdminComponentName();\n        final int callingUserId = caller.getUserId();\n        UserInfo userInfo = null;\n        try {\n            final int result = checkProvisioningPreconditionSkipPermission(\n                    ACTION_PROVISION_MANAGED_PROFILE, admin, callingUserId);\n            if (result != STATUS_OK) {\n                throw new ServiceSpecificException(\n                        ERROR_PRE_CONDITION_FAILED,\n                        \"Provisioning preconditions failed with result: \" + result);\n            }\n\n            final long startTime = SystemClock.elapsedRealtime();\n\n            onCreateAndProvisionManagedProfileStarted(provisioningParams);\n\n            userInfo = createProfileForUser(provisioningParams, callingUserId);\n            if (userInfo == null) {\n                throw new ServiceSpecificException(\n                        ERROR_PROFILE_CREATION_FAILED,\n                        \"Error creating profile, createProfileForUserEvenWhenDisallowed \"\n                                + \"returned null.\");\n            }\n            resetInteractAcrossProfilesAppOps(caller.getUserId());\n            logEventDuration(\n                    DevicePolicyEnums.PLATFORM_PROVISIONING_CREATE_PROFILE_MS,\n                    startTime,\n                    caller.getPackageName());\n\n            maybeInstallDevicePolicyManagementRoleHolderInUser(userInfo.id);\n            installExistingAdminPackage(userInfo.id, admin.getPackageName());\n\n            if (!enableAdminAndSetProfileOwner(userInfo.id, caller.getUserId(), admin)) {\n                throw new ServiceSpecificException(\n                        ERROR_SETTING_PROFILE_OWNER_FAILED,\n                        \"Error setting profile owner.\");\n            }\n            setUserSetupComplete(userInfo.id);\n            startProfileForSetup(userInfo.id, caller.getPackageName());\n\n            if (provisioningParams.isOrganizationOwnedProvisioning()) {\n                synchronized (getLockObject()) {\n                    setProfileOwnerOnOrganizationOwnedDeviceUncheckedLocked(admin, userInfo.id,\n                            true);\n                }\n            }\n            return userInfo.getUserHandle();\n        } catch (Exception e) {\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.PLATFORM_PROVISIONING_ERROR)\n                    .setStrings(caller.getPackageName())\n                    .write();\n            // In case of any errors during provisioning, remove the newly created profile.\n            if (userInfo != null) {\n                mUserManager.removeUserEvenWhenDisallowed(userInfo.id);\n            }\n            throw e;\n        }\n    }\n\n    private UserInfo createProfileForUser(ManagedProfileProvisioningParams params, int userId) {\n        final Set<String> nonRequiredApps = params.isLeaveAllSystemAppsEnabled()\n                ? Collections.emptySet()\n                : mOverlayPackagesProvider.getNonRequiredApps(params.getProfileAdminComponentName(),\n                        userId, ACTION_PROVISION_MANAGED_PROFILE);\n        if (nonRequiredApps.isEmpty()) {\n            Slogf.i(LOG_TAG, \"No disallowed packages for the managed profile.\");\n        } else {\n            for (String packageName : nonRequiredApps) {\n                Slogf.i(LOG_TAG, \"Disallowed package [\" + packageName + \"]\");\n            }\n        }\n        return mUserManager.createProfileForUserEvenWhenDisallowed(\n                params.getProfileName(),\n                UserManager.USER_TYPE_PROFILE_MANAGED,\n                UserInfo.FLAG_DISABLED,\n                userId,\n                nonRequiredApps.toArray(new String[nonRequiredApps.size()]));\n    }\n\n    @Override\n    public void finalizeCreateManagedProfile(\n            @NonNull ManagedProfileProvisioningParams provisioningParams,\n            @NonNull UserHandle managedProfileUser) {\n        Objects.requireNonNull(provisioningParams, \"provisioningParams is null\");\n        Objects.requireNonNull(managedProfileUser, \"managedProfileUser is null\");\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            finalizeCreateManagedProfileInternal(provisioningParams, managedProfileUser);\n        });\n    }\n\n    private void finalizeCreateManagedProfileInternal(\n            @NonNull ManagedProfileProvisioningParams provisioningParams,\n            @NonNull UserHandle managedProfileUser\n    ) {\n        onCreateAndProvisionManagedProfileCompleted(provisioningParams);\n        sendProvisioningCompletedBroadcast(\n                managedProfileUser.getIdentifier(),\n                ACTION_PROVISION_MANAGED_PROFILE,\n                provisioningParams.isLeaveAllSystemAppsEnabled());\n    }\n\n    @Override\n    public void finalizeWorkProfileProvisioning(UserHandle managedProfileUser,\n            Account migratedAccount) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        if (!isManagedProfile(managedProfileUser.getIdentifier())) {\n            throw new IllegalStateException(\"Given user is not a managed profile\");\n        }\n        ComponentName profileOwnerComponent =\n                mOwners.getProfileOwnerComponent(managedProfileUser.getIdentifier());\n        if (profileOwnerComponent == null) {\n            throw new IllegalStateException(\"There is no profile owner on the given profile\");\n        }\n        Intent primaryProfileSuccessIntent = new Intent(ACTION_MANAGED_PROFILE_PROVISIONED);\n        primaryProfileSuccessIntent.setPackage(profileOwnerComponent.getPackageName());\n        primaryProfileSuccessIntent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES\n                | Intent.FLAG_RECEIVER_FOREGROUND);\n        primaryProfileSuccessIntent.putExtra(Intent.EXTRA_USER, managedProfileUser);\n\n        if (migratedAccount != null) {\n            primaryProfileSuccessIntent.putExtra(EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE,\n                    migratedAccount);\n        }\n\n        mContext.sendBroadcastAsUser(primaryProfileSuccessIntent,\n                UserHandle.of(getProfileParentId(managedProfileUser.getIdentifier())));\n    }\n\n    /**\n     * Callback called at the beginning of {@link #createAndProvisionManagedProfile(\n     * ManagedProfileProvisioningParams, String)} after the relevant prechecks have passed.\n     *\n     * <p>The logic in this method blocks provisioning.\n     *\n     * <p>This method is meant to be overridden by OEMs.\n     */\n    private void onCreateAndProvisionManagedProfileStarted(\n            ManagedProfileProvisioningParams provisioningParams) {}\n\n    /**\n     * Callback called at the end of {@link #createAndProvisionManagedProfile(\n     * ManagedProfileProvisioningParams, String)} after all the other provisioning tasks\n     * have completed successfully.\n     *\n     * <p>The logic in this method blocks provisioning.\n     *\n     * <p>This method is meant to be overridden by OEMs.\n     */\n    private void onCreateAndProvisionManagedProfileCompleted(\n            ManagedProfileProvisioningParams provisioningParams) {}\n\n    private void maybeInstallDevicePolicyManagementRoleHolderInUser(int targetUserId) {\n        String devicePolicyManagerRoleHolderPackageName =\n                getRoleHolderPackageName(mContext, RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT);\n        if (devicePolicyManagerRoleHolderPackageName == null) {\n            Slogf.d(LOG_TAG, \"No device policy management role holder specified.\");\n            return;\n        }\n        try {\n            if (mIPackageManager.isPackageAvailable(\n                    devicePolicyManagerRoleHolderPackageName, targetUserId)) {\n                Slogf.d(LOG_TAG, \"The device policy management role holder \"\n                        + devicePolicyManagerRoleHolderPackageName + \" is already installed in \"\n                        + \"user \" + targetUserId);\n                return;\n            }\n            Slogf.d(LOG_TAG, \"Installing the device policy management role holder \"\n                    + devicePolicyManagerRoleHolderPackageName + \" in user \" + targetUserId);\n            mIPackageManager.installExistingPackageAsUser(\n                    devicePolicyManagerRoleHolderPackageName,\n                    targetUserId,\n                    PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                    PackageManager.INSTALL_REASON_POLICY,\n                    /* whiteListedPermissions= */ null);\n        } catch (RemoteException e) {\n            // Does not happen, same process\n        }\n    }\n\n    /**\n     * If multiple packages hold the role, returns the first package in the list.\n     */\n    @Nullable\n    private String getRoleHolderPackageName(Context context, String role) {\n        return getRoleHolderPackageNameOnUser(context, role, Process.myUserHandle());\n    }\n\n    /**\n     * If multiple packages hold the role, returns the first package in the list.\n     */\n    @Nullable\n    private String getRoleHolderPackageNameOnUser(Context context, String role, UserHandle user) {\n        RoleManager roleManager = context.getSystemService(RoleManager.class);\n\n        // Calling identity needs to be cleared as this method is used in the permissions checks.\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            List<String> roleHolders = roleManager.getRoleHoldersAsUser(role, user);\n            if (roleHolders.isEmpty()) {\n                return null;\n            }\n            return roleHolders.get(0);\n        });\n    }\n\n    private boolean isCallerDevicePolicyManagementRoleHolder(CallerIdentity caller) {\n        return doesCallerHoldRole(caller, RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT);\n    }\n\n    private boolean isCallerSystemSupervisionRoleHolder(CallerIdentity caller) {\n        return doesCallerHoldRole(caller, RoleManager.ROLE_SYSTEM_SUPERVISION);\n    }\n\n    /**\n     * Check if the caller is holding the given role on the calling user.\n     *\n     * @param caller the caller you wish to check\n     * @param role the name of the role to check for.\n     * @return {@code true} if the caller holds the role, {@code false} otherwise.\n     */\n    private boolean doesCallerHoldRole(CallerIdentity caller, String role) {\n        int callerUid = caller.getUid();\n        String roleHolderPackageName =\n                getRoleHolderPackageNameOnUser(role, caller.getUserId());\n        int roleHolderUid = mInjector.getPackageManagerInternal().getPackageUid(\n                roleHolderPackageName, 0, caller.getUserId());\n\n        return callerUid == roleHolderUid;\n    }\n\n    /**\n     * Return the package name of the role holder on the given user.\n     *\n     * <p>If the userId passed in is {@link UserHandle.USER_ALL} then every user will be checked and\n     * the package name of the role holder on the first user where there is a role holder is\n     * returned.\n     *\n     * @param role the name of the role to check for.\n     * @param userId the userId to check for the role holder on.\n     * @return the package name of the role holder\n     */\n    @Nullable\n    private String getRoleHolderPackageNameOnUser(String role, int userId) {\n        // Clear calling identity as the RoleManager APIs require privileged permissions.\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            List<UserInfo> users;\n            // Interpret USER_ALL as meaning \"any\" user.\n            if (userId == UserHandle.USER_ALL) {\n                users = mInjector.getUserManagerInternal().getUsers(/*excludeDying=*/ true);\n            } else {\n                users = List.of(new UserInfo(userId, /*name=*/ null, /*flags=*/ 0));\n            }\n            for (UserInfo user : users) {\n                List<String> roleHolders =\n                        mInjector.roleManagerGetRoleHoldersAsUser(role, user.getUserHandle());\n                if (!roleHolders.isEmpty()) {\n                    return roleHolders.get(0);\n                }\n            }\n            return null;\n        });\n    }\n\n    private void resetInteractAcrossProfilesAppOps(@UserIdInt int userId) {\n        mInjector.getCrossProfileApps(userId).clearInteractAcrossProfilesAppOps();\n        pregrantDefaultInteractAcrossProfilesAppOps(userId);\n    }\n\n    private void pregrantDefaultInteractAcrossProfilesAppOps(@UserIdInt int userId) {\n        final String op =\n                AppOpsManager.permissionToOp(permission.INTERACT_ACROSS_PROFILES);\n        for (String packageName : getConfigurableDefaultCrossProfilePackages(userId)) {\n            if (!appOpIsDefaultOrAllowed(userId, op, packageName)) {\n                continue;\n            }\n            mInjector.getCrossProfileApps(userId).setInteractAcrossProfilesAppOp(\n                    packageName, MODE_ALLOWED);\n        }\n    }\n\n    private Set<String> getConfigurableDefaultCrossProfilePackages(@UserIdInt int userId) {\n        List<String> defaultPackages = getDefaultCrossProfilePackages();\n        return defaultPackages.stream().filter(\n                mInjector.getCrossProfileApps(userId)::canConfigureInteractAcrossProfiles).collect(\n                Collectors.toSet());\n    }\n\n    private boolean appOpIsDefaultOrAllowed(@UserIdInt int userId, String op, String packageName) {\n        try {\n            final int uid = mContext.createContextAsUser(UserHandle.of(userId), /* flags= */ 0).\n                    getPackageManager().getPackageUid(packageName, /* flags= */ 0);\n            int mode = mInjector.getAppOpsManager().unsafeCheckOpNoThrow(\n                    op, uid, packageName);\n            return mode == MODE_ALLOWED || mode == MODE_DEFAULT;\n        } catch (NameNotFoundException e) {\n            return false;\n        }\n    }\n\n    private void installExistingAdminPackage(int userId, String packageName) {\n        try {\n            final int status = mContext.getPackageManager().installExistingPackageAsUser(\n                    packageName,\n                    userId);\n            if (status != PackageManager.INSTALL_SUCCEEDED) {\n                throw new ServiceSpecificException(\n                        ERROR_ADMIN_PACKAGE_INSTALLATION_FAILED,\n                        String.format(\"Failed to install existing package %s for user %d with \"\n                                        + \"result code %d\",\n                                packageName, userId, status));\n            }\n        } catch (NameNotFoundException e) {\n            throw new ServiceSpecificException(\n                    ERROR_ADMIN_PACKAGE_INSTALLATION_FAILED,\n                    String.format(\"Failed to install existing package %s for user %d: %s\",\n                            packageName, userId, e.getMessage()));\n        }\n    }\n\n    private boolean enableAdminAndSetProfileOwner(\n            @UserIdInt int userId, @UserIdInt int callingUserId, ComponentName adminComponent) {\n        enableAndSetActiveAdmin(userId, callingUserId, adminComponent);\n        return setProfileOwner(adminComponent, userId);\n    }\n\n    private void enableAndSetActiveAdmin(\n            @UserIdInt int userId, @UserIdInt int callingUserId, ComponentName adminComponent) {\n        final String adminPackage = adminComponent.getPackageName();\n        enablePackage(adminPackage, callingUserId);\n        setActiveAdmin(adminComponent, /* refreshing= */ true, userId, null);\n    }\n\n    private void enablePackage(String packageName, @UserIdInt int userId) {\n        try {\n            final int enabledSetting = mIPackageManager.getApplicationEnabledSetting(\n                    packageName, userId);\n            if (enabledSetting != PackageManager.COMPONENT_ENABLED_STATE_DEFAULT\n                    && enabledSetting != PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {\n                mIPackageManager.setApplicationEnabledSetting(\n                        packageName,\n                        PackageManager.COMPONENT_ENABLED_STATE_DEFAULT,\n                        // Device policy app may have launched ManagedProvisioning, play nice and\n                        // don't kill it as a side-effect of this call.\n                        PackageManager.DONT_KILL_APP,\n                        userId,\n                        mContext.getOpPackageName());\n            }\n        } catch (RemoteException e) {\n            // Shouldn't happen.\n            Slogf.wtf(LOG_TAG, \"Error setting application enabled\", e);\n        }\n    }\n\n    private void setUserSetupComplete(@UserIdInt int userId) {\n        Settings.Secure.putIntForUser(\n                mContext.getContentResolver(), USER_SETUP_COMPLETE, 1, userId);\n    }\n\n    private void startProfileForSetup(@UserIdInt int userId, String callerPackage)\n            throws IllegalStateException {\n        Slogf.i(LOG_TAG, \"Starting profile %d as requested by package %s\", userId, callerPackage);\n        final long startTime = SystemClock.elapsedRealtime();\n        final UserUnlockedBlockingReceiver unlockedReceiver = new UserUnlockedBlockingReceiver(\n                userId);\n        mContext.registerReceiverAsUser(\n                unlockedReceiver,\n                new UserHandle(userId),\n                new IntentFilter(Intent.ACTION_USER_UNLOCKED),\n                /* broadcastPermission = */ null,\n                /* scheduler= */ null);\n        try {\n            // Must call startProfileEvenWhenDisabled(), as profile is not enabled yet\n            if (!mInjector.getActivityManagerInternal().startProfileEvenWhenDisabled(userId)) {\n                throw new ServiceSpecificException(ERROR_STARTING_PROFILE_FAILED,\n                        String.format(\"Unable to start user %d in background\", userId));\n            }\n\n            if (!unlockedReceiver.waitForUserUnlocked()) {\n                throw new ServiceSpecificException(ERROR_STARTING_PROFILE_FAILED,\n                        String.format(\"Timeout whilst waiting for unlock of user %d.\", userId));\n            }\n            logEventDuration(\n                    DevicePolicyEnums.PLATFORM_PROVISIONING_START_PROFILE_MS,\n                    startTime,\n                    callerPackage);\n        } finally {\n            mContext.unregisterReceiver(unlockedReceiver);\n        }\n    }\n\n    private void maybeMigrateAccount(\n            @UserIdInt int targetUserId, @UserIdInt int sourceUserId, Account accountToMigrate,\n            boolean keepAccountMigrated, String callerPackage) {\n        final UserHandle sourceUser = UserHandle.of(sourceUserId);\n        final UserHandle targetUser = UserHandle.of(targetUserId);\n        if (accountToMigrate == null) {\n            Slogf.d(LOG_TAG, \"No account to migrate.\");\n            return;\n        }\n        if (sourceUser.equals(targetUser)) {\n            Slogf.w(LOG_TAG, \"sourceUser and targetUser are the same, won't migrate account.\");\n            return;\n        }\n\n        boolean copySucceeded = false;\n        int retryAttemptsLeft = RETRY_COPY_ACCOUNT_ATTEMPTS;\n        while (!copySucceeded && (retryAttemptsLeft > 0)) {\n            Slogf.i(LOG_TAG, \"Copying account. Attempts left : \" + retryAttemptsLeft);\n            copySucceeded =\n                    copyAccount(targetUser, sourceUser, accountToMigrate, callerPackage);\n            retryAttemptsLeft--;\n        }\n\n        if (!keepAccountMigrated) {\n            removeAccount(accountToMigrate, sourceUserId);\n        }\n\n    }\n\n    private boolean copyAccount(\n            UserHandle targetUser, UserHandle sourceUser, Account accountToMigrate,\n            String callerPackage) {\n        final long startTime = SystemClock.elapsedRealtime();\n        try {\n            final AccountManager accountManager = mContext.getSystemService(AccountManager.class);\n            final boolean copySucceeded = accountManager.copyAccountToUser(\n                    accountToMigrate,\n                    sourceUser,\n                    targetUser,\n                    /* handler= */ null, /* callback= */ null)\n                    .getResult(60 * 3, TimeUnit.SECONDS);\n            if (copySucceeded) {\n                logCopyAccountStatus(COPY_ACCOUNT_SUCCEEDED, callerPackage);\n                logEventDuration(\n                        DevicePolicyEnums.PLATFORM_PROVISIONING_COPY_ACCOUNT_MS,\n                        startTime,\n                        callerPackage);\n                Slogf.i(LOG_TAG, \"Copy account successful to \" + targetUser);\n                return true;\n            } else {\n                logCopyAccountStatus(COPY_ACCOUNT_FAILED, callerPackage);\n                Slogf.e(LOG_TAG, \"Failed to copy account to \" + targetUser);\n            }\n        } catch (OperationCanceledException e) {\n            // Account migration is not considered a critical operation.\n            logCopyAccountStatus(COPY_ACCOUNT_TIMED_OUT, callerPackage);\n            Slogf.e(LOG_TAG, \"Exception copying account to \" + targetUser, e);\n        } catch (AuthenticatorException | IOException e) {\n            logCopyAccountStatus(COPY_ACCOUNT_EXCEPTION, callerPackage);\n            Slogf.e(LOG_TAG, \"Exception copying account to \" + targetUser, e);\n        }\n        return false;\n    }\n\n    private static void logCopyAccountStatus(@CopyAccountStatus int status, String callerPackage) {\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.PLATFORM_PROVISIONING_COPY_ACCOUNT_STATUS)\n                .setInt(status)\n                .setStrings(callerPackage)\n                .write();\n    }\n\n    private void removeAccount(Account account, @UserIdInt int sourceUserId) {\n        final AccountManager accountManager = mContext.createContextAsUser(\n                        UserHandle.of(sourceUserId), /* flags= */ 0)\n                .getSystemService(AccountManager.class);\n        try {\n            final Bundle result = accountManager.removeAccount(account,\n                    null, null /* callback */, null /* handler */).getResult(60, TimeUnit.SECONDS);\n            if (result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, /* default */ false)) {\n                Slogf.i(LOG_TAG, \"Account removed from the primary user.\");\n            } else {\n                // TODO(174768447): Revisit start activity logic.\n                final Intent removeIntent =\n                        result.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n                removeIntent.addFlags(FLAG_ACTIVITY_NEW_TASK);\n                if (removeIntent != null) {\n                    Slogf.i(LOG_TAG, \"Starting activity to remove account\");\n                    new Handler(Looper.getMainLooper()).post(() -> {\n                        mContext.startActivity(removeIntent);\n                    });\n                } else {\n                    Slogf.e(LOG_TAG, \"Could not remove account from the primary user.\");\n                }\n            }\n        } catch (OperationCanceledException | AuthenticatorException | IOException e) {\n            Slogf.e(LOG_TAG, \"Exception removing account from the primary user.\", e);\n        }\n    }\n\n    @Override\n    public void provisionFullyManagedDevice(\n            @NonNull FullyManagedDeviceProvisioningParams provisioningParams,\n            @NonNull String callerPackage) {\n        Objects.requireNonNull(provisioningParams, \"provisioningParams is null.\");\n        Objects.requireNonNull(callerPackage, \"callerPackage is null.\");\n\n        ComponentName deviceAdmin = provisioningParams.getDeviceAdminComponentName();\n        Objects.requireNonNull(deviceAdmin, \"admin is null.\");\n        Objects.requireNonNull(provisioningParams.getOwnerName(), \"owner name is null.\");\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS)\n                        || (hasCallingOrSelfPermission(permission.PROVISION_DEMO_DEVICE)\n                        && provisioningParams.isDemoDevice()));\n\n        provisioningParams.logParams(callerPackage);\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            boolean isSingleUserMode;\n            int headlessDeviceOwnerMode = getHeadlessDeviceOwnerModeForDeviceAdmin(\n                    deviceAdmin, caller.getUserId());\n            isSingleUserMode = headlessDeviceOwnerMode == HEADLESS_DEVICE_OWNER_MODE_SINGLE_USER;\n\n            if (Flags.headlessSingleMinTargetSdk()\n                    && mInjector.userManagerIsHeadlessSystemUserMode()\n                    && isSingleUserMode\n                    && !mInjector.isChangeEnabled(\n                            PROVISION_SINGLE_USER_MODE, deviceAdmin.getPackageName(),\n                    caller.getUserId())) {\n                throw new IllegalStateException(\"Device admin is not targeting Android V.\");\n            }\n\n            int result = checkProvisioningPreconditionSkipPermission(\n                    ACTION_PROVISION_MANAGED_DEVICE, deviceAdmin, caller.getUserId());\n            if (result != STATUS_OK) {\n                throw new ServiceSpecificException(\n                        ERROR_PRE_CONDITION_FAILED,\n                        \"Provisioning preconditions failed with result: \" + result);\n            }\n            onProvisionFullyManagedDeviceStarted(provisioningParams);\n\n            // These properties are global so will apply on all users\n            setTimeAndTimezone(provisioningParams.getTimeZone(), provisioningParams.getLocalTime());\n            setLocale(provisioningParams.getLocale());\n\n            int deviceOwnerUserId =\n                    isSingleUserMode && mInjector.userManagerIsHeadlessSystemUserMode()\n                    ? mUserManagerInternal.getMainUserId() : UserHandle.USER_SYSTEM;\n\n            if (!removeNonRequiredAppsForManagedDevice(\n                    deviceOwnerUserId,\n                    provisioningParams.isLeaveAllSystemAppsEnabled(),\n                    deviceAdmin)) {\n                throw new ServiceSpecificException(\n                        ERROR_REMOVE_NON_REQUIRED_APPS_FAILED,\n                        \"PackageManager failed to remove non required apps.\");\n            }\n\n            if (!setActiveAdminAndDeviceOwner(deviceOwnerUserId, deviceAdmin)) {\n                throw new ServiceSpecificException(\n                        ERROR_SET_DEVICE_OWNER_FAILED, \"Failed to set device owner.\");\n            }\n\n            disallowAddUser();\n            setAdminCanGrantSensorsPermissionForUserUnchecked(\n                    deviceOwnerUserId, provisioningParams.canDeviceOwnerGrantSensorsPermissions());\n            setDemoDeviceStateUnchecked(deviceOwnerUserId, provisioningParams.isDemoDevice());\n            onProvisionFullyManagedDeviceCompleted(provisioningParams);\n            sendProvisioningCompletedBroadcast(\n                    deviceOwnerUserId,\n                    ACTION_PROVISION_MANAGED_DEVICE,\n                    provisioningParams.isLeaveAllSystemAppsEnabled());\n        } catch (Exception e) {\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.PLATFORM_PROVISIONING_ERROR)\n                    .setStrings(callerPackage)\n                    .write();\n            throw e;\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * Callback called at the beginning of {@link #provisionFullyManagedDevice(\n     * FullyManagedDeviceProvisioningParams, String)} after the relevant prechecks have passed.\n     *\n     * <p>The logic in this method blocks provisioning.\n     *\n     * <p>This method is meant to be overridden by OEMs.\n     */\n    private void onProvisionFullyManagedDeviceStarted(\n            FullyManagedDeviceProvisioningParams provisioningParams) {}\n\n    /**\n     * Callback called at the end of {@link #provisionFullyManagedDevice(\n     * FullyManagedDeviceProvisioningParams, String)} after all the other provisioning tasks\n     * have completed successfully.\n     *\n     * <p>The logic in this method blocks provisioning.\n     *\n     * <p>This method is meant to be overridden by OEMs.\n     */\n    private void onProvisionFullyManagedDeviceCompleted(\n            FullyManagedDeviceProvisioningParams provisioningParams) {}\n\n    private void setTimeAndTimezone(String timeZone, long localTime) {\n        try {\n            final AlarmManager alarmManager = mContext.getSystemService(AlarmManager.class);\n            if (timeZone != null) {\n                alarmManager.setTimeZone(timeZone);\n            }\n            if (localTime > 0) {\n                alarmManager.setTime(localTime);\n            }\n        } catch (Exception e) {\n            // Do not stop provisioning and ignore this error.\n            Slogf.e(LOG_TAG, \"Alarm manager failed to set the system time/timezone.\", e);\n        }\n    }\n\n    private void setLocale(Locale locale) {\n        if (locale == null || locale.equals(Locale.getDefault())) {\n            return;\n        }\n        try {\n            // If locale is different from current locale this results in a configuration change,\n            // which will trigger the restarting of the activity.\n            LocalePicker.updateLocale(locale);\n        } catch (Exception e) {\n            // Do not stop provisioning and ignore this error.\n            Slogf.e(LOG_TAG, \"Failed to set the system locale.\", e);\n        }\n    }\n\n    private boolean removeNonRequiredAppsForManagedDevice(\n            @UserIdInt int userId, boolean leaveAllSystemAppsEnabled, ComponentName admin) {\n        Set<String> packagesToDelete = leaveAllSystemAppsEnabled\n                ? Collections.emptySet()\n                : mOverlayPackagesProvider.getNonRequiredApps(\n                        admin, userId, ACTION_PROVISION_MANAGED_DEVICE);\n\n        removeNonInstalledPackages(packagesToDelete, userId);\n        if (packagesToDelete.isEmpty()) {\n            Slogf.i(LOG_TAG, \"No packages to delete on user \" + userId);\n            return true;\n        }\n\n        NonRequiredPackageDeleteObserver packageDeleteObserver =\n                new NonRequiredPackageDeleteObserver(packagesToDelete.size());\n        for (String packageName : packagesToDelete) {\n            Slogf.i(LOG_TAG, \"Deleting package [\" + packageName + \"] as user \" + userId);\n            mContext.getPackageManager().deletePackageAsUser(\n                    packageName,\n                    packageDeleteObserver,\n                    PackageManager.DELETE_SYSTEM_APP,\n                    userId);\n        }\n        Slogf.i(LOG_TAG, \"Waiting for non required apps to be deleted\");\n        return packageDeleteObserver.awaitPackagesDeletion();\n    }\n\n    private void removeNonInstalledPackages(Set<String> packages, @UserIdInt int userId) {\n        final Set<String> toBeRemoved = new HashSet<>();\n        for (String packageName : packages) {\n            if (!isPackageInstalledForUser(packageName, userId)) {\n                toBeRemoved.add(packageName);\n            }\n        }\n        packages.removeAll(toBeRemoved);\n    }\n\n    private void disallowAddUser() {\n        if (mIsAutomotive) {\n            // Auto still enables adding users due to the communal nature of those devices\n            if (mInjector.userManagerIsHeadlessSystemUserMode()) {\n                Slogf.i(LOG_TAG, \"Not setting DISALLOW_ADD_USER on headless system user mode.\");\n                return;\n            }\n        }\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            UserHandle userHandle = userInfo.getUserHandle();\n            if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_USER, userHandle)) {\n                mUserManager.setUserRestriction(\n                        UserManager.DISALLOW_ADD_USER, /* value= */ true, userHandle);\n            }\n        }\n    }\n\n    private boolean setActiveAdminAndDeviceOwner(\n            @UserIdInt int userId, ComponentName adminComponent) {\n        enableAndSetActiveAdmin(userId, userId, adminComponent);\n        // TODO(b/178187130): Directly set DO and remove the check once silent provisioning is no\n        //  longer used.\n        if (getDeviceOwnerComponent(/* callingUserOnly= */ true) == null) {\n            return setDeviceOwner(adminComponent, userId,\n                    /* setProfileOwnerOnCurrentUserIfNecessary= */ true);\n        }\n        return true;\n    }\n\n    private static void logEventDuration(int eventId, long startTime, String callerPackage) {\n        final long duration = SystemClock.elapsedRealtime() - startTime;\n        DevicePolicyEventLogger\n                .createEvent(eventId)\n                .setTimePeriod(duration)\n                .setStrings(callerPackage)\n                .write();\n    }\n\n    @Override\n    public void resetDefaultCrossProfileIntentFilters(@UserIdInt int userId) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                final List<UserInfo> profiles = mUserManager.getProfiles(userId);\n                final int numOfProfiles = profiles.size();\n                if (numOfProfiles <= 1) {\n                    return;\n                }\n\n                final String managedProvisioningPackageName = getManagedProvisioningPackage(\n                        mContext);\n                // Removes cross profile intent filters from the parent to all the profiles.\n                mIPackageManager.clearCrossProfileIntentFilters(\n                        userId, mContext.getOpPackageName());\n                // Setting and resetting default cross profile intent filters was previously handled\n                // by Managed Provisioning. For backwards compatibility, clear any intent filters\n                // that were set by ManagedProvisioning.\n                mIPackageManager.clearCrossProfileIntentFilters(\n                        userId, managedProvisioningPackageName);\n\n                // For each profile reset cross profile intent filters\n                for (int i = 0; i < numOfProfiles; i++) {\n                    UserInfo profile = profiles.get(i);\n                    mIPackageManager.clearCrossProfileIntentFilters(\n                            profile.id, mContext.getOpPackageName());\n                    // Clear any intent filters that were set by ManagedProvisioning.\n                    mIPackageManager.clearCrossProfileIntentFilters(\n                            profile.id, managedProvisioningPackageName);\n\n                    mUserManagerInternal.setDefaultCrossProfileIntentFilters(userId, profile.id);\n                }\n            } catch (RemoteException e) {\n                // Shouldn't happen.\n                Slogf.wtf(LOG_TAG, \"Error resetting default cross profile intent filters\", e);\n            }\n        });\n    }\n\n    private void setAdminCanGrantSensorsPermissionForUserUnchecked(@UserIdInt int userId,\n            boolean canGrant) {\n        Slogf.d(LOG_TAG, \"setAdminCanGrantSensorsPermissionForUserUnchecked(%d, %b)\",\n                userId, canGrant);\n        synchronized (getLockObject()) {\n            ActiveAdmin owner = getDeviceOrProfileOwnerAdminLocked(userId);\n\n            Preconditions.checkState(\n                    isDeviceOwner(owner) && owner.getUserHandle().getIdentifier() == userId,\n                    \"May only be set on a the user of a device owner.\");\n\n            owner.mAdminCanGrantSensorsPermissions = canGrant;\n            mPolicyCache.setAdminCanGrantSensorsPermissions(canGrant);\n            saveSettingsLocked(userId);\n        }\n    }\n\n    private void setDemoDeviceStateUnchecked(@UserIdInt int userId, boolean isDemoDevice) {\n        Slogf.d(LOG_TAG, \"setDemoDeviceStateUnchecked(%d, %b)\",\n                userId, isDemoDevice);\n        if (!isDemoDevice) {\n            return;\n        }\n        synchronized (getLockObject()) {\n            mInjector.settingsGlobalPutStringForUser(\n                    Global.DEVICE_DEMO_MODE, Integer.toString(/* value= */ 1), userId);\n        }\n\n        setUserProvisioningState(STATE_USER_SETUP_FINALIZED, userId);\n    }\n\n    private void updateAdminCanGrantSensorsPermissionCache(@UserIdInt int userId) {\n        synchronized (getLockObject()) {\n\n            ActiveAdmin owner;\n            // If the user is affiliated the device (either a DO itself, or an affiliated PO),\n            // use mAdminCanGrantSensorsPermissions from the DO\n            if (isUserAffiliatedWithDeviceLocked(userId)) {\n                owner = getDeviceOwnerAdminLocked();\n            } else {\n                owner = getDeviceOrProfileOwnerAdminLocked(userId);\n            }\n            boolean canGrant = owner != null && owner.mAdminCanGrantSensorsPermissions;\n            mPolicyCache.setAdminCanGrantSensorsPermissions(canGrant);\n        }\n    }\n\n    private void updateNetworkPreferenceForUser(int userId,\n            List<PreferentialNetworkServiceConfig> preferentialNetworkServiceConfigs) {\n        if (!isManagedProfile(userId) && !isDeviceOwnerUserId(userId)) {\n            return;\n        }\n        List<ProfileNetworkPreference> preferences = new ArrayList<>();\n        for (PreferentialNetworkServiceConfig preferentialNetworkServiceConfig :\n                preferentialNetworkServiceConfigs) {\n            ProfileNetworkPreference.Builder preferenceBuilder =\n                    new ProfileNetworkPreference.Builder();\n            if (preferentialNetworkServiceConfig.isEnabled()) {\n                if (preferentialNetworkServiceConfig.isFallbackToDefaultConnectionAllowed()) {\n                    preferenceBuilder.setPreference(PROFILE_NETWORK_PREFERENCE_ENTERPRISE);\n                } else if (preferentialNetworkServiceConfig.shouldBlockNonMatchingNetworks()) {\n                    preferenceBuilder.setPreference(\n                            PROFILE_NETWORK_PREFERENCE_ENTERPRISE_BLOCKING);\n                } else {\n                    preferenceBuilder.setPreference(\n                            PROFILE_NETWORK_PREFERENCE_ENTERPRISE_NO_FALLBACK);\n                }\n                preferenceBuilder.setIncludedUids(\n                        preferentialNetworkServiceConfig.getIncludedUids());\n                preferenceBuilder.setExcludedUids(\n                        preferentialNetworkServiceConfig.getExcludedUids());\n                preferenceBuilder.setPreferenceEnterpriseId(\n                        preferentialNetworkServiceConfig.getNetworkId());\n            } else {\n                preferenceBuilder.setPreference(PROFILE_NETWORK_PREFERENCE_DEFAULT);\n            }\n\n\n            preferences.add(preferenceBuilder.build());\n        }\n        Slogf.d(LOG_TAG, \"updateNetworkPreferenceForUser to \" + preferences);\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.getConnectivityManager().setProfileNetworkPreferences(\n                        UserHandle.of(userId), preferences,\n                        null /* executor */, null /* listener */));\n    }\n\n    @Override\n    public boolean canAdminGrantSensorsPermissions() {\n        if (!mHasFeature) {\n            return false;\n        }\n\n        return mPolicyCache.canAdminGrantSensorsPermissions();\n    }\n\n    @Override\n    public void setDeviceOwnerType(@NonNull ComponentName admin,\n            @DeviceOwnerType int deviceOwnerType) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        synchronized (getLockObject()) {\n            setDeviceOwnerTypeLocked(admin, deviceOwnerType);\n        }\n    }\n\n    private void setDeviceOwnerTypeLocked(ComponentName admin,\n            @DeviceOwnerType int deviceOwnerType) {\n        String packageName = admin.getPackageName();\n        boolean isAdminTestOnly;\n\n        verifyDeviceOwnerTypePreconditionsLocked(admin);\n\n        isAdminTestOnly = isAdminTestOnlyLocked(admin, mOwners.getDeviceOwnerUserId());\n        Preconditions.checkState(isAdminTestOnly\n                        || !mOwners.isDeviceOwnerTypeSetForDeviceOwner(packageName),\n                \"Test only admins can only set the device owner type more than once\");\n\n        mOwners.setDeviceOwnerType(packageName, deviceOwnerType, isAdminTestOnly);\n        setGlobalSettingDeviceOwnerType(deviceOwnerType);\n    }\n\n    // TODO(b/237065504): Allow mainline modules to get the device owner type. This is a workaround\n    // to get the device owner type in PermissionController. See HibernationPolicy.kt.\n    private void setGlobalSettingDeviceOwnerType(int deviceOwnerType) {\n        mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.settingsGlobalPutInt(\"device_owner_type\", deviceOwnerType));\n    }\n\n    @Override\n    @DeviceOwnerType\n    public int getDeviceOwnerType(@NonNull ComponentName admin) {\n        synchronized (getLockObject()) {\n            verifyDeviceOwnerTypePreconditionsLocked(admin);\n            return getDeviceOwnerTypeLocked(admin.getPackageName());\n        }\n    }\n\n    @DeviceOwnerType\n    private int getDeviceOwnerTypeLocked(String packageName) {\n        return mOwners.getDeviceOwnerType(packageName);\n    }\n\n    /**\n     * {@code true} is returned <b>only if</b> the caller is the device owner and the device owner\n     * type is {@link DevicePolicyManager#DEVICE_OWNER_TYPE_FINANCED}. {@code false} is returned for\n     * the case where the caller is not the device owner, there is no device owner, or the device\n     * owner type is not {@link DevicePolicyManager#DEVICE_OWNER_TYPE_FINANCED}.\n     */\n    private boolean isFinancedDeviceOwner(CallerIdentity caller) {\n        synchronized (getLockObject()) {\n            return isDeviceOwnerLocked(caller) && getDeviceOwnerTypeLocked(\n                    mOwners.getDeviceOwnerPackageName()) == DEVICE_OWNER_TYPE_FINANCED;\n        }\n    }\n\n    private void verifyDeviceOwnerTypePreconditionsLocked(@NonNull ComponentName admin) {\n        Preconditions.checkState(mOwners.hasDeviceOwner(), \"there is no device owner\");\n        Preconditions.checkState(mOwners.getDeviceOwnerComponent().equals(admin),\n                \"admin is not the device owner\");\n    }\n\n    @Override\n    public void setUsbDataSignalingEnabled(String packageName, boolean enabled) {\n        Objects.requireNonNull(packageName, \"Admin package name must be provided\");\n        final CallerIdentity caller = getCallerIdentity(packageName);\n\n        synchronized (getLockObject()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    /* admin= */ null, MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            Preconditions.checkState(canUsbDataSignalingBeDisabled(),\n                    \"USB data signaling cannot be disabled.\");\n            mDevicePolicyEngine.setGlobalPolicy(\n                    PolicyDefinition.USB_DATA_SIGNALING,\n                    enforcingAdmin,\n                    new BooleanPolicyValue(enabled));\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_USB_DATA_SIGNALING)\n                .setAdmin(packageName)\n                .setBoolean(enabled)\n                .write();\n    }\n\n    static void updateUsbDataSignal(Context context, boolean value) {\n        if (!canUsbDataSignalingBeDisabledInternal(context)) {\n            return;\n        }\n        if (!Binder.withCleanCallingIdentity(\n                () -> context.getSystemService(UsbManager.class).enableUsbDataSignal(value))) {\n            Slogf.w(LOG_TAG, \"Failed to set usb data signaling state\");\n        }\n    }\n\n    @Override\n    public boolean isUsbDataSignalingEnabled(String packageName) {\n        final CallerIdentity caller = getCallerIdentity(packageName);\n        Boolean enabled = mDevicePolicyEngine.getResolvedPolicy(\n                PolicyDefinition.USB_DATA_SIGNALING,\n                caller.getUserId());\n        return enabled == null || enabled;\n    }\n\n    private boolean isUsbDataSignalingEnabledInternalLocked() {\n        ActiveAdmin admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n        return admin == null || admin.mUsbDataSignalingEnabled;\n    }\n\n    @Override\n    public boolean canUsbDataSignalingBeDisabled() {\n        return canUsbDataSignalingBeDisabledInternal(mContext);\n    }\n\n    private static boolean canUsbDataSignalingBeDisabledInternal(Context context) {\n        return Binder.withCleanCallingIdentity(() ->\n            context.getSystemService(UsbManager.class) != null\n                  && context.getSystemService(UsbManager.class).getUsbHalVersion()\n                  >= UsbManager.USB_HAL_V1_3\n        );\n    }\n\n    private void notifyMinimumRequiredWifiSecurityLevelChanged(int level) {\n        mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getWifiManager()\n                        .notifyMinimumRequiredWifiSecurityLevelChanged(level));\n    }\n\n    private void notifyWifiSsidPolicyChanged(WifiSsidPolicy policy) {\n        if (policy == null) {\n            // If policy doesn't limit SSIDs, no need to disconnect anything.\n            return;\n        }\n        mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getWifiManager().notifyWifiSsidPolicyChanged(policy));\n    }\n\n    @Override\n    public void setMinimumRequiredWifiSecurityLevel(String callerPackageName, int level) {\n        CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller),\n                \"Wi-Fi minimum security level can only be controlled by a device owner or \"\n                        + \"a profile owner on an organization-owned device.\");\n\n        boolean valueChanged = false;\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (admin.mWifiMinimumSecurityLevel != level) {\n                admin.mWifiMinimumSecurityLevel = level;\n                saveSettingsLocked(caller.getUserId());\n                valueChanged = true;\n            }\n        }\n        if (valueChanged) notifyMinimumRequiredWifiSecurityLevelChanged(level);\n    }\n\n    @Override\n    public int getMinimumRequiredWifiSecurityLevel() {\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n            return (admin == null) ? DevicePolicyManager.WIFI_SECURITY_OPEN\n                    : admin.mWifiMinimumSecurityLevel;\n        }\n    }\n\n    @Override\n    public WifiSsidPolicy getWifiSsidPolicy(String callerPackageName) {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller)\n                        || isProfileOwnerOfOrganizationOwnedDevice(caller)\n                        || canQueryAdminPolicy(caller),\n                \"SSID policy can only be retrieved by a device owner or \"\n                        + \"a profile owner on an organization-owned device or \"\n                        + \"an app with the QUERY_ADMIN_POLICY permission.\");\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n            return admin != null ? admin.mWifiSsidPolicy : null;\n        }\n    }\n\n    @Override\n    public boolean isDevicePotentiallyStolen(String callerPackageName) {\n        final CallerIdentity caller = getCallerIdentity(callerPackageName);\n        if (!Flags.deviceTheftImplEnabled()) {\n            return false;\n        }\n        enforcePermission(QUERY_DEVICE_STOLEN_STATE, caller.getPackageName(),\n                caller.getUserId());\n\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                0 != (mLockPatternUtils.getStrongAuthForUser(caller.getUserId())\n                        & SOME_AUTH_REQUIRED_AFTER_ADAPTIVE_AUTH_REQUEST));\n    }\n\n    @Override\n    public void setWifiSsidPolicy(String callerPackageName, WifiSsidPolicy policy) {\n        CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller),\n                \"SSID denylist can only be controlled by a device owner or \"\n                        + \"a profile owner on an organization-owned device.\");\n\n        boolean changed = false;\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (!Objects.equals(policy, admin.mWifiSsidPolicy)) {\n                admin.mWifiSsidPolicy = policy;\n                changed = true;\n            }\n            if (changed) saveSettingsLocked(caller.getUserId());\n        }\n        if (changed) {\n            notifyWifiSsidPolicyChanged(policy);\n        }\n    }\n\n    @Override\n    public void setDrawables(@NonNull List<DevicePolicyDrawableResource> drawables) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                permission.UPDATE_DEVICE_MANAGEMENT_RESOURCES));\n\n        Objects.requireNonNull(drawables, \"drawables must be provided.\");\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (mDeviceManagementResourcesProvider.updateDrawables(drawables)) {\n                sendDrawableUpdatedBroadcast(\n                        drawables.stream().map(s -> s.getDrawableId()).collect(\n                                Collectors.toList()));\n            }\n        });\n    }\n\n    @Override\n    public void resetDrawables(@NonNull List<String> drawableIds) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                permission.UPDATE_DEVICE_MANAGEMENT_RESOURCES));\n\n        Objects.requireNonNull(drawableIds, \"drawableIds must be provided.\");\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (mDeviceManagementResourcesProvider.removeDrawables(drawableIds)) {\n                sendDrawableUpdatedBroadcast(drawableIds);\n            }\n        });\n    }\n\n    @Override\n    public ParcelableResource getDrawable(\n            String drawableId, String drawableStyle, String drawableSource) {\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mDeviceManagementResourcesProvider.getDrawable(\n                        drawableId, drawableStyle, drawableSource));\n    }\n\n    private void sendDrawableUpdatedBroadcast(List<String> drawableIds) {\n        sendResourceUpdatedBroadcast(EXTRA_RESOURCE_TYPE_DRAWABLE, drawableIds);\n    }\n\n    @Override\n    public void setStrings(@NonNull List<DevicePolicyStringResource> strings) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                permission.UPDATE_DEVICE_MANAGEMENT_RESOURCES));\n\n        Objects.requireNonNull(strings, \"strings must be provided.\");\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (mDeviceManagementResourcesProvider.updateStrings(strings)) {\n                sendStringsUpdatedBroadcast(\n                        strings.stream().map(s -> s.getStringId()).collect(Collectors.toList()));\n            }\n        });\n    }\n\n    @Override\n    public void resetStrings(@NonNull List<String> stringIds) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                permission.UPDATE_DEVICE_MANAGEMENT_RESOURCES));\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (mDeviceManagementResourcesProvider.removeStrings(stringIds)) {\n                sendStringsUpdatedBroadcast(stringIds);\n            }\n        });\n    }\n\n    @Override\n    public ParcelableResource getString(String stringId) {\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mDeviceManagementResourcesProvider.getString(stringId));\n    }\n\n    private void sendStringsUpdatedBroadcast(List<String> stringIds) {\n        sendResourceUpdatedBroadcast(EXTRA_RESOURCE_TYPE_STRING, stringIds);\n    }\n\n    private void sendResourceUpdatedBroadcast(int resourceType, List<String> resourceIds) {\n        final Intent intent = new Intent(ACTION_DEVICE_POLICY_RESOURCE_UPDATED);\n        intent.putExtra(EXTRA_RESOURCE_IDS, resourceIds.toArray(String[]::new));\n        intent.putExtra(EXTRA_RESOURCE_TYPE, resourceType);\n        intent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n\n        List<UserInfo> users = mUserManager.getAliveUsers();\n        for (int i = 0; i < users.size(); i++) {\n            UserHandle user = users.get(i).getUserHandle();\n            mContext.sendBroadcastAsUser(intent, user);\n        }\n    }\n\n    private String getUpdatableString(\n            String updatableStringId, int defaultStringId, Object... formatArgs) {\n        ParcelableResource resource = mDeviceManagementResourcesProvider.getString(\n                updatableStringId);\n        if (resource == null) {\n            return ParcelableResource.loadDefaultString(() ->\n                    mContext.getString(defaultStringId, formatArgs));\n        }\n        return resource.getString(\n                mContext, () -> mContext.getString(defaultStringId, formatArgs), formatArgs);\n    }\n\n    public boolean isDpcDownloaded() {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        ContentResolver cr = mContext.getContentResolver();\n\n        return mInjector.binderWithCleanCallingIdentity(() -> Settings.Secure.getIntForUser(\n                cr, MANAGED_PROVISIONING_DPC_DOWNLOADED,\n                /* def= */ 0, /* userHandle= */ cr.getUserId())\n                == 1);\n    }\n\n    public void setDpcDownloaded(boolean downloaded) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        int setTo = downloaded ? 1 : 0;\n\n        mInjector.binderWithCleanCallingIdentity(() -> Settings.Secure.putInt(\n                mContext.getContentResolver(), MANAGED_PROVISIONING_DPC_DOWNLOADED, setTo));\n    }\n\n    @Override\n    public void resetShouldAllowBypassingDevicePolicyManagementRoleQualificationState() {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                permission.MANAGE_ROLE_HOLDERS));\n        setBypassDevicePolicyManagementRoleQualificationStateInternal(\n                /* currentRoleHolder= */ null, /* allowBypass= */ false);\n    }\n\n    @Override\n    public boolean shouldAllowBypassingDevicePolicyManagementRoleQualification() {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                permission.MANAGE_ROLE_HOLDERS));\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            if (getUserData(\n                    UserHandle.USER_SYSTEM).mBypassDevicePolicyManagementRoleQualifications) {\n                return true;\n            }\n            return shouldAllowBypassingDevicePolicyManagementRoleQualificationInternal();\n        });\n    }\n\n    private boolean shouldAllowBypassingDevicePolicyManagementRoleQualificationInternal() {\n        if (nonTestNonPrecreatedUsersExist()) {\n            return false;\n        }\n\n\n        return !hasIncompatibleAccountsOnAnyUser();\n    }\n\n    private boolean hasAccountsOnAnyUser() {\n        long callingIdentity = Binder.clearCallingIdentity();\n        try {\n            for (UserInfo user : mUserManagerInternal.getUsers(/* excludeDying= */ true)) {\n                AccountManager am = mContext.createContextAsUser(\n                                UserHandle.of(user.id), /* flags= */ 0)\n                        .getSystemService(AccountManager.class);\n                Account[] accounts = am.getAccounts();\n                if (accounts.length != 0) {\n                    return true;\n                }\n            }\n\n            return false;\n        } finally {\n            Binder.restoreCallingIdentity(callingIdentity);\n        }\n    }\n\n    private void setBypassDevicePolicyManagementRoleQualificationStateInternal(\n            String currentRoleHolder, boolean allowBypass) {\n        boolean stateChanged = false;\n        DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n        if (policy.mBypassDevicePolicyManagementRoleQualifications != allowBypass) {\n            policy.mBypassDevicePolicyManagementRoleQualifications = allowBypass;\n            stateChanged = true;\n        }\n        if (!Objects.equals(currentRoleHolder, policy.mCurrentRoleHolder)) {\n            policy.mCurrentRoleHolder = currentRoleHolder;\n            stateChanged = true;\n        }\n        if (stateChanged) {\n            synchronized (getLockObject()) {\n                saveSettingsLocked(UserHandle.USER_SYSTEM);\n            }\n        }\n    }\n\n    private final class DevicePolicyManagementRoleObserver implements OnRoleHoldersChangedListener {\n        private final RoleManager mRm;\n        private final Executor mExecutor;\n        private final Context mContext;\n\n        DevicePolicyManagementRoleObserver(@NonNull Context context) {\n            mContext = context;\n            mExecutor = mContext.getMainExecutor();\n            mRm = mContext.getSystemService(RoleManager.class);\n        }\n\n        public void register() {\n            mRm.addOnRoleHoldersChangedListenerAsUser(mExecutor, this, UserHandle.ALL);\n        }\n\n        @Override\n        public void onRoleHoldersChanged(@NonNull String roleName, @NonNull UserHandle user) {\n            mDevicePolicyEngine.handleRoleChanged(roleName, user.getIdentifier());\n            switch (roleName) {\n                case RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT ->\n                        handleDevicePolicyManagementRoleChange(user);\n                case RoleManager.ROLE_FINANCED_DEVICE_KIOSK ->\n                        handleFinancedDeviceKioskRoleChange();\n            }\n        }\n\n        private void handleDevicePolicyManagementRoleChange(UserHandle user) {\n            String newRoleHolder = getDeviceManagementRoleHolder(user);\n            if (isDefaultRoleHolder(newRoleHolder)) {\n                Slogf.i(LOG_TAG,\n                        \"onRoleHoldersChanged: Default role holder is set, returning early\");\n                return;\n            }\n            if (newRoleHolder == null) {\n                Slogf.i(LOG_TAG,\n                        \"onRoleHoldersChanged: New role holder is null, returning early\");\n                return;\n            }\n            if (shouldAllowBypassingDevicePolicyManagementRoleQualificationInternal()) {\n                Slogf.w(LOG_TAG,\n                        \"onRoleHoldersChanged: Updating current role holder to \" + newRoleHolder);\n                setBypassDevicePolicyManagementRoleQualificationStateInternal(\n                        newRoleHolder, /* allowBypass= */ true);\n                return;\n            }\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            if (!newRoleHolder.equals(policy.mCurrentRoleHolder)) {\n                Slogf.w(LOG_TAG,\n                        \"onRoleHoldersChanged: You can't set a different role holder, role \"\n                                + \"is getting revoked from \" + newRoleHolder);\n                setBypassDevicePolicyManagementRoleQualificationStateInternal(\n                        /* currentRoleHolder= */ null, /* allowBypass= */ false);\n                mRm.removeRoleHolderAsUser(\n                        RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT,\n                        newRoleHolder,\n                        /* flags= */ 0,\n                        user,\n                        mExecutor,\n                        successful -> {});\n            }\n        }\n\n        private void handleFinancedDeviceKioskRoleChange() {\n            Slog.i(LOG_TAG, \"Handling action \" + ACTION_DEVICE_FINANCING_STATE_CHANGED);\n            Intent intent = new Intent(ACTION_DEVICE_FINANCING_STATE_CHANGED);\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                for (UserInfo userInfo : mUserManager.getUsers()) {\n                    UserHandle user = userInfo.getUserHandle();\n                    broadcastExplicitIntentToRoleHolder(\n                            intent, RoleManager.ROLE_SYSTEM_SUPERVISION, user);\n                    broadcastExplicitIntentToRoleHolder(\n                            intent, RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT, user);\n                    ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(user.getIdentifier());\n                    if (admin == null) {\n                        continue;\n                    }\n                    if (!isProfileOwnerOfOrganizationOwnedDevice(\n                            admin.info.getComponent(), user.getIdentifier())\n                            && !isDeviceOwner(admin)\n                            && !(isProfileOwner(admin.info.getComponent(), user.getIdentifier())\n                            && admin.getUserHandle().isSystem())) {\n                        continue;\n                    }\n                    // Don't send the broadcast twice if the DPC is the same package as the\n                    // DMRH\n                    if (admin.info.getPackageName().equals(getDeviceManagementRoleHolder(user))) {\n                        continue;\n                    }\n                    broadcastExplicitIntentToPackage(\n                            intent, admin.info.getPackageName(), admin.getUserHandle());\n                }\n            });\n        }\n\n        private String getDeviceManagementRoleHolder(UserHandle user) {\n            return DevicePolicyManagerService.this.getRoleHolderPackageNameOnUser(\n                    mContext, RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT, user);\n        }\n\n        private boolean isDefaultRoleHolder(String packageName) {\n            String defaultRoleHolder = getDefaultRoleHolderPackageName();\n            if (packageName == null || defaultRoleHolder == null) {\n                return false;\n            }\n            if (!defaultRoleHolder.equals(packageName)) {\n                return false;\n            }\n            return hasSigningCertificate(\n                    packageName, getDefaultRoleHolderPackageSignature());\n        }\n\n        private boolean hasSigningCertificate(String packageName, String  certificateString) {\n            if (packageName == null || certificateString == null) {\n                return false;\n            }\n            byte[] certificate;\n            try {\n                certificate = new Signature(certificateString).toByteArray();\n            } catch (IllegalArgumentException e) {\n                Slogf.w(LOG_TAG, \"Cannot parse signing certificate: \" + certificateString, e);\n                return false;\n            }\n            PackageManager pm = mInjector.getPackageManager();\n            return pm.hasSigningCertificate(\n                    packageName, certificate, PackageManager.CERT_INPUT_SHA256);\n        }\n\n        private String getDefaultRoleHolderPackageName() {\n            String[] info = getDefaultRoleHolderPackageNameAndSignature();\n            if (info == null) {\n                return null;\n            }\n            return info[0];\n        }\n\n        private String getDefaultRoleHolderPackageSignature() {\n            String[] info = getDefaultRoleHolderPackageNameAndSignature();\n            if (info == null || info.length < 2) {\n                return null;\n            }\n            return info[1];\n        }\n\n        private String[] getDefaultRoleHolderPackageNameAndSignature() {\n            String packageNameAndSignature = mContext.getString(\n                    R.string.config_devicePolicyManagement);\n            if (TextUtils.isEmpty(packageNameAndSignature)) {\n                return null;\n            }\n            if (packageNameAndSignature.contains(\":\")) {\n                return packageNameAndSignature.split(\":\");\n            }\n            return new String[]{packageNameAndSignature};\n        }\n    }\n\n    private void broadcastExplicitIntentToRoleHolder(\n            Intent intent, String role, UserHandle userHandle) {\n        String packageName = getRoleHolderPackageNameOnUser(mContext, role, userHandle);\n        if (packageName == null) {\n            return;\n        }\n        broadcastExplicitIntentToPackage(intent, packageName, userHandle);\n    }\n\n    private void broadcastExplicitIntentToPackage(\n            Intent intent, String packageName, UserHandle userHandle) {\n        int userId = userHandle.getIdentifier();\n        if (packageName == null) {\n            return;\n        }\n        Intent packageIntent = new Intent(intent)\n                .setPackage(packageName);\n        List<ResolveInfo> receivers = mContext.getPackageManager().queryBroadcastReceiversAsUser(\n                packageIntent,\n                PackageManager.ResolveInfoFlags.of(PackageManager.GET_RECEIVERS),\n                userId);\n        if (receivers.isEmpty()) {\n            Slog.i(LOG_TAG, \"Found no receivers to handle intent \" + intent\n                    + \" in package \" + packageName);\n            return;\n        }\n        for (ResolveInfo receiver : receivers) {\n            Intent componentIntent = new Intent(packageIntent)\n                    .setComponent(receiver.getComponentInfo().getComponentName())\n                    .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n            mContext.sendBroadcastAsUser(componentIntent, userHandle);\n        }\n    }\n\n    @Override\n    public List<UserHandle> getPolicyManagedProfiles(@NonNull UserHandle user) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        int userId = user.getIdentifier();\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            List<UserInfo> userProfiles = mUserManager.getProfiles(userId);\n            List<UserHandle> result = new ArrayList<>();\n            for (int i = 0; i < userProfiles.size(); i++) {\n                UserInfo userInfo = userProfiles.get(i);\n                if (userInfo.isManagedProfile() && hasProfileOwner(userInfo.id)) {\n                    result.add(new UserHandle(userInfo.id));\n                }\n            }\n            return result;\n        });\n    }\n\n    // DPC types\n    private static final int NOT_A_DPC = -1;\n    private static final int DEFAULT_DEVICE_OWNER = 0;\n    private static final int FINANCED_DEVICE_OWNER = 1;\n    private static final int PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE = 2;\n    private static final int PROFILE_OWNER_ON_USER_0 = 3;\n    private static final int PROFILE_OWNER = 4;\n    private static final int PROFILE_OWNER_ON_USER = 5;\n    private static final int AFFILIATED_PROFILE_OWNER_ON_USER = 6;\n    // DPC types\n    @IntDef(value = {\n            NOT_A_DPC,\n            DEFAULT_DEVICE_OWNER,\n            FINANCED_DEVICE_OWNER,\n            PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE,\n            PROFILE_OWNER_ON_USER_0,\n            PROFILE_OWNER,\n            PROFILE_OWNER_ON_USER,\n            AFFILIATED_PROFILE_OWNER_ON_USER\n    })\n    private @interface DpcType {}\n\n    // Permissions of existing DPC types.\n    private static final List<String> DEFAULT_DEVICE_OWNER_PERMISSIONS = List.of(\n            MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT,\n            MANAGE_DEVICE_POLICY_ACROSS_USERS,\n            MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL,\n            MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL,\n            MANAGE_DEVICE_POLICY_AIRPLANE_MODE,\n            MANAGE_DEVICE_POLICY_APPS_CONTROL,\n            MANAGE_DEVICE_POLICY_APP_FUNCTIONS,\n            MANAGE_DEVICE_POLICY_APP_RESTRICTIONS,\n            MANAGE_DEVICE_POLICY_AUDIO_OUTPUT,\n            MANAGE_DEVICE_POLICY_AUTOFILL,\n            MANAGE_DEVICE_POLICY_BLUETOOTH,\n            MANAGE_DEVICE_POLICY_CALLS,\n            MANAGE_DEVICE_POLICY_CAMERA,\n            MANAGE_DEVICE_POLICY_CERTIFICATES,\n            MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE,\n            MANAGE_DEVICE_POLICY_CONTENT_PROTECTION,\n            MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES,\n            MANAGE_DEVICE_POLICY_DEFAULT_SMS,\n            MANAGE_DEVICE_POLICY_DISPLAY,\n            MANAGE_DEVICE_POLICY_FACTORY_RESET,\n            MANAGE_DEVICE_POLICY_FUN,\n            MANAGE_DEVICE_POLICY_INPUT_METHODS,\n            MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES,\n            MANAGE_DEVICE_POLICY_KEYGUARD,\n            MANAGE_DEVICE_POLICY_LOCALE,\n            MANAGE_DEVICE_POLICY_LOCATION,\n            MANAGE_DEVICE_POLICY_LOCK,\n            MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n            MANAGE_DEVICE_POLICY_LOCK_TASK,\n            MANAGE_DEVICE_POLICY_MANAGED_SUBSCRIPTIONS,\n            MANAGE_DEVICE_POLICY_MICROPHONE,\n            MANAGE_DEVICE_POLICY_MOBILE_NETWORK,\n            MANAGE_DEVICE_POLICY_MODIFY_USERS,\n            MANAGE_DEVICE_POLICY_MTE,\n            MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION,\n            MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,\n            MANAGE_DEVICE_POLICY_PACKAGE_STATE,\n            MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA,\n            MANAGE_DEVICE_POLICY_PRINTING,\n            MANAGE_DEVICE_POLICY_PROFILES,\n            MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n            MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n            MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS,\n            MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,\n            MANAGE_DEVICE_POLICY_SAFE_BOOT,\n            MANAGE_DEVICE_POLICY_SCREEN_CAPTURE,\n            MANAGE_DEVICE_POLICY_SCREEN_CONTENT,\n            MANAGE_DEVICE_POLICY_SECURITY_LOGGING,\n            MANAGE_DEVICE_POLICY_SMS,\n            MANAGE_DEVICE_POLICY_STATUS_BAR,\n            MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,\n            MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS,\n            MANAGE_DEVICE_POLICY_SYSTEM_UPDATES,\n            MANAGE_DEVICE_POLICY_TIME,\n            MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING,\n            MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER,\n            MANAGE_DEVICE_POLICY_VPN,\n            MANAGE_DEVICE_POLICY_WALLPAPER,\n            MANAGE_DEVICE_POLICY_WIFI,\n            MANAGE_DEVICE_POLICY_WINDOWS,\n            MANAGE_DEVICE_POLICY_WIPE_DATA,\n            SET_TIME,\n            SET_TIME_ZONE,\n            MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES\n    );\n    private static final List<String> FINANCED_DEVICE_OWNER_PERMISSIONS = List.of(\n            MANAGE_DEVICE_POLICY_ACROSS_USERS,\n            MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL,\n            MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL,\n            MANAGE_DEVICE_POLICY_APPS_CONTROL,\n            MANAGE_DEVICE_POLICY_CALLS,\n            MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES,\n            MANAGE_DEVICE_POLICY_FACTORY_RESET,\n            MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES,\n            MANAGE_DEVICE_POLICY_KEYGUARD,\n            MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n            MANAGE_DEVICE_POLICY_LOCK_TASK,\n            MANAGE_DEVICE_POLICY_MODIFY_USERS,\n            MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,\n            MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,\n            MANAGE_DEVICE_POLICY_SAFE_BOOT,\n            MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,\n            MANAGE_DEVICE_POLICY_TIME,\n            MANAGE_DEVICE_POLICY_WIPE_DATA\n    );\n\n    /**\n     * All the permissions granted to a profile owner.\n     */\n    private static final List<String> PROFILE_OWNER_PERMISSIONS  =\n            List.of(\n                    MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT,\n                    MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL,\n                    MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                    MANAGE_DEVICE_POLICY_APP_FUNCTIONS,\n                    MANAGE_DEVICE_POLICY_APP_RESTRICTIONS,\n                    MANAGE_DEVICE_POLICY_AUDIO_OUTPUT,\n                    MANAGE_DEVICE_POLICY_AUTOFILL,\n                    MANAGE_DEVICE_POLICY_BLUETOOTH,\n                    MANAGE_DEVICE_POLICY_CALLS,\n                    MANAGE_DEVICE_POLICY_CAMERA,\n                    MANAGE_DEVICE_POLICY_CERTIFICATES,\n                    MANAGE_DEVICE_POLICY_CONTENT_PROTECTION,\n                    MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES,\n                    MANAGE_DEVICE_POLICY_DISPLAY,\n                    MANAGE_DEVICE_POLICY_FACTORY_RESET,\n                    MANAGE_DEVICE_POLICY_INPUT_METHODS,\n                    MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES,\n                    MANAGE_DEVICE_POLICY_KEYGUARD,\n                    MANAGE_DEVICE_POLICY_LOCALE,\n                    MANAGE_DEVICE_POLICY_LOCATION,\n                    MANAGE_DEVICE_POLICY_LOCK,\n                    MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                    MANAGE_DEVICE_POLICY_MANAGED_SUBSCRIPTIONS,\n                    MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION,\n                    MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,\n                    MANAGE_DEVICE_POLICY_PACKAGE_STATE,\n                    MANAGE_DEVICE_POLICY_PRINTING,\n                    MANAGE_DEVICE_POLICY_PROFILES,\n                    MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                    MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                    MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,\n                    MANAGE_DEVICE_POLICY_SCREEN_CAPTURE,\n                    MANAGE_DEVICE_POLICY_SCREEN_CONTENT,\n                    MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,\n                    MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS,\n                    MANAGE_DEVICE_POLICY_TIME,\n                    MANAGE_DEVICE_POLICY_VPN,\n                    MANAGE_DEVICE_POLICY_WIPE_DATA,\n                    MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES\n            );\n\n    /**\n     * All the additional permissions granted to an organisation owned profile owner.\n     */\n    private static final List<String>\n            ADDITIONAL_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS =\n            List.of(\n                    MANAGE_DEVICE_POLICY_ACROSS_USERS,\n                    MANAGE_DEVICE_POLICY_AIRPLANE_MODE,\n                    MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                    MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE,\n                    MANAGE_DEVICE_POLICY_DEFAULT_SMS,\n                    MANAGE_DEVICE_POLICY_LOCALE,\n                    MANAGE_DEVICE_POLICY_MICROPHONE,\n                    MANAGE_DEVICE_POLICY_MOBILE_NETWORK,\n                    MANAGE_DEVICE_POLICY_MTE,\n                    MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION,\n                    MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA,\n                    MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS,\n                    MANAGE_DEVICE_POLICY_SAFE_BOOT,\n                    MANAGE_DEVICE_POLICY_SECURITY_LOGGING,\n                    MANAGE_DEVICE_POLICY_SMS,\n                    MANAGE_DEVICE_POLICY_SYSTEM_UPDATES,\n                    MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING,\n                    MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER,\n                    MANAGE_DEVICE_POLICY_WIFI,\n                    SET_TIME,\n                    SET_TIME_ZONE\n            );\n\n    /**\n     * All the additional permissions granted to a Profile Owner on user 0.\n     */\n    private static final List<String> ADDITIONAL_PROFILE_OWNER_ON_USER_0_PERMISSIONS =\n            List.of(\n                    MANAGE_DEVICE_POLICY_AIRPLANE_MODE,\n                    MANAGE_DEVICE_POLICY_DISPLAY,\n                    MANAGE_DEVICE_POLICY_FUN,\n                    MANAGE_DEVICE_POLICY_LOCK_TASK,\n                    MANAGE_DEVICE_POLICY_MOBILE_NETWORK,\n                    MANAGE_DEVICE_POLICY_MODIFY_USERS,\n                    MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA,\n                    MANAGE_DEVICE_POLICY_PRINTING,\n                    MANAGE_DEVICE_POLICY_PROFILES,\n                    MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                    MANAGE_DEVICE_POLICY_SAFE_BOOT,\n                    MANAGE_DEVICE_POLICY_SMS,\n                    MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS,\n                    MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER,\n                    MANAGE_DEVICE_POLICY_WINDOWS,\n                    SET_TIME,\n                    SET_TIME_ZONE\n            );\n\n    /**\n     * All the additional permissions granted to a Profile Owner on an unaffiliated user.\n     */\n    private static final List<String> ADDITIONAL_PROFILE_OWNER_ON_USER_PERMISSIONS =\n            List.of(\n                    MANAGE_DEVICE_POLICY_LOCK_TASK\n            );\n\n    /**\n     * All the additional permissions granted to a Profile Owner on an affiliated user.\n     */\n    private static final List<String> ADDITIONAL_AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS =\n            List.of(\n                    MANAGE_DEVICE_POLICY_STATUS_BAR\n            );\n\n    /**\n     * Combination of {@link PROFILE_OWNER_PERMISSIONS} and\n     * {@link ADDITIONAL_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS}.\n     */\n    private static final List<String> PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS =\n            new ArrayList();\n\n    /**\n     * Combination of {@link PROFILE_OWNER_PERMISSIONS} and\n     * {@link ADDITIONAL_PROFILE_OWNER_ON_USER_0_PERMISSIONS}.\n     */\n    private static final List<String> PROFILE_OWNER_ON_USER_0_PERMISSIONS  =\n            new ArrayList();\n\n    /**\n     * Combination of {@link PROFILE_OWNER_PERMISSIONS} and\n     * {@link ADDITIONAL_AFFILIATED_PROFIL_OWNER_ON_USER_PERMISSIONS}.\n     */\n    private static final List<String> AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS =\n            new ArrayList();\n\n    /**\n     * Combination of {@link PROFILE_OWNER_PERMISSIONS} and\n     * {@link ADDITIONAL_PROFILE_OWNER_ON_USER_PERMISSIONS}.\n     */\n    private static final List<String> PROFILE_OWNER_ON_USER_PERMISSIONS =\n            new ArrayList();\n\n\n    private static final HashMap<Integer, List<String>> DPC_PERMISSIONS = new HashMap<>();\n    {\n        // Organisation owned profile owners have all the permission of a profile owner plus\n        // some extra permissions.\n        PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS.addAll(PROFILE_OWNER_PERMISSIONS);\n        PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS.addAll(\n                ADDITIONAL_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS);\n        // Profile owners on user 0 have all the permission of a profile owner plus\n        // some extra permissions.\n        PROFILE_OWNER_ON_USER_0_PERMISSIONS.addAll(PROFILE_OWNER_PERMISSIONS);\n        PROFILE_OWNER_ON_USER_0_PERMISSIONS.addAll(ADDITIONAL_PROFILE_OWNER_ON_USER_0_PERMISSIONS);\n        // Profile owners on users have all the permission of a profile owner plus\n        // some extra permissions.\n        PROFILE_OWNER_ON_USER_PERMISSIONS.addAll(PROFILE_OWNER_PERMISSIONS);\n        PROFILE_OWNER_ON_USER_PERMISSIONS.addAll(\n                ADDITIONAL_PROFILE_OWNER_ON_USER_PERMISSIONS);\n        // Profile owners on affiliated users have all the permission of a profile owner on a user\n        // plus some extra permissions.\n        AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS.addAll(PROFILE_OWNER_ON_USER_PERMISSIONS);\n        AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS.addAll(\n                ADDITIONAL_AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS);\n\n        DPC_PERMISSIONS.put(DEFAULT_DEVICE_OWNER, DEFAULT_DEVICE_OWNER_PERMISSIONS);\n        DPC_PERMISSIONS.put(FINANCED_DEVICE_OWNER, FINANCED_DEVICE_OWNER_PERMISSIONS);\n        DPC_PERMISSIONS.put(PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE,\n                PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS);\n        DPC_PERMISSIONS.put(PROFILE_OWNER_ON_USER_0, PROFILE_OWNER_ON_USER_0_PERMISSIONS);\n        DPC_PERMISSIONS.put(PROFILE_OWNER, PROFILE_OWNER_PERMISSIONS);\n        DPC_PERMISSIONS.put(PROFILE_OWNER_ON_USER, PROFILE_OWNER_ON_USER_PERMISSIONS);\n        DPC_PERMISSIONS.put(AFFILIATED_PROFILE_OWNER_ON_USER,\n                AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS);\n    }\n    //Map of Permission to Delegate Scope.\n    private static final HashMap<String, String> DELEGATE_SCOPES = new HashMap<>();\n    {\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_APP_RESTRICTIONS, DELEGATION_APP_RESTRICTIONS);\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_BLOCK_UNINSTALL, DELEGATION_BLOCK_UNINSTALL);\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_CERTIFICATES, DELEGATION_CERT_INSTALL);\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_PACKAGE_STATE, DELEGATION_PACKAGE_ACCESS);\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS, DELEGATION_PERMISSION_GRANT);\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_SECURITY_LOGGING, DELEGATION_SECURITY_LOGGING);\n    }\n\n    private static final HashMap<String, String> CROSS_USER_PERMISSIONS =\n            new HashMap<>();\n    {\n        // The permissions are all intrinsically global and therefore have no cross-user permission.\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_FACTORY_RESET, null);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MTE, null);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SECURITY_LOGGING, null);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_STATUS_BAR, null);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SYSTEM_UPDATES, null);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING, null);\n        CROSS_USER_PERMISSIONS.put(SET_TIME, null);\n        CROSS_USER_PERMISSIONS.put(SET_TIME_ZONE, null);\n\n        // The permissions are all critical for securing data within the current user and\n        // therefore are protected with MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL for\n        // cross-user calls.\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_KEYGUARD,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL);\n        if (Flags.lockNowCoexistence()) {\n            CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCK,\n                    MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL);\n        }\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL);\n\n        // These permissions are required for securing device ownership without accessing user data\n        // and therefore are protected with MANAGE_DEVICE_POLICY_ACROSS_USERS for cross-user calls.\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_AIRPLANE_MODE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_BLUETOOTH,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_CALLS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_CAMERA,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_DEFAULT_SMS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_INPUT_METHODS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MICROPHONE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MOBILE_NETWORK,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PACKAGE_STATE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SCREEN_CAPTURE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SMS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SAFE_BOOT,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_TIME,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_WIFI,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_WIPE_DATA,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_CONTENT_PROTECTION,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_APP_FUNCTIONS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n\n        // These permissions may grant access to user data and therefore must be protected with\n        // MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL for cross-user calls.\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_APP_RESTRICTIONS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_AUDIO_OUTPUT,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_AUTOFILL,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_BLOCK_UNINSTALL,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_CAMERA_TOGGLE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_DISPLAY,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_FUN,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCALE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCATION,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        if (!Flags.lockNowCoexistence()) {\n            CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCK,\n                    MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        }\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCK_TASK,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MODIFY_USERS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MICROPHONE_TOGGLE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PROFILES,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PRINTING,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SCREEN_CONTENT,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_VPN,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_WALLPAPER,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_WINDOWS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user. Only one permission provided in the list needs to be granted to pass this\n     * check.\n     * The given permissions will be checked along with their associated cross-user permissions if\n     * they exists and the target user is different to the calling user.\n     * Returns an {@link EnforcingAdmin} for the caller.\n     *\n     * @param admin the component name of the admin.\n     * @param callerPackageName The package name of the calling application.\n     * @param permissions an array of permission names to be checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private EnforcingAdmin enforcePermissionsAndGetEnforcingAdmin(@Nullable ComponentName admin,\n            String[] permissions, String callerPackageName, int targetUserId) {\n        enforcePermissions(permissions, callerPackageName, targetUserId);\n        return getEnforcingAdminForCaller(admin, callerPackageName);\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user.\n     * The given permission will be checked along with its associated cross-user permission if it\n     * exists and the target user is different to the calling user.\n     * Returns an {@link EnforcingAdmin} for the caller.\n     *\n     * @param admin the component name of the admin.\n     * @param callerPackageName The package name of the calling application.\n     * @param permission The name of the permission being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private EnforcingAdmin enforcePermissionAndGetEnforcingAdmin(@Nullable ComponentName admin,\n            String permission, String callerPackageName, int targetUserId) {\n        enforcePermission(permission, callerPackageName, targetUserId);\n        return getEnforcingAdminForCaller(admin, callerPackageName);\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user.  Only one permission provided in the list needs to be granted to pass this\n     * check.\n     * The given permissions will be checked along with their associated cross-user permissions if\n     * they exist and the target user is different to the calling user.\n     * Returns an {@link EnforcingAdmin} for the caller.\n     *\n     * @param admin the component name of the admin.\n     * @param callerPackageName The package name of the calling application.\n     * @param permissions The names of the permissions being checked.\n     * @param deviceAdminPolicy The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private EnforcingAdmin enforcePermissionsAndGetEnforcingAdmin(@Nullable ComponentName admin,\n            String[] permissions, int deviceAdminPolicy, String callerPackageName,\n            int targetUserId) {\n        enforcePermissions(permissions, deviceAdminPolicy, callerPackageName, targetUserId);\n        return getEnforcingAdminForCaller(admin, callerPackageName);\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param permission The name of the permission being checked.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private void enforcePermission(String permission, String callerPackageName)\n            throws SecurityException {\n        if (!hasPermission(permission, callerPackageName)) {\n            throw new SecurityException(\"Caller does not have the required permissions for \"\n                    + \"this user. Permission required: \"\n                    + permission\n                    + \".\");\n        }\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user. Only one permission provided in the list needs to be granted to pass this\n     * check.\n     * The given permissions will be checked along with their associated cross-user permissions if\n     * they exists and the target user is different to the calling user.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param permissions The names of the permissions being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private void enforcePermission(String permission, String callerPackageName, int targetUserId)\n            throws SecurityException {\n        enforcePermission(permission, callerPackageName);\n        if (targetUserId != getCallerIdentity(callerPackageName).getUserId()) {\n            enforcePermission(CROSS_USER_PERMISSIONS.get(permission), callerPackageName);\n        }\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user. Only one of the given permissions will be required to be held to pass this\n     * check.\n     * The given permissions will be checked along with their associated cross-user permissions if\n     * they exist and the target user is different to the calling user.\n     *\n     * @param permissions An array of the names of the permissions being checked.\n     * @param callerPackageName The package name  of the calling application.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private void enforcePermissions(String[] permissions, String callerPackageName,\n            int targetUserId) throws SecurityException {\n        String heldPermission = \"\";\n        for (String permission : permissions) {\n            if (hasPermission(permission, callerPackageName)) {\n                heldPermission = permission;\n                break;\n            }\n        }\n        if (heldPermission.isEmpty()) {\n            throw new SecurityException(\"Caller does not have the required permissions for \"\n                    + \"this user. One of the following permission required: \"\n                    + Arrays.toString(permissions));\n        }\n        enforcePermission(heldPermission, callerPackageName, targetUserId);\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user.\n     * The given permission will be checked along with its associated cross-user permission if it\n     * exists and the target user is different to the calling user.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param adminPolicy The admin policy that should grant holders permission.\n     * @param permissions The names of the permissions being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private void enforcePermissions(String[] permissions, int adminPolicy,\n            String callerPackageName, int targetUserId) throws SecurityException {\n        if (hasAdminPolicy(adminPolicy, callerPackageName)\n                && mInjector.userHandleGetCallingUserId() == targetUserId) {\n            return;\n        }\n        enforcePermissions(permissions, callerPackageName, targetUserId);\n    }\n\n    /**\n     * Checks whether the calling process has been granted permission to query a device policy on\n     * a specific user.\n     * The given permission will be checked along with its associated cross-user permission if it\n     * exists and the target user is different to the calling user.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param permission The name of the permission being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user\n     * and if the user has not been granted {@link QUERY_ADMIN_POLICY}.\n     */\n    private void enforceCanQuery(String permission, String callerPackageName, int targetUserId)\n            throws SecurityException {\n        if (hasPermission(QUERY_ADMIN_POLICY, callerPackageName)) {\n            return;\n        }\n        enforcePermission(permission, callerPackageName, targetUserId);\n    }\n\n    private boolean hasAdminPolicy(int adminPolicy, String callerPackageName) {\n        synchronized (getLockObject()) {\n            CallerIdentity caller = getCallerIdentity(callerPackageName);\n            ActiveAdmin deviceAdmin = getActiveAdminWithPolicyForUidLocked(\n                    null, adminPolicy, caller.getUid());\n            return deviceAdmin != null;\n        }\n    }\n\n    /**\n     * Return whether the calling process has been granted permission to apply a device policy on\n     * a specific user.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param permission The name of the permission being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     */\n    private boolean hasPermission(String permission, String callerPackageName, int targetUserId) {\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        boolean hasPermissionOnOwnUser = hasPermission(permission, caller.getPackageName());\n        boolean hasPermissionOnTargetUser = true;\n        if (hasPermissionOnOwnUser && caller.getUserId() != targetUserId) {\n            hasPermissionOnTargetUser = hasPermissionOnTargetUser\n                    && hasPermission(CROSS_USER_PERMISSIONS.get(permission),\n                        caller.getPackageName());\n        }\n\n        return hasPermissionOnOwnUser && hasPermissionOnTargetUser;\n    }\n\n    /**\n     * Return whether the calling process has been granted the given permission.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param permission The name of the permission being checked.\n     */\n    private boolean hasPermission(String permission, @NonNull String callerPackageName) {\n        Objects.requireNonNull(callerPackageName, \"callerPackageName is null\");\n        if (permission == null) {\n            return true;\n        }\n\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n\n        // Check if the caller holds the permission\n        if (mContext.checkCallingOrSelfPermission(permission) == PERMISSION_GRANTED) {\n            return true;\n        }\n        int dpcType = getDpcType(caller);\n        if (dpcType != NOT_A_DPC) {\n            return DPC_PERMISSIONS.get(dpcType).contains(permission);\n        }\n        // Check the permission for the role-holder\n        if (isCallerDevicePolicyManagementRoleHolder(caller)) {\n            return anyDpcHasPermission(permission, caller.getUserId());\n        }\n        if (DELEGATE_SCOPES.containsKey(permission)) {\n            return isCallerDelegate(caller, DELEGATE_SCOPES.get(permission));\n        }\n        return false;\n    }\n\n    /**\n     * Returns whether there is a DPC on the given user that has been granted the given permission.\n     *\n     * @param permission The name of the permission being checked.\n     * @param userId The id of the user to check.\n     */\n    private boolean anyDpcHasPermission(String permission, int userId) {\n        if (mOwners.isDefaultDeviceOwnerUserId(userId)) {\n            return DPC_PERMISSIONS.get(DEFAULT_DEVICE_OWNER).contains(permission);\n        }\n        if (mOwners.isFinancedDeviceOwnerUserId(userId)) {\n            return DPC_PERMISSIONS.get(FINANCED_DEVICE_OWNER).contains(permission);\n        }\n        if (mOwners.isProfileOwnerOfOrganizationOwnedDevice(userId)) {\n            return DPC_PERMISSIONS.get(PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE).contains(\n                    permission);\n        }\n        if (userId == 0 && mOwners.hasProfileOwner(0)) {\n            return DPC_PERMISSIONS.get(PROFILE_OWNER_ON_USER_0).contains(permission);\n        }\n        if (mOwners.hasProfileOwner(userId)) {\n            return DPC_PERMISSIONS.get(PROFILE_OWNER).contains(permission);\n        }\n        return false;\n    }\n\n    private EnforcingAdmin getEnforcingAdminForCaller(@Nullable ComponentName who,\n            String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        int userId = caller.getUserId();\n        ActiveAdmin admin;\n        if (isDeviceOwner(caller) || isProfileOwner(caller) || isCallerDelegate(caller)) {\n            ComponentName component;\n            synchronized (getLockObject()) {\n                if (who != null) {\n                    component = who;\n                } else {\n                    admin = getDeviceOrProfileOwnerAdminLocked(userId);\n                    component = admin.info.getComponent();\n                }\n            }\n            return EnforcingAdmin.createEnterpriseEnforcingAdmin(component, userId);\n        }\n        // Check for DA active admins.\n        admin = getActiveAdminForCaller(who, caller);\n        if (admin != null) {\n            return EnforcingAdmin.createDeviceAdminEnforcingAdmin(\n                    admin.info.getComponent(), userId);\n        }\n        return EnforcingAdmin.createEnforcingAdmin(caller.getPackageName(), userId);\n    }\n\n    private EnforcingAdmin getEnforcingAdminForPackage(@Nullable ComponentName who,\n            String packageName, int userId) {\n        ActiveAdmin admin;\n        if (who != null) {\n            if (isDeviceOwner(who, userId) || isProfileOwner(who, userId)) {\n                synchronized (getLockObject()) {\n                    admin = getActiveAdminUncheckedLocked(who, userId);\n                }\n                if (admin != null) {\n                    return EnforcingAdmin.createEnterpriseEnforcingAdmin(who, userId);\n                }\n            } else {\n                // Check for DA active admins.\n                admin = getActiveAdminUncheckedLocked(who, userId);\n                if (admin != null) {\n                    return EnforcingAdmin.createDeviceAdminEnforcingAdmin(who, userId);\n                }\n            }\n        }\n        return EnforcingAdmin.createEnforcingAdmin(packageName, userId);\n    }\n\n    private int getAffectedUser(boolean calledOnParent) {\n        int callingUserId = mInjector.userHandleGetCallingUserId();\n        return calledOnParent ? getProfileParentId(callingUserId) : callingUserId;\n    }\n\n    /**\n     * Return the DPC type of the given caller.\n     */\n    private @DpcType int getDpcType(CallerIdentity caller) {\n        // Check the permissions of DPCs\n        if (isDefaultDeviceOwner(caller)) {\n            return DEFAULT_DEVICE_OWNER;\n        }\n        if (isFinancedDeviceOwner(caller)) {\n            return FINANCED_DEVICE_OWNER;\n        }\n        if (isProfileOwner(caller)) {\n            if (isProfileOwnerOfOrganizationOwnedDevice(caller)) {\n                return PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE;\n            }\n            if (isManagedProfile(caller.getUserId())) {\n                return PROFILE_OWNER;\n            }\n            if (isProfileOwnerOnUser0(caller)) {\n                return PROFILE_OWNER_ON_USER_0;\n            }\n            if (isUserAffiliatedWithDevice(caller.getUserId())) {\n                return AFFILIATED_PROFILE_OWNER_ON_USER;\n            }\n            return PROFILE_OWNER_ON_USER;\n        }\n        return NOT_A_DPC;\n    }\n\n    private static boolean isSetStatusBarDisabledCoexistenceEnabled() {\n        return false;\n    }\n\n    private void unsuspendWorkAppsIfNecessary() {\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserDataUnchecked(UserHandle.USER_SYSTEM);\n            if (!policyData.mEffectiveKeepProfilesRunning) {\n                return;\n            }\n            policyData.mEffectiveKeepProfilesRunning = false;\n            saveSettingsLocked(UserHandle.USER_SYSTEM);\n        }\n\n        Slog.w(LOG_TAG, \"Work apps may have been paused via suspension previously.\");\n        PackageManagerInternal pmi = mInjector.getPackageManagerInternal();\n        List<UserInfo> users = mUserManagerInternal.getUsers(true /* excludeDying */);\n\n        for (UserInfo user : users) {\n            if (!user.isManagedProfile() || !user.isQuietModeEnabled()) {\n                continue;\n            }\n            int userId = user.id;\n            Set<String> suspendedByAdmin;\n            synchronized (getLockObject()) {\n                ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userId);\n                // This is legacy code from Turn off Work 2.0 which is before setPackagesSuspended\n                // is migrated to PolicyEngine, so we only need to query the legacy ActiveAdmin here\n                if (admin == null || admin.suspendedPackages == null) {\n                    suspendedByAdmin = Collections.emptySet();\n                } else {\n                    suspendedByAdmin = new ArraySet<>(admin.suspendedPackages);\n                }\n            }\n            var packagesToUnsuspend = mInjector.getPackageManager(userId)\n                    .getInstalledPackages(PackageManager.PackageInfoFlags.of(\n                            MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE))\n                    .stream()\n                    .map(packageInfo -> packageInfo.packageName)\n                    .filter(pkg -> !suspendedByAdmin.contains(pkg))\n                    .toArray(String[]::new);\n\n            Slogf.i(LOG_TAG, \"Unsuspending work apps for user %d\", userId);\n            // When app suspension was used for quiet mode, the apps were suspended by platform\n            // package, just like when admin suspends them. So although it wasn't admin who\n            // suspended, this method will remove the right suspension record.\n            pmi.setPackagesSuspendedByAdmin(userId, packagesToUnsuspend, false /* suspended */);\n        }\n    }\n\n    public void setMtePolicy(int flags, String callerPackageName) {\n        checkMteSupportedAndAllowedPolicy(flags);\n        final CallerIdentity caller = getCallerIdentity(callerPackageName);\n        // For now we continue to restrict the DISABLED setting to device owner - we might need\n        // another permission for this in future.\n        if (flags == DevicePolicyManager.MTE_DISABLED) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        }\n\n        if (Flags.setMtePolicyCoexistence()) {\n            enforcePermission(MANAGE_DEVICE_POLICY_MTE, caller.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                    || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n\n        synchronized (getLockObject()) {\n            if (Flags.setMtePolicyCoexistence()) {\n                final EnforcingAdmin admin = enforcePermissionAndGetEnforcingAdmin(null,\n                        MANAGE_DEVICE_POLICY_MTE, callerPackageName, caller.getUserId());\n                if (flags != DevicePolicyManager.MTE_NOT_CONTROLLED_BY_POLICY) {\n                    mDevicePolicyEngine.setGlobalPolicy(\n                            PolicyDefinition.MEMORY_TAGGING,\n                            admin,\n                            new IntegerPolicyValue(flags));\n                } else {\n                    mDevicePolicyEngine.removeGlobalPolicy(\n                            PolicyDefinition.MEMORY_TAGGING,\n                            admin);\n                }\n            } else {\n                ActiveAdmin admin =\n                        getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n                if (admin != null) {\n                    final String memtagProperty = \"arm64.memtag.bootctl\";\n                    if (flags == DevicePolicyManager.MTE_ENABLED) {\n                        mInjector.systemPropertiesSet(memtagProperty, \"memtag\");\n                    } else if (flags == DevicePolicyManager.MTE_DISABLED) {\n                        mInjector.systemPropertiesSet(memtagProperty, \"memtag-off\");\n                    } else if (flags == DevicePolicyManager.MTE_NOT_CONTROLLED_BY_POLICY) {\n                        if (admin.mtePolicy != DevicePolicyManager.MTE_NOT_CONTROLLED_BY_POLICY) {\n                            mInjector.systemPropertiesSet(memtagProperty, \"default\");\n                        }\n                    }\n                    admin.mtePolicy = flags;\n                    saveSettingsLocked(caller.getUserId());\n                }\n            }\n\n            DevicePolicyEventLogger.createEvent(DevicePolicyEnums.SET_MTE_POLICY)\n                    .setInt(flags)\n                    .setAdmin(caller.getPackageName())\n                    .write();\n        }\n    }\n\n    @Override\n    public void setMtePolicyBySystem(\n            @NonNull String systemEntity, int policy) {\n        Objects.requireNonNull(systemEntity);\n        checkMteSupportedAndAllowedPolicy(policy);\n\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                \"Only system services can call setMtePolicyBySystem\");\n\n        if (!Flags.setMtePolicyCoexistence()) {\n            throw new UnsupportedOperationException(\"System can not set MTE policy only\");\n        }\n\n        EnforcingAdmin admin = EnforcingAdmin.createSystemEnforcingAdmin(systemEntity);\n        if (policy != DevicePolicyManager.MTE_NOT_CONTROLLED_BY_POLICY) {\n            mDevicePolicyEngine.setGlobalPolicy(\n                    PolicyDefinition.MEMORY_TAGGING,\n                    admin,\n                    new IntegerPolicyValue(policy));\n        } else {\n            mDevicePolicyEngine.removeGlobalPolicy(\n                    PolicyDefinition.MEMORY_TAGGING,\n                    admin);\n        }\n    }\n\n    private void checkMteSupportedAndAllowedPolicy(int policy) {\n        final Set<Integer> allowedModes =\n                Set.of(\n                        DevicePolicyManager.MTE_NOT_CONTROLLED_BY_POLICY,\n                        DevicePolicyManager.MTE_DISABLED,\n                        DevicePolicyManager.MTE_ENABLED);\n        Preconditions.checkArgument(\n                allowedModes.contains(policy), \"Provided mode is not one of the allowed values.\");\n        // In general, this API should be available when \"bootctl_settings_toggle\" is set, which\n        // signals that there is a control for MTE in the user settings and this API fundamentally\n        // is a way for the device admin to override that setting.\n        // Allow bootctl_device_policy_manager as an override, e.g. to offer the\n        // DevicePolicyManager only without a visible user setting.\n        if (!mInjector.systemPropertiesGetBoolean(\n                \"ro.arm64.memtag.bootctl_device_policy_manager\",\n                mInjector.systemPropertiesGetBoolean(\n                        \"ro.arm64.memtag.bootctl_settings_toggle\", false))) {\n            throw new UnsupportedOperationException(\"device does not support MTE\");\n        }\n    }\n\n    @Override\n    public int getMtePolicy(String callerPackageName) {\n        final CallerIdentity caller = getCallerIdentity(callerPackageName);\n        if (Flags.setMtePolicyCoexistence()) {\n            enforcePermission(MANAGE_DEVICE_POLICY_MTE, caller.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                    || isProfileOwnerOfOrganizationOwnedDevice(caller)\n                    || isSystemUid(caller));\n        }\n\n        synchronized (getLockObject()) {\n            if (Flags.setMtePolicyCoexistence()) {\n                final EnforcingAdmin admin = enforcePermissionAndGetEnforcingAdmin(null,\n                        MANAGE_DEVICE_POLICY_MTE, callerPackageName, caller.getUserId());\n                final Integer policyFromAdmin = mDevicePolicyEngine.getGlobalPolicySetByAdmin(\n                        PolicyDefinition.MEMORY_TAGGING, admin);\n                return (policyFromAdmin != null ? policyFromAdmin\n                        : DevicePolicyManager.MTE_NOT_CONTROLLED_BY_POLICY);\n            } else {\n                ActiveAdmin admin =\n                        getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n                return admin != null\n                        ? admin.mtePolicy\n                        : DevicePolicyManager.MTE_NOT_CONTROLLED_BY_POLICY;\n            }\n        }\n    }\n\n    @Override\n    public void setContentProtectionPolicy(\n            ComponentName who, String callerPackageName, @ContentProtectionPolicy int policy)\n            throws SecurityException {\n        if (!android.view.contentprotection.flags.Flags.manageDevicePolicyEnabled()) {\n            return;\n        }\n\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        int userId = caller.getUserId();\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_CONTENT_PROTECTION_POLICY);\n        EnforcingAdmin enforcingAdmin =\n                enforcePermissionAndGetEnforcingAdmin(\n                        who, MANAGE_DEVICE_POLICY_CONTENT_PROTECTION, callerPackageName, userId);\n\n        if (policy == CONTENT_PROTECTION_DISABLED) {\n            mDevicePolicyEngine.removeLocalPolicy(\n                    PolicyDefinition.CONTENT_PROTECTION, enforcingAdmin, userId);\n        } else {\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.CONTENT_PROTECTION,\n                    enforcingAdmin,\n                    new IntegerPolicyValue(policy),\n                    userId);\n        }\n    }\n\n    @Override\n    public @ContentProtectionPolicy int getContentProtectionPolicy(\n            ComponentName who, String callerPackageName, int userId) {\n        if (!android.view.contentprotection.flags.Flags.manageDevicePolicyEnabled()) {\n            return CONTENT_PROTECTION_DISABLED;\n        }\n\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        enforceCanQuery(MANAGE_DEVICE_POLICY_CONTENT_PROTECTION, callerPackageName, userId);\n        Integer policy =\n                mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.CONTENT_PROTECTION, userId);\n        if (policy == null) {\n            return CONTENT_PROTECTION_DISABLED;\n        } else {\n            return policy;\n        }\n    }\n\n    @Override\n    public void setAppFunctionsPolicy(String callerPackageName, @AppFunctionsPolicy int policy) {\n        if (!android.app.appfunctions.flags.Flags.enableAppFunctionManager()) {\n            return;\n        }\n\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        int userId = caller.getUserId();\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_APP_FUNCTIONS_POLICY);\n        EnforcingAdmin enforcingAdmin =\n                enforcePermissionAndGetEnforcingAdmin(\n                        /* who */null, MANAGE_DEVICE_POLICY_APP_FUNCTIONS,\n                        callerPackageName, userId);\n\n        if (policy == APP_FUNCTIONS_NOT_CONTROLLED_BY_POLICY) {\n            mDevicePolicyEngine.removeLocalPolicy(\n                    PolicyDefinition.APP_FUNCTIONS, enforcingAdmin, userId);\n        } else {\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.APP_FUNCTIONS,\n                    enforcingAdmin, new IntegerPolicyValue(policy),\n                    userId);\n        }\n    }\n\n    @Override\n    public @AppFunctionsPolicy int getAppFunctionsPolicy(String callerPackageName, int userId) {\n        if (!android.app.appfunctions.flags.Flags.enableAppFunctionManager()) {\n            return APP_FUNCTIONS_NOT_CONTROLLED_BY_POLICY;\n        }\n\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        enforceCanQuery(MANAGE_DEVICE_POLICY_APP_FUNCTIONS, callerPackageName, userId);\n        Integer policy =\n                mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.APP_FUNCTIONS, userId);\n        if (policy == null) {\n            return APP_FUNCTIONS_NOT_CONTROLLED_BY_POLICY;\n        }\n        return policy;\n    }\n\n    private void updateContentProtectionPolicyCache(@UserIdInt int userId) {\n        mPolicyCache.setContentProtectionPolicy(\n                userId,\n                mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.CONTENT_PROTECTION, userId));\n    }\n\n    @Override\n    public ManagedSubscriptionsPolicy getManagedSubscriptionsPolicy() {\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOfOrganizationOwnedDeviceLocked();\n            if (admin != null && admin.mManagedSubscriptionsPolicy != null) {\n                return admin.mManagedSubscriptionsPolicy;\n            }\n        }\n        return new ManagedSubscriptionsPolicy(\n                ManagedSubscriptionsPolicy.TYPE_ALL_PERSONAL_SUBSCRIPTIONS);\n    }\n\n    @Override\n    public void setManagedSubscriptionsPolicy(ManagedSubscriptionsPolicy policy) {\n        CallerIdentity caller = getCallerIdentity();\n\n        if (!isCallerDevicePolicyManagementRoleHolder(caller)\n                && !Objects.equals(mInjector.settingsGlobalGetString(\n                        Global.ALLOW_WORK_PROFILE_TELEPHONY_FOR_NON_DPM_ROLE_HOLDERS), \"1\")) {\n            throw new UnsupportedOperationException(\"This api is not enabled\");\n        }\n\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller),\n                \"This policy can only be set by a profile owner on an organization-owned \"\n                        + \"device.\");\n\n        int parentUserId = getProfileParentId(caller.getUserId());\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (hasUserSetupCompleted(parentUserId) && !isAdminTestOnlyLocked(\n                    admin.info.getComponent(), caller.getUserId())) {\n                throw new IllegalStateException(\"Not allowed to apply this policy after setup\");\n            }\n            boolean changed = false;\n            if (!Objects.equals(policy, admin.mManagedSubscriptionsPolicy)) {\n                admin.mManagedSubscriptionsPolicy = policy;\n                changed = true;\n            }\n            if (changed) {\n                saveSettingsLocked(caller.getUserId());\n            } else {\n                return;\n            }\n        }\n\n        applyManagedSubscriptionsPolicyIfRequired();\n\n        int policyType = getManagedSubscriptionsPolicy().getPolicyType();\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            if (policyType == ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {\n                installOemDefaultDialerAndSmsApp(caller.getUserId());\n                updateTelephonyCrossProfileIntentFilters(parentUserId, caller.getUserId(), true);\n            } else if (policyType == ManagedSubscriptionsPolicy.TYPE_ALL_PERSONAL_SUBSCRIPTIONS) {\n                updateTelephonyCrossProfileIntentFilters(parentUserId, caller.getUserId(), false);\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    private void installOemDefaultDialerAndSmsApp(int targetUserId) {\n        try {\n            String defaultDialerPackageName = getOemDefaultDialerPackage();\n            String defaultSmsPackageName = getOemDefaultSmsPackage();\n\n            if (defaultDialerPackageName != null) {\n                mIPackageManager.installExistingPackageAsUser(defaultDialerPackageName,\n                        targetUserId, PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                        PackageManager.INSTALL_REASON_POLICY, null);\n            } else {\n                Slogf.w(LOG_TAG, \"Couldn't install dialer app, dialer app package is null\");\n            }\n\n            if (defaultSmsPackageName != null) {\n                mIPackageManager.installExistingPackageAsUser(defaultSmsPackageName, targetUserId,\n                        PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                        PackageManager.INSTALL_REASON_POLICY, null);\n            } else {\n                Slogf.w(LOG_TAG, \"Couldn't install sms app, sms app package is null\");\n            }\n\n            updateDialerAndSmsManagedShortcutsOverrideCache();\n        } catch (RemoteException re) {\n            // shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Failed to install dialer/sms app\", re);\n        }\n    }\n\n    private String getOemDefaultDialerPackage() {\n        TelecomManager telecomManager = mContext.getSystemService(TelecomManager.class);\n        return telecomManager.getSystemDialerPackage();\n    }\n\n    private String getOemDefaultSmsPackage() {\n        return mContext.getString(R.string.config_defaultSms);\n    }\n\n    private void updateDialerAndSmsManagedShortcutsOverrideCache() {\n        ArrayMap<String, String> shortcutOverrides = new ArrayMap<>();\n        int managedUserId = getManagedUserId();\n        List<String> dialerRoleHolders = mRoleManager.getRoleHoldersAsUser(RoleManager.ROLE_DIALER,\n                UserHandle.of(managedUserId));\n        List<String> smsRoleHolders = mRoleManager.getRoleHoldersAsUser(RoleManager.ROLE_SMS,\n                UserHandle.of(managedUserId));\n\n        String dialerPackageToOverride = getOemDefaultDialerPackage();\n        String smsPackageToOverride = getOemDefaultSmsPackage();\n\n        // To get the default app, we can get all the role holders and get the first element.\n        if (dialerPackageToOverride != null) {\n            shortcutOverrides.put(dialerPackageToOverride,\n                    dialerRoleHolders.isEmpty() ? dialerPackageToOverride\n                            : dialerRoleHolders.get(0));\n        }\n        if (smsPackageToOverride != null) {\n            shortcutOverrides.put(smsPackageToOverride,\n                    smsRoleHolders.isEmpty() ? smsPackageToOverride : smsRoleHolders.get(0));\n        }\n\n        mPolicyCache.setLauncherShortcutOverrides(shortcutOverrides);\n    }\n\n    private void registerListenerToAssignSubscriptionsToUser(int userId) {\n        synchronized (mSubscriptionsChangedListenerLock) {\n            if (mSubscriptionsChangedListener != null) {\n                return;\n            }\n            SubscriptionManager subscriptionManager = mContext.getSystemService(\n                    SubscriptionManager.class);\n            // Listener to assign all current and future subs to managed profile.\n            mSubscriptionsChangedListener = new SubscriptionManager.OnSubscriptionsChangedListener(\n                    mHandler.getLooper()) {\n                @Override\n                public void onSubscriptionsChanged() {\n                    final long id = mInjector.binderClearCallingIdentity();\n                    try {\n                        int[] subscriptionIds = subscriptionManager.getActiveSubscriptionIdList(\n                                false);\n                        for (int subId : subscriptionIds) {\n                            UserHandle associatedUserHandle =\n                                    subscriptionManager.getSubscriptionUserHandle(subId);\n                            if (associatedUserHandle == null\n                                    || associatedUserHandle.getIdentifier() != userId) {\n                                subscriptionManager.setSubscriptionUserHandle(subId,\n                                        UserHandle.of(userId));\n                            }\n                        }\n                    } finally {\n                        mInjector.binderRestoreCallingIdentity(id);\n                    }\n                }\n            };\n\n            final long id = mInjector.binderClearCallingIdentity();\n            try {\n                // When listener is added onSubscriptionsChanged gets called immediately for once\n                // (even if subscriptions are not changed) and later on when subscriptions changes.\n                subscriptionManager.addOnSubscriptionsChangedListener(\n                        mHandler::post,\n                        mSubscriptionsChangedListener);\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n    }\n\n    private void unregisterOnSubscriptionsChangedListener() {\n        synchronized (mSubscriptionsChangedListenerLock) {\n            if (mSubscriptionsChangedListener != null) {\n                SubscriptionManager subscriptionManager = mContext.getSystemService(\n                        SubscriptionManager.class);\n                subscriptionManager.removeOnSubscriptionsChangedListener(\n                        mSubscriptionsChangedListener);\n                mSubscriptionsChangedListener = null;\n            }\n        }\n    }\n\n    @Override\n    public DevicePolicyState getDevicePolicyState() {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        return mInjector.binderWithCleanCallingIdentity(mDevicePolicyEngine::getDevicePolicyState);\n    }\n\n    @Override\n    public boolean triggerDevicePolicyEngineMigration(boolean forceMigration) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            synchronized (getLockObject()) {\n                boolean canForceMigration = forceMigration && !hasNonTestOnlyActiveAdmins();\n                if (!canForceMigration && !shouldMigrateV1ToDevicePolicyEngine()) {\n                    return false;\n                }\n                boolean migrated = migrateV1PoliciesToDevicePolicyEngine();\n                migrated &= migratePoliciesPostUpgradeToDevicePolicyEngineLocked();\n                return migrated;\n            }\n        });\n    }\n\n    private boolean hasNonTestOnlyActiveAdmins() {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo userInfo : mUserManager.getUsers()) {\n                synchronized (getLockObject()) {\n                    List<ComponentName> activeAdmins = getActiveAdmins(userInfo.id);\n                    if (activeAdmins == null) {\n                        continue;\n                    }\n                    for (ComponentName admin : activeAdmins) {\n                        if (!isAdminTestOnlyLocked(admin, userInfo.id)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        });\n    }\n\n    private boolean shouldMigrateV1ToDevicePolicyEngine() {\n        return mInjector.binderWithCleanCallingIdentity(() -> !mOwners.isMigratedToPolicyEngine());\n    }\n\n    /**\n     * Migrates the initial set of policies to use policy engine.\n     * [b/318497672] Migrate policies that weren't migrated properly in the initial migration on\n     * update from Android T to Android U\n     */\n    private void maybeMigratePoliciesPostUpgradeToDevicePolicyEngineLocked() {\n        if (!mOwners.isMigratedToPolicyEngine() || mOwners.isMigratedPostUpdate()) {\n            return;\n        }\n        migratePoliciesPostUpgradeToDevicePolicyEngineLocked();\n        mOwners.markPostUpgradeMigration();\n    }\n\n    private boolean migratePoliciesPostUpgradeToDevicePolicyEngineLocked() {\n        try {\n            migrateScreenCapturePolicyLocked();\n            migrateLockTaskPolicyLocked();\n            migrateUserRestrictionsLocked();\n            return true;\n        } catch (Exception e) {\n            Slogf.e(LOG_TAG, e, \"Error occurred during post upgrade migration to the device \"\n                    + \"policy engine.\");\n            return false;\n        }\n    }\n\n    /**\n     * @return {@code true} if policies were migrated successfully, {@code false} otherwise.\n     */\n    private boolean migrateV1PoliciesToDevicePolicyEngine() {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                synchronized (getLockObject()) {\n                    Slogf.i(LOG_TAG,\n                            \"Started device policies migration to the device policy engine.\");\n                    // TODO(b/359188869): Move this to the current migration method.\n                    if (Flags.setPermissionGrantStateCoexistence()) {\n                        migratePermissionGrantStatePolicies();\n                    }\n                    migratePermittedInputMethodsPolicyLocked();\n                    migrateAccountManagementDisabledPolicyLocked();\n                    migrateUserControlDisabledPackagesLocked();\n\n                    mOwners.markMigrationToPolicyEngine();\n                    return true;\n                }\n            } catch (Exception e) {\n                mDevicePolicyEngine.clearAllPolicies();\n                Slogf.e(LOG_TAG, e, \"Error occurred during device policy migration, will \"\n                        + \"reattempt on the next system server restart.\");\n                return false;\n            }\n        });\n    }\n\n    /**\n     * Migrates the rest of policies to use policy engine.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void migratePoliciesToPolicyEngineLocked() {\n        maybeMigrateSecurityLoggingPolicyLocked();\n        // ID format: <sdk-int>.<auto_increment_id>.<descriptions>'\n        String unmanagedBackupId = \"35.1.unmanaged-mode\";\n        boolean unmanagedMigrated = maybeMigrateRequiredPasswordComplexityLocked(unmanagedBackupId);\n        if (unmanagedMigrated) {\n            Slogf.i(LOG_TAG, \"Backup made: \" + unmanagedBackupId);\n        }\n\n        String supervisionBackupId = \"36.2.supervision-support\";\n        boolean supervisionMigrated = maybeMigrateResetPasswordTokenLocked(supervisionBackupId);\n        supervisionMigrated |= maybeMigrateSuspendedPackagesLocked(supervisionBackupId);\n        supervisionMigrated |= maybeMigrateSetKeyguardDisabledFeatures(supervisionBackupId);\n        if (supervisionMigrated) {\n            Slogf.i(LOG_TAG, \"Backup made: \" + supervisionBackupId);\n        }\n\n        String memoryTaggingBackupId = \"36.3.memory-tagging\";\n        boolean memoryTaggingMigrated = maybeMigrateMemoryTaggingLocked(memoryTaggingBackupId);\n        if (memoryTaggingMigrated) {\n            Slogf.i(LOG_TAG, \"Backup made: \" + memoryTaggingBackupId);\n        }\n\n        // Additional migration steps should repeat the pattern above with a new backupId.\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private boolean maybeMigrateSetKeyguardDisabledFeatures(String backupId) {\n        Slog.i(LOG_TAG, \"Migrating set keyguard disabled features to policy engine\");\n        if (!Flags.setKeyguardDisabledFeaturesCoexistence()) {\n            return false;\n        }\n        if (mOwners.isSetKeyguardDisabledFeaturesMigrated()) {\n            return false;\n        }\n        // Create backup if none exists\n        mDevicePolicyEngine.createBackup(backupId);\n        try {\n            iterateThroughDpcAdminsLocked((admin, enforcingAdmin) -> {\n                if (admin.disabledKeyguardFeatures == 0) {\n                    return;\n                }\n                int userId = enforcingAdmin.getUserId();\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.KEYGUARD_DISABLED_FEATURES,\n                        enforcingAdmin,\n                        new IntegerPolicyValue(admin.disabledKeyguardFeatures),\n                        userId);\n            });\n        } catch (Exception e) {\n            Slog.wtf(LOG_TAG, \"Failed to migrate set keyguard disabled to policy engine\", e);\n        }\n\n        Slog.i(LOG_TAG, \"Marking set keyguard disabled features migration complete\");\n        mOwners.markSetKeyguardDisabledFeaturesMigrated();\n        return true;\n    }\n\n    private void migratePermissionGrantStatePolicies() {\n        Slogf.i(LOG_TAG, \"Migrating PERMISSION_GRANT policy to device policy engine.\");\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            ActiveAdmin admin = getMostProbableDPCAdminForLocalPolicy(userInfo.id);\n            if (admin == null) {\n                Slogf.i(LOG_TAG, \"No admin found that can set permission grant state on user \"\n                        + userInfo.id);\n                continue;\n            }\n            for (PackageInfo packageInfo : getInstalledPackagesOnUser(userInfo.id)) {\n                if (packageInfo.requestedPermissions == null) {\n                    continue;\n                }\n                for (String permission : packageInfo.requestedPermissions) {\n                    if (!isRuntimePermission(permission)) {\n                        continue;\n                    }\n                    int grantState = PERMISSION_GRANT_STATE_DEFAULT;\n                    try {\n                        grantState = getPermissionGrantStateForUser(\n                                packageInfo.packageName, permission,\n                                new CallerIdentity(\n                                        mInjector.binderGetCallingUid(),\n                                        admin.info.getComponent().getPackageName(),\n                                        admin.info.getComponent()),\n                                userInfo.id);\n                    } catch (RemoteException e) {\n                        Slogf.e(LOG_TAG, e, \"Error retrieving permission grant state for %s \"\n                                        + \"and %s\", packageInfo.packageName, permission);\n                    }\n                    if (grantState == PERMISSION_GRANT_STATE_DEFAULT) {\n                        // Not Controlled by a policy\n                        continue;\n                    }\n\n                    mDevicePolicyEngine.setLocalPolicy(\n                            PolicyDefinition.PERMISSION_GRANT(packageInfo.packageName,\n                                    permission),\n                            EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                                    admin.info.getComponent(),\n                                    admin.getUserHandle().getIdentifier()),\n                            new IntegerPolicyValue(grantState),\n                            userInfo.id,\n                            /* skipEnforcePolicy= */ true);\n                }\n            }\n        }\n    }\n\n    private void migrateScreenCapturePolicyLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            ActiveAdmin admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n            if (admin != null\n                    && ((isDeviceOwner(admin) && admin.disableScreenCapture)\n                    || (admin.getParentActiveAdmin() != null\n                    && admin.getParentActiveAdmin().disableScreenCapture))) {\n\n                EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                        admin.info.getComponent(), admin.getUserHandle().getIdentifier());\n                mDevicePolicyEngine.setGlobalPolicy(\n                        PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                        enforcingAdmin,\n                        new BooleanPolicyValue(true));\n            }\n\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                ActiveAdmin profileOwner = getProfileOwnerLocked(userInfo.id);\n                if (profileOwner != null && profileOwner.disableScreenCapture) {\n                    EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            profileOwner.info.getComponent(),\n                            profileOwner.getUserHandle().getIdentifier());\n                    mDevicePolicyEngine.setLocalPolicy(\n                            PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                            enforcingAdmin,\n                            new BooleanPolicyValue(true),\n                            profileOwner.getUserHandle().getIdentifier());\n                }\n            }\n        });\n    }\n\n    private void migrateLockTaskPolicyLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (deviceOwner != null) {\n                int doUserId = deviceOwner.getUserHandle().getIdentifier();\n                DevicePolicyData policies = getUserData(doUserId);\n                List<String> packages = policies.mLockTaskPackages;\n                int features = policies.mLockTaskFeatures;\n                // TODO: find out about persistent preferred activities\n                if (!packages.isEmpty()) {\n                    setLockTaskPolicyInPolicyEngine(deviceOwner, doUserId, packages, features);\n                }\n            }\n\n            for (int userId : mUserManagerInternal.getUserIds()) {\n                ActiveAdmin profileOwner = getProfileOwnerLocked(userId);\n                if (profileOwner != null && canDPCManagedUserUseLockTaskLocked(userId)) {\n                    DevicePolicyData policies = getUserData(userId);\n                    List<String> packages = policies.mLockTaskPackages;\n                    int features = policies.mLockTaskFeatures;\n                    if (!packages.isEmpty()) {\n                        setLockTaskPolicyInPolicyEngine(profileOwner, userId, packages, features);\n                    }\n                }\n            }\n        });\n    }\n\n    private void setLockTaskPolicyInPolicyEngine(\n            ActiveAdmin admin, int userId, List<String> packages, int features) {\n        EnforcingAdmin enforcingAdmin =\n                EnforcingAdmin.createEnterpriseEnforcingAdmin(admin.info.getComponent(), userId);\n        mDevicePolicyEngine.setLocalPolicy(\n                PolicyDefinition.LOCK_TASK,\n                enforcingAdmin,\n                new LockTaskPolicy(new HashSet<>(packages), features),\n                userId);\n    }\n\n    private void migratePermittedInputMethodsPolicyLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(userInfo.id);\n                if (admin != null) {\n                    EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(), admin.getUserHandle().getIdentifier());\n                    if (admin.permittedInputMethods != null) {\n                        mDevicePolicyEngine.setLocalPolicy(\n                                PolicyDefinition.PERMITTED_INPUT_METHODS,\n                                enforcingAdmin,\n                                new PackageSetPolicyValue(\n                                        new HashSet<>(admin.permittedInputMethods)),\n                                admin.getUserHandle().getIdentifier());\n                    }\n                    if (admin.getParentActiveAdmin() != null\n                            && admin.getParentActiveAdmin().permittedInputMethods != null) {\n                        mDevicePolicyEngine.setLocalPolicy(\n                                PolicyDefinition.PERMITTED_INPUT_METHODS,\n                                enforcingAdmin,\n                                new PackageSetPolicyValue(\n                                        new HashSet<>(admin.getParentActiveAdmin()\n                                                .permittedInputMethods)),\n                                getProfileParentId(admin.getUserHandle().getIdentifier()));\n                    }\n                }\n            }\n        });\n    }\n\n    private void migrateAccountManagementDisabledPolicyLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(userInfo.id);\n                if (admin != null) {\n                    EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(), admin.getUserHandle().getIdentifier());\n                    for (String accountType : admin.accountTypesWithManagementDisabled) {\n                        mDevicePolicyEngine.setLocalPolicy(\n                                PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(accountType),\n                                enforcingAdmin,\n                                new BooleanPolicyValue(true),\n                                admin.getUserHandle().getIdentifier());\n                    }\n                    if (admin.getParentActiveAdmin() != null) {\n                        for (String accountType : admin.getParentActiveAdmin()\n                                .accountTypesWithManagementDisabled) {\n                            mDevicePolicyEngine.setLocalPolicy(\n                                    PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(accountType),\n                                    enforcingAdmin,\n                                    new BooleanPolicyValue(true),\n                                    getProfileParentId(admin.getUserHandle().getIdentifier()));\n                        }\n                    }\n                }\n            }\n        });\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void migrateUserControlDisabledPackagesLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(userInfo.id);\n                if (admin != null && admin.protectedPackages != null) {\n                    EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(), admin.getUserHandle().getIdentifier());\n                    if (isDeviceOwner(admin)) {\n                        mDevicePolicyEngine.setGlobalPolicy(\n                                PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                                enforcingAdmin,\n                                new PackageSetPolicyValue(\n                                        new HashSet<>(admin.protectedPackages)));\n                    } else {\n                        mDevicePolicyEngine.setLocalPolicy(\n                                PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                                enforcingAdmin,\n                                new PackageSetPolicyValue(\n                                        new HashSet<>(admin.protectedPackages)),\n                                admin.getUserHandle().getIdentifier());\n                    }\n                }\n            }\n        });\n    }\n\n    private void migrateUserRestrictionsLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(userInfo.id);\n                if (admin == null) continue;\n                ComponentName adminComponent = admin.info.getComponent();\n                int userId = userInfo.id;\n                EnforcingAdmin enforcingAdmin =\n                        EnforcingAdmin.createEnterpriseEnforcingAdmin(adminComponent, userId);\n                int ownerType;\n                if (isDeviceOwner(admin)) {\n                    ownerType = OWNER_TYPE_DEVICE_OWNER;\n                } else if (isProfileOwnerOfOrganizationOwnedDevice(adminComponent, userId)) {\n                    ownerType = OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE;\n                } else if (isProfileOwner(adminComponent, userId)) {\n                    ownerType = OWNER_TYPE_PROFILE_OWNER;\n                } else {\n                    throw new IllegalStateException(\"Invalid DO/PO state\");\n                }\n\n                for (final String restriction : admin.ensureUserRestrictions().keySet()) {\n                    setBackwardCompatibleUserRestrictionLocked(ownerType, enforcingAdmin, userId,\n                            restriction, /* enabled */ true, /* parent */ false);\n                }\n                for (final String restriction : admin.getParentActiveAdmin()\n                        .ensureUserRestrictions().keySet()) {\n                    setBackwardCompatibleUserRestrictionLocked(ownerType, enforcingAdmin, userId,\n                            restriction, /* enabled */ true, /* parent */ true);\n                }\n            }\n        });\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void iterateThroughDpcAdminsLocked(BiConsumer<ActiveAdmin, EnforcingAdmin> runner) {\n        Binder.withCleanCallingIdentity(() -> {\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(userInfo.id);\n                if (admin == null) continue;\n                EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                        admin.info.getComponent(), userInfo.id);\n\n                runner.accept(admin, enforcingAdmin);\n            }\n        });\n    }\n\n    private List<PackageInfo> getInstalledPackagesOnUser(int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mContext.getPackageManager().getInstalledPackagesAsUser(\n                        PackageManager.PackageInfoFlags.of(\n                                PackageManager.GET_PERMISSIONS), userId));\n    }\n\n    /**\n     * Returns the most probable admin to have set a global policy according to the following\n     * heuristics:\n     *\n     * <ul>\n     * <li>The device owner on any user</li>\n     * <li>The org owned profile owner on any user</li>\n     * <li>The profile owner on any user</li>\n     * </ul>\n     */\n    @Nullable\n    // TODO(b/266928216): Check what the admin capabilities are when deciding which admin to return.\n    private ActiveAdmin getMostProbableDPCAdminForGlobalPolicy() {\n        synchronized (getLockObject()) {\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (deviceOwner != null) {\n                return deviceOwner;\n            }\n\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                if (isProfileOwnerOfOrganizationOwnedDevice(userInfo.id)) {\n                    return getProfileOwnerAdminLocked(userInfo.id);\n                }\n            }\n\n            for (UserInfo userInfo : users) {\n                ActiveAdmin profileOwner = getProfileOwnerLocked(userInfo.id);\n                if (profileOwner != null) {\n                    return profileOwner;\n                }\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Returns the most probable admin to have set a policy on the given {@code userId} according\n     * to the following heuristics:\n     *\n     * <ul>\n     * <li>The device owner on the given userId</li>\n     * <li>The profile owner on the given userId</li>\n     * <li>The org owned profile owner of which the given userId is its parent</li>\n     * <li>The profile owner of which the given userId is its parent</li>\n     * <li>The device owner on any user</li>\n     * <li>The profile owner on any user</li>\n     * </ul>\n     */\n    @Nullable\n    // TODO(b/266928216): Check what the admin capabilities are when deciding which admin to return.\n    private ActiveAdmin getMostProbableDPCAdminForLocalPolicy(int userId) {\n        synchronized (getLockObject()) {\n            ActiveAdmin localDeviceOwner = getDeviceOwnerLocked(userId);\n            if (localDeviceOwner != null) {\n                return localDeviceOwner;\n            }\n\n            ActiveAdmin localProfileOwner = getProfileOwnerLocked(userId);\n            if (localProfileOwner != null) {\n                return localProfileOwner;\n            }\n\n            int[] profileIds = mUserManager.getProfileIds(userId, /* enabledOnly= */ false);\n            for (int id : profileIds) {\n                if (id == userId) {\n                    continue;\n                }\n                if (isProfileOwnerOfOrganizationOwnedDevice(id)) {\n                    return getProfileOwnerAdminLocked(id);\n                }\n            }\n\n            for (int id : profileIds) {\n                if (id == userId) {\n                    continue;\n                }\n                if (isManagedProfile(id)) {\n                    return getProfileOwnerAdminLocked(id);\n                }\n            }\n\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (deviceOwner != null) {\n                return deviceOwner;\n            }\n\n            for (UserInfo userInfo : mUserManager.getUsers()) {\n                ActiveAdmin profileOwner = getProfileOwnerLocked(userInfo.id);\n                if (profileOwner != null) {\n                    return profileOwner;\n                }\n            }\n            return null;\n        }\n    }\n\n    private ActiveAdmin getActiveAdminForCaller(@Nullable ComponentName who,\n            CallerIdentity caller) {\n        synchronized (getLockObject()) {\n            if (who != null) {\n                return getActiveAdminUncheckedLocked(who, caller.getUserId());\n            }\n            return mInjector.binderWithCleanCallingIdentity(() -> {\n                List<ComponentName> activeAdmins = getActiveAdmins(caller.getUserId());\n                if (activeAdmins != null) {\n                    for (ComponentName admin : activeAdmins) {\n                        if (admin.getPackageName().equals(caller.getPackageName())) {\n                            return getActiveAdminUncheckedLocked(admin, caller.getUserId());\n                        }\n                    }\n                }\n                return null;\n            });\n        }\n    }\n\n    @Override\n    public boolean isDeviceFinanced(String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        Preconditions.checkCallAuthorization(isDeviceOwner(caller)\n                || isProfileOwnerOfOrganizationOwnedDevice(caller)\n                || isProfileOwnerOnUser0(caller)\n                || isCallerDevicePolicyManagementRoleHolder(caller)\n                || isCallerSystemSupervisionRoleHolder(caller));\n        return getFinancedDeviceKioskRoleHolderOnAnyUser() != null;\n    }\n\n    @Override\n    public String getFinancedDeviceKioskRoleHolder(String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        enforcePermission(MANAGE_PROFILE_AND_DEVICE_OWNERS, caller.getPackageName(),\n                caller.getUserId());\n        return getFinancedDeviceKioskRoleHolderOnAnyUser();\n    }\n\n    private String getFinancedDeviceKioskRoleHolderOnAnyUser() {\n        return getRoleHolderPackageNameOnUser(\n                RoleManager.ROLE_FINANCED_DEVICE_KIOSK, UserHandle.USER_ALL);\n    }\n\n    /**\n     * TODO (b/278924166): this method is added for debugging the specified bug.\n     * Remove once fixed.\n     **/\n    private void logStackTrace(String methodName) {\n        try {\n            StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();\n            String stackMethod;\n            StringBuilder stackTrace = new StringBuilder();\n            for (StackTraceElement s : stackTraceElements) {\n                stackMethod = s.getMethodName();\n                if (stackMethod == null || stackMethod.equals(\"getThreadStackTrace\")\n                        || stackMethod.equals(\"getStackTrace\")\n                        || stackMethod.equals(\"logStackTrace\")) {\n                    continue;\n                }\n                stackTrace.append(s.getMethodName() + \":\" + s.getLineNumber() + \"\\n\");\n            }\n            Slogf.d(LOG_TAG, \"StackTrace for \" + methodName + \": \\n\" + stackTrace);\n        } catch (Exception e) {\n            Slogf.d(LOG_TAG, \"Unable to get stacktrace\");\n        }\n    }\n\n    @Override\n    public int[] getSubscriptionIds(String callerPackageName) {\n        final CallerIdentity caller = getCallerIdentity(callerPackageName);\n        enforceCanQuery(\n                MANAGE_DEVICE_POLICY_MANAGED_SUBSCRIPTIONS,\n                caller.getPackageName(),\n                caller.getUserId());\n        return getSubscriptionIdsInternal(callerPackageName).toArray();\n    }\n\n    private IntArray getSubscriptionIdsInternal(String callerPackageName) {\n        SubscriptionManager subscriptionManager =\n                mContext.getSystemService(SubscriptionManager.class);\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            IntArray adminOwnedSubscriptions = new IntArray();\n            List<SubscriptionInfo> subs = subscriptionManager.getAvailableSubscriptionInfoList();\n            int subCount = (subs != null) ? subs.size() : 0;\n            for (int i = 0; i < subCount; i++) {\n                SubscriptionInfo sub = subs.get(i);\n                if (sub.getGroupOwner()\n                        .equals(callerPackageName)) {\n                    adminOwnedSubscriptions.add(sub.getSubscriptionId());\n                }\n            }\n            return adminOwnedSubscriptions;\n        });\n\n    }\n\n    @Override\n    public void setMaxPolicyStorageLimit(String callerPackageName, int storageLimit) {\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        enforcePermission(MANAGE_PROFILE_AND_DEVICE_OWNERS, caller.getPackageName(),\n                caller.getUserId());\n\n        if (storageLimit < DEFAULT_POLICY_SIZE_LIMIT && storageLimit != -1) {\n            throw new IllegalArgumentException(\"Can't set a size limit less than the minimum \"\n                    + \"allowed size.\");\n        }\n        mDevicePolicyEngine.setMaxPolicyStorageLimit(storageLimit);\n    }\n\n    @Override\n    public int getMaxPolicyStorageLimit(String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        enforcePermission(MANAGE_PROFILE_AND_DEVICE_OWNERS, caller.getPackageName(),\n                caller.getUserId());\n\n        return mDevicePolicyEngine.getMaxPolicyStorageLimit();\n    }\n\n    @Override\n    public void forceSetMaxPolicyStorageLimit(String callerPackageName, int storageLimit) {\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        enforcePermission(MANAGE_DEVICE_POLICY_STORAGE_LIMIT, caller.getPackageName(),\n                caller.getUserId());\n\n        mDevicePolicyEngine.setMaxPolicyStorageLimit(storageLimit);\n    }\n\n    @Override\n    public int getPolicySizeForAdmin(\n            String callerPackageName, android.app.admin.EnforcingAdmin admin) {\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        enforcePermission(MANAGE_DEVICE_POLICY_STORAGE_LIMIT, caller.getPackageName(),\n                caller.getUserId());\n\n        return mDevicePolicyEngine.getPolicySizeForAdmin(\n                EnforcingAdmin.createEnforcingAdmin(admin));\n    }\n\n    @Override\n    public int getHeadlessDeviceOwnerMode(String callerPackageName) {\n        final CallerIdentity caller = getCallerIdentity(callerPackageName);\n        enforcePermission(MANAGE_PROFILE_AND_DEVICE_OWNERS, caller.getPackageName(),\n                caller.getUserId());\n\n        return Binder.withCleanCallingIdentity(() -> getHeadlessDeviceOwnerModeForDeviceOwner());\n    }\n}\n```",
                        "upstream_file_tokens": {
                            "openai": 209636,
                            "general": {
                                "word_based": 76932,
                                "char_based": 281566
                            },
                            "gemini": 248668
                        },
                        "downstream_file_content": "```java\n/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.devicepolicy;\n\nimport static android.Manifest.permission.BIND_DEVICE_ADMIN;\nimport static android.Manifest.permission.LOCK_DEVICE;\nimport static android.Manifest.permission.MANAGE_CA_CERTIFICATES;\nimport static android.Manifest.permission.MANAGE_DEFAULT_APPLICATIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AIRPLANE_MODE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_APPS_CONTROL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_APP_RESTRICTIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AUDIO_OUTPUT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AUTOFILL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_BLUETOOTH;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CALLS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CAMERA;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CERTIFICATES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DEFAULT_SMS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DISPLAY;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_FACTORY_RESET;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_FUN;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_INPUT_METHODS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_KEYGUARD;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCALE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCATION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK_TASK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MICROPHONE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MOBILE_NETWORK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MODIFY_USERS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MTE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PACKAGE_STATE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PRINTING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PROFILES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PROFILE_INTERACTION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RESET_PASSWORD;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SAFE_BOOT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SCREEN_CAPTURE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SCREEN_CONTENT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SECURITY_LOGGING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SMS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_STATUS_BAR;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SYSTEM_UPDATES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_TIME;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_VPN;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WALLPAPER;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WIFI;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WINDOWS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WIPE_DATA;\nimport static android.Manifest.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS;\nimport static android.Manifest.permission.MASTER_CLEAR;\nimport static android.Manifest.permission.QUERY_ADMIN_POLICY;\nimport static android.Manifest.permission.REQUEST_PASSWORD_COMPLEXITY;\nimport static android.Manifest.permission.SET_TIME;\nimport static android.Manifest.permission.SET_TIME_ZONE;\nimport static android.accessibilityservice.AccessibilityServiceInfo.FEEDBACK_ALL_MASK;\nimport static android.accounts.AccountManager.LOGIN_ACCOUNTS_CHANGED_ACTION;\nimport static android.app.ActivityManager.LOCK_TASK_MODE_NONE;\nimport static android.app.AppOpsManager.MODE_ALLOWED;\nimport static android.app.AppOpsManager.MODE_DEFAULT;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_HIBERNATION;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_POWER_RESTRICTIONS;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_SUSPENSION;\nimport static android.app.admin.DeviceAdminInfo.HEADLESS_DEVICE_OWNER_MODE_AFFILIATED;\nimport static android.app.admin.DeviceAdminInfo.USES_POLICY_FORCE_LOCK;\nimport static android.app.admin.DeviceAdminInfo.USES_POLICY_WIPE_DATA;\nimport static android.app.admin.DeviceAdminReceiver.ACTION_COMPLIANCE_ACKNOWLEDGEMENT_REQUIRED;\nimport static android.app.admin.DeviceAdminReceiver.EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE;\nimport static android.app.admin.DevicePolicyIdentifiers.AUTO_TIMEZONE_POLICY;\nimport static android.app.admin.DevicePolicyManager.ACTION_CHECK_POLICY_COMPLIANCE;\nimport static android.app.admin.DevicePolicyManager.ACTION_DEVICE_FINANCING_STATE_CHANGED;\nimport static android.app.admin.DevicePolicyManager.ACTION_DEVICE_POLICY_RESOURCE_UPDATED;\nimport static android.app.admin.DevicePolicyManager.ACTION_MANAGED_PROFILE_PROVISIONED;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_USER;\nimport static android.app.admin.DevicePolicyManager.ACTION_SYSTEM_UPDATE_POLICY_CHANGED;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_APP_RESTRICTIONS;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_BLOCK_UNINSTALL;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_CERT_INSTALL;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_CERT_SELECTION;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_ENABLE_SYSTEM_APP;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_INSTALL_EXISTING_PACKAGE;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_KEEP_UNINSTALLED_PACKAGES;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_NETWORK_LOGGING;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_PACKAGE_ACCESS;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_PERMISSION_GRANT;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_SECURITY_LOGGING;\nimport static android.app.admin.DevicePolicyManager.DEVICE_OWNER_TYPE_DEFAULT;\nimport static android.app.admin.DevicePolicyManager.DEVICE_OWNER_TYPE_FINANCED;\nimport static android.app.admin.DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_PER_USER;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_HIBERNATION;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_POWER_RESTRICTIONS;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_SUSPENSION;\nimport static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_IDS;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE_DRAWABLE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE_STRING;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_BASE_INFO;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_IMEI;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_INDIVIDUAL_ATTESTATION;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_MEID;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_SERIAL;\nimport static android.app.admin.DevicePolicyManager.LEAVE_ALL_SYSTEM_APPS_ENABLED;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_GLOBAL_ACTIONS;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_HOME;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_KEYGUARD;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_NOTIFICATIONS;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_OVERVIEW;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_SYSTEM_INFO;\nimport static android.app.admin.DevicePolicyManager.NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\nimport static android.app.admin.DevicePolicyManager.NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\nimport static android.app.admin.DevicePolicyManager.OPERATION_SAFETY_REASON_NONE;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_HIGH;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_LOW;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_MEDIUM;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_NONE;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_COMPLEX;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_MANAGED;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_NUMERIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_SOMETHING;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED;\nimport static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;\nimport static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_NOT_SUSPENDED;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_SUSPENDED_EXPLICITLY;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_SUSPENDED_PROFILE_TIMEOUT;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_OFF;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_OPPORTUNISTIC;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_PROVIDER_HOSTNAME;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_UNKNOWN;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_SET_ERROR_FAILURE_SETTING;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_SET_NO_ERROR;\nimport static android.app.admin.DevicePolicyManager.PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATE_USER_SETUP_FINALIZED;\nimport static android.app.admin.DevicePolicyManager.STATE_USER_UNMANAGED;\nimport static android.app.admin.DevicePolicyManager.STATUS_ACCOUNTS_NOT_EMPTY;\nimport static android.app.admin.DevicePolicyManager.STATUS_CANNOT_ADD_MANAGED_PROFILE;\nimport static android.app.admin.DevicePolicyManager.STATUS_DEVICE_ADMIN_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_HAS_DEVICE_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATUS_HAS_PAIRED;\nimport static android.app.admin.DevicePolicyManager.STATUS_HEADLESS_SYSTEM_USER_MODE_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_MANAGED_USERS_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_NONSYSTEM_USER_EXISTS;\nimport static android.app.admin.DevicePolicyManager.STATUS_NOT_SYSTEM_USER;\nimport static android.app.admin.DevicePolicyManager.STATUS_OK;\nimport static android.app.admin.DevicePolicyManager.STATUS_PROVISIONING_NOT_ALLOWED_FOR_NON_DEVELOPER_USERS;\nimport static android.app.admin.DevicePolicyManager.STATUS_SYSTEM_USER;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_HAS_PROFILE_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_NOT_RUNNING;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_SETUP_COMPLETED;\nimport static android.app.admin.DevicePolicyManager.WIPE_EUICC;\nimport static android.app.admin.DevicePolicyManager.WIPE_EXTERNAL_STORAGE;\nimport static android.app.admin.DevicePolicyManager.WIPE_RESET_PROTECTION_DATA;\nimport static android.app.admin.DevicePolicyManager.WIPE_SILENTLY;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.LOCATION_CHANGED_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.LOCATION_CHANGED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NETWORK_LOGGING_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NETWORK_LOGGING_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NOTIFICATION_WORK_PROFILE_CONTENT_DESCRIPTION;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_SOON_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_TURN_ON_PROFILE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PRINTING_DISABLED_NAMED_ADMIN;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_FAILED_PASSWORD_ATTEMPTS_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_GENERIC_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_ORG_OWNED_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_BODY;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_TURN_ON_BUTTON;\nimport static android.app.admin.ProvisioningException.ERROR_ADMIN_PACKAGE_INSTALLATION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_PRE_CONDITION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_PROFILE_CREATION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_REMOVE_NON_REQUIRED_APPS_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_SETTING_PROFILE_OWNER_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_SET_DEVICE_OWNER_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_STARTING_PROFILE_FAILED;\nimport static android.content.Intent.ACTION_MANAGED_PROFILE_AVAILABLE;\nimport static android.content.Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.pm.PackageManager.GET_META_DATA;\nimport static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_AWARE;\nimport static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_UNAWARE;\nimport static android.content.pm.PackageManager.MATCH_UNINSTALLED_PACKAGES;\nimport static android.content.pm.PackageManager.PERMISSION_GRANTED;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_DEFAULT;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE_BLOCKING;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE_NO_FALLBACK;\nimport static android.net.NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK;\nimport static android.provider.DeviceConfig.NAMESPACE_DEVICE_POLICY_MANAGER;\nimport static android.provider.Settings.Global.PRIVATE_DNS_SPECIFIER;\nimport static android.provider.Settings.Secure.MANAGED_PROVISIONING_DPC_DOWNLOADED;\nimport static android.provider.Settings.Secure.USER_SETUP_COMPLETE;\nimport static android.provider.Telephony.Carriers.DPC_URI;\nimport static android.provider.Telephony.Carriers.ENFORCE_KEY;\nimport static android.provider.Telephony.Carriers.ENFORCE_MANAGED_URI;\nimport static android.provider.Telephony.Carriers.INVALID_APN_ID;\nimport static android.security.keystore.AttestationUtils.USE_INDIVIDUAL_ATTESTATION;\nimport static com.android.internal.logging.nano.MetricsProto.MetricsEvent.PROVISIONING_ENTRY_POINT_ADB;\nimport static com.android.internal.widget.LockPatternUtils.CREDENTIAL_TYPE_NONE;\nimport static com.android.internal.widget.LockPatternUtils.StrongAuthTracker.STRONG_AUTH_REQUIRED_AFTER_DPM_LOCK_NOW;\nimport static com.android.server.SystemTimeZone.TIME_ZONE_CONFIDENCE_HIGH;\nimport static com.android.server.am.ActivityManagerService.STOCK_PM_FLAGS;\nimport static com.android.server.devicepolicy.TransferOwnershipMetadataManager.ADMIN_TYPE_DEVICE_OWNER;\nimport static com.android.server.devicepolicy.TransferOwnershipMetadataManager.ADMIN_TYPE_PROFILE_OWNER;\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_DEVICE_OWNER;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_PROFILE_OWNER;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE;\n\nimport android.Manifest;\nimport android.Manifest.permission;\nimport android.accessibilityservice.AccessibilityServiceInfo;\nimport android.accounts.Account;\nimport android.accounts.AccountManager;\nimport android.accounts.AuthenticatorException;\nimport android.accounts.OperationCanceledException;\nimport android.annotation.IntDef;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManager.Mode;\nimport android.app.BroadcastOptions;\nimport android.app.IActivityManager;\nimport android.app.IActivityTaskManager;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.StatusBarManager;\nimport android.app.admin.AccountTypePolicyKey;\nimport android.app.admin.BooleanPolicyValue;\nimport android.app.admin.BundlePolicyValue;\nimport android.app.admin.ComponentNamePolicyValue;\nimport android.app.admin.DeviceAdminInfo;\nimport android.app.admin.DeviceAdminReceiver;\nimport android.app.admin.DevicePolicyCache;\nimport android.app.admin.DevicePolicyDrawableResource;\nimport android.app.admin.DevicePolicyEventLogger;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.admin.DevicePolicyManager.DeviceOwnerType;\nimport android.app.admin.DevicePolicyManager.DevicePolicyOperation;\nimport android.app.admin.DevicePolicyManager.OperationSafetyReason;\nimport android.app.admin.DevicePolicyManager.PasswordComplexity;\nimport android.app.admin.DevicePolicyManager.PersonalAppsSuspensionReason;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerLiteInternal;\nimport android.app.admin.DevicePolicySafetyChecker;\nimport android.app.admin.DevicePolicyState;\nimport android.app.admin.DevicePolicyStringResource;\nimport android.app.admin.DeviceStateCache;\nimport android.app.admin.FactoryResetProtectionPolicy;\nimport android.app.admin.FullyManagedDeviceProvisioningParams;\nimport android.app.admin.IDevicePolicyManager;\nimport android.app.admin.IntegerPolicyValue;\nimport android.app.admin.IntentFilterPolicyKey;\nimport android.app.admin.LockTaskPolicy;\nimport android.app.admin.LongPolicyValue;\nimport android.app.admin.ManagedProfileProvisioningParams;\nimport android.app.admin.ManagedSubscriptionsPolicy;\nimport android.app.admin.NetworkEvent;\nimport android.app.admin.PackagePolicy;\nimport android.app.admin.ParcelableGranteeMap;\nimport android.app.admin.ParcelableResource;\nimport android.app.admin.PasswordMetrics;\nimport android.app.admin.PasswordPolicy;\nimport android.app.admin.PolicyKey;\nimport android.app.admin.PolicyValue;\nimport android.app.admin.PreferentialNetworkServiceConfig;\nimport android.app.admin.SecurityLog;\nimport android.app.admin.SecurityLog.SecurityEvent;\nimport android.app.admin.StartInstallingUpdateCallback;\nimport android.app.admin.StringSetPolicyValue;\nimport android.app.admin.SystemUpdateInfo;\nimport android.app.admin.SystemUpdatePolicy;\nimport android.app.admin.UnsafeStateException;\nimport android.app.admin.UserRestrictionPolicyKey;\nimport android.app.admin.WifiSsidPolicy;\nimport android.app.backup.IBackupManager;\nimport android.app.compat.CompatChanges;\nimport android.app.role.OnRoleHoldersChangedListener;\nimport android.app.role.RoleManager;\nimport android.app.trust.TrustManager;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.compat.annotation.ChangeId;\nimport android.compat.annotation.EnabledAfter;\nimport android.compat.annotation.EnabledSince;\nimport android.content.ActivityNotFoundException;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.IIntentReceiver;\nimport android.content.IIntentSender;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.PermissionChecker;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.CrossProfileApps;\nimport android.content.pm.CrossProfileAppsInternal;\nimport android.content.pm.IPackageDataObserver;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageInstaller;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.StringParceledListSlice;\nimport android.content.pm.UserInfo;\nimport android.content.pm.UserPackage;\nimport android.content.pm.parsing.FrameworkParsingPackageUtils;\nimport android.content.res.Resources;\nimport android.database.ContentObserver;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.hardware.usb.UsbManager;\nimport android.location.Location;\nimport android.location.LocationManager;\nimport android.media.AudioManager;\nimport android.media.IAudioService;\nimport android.net.ConnectivityManager;\nimport android.net.ConnectivitySettingsManager;\nimport android.net.IIpConnectivityMetrics;\nimport android.net.ProfileNetworkPreference;\nimport android.net.ProxyInfo;\nimport android.net.Uri;\nimport android.net.VpnManager;\nimport android.net.metrics.IpConnectivityLog;\nimport android.net.wifi.WifiManager;\nimport android.os.AsyncTask;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.ParcelFileDescriptor;\nimport android.os.PersistableBundle;\nimport android.os.PowerManager;\nimport android.os.PowerManagerInternal;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ServiceSpecificException;\nimport android.os.ShellCallback;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.UserManager.EnforcingUser;\nimport android.os.UserManager.UserRestrictionSource;\nimport android.os.storage.StorageManager;\nimport android.permission.AdminPermissionControlParams;\nimport android.permission.IPermissionManager;\nimport android.permission.PermissionControllerManager;\nimport android.provider.CalendarContract;\nimport android.provider.ContactsContract.QuickContact;\nimport android.provider.ContactsInternal;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.provider.Settings.Global;\nimport android.provider.Telephony;\nimport android.security.AppUriAuthenticationPolicy;\nimport android.security.IKeyChainAliasCallback;\nimport android.security.IKeyChainService;\nimport android.security.KeyChain;\nimport android.security.KeyChain.KeyChainConnection;\nimport android.security.KeyStore;\nimport android.security.keymaster.KeymasterCertificateChain;\nimport android.security.keystore.AttestationUtils;\nimport android.security.keystore.KeyGenParameterSpec;\nimport android.security.keystore.ParcelableKeyGenParameterSpec;\nimport android.stats.devicepolicy.DevicePolicyEnums;\nimport android.telecom.TelecomManager;\nimport android.telephony.SubscriptionManager;\nimport android.telephony.TelephonyManager;\nimport android.telephony.data.ApnSetting;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.DebugUtils;\nimport android.util.IndentingPrintWriter;\nimport android.util.IntArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.Xml;\nimport android.view.IWindowManager;\nimport android.view.accessibility.AccessibilityManager;\nimport android.view.accessibility.IAccessibilityManager;\nimport android.view.inputmethod.InputMethodInfo;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.LocalePicker;\nimport com.android.internal.infra.AndroidFuture;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.net.NetworkUtilsInternal;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.statusbar.IStatusBarService;\nimport com.android.internal.telephony.SmsApplication;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.FunctionalUtils.ThrowingRunnable;\nimport com.android.internal.util.FunctionalUtils.ThrowingSupplier;\nimport com.android.internal.util.JournaledFile;\nimport com.android.internal.util.Preconditions;\nimport com.android.internal.util.StatLogger;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.internal.widget.LockSettingsInternal;\nimport com.android.internal.widget.LockscreenCredential;\nimport com.android.internal.widget.PasswordValidationError;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.net.module.util.ProxyUtils;\nimport com.android.server.AlarmManagerInternal;\nimport com.android.server.LocalManagerRegistry;\nimport com.android.server.LocalServices;\nimport com.android.server.LockGuard;\nimport com.android.server.PersistentDataBlockManagerInternal;\nimport com.android.server.SystemServerInitThreadPool;\nimport com.android.server.SystemService;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.devicepolicy.ActiveAdmin.TrustAgentInfo;\nimport com.android.server.inputmethod.InputMethodManagerInternal;\nimport com.android.server.net.NetworkPolicyManagerInternal;\nimport com.android.server.pm.DefaultCrossProfileIntentFilter;\nimport com.android.server.pm.DefaultCrossProfileIntentFiltersUtils;\nimport com.android.server.pm.PackageManagerLocal;\nimport com.android.server.pm.RestrictionsSet;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.pm.UserManagerInternal.UserRestrictionsListener;\nimport com.android.server.pm.UserRestrictionsUtils;\nimport com.android.server.pm.pkg.AndroidPackage;\nimport com.android.server.storage.DeviceStorageMonitorInternal;\nimport com.android.server.uri.NeededUriGrants;\nimport com.android.server.uri.UriGrantsManagerInternal;\nimport com.android.server.utils.Slogf;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Constructor;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.text.DateFormat;\nimport java.time.LocalDate;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\n/**\n * Implementation of the device policy APIs.\n */\npublic class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n\n    protected static final String LOG_TAG = \"DevicePolicyManager\";\n\n    private static final String ATTRIBUTION_TAG = \"DevicePolicyManagerService\";\n\n    static final boolean VERBOSE_LOG = false; // DO NOT SUBMIT WITH TRUE\n\n    static final String DEVICE_POLICIES_XML = \"device_policies.xml\";\n\n    static final String POLICIES_VERSION_XML = \"device_policies_version\";\n\n    private static final String TRANSFER_OWNERSHIP_PARAMETERS_XML =\n            \"transfer-ownership-parameters.xml\";\n\n    private static final String TAG_TRANSFER_OWNERSHIP_BUNDLE = \"transfer-ownership-bundle\";\n\n    private static final int REQUEST_EXPIRE_PASSWORD = 5571;\n\n    private static final int REQUEST_PROFILE_OFF_DEADLINE = 5572;\n\n    // Binary XML serializer doesn't support longer strings\n    private static final int MAX_POLICY_STRING_LENGTH = 65535;\n    // FrameworkParsingPackageUtils#MAX_FILE_NAME_SIZE, Android packages are used in dir names.\n    private static final int MAX_PACKAGE_NAME_LENGTH = 223;\n\n    private static final int MAX_PROFILE_NAME_LENGTH = 200;\n    private static final int MAX_LONG_SUPPORT_MESSAGE_LENGTH = 20000;\n    private static final int MAX_SHORT_SUPPORT_MESSAGE_LENGTH = 200;\n    private static final int MAX_ORG_NAME_LENGTH = 200;\n\n    private static final long MS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n\n    private static final long EXPIRATION_GRACE_PERIOD_MS = 5 * MS_PER_DAY; // 5 days, in ms\n    private static final long MANAGED_PROFILE_MAXIMUM_TIME_OFF_THRESHOLD = 3 * MS_PER_DAY;\n    /** When to warn the user about the approaching work profile off deadline: 1 day before */\n    private static final long MANAGED_PROFILE_OFF_WARNING_PERIOD = 1 * MS_PER_DAY;\n\n    private static final String ACTION_EXPIRED_PASSWORD_NOTIFICATION =\n            \"com.android.server.ACTION_EXPIRED_PASSWORD_NOTIFICATION\";\n\n    /** Broadcast action invoked when the user taps a notification to turn the profile on. */\n    @VisibleForTesting\n    static final String ACTION_TURN_PROFILE_ON_NOTIFICATION =\n            \"com.android.server.ACTION_TURN_PROFILE_ON_NOTIFICATION\";\n\n    /** Broadcast action for tracking managed profile maximum time off. */\n    @VisibleForTesting\n    static final String ACTION_PROFILE_OFF_DEADLINE =\n            \"com.android.server.ACTION_PROFILE_OFF_DEADLINE\";\n\n    private static final String CALLED_FROM_PARENT = \"calledFromParent\";\n    private static final String NOT_CALLED_FROM_PARENT = \"notCalledFromParent\";\n\n    private static final String CREDENTIAL_MANAGEMENT_APP = \"credentialManagementApp\";\n    private static final String NOT_CREDENTIAL_MANAGEMENT_APP = \"notCredentialManagementApp\";\n\n    private static final String NULL_STRING_ARRAY = \"nullStringArray\";\n\n    private static final String ALLOW_USER_PROVISIONING_KEY = \"ro.config.allowuserprovisioning\";\n\n    // Comprehensive list of delegations.\n    private static final String DELEGATIONS[] = {\n        DELEGATION_CERT_INSTALL,\n        DELEGATION_APP_RESTRICTIONS,\n        DELEGATION_BLOCK_UNINSTALL,\n        DELEGATION_ENABLE_SYSTEM_APP,\n        DELEGATION_KEEP_UNINSTALLED_PACKAGES,\n        DELEGATION_PACKAGE_ACCESS,\n        DELEGATION_PERMISSION_GRANT,\n        DELEGATION_INSTALL_EXISTING_PACKAGE,\n        DELEGATION_KEEP_UNINSTALLED_PACKAGES,\n        DELEGATION_NETWORK_LOGGING,\n        DELEGATION_SECURITY_LOGGING,\n        DELEGATION_CERT_SELECTION,\n    };\n\n    // Subset of delegations that can only be delegated by Device Owner or Profile Owner of a\n    // managed profile.\n    private static final List<String> DEVICE_OWNER_OR_MANAGED_PROFILE_OWNER_DELEGATIONS =\n            Arrays.asList(new String[]{\n                    DELEGATION_NETWORK_LOGGING,\n            });\n\n    // Subset of delegations that can only be delegated by Device Owner or Profile Owner of an\n    // organization-owned and managed profile.\n    private static final List<String>\n            DEVICE_OWNER_OR_ORGANIZATION_OWNED_MANAGED_PROFILE_OWNER_DELEGATIONS =\n            Arrays.asList(new String[]{\n                    DELEGATION_SECURITY_LOGGING,\n            });\n\n    // Subset of delegations that only one single package within a given user can hold\n    private static final List<String> EXCLUSIVE_DELEGATIONS = Arrays.asList(new String[] {\n            DELEGATION_NETWORK_LOGGING,\n            DELEGATION_SECURITY_LOGGING,\n            DELEGATION_CERT_SELECTION,\n    });\n\n    /**\n     * System property whose value indicates whether the device is fully owned by an organization:\n     * it can be either a device owner device, or a device with an organization-owned managed\n     * profile.\n     *\n     * <p>The state is stored as a Boolean string.\n     */\n    private static final String PROPERTY_ORGANIZATION_OWNED = \"ro.organization_owned\";\n\n    private static final int STATUS_BAR_DISABLE_MASK =\n            StatusBarManager.DISABLE_EXPAND |\n            StatusBarManager.DISABLE_NOTIFICATION_ICONS |\n            StatusBarManager.DISABLE_NOTIFICATION_ALERTS |\n            StatusBarManager.DISABLE_SEARCH;\n\n    private static final int STATUS_BAR_DISABLE2_MASK =\n            StatusBarManager.DISABLE2_QUICK_SETTINGS;\n\n    private static final Set<String> SECURE_SETTINGS_ALLOWLIST;\n    private static final Set<String> SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST;\n    private static final Set<String> GLOBAL_SETTINGS_ALLOWLIST;\n    private static final Set<String> GLOBAL_SETTINGS_DEPRECATED;\n    private static final Set<String> SYSTEM_SETTINGS_ALLOWLIST;\n    private static final Set<Integer> DA_DISALLOWED_POLICIES;\n    private static final String AB_DEVICE_KEY = \"ro.build.ab_update\";\n    // The version of the current DevicePolicyManagerService data. This version is used\n    // to decide whether an existing policy in the {@link #DEVICE_POLICIES_XML} needs to\n    // be upgraded. See {@link PolicyVersionUpgrader} on instructions how to add an upgrade\n    // step.\n    static final int DPMS_VERSION = 5;\n\n    static {\n        SECURE_SETTINGS_ALLOWLIST = new ArraySet<>();\n        SECURE_SETTINGS_ALLOWLIST.add(Settings.Secure.DEFAULT_INPUT_METHOD);\n        SECURE_SETTINGS_ALLOWLIST.add(Settings.Secure.SKIP_FIRST_USE_HINTS);\n        SECURE_SETTINGS_ALLOWLIST.add(Settings.Secure.INSTALL_NON_MARKET_APPS);\n\n        SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST = new ArraySet<>();\n        SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST.addAll(SECURE_SETTINGS_ALLOWLIST);\n        SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST.add(Settings.Secure.LOCATION_MODE);\n\n        GLOBAL_SETTINGS_ALLOWLIST = new ArraySet<>();\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.ADB_ENABLED);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.ADB_WIFI_ENABLED);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.AUTO_TIME);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.AUTO_TIME_ZONE);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.DATA_ROAMING);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.USB_MASS_STORAGE_ENABLED);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.WIFI_SLEEP_POLICY);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.STAY_ON_WHILE_PLUGGED_IN);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.PRIVATE_DNS_MODE);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.PRIVATE_DNS_SPECIFIER);\n\n        GLOBAL_SETTINGS_DEPRECATED = new ArraySet<>();\n        GLOBAL_SETTINGS_DEPRECATED.add(Settings.Global.BLUETOOTH_ON);\n        GLOBAL_SETTINGS_DEPRECATED.add(Settings.Global.DEVELOPMENT_SETTINGS_ENABLED);\n        GLOBAL_SETTINGS_DEPRECATED.add(Settings.Global.MODE_RINGER);\n        GLOBAL_SETTINGS_DEPRECATED.add(Settings.Global.NETWORK_PREFERENCE);\n        GLOBAL_SETTINGS_DEPRECATED.add(Settings.Global.WIFI_ON);\n\n        SYSTEM_SETTINGS_ALLOWLIST = new ArraySet<>();\n        SYSTEM_SETTINGS_ALLOWLIST.add(Settings.System.SCREEN_BRIGHTNESS);\n        SYSTEM_SETTINGS_ALLOWLIST.add(Settings.System.SCREEN_BRIGHTNESS_FLOAT);\n        SYSTEM_SETTINGS_ALLOWLIST.add(Settings.System.SCREEN_BRIGHTNESS_MODE);\n        SYSTEM_SETTINGS_ALLOWLIST.add(Settings.System.SCREEN_OFF_TIMEOUT);\n\n        DA_DISALLOWED_POLICIES = new ArraySet<>();\n        DA_DISALLOWED_POLICIES.add(DeviceAdminInfo.USES_POLICY_DISABLE_CAMERA);\n        DA_DISALLOWED_POLICIES.add(DeviceAdminInfo.USES_POLICY_DISABLE_KEYGUARD_FEATURES);\n        DA_DISALLOWED_POLICIES.add(DeviceAdminInfo.USES_POLICY_EXPIRE_PASSWORD);\n        DA_DISALLOWED_POLICIES.add(DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD);\n    }\n\n    /**\n     * Keyguard features that when set on a profile affect the profile content or challenge only.\n     * These cannot be set on the managed profile's parent DPM instance\n     */\n    private static final int PROFILE_KEYGUARD_FEATURES_PROFILE_ONLY =\n            DevicePolicyManager.KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS;\n\n    /** Keyguard features that are allowed to be set on a managed profile */\n    private static final int PROFILE_KEYGUARD_FEATURES =\n            NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER\n                    | PROFILE_KEYGUARD_FEATURES_PROFILE_ONLY;\n\n    private static final int DEVICE_ADMIN_DEACTIVATE_TIMEOUT = 10000;\n\n    /**\n     * Minimum timeout in milliseconds after which unlocking with weak auth times out,\n     * i.e. the user has to use a strong authentication method like password, PIN or pattern.\n     */\n    private static final long MINIMUM_STRONG_AUTH_TIMEOUT_MS = TimeUnit.HOURS.toMillis(1);\n\n    /**\n     * The amount of ms that a managed kiosk must go without user interaction to be considered\n     * unattended.\n     */\n    private static final int UNATTENDED_MANAGED_KIOSK_MS = 30000;\n\n    /**\n     * Strings logged with {@link\n     * com.android.internal.logging.nano.MetricsProto.MetricsEvent#PROVISIONING_ENTRY_POINT_ADB},\n     * {@link DevicePolicyEnums#PROVISIONING_ENTRY_POINT_ADB},\n     * {@link DevicePolicyEnums#SET_NETWORK_LOGGING_ENABLED} and\n     * {@link DevicePolicyEnums#RETRIEVE_NETWORK_LOGS}.\n     */\n    private static final String LOG_TAG_PROFILE_OWNER = \"profile-owner\";\n    private static final String LOG_TAG_DEVICE_OWNER = \"device-owner\";\n\n    /**\n     * For admin apps targeting R+, throw when the app sets password requirement\n     * that is not taken into account at given quality. For example when quality is set\n     * to {@link android.app.admin.DevicePolicyManager#PASSWORD_QUALITY_UNSPECIFIED}, it doesn't\n     * make sense to require certain password length. If the intent is to require a password of\n     * certain length having at least NUMERIC quality, the admin should first call\n     * {@link android.app.admin.DevicePolicyManager#setPasswordQuality} and only then call\n     * {@link android.app.admin.DevicePolicyManager#setPasswordMinimumLength}.\n     *\n     * <p>Conversely when an admin app targeting R+ lowers password quality, those\n     * requirements that stop making sense are reset to default values.\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion = Build.VERSION_CODES.Q)\n    private static final long ADMIN_APP_PASSWORD_COMPLEXITY = 123562444L;\n\n    /**\n     * Admin apps targeting Android R+ may not use\n     * {@link android.app.admin.DevicePolicyManager#setSecureSetting} to change the deprecated\n     * {@link android.provider.Settings.Secure#LOCATION_MODE} setting. Instead they should use\n     * {@link android.app.admin.DevicePolicyManager#setLocationEnabled}.\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion = Build.VERSION_CODES.Q)\n    private static final long USE_SET_LOCATION_ENABLED = 117835097L;\n\n    /**\n     * Forces wipeDataNoLock to attempt removing the user or throw an error as\n     * opposed to trying to factory reset the device first and only then falling back to user\n     * removal.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    public static final long EXPLICIT_WIPE_BEHAVIOUR = 242193913L;\n\n    /**\n     * Apps targetting U+ should now expect that attempts to grant sensor permissions without\n     * authorisation will result in a security exception.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    public static final long THROW_SECURITY_EXCEPTION_FOR_SENSOR_PERMISSIONS = 277035314L;\n\n    // Only add to the end of the list. Do not change or rearrange these values, that will break\n    // historical data. Do not use negative numbers or zero, logger only handles positive\n    // integers.\n    private static final int COPY_ACCOUNT_SUCCEEDED = 1;\n    private static final int COPY_ACCOUNT_FAILED = 2;\n    private static final int COPY_ACCOUNT_TIMED_OUT = 3;\n    private static final int COPY_ACCOUNT_EXCEPTION = 4;\n\n    @IntDef({\n            COPY_ACCOUNT_SUCCEEDED,\n            COPY_ACCOUNT_FAILED,\n            COPY_ACCOUNT_TIMED_OUT,\n            COPY_ACCOUNT_EXCEPTION})\n    private @interface CopyAccountStatus {}\n\n    /**\n     * Mapping of {@link android.app.admin.DevicePolicyManager.ApplicationExemptionConstants} to\n     * corresponding app-ops.\n     */\n    private static final Map<Integer, String> APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS =\n            new ArrayMap<>();\n    static {\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_SUSPENSION, OPSTR_SYSTEM_EXEMPT_FROM_SUSPENSION);\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS,\n                OPSTR_SYSTEM_EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS);\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION,\n                OPSTR_SYSTEM_EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION);\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_HIBERNATION, OPSTR_SYSTEM_EXEMPT_FROM_HIBERNATION);\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_POWER_RESTRICTIONS, OPSTR_SYSTEM_EXEMPT_FROM_POWER_RESTRICTIONS);\n    }\n\n    /**\n     * Admin apps targeting Android S+ may not use\n     * {@link android.app.admin.DevicePolicyManager#setPasswordQuality} to set password quality\n     * on the {@code DevicePolicyManager} instance obtained by calling\n     * {@link android.app.admin.DevicePolicyManager#getParentProfileInstance}.\n     * Instead, they should use\n     * {@link android.app.admin.DevicePolicyManager#setRequiredPasswordComplexity} to set\n     * coarse-grained password requirements device-wide.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.S)\n    private static final long PREVENT_SETTING_PASSWORD_QUALITY_ON_PARENT = 165573442L;\n\n    /**\n     * For Admin Apps targeting U+\n     * If {@link android.security.IKeyChainService#setGrant} is called with an alias with no\n     * existing key, throw IllegalArgumentException.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    private static final long THROW_EXCEPTION_WHEN_KEY_MISSING = 175101461L;\n\n    private static final String CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG =\n            \"The alias provided must be contained in the aliases specified in the credential \"\n                    + \"management app's authentication policy\";\n    private static final String NOT_SYSTEM_CALLER_MSG = \"Only the system can %s\";\n\n    private static final String PERMISSION_BASED_ACCESS_EXPERIMENT_FLAG =\n            \"enable_permission_based_access\";\n    private static final boolean DEFAULT_VALUE_PERMISSION_BASED_ACCESS_FLAG = false;\n\n    private static final String ENABLE_DEVICE_POLICY_ENGINE_FOR_FINANCE_FLAG =\n            \"enable_device_policy_engine\";\n    private static final boolean DEFAULT_ENABLE_DEVICE_POLICY_ENGINE_FOR_FINANCE_FLAG = true;\n\n    // TODO(b/265683382) remove the flag after rollout.\n    private static final String KEEP_PROFILES_RUNNING_FLAG = \"enable_keep_profiles_running\";\n    public static final boolean DEFAULT_KEEP_PROFILES_RUNNING_FLAG = true;\n\n    // TODO(b/261999445) remove the flag after rollout.\n    private static final String HEADLESS_FLAG = \"headless\";\n    private static final boolean DEFAULT_HEADLESS_FLAG = true;\n\n    // TODO(b/266831522) remove the flag after rollout.\n    private static final String APPLICATION_EXEMPTIONS_FLAG = \"application_exemptions\";\n    private static final boolean DEFAULT_APPLICATION_EXEMPTIONS_FLAG = true;\n\n    /**\n     * For apps targeting U+\n     * Enable multiple admins to coexist on the same device.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    static final long ENABLE_COEXISTENCE_CHANGE = 260560985L;\n\n    final Context mContext;\n    final Injector mInjector;\n    final PolicyPathProvider mPathProvider;\n    final IPackageManager mIPackageManager;\n    final IPermissionManager mIPermissionManager;\n    final UserManager mUserManager;\n    final UserManagerInternal mUserManagerInternal;\n    final UsageStatsManagerInternal mUsageStatsManagerInternal;\n    final TelephonyManager mTelephonyManager;\n    final RoleManager mRoleManager;\n    private final LockPatternUtils mLockPatternUtils;\n    private final LockSettingsInternal mLockSettingsInternal;\n    private final DeviceAdminServiceController mDeviceAdminServiceController;\n    private final OverlayPackagesProvider mOverlayPackagesProvider;\n\n    private final DevicePolicyCacheImpl mPolicyCache = new DevicePolicyCacheImpl();\n    private final DeviceStateCacheImpl mStateCache = new DeviceStateCacheImpl();\n    private final Object mESIDInitilizationLock = new Object();\n    private EnterpriseSpecificIdCalculator mEsidCalculator;\n    private final Object mSubscriptionsChangedListenerLock = new Object();\n    @GuardedBy(\"mSubscriptionsChangedListenerLock\")\n    private SubscriptionManager.OnSubscriptionsChangedListener mSubscriptionsChangedListener;\n\n    /**\n     * Contains the list of OEM Default Role Holders for Contact-related roles\n     * (DIALER, SMS, SYSTEM_CONTACTS)\n     */\n    private final Set<String> mContactSystemRoleHolders;\n\n    /**\n     * Contains (package-user) pairs to remove. An entry (p, u) implies that removal of package p\n     * is requested for user u.\n     */\n    private final Set<UserPackage> mPackagesToRemove = new ArraySet<>();\n\n    final LocalService mLocalService;\n\n    // Stores and loads state on device and profile owners.\n    @VisibleForTesting\n    final Owners mOwners;\n\n    private final Binder mToken = new Binder();\n\n    /**\n     * Whether or not device admin feature is supported. If it isn't return defaults for all\n     * public methods, unless the caller has the appropriate permission for a particular method.\n     */\n    final boolean mHasFeature;\n\n    /**\n     * Whether or not this device is a watch.\n     */\n    final boolean mIsWatch;\n\n    /**\n     * Whether or not this device is an automotive.\n     */\n    private final boolean mIsAutomotive;\n\n    /**\n     * Whether this device has the telephony feature.\n     */\n    final boolean mHasTelephonyFeature;\n\n    private final CertificateMonitor mCertificateMonitor;\n    private final SecurityLogMonitor mSecurityLogMonitor;\n    private final RemoteBugreportManager mBugreportCollectionManager;\n\n    @GuardedBy(\"getLockObject()\")\n    private NetworkLogger mNetworkLogger;\n\n    private final SetupContentObserver mSetupContentObserver;\n    private final DevicePolicyConstantsObserver mConstantsObserver;\n\n    private DevicePolicyConstants mConstants;\n\n    /**\n     * User to be switched to on {@code logoutUser()}.\n     *\n     * <p>Only used on devices with headless system user mode\n     */\n    @GuardedBy(\"getLockObject()\")\n    private @UserIdInt int mLogoutUserId = UserHandle.USER_NULL;\n\n    /**\n     * User the network logging notification was sent to.\n     */\n    // Guarded by mHandler\n    private @UserIdInt int mNetworkLoggingNotificationUserId = UserHandle.USER_NULL;\n\n    private final DeviceManagementResourcesProvider mDeviceManagementResourcesProvider;\n    private final DevicePolicyManagementRoleObserver mDevicePolicyManagementRoleObserver;\n\n    private final DevicePolicyEngine mDevicePolicyEngine;\n\n    private static final boolean ENABLE_LOCK_GUARD = true;\n\n    /**\n     * Profile off deadline is not set or more than MANAGED_PROFILE_OFF_WARNING_PERIOD away, or the\n     * user is running unlocked, no need for notification.\n     */\n    private static final int PROFILE_OFF_NOTIFICATION_NONE = 0;\n    /**\n     * Profile off deadline is closer than MANAGED_PROFILE_OFF_WARNING_PERIOD.\n     */\n    private static final int PROFILE_OFF_NOTIFICATION_WARNING = 1;\n    /**\n     * Profile off deadline reached, notify the user that personal apps blocked.\n     */\n    private static final int PROFILE_OFF_NOTIFICATION_SUSPENDED = 2;\n\n    interface Stats {\n        int LOCK_GUARD_GUARD = 0;\n\n        int COUNT = LOCK_GUARD_GUARD + 1;\n    }\n\n    private final StatLogger mStatLogger = new StatLogger(new String[] {\n            \"LockGuard.guard()\",\n    });\n\n    private final Object mLockDoNoUseDirectly = LockGuard.installNewLock(\n            LockGuard.INDEX_DPMS, /* doWtf=*/ true);\n\n    final Object getLockObject() {\n        if (ENABLE_LOCK_GUARD) {\n            final long start = mStatLogger.getTime();\n            LockGuard.guard(LockGuard.INDEX_DPMS);\n            mStatLogger.logDurationStat(Stats.LOCK_GUARD_GUARD, start);\n        }\n        return mLockDoNoUseDirectly;\n    }\n\n    /**\n     * Check if the current thread holds the DPMS lock, and if not, do a WTF.\n     *\n     * (Doing this check too much may be costly, so don't call it in a hot path.)\n     */\n    final void ensureLocked() {\n        if (Thread.holdsLock(mLockDoNoUseDirectly)) {\n            return;\n        }\n        Slogf.wtfStack(LOG_TAG, \"Not holding DPMS lock.\");\n    }\n\n    /**\n     * Calls wtfStack() if called with the DPMS lock held.\n     */\n    private void wtfIfInLock() {\n        if (Thread.holdsLock(mLockDoNoUseDirectly)) {\n            Slogf.wtfStack(LOG_TAG, \"Shouldn't be called with DPMS lock held\");\n        }\n    }\n\n    @VisibleForTesting\n    final TransferOwnershipMetadataManager mTransferOwnershipMetadataManager;\n\n    @Nullable\n    private DevicePolicySafetyChecker mSafetyChecker;\n\n    @GuardedBy(\"getLockObject()\")\n    private final ArrayList<Object> mPendingUserCreatedCallbackTokens = new ArrayList<>();\n\n    public static final class Lifecycle extends SystemService {\n        private DevicePolicyManagerService mService;\n\n        public Lifecycle(Context context) {\n            super(context);\n            String dpmsClassName = context.getResources()\n                    .getString(R.string.config_deviceSpecificDevicePolicyManagerService);\n            if (TextUtils.isEmpty(dpmsClassName)) {\n                mService = new DevicePolicyManagerService(context);\n            } else {\n                try {\n                    Class<?> serviceClass = Class.forName(dpmsClassName);\n                    Constructor<?> constructor = serviceClass.getConstructor(Context.class);\n                    mService = (DevicePolicyManagerService) constructor.newInstance(context);\n                } catch (Exception e) {\n                    throw new IllegalStateException(\n                        \"Failed to instantiate DevicePolicyManagerService with class name: \"\n                        + dpmsClassName, e);\n                }\n            }\n        }\n\n        /** Sets the {@link DevicePolicySafetyChecker}. */\n        public void setDevicePolicySafetyChecker(DevicePolicySafetyChecker safetyChecker) {\n            mService.setDevicePolicySafetyChecker(safetyChecker);\n        }\n\n        @Override\n        public void onStart() {\n            publishBinderService(Context.DEVICE_POLICY_SERVICE, mService);\n        }\n\n        @Override\n        public void onBootPhase(int phase) {\n            mService.systemReady(phase);\n        }\n\n        @Override\n        public void onUserStarting(@NonNull TargetUser user) {\n            if (user.isPreCreated()) return;\n            mService.handleStartUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserUnlocking(@NonNull TargetUser user) {\n            if (user.isPreCreated()) return;\n            mService.handleUnlockUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserStopping(@NonNull TargetUser user) {\n            if (user.isPreCreated()) return;\n            mService.handleStopUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserUnlocked(@NonNull TargetUser user) {\n            if (user.isPreCreated()) return;\n            mService.handleOnUserUnlocked(user.getUserIdentifier());\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    final SparseArray<DevicePolicyData> mUserData;\n\n    final Handler mHandler;\n    final Handler mBackgroundHandler;\n\n    /** Listens only if mHasFeature == true. */\n    final BroadcastReceiver mReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            final int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE,\n                    getSendingUserId());\n\n            /*\n             * Network logging would ideally be started in setDeviceOwnerSystemPropertyLocked(),\n             * however it's too early in the boot process to register with IIpConnectivityMetrics\n             * to listen for events.\n             */\n            if (Intent.ACTION_USER_STARTED.equals(action) && userHandle == UserHandle.USER_SYSTEM) {\n                synchronized (getLockObject()) {\n                    if (isNetworkLoggingEnabledInternalLocked()) {\n                        setNetworkLoggingActiveInternal(true);\n                    }\n                }\n            }\n\n            if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {\n                calculateHasIncompatibleAccounts();\n            }\n\n            if (Intent.ACTION_BOOT_COMPLETED.equals(action)\n                    && userHandle == mOwners.getDeviceOwnerUserId()) {\n                mBugreportCollectionManager.checkForPendingBugreportAfterBoot();\n\n            }\n            if (Intent.ACTION_BOOT_COMPLETED.equals(action)\n                    || ACTION_EXPIRED_PASSWORD_NOTIFICATION.equals(action)) {\n                if (VERBOSE_LOG) {\n                    Slogf.v(LOG_TAG, \"Sending password expiration notifications for action \"\n                            + action + \" for user \" + userHandle);\n                }\n                mHandler.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        handlePasswordExpirationNotification(userHandle);\n                    }\n                });\n            }\n\n            if (Intent.ACTION_USER_ADDED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_ADDED, userHandle);\n                synchronized (getLockObject()) {\n                    // It might take a while for the user to become affiliated. Make security\n                    // and network logging unavailable in the meantime.\n                    maybePauseDeviceWideLoggingLocked();\n                }\n            } else if (Intent.ACTION_USER_REMOVED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_REMOVED, userHandle);\n                synchronized (getLockObject()) {\n                    // Check whether the user is affiliated, *before* removing its data.\n                    boolean isRemovedUserAffiliated = isUserAffiliatedWithDeviceLocked(userHandle);\n                    removeUserData(userHandle);\n                    if (!isRemovedUserAffiliated) {\n                        // We discard the logs when unaffiliated users are deleted (so that the\n                        // device owner cannot retrieve data about that user after it's gone).\n                        discardDeviceWideLogsLocked();\n                        // Resume logging if all remaining users are affiliated.\n                        maybeResumeDeviceWideLoggingLocked();\n                    }\n                }\n                if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n                    mDevicePolicyEngine.handleUserRemoved(userHandle);\n                }\n            } else if (Intent.ACTION_USER_STARTED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_STARTED, userHandle);\n                synchronized (getLockObject()) {\n                    maybeSendAdminEnabledBroadcastLocked(userHandle);\n                    // Reset the policy data\n                    mUserData.remove(userHandle);\n                }\n                handlePackagesChanged(null /* check all admins */, userHandle);\n                updatePersonalAppsSuspensionOnUserStart(userHandle);\n            } else if (Intent.ACTION_USER_STOPPED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_STOPPED, userHandle);\n                if (isManagedProfile(userHandle)) {\n                    Slogf.d(LOG_TAG, \"Managed profile was stopped\");\n                    updatePersonalAppsSuspension(userHandle);\n                }\n            } else if (Intent.ACTION_USER_SWITCHED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_SWITCHED, userHandle);\n            } else if (Intent.ACTION_USER_UNLOCKED.equals(action)) {\n                synchronized (getLockObject()) {\n                    maybeSendAdminEnabledBroadcastLocked(userHandle);\n                }\n                if (isManagedProfile(userHandle)) {\n                    Slogf.d(LOG_TAG, \"Managed profile became unlocked\");\n                    final boolean suspended = updatePersonalAppsSuspension(userHandle);\n                    triggerPolicyComplianceCheckIfNeeded(userHandle, suspended);\n                }\n            } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {\n                handlePackagesChanged(null /* check all admins */, userHandle);\n            } else if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {\n                handlePackagesChanged(intent.getData().getSchemeSpecificPart(), userHandle);\n            } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {\n                if (intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {\n                    handlePackagesChanged(intent.getData().getSchemeSpecificPart(), userHandle);\n                } else {\n                    handleNewPackageInstalled(intent.getData().getSchemeSpecificPart(), userHandle);\n                }\n            } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)\n                    && !intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {\n                handlePackagesChanged(intent.getData().getSchemeSpecificPart(), userHandle);\n                removeCredentialManagementApp(intent.getData().getSchemeSpecificPart());\n            } else if (Intent.ACTION_MANAGED_PROFILE_ADDED.equals(action)) {\n                clearWipeProfileNotification();\n            } else if (Intent.ACTION_DATE_CHANGED.equals(action)\n                    || Intent.ACTION_TIME_CHANGED.equals(action)) {\n                // Update freeze period record when clock naturally progresses to the next day\n                // (ACTION_DATE_CHANGED), or when manual clock adjustment is made\n                // (ACTION_TIME_CHANGED)\n                updateSystemUpdateFreezePeriodsRecord(/* saveIfChanged */ true);\n                final int userId = getManagedUserId(getMainUserId());\n                if (userId >= 0) {\n                    updatePersonalAppsSuspension(userId);\n                }\n            } else if (ACTION_PROFILE_OFF_DEADLINE.equals(action)) {\n                Slogf.i(LOG_TAG, \"Profile off deadline alarm was triggered\");\n                final int userId = getManagedUserId(getMainUserId());\n                if (userId >= 0) {\n                    updatePersonalAppsSuspension(userId);\n                } else {\n                    Slogf.wtf(LOG_TAG, \"Got deadline alarm for nonexistent profile\");\n                }\n            } else if (ACTION_TURN_PROFILE_ON_NOTIFICATION.equals(action)) {\n                Slogf.i(LOG_TAG, \"requesting to turn on the profile: \" + userHandle);\n                mUserManager.requestQuietModeEnabled(false, UserHandle.of(userHandle));\n            } else if (ACTION_MANAGED_PROFILE_UNAVAILABLE.equals(action)) {\n                notifyIfManagedSubscriptionsAreUnavailable(\n                        UserHandle.of(userHandle), /* managedProfileAvailable= */ false);\n                updatePersonalAppsSuspension(userHandle);\n            } else if (ACTION_MANAGED_PROFILE_AVAILABLE.equals(action)) {\n                notifyIfManagedSubscriptionsAreUnavailable(\n                        UserHandle.of(userHandle), /* managedProfileAvailable= */ true);\n                final boolean suspended = updatePersonalAppsSuspension(userHandle);\n                triggerPolicyComplianceCheckIfNeeded(userHandle, suspended);\n            } else if (LOGIN_ACCOUNTS_CHANGED_ACTION.equals(action)) {\n                calculateHasIncompatibleAccounts();\n            }\n        }\n\n        private void sendDeviceOwnerUserCommand(String action, int userHandle) {\n            synchronized (getLockObject()) {\n                ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n                if (deviceOwner != null) {\n                    Bundle extras = new Bundle();\n                    extras.putParcelable(Intent.EXTRA_USER, UserHandle.of(userHandle));\n                    sendAdminCommandLocked(deviceOwner, action, extras, /* result */ null,\n                            /* inForeground */ true);\n                }\n            }\n        }\n    };\n\n    protected static class RestrictionsListener implements UserRestrictionsListener {\n        private final Context mContext;\n        private final UserManagerInternal mUserManagerInternal;\n        private final DevicePolicyManagerService mDpms;\n\n        public RestrictionsListener(\n                Context context,\n                UserManagerInternal userManagerInternal,\n                DevicePolicyManagerService dpms) {\n            mContext = context;\n            mUserManagerInternal = userManagerInternal;\n            mDpms = dpms;\n        }\n\n        @Override\n        public void onUserRestrictionsChanged(int userId, Bundle newRestrictions,\n                Bundle prevRestrictions) {\n            resetCrossProfileIntentFiltersIfNeeded(userId, newRestrictions, prevRestrictions);\n            resetUserVpnIfNeeded(userId, newRestrictions, prevRestrictions);\n        }\n\n        private void resetUserVpnIfNeeded(\n                int userId, Bundle newRestrictions, Bundle prevRestrictions) {\n            final boolean newlyEnforced =\n                    !prevRestrictions.getBoolean(UserManager.DISALLOW_CONFIG_VPN)\n                    && newRestrictions.getBoolean(UserManager.DISALLOW_CONFIG_VPN);\n            if (newlyEnforced) {\n                mDpms.clearUserConfiguredVpns(userId);\n            }\n        }\n\n        private void resetCrossProfileIntentFiltersIfNeeded(\n                int userId, Bundle newRestrictions, Bundle prevRestrictions) {\n            if (UserRestrictionsUtils.restrictionsChanged(prevRestrictions, newRestrictions,\n                    UserManager.DISALLOW_SHARE_INTO_MANAGED_PROFILE)) {\n                final int parentId = mUserManagerInternal.getProfileParentId(userId);\n                if (parentId == userId) {\n                    return;\n                }\n\n                // Always reset filters on the parent user, which handles cross profile intent\n                // filters between the parent and its profiles.\n                Slogf.i(LOG_TAG, \"Resetting cross-profile intent filters on restriction \"\n                        + \"change\");\n                mDpms.resetDefaultCrossProfileIntentFilters(parentId);\n                mContext.sendBroadcastAsUser(\n                        new Intent(DevicePolicyManager.ACTION_DATA_SHARING_RESTRICTION_APPLIED),\n                        UserHandle.of(userId));\n            }\n        }\n    }\n\n    private void clearUserConfiguredVpns(int userId) {\n        final String adminConfiguredVpnPkg;\n        synchronized (getLockObject()) {\n            final ActiveAdmin owner = getDeviceOrProfileOwnerAdminLocked(userId);\n            if (owner == null) {\n                Slogf.wtf(LOG_TAG, \"Admin not found\");\n                return;\n            }\n            adminConfiguredVpnPkg = owner.mAlwaysOnVpnPackage;\n        }\n\n        // Clear always-on configuration if it wasn't set by the admin.\n        if (adminConfiguredVpnPkg == null) {\n            mInjector.getVpnManager().setAlwaysOnVpnPackageForUser(userId, null, false, null);\n        }\n\n        // Clear app authorizations to establish VPNs. When DISALLOW_CONFIG_VPN is enforced apps\n        // won't be able to get those authorizations unless it is configured by an admin.\n        final List<AppOpsManager.PackageOps> allVpnOps = mInjector.getAppOpsManager()\n                .getPackagesForOps(new int[] {AppOpsManager.OP_ACTIVATE_VPN});\n        if (allVpnOps == null) {\n            return;\n        }\n        for (AppOpsManager.PackageOps pkgOps : allVpnOps) {\n            if (UserHandle.getUserId(pkgOps.getUid()) != userId\n                    || pkgOps.getPackageName().equals(adminConfiguredVpnPkg)) {\n                continue;\n            }\n            if (pkgOps.getOps().size() != 1) {\n                Slogf.wtf(LOG_TAG, \"Unexpected number of ops returned\");\n                continue;\n            }\n            final @Mode int mode = pkgOps.getOps().get(0).getMode();\n            if (mode == MODE_ALLOWED) {\n                Slogf.i(LOG_TAG, String.format(\"Revoking VPN authorization for package %s uid %d\",\n                        pkgOps.getPackageName(), pkgOps.getUid()));\n                mInjector.getAppOpsManager().setMode(AppOpsManager.OP_ACTIVATE_VPN, pkgOps.getUid(),\n                        pkgOps.getPackageName(), MODE_DEFAULT);\n            }\n        }\n    }\n\n    private final class UserLifecycleListener implements UserManagerInternal.UserLifecycleListener {\n\n        @Override\n        public void onUserCreated(UserInfo user, Object token) {\n            mHandler.post(() -> handleNewUserCreated(user, token));\n        }\n    }\n\n    private void handlePackagesChanged(@Nullable String packageName, int userHandle) {\n        boolean removedAdmin = false;\n        String removedAdminPackage = null;\n        if (VERBOSE_LOG) {\n            Slogf.d(LOG_TAG, \"Handling package changes package \" + packageName\n                    + \" for user \" + userHandle);\n        }\n        DevicePolicyData policy = getUserData(userHandle);\n        synchronized (getLockObject()) {\n            for (int i = policy.mAdminList.size() - 1; i >= 0; i--) {\n                ActiveAdmin aa = policy.mAdminList.get(i);\n                try {\n                    // If we're checking all packages or if the specific one we're checking matches,\n                    // then check if the package and receiver still exist.\n                    final String adminPackage = aa.info.getPackageName();\n                    if (packageName == null || packageName.equals(adminPackage)) {\n                        if (mIPackageManager.getPackageInfo(adminPackage, 0, userHandle) == null\n                                || mIPackageManager.getReceiverInfo(aa.info.getComponent(),\n                                PackageManager.MATCH_DIRECT_BOOT_AWARE\n                                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n                                userHandle) == null) {\n                            Slogf.e(LOG_TAG, String.format(\n                                    \"Admin package %s not found for user %d, removing active admin\",\n                                    packageName, userHandle));\n                            removedAdmin = true;\n                            removedAdminPackage = adminPackage;\n                            policy.mAdminList.remove(i);\n                            policy.mAdminMap.remove(aa.info.getComponent());\n                            pushActiveAdminPackagesLocked(userHandle);\n                            pushMeteredDisabledPackages(userHandle);\n                        }\n                    }\n                } catch (RemoteException re) {\n                    // Shouldn't happen.\n                    Slogf.wtf(LOG_TAG, \"Error handling package changes\", re);\n                }\n            }\n            if (removedAdmin) {\n                policy.validatePasswordOwner();\n            }\n\n            boolean removedDelegate = false;\n\n            // Check if a delegate was removed.\n            for (int i = policy.mDelegationMap.size() - 1; i >= 0; i--) {\n                final String delegatePackage = policy.mDelegationMap.keyAt(i);\n                if (isRemovedPackage(packageName, delegatePackage, userHandle)) {\n                    policy.mDelegationMap.removeAt(i);\n                    removedDelegate = true;\n                }\n            }\n\n            // If it's an owner package, we may need to refresh the bound connection.\n            final ComponentName owner = getOwnerComponent(userHandle);\n            if ((packageName != null) && (owner != null)\n                    && (owner.getPackageName().equals(packageName))) {\n                startOwnerService(userHandle, \"package-broadcast\");\n            }\n            if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n                mDevicePolicyEngine.handlePackageChanged(\n                        packageName, userHandle, removedAdminPackage);\n            }\n            // Persist updates if the removed package was an admin or delegate.\n            if (removedAdmin || removedDelegate) {\n                saveSettingsLocked(policy.mUserId);\n            }\n        }\n        if (removedAdmin) {\n            // The removed admin might have disabled camera, so update user restrictions.\n            pushUserRestrictions(userHandle);\n        }\n    }\n\n    private void removeCredentialManagementApp(String packageName) {\n        mBackgroundHandler.post(() -> {\n            try (KeyChainConnection connection = mInjector.keyChainBind()) {\n                IKeyChainService service = connection.getService();\n                if (service.hasCredentialManagementApp()\n                        && packageName.equals(service.getCredentialManagementAppPackageName())) {\n                    service.removeCredentialManagementApp();\n                }\n            } catch (RemoteException | InterruptedException | IllegalStateException\n                    | AssertionError e) {\n                Slogf.e(LOG_TAG, \"Unable to remove the credential management app\", e);\n            }\n        });\n    }\n\n    private boolean isRemovedPackage(String changedPackage, String targetPackage, int userHandle) {\n        try {\n            return targetPackage != null\n                    && (changedPackage == null || changedPackage.equals(targetPackage))\n                    && mIPackageManager.getPackageInfo(targetPackage, 0, userHandle) == null;\n        } catch (RemoteException e) {\n            // Shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Error checking isRemovedPackage\", e);\n        }\n\n        return false;\n    }\n\n    private void handleNewPackageInstalled(String packageName, int userHandle) {\n        // If personal apps were suspended by the admin, suspend the newly installed one.\n        if (!getUserData(userHandle).mAppsSuspended) {\n            return;\n        }\n        final String[] packagesToSuspend = { packageName };\n        // Check if package is considered not suspendable?\n        if (mInjector.getPackageManager(userHandle)\n                .getUnsuspendablePackages(packagesToSuspend).length != 0) {\n            Slogf.i(LOG_TAG, \"Newly installed package is unsuspendable: \" + packageName);\n            return;\n        }\n        mInjector.getPackageManagerInternal()\n                .setPackagesSuspendedByAdmin(userHandle, packagesToSuspend, true /*suspend*/);\n    }\n\n    public void setDevicePolicySafetyChecker(DevicePolicySafetyChecker safetyChecker) {\n        CallerIdentity callerIdentity = getCallerIdentity();\n        Preconditions.checkCallAuthorization(mIsAutomotive || isAdb(callerIdentity), \"can only set \"\n                + \"DevicePolicySafetyChecker on automotive builds or from ADB (but caller is %s)\",\n                callerIdentity);\n        setDevicePolicySafetyCheckerUnchecked(safetyChecker);\n    }\n\n    /**\n     * Used by {@code setDevicePolicySafetyChecker()} above and {@link OneTimeSafetyChecker}.\n     */\n    void setDevicePolicySafetyCheckerUnchecked(DevicePolicySafetyChecker safetyChecker) {\n        Slogf.i(LOG_TAG, \"Setting DevicePolicySafetyChecker as %s\", safetyChecker);\n        mSafetyChecker = safetyChecker;\n        mInjector.setDevicePolicySafetyChecker(safetyChecker);\n    }\n\n    /**\n     * Used by {@link OneTimeSafetyChecker} only.\n     */\n    DevicePolicySafetyChecker getDevicePolicySafetyChecker() {\n        return mSafetyChecker;\n    }\n\n    /**\n     * Checks if it's safe to execute the given {@code operation}.\n     *\n     * @throws UnsafeStateException if it's not safe to execute the operation.\n     */\n    private void checkCanExecuteOrThrowUnsafe(@DevicePolicyOperation int operation) {\n        int reason = getUnsafeOperationReason(operation);\n        if (reason == OPERATION_SAFETY_REASON_NONE) return;\n\n        if (mSafetyChecker == null) {\n            // Happens on CTS after it's set just once (by OneTimeSafetyChecker)\n            throw new UnsafeStateException(operation, reason);\n        }\n        // Let mSafetyChecker customize it (for example, by explaining how to retry)\n        throw mSafetyChecker.newUnsafeStateException(operation, reason);\n    }\n\n    /**\n     * Returns whether it's safe to execute the given {@code operation}, and why.\n     */\n    @OperationSafetyReason\n    int getUnsafeOperationReason(@DevicePolicyOperation int operation) {\n        return mSafetyChecker == null ? OPERATION_SAFETY_REASON_NONE\n                : mSafetyChecker.getUnsafeOperationReason(operation);\n    }\n\n    @Override\n    public void setNextOperationSafety(@DevicePolicyOperation int operation,\n            @OperationSafetyReason int reason) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n        Slogf.i(LOG_TAG, \"setNextOperationSafety(%s, %s)\",\n                DevicePolicyManager.operationToString(operation),\n                DevicePolicyManager.operationSafetyReasonToString(reason));\n        mSafetyChecker = new OneTimeSafetyChecker(this, operation, reason);\n    }\n\n    @Override\n    public boolean isSafeOperation(@OperationSafetyReason int reason) {\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"checking isSafeOperation(%s) using mSafetyChecker %s\",\n                    DevicePolicyManager.operationSafetyReasonToString(reason), mSafetyChecker);\n        }\n        return mSafetyChecker == null ? true : mSafetyChecker.isSafeOperation(reason);\n    }\n\n    // Used by DevicePolicyManagerServiceShellCommand\n    List<OwnerShellData> listAllOwners() {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            SparseArray<DevicePolicyData> userData;\n\n            // Gets the owners of \"full users\" first (device owner and profile owners)\n            List<OwnerShellData> owners = mOwners.listAllOwners();\n            synchronized (getLockObject()) {\n                for (int i = 0; i < owners.size(); i++) {\n                    OwnerShellData owner = owners.get(i);\n                    owner.isAffiliated = isUserAffiliatedWithDeviceLocked(owner.userId);\n                }\n                userData = mUserData;\n            }\n\n            // Then the owners of profile users (managed profiles)\n            for (int i = 0; i < userData.size(); i++) {\n                DevicePolicyData policyData = mUserData.valueAt(i);\n                int userId = userData.keyAt(i);\n                int parentUserId = mUserManagerInternal.getProfileParentId(userId);\n                boolean isProfile = parentUserId != userId;\n                if (!isProfile) continue;\n                for (int j = 0; j < policyData.mAdminList.size(); j++) {\n                    ActiveAdmin admin = policyData.mAdminList.get(j);\n                    OwnerShellData owner = OwnerShellData.forManagedProfileOwner(userId,\n                            parentUserId, admin.info.getComponent());\n                    owners.add(owner);\n                }\n            }\n\n            return owners;\n        });\n    }\n\n    /**\n     * Unit test will subclass it to inject mocks.\n     */\n    @VisibleForTesting\n    static class Injector {\n\n        public final Context mContext;\n\n        @Nullable private DevicePolicySafetyChecker mSafetyChecker;\n\n        Injector(Context context) {\n            mContext = context;\n        }\n\n        public boolean hasFeature() {\n            return getPackageManager().hasSystemFeature(PackageManager.FEATURE_DEVICE_ADMIN);\n        }\n\n        Context createContextAsUser(UserHandle user) throws PackageManager.NameNotFoundException {\n            final String packageName = mContext.getPackageName();\n            return mContext.createPackageContextAsUser(packageName, 0, user);\n        }\n\n        Resources getResources() {\n            return mContext.getResources();\n        }\n\n        UserManager getUserManager() {\n            return UserManager.get(mContext);\n        }\n\n        UserManagerInternal getUserManagerInternal() {\n            return LocalServices.getService(UserManagerInternal.class);\n        }\n\n        PackageManagerInternal getPackageManagerInternal() {\n            return LocalServices.getService(PackageManagerInternal.class);\n        }\n\n        PackageManagerLocal getPackageManagerLocal() {\n            return LocalManagerRegistry.getManager(PackageManagerLocal.class);\n        }\n\n        ActivityTaskManagerInternal getActivityTaskManagerInternal() {\n            return LocalServices.getService(ActivityTaskManagerInternal.class);\n        }\n\n        @NonNull PermissionControllerManager getPermissionControllerManager(\n                @NonNull UserHandle user) {\n            if (user.equals(mContext.getUser())) {\n                return mContext.getSystemService(PermissionControllerManager.class);\n            } else {\n                try {\n                    return mContext.createPackageContextAsUser(mContext.getPackageName(), 0,\n                            user).getSystemService(PermissionControllerManager.class);\n                } catch (NameNotFoundException notPossible) {\n                    // not possible\n                    throw new IllegalStateException(notPossible);\n                }\n            }\n        }\n\n        UsageStatsManagerInternal getUsageStatsManagerInternal() {\n            return LocalServices.getService(UsageStatsManagerInternal.class);\n        }\n\n        NetworkPolicyManagerInternal getNetworkPolicyManagerInternal() {\n            return LocalServices.getService(NetworkPolicyManagerInternal.class);\n        }\n\n        NotificationManager getNotificationManager() {\n            return mContext.getSystemService(NotificationManager.class);\n        }\n\n        IIpConnectivityMetrics getIIpConnectivityMetrics() {\n            return (IIpConnectivityMetrics) IIpConnectivityMetrics.Stub.asInterface(\n                ServiceManager.getService(IpConnectivityLog.SERVICE_NAME));\n        }\n\n        PackageManager getPackageManager() {\n            return mContext.getPackageManager();\n        }\n\n        PackageManager getPackageManager(int userId) {\n            try {\n                return createContextAsUser(UserHandle.of(userId)).getPackageManager();\n            } catch (NameNotFoundException e) {\n                throw new IllegalStateException(e);\n            }\n        }\n\n        PowerManagerInternal getPowerManagerInternal() {\n            return LocalServices.getService(PowerManagerInternal.class);\n        }\n\n        TelephonyManager getTelephonyManager() {\n            return mContext.getSystemService(TelephonyManager.class);\n        }\n\n        RoleManager getRoleManager() {\n            return mContext.getSystemService(RoleManager.class);\n        }\n\n        TrustManager getTrustManager() {\n            return (TrustManager) mContext.getSystemService(Context.TRUST_SERVICE);\n        }\n\n        AlarmManager getAlarmManager() {\n            return mContext.getSystemService(AlarmManager.class);\n        }\n\n        AlarmManagerInternal getAlarmManagerInternal() {\n            return LocalServices.getService(AlarmManagerInternal.class);\n        }\n\n        ConnectivityManager getConnectivityManager() {\n            return mContext.getSystemService(ConnectivityManager.class);\n        }\n\n        VpnManager getVpnManager() {\n            return mContext.getSystemService(VpnManager.class);\n        }\n\n        LocationManager getLocationManager() {\n            return mContext.getSystemService(LocationManager.class);\n        }\n\n        IWindowManager getIWindowManager() {\n            return IWindowManager.Stub\n                    .asInterface(ServiceManager.getService(Context.WINDOW_SERVICE));\n        }\n\n        IActivityManager getIActivityManager() {\n            return ActivityManager.getService();\n        }\n\n        IActivityTaskManager getIActivityTaskManager() {\n            return ActivityTaskManager.getService();\n        }\n\n        ActivityManagerInternal getActivityManagerInternal() {\n            return LocalServices.getService(ActivityManagerInternal.class);\n        }\n\n        IPackageManager getIPackageManager() {\n            return AppGlobals.getPackageManager();\n        }\n\n        IPermissionManager getIPermissionManager() {\n            return AppGlobals.getPermissionManager();\n        }\n\n        IBackupManager getIBackupManager() {\n            return IBackupManager.Stub.asInterface(\n                    ServiceManager.getService(Context.BACKUP_SERVICE));\n        }\n\n        IAudioService getIAudioService() {\n            return IAudioService.Stub.asInterface(ServiceManager.getService(Context.AUDIO_SERVICE));\n        }\n\n        PersistentDataBlockManagerInternal getPersistentDataBlockManagerInternal() {\n            return LocalServices.getService(PersistentDataBlockManagerInternal.class);\n        }\n\n        AppOpsManager getAppOpsManager() {\n            return mContext.getSystemService(AppOpsManager.class);\n        }\n\n        LockSettingsInternal getLockSettingsInternal() {\n            return LocalServices.getService(LockSettingsInternal.class);\n        }\n\n        CrossProfileApps getCrossProfileApps(@UserIdInt int userId) {\n            return mContext.createContextAsUser(UserHandle.of(userId), /* flags= */ 0)\n                    .getSystemService(CrossProfileApps.class);\n        }\n\n        boolean hasUserSetupCompleted(DevicePolicyData userData) {\n            return userData.mUserSetupComplete;\n        }\n\n        boolean isBuildDebuggable() {\n            return Build.IS_DEBUGGABLE;\n        }\n\n        LockPatternUtils newLockPatternUtils() {\n            return new LockPatternUtils(mContext);\n        }\n\n        EnterpriseSpecificIdCalculator newEnterpriseSpecificIdCalculator() {\n            return new EnterpriseSpecificIdCalculator(mContext);\n        }\n\n        boolean storageManagerIsFileBasedEncryptionEnabled() {\n            return StorageManager.isFileEncrypted();\n        }\n\n        Looper getMyLooper() {\n            return Looper.myLooper();\n        }\n\n        WifiManager getWifiManager() {\n            return mContext.getSystemService(WifiManager.class);\n        }\n\n        UsbManager getUsbManager() {\n            return mContext.getSystemService(UsbManager.class);\n        }\n\n        @SuppressWarnings(\"ResultOfClearIdentityCallNotStoredInVariable\")\n        long binderClearCallingIdentity() {\n            return Binder.clearCallingIdentity();\n        }\n\n        void binderRestoreCallingIdentity(long token) {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        int binderGetCallingUid() {\n            return Binder.getCallingUid();\n        }\n\n        int binderGetCallingPid() {\n            return Binder.getCallingPid();\n        }\n\n        UserHandle binderGetCallingUserHandle() {\n            return Binder.getCallingUserHandle();\n        }\n\n        boolean binderIsCallingUidMyUid() {\n            return getCallingUid() == Process.myUid();\n        }\n\n        void binderWithCleanCallingIdentity(@NonNull ThrowingRunnable action) {\n             Binder.withCleanCallingIdentity(action);\n        }\n\n        final <T> T binderWithCleanCallingIdentity(@NonNull ThrowingSupplier<T> action) {\n            return Binder.withCleanCallingIdentity(action);\n        }\n\n        final int userHandleGetCallingUserId() {\n            return UserHandle.getUserId(binderGetCallingUid());\n        }\n\n        void powerManagerGoToSleep(long time, int reason, int flags) {\n            mContext.getSystemService(PowerManager.class).goToSleep(time, reason, flags);\n        }\n\n        void powerManagerReboot(String reason) {\n            mContext.getSystemService(PowerManager.class).reboot(reason);\n        }\n\n        boolean recoverySystemRebootWipeUserData(boolean shutdown, String reason, boolean force,\n                boolean wipeEuicc, boolean wipeExtRequested, boolean wipeResetProtectionData)\n                        throws IOException {\n            return FactoryResetter.newBuilder(mContext).setSafetyChecker(mSafetyChecker)\n                    .setReason(reason).setShutdown(shutdown).setForce(force).setWipeEuicc(wipeEuicc)\n                    .setWipeAdoptableStorage(wipeExtRequested)\n                    .setWipeFactoryResetProtection(wipeResetProtectionData)\n                    .build().factoryReset();\n        }\n\n        boolean systemPropertiesGetBoolean(String key, boolean def) {\n            return SystemProperties.getBoolean(key, def);\n        }\n\n        long systemPropertiesGetLong(String key, long def) {\n            return SystemProperties.getLong(key, def);\n        }\n\n        String systemPropertiesGet(String key, String def) {\n            return SystemProperties.get(key, def);\n        }\n\n        String systemPropertiesGet(String key) {\n            return SystemProperties.get(key);\n        }\n\n        void systemPropertiesSet(String key, String value) {\n            SystemProperties.set(key, value);\n        }\n\n        boolean userManagerIsHeadlessSystemUserMode() {\n            return UserManager.isHeadlessSystemUserMode();\n        }\n\n        @SuppressWarnings(\"AndroidFrameworkPendingIntentMutability\")\n        PendingIntent pendingIntentGetActivityAsUser(Context context, int requestCode,\n                @NonNull Intent intent, int flags, Bundle options, UserHandle user) {\n            return PendingIntent.getActivityAsUser(\n                    context, requestCode, intent, flags, options, user);\n        }\n\n        @SuppressWarnings(\"AndroidFrameworkPendingIntentMutability\")\n        PendingIntent pendingIntentGetBroadcast(\n                Context context, int requestCode, Intent intent, int flags) {\n            return PendingIntent.getBroadcast(context, requestCode, intent, flags);\n        }\n\n        void registerContentObserver(Uri uri, boolean notifyForDescendents,\n                ContentObserver observer, int userHandle) {\n            mContext.getContentResolver().registerContentObserver(uri, notifyForDescendents,\n                    observer, userHandle);\n        }\n\n        int settingsSecureGetIntForUser(String name, int def, int userHandle) {\n            return Settings.Secure.getIntForUser(mContext.getContentResolver(),\n                    name, def, userHandle);\n        }\n\n        String settingsSecureGetStringForUser(String name, int userHandle) {\n            return Settings.Secure.getStringForUser(mContext.getContentResolver(), name,\n                    userHandle);\n        }\n\n        void settingsSecurePutIntForUser(String name, int value, int userHandle) {\n            Settings.Secure.putIntForUser(mContext.getContentResolver(),\n                    name, value, userHandle);\n        }\n\n        void settingsSecurePutStringForUser(String name, String value, int userHandle) {\n            Settings.Secure.putStringForUser(mContext.getContentResolver(),\n                    name, value, userHandle);\n        }\n\n        void settingsGlobalPutStringForUser(String name, String value, int userHandle) {\n            Settings.Global.putStringForUser(mContext.getContentResolver(),\n                    name, value, userHandle);\n        }\n\n        void settingsSecurePutInt(String name, int value) {\n            Settings.Secure.putInt(mContext.getContentResolver(), name, value);\n        }\n\n        int settingsGlobalGetInt(String name, int def) {\n            return Settings.Global.getInt(mContext.getContentResolver(), name, def);\n        }\n\n        @Nullable\n        String settingsGlobalGetString(String name) {\n            return Settings.Global.getString(mContext.getContentResolver(), name);\n        }\n\n        void settingsGlobalPutInt(String name, int value) {\n            Settings.Global.putInt(mContext.getContentResolver(), name, value);\n        }\n\n        void settingsSecurePutString(String name, String value) {\n            Settings.Secure.putString(mContext.getContentResolver(), name, value);\n        }\n\n        void settingsGlobalPutString(String name, String value) {\n            Settings.Global.putString(mContext.getContentResolver(), name, value);\n        }\n\n        void settingsSystemPutStringForUser(String name, String value, int userId) {\n          Settings.System.putStringForUser(\n              mContext.getContentResolver(), name, value, userId);\n        }\n\n        void securityLogSetLoggingEnabledProperty(boolean enabled) {\n            SecurityLog.setLoggingEnabledProperty(enabled);\n        }\n\n        boolean securityLogGetLoggingEnabledProperty() {\n            return SecurityLog.getLoggingEnabledProperty();\n        }\n\n        boolean securityLogIsLoggingEnabled() {\n            return SecurityLog.isLoggingEnabled();\n        }\n\n        KeyChainConnection keyChainBind() throws InterruptedException {\n            return KeyChain.bind(mContext);\n        }\n\n        KeyChainConnection keyChainBindAsUser(UserHandle user) throws InterruptedException {\n            return KeyChain.bindAsUser(mContext, user);\n        }\n\n        void postOnSystemServerInitThreadPool(Runnable runnable) {\n            SystemServerInitThreadPool.submit(runnable, LOG_TAG);\n        }\n\n        public TransferOwnershipMetadataManager newTransferOwnershipMetadataManager() {\n            return new TransferOwnershipMetadataManager();\n        }\n\n        public void runCryptoSelfTest() {\n            CryptoTestHelper.runAndLogSelfTest();\n        }\n\n        public String[] getPersonalAppsForSuspension(@UserIdInt int userId) {\n            return PersonalAppsSuspensionHelper.forUser(mContext, userId)\n                    .getPersonalAppsForSuspension();\n        }\n\n        public long systemCurrentTimeMillis() {\n            return System.currentTimeMillis();\n        }\n\n        public boolean isChangeEnabled(long changeId, String packageName, int userId) {\n            return CompatChanges.isChangeEnabled(changeId, packageName, UserHandle.of(userId));\n        }\n\n        void setDevicePolicySafetyChecker(DevicePolicySafetyChecker safetyChecker) {\n            mSafetyChecker = safetyChecker;\n        }\n\n        DeviceManagementResourcesProvider getDeviceManagementResourcesProvider() {\n            return new DeviceManagementResourcesProvider();\n        }\n    }\n\n    /**\n     * Instantiates the service.\n     */\n    public DevicePolicyManagerService(Context context) {\n        this(new Injector(\n                context.createAttributionContext(ATTRIBUTION_TAG)), new PolicyPathProvider() {});\n    }\n\n    @VisibleForTesting\n    DevicePolicyManagerService(Injector injector, PolicyPathProvider pathProvider) {\n        DevicePolicyManager.disableLocalCaches();\n\n        mInjector = injector;\n        mPathProvider = pathProvider;\n        mContext = Objects.requireNonNull(injector.mContext);\n        mHandler = new Handler(Objects.requireNonNull(injector.getMyLooper()));\n\n        mConstantsObserver = new DevicePolicyConstantsObserver(mHandler);\n        mConstantsObserver.register();\n        mConstants = loadConstants();\n\n        mUserManager = Objects.requireNonNull(injector.getUserManager());\n        mUserManagerInternal = Objects.requireNonNull(injector.getUserManagerInternal());\n        mUsageStatsManagerInternal = Objects.requireNonNull(\n                injector.getUsageStatsManagerInternal());\n        mIPackageManager = Objects.requireNonNull(injector.getIPackageManager());\n        mIPermissionManager = Objects.requireNonNull(injector.getIPermissionManager());\n        mTelephonyManager = Objects.requireNonNull(injector.getTelephonyManager());\n        mRoleManager = Objects.requireNonNull(injector.getRoleManager());\n\n        mLocalService = new LocalService();\n        mLockPatternUtils = injector.newLockPatternUtils();\n        mLockSettingsInternal = injector.getLockSettingsInternal();\n        // TODO: why does SecurityLogMonitor need to be created even when mHasFeature == false?\n        mSecurityLogMonitor = new SecurityLogMonitor(this);\n\n        mHasFeature = mInjector.hasFeature();\n        mIsWatch = mInjector.getPackageManager()\n                .hasSystemFeature(PackageManager.FEATURE_WATCH);\n        mHasTelephonyFeature = mInjector.getPackageManager()\n                .hasSystemFeature(PackageManager.FEATURE_TELEPHONY);\n        mIsAutomotive = mInjector.getPackageManager()\n                .hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);\n        mBackgroundHandler = BackgroundThread.getHandler();\n\n        // Needed when mHasFeature == false, because it controls the certificate warning text.\n        mCertificateMonitor = new CertificateMonitor(this, mInjector, mBackgroundHandler);\n\n        mDeviceAdminServiceController = new DeviceAdminServiceController(this, mConstants);\n        mOverlayPackagesProvider = new OverlayPackagesProvider(mContext);\n        mTransferOwnershipMetadataManager = mInjector.newTransferOwnershipMetadataManager();\n        mBugreportCollectionManager = new RemoteBugreportManager(this, mInjector);\n\n        mDeviceManagementResourcesProvider = mInjector.getDeviceManagementResourcesProvider();\n        mDevicePolicyManagementRoleObserver = new DevicePolicyManagementRoleObserver(mContext);\n        mDevicePolicyManagementRoleObserver.register();\n\n        // \"Lite\" interface is available even when the device doesn't have the feature\n        LocalServices.addService(DevicePolicyManagerLiteInternal.class, mLocalService);\n\n        // Policy version upgrade must not depend on either mOwners or mUserData, so they are\n        // initialized only after performing the upgrade.\n        if (mHasFeature) {\n            performPolicyVersionUpgrade();\n        }\n\n        mUserData = new SparseArray<>();\n        mOwners = makeOwners(injector, pathProvider);\n\n        mDevicePolicyEngine = new DevicePolicyEngine(\n                mContext, mDeviceAdminServiceController, getLockObject());\n\n        if (!mHasFeature) {\n            // Skip the rest of the initialization\n            mSetupContentObserver = null;\n            mContactSystemRoleHolders = Collections.emptySet();\n            return;\n        }\n\n        loadOwners();\n\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(Intent.ACTION_BOOT_COMPLETED);\n        filter.addAction(ACTION_EXPIRED_PASSWORD_NOTIFICATION);\n        filter.addAction(ACTION_TURN_PROFILE_ON_NOTIFICATION);\n        filter.addAction(ACTION_PROFILE_OFF_DEADLINE);\n        filter.addAction(Intent.ACTION_USER_ADDED);\n        filter.addAction(Intent.ACTION_USER_REMOVED);\n        filter.addAction(Intent.ACTION_USER_STARTED);\n        filter.addAction(Intent.ACTION_USER_STOPPED);\n        filter.addAction(Intent.ACTION_USER_SWITCHED);\n        filter.addAction(Intent.ACTION_USER_UNLOCKED);\n        filter.addAction(LOGIN_ACCOUNTS_CHANGED_ACTION);\n        filter.addAction(ACTION_MANAGED_PROFILE_UNAVAILABLE);\n        filter.addAction(ACTION_MANAGED_PROFILE_AVAILABLE);\n        filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);\n        mContext.registerReceiverAsUser(mReceiver, UserHandle.ALL, filter, null, mHandler);\n        filter = new IntentFilter();\n        filter.addAction(Intent.ACTION_PACKAGE_CHANGED);\n        filter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        filter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);\n        filter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        filter.addDataScheme(\"package\");\n        mContext.registerReceiverAsUser(mReceiver, UserHandle.ALL, filter, null, mHandler);\n        filter = new IntentFilter();\n        filter.addAction(Intent.ACTION_MANAGED_PROFILE_ADDED);\n        filter.addAction(Intent.ACTION_TIME_CHANGED);\n        filter.addAction(Intent.ACTION_DATE_CHANGED);\n        mContext.registerReceiverAsUser(mReceiver, UserHandle.ALL, filter, null, mHandler);\n\n        LocalServices.addService(DevicePolicyManagerInternal.class, mLocalService);\n\n        mSetupContentObserver = new SetupContentObserver(mHandler);\n\n        mUserManagerInternal.addUserRestrictionsListener(\n                new RestrictionsListener(mContext, mUserManagerInternal, this));\n        mUserManagerInternal.addUserLifecycleListener(new UserLifecycleListener());\n\n        mDeviceManagementResourcesProvider.load();\n        if (isPermissionCheckFlagEnabled() || isPolicyEngineForFinanceFlagEnabled()) {\n            mDevicePolicyEngine.load();\n        }\n\n        mContactSystemRoleHolders = fetchOemSystemHolders(/* roleResIds...= */\n                com.android.internal.R.string.config_defaultSms,\n                com.android.internal.R.string.config_defaultDialer,\n                com.android.internal.R.string.config_systemContacts\n        );\n\n        // The binder caches are not enabled until the first invalidation.\n        invalidateBinderCaches();\n    }\n\n    /**\n     * Fetch the OEM System Holders for the supplied roleNames\n     *\n     * @param roleResIds the list of resource ids whose role holders are needed\n     * @return the set of packageNames that handle the requested roles\n     */\n    private @NonNull Set<String> fetchOemSystemHolders(int... roleResIds) {\n        Set<String> packageNames = new ArraySet<>();\n\n        for (int roleResId : roleResIds) {\n            String packageName = getDefaultRoleHolderPackageName(roleResId);\n            if (packageName != null) {\n                packageNames.add(packageName);\n            }\n        }\n\n        return Collections.unmodifiableSet(packageNames);\n    }\n\n\n    private @Nullable String getDefaultRoleHolderPackageName(int resId) {\n        String packageNameAndSignature = mContext.getString(resId);\n\n        if (TextUtils.isEmpty(packageNameAndSignature)) {\n            return null;\n        }\n\n        if (packageNameAndSignature.contains(\":\")) {\n            return packageNameAndSignature.split(\":\")[0];\n        }\n\n        return packageNameAndSignature;\n    }\n\n    private void suspendAppsForQuietProfiles(boolean toSuspend) {\n        PackageManagerInternal pmi = mInjector.getPackageManagerInternal();\n        List<UserInfo> users = mUserManagerInternal.getUsers(true /* excludeDying */);\n        for (UserInfo user : users) {\n            if (user.isManagedProfile() && user.isQuietModeEnabled()) {\n                pmi.setPackagesSuspendedForQuietMode(user.id, toSuspend);\n            }\n        }\n    }\n\n    private Owners makeOwners(Injector injector, PolicyPathProvider pathProvider) {\n        return new Owners(\n                injector.getUserManager(), injector.getUserManagerInternal(),\n                injector.getPackageManagerInternal(),\n                injector.getActivityTaskManagerInternal(),\n                injector.getActivityManagerInternal(), mStateCache, pathProvider);\n    }\n\n    /**\n     * Invalidate the binder API caches. The invalidation itself does not require any\n     * locking, but this specific call should be protected by getLockObject() to ensure\n     * that the invalidation is synchronous with cached queries, for those queries that\n     * are served under getLockObject().\n     */\n    static void invalidateBinderCaches() {\n        DevicePolicyManager.invalidateBinderCaches();\n    }\n\n    /**\n     * Creates and loads the policy data from xml.\n     * @param userHandle the user for whom to load the policy data\n     * @return\n     */\n    @NonNull\n    DevicePolicyData getUserData(int userHandle) {\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = mUserData.get(userHandle);\n            if (policy == null) {\n                policy = new DevicePolicyData(userHandle);\n                mUserData.append(userHandle, policy);\n                loadSettingsLocked(policy, userHandle);\n                if (userHandle == UserHandle.USER_SYSTEM) {\n                    mStateCache.setDeviceProvisioned(policy.mUserSetupComplete);\n                }\n            }\n            return policy;\n        }\n    }\n\n    /**\n     * Creates and loads the policy data from xml for data that is shared between\n     * various profiles of a user. In contrast to {@link #getUserData(int)}\n     * it allows access to data of users other than the calling user.\n     *\n     * This function should only be used for shared data, e.g. everything regarding\n     * passwords and should be removed once multiple screen locks are present.\n     * @param userHandle the user for whom to load the policy data\n     * @return\n     */\n    DevicePolicyData getUserDataUnchecked(int userHandle) {\n        return mInjector.binderWithCleanCallingIdentity(() -> getUserData(userHandle));\n    }\n\n    void removeUserData(int userHandle) {\n        final boolean isOrgOwned;\n        synchronized (getLockObject()) {\n            if (userHandle == UserHandle.USER_SYSTEM) {\n                Slogf.w(LOG_TAG, \"Tried to remove device policy file for user 0! Ignoring.\");\n                return;\n            }\n            updatePasswordQualityCacheForUserGroup(userHandle);\n            mPolicyCache.onUserRemoved(userHandle);\n\n            if (isManagedProfile(userHandle)) {\n                clearManagedProfileApnUnchecked();\n            }\n            isOrgOwned = mOwners.isProfileOwnerOfOrganizationOwnedDevice(userHandle);\n\n            // Clear any restrictions set by the a profile owner and the parent admin.\n            final ActiveAdmin admin = getProfileOwnerLocked(userHandle);\n            if (admin != null) {\n                admin.userRestrictions = null;\n                final ActiveAdmin parentAdmin = admin.getParentActiveAdmin();\n                if (parentAdmin != null) {\n                    parentAdmin.userRestrictions = null;\n                }\n                pushUserRestrictions(userHandle);\n            }\n            mOwners.removeProfileOwner(userHandle);\n            mOwners.writeProfileOwner(userHandle);\n            pushScreenCapturePolicy(userHandle);\n\n            DevicePolicyData policy = mUserData.get(userHandle);\n            if (policy != null) {\n                mUserData.remove(userHandle);\n            }\n\n            File policyFile =\n                    new File(mPathProvider.getUserSystemDirectory(userHandle), DEVICE_POLICIES_XML);\n            policyFile.delete();\n            Slogf.i(LOG_TAG, \"Removed device policy file \" + policyFile.getAbsolutePath());\n        }\n        if (isOrgOwned) {\n            final UserInfo primaryUser = mUserManager.getPrimaryUser();\n            if (primaryUser != null) {\n                clearOrgOwnedProfileOwnerDeviceWidePolicies(primaryUser.id);\n            } else {\n                Slogf.wtf(LOG_TAG, \"Was unable to get primary user.\");\n            }\n        }\n    }\n\n    /**\n     * Load information about device and profile owners of the device, populating mOwners and\n     * pushing owner info to other system services. This is called at a fairly early stage of\n     * system server initialiation (via DevicePolicyManagerService's ctor), so care should to\n     * be taken to not interact with system services that are initialiated after DPMS.\n     * onLockSettingsReady() is a safer place to do initialization work not critical during\n     * the first boot stage.\n     * Note this only loads the list of owners, and not their actual policy (DevicePolicyData).\n     * The policy is normally loaded lazily when it's first accessed. In several occasions\n     * the list of owners is necessary for providing callers with aggregated policies across\n     * multiple owners, hence the owner list is loaded as part of DPMS's construction here.\n     */\n    void loadOwners() {\n        synchronized (getLockObject()) {\n            mOwners.load();\n            setDeviceOwnershipSystemPropertyLocked();\n            if (mOwners.hasDeviceOwner()) {\n                setGlobalSettingDeviceOwnerType(\n                        mOwners.getDeviceOwnerType(mOwners.getDeviceOwnerPackageName()));\n            }\n        }\n    }\n\n    /**\n     * Creates a new {@link CallerIdentity} object to represent the caller's identity.\n     */\n    private CallerIdentity getCallerIdentity() {\n        return getCallerIdentity(null, null);\n    }\n\n    /**\n     * Creates a new {@link CallerIdentity} object to represent the caller's identity.\n     */\n    private CallerIdentity getCallerIdentity(@Nullable String callerPackage) {\n        return getCallerIdentity(null, callerPackage);\n    }\n\n    /**\n     * Creates a new {@link CallerIdentity} object to represent the caller's identity.\n     * The component name should be an active admin for the calling user.\n     */\n    @VisibleForTesting\n    CallerIdentity getCallerIdentity(@Nullable ComponentName adminComponent) {\n        return getCallerIdentity(adminComponent, null);\n    }\n\n    /**\n     * Creates a new {@link CallerIdentity} object to represent the caller's identity.\n     * If {@code adminComponent} is provided, it's validated against the list of known\n     * active admins and caller uid. If {@code callerPackage} is provided, it's validated\n     * against the caller uid. If a valid {@code adminComponent} is provided but not\n     * {@code callerPackage}, the package name of the {@code adminComponent} is used instead.\n     */\n    @VisibleForTesting\n    CallerIdentity getCallerIdentity(@Nullable ComponentName adminComponent,\n            @Nullable String callerPackage) {\n        final int callerUid = mInjector.binderGetCallingUid();\n\n        if (callerPackage != null) {\n            if (!isCallingFromPackage(callerPackage, callerUid)) {\n                throw new SecurityException(\n                        String.format(\"Caller with uid %d is not %s\", callerUid, callerPackage));\n            }\n        }\n\n        if (adminComponent != null) {\n            final DevicePolicyData policy = getUserData(UserHandle.getUserId(callerUid));\n            ActiveAdmin admin = policy.mAdminMap.get(adminComponent);\n\n            // Throwing combined exception message for both the cases here, because from different\n            // security exceptions it could be deduced if particular package is admin package.\n            if (admin == null || admin.getUid() != callerUid) {\n                throw new SecurityException(String.format(\n                        \"Admin %s does not exist or is not owned by uid %d\", adminComponent,\n                        callerUid));\n            }\n            if (callerPackage != null) {\n                Preconditions.checkArgument(callerPackage.equals(adminComponent.getPackageName()));\n            } else {\n                callerPackage = adminComponent.getPackageName();\n            }\n        }\n\n        return new CallerIdentity(callerUid, callerPackage, adminComponent);\n    }\n\n    /**\n     * Checks if the device is in COMP mode, and if so migrates it to managed profile on a\n     * corporate owned device.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void migrateToProfileOnOrganizationOwnedDeviceIfCompLocked() {\n        if (VERBOSE_LOG) Slogf.d(LOG_TAG, \"Checking whether we need to migrate COMP \");\n        final int doUserId = mOwners.getDeviceOwnerUserId();\n        if (doUserId == UserHandle.USER_NULL) {\n            if (VERBOSE_LOG) Slogf.d(LOG_TAG, \"No DO found, skipping migration.\");\n            return;\n        }\n\n        final List<UserInfo> profiles = mUserManager.getProfiles(doUserId);\n        if (profiles.size() != 2) {\n            if (profiles.size() == 1) {\n                if (VERBOSE_LOG) Slogf.d(LOG_TAG, \"Profile not found, skipping migration.\");\n            } else {\n                Slogf.wtf(LOG_TAG, \"Found \" + profiles.size() + \" profiles, skipping migration\");\n            }\n            return;\n        }\n\n        final int poUserId = getManagedUserId(doUserId);\n        if (poUserId < 0) {\n            Slogf.wtf(LOG_TAG, \"Found DO and a profile, but it is not managed, skipping migration\");\n            return;\n        }\n\n        final ActiveAdmin doAdmin = getDeviceOwnerAdminLocked();\n        final ActiveAdmin poAdmin = getProfileOwnerAdminLocked(poUserId);\n        if (doAdmin == null || poAdmin == null) {\n            Slogf.wtf(LOG_TAG, \"Failed to get either PO or DO admin, aborting migration.\");\n            return;\n        }\n\n        final ComponentName doAdminComponent = mOwners.getDeviceOwnerComponent();\n        final ComponentName poAdminComponent = mOwners.getProfileOwnerComponent(poUserId);\n        if (doAdminComponent == null || poAdminComponent == null) {\n            Slogf.wtf(LOG_TAG, \"Cannot find PO or DO component name, aborting migration.\");\n            return;\n        }\n        if (!doAdminComponent.getPackageName().equals(poAdminComponent.getPackageName())) {\n            Slogf.e(LOG_TAG, \"DO and PO are different packages, aborting migration.\");\n            return;\n        }\n\n        Slogf.i(LOG_TAG, \"Migrating COMP to PO on a corp owned device; primary user: %d; \"\n                + \"profile: %d\", doUserId, poUserId);\n\n        Slogf.i(LOG_TAG, \"Giving the PO additional power...\");\n        setProfileOwnerOnOrganizationOwnedDeviceUncheckedLocked(poAdminComponent, poUserId, true);\n        Slogf.i(LOG_TAG, \"Migrating DO policies to PO...\");\n        moveDoPoliciesToProfileParentAdminLocked(doAdmin, poAdmin.getParentActiveAdmin());\n        migratePersonalAppSuspensionLocked(doUserId, poUserId, poAdmin);\n        saveSettingsLocked(poUserId);\n        Slogf.i(LOG_TAG, \"Clearing the DO...\");\n        final ComponentName doAdminReceiver = doAdmin.info.getComponent();\n        clearDeviceOwnerLocked(doAdmin, doUserId);\n        Slogf.i(LOG_TAG, \"Removing admin artifacts...\");\n        removeAdminArtifacts(doAdminReceiver, doUserId);\n        Slogf.i(LOG_TAG, \"Uninstalling the DO...\");\n        uninstallOrDisablePackage(doAdminComponent.getPackageName(), doUserId);\n        Slogf.i(LOG_TAG, \"Migration complete.\");\n\n        // Note: KeyChain keys are not removed and will remain accessible for the apps that have\n        // been given grants to use them.\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.COMP_TO_ORG_OWNED_PO_MIGRATED)\n                .setAdmin(poAdminComponent)\n                .write();\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void migratePersonalAppSuspensionLocked(\n            int doUserId, int poUserId, ActiveAdmin poAdmin) {\n        final PackageManagerInternal pmi = mInjector.getPackageManagerInternal();\n        if (!pmi.isSuspendingAnyPackages(PLATFORM_PACKAGE_NAME, doUserId)) {\n            Slogf.i(LOG_TAG, \"DO is not suspending any apps.\");\n            return;\n        }\n\n        if (getTargetSdk(poAdmin.info.getPackageName(), poUserId) >= Build.VERSION_CODES.R) {\n            Slogf.i(LOG_TAG, \"PO is targeting R+, keeping personal apps suspended.\");\n            getUserData(doUserId).mAppsSuspended = true;\n            poAdmin.mSuspendPersonalApps = true;\n        } else {\n            Slogf.i(LOG_TAG, \"PO isn't targeting R+, unsuspending personal apps.\");\n            pmi.unsuspendForSuspendingPackage(PLATFORM_PACKAGE_NAME, doUserId);\n        }\n    }\n\n    private void uninstallOrDisablePackage(String packageName, @UserIdInt int userId) {\n        final ApplicationInfo appInfo;\n        try {\n            appInfo = mIPackageManager.getApplicationInfo(\n                    packageName, MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE, userId);\n        } catch (RemoteException e) {\n            // Shouldn't happen.\n            Slogf.wtf(LOG_TAG, \"Error getting application info\", e);\n            return;\n        }\n        if (appInfo == null) {\n            Slogf.wtf(LOG_TAG, \"Failed to get package info for \" + packageName);\n            return;\n        }\n        if ((appInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {\n            Slogf.i(LOG_TAG, \"Package %s is pre-installed, marking disabled until used\",\n                    packageName);\n            mContext.getPackageManager().setApplicationEnabledSetting(packageName,\n                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED, /* flags= */ 0);\n            return;\n        }\n\n        final IIntentSender.Stub mLocalSender = new IIntentSender.Stub() {\n            @Override\n            public void send(int code, Intent intent, String resolvedType, IBinder allowlistToken,\n                    IIntentReceiver finishedReceiver, String requiredPermission, Bundle options) {\n                final int status = intent.getIntExtra(\n                        PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE);\n                if (status == PackageInstaller.STATUS_SUCCESS) {\n                    Slogf.i(LOG_TAG, \"Package %s uninstalled for user %d\", packageName, userId);\n                } else {\n                    Slogf.e(LOG_TAG, \"Failed to uninstall %s; status: %d\", packageName, status);\n                }\n            }\n        };\n\n        final PackageInstaller pi = mInjector.getPackageManager(userId).getPackageInstaller();\n        pi.uninstall(packageName, /* flags= */ 0, new IntentSender((IIntentSender) mLocalSender));\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void moveDoPoliciesToProfileParentAdminLocked(\n            ActiveAdmin doAdmin, ActiveAdmin parentAdmin) {\n        // The following policies can be already controlled via parent instance, skip if so.\n        if (parentAdmin.mPasswordPolicy.quality == PASSWORD_QUALITY_UNSPECIFIED) {\n            parentAdmin.mPasswordPolicy = doAdmin.mPasswordPolicy;\n        }\n        if (parentAdmin.passwordHistoryLength == ActiveAdmin.DEF_PASSWORD_HISTORY_LENGTH) {\n            parentAdmin.passwordHistoryLength = doAdmin.passwordHistoryLength;\n        }\n        if (parentAdmin.passwordExpirationTimeout == ActiveAdmin.DEF_PASSWORD_HISTORY_LENGTH) {\n            parentAdmin.passwordExpirationTimeout = doAdmin.passwordExpirationTimeout;\n        }\n        if (parentAdmin.maximumFailedPasswordsForWipe\n                == ActiveAdmin.DEF_MAXIMUM_FAILED_PASSWORDS_FOR_WIPE) {\n            parentAdmin.maximumFailedPasswordsForWipe = doAdmin.maximumFailedPasswordsForWipe;\n        }\n        if (parentAdmin.maximumTimeToUnlock == ActiveAdmin.DEF_MAXIMUM_TIME_TO_UNLOCK) {\n            parentAdmin.maximumTimeToUnlock = doAdmin.maximumTimeToUnlock;\n        }\n        if (parentAdmin.strongAuthUnlockTimeout\n                == DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS) {\n            parentAdmin.strongAuthUnlockTimeout = doAdmin.strongAuthUnlockTimeout;\n        }\n        parentAdmin.disabledKeyguardFeatures |=\n                doAdmin.disabledKeyguardFeatures & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\n\n        parentAdmin.trustAgentInfos.putAll(doAdmin.trustAgentInfos);\n\n        // The following policies weren't available to PO, but will be available after migration.\n        parentAdmin.disableCamera = doAdmin.disableCamera;\n        parentAdmin.disableScreenCapture = doAdmin.disableScreenCapture;\n        parentAdmin.accountTypesWithManagementDisabled.addAll(\n                doAdmin.accountTypesWithManagementDisabled);\n\n        moveDoUserRestrictionsToCopeParent(doAdmin, parentAdmin);\n\n        // From Android 11, {@link setAutoTimeRequired} is no longer used. The user restriction\n        // {@link UserManager#DISALLOW_CONFIG_DATE_TIME} should be used to enforce auto time\n        // settings instead.\n        if (doAdmin.requireAutoTime) {\n            parentAdmin.ensureUserRestrictions().putBoolean(\n                    UserManager.DISALLOW_CONFIG_DATE_TIME, true);\n        }\n    }\n\n    private void moveDoUserRestrictionsToCopeParent(ActiveAdmin doAdmin, ActiveAdmin parentAdmin) {\n        if (doAdmin.userRestrictions == null) {\n            return;\n        }\n        for (final String restriction : doAdmin.userRestrictions.keySet()) {\n            if (UserRestrictionsUtils.canProfileOwnerOfOrganizationOwnedDeviceChange(restriction)) {\n                parentAdmin.ensureUserRestrictions().putBoolean(\n                        restriction, doAdmin.userRestrictions.getBoolean(restriction));\n            }\n        }\n    }\n\n    /**\n     * If the device is in Device Owner mode, apply the restriction on adding\n     * a managed profile.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void applyProfileRestrictionsIfDeviceOwnerLocked() {\n        final int doUserId = mOwners.getDeviceOwnerUserId();\n        if (doUserId == UserHandle.USER_NULL) {\n            if (VERBOSE_LOG) Slogf.d(LOG_TAG, \"No DO found, skipping application of restriction.\");\n            return;\n        }\n\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            UserHandle userHandle = userInfo.getUserHandle();\n            // Based on  CDD : https://source.android.com/compatibility/12/android-12-cdd#95_multi-user_support,\n            // creation of clone profile is not allowed in case device owner is set.\n            // Enforcing this restriction on setting up of device owner.\n            if (!mUserManager.hasUserRestriction(\n                    UserManager.DISALLOW_ADD_CLONE_PROFILE, userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE, true,\n                        userHandle);\n            }\n            // Creation of managed profile is restricted in case device owner is set, enforcing this\n            // restriction by setting user level restriction at time of device owner setup.\n            if (!mUserManager.hasUserRestriction(\n                    UserManager.DISALLOW_ADD_MANAGED_PROFILE, userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE, true,\n                        userHandle);\n            }\n        }\n    }\n\n    /** Apply default restrictions that haven't been applied to profile owners yet. */\n    private void maybeSetDefaultProfileOwnerUserRestrictions() {\n        synchronized (getLockObject()) {\n            for (final int userId : mOwners.getProfileOwnerKeys()) {\n                final ActiveAdmin profileOwner = getProfileOwnerAdminLocked(userId);\n                // The following restrictions used to be applied to managed profiles by different\n                // means (via Settings or by disabling components). Now they are proper user\n                // restrictions so we apply them to managed profile owners. Non-managed secondary\n                // users didn't have those restrictions so we skip them to keep existing behavior.\n                if (profileOwner == null || !mUserManager.isManagedProfile(userId)) {\n                    continue;\n                }\n                maybeSetDefaultRestrictionsForAdminLocked(userId, profileOwner);\n                ensureUnknownSourcesRestrictionForProfileOwnerLocked(\n                        userId, profileOwner, false /* newOwner */);\n            }\n        }\n    }\n\n    /**\n     * Checks whether {@link UserManager#DISALLOW_INSTALL_UNKNOWN_SOURCES} should be added to the\n     * set of restrictions for this profile owner.\n     */\n    private void ensureUnknownSourcesRestrictionForProfileOwnerLocked(int userId,\n            ActiveAdmin profileOwner, boolean newOwner) {\n        if (newOwner || mInjector.settingsSecureGetIntForUser(\n                Settings.Secure.UNKNOWN_SOURCES_DEFAULT_REVERSED, 0, userId) != 0) {\n            if (isPolicyEngineForFinanceFlagEnabled()) {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.getPolicyDefinitionForUserRestriction(\n                                UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES),\n                        EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                                profileOwner.info.getComponent(),\n                                profileOwner.getUserHandle().getIdentifier()),\n                        new BooleanPolicyValue(true),\n                        userId);\n            } else {\n                profileOwner.ensureUserRestrictions().putBoolean(\n                        UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES, true);\n                saveUserRestrictionsLocked(userId);\n            }\n            mInjector.settingsSecurePutIntForUser(\n                    Settings.Secure.UNKNOWN_SOURCES_DEFAULT_REVERSED, 0, userId);\n        }\n    }\n\n    /**\n     * Apply default restrictions that haven't been applied to a given admin yet.\n     */\n    private void maybeSetDefaultRestrictionsForAdminLocked(int userId, ActiveAdmin admin) {\n        Set<String> defaultRestrictions =\n                UserRestrictionsUtils.getDefaultEnabledForManagedProfiles();\n        if (defaultRestrictions.equals(admin.defaultEnabledRestrictionsAlreadySet)) {\n            return; // The same set of default restrictions has been already applied.\n        }\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            for (String restriction : defaultRestrictions) {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction),\n                        EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                                admin.info.getComponent(),\n                                admin.getUserHandle().getIdentifier()),\n                        new BooleanPolicyValue(true),\n                        userId);\n            }\n            admin.defaultEnabledRestrictionsAlreadySet.addAll(defaultRestrictions);\n            Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" +\n                    defaultRestrictions);\n            return;\n        }\n\n        Slogf.i(LOG_TAG, \"New user restrictions need to be set by default for user \" + userId);\n\n        if (VERBOSE_LOG) {\n            Slogf.d(LOG_TAG, \"Default enabled restrictions: \"\n                    + defaultRestrictions\n                    + \". Restrictions already enabled: \"\n                    + admin.defaultEnabledRestrictionsAlreadySet);\n        }\n\n        final Set<String> restrictionsToSet = new ArraySet<>(defaultRestrictions);\n        restrictionsToSet.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n        if (!restrictionsToSet.isEmpty()) {\n            for (final String restriction : restrictionsToSet) {\n                admin.ensureUserRestrictions().putBoolean(restriction, true);\n            }\n            admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n            Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" + restrictionsToSet);\n            saveUserRestrictionsLocked(userId);\n        }\n    }\n\n    private void setDeviceOwnershipSystemPropertyLocked() {\n        final boolean deviceProvisioned =\n                mInjector.settingsGlobalGetInt(Settings.Global.DEVICE_PROVISIONED, 0) != 0;\n        final boolean hasDeviceOwner = mOwners.hasDeviceOwner();\n        final boolean hasOrgOwnedProfile = isOrganizationOwnedDeviceWithManagedProfile();\n        // If the device is not provisioned and there is currently no management, do not set the\n        // read-only system property yet, since device owner / org-owned profile may still be\n        // provisioned.\n        if (!hasDeviceOwner && !hasOrgOwnedProfile && !deviceProvisioned) {\n            return;\n        }\n        final String value = Boolean.toString(hasDeviceOwner || hasOrgOwnedProfile);\n        final String currentVal = mInjector.systemPropertiesGet(PROPERTY_ORGANIZATION_OWNED, null);\n        if (TextUtils.isEmpty(currentVal)) {\n            Slogf.i(LOG_TAG, \"Set ro.organization_owned property to \" + value);\n            mInjector.systemPropertiesSet(PROPERTY_ORGANIZATION_OWNED, value);\n        } else if (!value.equals(currentVal)) {\n            Slogf.w(LOG_TAG, \"Cannot change existing ro.organization_owned to \" + value);\n        }\n    }\n\n    private void maybeStartSecurityLogMonitorOnActivityManagerReady() {\n        synchronized (getLockObject()) {\n            if (mInjector.securityLogIsLoggingEnabled()) {\n                mSecurityLogMonitor.start(getSecurityLoggingEnabledUser());\n                mInjector.runCryptoSelfTest();\n                maybePauseDeviceWideLoggingLocked();\n            }\n        }\n    }\n\n    /**\n     * Fix left-over restrictions and auto-time policy during COMP -> COPE migration.\n     *\n     * When a COMP device with requireAutoTime policy set was migrated to an\n     * organization-owned profile, a DISALLOW_CONFIG_DATE_TIME restriction is set\n     * on user 0 from the DO user, which becomes unremovable by the organization-owned\n     * profile owner. Fix this by force removing that restriction. Also revert the\n     * parentAdmin.requireAutoTime bit (since the COPE PO cannot unset this bit)\n     * and replace it with DISALLOW_CONFIG_DATE_TIME on the correct\n     * admin, in line with the deprecation recommendation of setAutoTimeRequired().\n     */\n    private void fixupAutoTimeRestrictionDuringOrganizationOwnedDeviceMigration() {\n        for (UserInfo ui : mUserManager.getUsers()) {\n            final int userId = ui.id;\n            if (isProfileOwnerOfOrganizationOwnedDevice(userId)) {\n                final ActiveAdmin parent = getProfileOwnerAdminLocked(userId).parentAdmin;\n                if (parent != null && parent.requireAutoTime) {\n                    // Remove deprecated requireAutoTime\n                    parent.requireAutoTime = false;\n                    saveSettingsLocked(userId);\n\n                    // Remove user restrictions set by the device owner before the upgrade to\n                    // Android 11.\n                    mUserManagerInternal.setDevicePolicyUserRestrictions(UserHandle.USER_SYSTEM,\n                            new Bundle(), new RestrictionsSet(), /* isDeviceOwner */ false);\n\n                    // Apply user restriction to parent active admin instead\n                    parent.ensureUserRestrictions().putBoolean(\n                            UserManager.DISALLOW_CONFIG_DATE_TIME, true);\n                    pushUserRestrictions(userId);\n                }\n            }\n        }\n    }\n\n    /**\n     * Set an alarm for an upcoming event - expiration warning, expiration, or post-expiration\n     * reminders.  Clears alarm if no expirations are configured.\n     */\n    private void setExpirationAlarmCheckLocked(Context context, int userHandle, boolean parent) {\n        final long expiration = getPasswordExpirationLocked(null, userHandle, parent);\n        final long now = System.currentTimeMillis();\n        final long timeToExpire = expiration - now;\n        final long alarmTime;\n        if (expiration == 0) {\n            // No expirations are currently configured:  Cancel alarm.\n            alarmTime = 0;\n        } else if (timeToExpire <= 0) {\n            // The password has already expired:  Repeat every 24 hours.\n            alarmTime = now + MS_PER_DAY;\n        } else {\n            // Selecting the next alarm time:  Roll forward to the next 24 hour multiple before\n            // the expiration time.\n            long alarmInterval = timeToExpire % MS_PER_DAY;\n            if (alarmInterval == 0) {\n                alarmInterval = MS_PER_DAY;\n            }\n            alarmTime = now + alarmInterval;\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            int affectedUserHandle = parent ? getProfileParentId(userHandle) : userHandle;\n            AlarmManager am = mInjector.getAlarmManager();\n            // Broadcast alarms sent by system are immutable\n            PendingIntent pi = PendingIntent.getBroadcastAsUser(context, REQUEST_EXPIRE_PASSWORD,\n                    new Intent(ACTION_EXPIRED_PASSWORD_NOTIFICATION),\n                    PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_UPDATE_CURRENT\n                            | PendingIntent.FLAG_IMMUTABLE,\n                    UserHandle.of(affectedUserHandle));\n            am.cancel(pi);\n            if (alarmTime != 0) {\n                am.set(AlarmManager.RTC, alarmTime, pi);\n            }\n        });\n    }\n\n    ActiveAdmin getActiveAdminUncheckedLocked(ComponentName who, int userHandle) {\n        ensureLocked();\n        ActiveAdmin admin = getUserData(userHandle).mAdminMap.get(who);\n        if (admin != null\n                && who.getPackageName().equals(admin.info.getActivityInfo().packageName)\n                && who.getClassName().equals(admin.info.getActivityInfo().name)) {\n            return admin;\n        }\n        return null;\n    }\n\n    ActiveAdmin getActiveAdminUncheckedLocked(ComponentName who, int userHandle, boolean parent) {\n        ensureLocked();\n        if (parent) {\n            Preconditions.checkCallAuthorization(isManagedProfile(userHandle),\n                    \"You can not call APIs on the parent profile outside a managed profile, \"\n                            + \"userId = %d\", userHandle);\n        }\n        ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n        if (admin != null && parent) {\n            admin = admin.getParentActiveAdmin();\n        }\n        return admin;\n    }\n\n    ActiveAdmin getActiveAdminForCallerLocked(ComponentName who, int reqPolicy)\n            throws SecurityException {\n        return getActiveAdminOrCheckPermissionForCallerLocked(who,\n                reqPolicy, /* permission= */ null);\n    }\n\n    ActiveAdmin getDeviceOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        ComponentName doComponent = mOwners.getDeviceOwnerComponent();\n        ActiveAdmin doAdmin = getUserData(userId).mAdminMap.get(doComponent);\n        return doAdmin;\n    }\n\n    ActiveAdmin getDefaultDeviceOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        ComponentName doComponent = mOwners.getDeviceOwnerComponent();\n        if (mOwners.getDeviceOwnerType(doComponent.getPackageName()) == DEFAULT_DEVICE_OWNER) {\n            ActiveAdmin doAdmin = getUserData(userId).mAdminMap.get(doComponent);\n            return doAdmin;\n        }\n        return null;\n    }\n\n    ActiveAdmin getProfileOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        final ComponentName poAdminComponent = mOwners.getProfileOwnerComponent(userId);\n        ActiveAdmin poAdmin = getUserData(userId).mAdminMap.get(poAdminComponent);\n        return poAdmin;\n    }\n\n    @NonNull ActiveAdmin getOrganizationOwnedProfileOwnerLocked(final CallerIdentity caller) {\n        Preconditions.checkCallAuthorization(\n                mOwners.isProfileOwnerOfOrganizationOwnedDevice(caller.getUserId()),\n                \"Caller %s is not an admin of an org-owned device\",\n                caller.getComponentName());\n        final ActiveAdmin profileOwner = getProfileOwnerLocked(caller.getUserId());\n\n        return profileOwner;\n    }\n\n    ActiveAdmin getProfileOwnerOrDeviceOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        // Try to find an admin which can use reqPolicy\n        final ComponentName poAdminComponent = mOwners.getProfileOwnerComponent(userId);\n\n        if (poAdminComponent != null) {\n            return getProfileOwnerLocked(userId);\n        }\n\n        return getDeviceOwnerLocked(userId);\n    }\n\n    ActiveAdmin getProfileOwnerOrDefaultDeviceOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        // Try to find an admin which can use reqPolicy\n        final ComponentName poAdminComponent = mOwners.getProfileOwnerComponent(userId);\n\n        if (poAdminComponent != null) {\n            return getProfileOwnerLocked(userId);\n        }\n\n        return getDefaultDeviceOwnerLocked(userId);\n    }\n\n    @NonNull ActiveAdmin getParentOfAdminIfRequired(ActiveAdmin admin, boolean parent) {\n        Objects.requireNonNull(admin);\n        return parent ? admin.getParentActiveAdmin() : admin;\n    }\n\n    /**\n     * Finds an active admin for the caller then checks {@code permission} if admin check failed.\n     *\n     * @return an active admin or {@code null} if there is no active admin but\n     * {@code permission} is granted\n     * @throws SecurityException if caller neither has an active admin nor {@code permission}\n     */\n    @Nullable\n    ActiveAdmin getActiveAdminOrCheckPermissionForCallerLocked(\n            ComponentName who,\n            int reqPolicy,\n            @Nullable String permission) throws SecurityException {\n        return getActiveAdminOrCheckPermissionsForCallerLocked(\n                who, reqPolicy, permission == null ? Set.of() : Set.of(permission));\n    }\n\n    /**\n     * Finds an active admin for the caller then checks {@code permissions} if admin check failed.\n     *\n     * @return an active admin or {@code null} if there is no active admin but\n     * one of {@code permissions} is granted\n     * @throws SecurityException if caller neither has an active admin nor {@code permission}\n     */\n    @Nullable\n    ActiveAdmin getActiveAdminOrCheckPermissionsForCallerLocked(\n            ComponentName who,\n            int reqPolicy,\n            Set<String> permissions) throws SecurityException {\n        ensureLocked();\n        final CallerIdentity caller = getCallerIdentity();\n\n        ActiveAdmin result = getActiveAdminWithPolicyForUidLocked(who, reqPolicy, caller.getUid());\n        if (result != null) {\n            return result;\n        } else {\n            for (String permission : permissions) {\n                if (hasCallingPermission(permission)) {\n                    return null;\n                }\n            }\n        }\n\n        // Code for handling failure from getActiveAdminWithPolicyForUidLocked to find an admin\n        // that satisfies the required policy.\n        // Throws a security exception with the right error message.\n        if (who != null) {\n            final DevicePolicyData policy = getUserData(caller.getUserId());\n            ActiveAdmin admin = policy.mAdminMap.get(who);\n            final boolean isDeviceOwner = isDeviceOwner(admin.info.getComponent(),\n                    caller.getUserId());\n            final boolean isProfileOwner = isProfileOwner(admin.info.getComponent(),\n                    caller.getUserId());\n\n            if (DA_DISALLOWED_POLICIES.contains(reqPolicy) && !isDeviceOwner && !isProfileOwner) {\n                throw new SecurityException(\"Admin \" + admin.info.getComponent()\n                        + \" is not a device owner or profile owner, so may not use policy: \"\n                        + admin.info.getTagForPolicy(reqPolicy));\n            }\n            throw new SecurityException(\"Admin \" + admin.info.getComponent()\n                    + \" did not specify uses-policy for: \"\n                    + admin.info.getTagForPolicy(reqPolicy));\n        } else {\n            throw new SecurityException(\"No active admin owned by uid \"\n                    + caller.getUid() + \" for policy #\" + reqPolicy + (permissions.isEmpty() ? \"\"\n                    : \", which doesn't have \" + permissions));\n        }\n    }\n\n    ActiveAdmin getActiveAdminForCallerLocked(@Nullable ComponentName who, int reqPolicy,\n            boolean parent) throws SecurityException {\n        return getActiveAdminOrCheckPermissionForCallerLocked(\n                who, reqPolicy, parent, /* permission= */ null);\n    }\n\n    /**\n     * Finds an active admin for the caller then checks {@code permission} if admin check failed.\n     *\n     * @return an active admin or {@code null} if there is no active admin but\n     * {@code permission} is granted\n     * @throws SecurityException if caller neither has an active admin nor {@code permission}\n     */\n    @Nullable\n    ActiveAdmin getActiveAdminOrCheckPermissionForCallerLocked(\n            @Nullable ComponentName who,\n            int reqPolicy,\n            boolean parent,\n            @Nullable String permission) throws SecurityException {\n        return getActiveAdminOrCheckPermissionsForCallerLocked(\n                who, reqPolicy, parent, permission == null ? Set.of() : Set.of(permission));\n    }\n\n    /**\n     * Finds an active admin for the caller then checks {@code permission} if admin check failed.\n     *\n     * @return an active admin or {@code null} if there is no active admin but\n     * {@code permission} is granted\n     * @throws SecurityException if caller neither has an active admin nor {@code permission}\n     */\n    @Nullable\n    ActiveAdmin getActiveAdminOrCheckPermissionsForCallerLocked(\n            @Nullable ComponentName who,\n            int reqPolicy,\n            boolean parent,\n            Set<String> permissions) throws SecurityException {\n        ensureLocked();\n        if (parent) {\n            Preconditions.checkCallingUser(isManagedProfile(getCallerIdentity().getUserId()));\n        }\n        ActiveAdmin admin = getActiveAdminOrCheckPermissionsForCallerLocked(\n                who, reqPolicy, permissions);\n        return parent ? admin.getParentActiveAdmin() : admin;\n    }\n\n    /**\n     * Find the admin for the component and userId bit of the uid, then check\n     * the admin's uid matches the uid.\n     */\n    private ActiveAdmin getActiveAdminForUidLocked(ComponentName who, int uid) {\n        ensureLocked();\n        final int userId = UserHandle.getUserId(uid);\n        final DevicePolicyData policy = getUserData(userId);\n        ActiveAdmin admin = policy.mAdminMap.get(who);\n        if (admin == null) {\n            throw new SecurityException(\"No active admin \" + who + \" for UID \" + uid);\n        }\n        if (admin.getUid() != uid) {\n            throw new SecurityException(\"Admin \" + who + \" is not owned by uid \" + uid);\n        }\n        return admin;\n    }\n\n    /**\n     * Returns the active admin for the user of the caller as denoted by uid, which implements\n     * the {@code reqPolicy}.\n     *\n     * The {@code who} parameter is used as a hint:\n     * If provided, it must be the component name of the active admin for that user and the caller\n     * uid must match the uid of the admin.\n     * If not provided, iterate over all of the active admins in the DevicePolicyData for that user\n     * and return the one with the uid specified as parameter, and has the policy specified.\n     */\n    @Nullable\n    private ActiveAdmin getActiveAdminWithPolicyForUidLocked(ComponentName who, int reqPolicy,\n            int uid) {\n        ensureLocked();\n        // Try to find an admin which can use reqPolicy\n        final int userId = UserHandle.getUserId(uid);\n        final DevicePolicyData policy = getUserData(userId);\n        if (who != null) {\n            ActiveAdmin admin = policy.mAdminMap.get(who);\n            if (admin == null || admin.getUid() != uid) {\n                throw new SecurityException(\n                        \"Admin \" + who + \" is not active or not owned by uid \" + uid);\n            }\n            if (isActiveAdminWithPolicyForUserLocked(admin, reqPolicy, userId)) {\n                return admin;\n            }\n        } else {\n            for (ActiveAdmin admin : policy.mAdminList) {\n                if (admin.getUid() == uid && isActiveAdminWithPolicyForUserLocked(admin, reqPolicy,\n                        userId)) {\n                    return admin;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    @VisibleForTesting\n    boolean isActiveAdminWithPolicyForUserLocked(ActiveAdmin admin, int reqPolicy,\n            int userId) {\n        ensureLocked();\n        final boolean ownsDevice = isDeviceOwner(admin.info.getComponent(), userId);\n        final boolean ownsProfile = isProfileOwner(admin.info.getComponent(), userId);\n\n        boolean allowedToUsePolicy = ownsDevice || ownsProfile\n                || !DA_DISALLOWED_POLICIES.contains(reqPolicy)\n                || getTargetSdk(admin.info.getPackageName(), userId) < Build.VERSION_CODES.Q;\n        return allowedToUsePolicy && admin.info.usesPolicy(reqPolicy);\n    }\n\n    void sendAdminCommandLocked(ActiveAdmin admin, String action) {\n        sendAdminCommandLocked(admin, action, null);\n    }\n\n    void sendAdminCommandLocked(ActiveAdmin admin, String action, BroadcastReceiver result) {\n        sendAdminCommandLocked(admin, action, null, result);\n    }\n\n    void sendAdminCommandLocked(ActiveAdmin admin, String action, Bundle adminExtras,\n            BroadcastReceiver result) {\n        sendAdminCommandLocked(admin, action, adminExtras, result, false);\n    }\n\n    /**\n     * Send an update to one specific admin, get notified when that admin returns a result.\n     *\n     * @return whether the broadcast was successfully sent\n     */\n    boolean sendAdminCommandLocked(ActiveAdmin admin, String action, Bundle adminExtras,\n            BroadcastReceiver result, boolean inForeground) {\n        Intent intent = new Intent(action);\n        intent.setComponent(admin.info.getComponent());\n        if (UserManager.isDeviceInDemoMode(mContext)) {\n            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        }\n        if (action.equals(DeviceAdminReceiver.ACTION_PASSWORD_EXPIRING)) {\n            intent.putExtra(\"expiration\", admin.passwordExpirationDate);\n        }\n        if (inForeground) {\n            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        }\n        if (adminExtras != null) {\n            intent.putExtras(adminExtras);\n        }\n        if (mInjector.getPackageManager().queryBroadcastReceiversAsUser(\n                intent,\n                PackageManager.MATCH_DEBUG_TRIAGED_MISSING,\n                admin.getUserHandle()).isEmpty()) {\n            return false;\n        }\n\n        final BroadcastOptions options = BroadcastOptions.makeBasic();\n        options.setBackgroundActivityStartsAllowed(true);\n\n        if (result != null) {\n            mContext.sendOrderedBroadcastAsUser(intent, admin.getUserHandle(),\n                    null, AppOpsManager.OP_NONE, options.toBundle(),\n                    result, mHandler, Activity.RESULT_OK, null, null);\n        } else {\n            mContext.sendBroadcastAsUser(intent, admin.getUserHandle(), null, options.toBundle());\n        }\n\n        return true;\n    }\n\n    /**\n     * Send an update to all admins of a user that enforce a specified policy.\n     */\n    void sendAdminCommandLocked(String action, int reqPolicy, int userHandle, Bundle adminExtras) {\n        final DevicePolicyData policy = getUserData(userHandle);\n        final int count = policy.mAdminList.size();\n        for (int i = 0; i < count; i++) {\n            final ActiveAdmin admin = policy.mAdminList.get(i);\n            if (admin.info.usesPolicy(reqPolicy)) {\n                sendAdminCommandLocked(admin, action, adminExtras, null);\n            }\n        }\n    }\n\n    /**\n     * Send an update intent to all admins of a user and its profiles. Only send to admins that\n     * enforce a specified policy.\n     */\n    private void sendAdminCommandToSelfAndProfilesLocked(String action, int reqPolicy,\n            int userHandle, Bundle adminExtras) {\n        int[] profileIds = mUserManager.getProfileIdsWithDisabled(userHandle);\n        for (int profileId : profileIds) {\n            sendAdminCommandLocked(action, reqPolicy, profileId, adminExtras);\n        }\n    }\n\n    /**\n     * Sends a broadcast to each profile that share the password unlock with the given user id.\n     */\n    private void sendAdminCommandForLockscreenPoliciesLocked(\n            String action, int reqPolicy, int userHandle) {\n        final Bundle extras = new Bundle();\n        extras.putParcelable(Intent.EXTRA_USER, UserHandle.of(userHandle));\n        if (isSeparateProfileChallengeEnabled(userHandle)) {\n            sendAdminCommandLocked(action, reqPolicy, userHandle, extras);\n        } else {\n            sendAdminCommandToSelfAndProfilesLocked(action, reqPolicy, userHandle, extras);\n        }\n    }\n\n    void removeActiveAdminLocked(final ComponentName adminReceiver, final int userHandle) {\n        final ActiveAdmin admin = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n        DevicePolicyData policy = getUserData(userHandle);\n        if (admin != null && !policy.mRemovingAdmins.contains(adminReceiver)) {\n            policy.mRemovingAdmins.add(adminReceiver);\n            sendAdminCommandLocked(admin,\n                    DeviceAdminReceiver.ACTION_DEVICE_ADMIN_DISABLED,\n                    new BroadcastReceiver() {\n                        @Override\n                        public void onReceive(Context context, Intent intent) {\n                            removeAdminArtifacts(adminReceiver, userHandle);\n                            removePackageIfRequired(adminReceiver.getPackageName(), userHandle);\n                        }\n                    });\n        }\n    }\n\n    private DeviceAdminInfo findAdmin(final ComponentName adminName, final int userHandle,\n            boolean throwForMissingPermission) {\n        final ActivityInfo ai = mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                return mIPackageManager.getReceiverInfo(adminName,\n                        GET_META_DATA\n                        | PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS\n                        | PackageManager.MATCH_DIRECT_BOOT_AWARE\n                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE, userHandle);\n            } catch (RemoteException e) {\n                // shouldn't happen.\n                Slogf.wtf(LOG_TAG, \"Error getting receiver info\", e);\n                return null;\n            }\n        });\n        if (ai == null) {\n            throw new IllegalArgumentException(\"Unknown admin: \" + adminName);\n        }\n\n        if (!permission.BIND_DEVICE_ADMIN.equals(ai.permission)) {\n            final String message = \"DeviceAdminReceiver \" + adminName + \" must be protected with \"\n                    + permission.BIND_DEVICE_ADMIN;\n            Slogf.w(LOG_TAG, message);\n            if (throwForMissingPermission &&\n                    ai.applicationInfo.targetSdkVersion > Build.VERSION_CODES.M) {\n                throw new IllegalArgumentException(message);\n            }\n        }\n\n        try {\n            return new DeviceAdminInfo(mContext, ai);\n        } catch (XmlPullParserException | IOException e) {\n            Slogf.w(LOG_TAG, \"Bad device admin requested for user=\" + userHandle + \": \" + adminName,\n                    e);\n            return null;\n        }\n    }\n\n    private File getPolicyFileDirectory(@UserIdInt int userId) {\n        return userId == UserHandle.USER_SYSTEM\n                ? mPathProvider.getDataSystemDirectory()\n                : mPathProvider.getUserSystemDirectory(userId);\n    }\n\n    private JournaledFile makeJournaledFile(@UserIdInt int userId, String fileName) {\n        final String base = new File(getPolicyFileDirectory(userId), fileName)\n                .getAbsolutePath();\n        if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"Opening %s\", base);\n        return new JournaledFile(new File(base), new File(base + \".tmp\"));\n    }\n\n    private JournaledFile makeJournaledFile(@UserIdInt int userId) {\n        return makeJournaledFile(userId, DEVICE_POLICIES_XML);\n    }\n\n    /**\n     * Persist modified values to disk by calling {@link #saveSettingsLocked} for each\n     * affected user ID.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void saveSettingsForUsersLocked(Set<Integer> affectedUserIds) {\n        for (int userId : affectedUserIds) {\n            saveSettingsLocked(userId);\n        }\n    }\n\n    private void saveSettingsLocked(int userHandle) {\n        if (DevicePolicyData.store(getUserData(userHandle), makeJournaledFile(userHandle))) {\n            sendChangedNotification(userHandle);\n        }\n        invalidateBinderCaches();\n    }\n\n    private void sendChangedNotification(int userHandle) {\n        Intent intent = new Intent(DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED);\n        intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        Bundle options = new BroadcastOptions()\n                .setDeliveryGroupPolicy(BroadcastOptions.DELIVERY_GROUP_POLICY_MOST_RECENT)\n                .setDeferralPolicy(BroadcastOptions.DEFERRAL_POLICY_UNTIL_ACTIVE)\n                .toBundle();\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mContext.sendBroadcastAsUser(intent, new UserHandle(userHandle), null, options));\n    }\n\n    private void loadSettingsLocked(DevicePolicyData policy, int userHandle) {\n        DevicePolicyData.load(policy,\n                makeJournaledFile(userHandle),\n                component -> findAdmin(\n                        component, userHandle, /* throwForMissingPermission= */ false),\n                getOwnerComponent(userHandle));\n\n        policy.validatePasswordOwner();\n        updateMaximumTimeToLockLocked(userHandle);\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            updateLockTaskPackagesLocked(mContext, policy.mLockTaskPackages, userHandle);\n            updateLockTaskFeaturesLocked(policy.mLockTaskFeatures, userHandle);\n        }\n        if (policy.mStatusBarDisabled) {\n            setStatusBarDisabledInternal(policy.mStatusBarDisabled, userHandle);\n        }\n    }\n\n    static void updateLockTaskPackagesLocked(Context context, List<String> packages, int userId) {\n        Binder.withCleanCallingIdentity(() -> {\n\n            String[] packagesArray = null;\n            if (!packages.isEmpty()) {\n                // When adding packages, we need to include the exempt apps so they can still be\n                // launched (ideally we should use a different AM API as these apps don't need to\n                // use lock-task mode).\n                // They're not added when the packages is empty though, as in that case we're\n                // disabling lock-task mode.\n                List<String> exemptApps = listPolicyExemptAppsUnchecked(context);\n                if (!exemptApps.isEmpty()) {\n                    // TODO(b/175377361): add unit test to verify it (cannot be CTS because the\n                    //  policy-exempt apps are provided by OEM and the test would have no control\n                    //  over it) once tests are migrated to the new infra-structure\n                    HashSet<String> updatedPackages = new HashSet<>(packages);\n                    updatedPackages.addAll(exemptApps);\n                    if (VERBOSE_LOG) {\n                        Slogf.v(LOG_TAG, \"added %d policy-exempt apps to %d lock task \"\n                                + \"packages. Final list: %s\",\n                                exemptApps.size(), packages.size(), updatedPackages);\n                    }\n                    packagesArray = updatedPackages.toArray(new String[updatedPackages.size()]);\n                }\n            }\n\n            if (packagesArray == null) {\n                packagesArray = packages.toArray(new String[packages.size()]);\n            }\n            try {\n                ActivityManager.getService().updateLockTaskPackages(userId, packagesArray);\n            } catch (RemoteException e) {\n                // Shouldn't happen.\n                Slog.wtf(LOG_TAG, \"Remote Exception: \", e);\n            }\n        });\n    }\n\n    static void updateLockTaskFeaturesLocked(int flags, int userId) {\n        Binder.withCleanCallingIdentity(() -> {\n            try {\n                ActivityTaskManager.getService().updateLockTaskFeatures(userId, flags);\n            } catch (RemoteException e) {\n                // Shouldn't happen.\n                Slog.wtf(LOG_TAG, \"Remote Exception: \", e);\n            }\n        });\n    }\n\n    static void validateQualityConstant(int quality) {\n        switch (quality) {\n            case PASSWORD_QUALITY_UNSPECIFIED:\n            case PASSWORD_QUALITY_BIOMETRIC_WEAK:\n            case PASSWORD_QUALITY_SOMETHING:\n            case PASSWORD_QUALITY_NUMERIC:\n            case PASSWORD_QUALITY_NUMERIC_COMPLEX:\n            case PASSWORD_QUALITY_ALPHABETIC:\n            case PASSWORD_QUALITY_ALPHANUMERIC:\n            case PASSWORD_QUALITY_COMPLEX:\n            case PASSWORD_QUALITY_MANAGED:\n                return;\n        }\n        throw new IllegalArgumentException(\"Invalid quality constant: 0x\"\n                + Integer.toHexString(quality));\n    }\n\n    @VisibleForTesting\n    void systemReady(int phase) {\n        if (!mHasFeature) {\n            return;\n        }\n        switch (phase) {\n            case SystemService.PHASE_LOCK_SETTINGS_READY:\n                onLockSettingsReady();\n                loadAdminDataAsync();\n                mOwners.systemReady();\n                applyManagedSubscriptionsPolicyIfRequired();\n                break;\n            case SystemService.PHASE_ACTIVITY_MANAGER_READY:\n                synchronized (getLockObject()) {\n                    migrateToProfileOnOrganizationOwnedDeviceIfCompLocked();\n                    applyProfileRestrictionsIfDeviceOwnerLocked();\n\n                    // TODO: Is this the right place to trigger the migration?\n                    if (shouldMigrateToDevicePolicyEngine()) {\n                        migratePoliciesToDevicePolicyEngine();\n                    }\n\n                    maybeMigratePoliciesPostUpgradeToDevicePolicyEngineLocked();\n                }\n                maybeStartSecurityLogMonitorOnActivityManagerReady();\n                break;\n            case SystemService.PHASE_BOOT_COMPLETED:\n                // Ideally it should be done earlier, but currently it relies on RecoverySystem,\n                // which would hang on earlier phases\n                factoryResetIfDelayedEarlier();\n\n                ensureDeviceOwnerUserStarted(); // TODO Consider better place to do this.\n                break;\n        }\n    }\n\n    private void applyManagedSubscriptionsPolicyIfRequired() {\n        int copeProfileUserId = getOrganizationOwnedProfileUserId();\n        // This policy is relevant only for COPE devices.\n        if (copeProfileUserId != UserHandle.USER_NULL) {\n            unregisterOnSubscriptionsChangedListener();\n            int policyType = getManagedSubscriptionsPolicy().getPolicyType();\n            if (policyType == ManagedSubscriptionsPolicy.TYPE_ALL_PERSONAL_SUBSCRIPTIONS) {\n                clearManagedSubscriptionsPolicy();\n            } else if (policyType == ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {\n                // Add listener to assign all current and future subs to managed profile.\n                registerListenerToAssignSubscriptionsToUser(copeProfileUserId);\n            }\n        }\n    }\n\n    private void updatePersonalAppsSuspensionOnUserStart(int userHandle) {\n        final int profileUserHandle = getManagedUserId(userHandle);\n        if (profileUserHandle >= 0) {\n            // Given that the parent user has just started, profile should be locked.\n            updatePersonalAppsSuspension(profileUserHandle);\n        } else {\n            suspendPersonalAppsInternal(userHandle, profileUserHandle, false);\n        }\n    }\n\n    private void onLockSettingsReady() {\n        synchronized (getLockObject()) {\n            fixupAutoTimeRestrictionDuringOrganizationOwnedDeviceMigration();\n        }\n        getUserData(UserHandle.USER_SYSTEM);\n        cleanUpOldUsers();\n        maybeSetDefaultProfileOwnerUserRestrictions();\n        handleStartUser(UserHandle.USER_SYSTEM);\n        maybeLogStart();\n\n        // Register an observer for watching for user setup complete and settings changes.\n        mSetupContentObserver.register();\n        // Initialize the user setup state, to handle the upgrade case.\n        updateUserSetupCompleteAndPaired();\n\n        List<String> packageList;\n        synchronized (getLockObject()) {\n            packageList = getKeepUninstalledPackagesLocked();\n        }\n        if (packageList != null) {\n            mInjector.getPackageManagerInternal().setKeepUninstalledPackages(packageList);\n        }\n\n        synchronized (getLockObject()) {\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (deviceOwner != null) {\n                // Push the force-ephemeral-users policy to the user manager.\n                mUserManagerInternal.setForceEphemeralUsers(deviceOwner.forceEphemeralUsers);\n\n                // Update user switcher message to activity manager.\n                ActivityManagerInternal activityManagerInternal =\n                        mInjector.getActivityManagerInternal();\n                activityManagerInternal.setSwitchingFromSystemUserMessage(\n                        deviceOwner.startUserSessionMessage);\n                activityManagerInternal.setSwitchingToSystemUserMessage(\n                        deviceOwner.endUserSessionMessage);\n            }\n\n            revertTransferOwnershipIfNecessaryLocked();\n        }\n        updateUsbDataSignal();\n\n        // In case flag value has changed, we apply it during boot to avoid doing it concurrently\n        // with user toggling quiet mode.\n        setKeepProfileRunningEnabledUnchecked(isKeepProfilesRunningFlagEnabled());\n    }\n\n    // TODO(b/230841522) Make it static.\n    private class DpmsUpgradeDataProvider implements PolicyUpgraderDataProvider {\n        @Override\n        public JournaledFile makeDevicePoliciesJournaledFile(int userId) {\n            return DevicePolicyManagerService.this.makeJournaledFile(userId, DEVICE_POLICIES_XML);\n        }\n\n        @Override\n        public JournaledFile makePoliciesVersionJournaledFile(int userId) {\n            return DevicePolicyManagerService.this.makeJournaledFile(userId, POLICIES_VERSION_XML);\n        }\n\n        @Override\n        public Function<ComponentName, DeviceAdminInfo> getAdminInfoSupplier(int userId) {\n            return component ->\n                    findAdmin(component, userId, /* throwForMissingPermission= */ false);\n        }\n\n        @Override\n        public int[] getUsersForUpgrade() {\n            List<UserInfo> allUsers = mUserManager.getUsers();\n            return allUsers.stream().mapToInt(u -> u.id).toArray();\n        }\n\n        @Override\n        public List<String> getPlatformSuspendedPackages(int userId) {\n            PackageManagerInternal pmi = mInjector.getPackageManagerInternal();\n            return mInjector.getPackageManager(userId)\n                    .getInstalledPackages(PackageManager.PackageInfoFlags.of(\n                            MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE))\n                    .stream()\n                    .map(packageInfo -> packageInfo.packageName)\n                    .filter(pkg ->\n                            PLATFORM_PACKAGE_NAME.equals(pmi.getSuspendingPackage(pkg, userId))\n                    )\n                    .collect(Collectors.toList());\n        }\n    }\n\n    private void performPolicyVersionUpgrade() {\n        PolicyVersionUpgrader upgrader = new PolicyVersionUpgrader(\n                new DpmsUpgradeDataProvider(), mPathProvider);\n        upgrader.upgradePolicy(DPMS_VERSION);\n    }\n\n    private void revertTransferOwnershipIfNecessaryLocked() {\n        if (!mTransferOwnershipMetadataManager.metadataFileExists()) {\n            return;\n        }\n        Slogf.e(LOG_TAG, \"Owner transfer metadata file exists! Reverting transfer.\");\n        final TransferOwnershipMetadataManager.Metadata metadata =\n                mTransferOwnershipMetadataManager.loadMetadataFile();\n        // Revert transfer\n        if (metadata.adminType.equals(ADMIN_TYPE_PROFILE_OWNER)) {\n            transferProfileOwnershipLocked(metadata.targetComponent, metadata.sourceComponent,\n                    metadata.userId);\n            deleteTransferOwnershipMetadataFileLocked();\n            deleteTransferOwnershipBundleLocked(metadata.userId);\n        } else if (metadata.adminType.equals(ADMIN_TYPE_DEVICE_OWNER)) {\n            transferDeviceOwnershipLocked(metadata.targetComponent, metadata.sourceComponent,\n                    metadata.userId);\n            deleteTransferOwnershipMetadataFileLocked();\n            deleteTransferOwnershipBundleLocked(metadata.userId);\n        }\n        updateSystemUpdateFreezePeriodsRecord(/* saveIfChanged */ true);\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            pushUserControlDisabledPackagesLocked(metadata.userId);\n        }\n    }\n\n    private void maybeLogStart() {\n        if (!SecurityLog.isLoggingEnabled()) {\n            return;\n        }\n        final String verifiedBootState =\n                mInjector.systemPropertiesGet(\"ro.boot.verifiedbootstate\");\n        final String verityMode = mInjector.systemPropertiesGet(\"ro.boot.veritymode\");\n        SecurityLog.writeEvent(SecurityLog.TAG_OS_STARTUP, verifiedBootState, verityMode);\n    }\n\n    private void ensureDeviceOwnerUserStarted() {\n        final int userId;\n        synchronized (getLockObject()) {\n            if (!mOwners.hasDeviceOwner()) {\n                return;\n            }\n            userId = mOwners.getDeviceOwnerUserId();\n        }\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"Starting non-system DO user: \" + userId);\n        }\n        if (userId != UserHandle.USER_SYSTEM) {\n            try {\n                mInjector.getIActivityManager().startUserInBackground(userId);\n\n                // STOPSHIP Prevent the DO user from being killed.\n\n            } catch (RemoteException e) {\n                Slogf.w(LOG_TAG, \"Exception starting user\", e);\n            }\n        }\n    }\n\n    void handleStartUser(int userId) {\n        synchronized (getLockObject()) {\n            pushScreenCapturePolicy(userId);\n            if (!isPolicyEngineForFinanceFlagEnabled()) {\n                pushUserControlDisabledPackagesLocked(userId);\n            }\n        }\n        pushUserRestrictions(userId);\n        // When system user is started (device boot), load cache for all users.\n        // This is to mitigate the potential race between loading the cache and keyguard\n        // reading the value during user switch, due to onStartUser() being asynchronous.\n        updatePasswordQualityCacheForUserGroup(\n                userId == UserHandle.USER_SYSTEM ? UserHandle.USER_ALL : userId);\n        updatePermissionPolicyCache(userId);\n        updateAdminCanGrantSensorsPermissionCache(userId);\n\n        final List<PreferentialNetworkServiceConfig> preferentialNetworkServiceConfigs;\n        synchronized (getLockObject()) {\n            ActiveAdmin owner = getDeviceOrProfileOwnerAdminLocked(userId);\n            preferentialNetworkServiceConfigs = owner != null\n                    ? owner.mPreferentialNetworkServiceConfigs\n                    : List.of(PreferentialNetworkServiceConfig.DEFAULT);\n        }\n        updateNetworkPreferenceForUser(userId, preferentialNetworkServiceConfigs);\n\n        if (isProfileOwnerOfOrganizationOwnedDevice(userId)\n                && getManagedSubscriptionsPolicy().getPolicyType()\n                == ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {\n            updateDialerAndSmsManagedShortcutsOverrideCache();\n        }\n\n        startOwnerService(userId, \"start-user\");\n        if (isPermissionCheckFlagEnabled() || isPolicyEngineForFinanceFlagEnabled()) {\n            mDevicePolicyEngine.handleStartUser(userId);\n        }\n    }\n\n    void pushUserControlDisabledPackagesLocked(int userId) {\n        final int targetUserId;\n        final ActiveAdmin owner;\n        if (getDeviceOwnerUserIdUncheckedLocked() == userId) {\n            owner = getDeviceOwnerAdminLocked();\n            targetUserId = UserHandle.USER_ALL;\n        } else {\n            owner = getProfileOwnerAdminLocked(userId);\n            targetUserId = userId;\n        }\n\n        List<String> protectedPackages = (owner == null || owner.protectedPackages == null)\n                ? null : owner.protectedPackages;\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.getPackageManagerInternal().setOwnerProtectedPackages(\n                        targetUserId, protectedPackages));\n        mUsageStatsManagerInternal.setAdminProtectedPackages(new ArraySet(protectedPackages),\n                targetUserId);\n    }\n\n    void handleUnlockUser(int userId) {\n        startOwnerService(userId, \"unlock-user\");\n        if (isPermissionCheckFlagEnabled() || isPolicyEngineForFinanceFlagEnabled()) {\n            mDevicePolicyEngine.handleUnlockUser(userId);\n        }\n    }\n\n    void handleOnUserUnlocked(int userId) {\n        showNewUserDisclaimerIfNecessary(userId);\n    }\n\n    void handleStopUser(int userId) {\n        updateNetworkPreferenceForUser(userId, List.of(PreferentialNetworkServiceConfig.DEFAULT));\n        mDeviceAdminServiceController.stopServicesForUser(userId, /* actionForLog= */ \"stop-user\");\n        if (isPermissionCheckFlagEnabled() || isPolicyEngineForFinanceFlagEnabled()) {\n            mDevicePolicyEngine.handleStopUser(userId);\n        }\n    }\n\n    private void startOwnerService(int userId, String actionForLog) {\n        final ComponentName owner = getOwnerComponent(userId);\n        if (owner != null) {\n            mDeviceAdminServiceController.startServiceForAdmin(\n                    owner.getPackageName(), userId, actionForLog);\n            invalidateBinderCaches();\n        }\n    }\n\n    private void cleanUpOldUsers() {\n        // This is needed in case the broadcast {@link Intent.ACTION_USER_REMOVED} was not handled\n        // before reboot\n        Set<Integer> usersWithProfileOwners;\n        Set<Integer> usersWithData;\n        synchronized (getLockObject()) {\n            usersWithProfileOwners = mOwners.getProfileOwnerKeys();\n            usersWithData = new ArraySet<>();\n            for (int i = 0; i < mUserData.size(); i++) {\n                usersWithData.add(mUserData.keyAt(i));\n            }\n        }\n        List<UserInfo> allUsers = mUserManager.getUsers();\n\n        Set<Integer> deletedUsers = new ArraySet<>();\n        deletedUsers.addAll(usersWithProfileOwners);\n        deletedUsers.addAll(usersWithData);\n        for (UserInfo userInfo : allUsers) {\n            deletedUsers.remove(userInfo.id);\n        }\n        for (Integer userId : deletedUsers) {\n            removeUserData(userId);\n            if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n                mDevicePolicyEngine.handleUserRemoved(userId);\n            }\n        }\n    }\n\n    private void handlePasswordExpirationNotification(int userHandle) {\n        final Bundle adminExtras = new Bundle();\n        adminExtras.putParcelable(Intent.EXTRA_USER, UserHandle.of(userHandle));\n\n        synchronized (getLockObject()) {\n            final long now = System.currentTimeMillis();\n\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(userHandle);\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                ActiveAdmin admin = admins.get(i);\n                if ((admin.isPermissionBased || admin.info.usesPolicy(DeviceAdminInfo.USES_POLICY_EXPIRE_PASSWORD))\n                        && admin.passwordExpirationTimeout > 0L\n                        && now >= admin.passwordExpirationDate - EXPIRATION_GRACE_PERIOD_MS\n                        && admin.passwordExpirationDate > 0L) {\n                    sendAdminCommandLocked(admin,\n                            DeviceAdminReceiver.ACTION_PASSWORD_EXPIRING, adminExtras, null);\n                }\n            }\n            setExpirationAlarmCheckLocked(mContext, userHandle, /* parent */ false);\n        }\n    }\n\n    /**\n     * Clean up internal state when the set of installed trusted CA certificates changes.\n     *\n     * @param userHandle user to check for. This must be a real user and not, for example,\n     *        {@link UserHandle#ALL}.\n     * @param installedCertificates the full set of certificate authorities currently installed for\n     *        {@param userHandle}. After calling this function, {@code mAcceptedCaCertificates} will\n     *        correspond to some subset of this.\n     */\n    protected void onInstalledCertificatesChanged(final UserHandle userHandle,\n            final @NonNull Collection<String> installedCertificates) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(userHandle.getIdentifier());\n\n            boolean changed = false;\n            changed |= policy.mAcceptedCaCertificates.retainAll(installedCertificates);\n            changed |= policy.mOwnerInstalledCaCerts.retainAll(installedCertificates);\n            if (changed) {\n                saveSettingsLocked(userHandle.getIdentifier());\n            }\n        }\n    }\n\n    /**\n     * Internal method used by {@link CertificateMonitor}.\n     */\n    protected Set<String> getAcceptedCaCertificates(final UserHandle userHandle) {\n        if (!mHasFeature) {\n            return Collections.<String> emptySet();\n        }\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(userHandle.getIdentifier());\n            return policy.mAcceptedCaCertificates;\n        }\n    }\n\n    /**\n     * @param adminReceiver The admin to add\n     * @param refreshing true = update an active admin, no error\n     */\n    @Override\n    public void setActiveAdmin(\n            ComponentName adminReceiver, boolean refreshing, int userHandle) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        DevicePolicyData policy = getUserData(userHandle);\n        DeviceAdminInfo info = findAdmin(adminReceiver, userHandle,\n                /* throwForMissingPermission= */ true);\n        synchronized (getLockObject()) {\n            checkActiveAdminPrecondition(adminReceiver, info, policy);\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                final ActiveAdmin existingAdmin\n                        = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n                if (!refreshing && existingAdmin != null) {\n                    throw new IllegalArgumentException(\"Admin is already added\");\n                }\n                ActiveAdmin newAdmin = new ActiveAdmin(info, /* parent */ false);\n                newAdmin.testOnlyAdmin =\n                        (existingAdmin != null) ? existingAdmin.testOnlyAdmin\n                                : isPackageTestOnly(adminReceiver.getPackageName(), userHandle);\n                policy.mAdminMap.put(adminReceiver, newAdmin);\n                int replaceIndex = -1;\n                final int N = policy.mAdminList.size();\n                for (int i=0; i < N; i++) {\n                    ActiveAdmin oldAdmin = policy.mAdminList.get(i);\n                    if (oldAdmin.info.getComponent().equals(adminReceiver)) {\n                        replaceIndex = i;\n                        break;\n                    }\n                }\n                if (replaceIndex == -1) {\n                    policy.mAdminList.add(newAdmin);\n                    enableIfNecessary(info.getPackageName(), userHandle);\n                    mUsageStatsManagerInternal.onActiveAdminAdded(\n                            adminReceiver.getPackageName(), userHandle);\n                } else {\n                    policy.mAdminList.set(replaceIndex, newAdmin);\n                }\n                saveSettingsLocked(userHandle);\n                sendAdminCommandLocked(newAdmin, DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED,\n                        /* adminExtras= */ null, /* result= */ null);\n            });\n        }\n    }\n\n    private void loadAdminDataAsync() {\n        mInjector.postOnSystemServerInitThreadPool(() -> {\n            pushActiveAdminPackages();\n            mUsageStatsManagerInternal.onAdminDataAvailable();\n            pushAllMeteredRestrictedPackages();\n            mInjector.getNetworkPolicyManagerInternal().onAdminDataAvailable();\n        });\n    }\n\n    private void pushActiveAdminPackages() {\n        synchronized (getLockObject()) {\n            final List<UserInfo> users = mUserManager.getUsers();\n            for (int i = users.size() - 1; i >= 0; --i) {\n                final int userId = users.get(i).id;\n                mUsageStatsManagerInternal.setActiveAdminApps(\n                        getActiveAdminPackagesLocked(userId), userId);\n            }\n        }\n    }\n\n    private void pushAllMeteredRestrictedPackages() {\n        synchronized (getLockObject()) {\n            final List<UserInfo> users = mUserManager.getUsers();\n            for (int i = users.size() - 1; i >= 0; --i) {\n                final int userId = users.get(i).id;\n                mInjector.getNetworkPolicyManagerInternal().setMeteredRestrictedPackagesAsync(\n                        getMeteredDisabledPackages(userId), userId);\n            }\n        }\n    }\n\n    private void pushActiveAdminPackagesLocked(int userId) {\n        mUsageStatsManagerInternal.setActiveAdminApps(\n                getActiveAdminPackagesLocked(userId), userId);\n    }\n\n    private Set<String> getActiveAdminPackagesLocked(int userId) {\n        final DevicePolicyData policy = getUserData(userId);\n        Set<String> adminPkgs = null;\n        for (int i = policy.mAdminList.size() - 1; i >= 0; --i) {\n            final String pkgName = policy.mAdminList.get(i).info.getPackageName();\n            if (adminPkgs == null) {\n                adminPkgs = new ArraySet<>();\n            }\n            adminPkgs.add(pkgName);\n        }\n        return adminPkgs;\n    }\n\n    private void transferActiveAdminUncheckedLocked(ComponentName incomingReceiver,\n            ComponentName outgoingReceiver, int userHandle) {\n        final DevicePolicyData policy = getUserData(userHandle);\n        if (!policy.mAdminMap.containsKey(outgoingReceiver)\n                && policy.mAdminMap.containsKey(incomingReceiver)) {\n            // Nothing to transfer - the incoming receiver is already the active admin.\n            return;\n        }\n        final DeviceAdminInfo incomingDeviceInfo = findAdmin(incomingReceiver, userHandle,\n            /* throwForMissingPermission= */ true);\n        final ActiveAdmin adminToTransfer = policy.mAdminMap.get(outgoingReceiver);\n        final int oldAdminUid = adminToTransfer.getUid();\n\n        if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n            EnforcingAdmin oldAdmin =\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            outgoingReceiver, userHandle, adminToTransfer);\n            EnforcingAdmin newAdmin =\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            incomingReceiver, userHandle, adminToTransfer);\n\n            mDevicePolicyEngine.transferPolicies(oldAdmin, newAdmin);\n        }\n\n        adminToTransfer.transfer(incomingDeviceInfo);\n        policy.mAdminMap.remove(outgoingReceiver);\n        policy.mAdminMap.put(incomingReceiver, adminToTransfer);\n        if (policy.mPasswordOwner == oldAdminUid) {\n            policy.mPasswordOwner = adminToTransfer.getUid();\n        }\n\n        saveSettingsLocked(userHandle);\n        sendAdminCommandLocked(adminToTransfer, DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED,\n                null, null);\n    }\n\n    private void checkActiveAdminPrecondition(ComponentName adminReceiver, DeviceAdminInfo info,\n            DevicePolicyData policy) {\n        if (info == null) {\n            throw new IllegalArgumentException(\"Bad admin: \" + adminReceiver);\n        }\n        if (!info.getActivityInfo().applicationInfo.isInternal()) {\n            throw new IllegalArgumentException(\"Only apps in internal storage can be active admin: \"\n                    + adminReceiver);\n        }\n        if (info.getActivityInfo().applicationInfo.isInstantApp()) {\n            throw new IllegalArgumentException(\"Instant apps cannot be device admins: \"\n                    + adminReceiver);\n        }\n        if (policy.mRemovingAdmins.contains(adminReceiver)) {\n            throw new IllegalArgumentException(\n                    \"Trying to set an admin which is being removed\");\n        }\n    }\n\n    private void checkAllUsersAreAffiliatedWithDevice() {\n        Preconditions.checkCallAuthorization(areAllUsersAffiliatedWithDeviceLocked(),\n                \"operation not allowed when device has unaffiliated users\");\n    }\n\n    @Override\n    public boolean isAdminActive(ComponentName adminReceiver, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            return getActiveAdminUncheckedLocked(adminReceiver, userHandle) != null;\n        }\n    }\n\n    @Override\n    public boolean isRemovingAdmin(ComponentName adminReceiver, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(userHandle);\n            return policyData.mRemovingAdmins.contains(adminReceiver);\n        }\n    }\n\n    @Override\n    public boolean hasGrantedPolicy(ComponentName adminReceiver, int policyId, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(\n                isCallingFromPackage(adminReceiver.getPackageName(), caller.getUid())\n                        || isSystemUid(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin administrator = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n            if (administrator == null) {\n                throw new SecurityException(\"No active admin \" + adminReceiver);\n            }\n            return administrator.info.usesPolicy(policyId);\n        }\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public List<ComponentName> getActiveAdmins(int userHandle) {\n        if (!mHasFeature) {\n            return Collections.EMPTY_LIST;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(userHandle);\n            final int N = policy.mAdminList.size();\n            if (N <= 0) {\n                return null;\n            }\n            ArrayList<ComponentName> res = new ArrayList<ComponentName>(N);\n            for (int i=0; i<N; i++) {\n                res.add(policy.mAdminList.get(i).info.getComponent());\n            }\n            return res;\n        }\n    }\n\n    @Override\n    public boolean packageHasActiveAdmins(String packageName, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(userHandle);\n            final int N = policy.mAdminList.size();\n            for (int i=0; i<N; i++) {\n                if (policy.mAdminList.get(i).info.getPackageName().equals(packageName)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    @Override\n    public void forceRemoveActiveAdmin(ComponentName adminReceiver, int userHandle) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(adminReceiver, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isAdb(getCallerIdentity())\n                        || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS),\n                \"Caller must be shell or hold MANAGE_PROFILE_AND_DEVICE_OWNERS to call \"\n                        + \"forceRemoveActiveAdmin\");\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            boolean isOrgOwnedProfile = false;\n            synchronized (getLockObject()) {\n                if (!isAdminTestOnlyLocked(adminReceiver, userHandle)) {\n                    throw new SecurityException(\"Attempt to remove non-test admin \"\n                            + adminReceiver + \" \" + userHandle);\n                }\n\n                // If admin is a device or profile owner tidy that up first.\n                if (isDeviceOwner(adminReceiver, userHandle)) {\n                    clearDeviceOwnerLocked(getDeviceOwnerAdminLocked(), userHandle);\n                }\n                if (isProfileOwner(adminReceiver, userHandle)) {\n                    isOrgOwnedProfile = isProfileOwnerOfOrganizationOwnedDevice(userHandle);\n                    final ActiveAdmin admin = getActiveAdminUncheckedLocked(adminReceiver,\n                            userHandle, /* parent */ false);\n                    clearProfileOwnerLocked(admin, userHandle);\n                }\n            }\n            // Remove the admin skipping sending the broadcast.\n            removeAdminArtifacts(adminReceiver, userHandle);\n\n            // In case of PO on org owned device, clean device-wide policies and restrictions.\n            if (isOrgOwnedProfile) {\n                final UserHandle parentUser = UserHandle.of(getProfileParentId(userHandle));\n                clearOrgOwnedProfileOwnerUserRestrictions(parentUser);\n                clearOrgOwnedProfileOwnerDeviceWidePolicies(parentUser.getIdentifier());\n            }\n\n            Slogf.i(LOG_TAG, \"Admin \" + adminReceiver + \" removed from user \" + userHandle);\n        });\n    }\n\n    private void clearOrgOwnedProfileOwnerUserRestrictions(UserHandle parentUserHandle) {\n        mUserManager.setUserRestriction(\n                UserManager.DISALLOW_REMOVE_MANAGED_PROFILE, false, parentUserHandle);\n        mUserManager.setUserRestriction(\n                UserManager.DISALLOW_ADD_USER, false, parentUserHandle);\n    }\n\n    private void clearDeviceOwnerUserRestriction(UserHandle userHandle) {\n        if (isHeadlessFlagEnabled()) {\n            for (int userId : mUserManagerInternal.getUserIds()) {\n                UserHandle user = UserHandle.of(userId);\n                // ManagedProvisioning/DPC sets DISALLOW_ADD_USER. Clear to recover to the\n                // original state\n                if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_USER, user)) {\n                    mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_USER,\n                            false, user);\n                }\n                // When a device owner is set, the system automatically restricts adding a\n                // managed profile.\n                // Remove this restriction when the device owner is cleared.\n                if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                        user)) {\n                    mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                            false,\n                            user);\n                }\n                // When a device owner is set, the system automatically restricts adding a\n                // clone profile.\n                // Remove this restriction when the device owner is cleared.\n                if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE, user)) {\n                    mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE,\n                            false, user);\n                }\n            }\n        } else {\n            // ManagedProvisioning/DPC sets DISALLOW_ADD_USER. Clear to recover to the original state\n            if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_USER, userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_USER, false,\n                        userHandle);\n            }\n            // When a device owner is set, the system automatically restricts adding a\n            // managed profile.\n            // Remove this restriction when the device owner is cleared.\n            if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                    userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                        false,\n                        userHandle);\n            }\n            // When a device owner is set, the system automatically restricts adding a clone\n            // profile.\n            // Remove this restriction when the device owner is cleared.\n            if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE,\n                    userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE,\n                        false,\n                        userHandle);\n            }\n        }\n    }\n\n    /**\n     * Return if a given package has testOnly=\"true\", in which case we'll relax certain rules\n     * for CTS.\n     *\n     * DO NOT use this method except in {@link #setActiveAdmin}.  Use {@link #isAdminTestOnlyLocked}\n     * to check wehter an active admin is test-only or not.\n     *\n     * The system allows this flag to be changed when an app is updated, which is not good\n     * for us.  So we persist the flag in {@link ActiveAdmin} when an admin is first installed,\n     * and used the persisted version in actual checks. (See b/31382361 and b/28928996)\n     */\n    private boolean isPackageTestOnly(String packageName, int userHandle) {\n        final ApplicationInfo ai;\n        try {\n            ai = mInjector.getIPackageManager().getApplicationInfo(packageName,\n                    (PackageManager.MATCH_DIRECT_BOOT_AWARE\n                            | PackageManager.MATCH_DIRECT_BOOT_UNAWARE), userHandle);\n        } catch (RemoteException e) {\n            throw new IllegalStateException(e);\n        }\n        if (ai == null) {\n            throw new IllegalStateException(\"Couldn't find package: \"\n                    + packageName + \" on user \" + userHandle);\n        }\n        return (ai.flags & ApplicationInfo.FLAG_TEST_ONLY) != 0;\n    }\n\n    /**\n     * See {@link #isPackageTestOnly}.\n     */\n    private boolean isAdminTestOnlyLocked(ComponentName who, int userHandle) {\n        final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n        return (admin != null) && admin.testOnlyAdmin;\n    }\n\n    @Override\n    public void removeActiveAdmin(ComponentName adminReceiver, int userHandle) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS)\n                ? getCallerIdentity() : getCallerIdentity(adminReceiver);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_REMOVE_ACTIVE_ADMIN);\n        enforceUserUnlocked(userHandle);\n\n        ActiveAdmin admin;\n        synchronized (getLockObject()) {\n            admin = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n            if (admin == null) {\n                return;\n            }\n            // Active device/profile owners must remain active admins.\n            if (isDeviceOwner(adminReceiver, userHandle)\n                    || isProfileOwner(adminReceiver, userHandle)) {\n                Slogf.e(LOG_TAG, \"Device/profile owner cannot be removed: component=\"\n                        + adminReceiver);\n                return;\n            }\n            mInjector.binderWithCleanCallingIdentity(() ->\n                    removeActiveAdminLocked(adminReceiver, userHandle));\n        }\n        if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n            mDevicePolicyEngine.removePoliciesForAdmin(\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            adminReceiver, userHandle, admin));\n        }\n    }\n\n    private boolean canSetPasswordQualityOnParent(String packageName, final CallerIdentity caller) {\n        return !mInjector.isChangeEnabled(\n                PREVENT_SETTING_PASSWORD_QUALITY_ON_PARENT, packageName, caller.getUserId())\n            || isProfileOwnerOfOrganizationOwnedDevice(caller);\n    }\n\n    private boolean isPasswordLimitingAdminTargetingP(CallerIdentity caller) {\n        if (!caller.hasAdminComponent()) {\n            return false;\n        }\n\n        synchronized (getLockObject()) {\n            return getActiveAdminWithPolicyForUidLocked(\n                    caller.getComponentName(), DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD,\n                    caller.getUid()) != null;\n        }\n    }\n\n    private boolean notSupportedOnAutomotive(String method) {\n        if (mIsAutomotive) {\n            Slogf.i(LOG_TAG, \"%s is not supported on automotive builds\", method);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public void setPasswordQuality(ComponentName who, int quality, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordQuality\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        validateQualityConstant(quality);\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                        || isSystemUid(caller) || isPasswordLimitingAdminTargetingP(caller));\n\n        if (parent) {\n            Preconditions.checkCallAuthorization(\n                    canSetPasswordQualityOnParent(who.getPackageName(), caller),\n                    \"Profile Owner may not apply password quality requirements device-wide\");\n        }\n\n        final int userId = caller.getUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n\n            // If setPasswordQuality is called on the parent, ensure that\n            // the primary admin does not have password complexity state (this is an\n            // unsupported state).\n            if (parent) {\n                final ActiveAdmin primaryAdmin = getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, false);\n                final boolean hasComplexitySet =\n                        primaryAdmin.mPasswordComplexity != PASSWORD_COMPLEXITY_NONE;\n                Preconditions.checkState(!hasComplexitySet,\n                        \"Cannot set password quality when complexity is set on the primary admin.\"\n                        + \" Set the primary admin's complexity to NONE first.\");\n            }\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n                if (passwordPolicy.quality != quality) {\n                    passwordPolicy.quality = quality;\n                    ap.mPasswordComplexity = PASSWORD_COMPLEXITY_NONE;\n                    resetInactivePasswordRequirementsIfRPlus(userId, ap);\n                    updatePasswordValidityCheckpointLocked(userId, parent);\n                    updatePasswordQualityCacheForUserGroup(userId);\n                    saveSettingsLocked(userId);\n                }\n                logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n            });\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_QUALITY)\n                .setAdmin(who)\n                .setInt(quality)\n                .setStrings(parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT)\n                .write();\n    }\n\n    private boolean passwordQualityInvocationOrderCheckEnabled(String packageName, int userId) {\n        return mInjector.isChangeEnabled(ADMIN_APP_PASSWORD_COMPLEXITY, packageName, userId);\n    }\n\n    /**\n     * For admins targeting R+ reset various password constraints to default values when quality is\n     * set to a value that makes those constraints that have no effect.\n     */\n    private void resetInactivePasswordRequirementsIfRPlus(int userId, ActiveAdmin admin) {\n        if (passwordQualityInvocationOrderCheckEnabled(admin.info.getPackageName(), userId)) {\n            final PasswordPolicy policy = admin.mPasswordPolicy;\n            if (policy.quality < PASSWORD_QUALITY_NUMERIC) {\n                policy.length = PasswordPolicy.DEF_MINIMUM_LENGTH;\n            }\n            if (policy.quality < PASSWORD_QUALITY_COMPLEX) {\n                policy.letters = PasswordPolicy.DEF_MINIMUM_LETTERS;\n                policy.upperCase = PasswordPolicy.DEF_MINIMUM_UPPER_CASE;\n                policy.lowerCase = PasswordPolicy.DEF_MINIMUM_LOWER_CASE;\n                policy.numeric = PasswordPolicy.DEF_MINIMUM_NUMERIC;\n                policy.symbols = PasswordPolicy.DEF_MINIMUM_SYMBOLS;\n                policy.nonLetter = PasswordPolicy.DEF_MINIMUM_NON_LETTER;\n            }\n        }\n    }\n\n    /**\n     * Updates a flag that tells us whether the user's password currently satisfies the\n     * requirements set by all of the user's active admins.\n     * This should be called whenever the password or the admin policies have changed. The caller\n     * is responsible for calling {@link #saveSettingsLocked} to persist the change.\n     *\n     * @return the set of user IDs that have been affected\n     */\n    @GuardedBy(\"getLockObject()\")\n    private Set<Integer> updatePasswordValidityCheckpointLocked(int userHandle, boolean parent) {\n        final ArraySet<Integer> affectedUserIds = new ArraySet<>();\n        final int credentialOwner = getCredentialOwner(userHandle, parent);\n        DevicePolicyData policy = getUserData(credentialOwner);\n        PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(credentialOwner);\n        // Update the checkpoint only if the user's password metrics is known\n        if (metrics != null) {\n            final int userToCheck = getProfileParentUserIfRequested(userHandle, parent);\n            final boolean newCheckpoint = isPasswordSufficientForUserWithoutCheckpointLocked(\n                    metrics, userToCheck);\n            if (newCheckpoint != policy.mPasswordValidAtLastCheckpoint) {\n                policy.mPasswordValidAtLastCheckpoint = newCheckpoint;\n                affectedUserIds.add(credentialOwner);\n            }\n        }\n        return affectedUserIds;\n    }\n\n    /**\n     * Update password quality values in policy cache for all users in the same user group as\n     * the given user. The cached password quality for user X is the aggregated quality among all\n     * admins who have influence of user X's screenlock, i.e. it's equivalent to the return value of\n     * getPasswordQuality(null, user X, false).\n     *\n     * Caches for all users in the same user group often need to be updated alltogether because a\n     * user's admin policy can affect another's aggregated password quality in some situation.\n     * For example a managed profile's policy will affect the parent user if the profile has unified\n     * challenge. A profile can also explicitly set a parent password quality which will affect the\n     * aggregated password quality of the parent user.\n     */\n    private void updatePasswordQualityCacheForUserGroup(@UserIdInt int userId) {\n        final List<UserInfo> users;\n        if (userId == UserHandle.USER_ALL) {\n            users = mUserManager.getUsers();\n        } else {\n            users = mUserManager.getProfiles(userId);\n        }\n        for (UserInfo userInfo : users) {\n            final int currentUserId = userInfo.id;\n            mPolicyCache.setPasswordQuality(currentUserId,\n                    getPasswordQuality(null, currentUserId, false));\n        }\n    }\n\n    @Override\n    public int getPasswordQuality(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return PASSWORD_QUALITY_UNSPECIFIED;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        // System caller can query policy for a particular admin.\n        Preconditions.checkCallAuthorization(\n                who == null || isCallingFromPackage(who.getPackageName(), caller.getUid())\n                        || canQueryAdminPolicy(caller));\n\n        synchronized (getLockObject()) {\n            int mode = PASSWORD_QUALITY_UNSPECIFIED;\n\n            if (who != null) {\n                ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                return admin != null ? admin.mPasswordPolicy.quality : mode;\n            }\n\n            // Return the strictest policy across all participating admins.\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                ActiveAdmin admin = admins.get(i);\n                if (mode < admin.mPasswordPolicy.quality) {\n                    mode = admin.mPasswordPolicy.quality;\n                }\n            }\n            return mode;\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private List<ActiveAdmin> getActiveAdminsForLockscreenPoliciesLocked(int userHandle) {\n        if (isSeparateProfileChallengeEnabled(userHandle)) {\n\n            if (isPermissionCheckFlagEnabled()) {\n                return getActiveAdminsForAffectedUserInclPermissionBasedAdminLocked(userHandle);\n            }\n            // If this user has a separate challenge, only return its restrictions.\n            return getUserDataUnchecked(userHandle).mAdminList;\n        }\n        // If isSeparateProfileChallengeEnabled is false and userHandle points to a managed profile\n        // we need to query the parent user who owns the credential.\n        if (isPermissionCheckFlagEnabled()) {\n            return getActiveAdminsForUserAndItsManagedProfilesInclPermissionBasedAdminLocked(getProfileParentId(userHandle),\n                    (user) -> !mLockPatternUtils.isSeparateProfileChallengeEnabled(user.id));\n        } else {\n            return getActiveAdminsForUserAndItsManagedProfilesLocked(getProfileParentId(userHandle),\n                    (user) -> !mLockPatternUtils.isSeparateProfileChallengeEnabled(user.id));\n        }\n\n    }\n\n    /**\n     * Get the list of active admins for an affected user:\n     * <ul>\n     * <li>The active admins associated with the userHandle itself</li>\n     * <li>The parent active admins for each managed profile associated with the userHandle</li>\n     * </ul>\n     *\n     * @param userHandle the affected user for whom to get the active admins\n     * @return the list of active admins for the affected user\n     */\n    @GuardedBy(\"getLockObject()\")\n    private List<ActiveAdmin> getActiveAdminsForAffectedUserLocked(int userHandle) {\n        if (isManagedProfile(userHandle)) {\n            return getUserDataUnchecked(userHandle).mAdminList;\n        }\n        return getActiveAdminsForUserAndItsManagedProfilesLocked(userHandle,\n                /* shouldIncludeProfileAdmins */ (user) -> false);\n    }\n\n    /**\n     * Get the list of active admins for an affected user:\n     * <ul>\n     * <li>The active admins associated with the userHandle itself</li>\n     * <li>The parent active admins for each managed profile associated with the userHandle</li>\n     * <li>The permission based admin associated with the userHandle itself</li>\n     * </ul>\n     *\n     * @param userHandle the affected user for whom to get the active admins\n     * @return the list of active admins for the affected user\n     */\n    @GuardedBy(\"getLockObject()\")\n    private List<ActiveAdmin> getActiveAdminsForAffectedUserInclPermissionBasedAdminLocked(\n            int userHandle) {\n        List<ActiveAdmin> list;\n\n        if (isManagedProfile(userHandle)) {\n            list = getUserDataUnchecked(userHandle).mAdminList;\n        }\n        list = getActiveAdminsForUserAndItsManagedProfilesInclPermissionBasedAdminLocked(userHandle,\n                /* shouldIncludeProfileAdmins */ (user) -> false);\n\n        if (getUserData(userHandle).mPermissionBasedAdmin != null) {\n            list.add(getUserData(userHandle).mPermissionBasedAdmin);\n        }\n        return list;\n    }\n\n    /**\n     * Returns the list of admins on the given user, as well as parent admins for each managed\n     * profile associated with the given user. Optionally also include the admin of each managed\n     * profile.\n     * <p> Should not be called on a profile user.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private List<ActiveAdmin> getActiveAdminsForUserAndItsManagedProfilesLocked(int userHandle,\n            Predicate<UserInfo> shouldIncludeProfileAdmins) {\n        ArrayList<ActiveAdmin> admins = new ArrayList<>();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo userInfo : mUserManager.getProfiles(userHandle)) {\n                DevicePolicyData policy = getUserDataUnchecked(userInfo.id);\n                if (userInfo.id == userHandle) {\n                    admins.addAll(policy.mAdminList);\n                } else if (userInfo.isManagedProfile()) {\n                    for (int i = 0; i < policy.mAdminList.size(); i++) {\n                        ActiveAdmin admin = policy.mAdminList.get(i);\n                        if (admin.hasParentActiveAdmin()) {\n                            admins.add(admin.getParentActiveAdmin());\n                        }\n                        if (shouldIncludeProfileAdmins.test(userInfo)) {\n                            admins.add(admin);\n                        }\n                    }\n                }\n            }\n        });\n        return admins;\n    }\n\n    /**\n     * Returns the list of admins on the given user, as well as parent admins for each managed\n     * profile associated with the given user. Optionally also include the admin of each managed\n     * profile.\n     * <p> Should not be called on a profile user.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private List<ActiveAdmin> getActiveAdminsForUserAndItsManagedProfilesInclPermissionBasedAdminLocked(int userHandle,\n            Predicate<UserInfo> shouldIncludeProfileAdmins) {\n        ArrayList<ActiveAdmin> admins = new ArrayList<>();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo userInfo : mUserManager.getProfiles(userHandle)) {\n                DevicePolicyData policy = getUserDataUnchecked(userInfo.id);\n                if (userInfo.id == userHandle) {\n                    admins.addAll(policy.mAdminList);\n                    if (policy.mPermissionBasedAdmin != null) {\n                        admins.add(policy.mPermissionBasedAdmin);\n                    }\n                } else if (userInfo.isManagedProfile()) {\n                    for (int i = 0; i < policy.mAdminList.size(); i++) {\n                        ActiveAdmin admin = policy.mAdminList.get(i);\n                        if (admin.hasParentActiveAdmin()) {\n                            admins.add(admin.getParentActiveAdmin());\n                        }\n                        if (shouldIncludeProfileAdmins.test(userInfo)) {\n                            admins.add(admin);\n                        }\n                    }\n                    if (policy.mPermissionBasedAdmin != null\n                            && shouldIncludeProfileAdmins.test(userInfo)) {\n                        admins.add(policy.mPermissionBasedAdmin);\n                    }\n                }\n            }\n        });\n        return admins;\n    }\n\n    private boolean isSeparateProfileChallengeEnabled(int userHandle) {\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mLockPatternUtils.isSeparateProfileChallengeEnabled(userHandle));\n    }\n\n    @Override\n    public void setPasswordMinimumLength(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumLength\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(userId, ap, PASSWORD_QUALITY_NUMERIC, \"setPasswordMinimumLength\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.length != length) {\n                passwordPolicy.length = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_LENGTH)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    private void ensureMinimumQuality(\n            int userId, ActiveAdmin admin, int minimumQuality, String operation) {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            // This check will also take care of the case where the password requirements\n            // are specified as complexity rather than quality: When a password complexity\n            // is set, the quality is reset to \"unspecified\" which will be below any value\n            // of minimumQuality.\n            if (admin.mPasswordPolicy.quality < minimumQuality\n                    && passwordQualityInvocationOrderCheckEnabled(admin.info.getPackageName(),\n                    userId)) {\n                throw new IllegalStateException(String.format(\n                        \"password quality should be at least %d for %s\",\n                        minimumQuality, operation));\n            }\n        });\n    }\n\n    @Override\n    public int getPasswordMinimumLength(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.length, PASSWORD_QUALITY_NUMERIC);\n    }\n\n    @Override\n    public void setPasswordHistoryLength(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            if (ap.passwordHistoryLength != length) {\n                ap.passwordHistoryLength = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            final int affectedUserId = parent ? getProfileParentId(userId) : userId;\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_HISTORY_LENGTH_SET,\n                    who.getPackageName(), userId, affectedUserId, length);\n        }\n    }\n\n    @Override\n    public int getPasswordHistoryLength(ComponentName who, int userHandle, boolean parent) {\n        if (!mLockPatternUtils.hasSecureLockScreen()) {\n            return 0;\n        }\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.passwordHistoryLength, PASSWORD_QUALITY_UNSPECIFIED);\n    }\n\n    @Override\n    public void setPasswordExpirationTimeout(ComponentName who, String callerPackageName,\n            long timeout, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n        if (!isPermissionCheckFlagEnabled()) {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n        }\n\n        Preconditions.checkArgumentNonnegative(timeout, \"Timeout must be >= 0 ms\");\n        int userHandle = mInjector.userHandleGetCallingUserId();\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n        synchronized (getLockObject()) {\n            ActiveAdmin ap;\n            if (isPermissionCheckFlagEnabled()) {\n                CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n                ap = enforcePermissionAndGetEnforcingAdmin(\n                        who, MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                        caller.getPackageName(), affectedUserId)\n                        .getActiveAdmin();\n            } else {\n                ap = getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_EXPIRE_PASSWORD, parent);\n            }\n            // Calling this API automatically bumps the expiration date\n            final long expiration = timeout > 0L ? (timeout + System.currentTimeMillis()) : 0L;\n            ap.passwordExpirationDate = expiration;\n            ap.passwordExpirationTimeout = timeout;\n            if (timeout > 0L) {\n                Slogf.w(LOG_TAG, \"setPasswordExpiration(): password will expire on \"\n                        + DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT)\n                        .format(new Date(expiration)));\n            }\n            saveSettingsLocked(userHandle);\n\n            // in case this is the first one, set the alarm on the appropriate user.\n            setExpirationAlarmCheckLocked(mContext, userHandle, parent);\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_EXPIRATION_SET, callerPackageName,\n                    userHandle, affectedUserId, timeout);\n        }\n    }\n\n    /**\n     * Return a single admin's expiration cycle time, or the min of all cycle times.\n     * Returns 0 if not configured.\n     */\n    @Override\n    public long getPasswordExpirationTimeout(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return 0L;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            long timeout = 0L;\n\n            if (who != null) {\n                ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                return admin != null ? admin.passwordExpirationTimeout : timeout;\n            }\n\n            // Return the strictest policy across all participating admins.\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                ActiveAdmin admin = admins.get(i);\n                if (timeout == 0L || (admin.passwordExpirationTimeout != 0L\n                        && timeout > admin.passwordExpirationTimeout)) {\n                    timeout = admin.passwordExpirationTimeout;\n                }\n            }\n            return timeout;\n        }\n    }\n\n    @Override\n    public boolean addCrossProfileWidgetProvider(ComponentName admin, String callerPackageName,\n            String packageName) {\n        CallerIdentity caller;\n\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n        ActiveAdmin activeAdmin;\n\n        if (isPermissionCheckFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            activeAdmin = enforcingAdmin.getActiveAdmin();\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwner(caller));\n            synchronized (getLockObject()) {\n                activeAdmin = getProfileOwnerLocked(caller.getUserId());\n            }\n        }\n        List<String> changedProviders = null;\n\n        synchronized (getLockObject()) {\n            if (activeAdmin.crossProfileWidgetProviders == null) {\n                activeAdmin.crossProfileWidgetProviders = new ArrayList<>();\n            }\n            List<String> providers = activeAdmin.crossProfileWidgetProviders;\n            if (!providers.contains(packageName)) {\n                providers.add(packageName);\n                changedProviders = new ArrayList<>(providers);\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_CROSS_PROFILE_WIDGET_PROVIDER)\n                .setAdmin(caller.getPackageName())\n                .write();\n\n        if (changedProviders != null) {\n            mLocalService.notifyCrossProfileProvidersChanged(caller.getUserId(),\n                    changedProviders);\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean removeCrossProfileWidgetProvider(ComponentName admin, String callerPackageName,\n            String packageName) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n\n        ActiveAdmin activeAdmin;\n\n        if (isPermissionCheckFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            activeAdmin = enforcingAdmin.getActiveAdmin();\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwner(caller));\n            synchronized (getLockObject()) {\n                activeAdmin = getProfileOwnerLocked(caller.getUserId());\n            }\n        }\n        List<String> changedProviders = null;\n\n        synchronized (getLockObject()) {\n            if (activeAdmin.crossProfileWidgetProviders == null\n                    || activeAdmin.crossProfileWidgetProviders.isEmpty()) {\n                return false;\n            }\n            List<String> providers = activeAdmin.crossProfileWidgetProviders;\n            if (providers.remove(packageName)) {\n                changedProviders = new ArrayList<>(providers);\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.REMOVE_CROSS_PROFILE_WIDGET_PROVIDER)\n                .setAdmin(caller.getPackageName())\n                .write();\n\n        if (changedProviders != null) {\n            mLocalService.notifyCrossProfileProvidersChanged(caller.getUserId(),\n                    changedProviders);\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public List<String> getCrossProfileWidgetProviders(ComponentName admin,\n            String callerPackageName) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n        ActiveAdmin activeAdmin;\n\n        if (isPermissionCheckFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforceCanQueryAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            activeAdmin = enforcingAdmin.getActiveAdmin();\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwner(caller));\n            synchronized (getLockObject()) {\n                activeAdmin = getProfileOwnerLocked(caller.getUserId());\n            }\n        }\n\n        synchronized (getLockObject()) {\n            if (activeAdmin.crossProfileWidgetProviders == null\n                    || activeAdmin.crossProfileWidgetProviders.isEmpty()) {\n                return null;\n            }\n            if (mInjector.binderIsCallingUidMyUid()) {\n                return new ArrayList<>(activeAdmin.crossProfileWidgetProviders);\n            } else {\n                return activeAdmin.crossProfileWidgetProviders;\n            }\n        }\n    }\n\n    /**\n     * Return a single admin's expiration date/time, or the min (soonest) for all admins.\n     * Returns 0 if not configured.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private long getPasswordExpirationLocked(ComponentName who, int userHandle, boolean parent) {\n        long timeout = 0L;\n\n        if (who != null) {\n            ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n            return admin != null ? admin.passwordExpirationDate : timeout;\n        }\n\n        // Return the strictest policy across all participating admins.\n        List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                getProfileParentUserIfRequested(userHandle, parent));\n        final int N = admins.size();\n        for (int i = 0; i < N; i++) {\n            ActiveAdmin admin = admins.get(i);\n            if (timeout == 0L || (admin.passwordExpirationDate != 0\n                    && timeout > admin.passwordExpirationDate)) {\n                timeout = admin.passwordExpirationDate;\n            }\n        }\n        return timeout;\n    }\n\n    @Override\n    public long getPasswordExpiration(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return 0L;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            return getPasswordExpirationLocked(who, userHandle, parent);\n        }\n    }\n\n    @Override\n    public void setPasswordMinimumUpperCase(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumUpperCase\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            final ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(\n                    userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumUpperCase\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.upperCase != length) {\n                passwordPolicy.upperCase = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_UPPER_CASE)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumUpperCase(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.upperCase, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumLowerCase(ComponentName who, int length, boolean parent) {\n        if (notSupportedOnAutomotive(\"setPasswordMinimumLowerCase\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(\n                    userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumLowerCase\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.lowerCase != length) {\n                passwordPolicy.lowerCase = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_LOWER_CASE)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumLowerCase(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.lowerCase, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumLetters(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumLetters\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumLetters\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.letters != length) {\n                passwordPolicy.letters = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_LETTERS)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumLetters(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.letters, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumNumeric(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumNumeric\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumNumeric\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.numeric != length) {\n                passwordPolicy.numeric = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_NUMERIC)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumNumeric(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.numeric, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumSymbols(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumSymbols\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumSymbols\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.symbols != length) {\n                ap.mPasswordPolicy.symbols = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_SYMBOLS)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumSymbols(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.symbols, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumNonLetter(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumNonLetter\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(\n                    userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumNonLetter\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.nonLetter != length) {\n                ap.mPasswordPolicy.nonLetter = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_NON_LETTER)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumNonLetter(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.nonLetter, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    /**\n     * Calculates strictest (maximum) value for a given password property enforced by admin[s].\n     */\n    private int getStrictestPasswordRequirement(ComponentName who, int userHandle,\n            boolean parent, Function<ActiveAdmin, Integer> getter, int minimumPasswordQuality) {\n        if (!mHasFeature) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            if (who != null) {\n                final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                return admin != null ? getter.apply(admin) : 0;\n            }\n\n            int maxValue = 0;\n            final List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                final ActiveAdmin admin = admins.get(i);\n                if (!isLimitPasswordAllowed(admin, minimumPasswordQuality)) {\n                    continue;\n                }\n                final Integer adminValue = getter.apply(admin);\n                if (adminValue > maxValue) {\n                    maxValue = adminValue;\n                }\n            }\n            return maxValue;\n        }\n    }\n\n    /**\n     * Calculates strictest (maximum) value for a given password property enforced by admin[s].\n     */\n    @Override\n    public PasswordMetrics getPasswordMinimumMetrics(@UserIdInt int userHandle,\n            boolean deviceWideOnly) {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle)\n                && (isSystemUid(caller) || hasCallingOrSelfPermission(\n                permission.SET_INITIAL_LOCK)));\n        return getPasswordMinimumMetricsUnchecked(userHandle, deviceWideOnly);\n    }\n\n    private PasswordMetrics getPasswordMinimumMetricsUnchecked(@UserIdInt int userId) {\n        return getPasswordMinimumMetricsUnchecked(userId, false);\n    }\n\n    private PasswordMetrics getPasswordMinimumMetricsUnchecked(@UserIdInt int userId,\n            boolean deviceWideOnly) {\n        if (!mHasFeature) {\n            new PasswordMetrics(CREDENTIAL_TYPE_NONE);\n        }\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n        if (deviceWideOnly) {\n            Preconditions.checkArgument(!isManagedProfile(userId));\n        }\n\n        ArrayList<PasswordMetrics> adminMetrics = new ArrayList<>();\n        final List<ActiveAdmin> admins;\n        synchronized (getLockObject()) {\n            if (deviceWideOnly) {\n                admins = getActiveAdminsForUserAndItsManagedProfilesLocked(userId,\n                        /* shouldIncludeProfileAdmins */ (user) -> false);\n            } else {\n                admins = getActiveAdminsForLockscreenPoliciesLocked(userId);\n            }\n            for (ActiveAdmin admin : admins) {\n                adminMetrics.add(admin.mPasswordPolicy.getMinMetrics());\n            }\n        }\n        return PasswordMetrics.merge(adminMetrics);\n    }\n\n    @Override\n    public boolean isActivePasswordSufficient(\n            String callerPackageName, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        enforceUserUnlocked(userHandle, parent);\n\n        synchronized (getLockObject()) {\n            if (isPermissionCheckFlagEnabled()) {\n                int affectedUser = parent ? getProfileParentId(userHandle) : userHandle;\n                enforcePermission(MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                        callerPackageName, affectedUser);\n            } else {\n                // This API can only be called by an active device admin,\n                // so try to retrieve it to check that the caller is one.\n                getActiveAdminForCallerLocked(\n                        null, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            }\n\n            int credentialOwner = getCredentialOwner(userHandle, parent);\n            DevicePolicyData policy = getUserDataUnchecked(credentialOwner);\n            PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(credentialOwner);\n            final int userToCheck = getProfileParentUserIfRequested(userHandle, parent);\n            boolean activePasswordSufficientForUserLocked = isActivePasswordSufficientForUserLocked(\n                    policy.mPasswordValidAtLastCheckpoint, metrics, userToCheck);\n            return activePasswordSufficientForUserLocked;\n        }\n    }\n\n    @Override\n    public boolean isActivePasswordSufficientForDeviceRequirement() {\n        if (!mHasFeature) {\n            return true;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        final int profileUserId = caller.getUserId();\n        Preconditions.checkCallingUser(isManagedProfile(profileUserId));\n\n        // This method is always called on the parent DPM instance to check if its password (i.e.\n        // the device password) is sufficient for all explicit password requirement set on it\n        // So retrieve the parent user Id to which the device password belongs.\n        final int parentUser = getProfileParentId(profileUserId);\n        enforceUserUnlocked(parentUser);\n\n        final boolean isSufficient;\n        synchronized (getLockObject()) {\n\n            int complexity = getAggregatedPasswordComplexityLocked(parentUser, true);\n            PasswordMetrics minMetrics = getPasswordMinimumMetricsUnchecked(parentUser, true);\n\n            PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(parentUser);\n            final List<PasswordValidationError> passwordValidationErrors =\n                    PasswordMetrics.validatePasswordMetrics(minMetrics, complexity, metrics);\n            isSufficient = passwordValidationErrors.isEmpty();\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.IS_ACTIVE_PASSWORD_SUFFICIENT_FOR_DEVICE)\n                .setStrings(mOwners.getProfileOwnerComponent(caller.getUserId()).getPackageName())\n                .write();\n        return isSufficient;\n    }\n\n    @Override\n    public boolean isUsingUnifiedPassword(ComponentName admin) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isProfileOwner(caller));\n        Preconditions.checkCallingUser(isManagedProfile(caller.getUserId()));\n\n        return !isSeparateProfileChallengeEnabled(caller.getUserId());\n    }\n\n    @Override\n    public boolean isPasswordSufficientAfterProfileUnification(int userHandle, int profileUser) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(!isManagedProfile(userHandle),\n                \"You can not check password sufficiency for a managed profile, userId = %d\",\n                userHandle);\n        enforceUserUnlocked(userHandle);\n\n        synchronized (getLockObject()) {\n            PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(userHandle);\n\n            // Combine password policies across the user and its profiles. Profile admins are\n            // included if the profile is to be unified or currently has unified challenge\n            List<ActiveAdmin> admins = getActiveAdminsForUserAndItsManagedProfilesLocked(userHandle,\n                    /* shouldIncludeProfileAdmins */ (user) -> user.id == profileUser\n                    || !mLockPatternUtils.isSeparateProfileChallengeEnabled(user.id));\n            ArrayList<PasswordMetrics> adminMetrics = new ArrayList<>(admins.size());\n            int maxRequiredComplexity = PASSWORD_COMPLEXITY_NONE;\n            for (ActiveAdmin admin : admins) {\n                adminMetrics.add(admin.mPasswordPolicy.getMinMetrics());\n                maxRequiredComplexity = Math.max(maxRequiredComplexity, admin.mPasswordComplexity);\n            }\n            return PasswordMetrics.validatePasswordMetrics(PasswordMetrics.merge(adminMetrics),\n                    maxRequiredComplexity, metrics).isEmpty();\n        }\n    }\n\n    private boolean isActivePasswordSufficientForUserLocked(\n            boolean passwordValidAtLastCheckpoint, @Nullable PasswordMetrics metrics,\n            int userHandle) {\n        if (!mInjector.storageManagerIsFileBasedEncryptionEnabled() && (metrics == null)) {\n            // Before user enters their password for the first time after a reboot, return the\n            // value of this flag, which tells us whether the password was valid the last time\n            // settings were saved.  If DPC changes password requirements on boot so that the\n            // current password no longer meets the requirements, this value will be stale until\n            // the next time the password is entered.\n            return passwordValidAtLastCheckpoint;\n        }\n\n        if (metrics == null) {\n            // Called on a FBE device when the user password exists but its metrics is unknown.\n            // This shouldn't happen since we enforce the user to be unlocked (which would result\n            // in the metrics known to the framework on a FBE device) at all call sites.\n            throw new IllegalStateException(\"isActivePasswordSufficient called on FBE-locked user\");\n        }\n\n        return isPasswordSufficientForUserWithoutCheckpointLocked(metrics, userHandle);\n    }\n\n    /**\n     * Returns {@code true} if the password represented by the {@code metrics} argument\n     * sufficiently fulfills the password requirements for the user corresponding to\n     * {@code userId}.\n     */\n    private boolean isPasswordSufficientForUserWithoutCheckpointLocked(\n            @NonNull PasswordMetrics metrics, @UserIdInt int userId) {\n        final int complexity = getAggregatedPasswordComplexityLocked(userId);\n        PasswordMetrics minMetrics = getPasswordMinimumMetricsUnchecked(userId);\n        final List<PasswordValidationError> passwordValidationErrors =\n                PasswordMetrics.validatePasswordMetrics(minMetrics, complexity, metrics);\n        return passwordValidationErrors.isEmpty();\n    }\n\n    @Override\n    @PasswordComplexity\n    public int getPasswordComplexity(boolean parent) {\n        final CallerIdentity caller = getCallerIdentity();\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.GET_USER_PASSWORD_COMPLEXITY_LEVEL)\n                .setStrings(parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT,\n                        mInjector.getPackageManager().getPackagesForUid(caller.getUid()))\n                .write();\n\n        enforceUserUnlocked(caller.getUserId());\n        if (parent) {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller) || isSystemUid(caller),\n                    \"Only profile owner, device owner and system may call this method on parent.\");\n        } else {\n            if (isPermissionCheckFlagEnabled()) {\n                Preconditions.checkCallAuthorization(\n                        hasCallingOrSelfPermission(REQUEST_PASSWORD_COMPLEXITY)\n                                || hasCallingOrSelfPermission(MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS)\n                                || isDefaultDeviceOwner(caller) || isProfileOwner(caller),\n                        \"Must have \" + REQUEST_PASSWORD_COMPLEXITY + \" or \" +\n                                MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS\n                                + \" permissions, or be a profile owner or device owner.\");\n            } else {\n                Preconditions.checkCallAuthorization(\n                        hasCallingOrSelfPermission(REQUEST_PASSWORD_COMPLEXITY)\n                                || isDefaultDeviceOwner(caller) || isProfileOwner(caller),\n                        \"Must have \" + REQUEST_PASSWORD_COMPLEXITY\n                                + \" permission, or be a profile owner or device owner.\");\n            }\n        }\n\n        synchronized (getLockObject()) {\n            final int credentialOwner = getCredentialOwner(caller.getUserId(), parent);\n            PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(credentialOwner);\n            return metrics == null ? PASSWORD_COMPLEXITY_NONE : metrics.determineComplexity();\n        }\n    }\n\n    @Override\n    public void setRequiredPasswordComplexity(\n            String callerPackageName, int passwordComplexity, boolean calledOnParent) {\n        if (!mHasFeature) {\n            return;\n        }\n        final Set<Integer> allowedModes = Set.of(PASSWORD_COMPLEXITY_NONE, PASSWORD_COMPLEXITY_LOW,\n                PASSWORD_COMPLEXITY_MEDIUM, PASSWORD_COMPLEXITY_HIGH);\n        Preconditions.checkArgument(allowedModes.contains(passwordComplexity),\n                \"Provided complexity is not one of the allowed values.\");\n\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        if (!isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n            Preconditions.checkArgument(!calledOnParent || isProfileOwner(caller));\n        }\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            if (isPermissionCheckFlagEnabled()) {\n                // TODO: Make sure this returns the parent of the fake admin\n                // TODO: Deal with null componentname\n                int affectedUser = calledOnParent\n                        ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n                admin = enforcePermissionAndGetEnforcingAdmin(\n                        null, MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                        caller.getPackageName(), affectedUser).getActiveAdmin();\n            } else {\n                admin = getParentOfAdminIfRequired(\n                        getProfileOwnerOrDeviceOwnerLocked(caller.getUserId()), calledOnParent);\n            }\n\n            if (admin.mPasswordComplexity != passwordComplexity) {\n                // We require the caller to explicitly clear any password quality requirements set\n                // on the parent DPM instance, to avoid the case where password requirements are\n                // specified in the form of quality on the parent but complexity on the profile\n                // itself.\n                if (!calledOnParent) {\n                    final boolean hasQualityRequirementsOnParent = admin.hasParentActiveAdmin()\n                            && admin.getParentActiveAdmin().mPasswordPolicy.quality\n                            != PASSWORD_QUALITY_UNSPECIFIED;\n                    Preconditions.checkState(!hasQualityRequirementsOnParent,\n                            \"Password quality is set on the parent when attempting to set password\"\n                            + \"complexity. Clear the quality by setting the password quality \"\n                            + \"on the parent to PASSWORD_QUALITY_UNSPECIFIED first\");\n                }\n\n                mInjector.binderWithCleanCallingIdentity(() -> {\n                    admin.mPasswordComplexity = passwordComplexity;\n                    // Reset the password policy.\n                    admin.mPasswordPolicy = new PasswordPolicy();\n                    updatePasswordValidityCheckpointLocked(caller.getUserId(), calledOnParent);\n                    updatePasswordQualityCacheForUserGroup(caller.getUserId());\n                    saveSettingsLocked(caller.getUserId());\n                });\n\n\n                //TODO(b/276855301): caller.getPackageName() will be null when the coexistence flags are\n                // turned off. Change back to caller.getPackageName once this API is unflagged.\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.SET_PASSWORD_COMPLEXITY)\n                        .setAdmin(admin.info.getPackageName())\n                        .setInt(passwordComplexity)\n                        .setBoolean(calledOnParent)\n                        .write();\n            }\n            logPasswordComplexityRequiredIfSecurityLogEnabled(caller.getPackageName(),\n                    caller.getUserId(), calledOnParent, passwordComplexity);\n        }\n    }\n\n    private void logPasswordComplexityRequiredIfSecurityLogEnabled(String adminPackageName,\n            int userId,\n            boolean parent, int complexity) {\n        if (SecurityLog.isLoggingEnabled()) {\n            final int affectedUserId = parent ? getProfileParentId(userId) : userId;\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_COMPLEXITY_REQUIRED,\n                    adminPackageName, userId, affectedUserId, complexity);\n        }\n    }\n    @GuardedBy(\"getLockObject()\")\n    private int getAggregatedPasswordComplexityLocked(@UserIdInt int userHandle) {\n        return getAggregatedPasswordComplexityLocked(userHandle, false);\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private int getAggregatedPasswordComplexityLocked(@UserIdInt int userHandle,\n            boolean deviceWideOnly) {\n        ensureLocked();\n        final List<ActiveAdmin> admins;\n        if (deviceWideOnly) {\n            admins = getActiveAdminsForUserAndItsManagedProfilesLocked(userHandle,\n                    /* shouldIncludeProfileAdmins */ (user) -> false);\n        } else {\n            admins = getActiveAdminsForLockscreenPoliciesLocked(userHandle);\n        }\n        int maxRequiredComplexity = PASSWORD_COMPLEXITY_NONE;\n        for (ActiveAdmin admin : admins) {\n            maxRequiredComplexity = Math.max(maxRequiredComplexity, admin.mPasswordComplexity);\n        }\n        return maxRequiredComplexity;\n    }\n\n    @Override\n    public int getRequiredPasswordComplexity(String callerPackageName, boolean calledOnParent) {\n        if (!mHasFeature) {\n            return PASSWORD_COMPLEXITY_NONE;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n\n        if (isPermissionCheckFlagEnabled()) {\n            int affectedUser = calledOnParent ? getProfileParentId(caller.getUserId())\n                    : caller.getUserId();\n            enforcePermission(MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                    callerPackageName, affectedUser);\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n            Preconditions.checkArgument(!calledOnParent || isProfileOwner(caller));\n        }\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin requiredAdmin = getParentOfAdminIfRequired(\n                    getDeviceOrProfileOwnerAdminLocked(caller.getUserId()), calledOnParent);\n            return requiredAdmin.mPasswordComplexity;\n        }\n    }\n\n    @Override\n    public int getAggregatedPasswordComplexityForUser(int userId, boolean deviceWideOnly) {\n        if (!mHasFeature) {\n            return PASSWORD_COMPLEXITY_NONE;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            return getAggregatedPasswordComplexityLocked(userId, deviceWideOnly);\n        }\n    }\n\n\n    @Override\n    public int getCurrentFailedPasswordAttempts(\n            String callerPackageName, int userHandle, boolean parent) {\n        if (!mLockPatternUtils.hasSecureLockScreen()) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            if (!isSystemUid(caller)) {\n                // This API can be called by an active device admin or by keyguard code.\n                if (!hasCallingPermission(permission.ACCESS_KEYGUARD_SECURE_STORAGE)) {\n                    if (isPermissionCheckFlagEnabled()) {\n                        int affectedUser = parent ? getProfileParentId(userHandle) : userHandle;\n                        enforcePermission(MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                                callerPackageName, affectedUser);\n                    } else {\n                        getActiveAdminForCallerLocked(\n                                null, DeviceAdminInfo.USES_POLICY_WATCH_LOGIN, parent);\n                    }\n                }\n            }\n\n            DevicePolicyData policy = getUserDataUnchecked(getCredentialOwner(userHandle, parent));\n\n            return policy.mFailedPasswordAttempts;\n        }\n    }\n\n    @Override\n    public void setMaximumFailedPasswordsForWipe(\n            ComponentName who, String callerPackageName, int num, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n\n        if (!isPermissionCheckFlagEnabled()) {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n        }\n\n\n        int userId = mInjector.userHandleGetCallingUserId();\n        int affectedUserId = parent ? getProfileParentId(userId) : userId;\n\n        synchronized (getLockObject()) {\n            ActiveAdmin ap;\n            if (isPermissionCheckFlagEnabled()) {\n                CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n                ap = enforcePermissionAndGetEnforcingAdmin(\n                        who,\n                        /*permission=*/ MANAGE_DEVICE_POLICY_WIPE_DATA,\n                        /* adminPolicy=*/ DeviceAdminInfo.USES_POLICY_WIPE_DATA,\n                        caller.getPackageName(), affectedUserId).getActiveAdmin();\n            } else {\n                // This API can only be called by an active device admin,\n                // so try to retrieve it to check that the caller is one.\n                getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_WIPE_DATA, parent);\n                ap = getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_WATCH_LOGIN, parent);\n            }\n\n            if (ap.maximumFailedPasswordsForWipe != num) {\n                ap.maximumFailedPasswordsForWipe = num;\n                saveSettingsLocked(userId);\n            }\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_MAX_PASSWORD_ATTEMPTS_SET, callerPackageName,\n                    userId, affectedUserId, num);\n        }\n    }\n\n    @Override\n    public int getMaximumFailedPasswordsForWipe(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        // System caller can query policy for a particular admin.\n        Preconditions.checkCallAuthorization(\n                who == null || isCallingFromPackage(who.getPackageName(), caller.getUid())\n                        || canQueryAdminPolicy(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = (who != null)\n                    ? getActiveAdminUncheckedLocked(who, userHandle, parent)\n                    : getAdminWithMinimumFailedPasswordsForWipeLocked(userHandle, parent);\n            return admin != null ? admin.maximumFailedPasswordsForWipe : 0;\n        }\n    }\n\n    @Override\n    public int getProfileWithMinimumFailedPasswordsForWipe(int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return UserHandle.USER_NULL;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getAdminWithMinimumFailedPasswordsForWipeLocked(\n                    userHandle, parent);\n            return admin != null ? getUserIdToWipeForFailedPasswords(admin) : UserHandle.USER_NULL;\n        }\n    }\n\n    /**\n     * Returns the admin with the strictest policy on maximum failed passwords for:\n     * <ul>\n     *   <li>this user if it has a separate profile challenge, or\n     *   <li>this user and all profiles that don't have their own challenge otherwise.\n     * </ul>\n     * <p>If the policy for the primary and any other profile are equal, it returns the admin for\n     * the primary profile. Policy of a PO on an organization-owned device applies to the primary\n     * profile.\n     * Returns {@code null} if no participating admin has that policy set.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private ActiveAdmin getAdminWithMinimumFailedPasswordsForWipeLocked(\n            int userHandle, boolean parent) {\n        int count = 0;\n        ActiveAdmin strictestAdmin = null;\n\n        // Return the strictest policy across all participating admins.\n        List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                getProfileParentUserIfRequested(userHandle, parent));\n        final int N = admins.size();\n        for (int i = 0; i < N; i++) {\n            ActiveAdmin admin = admins.get(i);\n            if (admin.maximumFailedPasswordsForWipe ==\n                    ActiveAdmin.DEF_MAXIMUM_FAILED_PASSWORDS_FOR_WIPE) {\n                continue;  // No max number of failed passwords policy set for this profile.\n            }\n\n            // We always favor the primary profile if several profiles have the same value set.\n            final int userId = getUserIdToWipeForFailedPasswords(admin);\n            if (count == 0 ||\n                    count > admin.maximumFailedPasswordsForWipe ||\n                    (count == admin.maximumFailedPasswordsForWipe &&\n                            getUserInfo(userId).isPrimary())) {\n                count = admin.maximumFailedPasswordsForWipe;\n                strictestAdmin = admin;\n            }\n        }\n        return strictestAdmin;\n    }\n\n    private UserInfo getUserInfo(@UserIdInt int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() -> mUserManager.getUserInfo(userId));\n    }\n\n    private boolean setPasswordPrivileged(@NonNull String password, int flags,\n            CallerIdentity caller) {\n        // Only allow setting password on an unsecured user\n        if (isLockScreenSecureUnchecked(caller.getUserId())) {\n            throw new SecurityException(\"Cannot change current password\");\n        }\n        return resetPasswordInternal(password, 0, null, flags, caller);\n    }\n\n    @Override\n    public boolean resetPassword(@Nullable String password, int flags) throws RemoteException {\n        if (!mLockPatternUtils.hasSecureLockScreen()) {\n            Slogf.w(LOG_TAG, \"Cannot reset password when the device has no lock screen\");\n            return false;\n        }\n        if (password == null) password = \"\";\n        final CallerIdentity caller = getCallerIdentity();\n        final int userHandle = caller.getUserId();\n\n        // As of R, only privileged caller holding RESET_PASSWORD can call resetPassword() to\n        // set password to an unsecured user.\n        if (hasCallingPermission(permission.RESET_PASSWORD)) {\n            final boolean result = setPasswordPrivileged(password, flags, caller);\n            if (result) {\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.RESET_PASSWORD)\n                        .write();\n            }\n            return result;\n        }\n\n        // If caller has PO (or DO) throw or fail silently depending on its target SDK level.\n        if (isDefaultDeviceOwner(caller) || isProfileOwner(caller)) {\n            synchronized (getLockObject()) {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n                if (getTargetSdk(admin.info.getPackageName(), userHandle) < Build.VERSION_CODES.O) {\n                    Slogf.e(LOG_TAG, \"DPC can no longer call resetPassword()\");\n                    return false;\n                }\n                throw new SecurityException(\"Device admin can no longer call resetPassword()\");\n            }\n        }\n\n        // Caller is not DO or PO, could either be unauthorized or Device Admin.\n        synchronized (getLockObject()) {\n            // Legacy device admin cannot call resetPassword either\n            ActiveAdmin admin = getActiveAdminForCallerLocked(\n                    null, DeviceAdminInfo.USES_POLICY_RESET_PASSWORD, false);\n            Preconditions.checkCallAuthorization(admin != null,\n                    \"Unauthorized caller cannot call resetPassword.\");\n            if (getTargetSdk(admin.info.getPackageName(),\n                    userHandle) <= android.os.Build.VERSION_CODES.M) {\n                Slogf.e(LOG_TAG, \"Device admin can no longer call resetPassword()\");\n                return false;\n            }\n            throw new SecurityException(\"Device admin can no longer call resetPassword()\");\n        }\n    }\n\n    private boolean resetPasswordInternal(String password, long tokenHandle, byte[] token,\n            int flags, CallerIdentity caller) {\n        final int callingUid = caller.getUid();\n        final int userHandle = UserHandle.getUserId(callingUid);\n        final boolean isPin = PasswordMetrics.isNumericOnly(password);\n        synchronized (getLockObject()) {\n            final PasswordMetrics minMetrics = getPasswordMinimumMetricsUnchecked(userHandle);\n            final List<PasswordValidationError> validationErrors;\n            final int complexity = getAggregatedPasswordComplexityLocked(userHandle);\n            // TODO: Consider changing validation API to take LockscreenCredential.\n            if (password.isEmpty()) {\n                validationErrors = PasswordMetrics.validatePasswordMetrics(\n                        minMetrics, complexity, new PasswordMetrics(CREDENTIAL_TYPE_NONE));\n            } else {\n                // TODO(b/120484642): remove getBytes() below\n                validationErrors = PasswordMetrics.validatePassword(\n                        minMetrics, complexity, isPin, password.getBytes());\n            }\n\n            if (!validationErrors.isEmpty()) {\n                Slogf.w(LOG_TAG, \"Failed to reset password due to constraint violation: %s\",\n                        validationErrors.get(0));\n                return false;\n            }\n        }\n\n        DevicePolicyData policy = getUserData(userHandle);\n        if (policy.mPasswordOwner >= 0 && policy.mPasswordOwner != callingUid) {\n            Slogf.w(LOG_TAG, \"resetPassword: already set by another uid and not entered by user\");\n            return false;\n        }\n\n        boolean callerIsDeviceOwnerAdmin = isDefaultDeviceOwner(caller);\n        boolean doNotAskCredentialsOnBoot =\n                (flags & DevicePolicyManager.RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT) != 0;\n        if (callerIsDeviceOwnerAdmin && doNotAskCredentialsOnBoot) {\n            setDoNotAskCredentialsOnBoot();\n        }\n\n        // Don't do this with the lock held, because it is going to call\n        // back in to the service.\n        final long ident = mInjector.binderClearCallingIdentity();\n        final LockscreenCredential newCredential;\n        if (isPin) {\n            newCredential = LockscreenCredential.createPin(password);\n        } else {\n            newCredential = LockscreenCredential.createPasswordOrNone(password);\n        }\n        try {\n            if (tokenHandle == 0 || token == null) {\n                if (!mLockPatternUtils.setLockCredential(newCredential,\n                        LockscreenCredential.createNone(), userHandle)) {\n                    return false;\n                }\n            } else {\n                if (!mLockPatternUtils.setLockCredentialWithToken(newCredential, tokenHandle,\n                        token, userHandle)) {\n                    return false;\n                }\n            }\n            boolean requireEntry = (flags & DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY) != 0;\n            if (requireEntry) {\n                mLockPatternUtils.requireStrongAuth(STRONG_AUTH_REQUIRED_AFTER_DPM_LOCK_NOW,\n                        UserHandle.USER_ALL);\n            }\n            synchronized (getLockObject()) {\n                int newOwner = requireEntry ? callingUid : -1;\n                if (policy.mPasswordOwner != newOwner) {\n                    policy.mPasswordOwner = newOwner;\n                    saveSettingsLocked(userHandle);\n                }\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n        return true;\n    }\n\n    private boolean isLockScreenSecureUnchecked(int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() -> mLockPatternUtils.isSecure(userId));\n    }\n\n    private void setDoNotAskCredentialsOnBoot() {\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(UserHandle.USER_SYSTEM);\n            if (!policyData.mDoNotAskCredentialsOnBoot) {\n                policyData.mDoNotAskCredentialsOnBoot = true;\n                saveSettingsLocked(UserHandle.USER_SYSTEM);\n            }\n        }\n    }\n\n    @Override\n    public boolean getDoNotAskCredentialsOnBoot() {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.QUERY_DO_NOT_ASK_CREDENTIALS_ON_BOOT));\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(UserHandle.USER_SYSTEM);\n            return policyData.mDoNotAskCredentialsOnBoot;\n        }\n    }\n\n    @Override\n    public void setMaximumTimeToLock(ComponentName who, String callerPackageName,\n            long timeMs, boolean parent) {\n        if (!mHasFeature) {\n            return;\n        }\n        if (!isPermissionCheckFlagEnabled()) {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n        }\n        int userHandle = mInjector.userHandleGetCallingUserId();\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n        synchronized (getLockObject()) {\n            ActiveAdmin ap;\n            if (isPermissionCheckFlagEnabled()) {\n                CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n                ap = enforcePermissionAndGetEnforcingAdmin(\n                        who,\n                        /*permission=*/ MANAGE_DEVICE_POLICY_LOCK,\n                        /*AdminPolicy=*/DeviceAdminInfo.USES_POLICY_FORCE_LOCK,\n                        caller.getPackageName(),\n                        affectedUserId).getActiveAdmin();\n            } else {\n                ap = getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_FORCE_LOCK, parent);\n            }\n\n            if (ap.maximumTimeToUnlock != timeMs) {\n                ap.maximumTimeToUnlock = timeMs;\n                saveSettingsLocked(userHandle);\n                updateMaximumTimeToLockLocked(userHandle);\n            }\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_MAX_SCREEN_LOCK_TIMEOUT_SET,\n                    callerPackageName, userHandle, affectedUserId, timeMs);\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void updateMaximumTimeToLockLocked(@UserIdInt int userId) {\n        // Update the profile's timeout\n        if (isManagedProfile(userId)) {\n            updateProfileLockTimeoutLocked(userId);\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            // Update the device timeout\n            final int parentId = getProfileParentId(userId);\n            final long timeMs = getMaximumTimeToLockPolicyFromAdmins(\n                    getActiveAdminsForLockscreenPoliciesLocked(parentId));\n\n            final DevicePolicyData policy = getUserDataUnchecked(parentId);\n            if (policy.mLastMaximumTimeToLock == timeMs) {\n                return;\n            }\n            policy.mLastMaximumTimeToLock = timeMs;\n\n            if (policy.mLastMaximumTimeToLock != Long.MAX_VALUE) {\n                // Make sure KEEP_SCREEN_ON is disabled, since that\n                // would allow bypassing of the maximum time to lock.\n                mInjector.settingsGlobalPutInt(Settings.Global.STAY_ON_WHILE_PLUGGED_IN, 0);\n            }\n            getPowerManagerInternal().setMaximumScreenOffTimeoutFromDeviceAdmin(parentId, timeMs);\n        });\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void updateProfileLockTimeoutLocked(@UserIdInt int userId) {\n        final long timeMs;\n        if (isSeparateProfileChallengeEnabled(userId)) {\n            timeMs = getMaximumTimeToLockPolicyFromAdmins(\n                    getActiveAdminsForLockscreenPoliciesLocked(userId));\n        } else {\n            timeMs = Long.MAX_VALUE;\n        }\n\n        final DevicePolicyData policy = getUserDataUnchecked(userId);\n        if (policy.mLastMaximumTimeToLock == timeMs) {\n            return;\n        }\n        policy.mLastMaximumTimeToLock = timeMs;\n\n        mInjector.binderWithCleanCallingIdentity(() ->\n                getPowerManagerInternal().setMaximumScreenOffTimeoutFromDeviceAdmin(\n                        userId, policy.mLastMaximumTimeToLock));\n    }\n\n    @Override\n    public long getMaximumTimeToLock(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        // System caller can query policy for a particular admin.\n        Preconditions.checkCallAuthorization(\n                who == null || isCallingFromPackage(who.getPackageName(), caller.getUid())\n                        || canQueryAdminPolicy(caller));\n\n        synchronized (getLockObject()) {\n            if (who != null) {\n                final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                return admin != null ? admin.maximumTimeToUnlock : 0;\n            }\n            // Return the strictest policy across all participating admins.\n            final List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            final long timeMs = getMaximumTimeToLockPolicyFromAdmins(admins);\n            return timeMs == Long.MAX_VALUE ? 0 : timeMs;\n        }\n    }\n\n    private long getMaximumTimeToLockPolicyFromAdmins(List<ActiveAdmin> admins) {\n        long time = Long.MAX_VALUE;\n        for (final ActiveAdmin admin : admins) {\n            if (admin.maximumTimeToUnlock > 0 && admin.maximumTimeToUnlock < time) {\n                time = admin.maximumTimeToUnlock;\n            }\n        }\n        return time;\n    }\n\n    @Override\n    public void setRequiredStrongAuthTimeout(ComponentName who, String callerPackageName, long timeoutMs,\n            boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n        Preconditions.checkArgument(timeoutMs >= 0, \"Timeout must not be a negative number.\");\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        }\n        // timeoutMs with value 0 means that the admin doesn't participate\n        // timeoutMs is clamped to the interval in case the internal constants change in the future\n        final long minimumStrongAuthTimeout = getMinimumStrongAuthTimeoutMs();\n        if (timeoutMs != 0 && timeoutMs < minimumStrongAuthTimeout) {\n            timeoutMs = minimumStrongAuthTimeout;\n        }\n        if (timeoutMs > DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS) {\n            timeoutMs = DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS;\n        }\n\n        final int userHandle = caller.getUserId();\n        boolean changed = false;\n        synchronized (getLockObject()) {\n            ActiveAdmin ap;\n            if (isPermissionCheckFlagEnabled()) {\n                int affectedUser = parent\n                        ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n                ap = enforcePermissionAndGetEnforcingAdmin(\n                        who, MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                        caller.getPackageName(), affectedUser).getActiveAdmin();\n            } else {\n                ap = getParentOfAdminIfRequired(\n                        getProfileOwnerOrDeviceOwnerLocked(caller.getUserId()), parent);\n            }\n            if (ap.strongAuthUnlockTimeout != timeoutMs) {\n                ap.strongAuthUnlockTimeout = timeoutMs;\n                saveSettingsLocked(userHandle);\n                changed = true;\n            }\n        }\n        if (changed) {\n            mLockSettingsInternal.refreshStrongAuthTimeout(userHandle);\n            // Refreshes the parent if profile has unified challenge, since the timeout would\n            // also affect the parent user in this case.\n            if (isManagedProfile(userHandle) && !isSeparateProfileChallengeEnabled(userHandle)) {\n                mLockSettingsInternal.refreshStrongAuthTimeout(getProfileParentId(userHandle));\n            }\n        }\n    }\n\n    /**\n     * Return a single admin's strong auth unlock timeout or minimum value (strictest) of all\n     * admins if who is null.\n     * Returns 0 if not configured for the provided admin.\n     */\n    @Override\n    public long getRequiredStrongAuthTimeout(ComponentName who, int userId, boolean parent) {\n        if (!mHasFeature) {\n            return DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS;\n        }\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userId));\n\n        if (!mLockPatternUtils.hasSecureLockScreen()) {\n            // No strong auth timeout on devices not supporting the\n            // {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature\n            return 0;\n        }\n        synchronized (getLockObject()) {\n            if (who != null) {\n                ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userId, parent);\n                return admin != null ? admin.strongAuthUnlockTimeout : 0;\n            }\n\n            // Return the strictest policy across all participating admins.\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userId, parent));\n\n            long strongAuthUnlockTimeout = DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS;\n            for (int i = 0; i < admins.size(); i++) {\n                final long timeout = admins.get(i).strongAuthUnlockTimeout;\n                if (timeout != 0) { // take only participating admins into account\n                    strongAuthUnlockTimeout = Math.min(timeout, strongAuthUnlockTimeout);\n                }\n            }\n            return Math.max(strongAuthUnlockTimeout, getMinimumStrongAuthTimeoutMs());\n        }\n    }\n\n    private long getMinimumStrongAuthTimeoutMs() {\n        if (!mInjector.isBuildDebuggable()) {\n            return MINIMUM_STRONG_AUTH_TIMEOUT_MS;\n        }\n        // ideally the property was named persist.sys.min_strong_auth_timeout, but system property\n        // name cannot be longer than 31 characters\n        return Math.min(mInjector.systemPropertiesGetLong(\"persist.sys.min_str_auth_timeo\",\n                MINIMUM_STRONG_AUTH_TIMEOUT_MS),\n                MINIMUM_STRONG_AUTH_TIMEOUT_MS);\n    }\n\n    @Override\n    public void lockNow(int flags, String callerPackageName, boolean parent) {\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(callerPackageName);\n        } else {\n            caller = getCallerIdentity();\n        }\n\n        final int callingUserId = caller.getUserId();\n        ComponentName adminComponent = null;\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            // Make sure the caller has any active admin with the right policy or\n            // the required permission.\n            if (isUnicornFlagEnabled()) {\n                admin = enforcePermissionAndGetEnforcingAdmin(\n                        /* admin= */ null,\n                        /* permission= */ MANAGE_DEVICE_POLICY_LOCK,\n                        USES_POLICY_FORCE_LOCK,\n                        caller.getPackageName(),\n                        getAffectedUser(parent)\n                 ).getActiveAdmin();\n            } else {\n                admin = getActiveAdminOrCheckPermissionForCallerLocked(\n                        null,\n                        DeviceAdminInfo.USES_POLICY_FORCE_LOCK,\n                        parent,\n                        LOCK_DEVICE);\n            }\n            checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_LOCK_NOW);\n            final long ident = mInjector.binderClearCallingIdentity();\n            try {\n                adminComponent = admin == null ? null : admin.info.getComponent();\n                if (adminComponent != null) {\n                    // For Profile Owners only, callers with only permission not allowed.\n                    if ((flags & DevicePolicyManager.FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY) != 0) {\n                        // Evict key\n                        Preconditions.checkCallingUser(isManagedProfile(callingUserId));\n                        Preconditions.checkArgument(!parent,\n                                \"Cannot set FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY for the parent\");\n                        if (!isProfileOwner(adminComponent, callingUserId)) {\n                            throw new SecurityException(\"Only profile owner admins can set \"\n                                    + \"FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY\");\n                        }\n                        if (!mInjector.storageManagerIsFileBasedEncryptionEnabled()) {\n                            throw new UnsupportedOperationException(\n                                    \"FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY only applies to FBE\"\n                                        + \" devices\");\n                        }\n                        mUserManager.evictCredentialEncryptionKey(callingUserId);\n                    }\n                }\n\n                // Lock all users unless this is a managed profile with a separate challenge\n                final int userToLock = (parent || !isSeparateProfileChallengeEnabled(callingUserId)\n                        ? UserHandle.USER_ALL : callingUserId);\n                mLockPatternUtils.requireStrongAuth(\n                        STRONG_AUTH_REQUIRED_AFTER_DPM_LOCK_NOW, userToLock);\n\n                // Require authentication for the device or profile\n                if (userToLock == UserHandle.USER_ALL) {\n                    if (mIsAutomotive) {\n                        if (VERBOSE_LOG) {\n                            Slogf.v(LOG_TAG, \"lockNow(): not powering off display on automotive\"\n                                    + \" build\");\n                        }\n                    } else {\n                        // Power off the display\n                        mInjector.powerManagerGoToSleep(SystemClock.uptimeMillis(),\n                                PowerManager.GO_TO_SLEEP_REASON_DEVICE_ADMIN, 0);\n                    }\n                    mInjector.getIWindowManager().lockNow(null);\n                } else {\n                    mInjector.getTrustManager().setDeviceLockedForUser(userToLock, true);\n                }\n\n                if (SecurityLog.isLoggingEnabled() && adminComponent != null) {\n                    final int affectedUserId =\n                            parent ? getProfileParentId(callingUserId) : callingUserId;\n                    SecurityLog.writeEvent(SecurityLog.TAG_REMOTE_LOCK,\n                            adminComponent.getPackageName(), callingUserId, affectedUserId);\n                }\n            } catch (RemoteException e) {\n            } finally {\n                mInjector.binderRestoreCallingIdentity(ident);\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.LOCK_NOW)\n                .setAdmin(adminComponent)\n                .setInt(flags)\n                .write();\n    }\n\n    @Override\n    public void enforceCanManageCaCerts(ComponentName who, String callerPackage) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization(canManageCaCerts(caller));\n    }\n\n    private boolean canManageCaCerts(CallerIdentity caller) {\n        return (caller.hasAdminComponent() && (isDefaultDeviceOwner(caller)\n                || isProfileOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_CERT_INSTALL))\n                || hasCallingOrSelfPermission(MANAGE_CA_CERTIFICATES);\n    }\n\n    @Override\n    public boolean approveCaCert(String alias, int userId, boolean approval) {\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            Set<String> certs = getUserData(userId).mAcceptedCaCertificates;\n            boolean changed = (approval ? certs.add(alias) : certs.remove(alias));\n            if (!changed) {\n                return false;\n            }\n            saveSettingsLocked(userId);\n        }\n        mCertificateMonitor.onCertificateApprovalsChanged(userId);\n        return true;\n    }\n\n    @Override\n    public boolean isCaCertApproved(String alias, int userId) {\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            return getUserData(userId).mAcceptedCaCertificates.contains(alias);\n        }\n    }\n\n    private Set<Integer> removeCaApprovalsIfNeeded(int userId) {\n        final ArraySet<Integer> affectedUserIds = new ArraySet<>();\n        for (UserInfo userInfo : mUserManager.getProfiles(userId)) {\n            boolean isSecure = mLockPatternUtils.isSecure(userInfo.id);\n            if (userInfo.isManagedProfile()){\n                isSecure |= mLockPatternUtils.isSecure(getProfileParentId(userInfo.id));\n            }\n            if (!isSecure) {\n                synchronized (getLockObject()) {\n                    getUserData(userInfo.id).mAcceptedCaCertificates.clear();\n                    affectedUserIds.add(userInfo.id);\n                }\n                mCertificateMonitor.onCertificateApprovalsChanged(userId);\n            }\n        }\n        return affectedUserIds;\n    }\n\n    @Override\n    public boolean installCaCert(ComponentName admin, String callerPackage, byte[] certBuffer) {\n        if (!mHasFeature) {\n            return false;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        Preconditions.checkCallAuthorization(canManageCaCerts(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_INSTALL_CA_CERT);\n\n        final String alias = mInjector.binderWithCleanCallingIdentity(() -> {\n            String installedAlias = mCertificateMonitor.installCaCert(\n                    caller.getUserHandle(), certBuffer);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.INSTALL_CA_CERT)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ admin == null)\n                    .write();\n            return installedAlias;\n        });\n\n        if (alias == null) {\n            Slogf.w(LOG_TAG, \"Problem installing cert\");\n            return false;\n        }\n\n        synchronized (getLockObject()) {\n            getUserData(caller.getUserId()).mOwnerInstalledCaCerts.add(alias);\n            saveSettingsLocked(caller.getUserId());\n        }\n        return true;\n    }\n\n    @Override\n    public void uninstallCaCerts(ComponentName admin, String callerPackage, String[] aliases) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        Preconditions.checkCallAuthorization(canManageCaCerts(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_UNINSTALL_CA_CERT);\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            mCertificateMonitor.uninstallCaCerts(caller.getUserHandle(), aliases);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.UNINSTALL_CA_CERTS)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ admin == null)\n                    .write();\n        });\n\n        synchronized (getLockObject()) {\n            if (getUserData(caller.getUserId()).mOwnerInstalledCaCerts.removeAll(\n                    Arrays.asList(aliases))) {\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public boolean installKeyPair(ComponentName who, String callerPackage, byte[] privKey,\n            byte[] cert, byte[] chain, String alias, boolean requestAccess,\n            boolean isUserSelectable) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        final boolean isCallerDelegate = isCallerDelegate(caller, DELEGATION_CERT_INSTALL);\n        final boolean isCredentialManagementApp = isCredentialManagementApp(caller);\n        if (isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    hasPermission(MANAGE_DEVICE_POLICY_CERTIFICATES,\n                            caller.getPackageName(), caller.getUserId())\n                            || isCredentialManagementApp);\n        }  else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && (isCallerDelegate || isCredentialManagementApp)));\n        }\n        if (isCredentialManagementApp) {\n            Preconditions.checkCallAuthorization(!isUserSelectable, \"The credential \"\n                    + \"management app is not allowed to install a user selectable key pair\");\n            Preconditions.checkCallAuthorization(\n                    isAliasInCredentialManagementAppPolicy(caller, alias),\n                    CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG);\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_INSTALL_KEY_PAIR);\n\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            final KeyChainConnection keyChainConnection =\n                    KeyChain.bindAsUser(mContext, caller.getUserHandle());\n            try {\n                IKeyChainService keyChain = keyChainConnection.getService();\n                if (!keyChain.installKeyPair(privKey, cert, chain, alias, KeyStore.UID_SELF)) {\n                    logInstallKeyPairFailure(caller, isCredentialManagementApp);\n                    return false;\n                }\n                if (requestAccess) {\n                    keyChain.setGrant(caller.getUid(), alias, true);\n                }\n                keyChain.setUserSelectable(alias, isUserSelectable);\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.INSTALL_KEY_PAIR)\n                        .setAdmin(caller.getPackageName())\n                        .setBoolean(/* isDelegate */ isCallerDelegate)\n                        .setStrings(isCredentialManagementApp\n                                ? CREDENTIAL_MANAGEMENT_APP : NOT_CREDENTIAL_MANAGEMENT_APP)\n                        .write();\n                return true;\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Installing certificate\", e);\n            } finally {\n                keyChainConnection.close();\n            }\n        } catch (InterruptedException e) {\n            Slogf.w(LOG_TAG, \"Interrupted while installing certificate\", e);\n            Thread.currentThread().interrupt();\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        logInstallKeyPairFailure(caller, isCredentialManagementApp);\n        return false;\n    }\n\n    private void logInstallKeyPairFailure(CallerIdentity caller,\n            boolean isCredentialManagementApp) {\n        if (!isCredentialManagementApp) {\n            return;\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.CREDENTIAL_MANAGEMENT_APP_INSTALL_KEY_PAIR_FAILED)\n                .setStrings(caller.getPackageName())\n                .write();\n    }\n\n    @Override\n    public boolean removeKeyPair(ComponentName who, String callerPackage, String alias) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        final boolean isCallerDelegate = isCallerDelegate(caller, DELEGATION_CERT_INSTALL);\n        final boolean isCredentialManagementApp = isCredentialManagementApp(caller);\n        if (isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    hasPermission(MANAGE_DEVICE_POLICY_CERTIFICATES,\n                            caller.getPackageName(), caller.getUserId())\n                            || isCredentialManagementApp);\n        }  else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && (isCallerDelegate || isCredentialManagementApp)));\n        }\n        if (isCredentialManagementApp) {\n            Preconditions.checkCallAuthorization(\n                    isAliasInCredentialManagementAppPolicy(caller, alias),\n                    CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG);\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_REMOVE_KEY_PAIR);\n\n        final long id = Binder.clearCallingIdentity();\n        try {\n            final KeyChainConnection keyChainConnection =\n                    KeyChain.bindAsUser(mContext, caller.getUserHandle());\n            try {\n                IKeyChainService keyChain = keyChainConnection.getService();\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.REMOVE_KEY_PAIR)\n                        .setAdmin(caller.getPackageName())\n                        .setBoolean(/* isDelegate */ isCallerDelegate)\n                        .setStrings(isCredentialManagementApp\n                                ? CREDENTIAL_MANAGEMENT_APP : NOT_CREDENTIAL_MANAGEMENT_APP)\n                        .write();\n                return keyChain.removeKeyPair(alias);\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Removing keypair\", e);\n            } finally {\n                keyChainConnection.close();\n            }\n        } catch (InterruptedException e) {\n            Slogf.w(LOG_TAG, \"Interrupted while removing keypair\", e);\n            Thread.currentThread().interrupt();\n        } finally {\n            Binder.restoreCallingIdentity(id);\n        }\n        return false;\n    }\n\n    @Override\n    public boolean hasKeyPair(String callerPackage, String alias) {\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        final boolean isCredentialManagementApp = isCredentialManagementApp(caller);\n        Preconditions.checkCallAuthorization(canInstallCertificates(caller)\n                || isCredentialManagementApp);\n        if (isCredentialManagementApp) {\n            Preconditions.checkCallAuthorization(\n                    isAliasInCredentialManagementAppPolicy(caller, alias),\n                    CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG);\n        }\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try (KeyChainConnection keyChainConnection =\n                         KeyChain.bindAsUser(mContext, caller.getUserHandle())) {\n                return keyChainConnection.getService().containsKeyPair(alias);\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Querying keypair\", e);\n            } catch (InterruptedException e) {\n                Slogf.w(LOG_TAG, \"Interrupted while querying keypair\", e);\n                Thread.currentThread().interrupt();\n            }\n            return false;\n        });\n    }\n\n    private boolean canInstallCertificates(CallerIdentity caller) {\n        if (isPermissionCheckFlagEnabled()) {\n            return hasPermission(MANAGE_DEVICE_POLICY_CERTIFICATES,\n                    caller.getPackageName(), caller.getUserId());\n        }  else {\n            return isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                    || isCallerDelegate(caller, DELEGATION_CERT_INSTALL);\n        }\n    }\n\n    private boolean canChooseCertificates(CallerIdentity caller) {\n        return isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                || isCallerDelegate(caller, DELEGATION_CERT_SELECTION);\n    }\n\n    @Override\n    public boolean setKeyGrantToWifiAuth(String callerPackage, String alias, boolean hasGrant) {\n        Preconditions.checkStringNotEmpty(alias, \"Alias to grant cannot be empty\");\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(canChooseCertificates(caller));\n        try {\n            return setKeyChainGrantInternal(\n                    alias, hasGrant, Process.WIFI_UID, caller.getUserHandle());\n        } catch (IllegalArgumentException e) {\n            if (mInjector.isChangeEnabled(THROW_EXCEPTION_WHEN_KEY_MISSING, caller.getPackageName(),\n                    caller.getUserId())) {\n                throw e;\n            }\n            return false;\n        }\n    }\n\n    @Override\n    public boolean isKeyPairGrantedToWifiAuth(String callerPackage, String alias) {\n        Preconditions.checkStringNotEmpty(alias, \"Alias to check cannot be empty\");\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(canChooseCertificates(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try (KeyChainConnection keyChainConnection =\n                         KeyChain.bindAsUser(mContext, caller.getUserHandle())) {\n                final List<String> result = new ArrayList<>();\n                final int[] granteeUids = keyChainConnection.getService().getGrants(alias);\n\n                for (final int uid : granteeUids) {\n                    if (uid == Process.WIFI_UID) {\n                        return true;\n                    }\n                }\n                return false;\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Querying grant to wifi auth.\", e);\n                return false;\n            }\n        });\n    }\n\n    @Override\n    public boolean setKeyGrantForApp(ComponentName who, String callerPackage, String alias,\n            String packageName, boolean hasGrant) {\n        Preconditions.checkStringNotEmpty(alias, \"Alias to grant cannot be empty\");\n        Preconditions.checkStringNotEmpty(packageName, \"Package to grant to cannot be empty\");\n\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_CERT_SELECTION)));\n\n        final int granteeUid;\n        try {\n            ApplicationInfo ai = mInjector.getIPackageManager().getApplicationInfo(\n                    packageName, 0, caller.getUserId());\n            Preconditions.checkArgument(ai != null,\n                    \"Provided package %s is not installed\", packageName);\n            granteeUid = ai.uid;\n        } catch (RemoteException e) {\n            throw new IllegalStateException(\"Failure getting grantee uid\", e);\n        }\n        try {\n            return setKeyChainGrantInternal(alias, hasGrant, granteeUid, caller.getUserHandle());\n        } catch (IllegalArgumentException e) {\n            if (mInjector.isChangeEnabled(THROW_EXCEPTION_WHEN_KEY_MISSING, callerPackage,\n                    caller.getUserId())) {\n                throw e;\n            }\n            return false;\n        }\n    }\n\n    private boolean setKeyChainGrantInternal(String alias, boolean hasGrant, int granteeUid,\n            UserHandle userHandle) {\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            try (KeyChainConnection keyChainConnection =\n                         KeyChain.bindAsUser(mContext, userHandle)) {\n                IKeyChainService keyChain = keyChainConnection.getService();\n                return keyChain.setGrant(granteeUid, alias, hasGrant);\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Setting grant for package.\", e);\n                return false;\n            }\n        } catch (InterruptedException e) {\n            Slogf.w(LOG_TAG, \"Interrupted while setting key grant\", e);\n            Thread.currentThread().interrupt();\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        return false;\n    }\n\n    @Override\n    public ParcelableGranteeMap getKeyPairGrants(String callerPackage, String alias) {\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(canChooseCertificates(caller));\n\n        final ArrayMap<Integer, Set<String>> result = new ArrayMap<>();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            try (KeyChainConnection keyChainConnection =\n                         KeyChain.bindAsUser(mContext, caller.getUserHandle())) {\n                final int[] granteeUids = keyChainConnection.getService().getGrants(alias);\n                final PackageManager pm = mInjector.getPackageManager(caller.getUserId());\n\n                for (final int uid : granteeUids) {\n                    final String[] packages = pm.getPackagesForUid(uid);\n                    if (packages == null) {\n                        Slogf.wtf(LOG_TAG, \"No packages found for uid \" + uid);\n                        continue;\n                    }\n                    result.put(uid, new ArraySet<String>(packages));\n                }\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Querying keypair grants\", e);\n            } catch (InterruptedException e) {\n                Slogf.w(LOG_TAG, \"Interrupted while querying keypair grants\", e);\n                Thread.currentThread().interrupt();\n            }\n        });\n        return new ParcelableGranteeMap(result);\n    }\n\n    @VisibleForTesting\n    public static int[] translateIdAttestationFlags(\n            int idAttestationFlags) {\n        Map<Integer, Integer> idTypeToAttestationFlag = new HashMap();\n        idTypeToAttestationFlag.put(ID_TYPE_SERIAL, AttestationUtils.ID_TYPE_SERIAL);\n        idTypeToAttestationFlag.put(ID_TYPE_IMEI, AttestationUtils.ID_TYPE_IMEI);\n        idTypeToAttestationFlag.put(ID_TYPE_MEID, AttestationUtils.ID_TYPE_MEID);\n        idTypeToAttestationFlag.put(\n                ID_TYPE_INDIVIDUAL_ATTESTATION, USE_INDIVIDUAL_ATTESTATION);\n\n        int numFlagsSet = Integer.bitCount(idAttestationFlags);\n        // No flags are set - return null to indicate no device ID attestation information should\n        // be included in the attestation record.\n        if (numFlagsSet == 0) {\n            return null;\n        }\n\n        // If the ID_TYPE_BASE_INFO is set, make sure that a non-null array is returned, even if\n        // no other flag is set. That will lead to inclusion of general device make data in the\n        // attestation record, but no specific device identifiers.\n        if ((idAttestationFlags & ID_TYPE_BASE_INFO) != 0) {\n            numFlagsSet -= 1;\n            idAttestationFlags = idAttestationFlags & (~ID_TYPE_BASE_INFO);\n        }\n\n        int[] attestationUtilsFlags = new int[numFlagsSet];\n        int i = 0;\n        for (Integer idType: idTypeToAttestationFlag.keySet()) {\n            if ((idType & idAttestationFlags) != 0) {\n                attestationUtilsFlags[i++] = idTypeToAttestationFlag.get(idType);\n            }\n        }\n\n        return attestationUtilsFlags;\n    }\n\n    @Override\n    public boolean generateKeyPair(ComponentName who, String callerPackage, String algorithm,\n            ParcelableKeyGenParameterSpec parcelableKeySpec, int idAttestationFlags,\n            KeymasterCertificateChain attestationChain) {\n        // Get attestation flags, if any.\n        final int[] attestationUtilsFlags = translateIdAttestationFlags(idAttestationFlags);\n        final boolean deviceIdAttestationRequired = attestationUtilsFlags != null;\n        KeyGenParameterSpec keySpec = parcelableKeySpec.getSpec();\n        final String alias = keySpec.getKeystoreAlias();\n        Preconditions.checkStringNotEmpty(alias, \"Empty alias provided\");\n        Preconditions.checkArgument(\n                !deviceIdAttestationRequired || keySpec.getAttestationChallenge() != null,\n                \"Requested Device ID attestation but challenge is empty\");\n\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        final boolean isCallerDelegate = isCallerDelegate(caller, DELEGATION_CERT_INSTALL);\n        final boolean isCredentialManagementApp = isCredentialManagementApp(caller);\n        if (deviceIdAttestationRequired && attestationUtilsFlags.length > 0) {\n            Preconditions.checkCallAuthorization(hasDeviceIdAccessUnchecked(\n                    caller.getPackageName(), caller.getUid()));\n            enforceIndividualAttestationSupportedIfRequested(attestationUtilsFlags);\n        } else {\n            if (isPermissionCheckFlagEnabled()) {\n                Preconditions.checkCallAuthorization(\n                        hasPermission(MANAGE_DEVICE_POLICY_CERTIFICATES,\n                                caller.getPackageName(), caller.getUserId())\n                                || isCredentialManagementApp);\n            }  else {\n                Preconditions.checkCallAuthorization((caller.hasAdminComponent() && (isProfileOwner(\n                        caller) || isDefaultDeviceOwner(caller))) || (caller.hasPackage() && (\n                        isCallerDelegate || isCredentialManagementApp)));\n            }\n            if (isCredentialManagementApp) {\n                Preconditions.checkCallAuthorization(\n                        isAliasInCredentialManagementAppPolicy(caller, alias),\n                        CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG);\n            }\n        }\n\n        if (TextUtils.isEmpty(alias)) {\n            throw new IllegalArgumentException(\"Empty alias provided.\");\n        }\n        // As the caller will be granted access to the key, ensure no UID was specified, as\n        // it will not have the desired effect.\n        if (keySpec.getUid() != KeyStore.UID_SELF) {\n            Slogf.e(LOG_TAG, \"Only the caller can be granted access to the generated keypair.\");\n            logGenerateKeyPairFailure(caller, isCredentialManagementApp);\n            return false;\n        }\n\n        if (deviceIdAttestationRequired) {\n            if (keySpec.getAttestationChallenge() == null) {\n                throw new IllegalArgumentException(\n                        \"Requested Device ID attestation but challenge is empty.\");\n            }\n            KeyGenParameterSpec.Builder specBuilder = new KeyGenParameterSpec.Builder(keySpec);\n            specBuilder.setAttestationIds(attestationUtilsFlags);\n            specBuilder.setDevicePropertiesAttestationIncluded(true);\n            keySpec = specBuilder.build();\n        }\n\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            try (KeyChainConnection keyChainConnection =\n                    KeyChain.bindAsUser(mContext, caller.getUserHandle())) {\n                IKeyChainService keyChain = keyChainConnection.getService();\n\n                final int generationResult = keyChain.generateKeyPair(algorithm,\n                        new ParcelableKeyGenParameterSpec(keySpec));\n                if (generationResult != KeyChain.KEY_GEN_SUCCESS) {\n                    Slogf.e(LOG_TAG, \"KeyChain failed to generate a keypair, error %d.\",\n                            generationResult);\n                    logGenerateKeyPairFailure(caller, isCredentialManagementApp);\n                    switch (generationResult) {\n                        case KeyChain.KEY_GEN_STRONGBOX_UNAVAILABLE:\n                            throw new ServiceSpecificException(\n                                    DevicePolicyManager.KEY_GEN_STRONGBOX_UNAVAILABLE,\n                                    String.format(\"KeyChain error: %d\", generationResult));\n                        case KeyChain.KEY_ATTESTATION_CANNOT_ATTEST_IDS:\n                            throw new UnsupportedOperationException(\n                                \"Device does not support Device ID attestation.\");\n                        default:\n                            return false;\n                    }\n                }\n\n                // Set a grant for the caller here so that when the client calls\n                // requestPrivateKey, it will be able to get the key from Keystore.\n                // Note the use of the calling  UID, since the request for the private\n                // key will come from the client's process, so the grant has to be for\n                // that UID.\n                keyChain.setGrant(caller.getUid(), alias, true);\n\n                try {\n                    final List<byte[]> encodedCerts = new ArrayList();\n                    final CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n                    final byte[] certChainBytes = keyChain.getCaCertificates(alias);\n                    encodedCerts.add(keyChain.getCertificate(alias));\n                    if (certChainBytes != null) {\n                        final Collection<X509Certificate> certs =\n                                (Collection<X509Certificate>) certFactory.generateCertificates(\n                                    new ByteArrayInputStream(certChainBytes));\n                        for (X509Certificate cert : certs) {\n                            encodedCerts.add(cert.getEncoded());\n                        }\n                    }\n\n                    attestationChain.shallowCopyFrom(new KeymasterCertificateChain(encodedCerts));\n                } catch (CertificateException e) {\n                    logGenerateKeyPairFailure(caller, isCredentialManagementApp);\n                    Slogf.e(LOG_TAG, \"While retrieving certificate chain.\", e);\n                    return false;\n                }\n\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.GENERATE_KEY_PAIR)\n                        .setAdmin(caller.getPackageName())\n                        .setBoolean(/* isDelegate */ isCallerDelegate)\n                        .setInt(idAttestationFlags)\n                        .setStrings(algorithm, isCredentialManagementApp\n                                ? CREDENTIAL_MANAGEMENT_APP : NOT_CREDENTIAL_MANAGEMENT_APP)\n                        .write();\n                return true;\n            }\n        } catch (RemoteException e) {\n            Slogf.e(LOG_TAG, \"KeyChain error while generating a keypair\", e);\n        } catch (InterruptedException e) {\n            Slogf.w(LOG_TAG, \"Interrupted while generating keypair\", e);\n            Thread.currentThread().interrupt();\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        logGenerateKeyPairFailure(caller, isCredentialManagementApp);\n        return false;\n    }\n\n    private void logGenerateKeyPairFailure(CallerIdentity caller,\n            boolean isCredentialManagementApp) {\n        if (!isCredentialManagementApp) {\n            return;\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.CREDENTIAL_MANAGEMENT_APP_GENERATE_KEY_PAIR_FAILED)\n                .setStrings(caller.getPackageName())\n                .write();\n    }\n\n    private void enforceIndividualAttestationSupportedIfRequested(int[] attestationUtilsFlags) {\n        for (int attestationFlag : attestationUtilsFlags) {\n            if (attestationFlag == USE_INDIVIDUAL_ATTESTATION\n                    && !mInjector.getPackageManager().hasSystemFeature(\n                    PackageManager.FEATURE_DEVICE_UNIQUE_ATTESTATION)) {\n                throw new UnsupportedOperationException(\"Device Individual attestation is not \"\n                        + \"supported on this device.\");\n            }\n        }\n    }\n\n    @Override\n    public boolean setKeyPairCertificate(ComponentName who, String callerPackage, String alias,\n            byte[] cert, byte[] chain, boolean isUserSelectable) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        final boolean isCallerDelegate = isCallerDelegate(caller, DELEGATION_CERT_INSTALL);\n        final boolean isCredentialManagementApp = isCredentialManagementApp(caller);\n        if (isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    hasPermission(MANAGE_DEVICE_POLICY_CERTIFICATES,\n                            caller.getPackageName(), caller.getUserId())\n                            || isCredentialManagementApp);\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && (isCallerDelegate || isCredentialManagementApp)));\n        }\n        if (isCredentialManagementApp) {\n            Preconditions.checkCallAuthorization(\n                    isAliasInCredentialManagementAppPolicy(caller, alias),\n                    CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG);\n        }\n\n        final long id = mInjector.binderClearCallingIdentity();\n        try (final KeyChainConnection keyChainConnection =\n                KeyChain.bindAsUser(mContext, caller.getUserHandle())) {\n            IKeyChainService keyChain = keyChainConnection.getService();\n            if (!keyChain.setKeyPairCertificate(alias, cert, chain)) {\n                return false;\n            }\n            keyChain.setUserSelectable(alias, isUserSelectable);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_KEY_PAIR_CERTIFICATE)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ isCallerDelegate)\n                    .setStrings(isCredentialManagementApp\n                            ? CREDENTIAL_MANAGEMENT_APP : NOT_CREDENTIAL_MANAGEMENT_APP)\n                    .write();\n            return true;\n        } catch (InterruptedException e) {\n            Slogf.w(LOG_TAG, \"Interrupted while setting keypair certificate\", e);\n            Thread.currentThread().interrupt();\n        } catch (RemoteException e) {\n            Slogf.e(LOG_TAG, \"Failed setting keypair certificate\", e);\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        return false;\n    }\n\n    @Override\n    public void choosePrivateKeyAlias(final int uid, final Uri uri, final String alias,\n            final IBinder response) {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isSystemUid(caller),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"choose private key alias\"));\n\n        // If there is a profile owner, redirect to that; otherwise query the device owner.\n        ComponentName aliasChooser = getProfileOwnerAsUser(caller.getUserId());\n        if (aliasChooser == null && caller.getUserHandle().isSystem()) {\n            synchronized (getLockObject()) {\n                final ActiveAdmin deviceOwnerAdmin = getDeviceOwnerAdminLocked();\n                if (deviceOwnerAdmin != null) {\n                    aliasChooser = deviceOwnerAdmin.info.getComponent();\n                }\n            }\n        }\n        if (aliasChooser == null) {\n            sendPrivateKeyAliasResponse(null, response);\n            return;\n        }\n\n        Intent intent = new Intent(DeviceAdminReceiver.ACTION_CHOOSE_PRIVATE_KEY_ALIAS);\n        intent.putExtra(DeviceAdminReceiver.EXTRA_CHOOSE_PRIVATE_KEY_SENDER_UID, uid);\n        intent.putExtra(DeviceAdminReceiver.EXTRA_CHOOSE_PRIVATE_KEY_URI, uri);\n        intent.putExtra(DeviceAdminReceiver.EXTRA_CHOOSE_PRIVATE_KEY_ALIAS, alias);\n        intent.putExtra(DeviceAdminReceiver.EXTRA_CHOOSE_PRIVATE_KEY_RESPONSE, response);\n        intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n\n        final ComponentName delegateReceiver;\n        delegateReceiver = resolveDelegateReceiver(DELEGATION_CERT_SELECTION,\n                DeviceAdminReceiver.ACTION_CHOOSE_PRIVATE_KEY_ALIAS, caller.getUserId());\n\n        final boolean isDelegate;\n        if (delegateReceiver != null) {\n            intent.setComponent(delegateReceiver);\n            isDelegate = true;\n        } else {\n            intent.setComponent(aliasChooser);\n            isDelegate = false;\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            mContext.sendOrderedBroadcastAsUser(intent, caller.getUserHandle(), null,\n                    new BroadcastReceiver() {\n                @Override\n                public void onReceive(Context context, Intent intent) {\n                    final String chosenAlias = getResultData();\n                    sendPrivateKeyAliasResponse(chosenAlias, response);\n                }\n            }, null, Activity.RESULT_OK, null, null);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.CHOOSE_PRIVATE_KEY_ALIAS)\n                    .setAdmin(intent.getComponent())\n                    .setBoolean(isDelegate)\n                    .write();\n        });\n    }\n\n    private void sendPrivateKeyAliasResponse(final String alias, final IBinder responseBinder) {\n        final IKeyChainAliasCallback keyChainAliasResponse =\n                IKeyChainAliasCallback.Stub.asInterface(responseBinder);\n        // Send the response. It's OK to do this from the main thread because IKeyChainAliasCallback\n        // is oneway, which means it won't block if the recipient lives in another process.\n        try {\n            keyChainAliasResponse.alias(alias);\n        } catch (Exception e) {\n            // Caller could throw RuntimeException or RemoteException back across processes. Catch\n            // everything just to be sure.\n            Slogf.e(LOG_TAG, \"error while responding to callback\", e);\n        }\n    }\n\n    /**\n     * Determine whether DPMS should check if a delegate package is already installed before\n     * granting it new delegations via {@link #setDelegatedScopes}.\n     */\n    private static boolean shouldCheckIfDelegatePackageIsInstalled(String delegatePackage,\n            int targetSdk, List<String> scopes) {\n        // 1) Never skip is installed check from N.\n        if (targetSdk >= Build.VERSION_CODES.N) {\n            return true;\n        }\n        // 2) Skip if DELEGATION_CERT_INSTALL is the only scope being given.\n        if (scopes.size() == 1 && scopes.get(0).equals(DELEGATION_CERT_INSTALL)) {\n            return false;\n        }\n        // 3) Skip if all previously granted scopes are being cleared.\n        if (scopes.isEmpty()) {\n            return false;\n        }\n        // Otherwise it should check that delegatePackage is installed.\n        return true;\n    }\n\n    /**\n     * Set the scopes of a device owner or profile owner delegate.\n     *\n     * @param who the device owner or profile owner.\n     * @param delegatePackage the name of the delegate package.\n     * @param scopeList the list of delegation scopes to be given to the delegate package.\n     */\n    @Override\n    public void setDelegatedScopes(ComponentName who, String delegatePackage,\n            List<String> scopeList) throws SecurityException {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkStringNotEmpty(delegatePackage, \"Delegate package is null or empty\");\n        Preconditions.checkCollectionElementsNotNull(scopeList, \"Scopes\");\n        final CallerIdentity caller = getCallerIdentity(who);\n\n        // Remove possible duplicates.\n        final ArrayList<String> scopes = new ArrayList(new ArraySet(scopeList));\n        // Ensure given scopes are valid.\n        if (scopes.retainAll(Arrays.asList(DELEGATIONS))) {\n            throw new IllegalArgumentException(\"Unexpected delegation scopes\");\n        }\n        // Retrieve the user ID of the calling process.\n        final int userId = caller.getUserId();\n        // Ensure calling process is device/profile owner.\n        if (!Collections.disjoint(scopes, DEVICE_OWNER_OR_MANAGED_PROFILE_OWNER_DELEGATIONS)) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || (isProfileOwner(caller) && isManagedProfile(caller.getUserId())));\n        } else if (!Collections.disjoint(\n                scopes, DEVICE_OWNER_OR_ORGANIZATION_OWNED_MANAGED_PROFILE_OWNER_DELEGATIONS)) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        }\n\n        synchronized (getLockObject()) {\n            // Ensure the delegate is installed (skip this for DELEGATION_CERT_INSTALL in pre-N).\n            if (shouldCheckIfDelegatePackageIsInstalled(delegatePackage,\n                        getTargetSdk(who.getPackageName(), userId), scopes)) {\n                // Throw when the delegate package is not installed.\n                if (!isPackageInstalledForUser(delegatePackage, userId)) {\n                    throw new IllegalArgumentException(\"Package \" + delegatePackage\n                            + \" is not installed on the current user\");\n                }\n            }\n\n            // Set the new delegate in user policies.\n            final DevicePolicyData policy = getUserData(userId);\n            List<String> exclusiveScopes = null;\n            if (!scopes.isEmpty()) {\n                policy.mDelegationMap.put(delegatePackage, new ArrayList<>(scopes));\n                exclusiveScopes = new ArrayList<>(scopes);\n                exclusiveScopes.retainAll(EXCLUSIVE_DELEGATIONS);\n            } else {\n                // Remove any delegation info if the given scopes list is empty.\n                policy.mDelegationMap.remove(delegatePackage);\n            }\n            sendDelegationChangedBroadcast(delegatePackage, scopes, userId);\n\n            // If set, remove exclusive scopes from all other delegates\n            if (exclusiveScopes != null && !exclusiveScopes.isEmpty()) {\n                for (int i = policy.mDelegationMap.size() - 1; i >= 0; --i) {\n                    final String currentPackage = policy.mDelegationMap.keyAt(i);\n                    final List<String> currentScopes = policy.mDelegationMap.valueAt(i);\n\n                    if (!currentPackage.equals(delegatePackage)) {\n                        // Iterate through all other delegates\n                        if (currentScopes.removeAll(exclusiveScopes)) {\n                            // And if this delegate had some exclusive scopes which are now moved\n                            // to the new delegate, notify about its delegation changes.\n                            if (currentScopes.isEmpty()) {\n                                policy.mDelegationMap.removeAt(i);\n                            }\n                            sendDelegationChangedBroadcast(currentPackage,\n                                    new ArrayList<>(currentScopes), userId);\n                        }\n                    }\n                }\n            }\n            // Persist updates.\n            saveSettingsLocked(userId);\n        }\n    }\n\n    private void sendDelegationChangedBroadcast(String delegatePackage, ArrayList<String> scopes,\n            int userId) {\n        // Notify delegate package of updates.\n        final Intent intent = new Intent(\n                DevicePolicyManager.ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED);\n        // Only call receivers registered with Context#registerReceiver (don\u2019t wake delegate).\n        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        // Limit components this intent resolves to to the delegate package.\n        intent.setPackage(delegatePackage);\n        // Include the list of delegated scopes as an extra.\n        intent.putStringArrayListExtra(DevicePolicyManager.EXTRA_DELEGATION_SCOPES, scopes);\n        // Send the broadcast.\n        mContext.sendBroadcastAsUser(intent, UserHandle.of(userId));\n    }\n\n    /**\n     * Get the delegation scopes given to a delegate package by a device owner or profile owner.\n     *\n     * A DO/PO can get the scopes of any package. A non DO/PO package can get its own scopes by\n     * passing in {@code null} as the {@code who} parameter and its own name as the\n     * {@code delegatepackage}.\n     *\n     * @param who the device owner or profile owner, or {@code null} if the caller is\n     *            {@code delegatePackage}.\n     * @param delegatePackage the name of the delegate package whose scopes are to be retrieved.\n     * @return a list of the delegation scopes currently given to {@code delegatePackage}.\n     */\n    @Override\n    @NonNull\n    public List<String> getDelegatedScopes(ComponentName who,\n            String delegatePackage) throws SecurityException {\n        Objects.requireNonNull(delegatePackage, \"Delegate package is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n\n        // Ensure the caller may call this method:\n        // * Either it's a profile owner / device owner, if componentName is provided\n        // * Or it's an app querying its own delegation scopes\n        if (caller.hasAdminComponent()) {\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        } else {\n            Preconditions.checkCallAuthorization(isPackage(caller, delegatePackage),\n                    String.format(\"Caller with uid %d is not %s\", caller.getUid(),\n                            delegatePackage));\n        }\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(caller.getUserId());\n            // Retrieve the scopes assigned to delegatePackage, or null if no scope was given.\n            final List<String> scopes = policy.mDelegationMap.get(delegatePackage);\n            return scopes == null ? Collections.EMPTY_LIST : scopes;\n        }\n    }\n\n    /**\n     * Get a list of  packages that were given a specific delegation scopes by a device owner or\n     * profile owner.\n     *\n     * @param who the device owner or profile owner.\n     * @param scope the scope whose delegates are to be retrieved.\n     * @return a list of the delegate packages currently given the {@code scope} delegation.\n     */\n    @NonNull\n    public List<String> getDelegatePackages(ComponentName who, String scope)\n            throws SecurityException {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(scope, \"Scope is null\");\n        if (!Arrays.asList(DELEGATIONS).contains(scope)) {\n            throw new IllegalArgumentException(\"Unexpected delegation scope: \" + scope);\n        }\n\n        // Retrieve the user ID of the calling process.\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        synchronized (getLockObject()) {\n            return getDelegatePackagesInternalLocked(scope, caller.getUserId());\n        }\n    }\n\n    private List<String> getDelegatePackagesInternalLocked(String scope, int userId) {\n        final DevicePolicyData policy = getUserData(userId);\n\n        // Create a list to hold the resulting delegate packages.\n        final List<String> delegatePackagesWithScope = new ArrayList<>();\n        // Add all delegations containing scope to the result list.\n        for (int i = 0; i < policy.mDelegationMap.size(); i++) {\n            if (policy.mDelegationMap.valueAt(i).contains(scope)) {\n                delegatePackagesWithScope.add(policy.mDelegationMap.keyAt(i));\n            }\n        }\n        return delegatePackagesWithScope;\n    }\n\n    /**\n     * Return the ComponentName of the receiver that handles the given broadcast action, from\n     * the app that holds the given delegation capability. If the app defines multiple receivers\n     * with the same intent action filter, will return any one of them nondeterministically.\n     *\n     * @return ComponentName of the receiver or {@null} if none exists.\n     */\n    private ComponentName resolveDelegateReceiver(String scope, String action, int userId) {\n\n        final List<String> delegates;\n        synchronized (getLockObject()) {\n            delegates = getDelegatePackagesInternalLocked(scope, userId);\n        }\n        if (delegates.size() == 0) {\n            return null;\n        } else if (delegates.size() > 1) {\n            Slogf.wtf(LOG_TAG, \"More than one delegate holds \" + scope);\n            return null;\n        }\n        final String pkg = delegates.get(0);\n        Intent intent = new Intent(action);\n        intent.setPackage(pkg);\n        final List<ResolveInfo> receivers;\n        try {\n            receivers = mIPackageManager.queryIntentReceivers(\n                    intent, null, 0, userId).getList();\n        } catch (RemoteException e) {\n            return null;\n        }\n        final int count = receivers.size();\n        if (count >= 1) {\n            if (count > 1) {\n                Slogf.w(LOG_TAG, pkg + \" defines more than one delegate receiver for \" + action);\n            }\n            return receivers.get(0).activityInfo.getComponentName();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Check whether a caller application has been delegated a given scope via\n     * {@link #setDelegatedScopes} to access privileged APIs on the behalf of a profile owner or\n     * device owner.\n     * <p>\n     * This is done by checking that {@code callerPackage} was granted {@code scope} delegation and\n     * then comparing the calling UID with the UID of {@code callerPackage} as reported by\n     * {@link PackageManager#getPackageUidAsUser}.\n     *\n     * @param callerPackage the name of the package that is trying to invoke a function in the DPMS.\n     * @param scope the delegation scope to be checked.\n     * @return {@code true} if the calling process is a delegate of {@code scope}.\n     */\n    private boolean isCallerDelegate(String callerPackage, int callerUid, String scope) {\n        Objects.requireNonNull(callerPackage, \"callerPackage is null\");\n        if (!Arrays.asList(DELEGATIONS).contains(scope)) {\n            throw new IllegalArgumentException(\"Unexpected delegation scope: \" + scope);\n        }\n\n        // Retrieve the UID and user ID of the calling process.\n        final int userId = UserHandle.getUserId(callerUid);\n        synchronized (getLockObject()) {\n            // Retrieve user policy data.\n            final DevicePolicyData policy = getUserData(userId);\n            // Retrieve the list of delegation scopes granted to callerPackage.\n            final List<String> scopes = policy.mDelegationMap.get(callerPackage);\n            // Check callingUid only if callerPackage has the required scope delegation.\n            if (scopes != null && scopes.contains(scope)) {\n                // Return true if the caller is actually callerPackage.\n                return isCallingFromPackage(callerPackage, callerUid);\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Check whether a caller application has been delegated a given scope via\n     * {@link #setDelegatedScopes} to access privileged APIs on the behalf of a profile owner or\n     * device owner.\n     * <p>\n     * This is done by checking that the calling package was granted {@code scope} delegation and\n     * then comparing the calling UID with the UID of the calling package as reported by\n     * {@link PackageManager#getPackageUidAsUser}.\n     *\n     * @param caller the calling identity\n     * @param scope the delegation scope to be checked.\n     * @return {@code true} if the calling process is a delegate of {@code scope}.\n     */\n    private boolean isCallerDelegate(CallerIdentity caller, String scope) {\n        if (caller.getPackageName() == null) {\n            return false;\n        }\n        Preconditions.checkArgument(Arrays.asList(DELEGATIONS).contains(scope),\n                \"Unexpected delegation scope: %s\", scope);\n\n        synchronized (getLockObject()) {\n            // Retrieve user policy data.\n            final DevicePolicyData policy = getUserData(caller.getUserId());\n            // Retrieve the list of delegation scopes granted to callerPackage.\n            final List<String> scopes = policy.mDelegationMap.get(caller.getPackageName());\n            // Check callingUid only if callerPackage has the required scope delegation.\n            return scopes != null && scopes.contains(scope);\n        }\n    }\n\n    /**\n     * Check whether a caller application has been delegated any scope via\n     * {@link #setDelegatedScopes} to access privileged APIs on the behalf of a profile owner or\n     * device owner.\n     * <p>\n     * This is done by checking that the calling package was granted any scope delegations and\n     * then comparing the calling UID with the UID of the calling package as reported by\n     * {@link PackageManager#getPackageUidAsUser}.\n     *\n     * @param caller the calling identity\n     * @return {@code true} if the calling process is a delegate of any scope.\n     */\n    private boolean isCallerDelegate(CallerIdentity caller) {\n        Objects.requireNonNull(caller.getPackageName(), \"callerPackage is null\");\n\n        synchronized (getLockObject()) {\n            // Retrieve user policy data.\n            final DevicePolicyData policy = getUserData(caller.getUserId());\n            // Retrieve the list of delegation scopes granted to callerPackage.\n            final List<String> scopes = policy.mDelegationMap.get(caller.getPackageName());\n            // Check callingUid only if callerPackage has the required scope delegation.\n            return scopes != null;\n        }\n    }\n\n    /**\n     * Helper function to preserve delegation behavior pre-O when using the deprecated functions\n     * {@code #setCertInstallerPackage} and {@code #setApplicationRestrictionsManagingPackage}.\n     */\n    private void setDelegatedScopePreO(ComponentName who,\n            String delegatePackage, String scope) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        // Ensure calling process is device/profile owner.\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(caller.getUserId());\n\n            if (delegatePackage != null) {\n                // Set package as a delegate for scope if it is not already one.\n                List<String> scopes = policy.mDelegationMap.get(delegatePackage);\n                if (scopes == null) {\n                    scopes = new ArrayList<>();\n                }\n                if (!scopes.contains(scope)) {\n                    scopes.add(scope);\n                    setDelegatedScopes(who, delegatePackage, scopes);\n                }\n            }\n\n            // Clear any existing scope delegates.\n            for (int i = 0; i < policy.mDelegationMap.size(); i++) {\n                final String currentPackage = policy.mDelegationMap.keyAt(i);\n                final List<String> currentScopes = policy.mDelegationMap.valueAt(i);\n\n                if (!currentPackage.equals(delegatePackage) && currentScopes.contains(scope)) {\n                    final List<String> newScopes = new ArrayList(currentScopes);\n                    newScopes.remove(scope);\n                    setDelegatedScopes(who, currentPackage, newScopes);\n                }\n            }\n        }\n    }\n\n    /**\n     * Check whether a caller application is the credential management app, which can access\n     * privileged APIs.\n     * <p>\n     * This is done by checking that the calling package is authorized to perform the app operation\n     * {@link android.app.AppOpsManager#OP_MANAGE_CREDENTIALS}.\n     *\n     * @param caller the calling identity\n     * @return {@code true} if the calling process is the credential management app.\n     */\n    private boolean isCredentialManagementApp(CallerIdentity caller) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            AppOpsManager appOpsManager = mInjector.getAppOpsManager();\n            if (appOpsManager == null) return false;\n            return appOpsManager.noteOpNoThrow(AppOpsManager.OP_MANAGE_CREDENTIALS, caller.getUid(),\n                    caller.getPackageName(), null, null) == AppOpsManager.MODE_ALLOWED;\n        });\n    }\n\n    /**\n     * If the caller is the credential management app, the alias provided must be contained\n     * in the aliases specified in the credential management app's authentication policy.\n     */\n    private boolean isAliasInCredentialManagementAppPolicy(CallerIdentity caller, String alias) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try (KeyChainConnection connection = KeyChain.bindAsUser(mContext,\n                    caller.getUserHandle())) {\n                // The policy will be null if there is no credential management app\n                AppUriAuthenticationPolicy policy =\n                        connection.getService().getCredentialManagementAppPolicy();\n                return policy != null && !policy.getAppAndUriMappings().isEmpty()\n                        && containsAlias(policy, alias);\n            } catch (RemoteException | InterruptedException e) {\n                return false;\n            }\n        });\n    }\n\n    private static boolean containsAlias(AppUriAuthenticationPolicy policy, String alias) {\n        for (Map.Entry<String, Map<Uri, String>> appsToUris :\n                policy.getAppAndUriMappings().entrySet()) {\n            for (Map.Entry<Uri, String> urisToAliases : appsToUris.getValue().entrySet()) {\n                if (urisToAliases.getValue().equals(alias)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void setCertInstallerPackage(ComponentName who, String installerPackage)\n            throws SecurityException {\n        setDelegatedScopePreO(who, installerPackage, DELEGATION_CERT_INSTALL);\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CERT_INSTALLER_PACKAGE)\n                .setAdmin(who)\n                .setStrings(installerPackage)\n                .write();\n    }\n\n    @Override\n    public String getCertInstallerPackage(ComponentName who) throws SecurityException {\n        final List<String> delegatePackages = getDelegatePackages(who, DELEGATION_CERT_INSTALL);\n        return delegatePackages.size() > 0 ? delegatePackages.get(0) : null;\n    }\n\n    /**\n     * @return {@code true} if the package is installed and set as always-on, {@code false} if it is\n     * not installed and therefore not available.\n     *\n     * @throws SecurityException if the caller is not a profile or device owner.\n     * @throws UnsupportedOperationException if the package does not support being set as always-on.\n     */\n    @Override\n    public boolean setAlwaysOnVpnPackage(ComponentName who, String vpnPackage, boolean lockdown,\n            List<String> lockdownAllowlist)\n            throws SecurityException {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_ALWAYS_ON_VPN_PACKAGE);\n\n        if (vpnPackage == null) {\n            final String prevVpnPackage;\n            synchronized (getLockObject()) {\n                prevVpnPackage = getProfileOwnerOrDeviceOwnerLocked(\n                        caller.getUserId()).mAlwaysOnVpnPackage;\n                // If the admin is clearing VPN package but hasn't configure any VPN previously,\n                // ignore it so that it doesn't interfere with user-configured VPNs.\n                if (TextUtils.isEmpty(prevVpnPackage)) {\n                    return true;\n                }\n            }\n            revokeVpnAuthorizationForPackage(prevVpnPackage, caller.getUserId());\n        }\n\n        final int userId = caller.getUserId();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (vpnPackage != null && !isPackageInstalledForUser(vpnPackage, userId)) {\n                Slogf.w(LOG_TAG, \"Non-existent VPN package specified: \" + vpnPackage);\n                throw new ServiceSpecificException(\n                        DevicePolicyManager.ERROR_VPN_PACKAGE_NOT_FOUND, vpnPackage);\n            }\n\n            if (vpnPackage != null && lockdown && lockdownAllowlist != null) {\n                for (String packageName : lockdownAllowlist) {\n                    if (!isPackageInstalledForUser(packageName, userId)) {\n                        Slogf.w(LOG_TAG, \"Non-existent package in VPN allowlist: \" + packageName);\n                        throw new ServiceSpecificException(\n                                DevicePolicyManager.ERROR_VPN_PACKAGE_NOT_FOUND, packageName);\n                    }\n                }\n            }\n            // If some package is uninstalled after the check above, it will be ignored by CM.\n            if (!mInjector.getVpnManager().setAlwaysOnVpnPackageForUser(\n                    userId, vpnPackage, lockdown, lockdownAllowlist)) {\n                throw new UnsupportedOperationException();\n            }\n        });\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_ALWAYS_ON_VPN_PACKAGE)\n                .setAdmin(caller.getComponentName())\n                .setStrings(vpnPackage)\n                .setBoolean(lockdown)\n                .setInt(lockdownAllowlist != null ? lockdownAllowlist.size() : 0)\n                .write();\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (!TextUtils.equals(vpnPackage, admin.mAlwaysOnVpnPackage)\n                    || lockdown != admin.mAlwaysOnVpnLockdown) {\n                admin.mAlwaysOnVpnPackage = vpnPackage;\n                admin.mAlwaysOnVpnLockdown = lockdown;\n                saveSettingsLocked(userId);\n            }\n        }\n        return true;\n    }\n\n    private void revokeVpnAuthorizationForPackage(String vpnPackage, int userId) {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                final ApplicationInfo ai = mIPackageManager.getApplicationInfo(\n                        vpnPackage, /* flags= */ 0, userId);\n                if (ai == null) {\n                    Slogf.w(LOG_TAG, \"Non-existent VPN package: \" + vpnPackage);\n                } else {\n                    mInjector.getAppOpsManager().setMode(AppOpsManager.OP_ACTIVATE_VPN,\n                            ai.uid, vpnPackage, MODE_DEFAULT);\n                }\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Can't talk to package managed\", e);\n            }\n        });\n    }\n\n    @Override\n    public String getAlwaysOnVpnPackage(ComponentName admin) throws SecurityException {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getVpnManager().getAlwaysOnVpnPackageForUser(caller.getUserId()));\n    }\n\n    @Override\n    public String getAlwaysOnVpnPackageForUser(int userHandle) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"call getAlwaysOnVpnPackageForUser\"));\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userHandle);\n            return admin != null ? admin.mAlwaysOnVpnPackage : null;\n        }\n    }\n\n    @Override\n    public boolean isAlwaysOnVpnLockdownEnabled(ComponentName admin) throws SecurityException {\n        final CallerIdentity caller;\n        if (hasCallingPermission(PERMISSION_MAINLINE_NETWORK_STACK)) {\n            // TODO: CaptivePortalLoginActivity erroneously calls this method with a non-admin\n            // ComponentName, so we have to use a separate code path for it:\n            // getCallerIdentity(admin) will throw if the admin is not in the known admin list.\n            caller = getCallerIdentity();\n        } else {\n            caller = getCallerIdentity(admin);\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        }\n\n        return mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getVpnManager().isVpnLockdownEnabled(caller.getUserId()));\n    }\n\n    @Override\n    public boolean isAlwaysOnVpnLockdownEnabledForUser(int userHandle) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"call isAlwaysOnVpnLockdownEnabledForUser\"));\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userHandle);\n            return admin != null && admin.mAlwaysOnVpnLockdown;\n        }\n    }\n\n    @Override\n    public List<String> getAlwaysOnVpnLockdownAllowlist(ComponentName admin)\n            throws SecurityException {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getVpnManager().getVpnLockdownAllowlist(caller.getUserId()));\n    }\n\n    private void forceWipeDeviceNoLock(boolean wipeExtRequested, String reason, boolean wipeEuicc,\n            boolean wipeResetProtectionData) {\n        wtfIfInLock();\n        boolean success = false;\n\n        try {\n            boolean delayed = !mInjector.recoverySystemRebootWipeUserData(\n                    /* shutdown= */ false, reason, /* force= */ true, /* wipeEuicc= */ wipeEuicc,\n                    wipeExtRequested, wipeResetProtectionData);\n            if (delayed) {\n                // Persist the request so the device is automatically factory-reset on next start if\n                // the system crashes or reboots before the {@code DevicePolicySafetyChecker} calls\n                // its callback.\n                Slogf.i(LOG_TAG, \"Persisting factory reset request as it could be delayed by %s\",\n                        mSafetyChecker);\n                synchronized (getLockObject()) {\n                    DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n                    policy.setDelayedFactoryReset(reason, wipeExtRequested, wipeEuicc,\n                            wipeResetProtectionData);\n                    saveSettingsLocked(UserHandle.USER_SYSTEM);\n                }\n            }\n            success = true;\n        } catch (IOException | SecurityException e) {\n            Slogf.w(LOG_TAG, \"Failed requesting data wipe\", e);\n        } finally {\n            if (!success) SecurityLog.writeEvent(SecurityLog.TAG_WIPE_FAILURE);\n        }\n    }\n\n    private void factoryResetIfDelayedEarlier() {\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n\n            if (policy.mFactoryResetFlags == 0) return;\n\n            if (policy.mFactoryResetReason == null) {\n                // Shouldn't happen.\n                Slogf.e(LOG_TAG, \"no persisted reason for factory resetting\");\n                policy.mFactoryResetReason = \"requested before boot\";\n            }\n            FactoryResetter factoryResetter = FactoryResetter.newBuilder(mContext)\n                    .setReason(policy.mFactoryResetReason).setForce(true)\n                    .setWipeEuicc((policy.mFactoryResetFlags & DevicePolicyData\n                            .FACTORY_RESET_FLAG_WIPE_EUICC) != 0)\n                    .setWipeAdoptableStorage((policy.mFactoryResetFlags & DevicePolicyData\n                            .FACTORY_RESET_FLAG_WIPE_EXTERNAL_STORAGE) != 0)\n                    .setWipeFactoryResetProtection((policy.mFactoryResetFlags & DevicePolicyData\n                            .FACTORY_RESET_FLAG_WIPE_FACTORY_RESET_PROTECTION) != 0)\n                    .build();\n            Slogf.i(LOG_TAG, \"Factory resetting on boot using \" + factoryResetter);\n            try {\n                if (!factoryResetter.factoryReset()) {\n                    // Shouldn't happen because FactoryResetter was created without a\n                    // DevicePolicySafetyChecker.\n                    Slogf.wtf(LOG_TAG, \"Factory reset using \" + factoryResetter + \" failed.\");\n                }\n            } catch (IOException e) {\n                // Shouldn't happen.\n                Slogf.wtf(LOG_TAG, \"Could not factory reset using \" + factoryResetter, e);\n            }\n        }\n    }\n\n    private void forceWipeUser(int userId, String wipeReasonForUser, boolean wipeSilently) {\n        boolean success = false;\n        try {\n            if (getCurrentForegroundUserId() == userId) {\n                // TODO: We need to special case headless here as we can't switch to the system user\n                mInjector.getIActivityManager().switchUser(UserHandle.USER_SYSTEM);\n            }\n\n            success = mUserManagerInternal.removeUserEvenWhenDisallowed(userId);\n            if (!success) {\n                Slogf.w(LOG_TAG, \"Couldn't remove user \" + userId);\n            } else if (isManagedProfile(userId) && !wipeSilently) {\n                sendWipeProfileNotification(wipeReasonForUser,\n                        UserHandle.of(getProfileParentId(userId)));\n            }\n        } catch (RemoteException re) {\n            // Shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Error forcing wipe user\", re);\n        } finally {\n            if (!success) SecurityLog.writeEvent(SecurityLog.TAG_WIPE_FAILURE);\n        }\n    }\n\n    @Override\n    public void wipeDataWithReason(String callerPackageName, int flags,\n            @NonNull String wipeReasonForUser, boolean calledOnParentInstance,\n            boolean factoryReset) {\n        if (!mHasFeature && !hasCallingOrSelfPermission(permission.MASTER_CLEAR)) {\n            return;\n        }\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(callerPackageName);\n        }  else {\n            caller = getCallerIdentity();\n        }\n        ActiveAdmin admin;\n\n        boolean calledByProfileOwnerOnOrgOwnedDevice =\n                isProfileOwnerOfOrganizationOwnedDevice(caller.getUserId());\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionsAndGetEnforcingAdmin(\n                    /*admin=*/ null,\n                    /*permission=*/ new String[]{MANAGE_DEVICE_POLICY_WIPE_DATA, MASTER_CLEAR},\n                    USES_POLICY_WIPE_DATA,\n                    caller.getPackageName(),\n                    factoryReset ? UserHandle.USER_ALL : getAffectedUser(calledOnParentInstance));\n            admin = enforcingAdmin.getActiveAdmin();\n        } else {\n            if (calledOnParentInstance) {\n                Preconditions.checkCallAuthorization(calledByProfileOwnerOnOrgOwnedDevice,\n                        \"Wiping the entire device can only be done by a profile owner on \"\n                                + \"organization-owned device.\");\n            }\n            if ((flags & WIPE_RESET_PROTECTION_DATA) != 0) {\n                Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                                || calledByProfileOwnerOnOrgOwnedDevice\n                                || isFinancedDeviceOwner(caller),\n                        \"Only device owners or profile owners of organization-owned device can set \"\n                                + \"WIPE_RESET_PROTECTION_DATA\");\n            }\n            synchronized (getLockObject()) {\n                admin = getActiveAdminWithPolicyForUidLocked(/* who= */ null,\n                        DeviceAdminInfo.USES_POLICY_WIPE_DATA, caller.getUid());\n            }\n            Preconditions.checkCallAuthorization(\n                    (admin != null) || hasCallingOrSelfPermission(permission.MASTER_CLEAR),\n                    \"No active admin for user %d and caller %d does not hold MASTER_CLEAR \"\n                            + \"permission\",\n                    caller.getUserId(), caller.getUid());\n        }\n\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_WIPE_DATA);\n\n        if (TextUtils.isEmpty(wipeReasonForUser)) {\n            wipeReasonForUser = getGenericWipeReason(\n                    calledByProfileOwnerOnOrgOwnedDevice, calledOnParentInstance);\n        }\n\n        int userId = admin != null ? admin.getUserHandle().getIdentifier()\n                : caller.getUserId();\n        Slogf.i(LOG_TAG, \"wipeDataWithReason(%s): admin=%s, user=%d\", wipeReasonForUser, admin,\n                userId);\n        if (calledByProfileOwnerOnOrgOwnedDevice) {\n            // When wipeData is called on the parent instance, it implies wiping the entire device.\n            if (calledOnParentInstance) {\n                userId = UserHandle.USER_SYSTEM;\n            } else {\n                // when wipeData is _not_ called on the parent instance, it implies relinquishing\n                // control over the device, wiping only the work profile. So the user restriction\n                // on profile removal needs to be removed first.\n                final UserHandle parentUser = UserHandle.of(getProfileParentId(userId));\n                mInjector.binderWithCleanCallingIdentity(\n                        () -> clearOrgOwnedProfileOwnerUserRestrictions(parentUser));\n            }\n        }\n        DevicePolicyEventLogger event = DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.WIPE_DATA_WITH_REASON)\n                .setInt(flags)\n                .setStrings(calledOnParentInstance ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT);\n\n        final String adminName;\n        final ComponentName adminComp;\n        if (admin != null) {\n            if (admin.isPermissionBased) {\n                adminComp = null;\n                adminName = caller.getPackageName();\n                event.setAdmin(adminName);\n            } else {\n                adminComp = admin.info.getComponent();\n                adminName = adminComp.flattenToShortString();\n                event.setAdmin(adminComp);\n            }\n        } else {\n            adminComp = null;\n            adminName = mInjector.getPackageManager().getPackagesForUid(caller.getUid())[0];\n            Slogf.i(LOG_TAG, \"Logging wipeData() event admin as \" + adminName);\n            event.setAdmin(adminName);\n            if (mInjector.userManagerIsHeadlessSystemUserMode()) {\n                // On headless system user mode, the call is meant to factory reset the whole\n                // device, otherwise the caller could simply remove the current user.\n                userId = UserHandle.USER_SYSTEM;\n            }\n        }\n        event.write();\n\n        String internalReason = String.format(\n                \"DevicePolicyManager.wipeDataWithReason() from %s, organization-owned? %s\",\n                adminName, calledByProfileOwnerOnOrgOwnedDevice);\n\n        wipeDataNoLock(adminComp, flags, internalReason, wipeReasonForUser, userId,\n                calledOnParentInstance, factoryReset);\n    }\n\n    private String getGenericWipeReason(\n            boolean calledByProfileOwnerOnOrgOwnedDevice, boolean calledOnParentInstance) {\n        return calledByProfileOwnerOnOrgOwnedDevice && !calledOnParentInstance\n                ? getUpdatableString(\n                        WORK_PROFILE_DELETED_ORG_OWNED_MESSAGE,\n                        R.string.device_ownership_relinquished)\n                : getUpdatableString(\n                        WORK_PROFILE_DELETED_GENERIC_MESSAGE,\n                        R.string.work_profile_deleted_description_dpm_wipe);\n    }\n\n    /**\n     * Clears device wide policies enforced by COPE PO when relinquishing the device. This method\n     * should be invoked once the admin is gone, so that all methods that rely on calculating\n     * aggregate policy (e.g. strong auth timeout) from all admins aren't affected by its policies.\n     * This method assumes that there is no other device or profile owners left on the device.\n     * Shouldn't be called from binder thread without clearing identity.\n     */\n    private void clearOrgOwnedProfileOwnerDeviceWidePolicies(@UserIdInt int parentId) {\n        Slogf.i(LOG_TAG, \"Cleaning up device-wide policies left over from org-owned profile...\");\n        // Lockscreen message\n        mLockPatternUtils.setDeviceOwnerInfo(null);\n        // Wifi config lockdown\n        mInjector.settingsGlobalPutInt(Global.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN, 0);\n        // Security logging\n        if (mInjector.securityLogGetLoggingEnabledProperty()) {\n            mSecurityLogMonitor.stop();\n            mInjector.securityLogSetLoggingEnabledProperty(false);\n        }\n        // Network logging\n        setNetworkLoggingActiveInternal(false);\n\n        // System update policy.\n        final boolean hasSystemUpdatePolicy;\n        synchronized (getLockObject()) {\n            hasSystemUpdatePolicy = mOwners.getSystemUpdatePolicy() != null;\n            if (hasSystemUpdatePolicy) {\n                mOwners.clearSystemUpdatePolicy();\n                mOwners.writeDeviceOwner();\n            }\n        }\n        if (hasSystemUpdatePolicy) {\n            mContext.sendBroadcastAsUser(\n                    new Intent(ACTION_SYSTEM_UPDATE_POLICY_CHANGED), UserHandle.SYSTEM);\n        }\n\n        // Unsuspend personal apps if needed.\n        suspendPersonalAppsInternal(parentId, getManagedUserId(parentId), false);\n\n        // Notify FRP agent, LSS and WindowManager to ensure they don't hold on to stale policies.\n        final int frpAgentUid = getFrpManagementAgentUid();\n        if (frpAgentUid > 0) {\n            notifyResetProtectionPolicyChanged(frpAgentUid);\n        }\n        mLockSettingsInternal.refreshStrongAuthTimeout(parentId);\n\n        clearManagedSubscriptionsPolicy();\n        clearLauncherShortcutOverrides();\n        updateTelephonyCrossProfileIntentFilters(parentId, UserHandle.USER_NULL, false);\n\n        Slogf.i(LOG_TAG, \"Cleaning up device-wide policies done.\");\n    }\n\n    private void clearManagedSubscriptionsPolicy() {\n        unregisterOnSubscriptionsChangedListener();\n\n        SubscriptionManager subscriptionManager = mContext.getSystemService(\n                SubscriptionManager.class);\n        //Iterate over all the subscriptions and remove association with any user.\n        int[] subscriptionIds = subscriptionManager.getActiveSubscriptionIdList(false);\n        for (int subId : subscriptionIds) {\n            subscriptionManager.setSubscriptionUserHandle(subId, null);\n        }\n    }\n\n    private void clearLauncherShortcutOverrides() {\n        mPolicyCache.setLauncherShortcutOverrides(new ArrayMap<>());\n    }\n\n    private void updateTelephonyCrossProfileIntentFilters(int parentUserId, int profileUserId,\n            boolean enableWorkTelephony) {\n        try {\n            // This should only occur when managed profile is being removed.\n            if (!enableWorkTelephony && profileUserId == UserHandle.USER_NULL) {\n                mIPackageManager.clearCrossProfileIntentFilters(parentUserId,\n                        mContext.getPackageName());\n                return;\n            }\n            for (DefaultCrossProfileIntentFilter filter :\n                    DefaultCrossProfileIntentFiltersUtils\n                            .getDefaultCrossProfileTelephonyIntentFilters(!enableWorkTelephony)) {\n                if (removeCrossProfileIntentFilter(filter, parentUserId, profileUserId)) {\n                    Slogf.w(LOG_TAG,\n                            \"Failed to remove cross-profile intent filter: \"\n                                    + filter.filter.getIntentFilter() + \", enableWorkTelephony: \"\n                                    + enableWorkTelephony);\n                }\n            }\n            for (DefaultCrossProfileIntentFilter filter :\n                    DefaultCrossProfileIntentFiltersUtils\n                            .getDefaultCrossProfileTelephonyIntentFilters(enableWorkTelephony)) {\n                addCrossProfileIntentFilter(filter, parentUserId, profileUserId);\n            }\n        } catch (RemoteException re) {\n            Slogf.wtf(LOG_TAG, \"Error updating telephony cross profile intent filters\", re);\n        }\n    }\n\n    void addCrossProfileIntentFilter(DefaultCrossProfileIntentFilter filter, int parentUserId,\n            int profileUserId)\n            throws RemoteException {\n        if (filter.direction == DefaultCrossProfileIntentFilter.Direction.TO_PROFILE) {\n            mIPackageManager.addCrossProfileIntentFilter(\n                    filter.filter.getIntentFilter(),\n                    mContext.getOpPackageName(),\n                    parentUserId,\n                    profileUserId,\n                    filter.flags);\n        } else {\n            mIPackageManager.addCrossProfileIntentFilter(\n                    filter.filter.getIntentFilter(),\n                    mContext.getOpPackageName(),\n                    profileUserId,\n                    parentUserId,\n                    filter.flags);\n        }\n    }\n\n    boolean removeCrossProfileIntentFilter(DefaultCrossProfileIntentFilter filter, int parentUserId,\n            int profileUserId)\n            throws RemoteException {\n        if (filter.direction == DefaultCrossProfileIntentFilter.Direction.TO_PROFILE) {\n            return mIPackageManager.removeCrossProfileIntentFilter(\n                    filter.filter.getIntentFilter(),\n                    mContext.getOpPackageName(),\n                    parentUserId,\n                    profileUserId,\n                    filter.flags);\n        } else {\n            return mIPackageManager.removeCrossProfileIntentFilter(\n                    filter.filter.getIntentFilter(),\n                    mContext.getOpPackageName(),\n                    profileUserId,\n                    parentUserId,\n                    filter.flags);\n        }\n    }\n\n    /**\n     * @param factoryReset null: legacy behaviour, false: attempt to remove user, true: attempt to\n     *                     factory reset\n     */\n    private void wipeDataNoLock(@Nullable ComponentName admin, int flags, String internalReason,\n            String wipeReasonForUser, int userId, boolean calledOnParentInstance,\n            @Nullable Boolean factoryReset) {\n        wtfIfInLock();\n        final String adminPackage;\n        if (admin != null) {\n            adminPackage = admin.getPackageName();\n        } else {\n            int callerId = mInjector.binderGetCallingUid();\n            String[] adminPackages = mInjector.getPackageManager().getPackagesForUid(callerId);\n            Preconditions.checkState(adminPackages.length > 0,\n                    \"Caller %s does not have any associated packages\", callerId);\n            adminPackage = adminPackages[0];\n        }\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            // First check whether the admin is allowed to wipe the device/user/profile.\n            final String restriction;\n            if (userId == UserHandle.USER_SYSTEM) {\n                restriction = UserManager.DISALLOW_FACTORY_RESET;\n            } else if (isManagedProfile(userId)) {\n                restriction = UserManager.DISALLOW_REMOVE_MANAGED_PROFILE;\n            } else {\n                restriction = UserManager.DISALLOW_REMOVE_USER;\n            }\n            if (isAdminAffectedByRestriction(admin, restriction, userId)) {\n                throw new SecurityException(\"Cannot wipe data. \" + restriction\n                        + \" restriction is set for user \" + userId);\n            }\n        });\n\n        boolean isSystemUser = userId == UserHandle.USER_SYSTEM;\n        boolean wipeDevice;\n        if (factoryReset == null || !mInjector.isChangeEnabled(EXPLICIT_WIPE_BEHAVIOUR,\n                adminPackage,\n                userId)) {\n            // Legacy mode\n            wipeDevice = isSystemUser;\n        } else {\n            // Explicit behaviour\n            if (factoryReset) {\n                EnforcingAdmin enforcingAdmin = enforcePermissionsAndGetEnforcingAdmin(\n                        /*admin=*/ null,\n                        /*permission=*/ new String[]{MANAGE_DEVICE_POLICY_WIPE_DATA,\n                                MASTER_CLEAR},\n                        USES_POLICY_WIPE_DATA,\n                        adminPackage,\n                        factoryReset ? UserHandle.USER_ALL :\n                                getAffectedUser(calledOnParentInstance));\n                wipeDevice = true;\n            } else {\n                mInjector.binderWithCleanCallingIdentity(() -> {\n                    Preconditions.checkCallAuthorization(!isSystemUser,\n                            \"User %s is a system user and cannot be removed\", userId);\n                    boolean isLastNonHeadlessUser = getUserInfo(userId).isFull()\n                            && mUserManager.getAliveUsers().stream()\n                            .filter((it) -> it.getUserHandle().getIdentifier() != userId)\n                            .noneMatch(UserInfo::isFull);\n                    Preconditions.checkState(!isLastNonHeadlessUser,\n                            \"Removing user %s would leave the device without any active users. \"\n                                    + \"Consider factory resetting the device instead.\",\n                            userId);\n                });\n                wipeDevice = false;\n            }\n        }\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (wipeDevice) {\n                forceWipeDeviceNoLock(\n                        (flags & WIPE_EXTERNAL_STORAGE) != 0,\n                        internalReason,\n                        (flags & WIPE_EUICC) != 0,\n                        (flags & WIPE_RESET_PROTECTION_DATA) != 0);\n            } else {\n                forceWipeUser(userId, wipeReasonForUser, (flags & WIPE_SILENTLY) != 0);\n            }\n        });\n    }\n\n    private void sendWipeProfileNotification(String wipeReasonForUser, UserHandle user) {\n        Notification notification =\n                new Notification.Builder(mContext, SystemNotificationChannels.DEVICE_ADMIN)\n                        .setSmallIcon(android.R.drawable.stat_sys_warning)\n                        .setContentTitle(getWorkProfileDeletedTitle())\n                        .setContentText(wipeReasonForUser)\n                        .setColor(mContext.getColor(R.color.system_notification_accent_color))\n                        .setStyle(new Notification.BigTextStyle().bigText(wipeReasonForUser))\n                        .build();\n        mInjector.getNotificationManager().notifyAsUser(\n                /* tag= */ null, SystemMessage.NOTE_PROFILE_WIPED, notification, user);\n    }\n\n    private String getWorkProfileDeletedTitle() {\n        return getUpdatableString(WORK_PROFILE_DELETED_TITLE, R.string.work_profile_deleted);\n    }\n\n    private void clearWipeProfileNotification() {\n        mInjector.getNotificationManager().cancel(SystemMessage.NOTE_PROFILE_WIPED);\n    }\n\n    @Override\n    public void setFactoryResetProtectionPolicy(ComponentName who, String callerPackageName,\n            @Nullable FactoryResetProtectionPolicy policy) {\n        if (!mHasFeature) {\n            return;\n        }\n        if (!isPermissionCheckFlagEnabled()) {\n            Preconditions.checkNotNull(who, \"ComponentName is null\");\n        }\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        if (!isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager\n                .OPERATION_SET_FACTORY_RESET_PROTECTION_POLICY);\n\n        final int frpManagementAgentUid = getFrpManagementAgentUidOrThrow();\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            if (isPermissionCheckFlagEnabled()) {\n                admin = enforcePermissionAndGetEnforcingAdmin(\n                        who, MANAGE_DEVICE_POLICY_FACTORY_RESET, caller.getPackageName(),\n                        UserHandle.USER_ALL)\n                        .getActiveAdmin();\n            } else {\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n            admin.mFactoryResetProtectionPolicy = policy;\n            saveSettingsLocked(caller.getUserId());\n        }\n\n        mInjector.binderWithCleanCallingIdentity(\n                () -> notifyResetProtectionPolicyChanged(frpManagementAgentUid));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_FACTORY_RESET_PROTECTION)\n                .setAdmin(caller.getPackageName())\n                .write();\n    }\n\n    // Shouldn't be called from binder thread without clearing identity.\n    private void notifyResetProtectionPolicyChanged(int frpManagementAgentUid) {\n        final Intent intent = new Intent(\n                DevicePolicyManager.ACTION_RESET_PROTECTION_POLICY_CHANGED).addFlags(\n                Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND | Intent.FLAG_RECEIVER_FOREGROUND);\n        mContext.sendBroadcastAsUser(intent,\n                UserHandle.getUserHandleForUid(frpManagementAgentUid),\n                permission.MANAGE_FACTORY_RESET_PROTECTION);\n    }\n\n    @Override\n    public FactoryResetProtectionPolicy getFactoryResetProtectionPolicy(\n            @Nullable ComponentName who) {\n        if (!mHasFeature) {\n            return null;\n        }\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        final int frpManagementAgentUid = getFrpManagementAgentUidOrThrow();\n        final ActiveAdmin admin;\n        synchronized (getLockObject()) {\n            if (who == null) {\n                Preconditions.checkCallAuthorization(frpManagementAgentUid == caller.getUid()\n                                || hasCallingPermission(permission.MASTER_CLEAR)\n                                || hasCallingPermission(MANAGE_DEVICE_POLICY_FACTORY_RESET),\n                        \"Must be called by the FRP management agent on device\");\n                admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceOrSystemPermissionBasedAdminLocked();\n            } else {\n                Preconditions.checkCallAuthorization(\n                        isDefaultDeviceOwner(caller)\n                                || isProfileOwnerOfOrganizationOwnedDevice(caller));\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n        }\n\n        return admin != null ? admin.mFactoryResetProtectionPolicy : null;\n    }\n\n    private int getFrpManagementAgentUid() {\n        PersistentDataBlockManagerInternal pdb = mInjector.getPersistentDataBlockManagerInternal();\n        return pdb != null ? pdb.getAllowedUid() : -1;\n    }\n\n    private int getFrpManagementAgentUidOrThrow() {\n        int uid = getFrpManagementAgentUid();\n        if (uid == -1) {\n            throw new UnsupportedOperationException(\n                    \"The persistent data block service is not supported on this device\");\n        }\n        return uid;\n    }\n\n    @Override\n    public boolean isFactoryResetProtectionPolicySupported() {\n        return getFrpManagementAgentUid() != -1;\n    }\n\n    @Override\n    public void sendLostModeLocationUpdate(AndroidFuture<Boolean> future) {\n        if (!mHasFeature) {\n            future.complete(false);\n            return;\n        }\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.TRIGGER_LOST_MODE));\n\n        synchronized (getLockObject()) {\n            // TODO(b/261999445): Remove\n            ActiveAdmin admin;\n            if (isHeadlessFlagEnabled()) {\n                admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n            } else {\n                admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked(\n                        UserHandle.USER_SYSTEM);\n            }\n            Preconditions.checkState(admin != null,\n                    \"Lost mode location updates can only be sent on an organization-owned device.\");\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                String[] providers = {LocationManager.FUSED_PROVIDER,\n                        LocationManager.NETWORK_PROVIDER, LocationManager.GPS_PROVIDER};\n                tryRetrieveAndSendLocationUpdate(admin, future, providers, /* index= */ 0);\n            });\n        }\n    }\n\n    /** Send lost mode location updates recursively, in order of the list of location providers. */\n    private void tryRetrieveAndSendLocationUpdate(ActiveAdmin admin,\n            AndroidFuture<Boolean> future, String[] providers, int index) {\n        // None of the providers were able to get location, return false\n        if (index == providers.length) {\n            future.complete(false);\n            return;\n        }\n        if (mInjector.getLocationManager().isProviderEnabled(providers[index])) {\n            mInjector.getLocationManager().getCurrentLocation(providers[index],\n                    /* cancellationSignal= */ null, mContext.getMainExecutor(), location -> {\n                        if (location != null) {\n                            mContext.sendBroadcastAsUser(\n                                    newLostModeLocationUpdateIntent(admin, location),\n                                    admin.getUserHandle());\n                            future.complete(true);\n                        } else {\n                            tryRetrieveAndSendLocationUpdate(admin, future, providers, index + 1);\n                        }\n                    }\n            );\n        } else {\n           tryRetrieveAndSendLocationUpdate(admin, future, providers, index + 1);\n        }\n    }\n\n    private Intent newLostModeLocationUpdateIntent(ActiveAdmin admin, Location location) {\n        final Intent intent = new Intent(\n                DevicePolicyManager.ACTION_LOST_MODE_LOCATION_UPDATE);\n        intent.putExtra(DevicePolicyManager.EXTRA_LOST_MODE_LOCATION, location);\n        intent.setPackage(admin.info.getPackageName());\n        return intent;\n    }\n\n    /**\n     * Called by a privileged caller holding {@code BIND_DEVICE_ADMIN} permission to retrieve\n     * the remove warning for the given device admin.\n     */\n    @Override\n    public void getRemoveWarning(ComponentName comp, final RemoteCallback result, int userHandle) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminUncheckedLocked(comp, userHandle);\n            if (admin == null) {\n                result.sendResult(null);\n                return;\n            }\n            Intent intent = new Intent(DeviceAdminReceiver.ACTION_DEVICE_ADMIN_DISABLE_REQUESTED);\n            intent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.setComponent(admin.info.getComponent());\n            mContext.sendOrderedBroadcastAsUser(intent, new UserHandle(userHandle),\n                    null, new BroadcastReceiver() {\n                @Override\n                public void onReceive(Context context, Intent intent) {\n                    result.sendResult(getResultExtras(false));\n                }\n            }, null, Activity.RESULT_OK, null, null);\n        }\n    }\n\n    @Override\n    public void reportPasswordChanged(PasswordMetrics metrics, @UserIdInt int userId) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isSystemUid(caller));\n        // Managed Profile password can only be changed when it has a separate challenge.\n        if (!isSeparateProfileChallengeEnabled(userId)) {\n            Preconditions.checkCallAuthorization(!isManagedProfile(userId), \"You can \"\n                    + \"not set the active password for a managed profile, userId = %d\", userId);\n        }\n\n        DevicePolicyData policy = getUserData(userId);\n        final ArraySet<Integer> affectedUserIds = new ArraySet<>();\n\n        synchronized (getLockObject()) {\n            policy.mFailedPasswordAttempts = 0;\n            affectedUserIds.add(userId);\n            affectedUserIds.addAll(updatePasswordValidityCheckpointLocked(\n                    userId, /* parent */ false));\n            affectedUserIds.addAll(updatePasswordExpirationsLocked(userId));\n            setExpirationAlarmCheckLocked(mContext, userId, /* parent */ false);\n\n            // Send a broadcast to each profile using this password as its primary unlock.\n            sendAdminCommandForLockscreenPoliciesLocked(\n                    DeviceAdminReceiver.ACTION_PASSWORD_CHANGED,\n                    DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, userId);\n\n            affectedUserIds.addAll(removeCaApprovalsIfNeeded(userId));\n            saveSettingsForUsersLocked(affectedUserIds);\n        }\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_CHANGED,\n                    /* complexity */ metrics.determineComplexity(), /*user*/ userId);\n        }\n    }\n\n    /**\n     * Called any time the device password is updated. Resets all password expiration clocks.\n     *\n     * @return the set of user IDs that have been affected\n     */\n    @GuardedBy(\"getLockObject()\")\n    private Set<Integer> updatePasswordExpirationsLocked(int userHandle) {\n        final ArraySet<Integer> affectedUserIds = new ArraySet<>();\n        List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(userHandle);\n        for (int i = 0; i < admins.size(); i++) {\n            ActiveAdmin admin = admins.get(i);\n            if (admin.isPermissionBased || admin.info.usesPolicy(DeviceAdminInfo.USES_POLICY_EXPIRE_PASSWORD)) {\n                affectedUserIds.add(admin.getUserHandle().getIdentifier());\n                long timeout = admin.passwordExpirationTimeout;\n                admin.passwordExpirationDate =\n                        timeout > 0L ? (timeout + System.currentTimeMillis()) : 0L;\n            }\n        }\n        return affectedUserIds;\n    }\n\n    @Override\n    public void reportFailedPasswordAttempt(int userHandle, boolean parent) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n        if (!isSeparateProfileChallengeEnabled(userHandle)) {\n            Preconditions.checkCallAuthorization(!isManagedProfile(userHandle),\n                    \"You can not report failed password attempt if separate profile challenge is \"\n                            + \"not in place for a managed profile, userId = %d\", userHandle);\n        }\n\n        boolean wipeData = false;\n        ActiveAdmin strictestAdmin = null;\n        final long ident = mInjector.binderClearCallingIdentity();\n        try {\n            synchronized (getLockObject()) {\n                DevicePolicyData policy = getUserData(userHandle);\n                policy.mFailedPasswordAttempts++;\n                saveSettingsLocked(userHandle);\n                if (mHasFeature) {\n                    strictestAdmin = getAdminWithMinimumFailedPasswordsForWipeLocked(\n                            userHandle, /* parent= */ false);\n                    int max = strictestAdmin != null\n                            ? strictestAdmin.maximumFailedPasswordsForWipe : 0;\n                    if (max > 0 && policy.mFailedPasswordAttempts >= max) {\n                        wipeData = true;\n                    }\n\n                    sendAdminCommandForLockscreenPoliciesLocked(\n                            DeviceAdminReceiver.ACTION_PASSWORD_FAILED,\n                            DeviceAdminInfo.USES_POLICY_WATCH_LOGIN, userHandle);\n                }\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n\n        if (wipeData && strictestAdmin != null) {\n            final int userId = getUserIdToWipeForFailedPasswords(strictestAdmin);\n            Slogf.i(LOG_TAG, \"Max failed password attempts policy reached for admin: \"\n                    + strictestAdmin.info.getComponent().flattenToShortString()\n                    + \". Calling wipeData for user \" + userId);\n\n            // Attempt to wipe the device/user/profile associated with the admin, as if the\n            // admin had called wipeData(). That way we can check whether the admin is actually\n            // allowed to wipe the device (e.g. a regular device admin shouldn't be able to wipe the\n            // device if the device owner has set DISALLOW_FACTORY_RESET, but the DO should be\n            // able to do so).\n            // IMPORTANT: Call without holding the lock to prevent deadlock.\n            try {\n                wipeDataNoLock(strictestAdmin.info.getComponent(),\n                        /* flags= */ 0,\n                        /* reason= */ \"reportFailedPasswordAttempt()\",\n                        getFailedPasswordAttemptWipeMessage(),\n                        userId,\n                        /* calledOnParentInstance= */ parent,\n                        // factoryReset=null to enable U- behaviour\n                        /* factoryReset= */ null);\n            } catch (SecurityException e) {\n                Slogf.w(LOG_TAG, \"Failed to wipe user \" + userId\n                        + \" after max failed password attempts reached.\", e);\n            }\n        }\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT,\n                    /* result= */ 0, /* method strength= */ 1);\n        }\n    }\n\n    private String getFailedPasswordAttemptWipeMessage() {\n        return getUpdatableString(\n                WORK_PROFILE_DELETED_FAILED_PASSWORD_ATTEMPTS_MESSAGE,\n               R.string.work_profile_deleted_reason_maximum_password_failure);\n    }\n\n    /**\n     * Returns which user should be wiped if this admin's maximum filed password attempts policy is\n     * violated.\n     */\n    private int getUserIdToWipeForFailedPasswords(ActiveAdmin admin) {\n        final int userId = admin.getUserHandle().getIdentifier();\n        if (admin.isPermissionBased) {\n            return userId;\n        }\n        final ComponentName component = admin.info.getComponent();\n        return isProfileOwnerOfOrganizationOwnedDevice(component, userId)\n                ? getProfileParentId(userId) : userId;\n    }\n\n    @Override\n    public void reportSuccessfulPasswordAttempt(int userHandle) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(userHandle);\n            if (policy.mFailedPasswordAttempts != 0 || policy.mPasswordOwner >= 0) {\n                mInjector.binderWithCleanCallingIdentity(() -> {\n                    policy.mFailedPasswordAttempts = 0;\n                    policy.mPasswordOwner = -1;\n                    saveSettingsLocked(userHandle);\n                    if (mHasFeature) {\n                        sendAdminCommandForLockscreenPoliciesLocked(\n                                DeviceAdminReceiver.ACTION_PASSWORD_SUCCEEDED,\n                                DeviceAdminInfo.USES_POLICY_WATCH_LOGIN, userHandle);\n                    }\n                });\n            }\n        }\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT, /*result*/ 1,\n                    /*method strength*/ 1);\n        }\n    }\n\n    @Override\n    public void reportFailedBiometricAttempt(int userHandle) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT, /*result*/ 0,\n                    /*method strength*/ 0);\n        }\n    }\n\n    @Override\n    public void reportSuccessfulBiometricAttempt(int userHandle) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT, /*result*/ 1,\n                    /*method strength*/ 0);\n        }\n    }\n\n    @Override\n    public void reportKeyguardDismissed(int userHandle) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISMISSED);\n        }\n    }\n\n    @Override\n    public void reportKeyguardSecured(int userHandle) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_SECURED);\n        }\n    }\n\n    @Override\n    public ComponentName setGlobalProxy(ComponentName who, String proxySpec,\n            String exclusionList) {\n        if (!mHasFeature) {\n            return null;\n        }\n        synchronized (getLockObject()) {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n\n            // Only check if system user has set global proxy. We don't allow other users to set it.\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            ActiveAdmin admin = getActiveAdminForCallerLocked(who,\n                    DeviceAdminInfo.USES_POLICY_SETS_GLOBAL_PROXY);\n\n            // Scan through active admins and find if anyone has already\n            // set the global proxy.\n            Set<ComponentName> compSet = policy.mAdminMap.keySet();\n            for (ComponentName component : compSet) {\n                ActiveAdmin ap = policy.mAdminMap.get(component);\n                if ((ap.specifiesGlobalProxy) && (!component.equals(who))) {\n                    // Another admin already sets the global proxy\n                    // Return it to the caller.\n                    return component;\n                }\n            }\n\n            // If the user is not system, don't set the global proxy. Fail silently.\n            if (UserHandle.getCallingUserId() != UserHandle.USER_SYSTEM) {\n                Slogf.w(LOG_TAG, \"Only the owner is allowed to set the global proxy. User \"\n                        + UserHandle.getCallingUserId() + \" is not permitted.\");\n                return null;\n            }\n            if (proxySpec == null) {\n                admin.specifiesGlobalProxy = false;\n                admin.globalProxySpec = null;\n                admin.globalProxyExclusionList = null;\n            } else {\n\n                admin.specifiesGlobalProxy = true;\n                admin.globalProxySpec = proxySpec;\n                admin.globalProxyExclusionList = exclusionList;\n            }\n\n            // Reset the global proxy accordingly\n            // Do this using system permissions, as apps cannot write to secure settings\n            mInjector.binderWithCleanCallingIdentity(() -> resetGlobalProxyLocked(policy));\n            return null;\n        }\n    }\n\n    @Override\n    public ComponentName getGlobalProxyAdmin(int userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasFullCrossUsersPermission(caller, userHandle) && canQueryAdminPolicy(caller));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            // Scan through active admins and find if anyone has already\n            // set the global proxy.\n            final int N = policy.mAdminList.size();\n            for (int i = 0; i < N; i++) {\n                ActiveAdmin ap = policy.mAdminList.get(i);\n                if (ap.specifiesGlobalProxy) {\n                    // Device admin sets the global proxy\n                    // Return it to the caller.\n                    return ap.info.getComponent();\n                }\n            }\n        }\n        // No device admin sets the global proxy.\n        return null;\n    }\n\n    @Override\n    public void setRecommendedGlobalProxy(ComponentName who, ProxyInfo proxyInfo) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkAllUsersAreAffiliatedWithDevice();\n        mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getConnectivityManager().setGlobalProxy(proxyInfo));\n    }\n\n    private void resetGlobalProxyLocked(DevicePolicyData policy) {\n        final int N = policy.mAdminList.size();\n        for (int i = 0; i < N; i++) {\n            ActiveAdmin ap = policy.mAdminList.get(i);\n            if (ap.specifiesGlobalProxy) {\n                saveGlobalProxyLocked(ap.globalProxySpec, ap.globalProxyExclusionList);\n                return;\n            }\n        }\n        // No device admins defining global proxies - reset global proxy settings to none\n        saveGlobalProxyLocked(null, null);\n    }\n\n    private void saveGlobalProxyLocked(String proxySpec, String exclusionList) {\n        if (exclusionList == null) {\n            exclusionList = \"\";\n        }\n        if (proxySpec == null) {\n            proxySpec = \"\";\n        }\n        // Remove white spaces\n        proxySpec = proxySpec.trim();\n        String data[] = proxySpec.split(\":\");\n        int proxyPort = 8080;\n        if (data.length > 1) {\n            try {\n                proxyPort = Integer.parseInt(data[1]);\n            } catch (NumberFormatException e) {}\n        }\n        exclusionList = exclusionList.trim();\n\n        ProxyInfo proxyProperties = ProxyInfo.buildDirectProxy(data[0], proxyPort,\n                ProxyUtils.exclusionStringAsList(exclusionList));\n        if (!proxyProperties.isValid()) {\n            Slogf.e(LOG_TAG, \"Invalid proxy properties, ignoring: \" + proxyProperties.toString());\n            return;\n        }\n        mInjector.settingsGlobalPutString(Settings.Global.GLOBAL_HTTP_PROXY_HOST, data[0]);\n        mInjector.settingsGlobalPutInt(Settings.Global.GLOBAL_HTTP_PROXY_PORT, proxyPort);\n        mInjector.settingsGlobalPutString(Settings.Global.GLOBAL_HTTP_PROXY_EXCLUSION_LIST,\n                exclusionList);\n    }\n\n    /**\n     * Called by an application that is administering the device to request that the storage system\n     * be encrypted. Does nothing if the caller is on a secondary user or a managed profile.\n     *\n     * @return the new total request status (for all admins), or {@link\n     *         DevicePolicyManager#ENCRYPTION_STATUS_UNSUPPORTED} if called for a non-system user\n     */\n    @Override\n    public int setStorageEncryption(ComponentName who, boolean encrypt) {\n        if (!mHasFeature) {\n            return DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userHandle = UserHandle.getCallingUserId();\n        synchronized (getLockObject()) {\n            // Check for permissions\n            // Only system user can set storage encryption\n            if (userHandle != UserHandle.USER_SYSTEM) {\n                Slogf.w(LOG_TAG, \"Only owner/system user is allowed to set storage encryption. \"\n                        + \"User \" + UserHandle.getCallingUserId() + \" is not permitted.\");\n                return DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n            }\n\n            ActiveAdmin ap = getActiveAdminForCallerLocked(who,\n                    DeviceAdminInfo.USES_ENCRYPTED_STORAGE);\n\n            // Quick exit:  If the filesystem does not support encryption, we can exit early.\n            if (!isEncryptionSupported()) {\n                return DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n            }\n\n            // (1) Record the value for the admin so it's sticky\n            if (ap.encryptionRequested != encrypt) {\n                ap.encryptionRequested = encrypt;\n                saveSettingsLocked(userHandle);\n            }\n\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            // (2) Compute \"max\" for all admins\n            boolean newRequested = false;\n            final int N = policy.mAdminList.size();\n            for (int i = 0; i < N; i++) {\n                newRequested |= policy.mAdminList.get(i).encryptionRequested;\n            }\n\n            // Notify OS of new request\n            setEncryptionRequested(newRequested);\n\n            // Return the new global request status\n            return newRequested\n                    ? DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE\n                    : DevicePolicyManager.ENCRYPTION_STATUS_INACTIVE;\n        }\n    }\n\n    /**\n     * Get the current storage encryption request status for a given admin, or aggregate of all\n     * active admins.\n     */\n    @Override\n    public boolean getStorageEncryption(@Nullable ComponentName who, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            // Check for permissions if a particular caller is specified\n            if (caller.hasAdminComponent()) {\n                // When checking for a single caller, status is based on caller's request\n                ActiveAdmin ap = getActiveAdminUncheckedLocked(who, userHandle);\n                return ap != null ? ap.encryptionRequested : false;\n            }\n\n            // If no particular caller is specified, return the aggregate set of requests.\n            // This is short circuited by returning true on the first hit.\n            DevicePolicyData policy = getUserData(userHandle);\n            final int N = policy.mAdminList.size();\n            for (int i = 0; i < N; i++) {\n                if (policy.mAdminList.get(i).encryptionRequested) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Get the current encryption status of the device.\n     */\n    @Override\n    public int getStorageEncryptionStatus(@Nullable String callerPackage, int userHandle) {\n        if (!mHasFeature) {\n            // Ok to return current status.\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n\n        final ApplicationInfo ai;\n        try {\n            ai = mIPackageManager.getApplicationInfo(callerPackage, 0, userHandle);\n        } catch (RemoteException e) {\n            throw new SecurityException(e);\n        }\n\n        boolean legacyApp = false;\n        if (ai.targetSdkVersion <= Build.VERSION_CODES.M) {\n            legacyApp = true;\n        }\n\n        final int rawStatus = getEncryptionStatus();\n        if ((rawStatus == DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_PER_USER) && legacyApp) {\n            return DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE;\n        }\n        return rawStatus;\n    }\n\n    /**\n     * Hook to low-levels:  This should report if the filesystem supports encrypted storage.\n     */\n    private boolean isEncryptionSupported() {\n        // Note, this can be implemented as\n        //   return getEncryptionStatus() != DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n        // But is provided as a separate internal method if there's a faster way to do a\n        // simple check for supported-or-not.\n        return getEncryptionStatus() != DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n    }\n\n    /**\n     * Hook to low-levels:  Reporting the current status of encryption.\n     * @return Either {@link DevicePolicyManager#ENCRYPTION_STATUS_UNSUPPORTED}\n     * or {@link DevicePolicyManager#ENCRYPTION_STATUS_ACTIVE_PER_USER}.\n     */\n    private int getEncryptionStatus() {\n        if (mInjector.storageManagerIsFileBasedEncryptionEnabled()) {\n            return DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_PER_USER;\n        } else {\n            return DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n        }\n    }\n\n    /**\n     * Hook to low-levels:  If needed, record the new admin setting for encryption.\n     */\n    private void setEncryptionRequested(boolean encrypt) {\n    }\n\n    /**\n     * Set whether the screen capture is disabled for the user managed by the specified admin.\n     */\n    @Override\n    public void setScreenCaptureDisabled(\n            ComponentName who, String callerPackage, boolean disabled, boolean parent) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackage);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            caller = getCallerIdentity(who);\n            if (parent) {\n                Preconditions.checkCallAuthorization(\n                        isProfileOwnerOfOrganizationOwnedDevice(caller));\n            } else {\n                Preconditions.checkCallAuthorization(isProfileOwner(caller)\n                        || isDefaultDeviceOwner(caller));\n            }\n        }\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            int callerUserId = Binder.getCallingUserHandle().getIdentifier();\n            int targetUserId = parent ? getProfileParentId(callerUserId) : callerUserId;\n            EnforcingAdmin admin = enforcePermissionAndGetEnforcingAdmin(\n                    who, MANAGE_DEVICE_POLICY_SCREEN_CAPTURE, caller.getPackageName(),\n                    targetUserId);\n            if ((parent && isProfileOwnerOfOrganizationOwnedDevice(caller))\n                    || isDefaultDeviceOwner(caller)) {\n                if (disabled) {\n                    mDevicePolicyEngine.setGlobalPolicy(\n                            PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                            admin,\n                            new BooleanPolicyValue(disabled));\n                } else {\n                    mDevicePolicyEngine.removeGlobalPolicy(\n                            PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                            admin);\n                }\n            } else {\n                if (disabled) {\n                    mDevicePolicyEngine.setLocalPolicy(\n                            PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                            admin,\n                            new BooleanPolicyValue(disabled),\n                            callerUserId);\n                } else {\n                    mDevicePolicyEngine.removeLocalPolicy(\n                            PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                            admin,\n                            callerUserId);\n                }\n            }\n        } else {\n            synchronized (getLockObject()) {\n                ActiveAdmin ap = getParentOfAdminIfRequired(\n                        getProfileOwnerOrDefaultDeviceOwnerLocked(caller.getUserId()), parent);\n                if (ap.disableScreenCapture != disabled) {\n                    ap.disableScreenCapture = disabled;\n                    saveSettingsLocked(caller.getUserId());\n                    pushScreenCapturePolicy(caller.getUserId());\n                }\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SCREEN_CAPTURE_DISABLED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(disabled)\n                .write();\n    }\n\n    // Push the screen capture policy for a given userId. If screen capture is disabled by the\n    // DO or COPE PO on the parent profile, then this takes precedence as screen capture will\n    // be disabled device-wide.\n    private void pushScreenCapturePolicy(int adminUserId) {\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            return;\n        }\n        // Update screen capture device-wide if disabled by the DO or COPE PO on the parent profile.\n        // TODO(b/261999445): remove\n        ActiveAdmin admin;\n        if (isHeadlessFlagEnabled()) {\n            admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceParentLocked(\n                    mUserManagerInternal.getProfileParentId(adminUserId));\n        } else {\n            admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceParentLocked(\n                    UserHandle.USER_SYSTEM);\n        }\n        if (admin != null && admin.disableScreenCapture) {\n            setScreenCaptureDisabled(UserHandle.USER_ALL);\n            return;\n        }\n        // Otherwise, update screen capture only for the calling user.\n        admin = getProfileOwnerAdminLocked(adminUserId);\n        if (admin != null && admin.disableScreenCapture) {\n            setScreenCaptureDisabled(adminUserId);\n            return;\n        }\n        // If the admin is permission based, update only for the calling user.\n        admin = getUserData(adminUserId).createOrGetPermissionBasedAdmin(adminUserId);\n        if (admin != null && admin.disableScreenCapture) {\n            setScreenCaptureDisabled(adminUserId);\n            return;\n        }\n        setScreenCaptureDisabled(UserHandle.USER_NULL);\n    }\n\n    // Set the latest screen capture policy, overriding any existing ones.\n    // userHandle can be one of USER_ALL, USER_NULL or a concrete userId.\n    private void setScreenCaptureDisabled(int userHandle) {\n        int current = mPolicyCache.getScreenCaptureDisallowedUser();\n        if (userHandle == current) {\n            return;\n        }\n        mPolicyCache.setScreenCaptureDisallowedUser(userHandle);\n        updateScreenCaptureDisabled();\n    }\n\n    /**\n     * Returns whether or not screen capture is disabled for  any active admin.\n     */\n    @Override\n    public boolean getScreenCaptureDisabled(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return false;\n        }\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        if (parent) {\n            Preconditions.checkCallAuthorization(\n                    isProfileOwnerOfOrganizationOwnedDevice(getCallerIdentity().getUserId()));\n        }\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            Boolean disallowed = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                    userHandle);\n            return disallowed != null && disallowed;\n        } else {\n            return !mPolicyCache.isScreenCaptureAllowed(userHandle);\n        }\n    }\n\n    private void updateScreenCaptureDisabled() {\n        mHandler.post(() -> {\n            try {\n                mInjector.getIWindowManager().refreshScreenCaptureDisabled();\n            } catch (RemoteException e) {\n                Slogf.w(LOG_TAG, \"Unable to notify WindowManager.\", e);\n            }\n        });\n    }\n\n    @Override\n    public void setNearbyNotificationStreamingPolicy(int policy) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (admin.mNearbyNotificationStreamingPolicy != policy) {\n                admin.mNearbyNotificationStreamingPolicy = policy;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public int getNearbyNotificationStreamingPolicy(final int userId) {\n        if (!mHasFeature) {\n            return NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                        || hasCallingOrSelfPermission(permission.READ_NEARBY_STREAMING_POLICY));\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userId);\n            return admin != null\n                    ? admin.mNearbyNotificationStreamingPolicy\n                    : NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\n        }\n    }\n\n    @Override\n    public void setNearbyAppStreamingPolicy(int policy) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (admin.mNearbyAppStreamingPolicy != policy) {\n                admin.mNearbyAppStreamingPolicy = policy;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public int getNearbyAppStreamingPolicy(final int userId) {\n        if (!mHasFeature) {\n            return NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                        || hasCallingOrSelfPermission(permission.READ_NEARBY_STREAMING_POLICY));\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userId);\n            return admin != null\n                    ? admin.mNearbyAppStreamingPolicy\n                    : NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\n        }\n    }\n\n    /**\n     * Set whether auto time is required by the specified admin (must be device or profile owner).\n     */\n    @Override\n    public void setAutoTimeRequired(ComponentName who, boolean required) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDeviceOwner(caller) || isProfileOwner(caller));\n\n        boolean requireAutoTimeChanged = false;\n        synchronized (getLockObject()) {\n            Preconditions.checkCallAuthorization(!isManagedProfile(caller.getUserId()),\n                    \"Managed profile cannot set auto time required\");\n\n            if (isPolicyEngineForFinanceFlagEnabled()) {\n                EnforcingAdmin admin = getEnforcingAdminForCaller(who, who.getPackageName());\n                setGlobalUserRestrictionInternal(\n                        admin, UserManager.DISALLOW_CONFIG_DATE_TIME, required);\n            } else {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n                if (admin.requireAutoTime != required) {\n                    admin.requireAutoTime = required;\n                    saveSettingsLocked(caller.getUserId());\n                    requireAutoTimeChanged = true;\n                }\n                // requireAutoTime is now backed by DISALLOW_CONFIG_DATE_TIME restriction, so\n                // propagate updated restrictions to the framework.\n                if (requireAutoTimeChanged) {\n                    pushUserRestrictions(caller.getUserId());\n                }\n            }\n        }\n        // Turn AUTO_TIME on in settings if it is required\n        if (required) {\n            mInjector.binderWithCleanCallingIdentity(\n                    () -> mInjector.settingsGlobalPutInt(Settings.Global.AUTO_TIME,\n                            1 /* AUTO_TIME on */));\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_AUTO_TIME_REQUIRED)\n                .setAdmin(who)\n                .setBoolean(required)\n                .write();\n    }\n\n    /**\n     * Returns whether or not auto time is required by the device owner or any profile owner.\n     */\n    @Override\n    public boolean getAutoTimeRequired() {\n        if (!mHasFeature) {\n            return false;\n        }\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            Boolean required = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.getPolicyDefinitionForUserRestriction(\n                            UserManager.DISALLOW_CONFIG_DATE_TIME),\n                    mInjector.binderGetCallingUserHandle().getIdentifier());\n            return required != null && required;\n        } else {\n            synchronized (getLockObject()) {\n                ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n                if (deviceOwner != null && deviceOwner.requireAutoTime) {\n                    // If the device owner enforces auto time, we don't need to check the PO's\n                    return true;\n                }\n\n                // Now check to see if any profile owner on any user enforces auto time\n                for (Integer userId : mOwners.getProfileOwnerKeys()) {\n                    ActiveAdmin profileOwner = getProfileOwnerAdminLocked(userId);\n                    if (profileOwner != null && profileOwner.requireAutoTime) {\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Set whether auto time is enabled on the device.\n     */\n    @Override\n    public void setAutoTimeEnabled(@Nullable ComponentName who, String callerPackageName,\n            boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n\n        if (isUnicornFlagEnabled()) {\n            // The effect of this policy is device-wide.\n            enforcePermission(SET_TIME, caller.getPackageName(), UserHandle.USER_ALL);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwnerOnUser0(caller)\n                    || isProfileOwnerOfOrganizationOwnedDevice(caller) || isDefaultDeviceOwner(\n                    caller));\n        }\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.settingsGlobalPutInt(Settings.Global.AUTO_TIME, enabled ? 1 : 0));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_AUTO_TIME)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(enabled)\n                .write();\n    }\n\n    /**\n     * Returns whether auto time is used on the device or not.\n     */\n    @Override\n    public boolean getAutoTimeEnabled(@Nullable ComponentName who, String callerPackageName) {\n        if (!mHasFeature) {\n            return false;\n        }\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n\n        if (isUnicornFlagEnabled()) {\n            enforceCanQuery(SET_TIME, caller.getPackageName(), UserHandle.USER_ALL);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwnerOnUser0(caller)\n                    || isProfileOwnerOfOrganizationOwnedDevice(caller) || isDefaultDeviceOwner(\n                    caller));\n        }\n\n        return mInjector.settingsGlobalGetInt(Global.AUTO_TIME, 0) > 0;\n    }\n\n    /**\n     * Set whether auto time zone is enabled on the device.\n     */\n    @Override\n    public void setAutoTimeZoneEnabled(@Nullable ComponentName who, String callerPackageName,\n            boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n\n        if (isUnicornFlagEnabled()) {\n            // The effect of this policy is device-wide.\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    SET_TIME_ZONE,\n                    caller.getPackageName(),\n                    UserHandle.USER_ALL\n            );\n            mDevicePolicyEngine.setGlobalPolicy(\n                    PolicyDefinition.AUTO_TIMEZONE,\n                    // TODO(b/260573124): add correct enforcing admin when permission changes are\n                    //  merged.\n                    enforcingAdmin,\n                    new BooleanPolicyValue(enabled));\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwnerOnUser0(caller)\n                    || isProfileOwnerOfOrganizationOwnedDevice(caller) || isDefaultDeviceOwner(\n                    caller));\n            mInjector.binderWithCleanCallingIdentity(() ->\n                    mInjector.settingsGlobalPutInt(Global.AUTO_TIME_ZONE, enabled ? 1 : 0));\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_AUTO_TIME_ZONE)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(enabled)\n                .write();\n    }\n\n    /**\n     * Returns whether auto time zone is used on the device or not.\n     */\n    @Override\n    public boolean getAutoTimeZoneEnabled(@Nullable ComponentName who, String callerPackageName) {\n        if (!mHasFeature) {\n            return false;\n        }\n\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n\n        if (isUnicornFlagEnabled()) {\n            // The effect of this policy is device-wide.\n            enforceCanQuery(SET_TIME_ZONE, caller.getPackageName(), UserHandle.USER_ALL);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwnerOnUser0(caller)\n                    || isProfileOwnerOfOrganizationOwnedDevice(caller) || isDefaultDeviceOwner(\n                    caller));\n        }\n\n        return mInjector.settingsGlobalGetInt(Global.AUTO_TIME_ZONE, 0) > 0;\n    }\n\n    // TODO (b/137101239): remove this method in follow-up CL\n    // since it's only used for split system user.\n    @Override\n    public void setForceEphemeralUsers(ComponentName who, boolean forceEphemeralUsers) {\n        throw new UnsupportedOperationException(\"This method was used by split system user only.\");\n    }\n\n    // TODO (b/137101239): remove this method in follow-up CL\n    // since it's only used for split system user.\n    @Override\n    public boolean getForceEphemeralUsers(ComponentName who) {\n        throw new UnsupportedOperationException(\"This method was used by split system user only.\");\n    }\n\n    @Override\n    public boolean requestBugreport(ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        // TODO: If an unaffiliated user is removed, the admin will be able to request a bugreport\n        // which could still contain data related to that user. Should we disallow that, e.g. until\n        // next boot? Might not be needed given that this still requires user consent.\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkAllUsersAreAffiliatedWithDevice();\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_REQUEST_BUGREPORT);\n\n        if (mBugreportCollectionManager.requestBugreport()) {\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.REQUEST_BUGREPORT)\n                    .setAdmin(who)\n                    .write();\n\n            final long currentTime = System.currentTimeMillis();\n            synchronized (getLockObject()) {\n                DevicePolicyData policyData = getUserData(UserHandle.USER_SYSTEM);\n                if (currentTime > policyData.mLastBugReportRequestTime) {\n                    policyData.mLastBugReportRequestTime = currentTime;\n                    saveSettingsLocked(UserHandle.USER_SYSTEM);\n                }\n            }\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    void sendDeviceOwnerCommand(String action, Bundle extras) {\n        final int deviceOwnerUserId;\n        final ComponentName receiverComponent;\n        synchronized (getLockObject()) {\n            deviceOwnerUserId = mOwners.getDeviceOwnerUserId();\n            receiverComponent = mOwners.getDeviceOwnerComponent();\n        }\n        sendActiveAdminCommand(action, extras, deviceOwnerUserId, receiverComponent,\n                /* inForeground */ false);\n    }\n\n    void sendDeviceOwnerOrProfileOwnerCommand(String action, Bundle extras, int userId) {\n        if (userId == UserHandle.USER_ALL) {\n            userId = UserHandle.USER_SYSTEM;\n        }\n        boolean inForeground = false;\n        ComponentName receiverComponent = null;\n        if (action.equals(DeviceAdminReceiver.ACTION_NETWORK_LOGS_AVAILABLE)) {\n            inForeground = true;\n            receiverComponent = resolveDelegateReceiver(DELEGATION_NETWORK_LOGGING, action, userId);\n        }\n        if (action.equals(DeviceAdminReceiver.ACTION_SECURITY_LOGS_AVAILABLE)) {\n            inForeground = true;\n            receiverComponent = resolveDelegateReceiver(\n                DELEGATION_SECURITY_LOGGING, action, userId);\n        }\n        if (receiverComponent == null) {\n            receiverComponent = getOwnerComponent(userId);\n        }\n        sendActiveAdminCommand(action, extras, userId, receiverComponent, inForeground);\n    }\n\n    private void sendProfileOwnerCommand(String action, Bundle extras, @UserIdInt int userId) {\n        sendActiveAdminCommand(action, extras, userId, mOwners.getProfileOwnerComponent(userId),\n                /* inForeground */ false);\n    }\n\n    private void sendActiveAdminCommand(String action, Bundle extras,\n            @UserIdInt int userId, ComponentName receiverComponent, boolean inForeground) {\n        final Intent intent = new Intent(action);\n        intent.setComponent(receiverComponent);\n        if (extras != null) {\n            intent.putExtras(extras);\n        }\n        if (inForeground) {\n            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        }\n\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"sendActiveAdminCommand(): broadcasting \" + action + \" to \"\n                    + receiverComponent.flattenToShortString() + \" on user \" + userId);\n        }\n        mContext.sendBroadcastAsUser(intent, UserHandle.of(userId));\n    }\n\n    private void sendOwnerChangedBroadcast(String broadcast, int userId) {\n        final Intent intent = new Intent(broadcast)\n                .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        mContext.sendBroadcastAsUser(intent, UserHandle.of(userId));\n    }\n\n    void sendBugreportToDeviceOwner(Uri bugreportUri, String bugreportHash) {\n        synchronized (getLockObject()) {\n            final Intent intent = new Intent(DeviceAdminReceiver.ACTION_BUGREPORT_SHARE);\n            intent.setComponent(mOwners.getDeviceOwnerComponent());\n            intent.setDataAndType(bugreportUri, RemoteBugreportManager.BUGREPORT_MIMETYPE);\n            intent.putExtra(DeviceAdminReceiver.EXTRA_BUGREPORT_HASH, bugreportHash);\n            intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n\n            final UriGrantsManagerInternal ugm = LocalServices\n                    .getService(UriGrantsManagerInternal.class);\n            final NeededUriGrants needed = ugm.checkGrantUriPermissionFromIntent(intent,\n                    Process.SHELL_UID, mOwners.getDeviceOwnerComponent().getPackageName(),\n                    mOwners.getDeviceOwnerUserId());\n            ugm.grantUriPermissionUncheckedFromIntent(needed, null);\n\n            mContext.sendBroadcastAsUser(intent, UserHandle.of(mOwners.getDeviceOwnerUserId()));\n        }\n    }\n\n    void setDeviceOwnerRemoteBugreportUriAndHash(String bugreportUri, String bugreportHash) {\n        synchronized (getLockObject()) {\n            mOwners.setDeviceOwnerRemoteBugreportUriAndHash(bugreportUri, bugreportHash);\n        }\n    }\n\n    Pair<String, String> getDeviceOwnerRemoteBugreportUriAndHash() {\n        synchronized (getLockObject()) {\n            final String uri = mOwners.getDeviceOwnerRemoteBugreportUri();\n            return uri == null ? null\n                    : new Pair<>(uri, mOwners.getDeviceOwnerRemoteBugreportHash());\n        }\n    }\n\n    /**\n     * Disables all device cameras according to the specified admin.\n     */\n    @Override\n    public void setCameraDisabled(ComponentName who, String callerPackageName, boolean disabled,\n            boolean parent) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        final int userId = caller.getUserId();\n\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_CAMERA_DISABLED);\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_CAMERA,\n                    caller.getPackageName(),\n                    getProfileParentUserIfRequested(userId, parent));\n            try {\n                setBackwardCompatibleUserRestriction(\n                        caller, enforcingAdmin, UserManager.DISALLOW_CAMERA, disabled, parent);\n            } catch (IllegalStateException e) {\n                throw new IllegalStateException(\n                        \"Please use addUserRestriction or addUserRestrictionGlobally using the key\"\n                                + \" UserManager.DISALLOW_CAMERA to disable the camera locally or\"\n                                + \" globally, respectively\");\n            }\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            if (parent) {\n                Preconditions.checkCallAuthorization(\n                        isProfileOwnerOfOrganizationOwnedDevice(caller));\n            }\n            synchronized (getLockObject()) {\n                ActiveAdmin admin = getActiveAdminForCallerLocked(who,\n                        DeviceAdminInfo.USES_POLICY_DISABLE_CAMERA, parent);\n                if (admin.disableCamera != disabled) {\n                    admin.disableCamera = disabled;\n                    saveSettingsLocked(userId);\n                }\n            }\n            // Tell the user manager that the restrictions have changed.\n            pushUserRestrictions(userId);\n        }\n\n        final int affectedUserId = parent ? getProfileParentId(userId) : userId;\n        if (SecurityLog.isLoggingEnabled() && who != null) {\n            SecurityLog.writeEvent(SecurityLog.TAG_CAMERA_POLICY_SET,\n                    who.getPackageName(), userId, affectedUserId, disabled ? 1 : 0);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CAMERA_DISABLED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(disabled)\n                .setStrings(parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT)\n                .write();\n    }\n\n    /**\n     * Gets whether or not all device cameras are disabled for a given admin, or disabled for any\n     * active admins.\n     */\n    @Override\n    public boolean getCameraDisabled(ComponentName who, String callerPackageName, int userHandle,\n            boolean parent) {\n        if (!mHasFeature) {\n            return false;\n        }\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    hasFullCrossUsersPermission(caller, userHandle)\n                            || isCameraServerUid(caller)\n                            || hasPermission(MANAGE_DEVICE_POLICY_CAMERA,\n                                caller.getPackageName(), userHandle)\n                            || hasPermission(QUERY_ADMIN_POLICY, caller.getPackageName()));\n        } else {\n            Preconditions.checkCallAuthorization(\n                    hasFullCrossUsersPermission(caller, userHandle) || isCameraServerUid(caller));\n            if (parent) {\n                Preconditions.checkCallAuthorization(\n                        isProfileOwnerOfOrganizationOwnedDevice(caller.getUserId()));\n            }\n        }\n\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            PolicyDefinition<Boolean> policy =\n                    PolicyDefinition.getPolicyDefinitionForUserRestriction(\n                            UserManager.DISALLOW_CAMERA);\n            if (who != null) {\n                EnforcingAdmin admin = getEnforcingAdminForCaller(who, callerPackageName);\n                return Boolean.TRUE.equals(\n                        mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                                policy, admin, affectedUserId));\n            } else {\n                return Boolean.TRUE.equals(\n                        mDevicePolicyEngine.getResolvedPolicy(policy, affectedUserId));\n            }\n        } else {\n            synchronized (getLockObject()) {\n                if (who != null) {\n                    ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                    return (admin != null) && admin.disableCamera;\n                }\n                // First, see if DO has set it.  If so, it's device-wide.\n                final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n                if (deviceOwner != null && deviceOwner.disableCamera) {\n                    return true;\n                }\n\n                // Return the strictest policy across all participating admins.\n                List<ActiveAdmin> admins = getActiveAdminsForAffectedUserLocked(affectedUserId);\n\n                // Determine whether or not the device camera is disabled for any active admins.\n                for (ActiveAdmin activeAdmin : admins) {\n                    if (activeAdmin.disableCamera) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n\n    @Override\n    public void setKeyguardDisabledFeatures(\n            ComponentName who, String callerPackageName, int which, boolean parent) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n        }\n\n        final int userHandle = caller.getUserId();\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n        synchronized (getLockObject()) {\n            if (isUnicornFlagEnabled()) {\n                // SUPPORT USES_POLICY_DISABLE_KEYGUARD_FEATURES\n                EnforcingAdmin admin = enforcePermissionAndGetEnforcingAdmin(\n                        who, MANAGE_DEVICE_POLICY_KEYGUARD, caller.getPackageName(),\n                        affectedUserId);\n                if (which == 0) {\n                    mDevicePolicyEngine.removeLocalPolicy(\n                            PolicyDefinition.KEYGUARD_DISABLED_FEATURES, admin, affectedUserId);\n                } else {\n                    // TODO(b/273723433): revisit silent masking of features\n                    if (isManagedProfile(userHandle)) {\n                        if (parent) {\n                            if (isProfileOwnerOfOrganizationOwnedDevice(caller)) {\n                                which = which & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\n                            } else {\n                                which = which\n                                        & NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\n                            }\n                        } else {\n                            which = which & PROFILE_KEYGUARD_FEATURES;\n                        }\n                    }\n                    mDevicePolicyEngine.setLocalPolicy(PolicyDefinition.KEYGUARD_DISABLED_FEATURES,\n                            admin, new IntegerPolicyValue(which), affectedUserId);\n                }\n                invalidateBinderCaches();\n            } else {\n                ActiveAdmin ap = getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_DISABLE_KEYGUARD_FEATURES, parent);\n                if (isManagedProfile(userHandle)) {\n                    if (parent) {\n                        if (isProfileOwnerOfOrganizationOwnedDevice(caller)) {\n                            which = which & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\n                        } else {\n                            which = which & NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\n                        }\n                    } else {\n                        which = which & PROFILE_KEYGUARD_FEATURES;\n                    }\n                }\n                if (ap.disabledKeyguardFeatures != which) {\n                    ap.disabledKeyguardFeatures = which;\n                    saveSettingsLocked(userHandle);\n                }\n            }\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISABLED_FEATURES_SET,\n                    caller.getPackageName(), userHandle, affectedUserId, which);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_KEYGUARD_DISABLED_FEATURES)\n                .setAdmin(caller.getPackageName())\n                .setInt(which)\n                .setStrings(parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT)\n                .write();\n    }\n\n    /**\n     * Gets the disabled state for features in keyguard for the given admin,\n     * or the aggregate of all active admins if who is null.\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public int getKeyguardDisabledFeatures(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(\n                who == null || isCallingFromPackage(who.getPackageName(), caller.getUid())\n                        || isSystemUid(caller));\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n\n        synchronized (getLockObject()) {\n            if (who != null) {\n                if (isUnicornFlagEnabled()) {\n                    EnforcingAdmin admin = getEnforcingAdminForPackage(\n                            who, who.getPackageName(), userHandle);\n                    Integer features = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                            PolicyDefinition.KEYGUARD_DISABLED_FEATURES,\n                            admin,\n                            affectedUserId);\n\n                    return features == null ? 0 : features;\n                } else {\n                    ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                    return (admin != null) ? admin.disabledKeyguardFeatures : 0;\n                }\n            }\n\n            if (isUnicornFlagEnabled()) {\n                Integer features = mDevicePolicyEngine.getResolvedPolicy(\n                        PolicyDefinition.KEYGUARD_DISABLED_FEATURES,\n                        affectedUserId);\n\n                return Binder.withCleanCallingIdentity(() -> {\n                    int combinedFeatures = features == null ? 0 : features;\n                    List<UserInfo> profiles = mUserManager.getProfiles(affectedUserId);\n                    for (UserInfo profile : profiles) {\n                        int profileId = profile.id;\n                        if (profileId == affectedUserId) {\n                            continue;\n                        }\n                        Integer profileFeatures = mDevicePolicyEngine.getResolvedPolicy(\n                                PolicyDefinition.KEYGUARD_DISABLED_FEATURES,\n                                profileId);\n                        if (profileFeatures != null) {\n                            combinedFeatures |= (profileFeatures\n                                    & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER);\n                        }\n                    }\n                    return combinedFeatures;\n                });\n            }\n\n            final long ident = mInjector.binderClearCallingIdentity();\n            try {\n                final List<ActiveAdmin> admins;\n                if (!parent && isManagedProfile(userHandle)) {\n                    // If we are being asked about a managed profile, just return keyguard features\n                    // disabled by admins in the profile.\n                    admins = getUserDataUnchecked(userHandle).mAdminList;\n                } else {\n                    // Otherwise return those set by admins in the user and its profiles.\n                    admins = getActiveAdminsForLockscreenPoliciesLocked(\n                            getProfileParentUserIfRequested(userHandle, parent));\n                }\n\n                int which = DevicePolicyManager.KEYGUARD_DISABLE_FEATURES_NONE;\n                final int N = admins.size();\n                for (int i = 0; i < N; i++) {\n                    ActiveAdmin admin = admins.get(i);\n                    int userId = admin.getUserHandle().getIdentifier();\n                    boolean isRequestedUser = !parent && (userId == userHandle);\n                    if (isRequestedUser || !isManagedProfile(userId)) {\n                        // If we are being asked explicitly about this user\n                        // return all disabled features even if its a managed profile.\n                        which |= admin.disabledKeyguardFeatures;\n                    } else {\n                        // Otherwise a managed profile is only allowed to disable\n                        // some features on the parent user.\n                        which |= (admin.disabledKeyguardFeatures\n                                & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER);\n                    }\n                }\n                return which;\n            } finally {\n                mInjector.binderRestoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public void setKeepUninstalledPackages(ComponentName who, String callerPackage,\n            List<String> packageList) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(packageList, \"packageList is null\");\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                &&  isDefaultDeviceOwner(caller))\n                || (caller.hasPackage()\n                && isCallerDelegate(caller, DELEGATION_KEEP_UNINSTALLED_PACKAGES)));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_KEEP_UNINSTALLED_PACKAGES);\n\n        synchronized (getLockObject()) {\n            // Get the device owner\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            // Set list of packages to be kept even if uninstalled.\n            deviceOwner.keepUninstalledPackages = packageList;\n            // Save settings.\n            saveSettingsLocked(caller.getUserId());\n            // Notify package manager.\n            mInjector.getPackageManagerInternal().setKeepUninstalledPackages(packageList);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_KEEP_UNINSTALLED_PACKAGES)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ who == null)\n                .setStrings(packageList.toArray(new String[0]))\n                .write();\n    }\n\n    @Override\n    public List<String> getKeepUninstalledPackages(ComponentName who, String callerPackage) {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                &&  isDefaultDeviceOwner(caller))\n                || (caller.hasPackage()\n                && isCallerDelegate(caller, DELEGATION_KEEP_UNINSTALLED_PACKAGES)));\n\n        synchronized (getLockObject()) {\n            return getKeepUninstalledPackagesLocked();\n        }\n    }\n\n    private List<String> getKeepUninstalledPackagesLocked() {\n        ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n        return (deviceOwner != null) ? deviceOwner.keepUninstalledPackages : null;\n    }\n\n    /**\n     * Logs a warning when the device doesn't have {@code PackageManager.FEATURE_DEVICE_ADMIN}.\n     *\n     * @param message action that was not executed; should not end with a period because the missing\n     * feature will be appended to it.\n     */\n    private void logMissingFeatureAction(String message) {\n        Slogf.w(LOG_TAG, message + \" because device does not have the \"\n                + PackageManager.FEATURE_DEVICE_ADMIN + \" feature.\");\n    }\n\n    @Override\n    public boolean setDeviceOwner(ComponentName admin, int userId,\n            boolean setProfileOwnerOnCurrentUserIfNecessary) {\n        if (!mHasFeature) {\n            logMissingFeatureAction(\"Cannot set \" + ComponentName.flattenToShortString(admin)\n                    + \" as device owner for user \" + userId);\n            return false;\n        }\n        Preconditions.checkArgument(admin != null);\n\n        final CallerIdentity caller = getCallerIdentity();\n\n        boolean hasIncompatibleAccountsOrNonAdb =\n                !isAdb(caller) || hasIncompatibleAccountsOnAnyUser();\n\n        if (!hasIncompatibleAccountsOrNonAdb) {\n            synchronized (getLockObject()) {\n                if (!isAdminTestOnlyLocked(admin, userId) && hasAccountsOnAnyUser()) {\n                    Slogf.w(LOG_TAG,\n                            \"Non test-only owner can't be installed with existing accounts.\");\n                    return false;\n                }\n            }\n        }\n\n        synchronized (getLockObject()) {\n            enforceCanSetDeviceOwnerLocked(caller, admin, userId, hasIncompatibleAccountsOrNonAdb);\n\n            Preconditions.checkArgument(isPackageInstalledForUser(admin.getPackageName(), userId),\n                    \"Invalid component \" + admin + \" for device owner\");\n            final ActiveAdmin activeAdmin = getActiveAdminUncheckedLocked(admin, userId);\n            Preconditions.checkArgument(activeAdmin != null && !getUserData(\n                    userId).mRemovingAdmins.contains(admin), \"Not active admin: \" + admin);\n\n            // Shutting down backup manager service permanently.\n            toggleBackupServiceActive(UserHandle.USER_SYSTEM, /* makeActive= */ false);\n            if (isAdb(caller)) {\n                // Log device owner provisioning was started using adb.\n                MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_DEVICE_OWNER);\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.PROVISIONING_ENTRY_POINT_ADB)\n                        .setAdmin(admin)\n                        .setStrings(LOG_TAG_DEVICE_OWNER)\n                        .write();\n            }\n\n            mOwners.setDeviceOwner(admin, userId);\n            mOwners.writeDeviceOwner();\n            setDeviceOwnershipSystemPropertyLocked();\n\n            //TODO(b/180371154): when provisionFullyManagedDevice is used in tests, remove this\n            // hard-coded default value setting.\n            if (isAdb(caller)) {\n                activeAdmin.mAdminCanGrantSensorsPermissions = true;\n                mPolicyCache.setAdminCanGrantSensorsPermissions(true);\n                saveSettingsLocked(userId);\n            }\n\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                // Restrict adding a managed profile when a device owner is set on the device.\n                // That is to prevent the co-existence of a managed profile and a device owner\n                // on the same device.\n                // Instead, the device may be provisioned with an organization-owned managed\n                // profile, such that the admin on that managed profile has extended management\n                // capabilities that can affect the entire device (but not access private data\n                // on the primary profile).\n                if (isHeadlessFlagEnabled()) {\n                    for (int u : mUserManagerInternal.getUserIds()) {\n                        mUserManager.setUserRestriction(\n                                UserManager.DISALLOW_ADD_MANAGED_PROFILE, true,\n                                UserHandle.of(u));\n                        // Restrict adding a clone profile when a device owner is set on the device.\n                        // That is to prevent the co-existence of a clone profile and a device owner\n                        // on the same device.\n                        // CDD for reference : https://source.android.com/compatibility/12/android-12-cdd#95_multi-user_support\n                        mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE,\n                                true,\n                                UserHandle.of(u));\n                    }\n                } else {\n                    mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                            true,\n                            UserHandle.of(userId));\n                    // Restrict adding a clone profile when a device owner is set on the device.\n                    // That is to prevent the co-existence of a clone profile and a device owner\n                    // on the same device.\n                    // CDD for reference : https://source.android.com/compatibility/12/android-12-cdd#95_multi-user_support\n                    mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE,\n                            true,\n                            UserHandle.of(userId));\n                }\n                // TODO Send to system too?\n                sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_DEVICE_OWNER_CHANGED, userId);\n            });\n            mDeviceAdminServiceController.startServiceForAdmin(\n                    admin.getPackageName(), userId, \"set-device-owner\");\n\n            Slogf.i(LOG_TAG, \"Device owner set: \" + admin + \" on user \" + userId);\n        }\n\n        if (setProfileOwnerOnCurrentUserIfNecessary\n                && mInjector.userManagerIsHeadlessSystemUserMode()) {\n            int currentForegroundUser;\n            synchronized (getLockObject()) {\n                currentForegroundUser = getCurrentForegroundUserId();\n            }\n            Slogf.i(LOG_TAG, \"setDeviceOwner(): setting \" + admin\n                    + \" as profile owner on user \" + currentForegroundUser);\n            // Sets profile owner on current foreground user since\n            // the human user will complete the DO setup workflow from there.\n            manageUserUnchecked(/* deviceOwner= */ admin, /* profileOwner= */ admin,\n                    /* managedUser= */ currentForegroundUser, /* adminExtras= */ null,\n                    /* showDisclaimer= */ false);\n        }\n        return true;\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public boolean hasDeviceOwner() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || canManageUsers(caller) || isFinancedDeviceOwner(\n                        caller) || hasCallingOrSelfPermission(\n                        MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        return mOwners.hasDeviceOwner();\n    }\n\n    boolean isDeviceOwner(ActiveAdmin admin) {\n        return isDeviceOwner(admin.info.getComponent(), admin.getUserHandle().getIdentifier());\n    }\n\n    /**\n     * Check if the user is a Device Owner\n     *\n     * @param who    component to check against\n     * @param userId user to check\n     * @return if the user is a Device Owner\n     */\n    public boolean isDeviceOwner(@Nullable ComponentName who, int userId) {\n        synchronized (getLockObject()) {\n            return mOwners.hasDeviceOwner() && mOwners.getDeviceOwnerUserId() == userId\n                    && mOwners.getDeviceOwnerComponent().equals(who);\n        }\n    }\n\n    /**\n     * Returns {@code true} <b>only if</b> the caller is the device owner and the device owner type\n     * is {@link DevicePolicyManager#DEVICE_OWNER_TYPE_DEFAULT}. {@code false} is returned for the\n     * case where the caller is not the device owner, there is no device owner, or the device owner\n     * type is not {@link DevicePolicyManager#DEVICE_OWNER_TYPE_DEFAULT}.\n     *\n     */\n    private boolean isDefaultDeviceOwner(CallerIdentity caller) {\n        synchronized (getLockObject()) {\n            return isDeviceOwnerLocked(caller) && getDeviceOwnerTypeLocked(\n                    mOwners.getDeviceOwnerPackageName()) == DEVICE_OWNER_TYPE_DEFAULT;\n        }\n    }\n\n    /**\n     * Returns {@code true} if the provided caller identity is of a device owner.\n     * @param caller identity of caller.\n     * @return true if {@code identity} is a device owner, false otherwise.\n     */\n    public boolean isDeviceOwner(CallerIdentity caller) {\n        synchronized (getLockObject()) {\n            return isDeviceOwnerLocked(caller);\n        }\n    }\n\n    private boolean isDeviceOwnerLocked(CallerIdentity caller) {\n        if (!mOwners.hasDeviceOwner() || mOwners.getDeviceOwnerUserId() != caller.getUserId()) {\n            return false;\n        }\n\n        if (caller.hasAdminComponent()) {\n            return mOwners.getDeviceOwnerComponent().equals(caller.getComponentName());\n        } else {\n            return isUidDeviceOwnerLocked(caller.getUid());\n        }\n    }\n\n    private boolean isDeviceOwnerUserId(int userId) {\n        synchronized (getLockObject()) {\n            return mOwners.getDeviceOwnerComponent() != null\n                    && mOwners.getDeviceOwnerUserId() == userId;\n        }\n    }\n\n    /**\n     * Check if {@link userId} is a Profile Owner\n     *\n     * @param who    component to check against\n     * @param userId user to check\n     * @return if the user is a Profile Owner\n     */\n    public boolean isProfileOwner(@Nullable ComponentName who, int userId) {\n        final ComponentName profileOwner = mInjector.binderWithCleanCallingIdentity(\n                () -> getProfileOwnerAsUser(userId));\n        return who != null && who.equals(profileOwner);\n    }\n\n    /**\n     * Returns {@code true} if the provided caller identity is of a profile owner.\n     * @param caller identity of caller.\n     * @return true if {@code identity} is a profile owner, false otherwise.\n     */\n    public boolean isProfileOwner(CallerIdentity caller) {\n        synchronized (getLockObject()) {\n            final ComponentName profileOwner = mInjector.binderWithCleanCallingIdentity(() ->\n                    getProfileOwnerAsUser(caller.getUserId()));\n            // No profile owner.\n            if (profileOwner == null) {\n                return false;\n            }\n            // The admin ComponentName was specified, check it directly.\n            if (caller.hasAdminComponent()) {\n                return profileOwner.equals(caller.getComponentName());\n            } else {\n                return isUidProfileOwnerLocked(caller.getUid());\n            }\n        }\n    }\n\n    /**\n     * Checks if the app uid provided is the profile owner. This method should only be called\n     * if no componentName is available.\n     *\n     * @param appUid UID of the caller.\n     * @return true if the caller is the profile owner\n     */\n    private boolean isUidProfileOwnerLocked(int appUid) {\n        ensureLocked();\n\n        final int userId = UserHandle.getUserId(appUid);\n        final ComponentName profileOwnerComponent = mOwners.getProfileOwnerComponent(userId);\n        if (profileOwnerComponent == null) {\n            return false;\n        }\n        for (ActiveAdmin admin : getUserData(userId).mAdminList) {\n            final ComponentName currentAdminComponent = admin.info.getComponent();\n            if (admin.getUid() == appUid && profileOwnerComponent.equals(currentAdminComponent)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean hasProfileOwner(int userId) {\n        synchronized (getLockObject()) {\n            return mOwners.hasProfileOwner(userId);\n        }\n    }\n\n    /**\n     * Returns {@code true} if the provided caller identity is of a profile owner of an organization\n     * owned device.\n     *\n     * @param caller identity of caller\n     * @return true if {@code identity} is a profile owner of an organization owned device, false\n     * otherwise.\n     */\n    private boolean isProfileOwnerOfOrganizationOwnedDevice(CallerIdentity caller) {\n        return isProfileOwner(caller) && isProfileOwnerOfOrganizationOwnedDevice(\n                caller.getUserId());\n    }\n\n    private boolean isProfileOwnerOfOrganizationOwnedDevice(int userId) {\n        synchronized (getLockObject()) {\n            return mOwners.isProfileOwnerOfOrganizationOwnedDevice(userId);\n        }\n    }\n\n    private boolean isProfileOwnerOfOrganizationOwnedDevice(ComponentName who, int userId) {\n        return isProfileOwner(who, userId) && isProfileOwnerOfOrganizationOwnedDevice(userId);\n    }\n\n    private boolean isProfileOwnerOnUser0(CallerIdentity caller) {\n        return isProfileOwner(caller) && caller.getUserHandle().isSystem();\n    }\n\n    private boolean isPackage(CallerIdentity caller, String packageName) {\n        return isCallingFromPackage(packageName, caller.getUid());\n    }\n\n    @Override\n    public ComponentName getDeviceOwnerComponent(boolean callingUserOnly) {\n        if (!mHasFeature) {\n            return null;\n        }\n        if (!callingUserOnly) {\n            Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                    || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        }\n        synchronized (getLockObject()) {\n            if (!mOwners.hasDeviceOwner()) {\n                return null;\n            }\n            if (callingUserOnly && mInjector.userHandleGetCallingUserId() !=\n                    mOwners.getDeviceOwnerUserId()) {\n                return null;\n            }\n            return mOwners.getDeviceOwnerComponent();\n        }\n    }\n\n    private int getDeviceOwnerUserIdUncheckedLocked() {\n        return mOwners.hasDeviceOwner() ? mOwners.getDeviceOwnerUserId() : UserHandle.USER_NULL;\n    }\n\n    @Override\n    public int getDeviceOwnerUserId() {\n        if (!mHasFeature) {\n            return UserHandle.USER_NULL;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            return getDeviceOwnerUserIdUncheckedLocked();\n        }\n    }\n\n    private @UserIdInt int getMainUserId() {\n        int mainUserId = mUserManagerInternal.getMainUserId();\n        if (mainUserId == UserHandle.USER_NULL) {\n            Slogf.d(LOG_TAG, \"getMainUserId(): no main user, returning USER_SYSTEM\");\n            return UserHandle.USER_SYSTEM;\n        }\n        return mainUserId;\n    }\n\n    // TODO(b/240562946): Remove api as owner name is not used.\n    /**\n     * Returns the \"name\" of the device owner.  It'll work for non-DO users too, but requires\n     * MANAGE_USERS.\n     */\n    @Override\n    public String getDeviceOwnerName() {\n        if (!mHasFeature) {\n            return null;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        synchronized (getLockObject()) {\n            if (!mOwners.hasDeviceOwner()) {\n                return null;\n            }\n            // TODO This totally ignores the name passed to setDeviceOwner (change for b/20679292)\n            // Should setDeviceOwner/ProfileOwner still take a name?\n            String deviceOwnerPackage = mOwners.getDeviceOwnerPackageName();\n            return getApplicationLabel(deviceOwnerPackage, UserHandle.USER_SYSTEM);\n        }\n    }\n\n    /** Returns the active device owner or {@code null} if there is no device owner. */\n    @VisibleForTesting\n    ActiveAdmin getDeviceOwnerAdminLocked() {\n        ensureLocked();\n        ComponentName component = mOwners.getDeviceOwnerComponent();\n        if (component == null) {\n            return null;\n        }\n\n        DevicePolicyData policy = getUserData(mOwners.getDeviceOwnerUserId());\n        final int n = policy.mAdminList.size();\n        for (int i = 0; i < n; i++) {\n            ActiveAdmin admin = policy.mAdminList.get(i);\n            if (component.equals(admin.info.getComponent())) {\n                return admin;\n            }\n        }\n        Slogf.wtf(LOG_TAG, \"Active admin for device owner not found. component=\" + component);\n        return null;\n    }\n\n    /**\n     * @deprecated Use the version which does not take a user id.\n     */\n    @Deprecated\n    ActiveAdmin getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked(int userId) {\n        ensureLocked();\n        ActiveAdmin admin = getDeviceOwnerAdminLocked();\n        if (admin == null) {\n            admin = getProfileOwnerOfOrganizationOwnedDeviceLocked(userId);\n        }\n        return admin;\n    }\n\n    ActiveAdmin getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked() {\n        ensureLocked();\n        ActiveAdmin admin = getDeviceOwnerAdminLocked();\n        if (admin == null) {\n            admin = getProfileOwnerOfOrganizationOwnedDeviceLocked();\n        }\n        return admin;\n    }\n\n    ActiveAdmin getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceOrSystemPermissionBasedAdminLocked() {\n        ensureLocked();\n        ActiveAdmin doOrPo = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n        if (isPermissionCheckFlagEnabled() && doOrPo == null) {\n            return getUserData(0).mPermissionBasedAdmin;\n        }\n        return doOrPo;\n    }\n\n    ActiveAdmin getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceParentLocked(int userId) {\n        ensureLocked();\n        ActiveAdmin admin = getDeviceOwnerAdminLocked();\n        if (admin != null) {\n            return admin;\n        }\n        admin = getProfileOwnerOfOrganizationOwnedDeviceLocked(userId);\n        return admin != null ? admin.getParentActiveAdmin() : null;\n    }\n\n    @Override\n    public void clearDeviceOwner(String packageName) {\n        Objects.requireNonNull(packageName, \"packageName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(packageName);\n        synchronized (getLockObject()) {\n            final ComponentName deviceOwnerComponent = mOwners.getDeviceOwnerComponent();\n            final int deviceOwnerUserId = mOwners.getDeviceOwnerUserId();\n            if (!mOwners.hasDeviceOwner()\n                    || !deviceOwnerComponent.getPackageName().equals(packageName)\n                    || (deviceOwnerUserId != caller.getUserId())) {\n                throw new SecurityException(\n                        \"clearDeviceOwner can only be called by the device owner\");\n            }\n            enforceUserUnlocked(deviceOwnerUserId);\n\n            final ActiveAdmin admin = getDeviceOwnerAdminLocked();\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                clearDeviceOwnerLocked(admin, deviceOwnerUserId);\n                removeActiveAdminLocked(deviceOwnerComponent, deviceOwnerUserId);\n                sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_DEVICE_OWNER_CHANGED,\n                        deviceOwnerUserId);\n            });\n            Slogf.i(LOG_TAG, \"Device owner removed: \" + deviceOwnerComponent);\n        }\n    }\n\n    private void clearOverrideApnUnchecked() {\n        if (!mHasTelephonyFeature) {\n            return;\n        }\n        // Disable Override APNs and remove them from database.\n        setOverrideApnsEnabledUnchecked(false);\n        final List<ApnSetting> apns = getOverrideApnsUnchecked();\n        for (int i = 0; i < apns.size(); i ++) {\n            removeOverrideApnUnchecked(apns.get(i).getId());\n        }\n    }\n\n    private void clearManagedProfileApnUnchecked() {\n        if (!mHasTelephonyFeature) {\n            return;\n        }\n        if (!LocalServices.getService(SystemServiceManager.class).isBootCompleted()) {\n            Slogf.i(LOG_TAG, \"Skip clearing managed profile Apn before boot completed\");\n            // Cannot talk to APN content provider before system boots\n            // Ideally we should delay the cleanup post boot_completed, not just\n            // skipping  it altogether.\n            return;\n        }\n        final List<ApnSetting> apns = getOverrideApnsUnchecked();\n        for (ApnSetting apn : apns) {\n            if (apn.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE) {\n                removeOverrideApnUnchecked(apn.getId());\n            }\n        }\n    }\n\n    private void clearDeviceOwnerLocked(ActiveAdmin admin, int userId) {\n        String ownersPackage = mOwners.getDeviceOwnerPackageName();\n        if (ownersPackage != null) {\n            mDeviceAdminServiceController.stopServiceForAdmin(\n                    ownersPackage, userId, \"clear-device-owner\");\n        }\n\n        if (admin != null) {\n            admin.disableCamera = false;\n            admin.userRestrictions = null;\n            admin.defaultEnabledRestrictionsAlreadySet.clear();\n            admin.forceEphemeralUsers = false;\n            admin.isNetworkLoggingEnabled = false;\n            admin.requireAutoTime = false;\n            mUserManagerInternal.setForceEphemeralUsers(admin.forceEphemeralUsers);\n        }\n        final DevicePolicyData policyData = getUserData(userId);\n        policyData.mCurrentInputMethodSet = false;\n        if (policyData.mPasswordTokenHandle != 0) {\n            mLockPatternUtils.removeEscrowToken(policyData.mPasswordTokenHandle, userId);\n            policyData.mPasswordTokenHandle = 0;\n        }\n        saveSettingsLocked(userId);\n        mPolicyCache.onUserRemoved(userId);\n        final DevicePolicyData systemPolicyData = getUserData(UserHandle.USER_SYSTEM);\n        systemPolicyData.mLastSecurityLogRetrievalTime = -1;\n        systemPolicyData.mLastBugReportRequestTime = -1;\n        systemPolicyData.mLastNetworkLogsRetrievalTime = -1;\n        saveSettingsLocked(UserHandle.USER_SYSTEM);\n        clearUserPoliciesLocked(userId);\n        clearOverrideApnUnchecked();\n        clearApplicationRestrictions(userId);\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            mInjector.getPackageManagerInternal().clearBlockUninstallForUser(userId);\n        }\n\n        mOwners.clearDeviceOwner();\n        mOwners.writeDeviceOwner();\n\n        updateAdminCanGrantSensorsPermissionCache(userId);\n        clearDeviceOwnerUserRestriction(UserHandle.of(userId));\n        mInjector.securityLogSetLoggingEnabledProperty(false);\n        mSecurityLogMonitor.stop();\n        setNetworkLoggingActiveInternal(false);\n        deleteTransferOwnershipBundleLocked(userId);\n        toggleBackupServiceActive(UserHandle.USER_SYSTEM, true);\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            pushUserControlDisabledPackagesLocked(userId);\n        }\n        setGlobalSettingDeviceOwnerType(DEVICE_OWNER_TYPE_DEFAULT);\n\n        if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n            mDevicePolicyEngine.removePoliciesForAdmin(\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(), userId, admin));\n        }\n    }\n\n    private void clearApplicationRestrictions(int userId) {\n        // Changing app restrictions involves disk IO, offload it to the background thread.\n        mBackgroundHandler.post(() -> {\n            final List<PackageInfo> installedPackageInfos = mInjector.getPackageManager(userId)\n                    .getInstalledPackages(MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE);\n            final UserHandle userHandle = UserHandle.of(userId);\n            for (final PackageInfo packageInfo : installedPackageInfos) {\n                mInjector.getUserManager().setApplicationRestrictions(\n                        packageInfo.packageName, null /* restrictions */, userHandle);\n            }\n        });\n    }\n\n    @Override\n    public boolean setProfileOwner(ComponentName who, int userHandle) {\n        if (!mHasFeature) {\n            logMissingFeatureAction(\"Cannot set \" + ComponentName.flattenToShortString(who)\n                    + \" as profile owner for user \" + userHandle);\n            return false;\n        }\n        Preconditions.checkArgument(who != null);\n\n        final CallerIdentity caller = getCallerIdentity();\n        // Cannot be called while holding the lock:\n        final boolean hasIncompatibleAccountsOrNonAdb =\n                hasIncompatibleAccountsOrNonAdbNoLock(caller, userHandle, who);\n        synchronized (getLockObject()) {\n            enforceCanSetProfileOwnerLocked(\n                    caller, who, userHandle, hasIncompatibleAccountsOrNonAdb);\n            final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n            Preconditions.checkArgument(\n                    isPackageInstalledForUser(who.getPackageName(), userHandle)\n                            && admin != null\n                            && !getUserData(userHandle).mRemovingAdmins.contains(who),\n                    \"Not active admin: \" + who);\n\n            final int parentUserId = getProfileParentId(userHandle);\n            // When trying to set a profile owner on a new user, it may be that this user is\n            // a profile - but it may not be a managed profile if there's a restriction on the\n            // parent to add managed profiles (e.g. if the device has a device owner).\n            if (parentUserId != userHandle && mUserManager.hasUserRestriction(\n                    UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                    UserHandle.of(parentUserId))) {\n                Slogf.i(LOG_TAG, \"Cannot set profile owner because of restriction.\");\n                return false;\n            }\n\n            boolean isAdb = isAdb(caller);\n            if (isAdb) {\n                // Log profile owner provisioning was started using adb.\n                MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_PROFILE_OWNER);\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.PROVISIONING_ENTRY_POINT_ADB)\n                        .setAdmin(who)\n                        .setStrings(LOG_TAG_PROFILE_OWNER)\n                        .write();\n            }\n\n            // Shutting down backup manager service permanently.\n            toggleBackupServiceActive(userHandle, /* makeActive= */ false);\n\n            mOwners.setProfileOwner(who, userHandle);\n            mOwners.writeProfileOwner(userHandle);\n            Slogf.i(LOG_TAG, \"Profile owner set: \" + who + \" on user \" + userHandle);\n\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                if (mUserManager.isManagedProfile(userHandle)) {\n                    maybeSetDefaultRestrictionsForAdminLocked(userHandle, admin);\n                    ensureUnknownSourcesRestrictionForProfileOwnerLocked(userHandle, admin,\n                            true /* newOwner */);\n                }\n                if(isAdb) {\n                    // DISALLOW_DEBUGGING_FEATURES is being added to newly-created\n                    // work profile by default due to b/382064697 . This would have\n                    //  impacted certain CTS test flows when they interact with the\n                    // work profile via ADB (for example installing an app into the\n                    // work profile). Remove DISALLOW_DEBUGGING_FEATURES here to\n                    // reduce the potential impact.\n                    setLocalUserRestrictionInternal(\n                        EnforcingAdmin.createEnterpriseEnforcingAdmin(who, userHandle),\n                        UserManager.DISALLOW_DEBUGGING_FEATURES, false, userHandle);\n                }\n\n                sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                        userHandle);\n            });\n            mDeviceAdminServiceController.startServiceForAdmin(\n                    who.getPackageName(), userHandle, \"set-profile-owner\");\n            return true;\n        }\n    }\n\n    private void toggleBackupServiceActive(int userId, boolean makeActive) {\n        long ident = mInjector.binderClearCallingIdentity();\n        try {\n            if (mInjector.getIBackupManager() != null) {\n                mInjector.getIBackupManager()\n                        .setBackupServiceActive(userId, makeActive);\n            }\n        } catch (RemoteException e) {\n            throw new IllegalStateException(String.format(\"Failed %s backup service.\",\n                    makeActive ? \"activating\" : \"deactivating\"), e);\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n\n    }\n\n    @Override\n    public void clearProfileOwner(ComponentName who) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        final int userId = caller.getUserId();\n        Preconditions.checkCallingUser(!isManagedProfile(userId));\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        enforceUserUnlocked(userId);\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                clearProfileOwnerLocked(admin, userId);\n                removeActiveAdminLocked(who, userId);\n                sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                        userId);\n            });\n            Slogf.i(LOG_TAG, \"Profile owner \" + who + \" removed from user \" + userId);\n        }\n    }\n\n    public void clearProfileOwnerLocked(ActiveAdmin admin, int userId) {\n        String ownersPackage = mOwners.getProfileOwnerPackage(userId);\n        if (ownersPackage != null) {\n            mDeviceAdminServiceController.stopServiceForAdmin(\n                    ownersPackage, userId, \"clear-profile-owner\");\n        }\n\n        if (admin != null) {\n            admin.disableCamera = false;\n            admin.userRestrictions = null;\n            admin.defaultEnabledRestrictionsAlreadySet.clear();\n        }\n        final DevicePolicyData policyData = getUserData(userId);\n        policyData.mCurrentInputMethodSet = false;\n        policyData.mOwnerInstalledCaCerts.clear();\n        saveSettingsLocked(userId);\n        clearUserPoliciesLocked(userId);\n        clearApplicationRestrictions(userId);\n        mOwners.removeProfileOwner(userId);\n        mOwners.writeProfileOwner(userId);\n        deleteTransferOwnershipBundleLocked(userId);\n        toggleBackupServiceActive(userId, true);\n        applyProfileRestrictionsIfDeviceOwnerLocked();\n        setNetworkLoggingActiveInternal(false);\n\n        if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n            mDevicePolicyEngine.removePoliciesForAdmin(\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(), userId, admin));\n        }\n    }\n\n    @Override\n    public void setDeviceOwnerLockScreenInfo(ComponentName who, CharSequence info) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mLockPatternUtils.setDeviceOwnerInfo(info != null ? info.toString() : null));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_DEVICE_OWNER_LOCK_SCREEN_INFO)\n                .setAdmin(caller.getComponentName())\n                .write();\n    }\n\n    @Override\n    public CharSequence getDeviceOwnerLockScreenInfo() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        return mInjector.binderWithCleanCallingIdentity(() ->\n            mLockPatternUtils.getDeviceOwnerInfo());\n    }\n\n    private void clearUserPoliciesLocked(int userId) {\n        // Reset some of the user-specific policies.\n        final DevicePolicyData policy = getUserData(userId);\n        policy.mPermissionPolicy = DevicePolicyManager.PERMISSION_POLICY_PROMPT;\n        // Clear delegations.\n        policy.mDelegationMap.clear();\n        policy.mStatusBarDisabled = false;\n        policy.mSecondaryLockscreenEnabled = false;\n        policy.mUserProvisioningState = DevicePolicyManager.STATE_USER_UNMANAGED;\n        policy.mAffiliationIds.clear();\n        resetAffiliationCacheLocked();\n        policy.mLockTaskPackages.clear();\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            updateLockTaskPackagesLocked(mContext, policy.mLockTaskPackages, userId);\n        }\n        policy.mLockTaskFeatures = DevicePolicyManager.LOCK_TASK_FEATURE_NONE;\n        saveSettingsLocked(userId);\n\n        try {\n            mIPermissionManager.updatePermissionFlagsForAllApps(\n                    PackageManager.FLAG_PERMISSION_POLICY_FIXED,\n                    0  /* flagValues */, userId);\n            pushUserRestrictions(userId);\n        } catch (RemoteException re) {\n            // Shouldn't happen.\n            Slogf.wtf(LOG_TAG, \"Failing in updatePermissionFlagsForAllApps\", re);\n        }\n    }\n\n    @Override\n    public boolean hasUserSetupCompleted() {\n        return hasUserSetupCompleted(mInjector.userHandleGetCallingUserId());\n    }\n\n    // This checks only if the Setup Wizard has run.  Since Wear devices pair before\n    // completing Setup Wizard, and pairing involves transferring user data, calling\n    // logic may want to check mIsWatch or mPaired in addition to hasUserSetupCompleted().\n    private boolean hasUserSetupCompleted(int userHandle) {\n        if (!mHasFeature) {\n            return true;\n        }\n        return mInjector.hasUserSetupCompleted(getUserData(userHandle));\n    }\n\n    private boolean hasPaired(int userHandle) {\n        if (!mHasFeature) {\n            return true;\n        }\n        return getUserData(userHandle).mPaired;\n    }\n\n    @Override\n    public int getUserProvisioningState(int userHandle) {\n        if (!mHasFeature) {\n            return DevicePolicyManager.STATE_USER_UNMANAGED;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(caller)\n                || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        if (userHandle != caller.getUserId()) {\n            Preconditions.checkCallAuthorization(canManageUsers(caller)\n                    || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n        }\n\n        return getUserData(userHandle).mUserProvisioningState;\n    }\n\n    @Override\n    public void setUserProvisioningState(int newState, int userId) {\n        if (!mHasFeature) {\n            logMissingFeatureAction(\"Cannot set provisioning state \" + newState + \" for user \"\n                    + userId);\n            return;\n        }\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        final CallerIdentity caller = getCallerIdentity();\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            int deviceOwnerUserId = mOwners.getDeviceOwnerUserId();\n            // NOTE: multiple if statements are nested below so it can log more info on error\n            if (userId != deviceOwnerUserId) {\n                boolean hasProfileOwner = mOwners.hasProfileOwner(userId);\n                if (!hasProfileOwner) {\n                    int managedUserId = getManagedUserId(userId);\n                    if (managedUserId < 0 && newState != STATE_USER_UNMANAGED) {\n                        // No managed device, user or profile, so setting provisioning state makes\n                        // no sense.\n                        String error = \"Not allowed to change provisioning state unless a \"\n                                + \"device or profile owner is set.\";\n                        Slogf.w(LOG_TAG, \"setUserProvisioningState(newState=%d, userId=%d) failed: \"\n                                + \"deviceOwnerId=%d, hasProfileOwner=%b, managedUserId=%d, err=%s\",\n                                newState, userId, deviceOwnerUserId, hasProfileOwner,\n                                managedUserId, error);\n                        throw new IllegalStateException(error);\n                    }\n                }\n            }\n\n            synchronized (getLockObject()) {\n                boolean transitionCheckNeeded = true;\n\n                // Calling identity/permission checks.\n                if (isAdb(caller)) {\n                    // ADB shell can only move directly from un-managed to finalized as part of\n                    // directly setting profile-owner or device-owner.\n                    if (getUserProvisioningState(userId)\n                            != DevicePolicyManager.STATE_USER_UNMANAGED\n                            || newState != STATE_USER_SETUP_FINALIZED) {\n                        throw new IllegalStateException(\"Not allowed to change provisioning state \"\n                                + \"unless current provisioning state is unmanaged, and new state\"\n                                + \"is finalized.\");\n                    }\n                    transitionCheckNeeded = false;\n                }\n\n                final DevicePolicyData policyData = getUserData(userId);\n                if (transitionCheckNeeded) {\n                    // Optional state transition check for non-ADB case.\n                    checkUserProvisioningStateTransition(policyData.mUserProvisioningState,\n                            newState);\n                }\n                policyData.mUserProvisioningState = newState;\n                saveSettingsLocked(userId);\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    private void checkUserProvisioningStateTransition(int currentState, int newState) {\n        // Valid transitions for normal use-cases.\n        switch (currentState) {\n            case DevicePolicyManager.STATE_USER_UNMANAGED:\n                // Can move to any state from unmanaged (except itself as an edge case)..\n                if (newState != DevicePolicyManager.STATE_USER_UNMANAGED) {\n                    return;\n                }\n                break;\n            case DevicePolicyManager.STATE_USER_SETUP_INCOMPLETE:\n            case DevicePolicyManager.STATE_USER_SETUP_COMPLETE:\n                // Can only move to finalized from these states.\n                if (newState == STATE_USER_SETUP_FINALIZED) {\n                    return;\n                }\n                break;\n            case DevicePolicyManager.STATE_USER_PROFILE_COMPLETE:\n                // Current user has a managed-profile, but current user is not managed, so\n                // rather than moving to finalized state, go back to unmanaged once\n                // profile provisioning is complete.\n                if (newState == DevicePolicyManager.STATE_USER_PROFILE_FINALIZED) {\n                    return;\n                }\n                break;\n            case STATE_USER_SETUP_FINALIZED:\n                // Cannot transition out of finalized.\n                break;\n            case DevicePolicyManager.STATE_USER_PROFILE_FINALIZED:\n                // Should only move to an unmanaged state after removing the work profile.\n                if (newState == DevicePolicyManager.STATE_USER_UNMANAGED) {\n                    return;\n                }\n                break;\n        }\n\n        // Didn't meet any of the accepted state transition checks above, throw appropriate error.\n        throw new IllegalStateException(\"Cannot move to user provisioning state [\" + newState + \"] \"\n                + \"from state [\" + currentState + \"]\");\n    }\n\n    @Override\n    public void setProfileEnabled(ComponentName who) {\n        if (!mHasFeature) {\n            logMissingFeatureAction(\"Cannot enable profile for \"\n                    + ComponentName.flattenToShortString(who));\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        final int userId = caller.getUserId();\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        Preconditions.checkCallingUser(isManagedProfile(userId));\n\n        synchronized (getLockObject()) {\n            // Check if the profile is already enabled.\n            UserInfo managedProfile = getUserInfo(userId);\n            if (managedProfile.isEnabled()) {\n                Slogf.e(LOG_TAG,\n                        \"setProfileEnabled is called when the profile is already enabled\");\n                return;\n            }\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                mUserManager.setUserEnabled(userId);\n                UserInfo parent = mUserManager.getProfileParent(userId);\n                Intent intent = new Intent(Intent.ACTION_MANAGED_PROFILE_ADDED);\n                intent.putExtra(Intent.EXTRA_USER, new UserHandle(userId));\n                UserHandle parentHandle = new UserHandle(parent.id);\n                mLocalService.broadcastIntentToManifestReceivers(intent,\n                        parentHandle, /* requiresPermission= */ true);\n                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY |\n                        Intent.FLAG_RECEIVER_FOREGROUND);\n                mContext.sendBroadcastAsUser(intent, parentHandle);\n            });\n        }\n    }\n\n    @Override\n    public void setProfileName(ComponentName who, String profileName) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        final String truncatedProfileName =\n                profileName.substring(0, Math.min(profileName.length(), MAX_PROFILE_NAME_LENGTH));\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            mUserManager.setUserName(caller.getUserId(), truncatedProfileName);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_PROFILE_NAME)\n                    .setAdmin(caller.getComponentName())\n                    .write();\n        });\n    }\n\n    @Override\n    public ComponentName getProfileOwnerAsUser(int userId) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId)\n                || hasFullCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            return mOwners.getProfileOwnerComponent(userId);\n        }\n    }\n\n    // Returns the active profile owner for this user or null if the current user has no\n    // profile owner.\n    @VisibleForTesting\n    ActiveAdmin getProfileOwnerAdminLocked(int userHandle) {\n        ComponentName profileOwner = mOwners.getProfileOwnerComponent(userHandle);\n        if (profileOwner == null) {\n            return null;\n        }\n        DevicePolicyData policy = getUserData(userHandle);\n        final int n = policy.mAdminList.size();\n        for (int i = 0; i < n; i++) {\n            ActiveAdmin admin = policy.mAdminList.get(i);\n            if (profileOwner.equals(admin.info.getComponent())) {\n                return admin;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the ActiveAdmin associated with the PO or DO on the given user.\n     */\n    private @Nullable ActiveAdmin getDeviceOrProfileOwnerAdminLocked(int userHandle) {\n        ActiveAdmin admin = getProfileOwnerAdminLocked(userHandle);\n        if (admin == null && getDeviceOwnerUserIdUncheckedLocked() == userHandle) {\n            admin = getDeviceOwnerAdminLocked();\n        }\n        return admin;\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    ActiveAdmin getProfileOwnerOfOrganizationOwnedDeviceLocked(int userHandle) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo userInfo : mUserManager.getProfiles(userHandle)) {\n                if (userInfo.isManagedProfile()) {\n                    if (getProfileOwnerAsUser(userInfo.id) != null\n                            && isProfileOwnerOfOrganizationOwnedDevice(userInfo.id)) {\n                        ComponentName who = getProfileOwnerAsUser(userInfo.id);\n                        return getActiveAdminUncheckedLocked(who, userInfo.id);\n                    }\n                }\n            }\n            return null;\n        });\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    ActiveAdmin getProfileOwnerOfOrganizationOwnedDeviceLocked() {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo userInfo : mUserManager.getUsers()) {\n                if (userInfo.isManagedProfile()) {\n                    if (getProfileOwnerAsUser(userInfo.id) != null\n                            && isProfileOwnerOfOrganizationOwnedDevice(userInfo.id)) {\n                        ComponentName who = getProfileOwnerAsUser(userInfo.id);\n                        return getActiveAdminUncheckedLocked(who, userInfo.id);\n                    }\n                }\n            }\n            return null;\n        });\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public @Nullable ComponentName getProfileOwnerOrDeviceOwnerSupervisionComponent(\n            @NonNull UserHandle userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        synchronized (getLockObject()) {\n            final ComponentName doComponent = mOwners.getDeviceOwnerComponent();\n            final ComponentName poComponent =\n                    mOwners.getProfileOwnerComponent(userHandle.getIdentifier());\n            // Return test only admin if configured to do so.\n            // TODO(b/182994391): Replace with more generic solution to override the supervision\n            // component.\n            if (mConstants.USE_TEST_ADMIN_AS_SUPERVISION_COMPONENT) {\n                if (isAdminTestOnlyLocked(doComponent, userHandle.getIdentifier())) {\n                    return doComponent;\n                } else if (isAdminTestOnlyLocked(poComponent, userHandle.getIdentifier())) {\n                    return poComponent;\n                }\n            }\n\n            // Check profile owner first as that is what most likely is set.\n            if (isSupervisionComponentLocked(poComponent)) {\n                return poComponent;\n            }\n\n            if (isSupervisionComponentLocked(doComponent)) {\n                return doComponent;\n            }\n\n            return null;\n        }\n    }\n\n    /**\n     * Returns if the specified component is the supervision component.\n     */\n    @Override\n    public boolean isSupervisionComponent(@NonNull ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        synchronized (getLockObject()) {\n            if (mConstants.USE_TEST_ADMIN_AS_SUPERVISION_COMPONENT) {\n                final CallerIdentity caller = getCallerIdentity();\n                if (isAdminTestOnlyLocked(who, caller.getUserId())) {\n                    return true;\n                }\n            }\n            return isSupervisionComponentLocked(who);\n        }\n    }\n\n    private boolean isSupervisionComponentLocked(@Nullable ComponentName who) {\n        if (who == null) {\n            return false;\n        }\n\n        final String configComponent = mContext.getResources().getString(\n                com.android.internal.R.string.config_defaultSupervisionProfileOwnerComponent);\n        if (configComponent != null) {\n            final ComponentName componentName = ComponentName.unflattenFromString(configComponent);\n            if (who.equals(componentName)) {\n                return true;\n            }\n        }\n\n        // Check the system supervision role.\n        final String configPackage = mContext.getResources().getString(\n                com.android.internal.R.string.config_systemSupervision);\n\n        return who.getPackageName().equals(configPackage);\n    }\n\n    // TODO(b/240562946): Remove api as owner name is not used.\n    @Override\n    public String getProfileOwnerName(int userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        return getProfileOwnerNameUnchecked(userHandle);\n    }\n\n    private String getProfileOwnerNameUnchecked(int userHandle) {\n        ComponentName profileOwner = getProfileOwnerAsUser(userHandle);\n        if (profileOwner == null) {\n            return null;\n        }\n        return getApplicationLabel(profileOwner.getPackageName(), userHandle);\n    }\n\n    private @UserIdInt int getOrganizationOwnedProfileUserId() {\n        for (UserInfo ui : mUserManagerInternal.getUserInfos()) {\n            if (ui.isManagedProfile() && isProfileOwnerOfOrganizationOwnedDevice(ui.id)) {\n                return ui.id;\n            }\n        }\n        return UserHandle.USER_NULL;\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public boolean isOrganizationOwnedDeviceWithManagedProfile() {\n        if (!mHasFeature) {\n            return false;\n        }\n        return getOrganizationOwnedProfileUserId() != UserHandle.USER_NULL;\n    }\n\n    @Override\n    public boolean checkDeviceIdentifierAccess(String packageName, int pid, int uid) {\n        final CallerIdentity caller = getCallerIdentity();\n        ensureCallerIdentityMatchesIfNotSystem(packageName, pid, uid, caller);\n\n        // Verify that the specified packages matches the provided uid.\n        if (!doesPackageMatchUid(packageName, uid)) {\n            return false;\n        }\n        // A device or profile owner must also have the READ_PHONE_STATE permission to access device\n        // identifiers. If the package being checked does not have this permission then deny access.\n        if (!hasPermission(permission.READ_PHONE_STATE, pid, uid)) {\n            return false;\n        }\n        return hasDeviceIdAccessUnchecked(packageName, uid);\n    }\n\n    /**\n     * Check if one the following conditions hold:\n     * (1) The device has a Device Owner, and one of the following holds:\n     *   (1.1) The caller is the Device Owner\n     *   (1.2) The caller is another app in the same user as the device owner, AND\n     *         The caller is the delegated certificate installer.\n     *   (1.3) The caller is a Profile Owner and the calling user is affiliated.\n     * (2) The user has a profile owner, AND:\n     *   (2.1) The profile owner has been granted access to Device IDs and one of the following\n     *         holds:\n     *     (2.1.1) The caller is the profile owner.\n     *     (2.1.2) The caller is from another app in the same user as the profile owner, AND\n     *             the caller is the delegated cert installer.\n     * (3) The caller holds the\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES} permission.\n     *\n     *  For the device owner case, simply check that the caller is the device owner or the\n     *  delegated certificate installer.\n     *\n     *  For the profile owner case, first check that the caller is the profile owner or can\n     *  manage the DELEGATION_CERT_INSTALL scope.\n     *  If that check succeeds, ensure the profile owner was granted access to device\n     *  identifiers. The grant is transitive: The delegated cert installer is implicitly allowed\n     *  access to device identifiers in this case as part of the delegation.\n     */\n    @VisibleForTesting\n    boolean hasDeviceIdAccessUnchecked(String packageName, int uid) {\n        final int userId = UserHandle.getUserId(uid);\n        // TODO(b/280048070): Introduce a permission to handle device ID access\n        if (isPermissionCheckFlagEnabled()\n                && !(isUidProfileOwnerLocked(uid) || isUidDeviceOwnerLocked(uid))) {\n            return hasPermission(MANAGE_DEVICE_POLICY_CERTIFICATES, packageName, userId);\n        } else {\n            ComponentName deviceOwner = getDeviceOwnerComponent(true);\n            if (deviceOwner != null && (deviceOwner.getPackageName().equals(packageName)\n                    || isCallerDelegate(packageName, uid, DELEGATION_CERT_INSTALL))) {\n                return true;\n            }\n            ComponentName profileOwner = getProfileOwnerAsUser(userId);\n            final boolean isCallerProfileOwnerOrDelegate = profileOwner != null\n                    && (profileOwner.getPackageName().equals(packageName)\n                    || isCallerDelegate(packageName, uid, DELEGATION_CERT_INSTALL));\n            if (isCallerProfileOwnerOrDelegate && (isProfileOwnerOfOrganizationOwnedDevice(userId)\n                    || isUserAffiliatedWithDevice(userId))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean doesPackageMatchUid(String packageName, int uid) {\n        final int userId = UserHandle.getUserId(uid);\n        try {\n            ApplicationInfo appInfo = mIPackageManager.getApplicationInfo(packageName, 0, userId);\n            // Since this call goes directly to PackageManagerService a NameNotFoundException is not\n            // thrown but null data can be returned; if the appInfo for the specified package cannot\n            // be found then return false to prevent crashing the app.\n            if (appInfo == null) {\n                Slogf.w(LOG_TAG, \"appInfo could not be found for package %s\", packageName);\n                return false;\n            } else if (uid != appInfo.uid) {\n                String message = String.format(\"Package %s (uid=%d) does not match provided uid %d\",\n                        packageName, appInfo.uid, uid);\n                Slogf.w(LOG_TAG, message);\n                throw new SecurityException(message);\n            }\n        } catch (RemoteException e) {\n            // If an exception is caught obtaining the appInfo just return false to prevent crashing\n            // apps due to an internal error.\n            Slogf.e(LOG_TAG, e, \"Exception caught obtaining appInfo for package %s\", packageName);\n            return false;\n        }\n        return true;\n    }\n\n    private void ensureCallerIdentityMatchesIfNotSystem(String packageName, int pid, int uid,\n            CallerIdentity caller) {\n        // If the caller is not a system app then it should only be able to check its own device\n        // identifier access.\n        int callingUid = caller.getUid();\n        int callingPid = mInjector.binderGetCallingPid();\n        if (UserHandle.getAppId(callingUid) >= Process.FIRST_APPLICATION_UID\n                && (callingUid != uid || callingPid != pid)) {\n            String message = String.format(\n                    \"Calling uid %d, pid %d cannot check device identifier access for package %s \"\n                            + \"(uid=%d, pid=%d)\", callingUid, callingPid, packageName, uid, pid);\n            Slogf.w(LOG_TAG, message);\n            throw new SecurityException(message);\n        }\n    }\n\n    /**\n     * Canonical name for a given package.\n     */\n    private String getApplicationLabel(String packageName, @UserIdInt int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            final Context userContext;\n            try {\n                UserHandle userHandle = UserHandle.of(userId);\n                userContext = mContext.createPackageContextAsUser(packageName, /* flags= */ 0,\n                        userHandle);\n            } catch (PackageManager.NameNotFoundException nnfe) {\n                Slogf.w(LOG_TAG, nnfe, \"%s is not installed for user %d\", packageName, userId);\n                return null;\n            }\n            ApplicationInfo appInfo = userContext.getApplicationInfo();\n            CharSequence result = null;\n            if (appInfo != null) {\n                result = appInfo.loadUnsafeLabel(userContext.getPackageManager());\n            }\n            return result != null ? result.toString() : null;\n        });\n    }\n\n    /**\n     * The profile owner can only be set by adb or an app with the MANAGE_PROFILE_AND_DEVICE_OWNERS\n     * permission.\n     * The profile owner can only be set before the user setup phase has completed,\n     * except for:\n     * - SYSTEM_UID\n     * - adb unless hasIncompatibleAccountsOrNonAdb is true.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void enforceCanSetProfileOwnerLocked(\n            CallerIdentity caller, @Nullable ComponentName owner, @UserIdInt int userId,\n            boolean hasIncompatibleAccountsOrNonAdb) {\n        UserInfo info = getUserInfo(userId);\n        if (info == null) {\n            // User doesn't exist.\n            throw new IllegalArgumentException(\n                    \"Attempted to set profile owner for invalid userId: \" + userId);\n        }\n        if (info.isGuest()) {\n            throw new IllegalStateException(\"Cannot set a profile owner on a guest\");\n        }\n        if (mOwners.hasProfileOwner(userId)) {\n            StringBuilder errorMessage = new StringBuilder(\"Trying to set the profile owner\");\n            if (!hasIncompatibleAccountsOrNonAdb) {\n                append(errorMessage, owner).append(\" on user \").append(userId);\n            }\n            errorMessage.append(\", but profile owner\");\n            if (!hasIncompatibleAccountsOrNonAdb) {\n                appendProfileOwnerLocked(errorMessage, userId);\n            }\n\n            throw new IllegalStateException(errorMessage.append(\" is already set.\").toString());\n        }\n        if (mOwners.hasDeviceOwner() && mOwners.getDeviceOwnerUserId() == userId) {\n            StringBuilder errorMessage = new StringBuilder(\"Trying to set the profile owner\");\n            if (!hasIncompatibleAccountsOrNonAdb) {\n                append(errorMessage, owner).append(\" on user \").append(userId);\n            }\n            errorMessage.append(\", but the user already has a device owner\");\n            if (!hasIncompatibleAccountsOrNonAdb) {\n                appendDeviceOwnerLocked(errorMessage);\n            }\n            throw new IllegalStateException(errorMessage.append('.').toString());\n        }\n        if (isAdb(caller)) {\n            if ((mIsWatch || hasUserSetupCompleted(userId))\n                    && hasIncompatibleAccountsOrNonAdb) {\n                StringBuilder errorMessage = new StringBuilder(\"Not allowed to set the profile \"\n                        + \"owner\");\n                if (!hasIncompatibleAccountsOrNonAdb) {\n                    append(errorMessage, owner).append(\" on user \").append(userId).append(' ');\n                }\n                throw new IllegalStateException(errorMessage.append(\" because there are already \"\n                        + \"some accounts on the profile.\").toString());\n            }\n            return;\n        }\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        if ((mIsWatch || hasUserSetupCompleted(userId))) {\n            Preconditions.checkState(isSystemUid(caller),\n                    \"Cannot set the profile owner on a user which is already set-up\");\n\n            if (!mIsWatch) {\n                if (!isSupervisionComponentLocked(owner)) {\n                    throw new IllegalStateException(\"Unable to set non-default profile owner\"\n                            + \" post-setup \" + owner);\n                }\n            }\n        }\n    }\n\n    /**\n     * The Device owner can only be set by adb or an app with the MANAGE_PROFILE_AND_DEVICE_OWNERS\n     * permission.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void enforceCanSetDeviceOwnerLocked(\n            CallerIdentity caller, @Nullable ComponentName owner, @UserIdInt int deviceOwnerUserId,\n            boolean hasIncompatibleAccountsOrNonAdb) {\n        boolean showComponentOnError = false;\n        if (!isAdb(caller)) {\n            Preconditions.checkCallAuthorization(\n                    hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        } else {\n            showComponentOnError = true;\n        }\n\n        final int code = checkDeviceOwnerProvisioningPreConditionLocked(owner,\n                /* deviceOwnerUserId= */ deviceOwnerUserId, /* callingUserId*/ caller.getUserId(),\n                isAdb(caller), hasIncompatibleAccountsOrNonAdb);\n        if (code != STATUS_OK) {\n            final String provisioningErrorStringLocked = computeProvisioningErrorStringLocked(code,\n                    deviceOwnerUserId, owner, showComponentOnError);\n            if (code == STATUS_HEADLESS_SYSTEM_USER_MODE_NOT_SUPPORTED) {\n                throw new ServiceSpecificException(code, provisioningErrorStringLocked);\n            } else {\n                throw new IllegalStateException(provisioningErrorStringLocked);\n            }\n        }\n    }\n\n    private String computeProvisioningErrorString(int code, @UserIdInt int userId) {\n        synchronized (getLockObject()) {\n            return computeProvisioningErrorStringLocked(code, userId, /* newOwner= */ null,\n                    /* showComponentOnError= */ false);\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private String computeProvisioningErrorStringLocked(int code, @UserIdInt int userId,\n            @Nullable ComponentName newOwner, boolean showComponentOnError) {\n        switch (code) {\n            case STATUS_OK:\n                return \"OK\";\n            case STATUS_HAS_DEVICE_OWNER: {\n                StringBuilder error = new StringBuilder(\"Trying to set the device owner\");\n                if (showComponentOnError && newOwner != null) {\n                    append(error, newOwner);\n                }\n                error.append(\", but device owner\");\n                if (showComponentOnError) {\n                    appendDeviceOwnerLocked(error);\n                }\n                return error.append(\" is already set.\").toString();\n            }\n            case STATUS_USER_HAS_PROFILE_OWNER: {\n                StringBuilder error = new StringBuilder(\"Trying to set the device owner\");\n                if (showComponentOnError && newOwner != null) {\n                    append(error, newOwner);\n                }\n                error.append(\", but the user already has a profile owner\");\n                if (showComponentOnError) {\n                    appendProfileOwnerLocked(error, userId);\n                }\n                return error.append(\".\").toString();\n            }\n            case STATUS_USER_NOT_RUNNING:\n                return \"User \" + userId + \" not running.\";\n            case STATUS_NOT_SYSTEM_USER:\n                return \"User \" + userId + \" is not system user.\";\n            case STATUS_USER_SETUP_COMPLETED:\n                return  \"Cannot set the device owner if the device is already set-up.\";\n            case STATUS_NONSYSTEM_USER_EXISTS:\n                return \"Not allowed to set the device owner because there are already several\"\n                        + \" users on the device.\";\n            case STATUS_ACCOUNTS_NOT_EMPTY:\n                return \"Not allowed to set the device owner because there are already some accounts\"\n                        + \" on the device.\";\n            case STATUS_HAS_PAIRED:\n                return \"Not allowed to set the device owner because this device has already \"\n                        + \"paired.\";\n            case STATUS_HEADLESS_SYSTEM_USER_MODE_NOT_SUPPORTED:\n                return \"Cannot provision an unsupported DPC into DO on a\"\n                        + \" headless device\";\n            default:\n                return \"Unexpected @ProvisioningPreCondition: \" + code;\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void appendDeviceOwnerLocked(StringBuilder string) {\n        ComponentName deviceOwner = getDeviceOwnerComponent(/* callingUserOnly= */ false);\n        if (deviceOwner == null) {\n            // Shouldn't happen, but it doesn't hurt to check...\n            Slogf.wtf(LOG_TAG, \"appendDeviceOwnerLocked(): device has no DO set\");\n            return;\n        }\n        append(string, deviceOwner);\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void appendProfileOwnerLocked(StringBuilder string, @UserIdInt int userId) {\n        ComponentName profileOwner = mOwners.getProfileOwnerComponent(userId);\n        if (profileOwner == null) {\n            // Shouldn't happen, but it doesn't hurt to check...\n            Slogf.wtf(LOG_TAG, \"profileOwner(%d): PO not set\", userId);\n            return;\n        }\n        append(string, profileOwner);\n    }\n\n    private static StringBuilder append(StringBuilder string, ComponentName component) {\n        return string.append(\" (\").append(component.flattenToShortString()).append(')');\n    }\n\n    private void enforceUserUnlocked(int userId) {\n        // Since we're doing this operation on behalf of an app, we only\n        // want to use the actual \"unlocked\" state.\n        Preconditions.checkState(mUserManager.isUserUnlocked(userId),\n                \"User must be running and unlocked\");\n    }\n\n    private void enforceUserUnlocked(@UserIdInt int userId, boolean parent) {\n        if (parent) {\n            enforceUserUnlocked(getProfileParentId(userId));\n        } else {\n            enforceUserUnlocked(userId);\n        }\n    }\n\n    private boolean canManageUsers(CallerIdentity caller) {\n        return hasCallingOrSelfPermission(permission.MANAGE_USERS);\n    }\n\n    private boolean canQueryAdminPolicy(CallerIdentity caller) {\n        return hasCallingOrSelfPermission(permission.QUERY_ADMIN_POLICY);\n    }\n\n    private boolean hasPermission(String permission, int pid, int uid) {\n        return mContext.checkPermission(permission, pid, uid) == PackageManager.PERMISSION_GRANTED;\n    }\n\n    private boolean hasCallingPermission(String permission) {\n        return mContext.checkCallingPermission(permission) == PackageManager.PERMISSION_GRANTED;\n    }\n\n    private boolean hasCallingOrSelfPermission(String permission) {\n        return mContext.checkCallingOrSelfPermission(permission)\n                == PackageManager.PERMISSION_GRANTED;\n    }\n\n    private boolean hasPermissionForPreflight(CallerIdentity caller, String permission) {\n        final int callingPid = mInjector.binderGetCallingPid();\n        final String packageName = mContext.getPackageName();\n\n        return PermissionChecker.checkPermissionForPreflight(mContext, permission, callingPid,\n                caller.getUid(), packageName) == PermissionChecker.PERMISSION_GRANTED;\n    }\n\n    private boolean hasFullCrossUsersPermission(CallerIdentity caller, int userHandle) {\n        return (userHandle == caller.getUserId()) || isSystemUid(caller) || isRootUid(caller)\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS_FULL);\n    }\n\n    private boolean hasCrossUsersPermission(CallerIdentity caller, int userHandle) {\n        return (userHandle == caller.getUserId()) || isSystemUid(caller) || isRootUid(caller)\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS);\n    }\n\n    private boolean canDPCManagedUserUseLockTaskLocked(int userId) {\n        if (isUserAffiliatedWithDeviceLocked(userId)) {\n            return true;\n        }\n\n        // Unaffiliated profile owners are not allowed to use lock when there is a device owner.\n        if (mOwners.hasDeviceOwner()) {\n            return false;\n        }\n        \n        final ComponentName profileOwner = getProfileOwnerAsUser(userId);\n        if (profileOwner == null) {\n            return false;\n        }\n        // Managed profiles are not allowed to use lock task\n        if (isManagedProfile(userId)) {\n            return false;\n        }\n        \n        return true;\n    }\n    private void enforceCanQueryLockTaskLocked(ComponentName who, String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        final int userId = caller.getUserId();\n\n        enforceCanQuery(MANAGE_DEVICE_POLICY_LOCK_TASK, caller.getPackageName(), userId);\n        if ((isDeviceOwner(caller) || isProfileOwner(caller))\n                && !canDPCManagedUserUseLockTaskLocked(userId)) {\n            throw new SecurityException(\"User \" + userId + \" is not allowed to use lock task\");\n        }\n    }\n\n    private EnforcingAdmin enforceCanCallLockTaskLocked(ComponentName who,\n            String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        final int userId =  caller.getUserId();\n\n        EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                who,\n                MANAGE_DEVICE_POLICY_LOCK_TASK,\n                caller.getPackageName(),\n                userId\n        );\n        if ((isDeviceOwner(caller) || isProfileOwner(caller))\n                && !canDPCManagedUserUseLockTaskLocked(userId)) {\n            throw new SecurityException(\"User \" + userId + \" is not allowed to use lock task\");\n        }\n        return enforcingAdmin;\n    }\n\n    private void enforceCanCallLockTaskLocked(CallerIdentity caller) {\n        Preconditions.checkCallAuthorization(isProfileOwner(caller)\n                || isDefaultDeviceOwner(caller) || isFinancedDeviceOwner(caller));\n\n        final int userId =  caller.getUserId();\n        if (!canDPCManagedUserUseLockTaskLocked(userId)) {\n            throw new SecurityException(\"User \" + userId + \" is not allowed to use lock task\");\n        }\n    }\n\n    private boolean isSystemUid(CallerIdentity caller) {\n        return UserHandle.isSameApp(caller.getUid(), Process.SYSTEM_UID);\n    }\n\n    private boolean isRootUid(CallerIdentity caller) {\n        return UserHandle.isSameApp(caller.getUid(), Process.ROOT_UID);\n    }\n\n    private boolean isShellUid(CallerIdentity caller) {\n        return UserHandle.isSameApp(caller.getUid(), Process.SHELL_UID);\n    }\n\n    private boolean isCameraServerUid(CallerIdentity caller) {\n        return UserHandle.isSameApp(caller.getUid(), Process.CAMERASERVER_UID);\n    }\n\n    private @UserIdInt int getCurrentForegroundUserId() {\n        try {\n            UserInfo currentUser = mInjector.getIActivityManager().getCurrentUser();\n            if (currentUser == null) {\n                // TODO(b/206107460): should not happen on production, but it's happening on unit\n                // tests that are not properly setting the expectation (because they don't need it)\n                Slogf.wtf(LOG_TAG, \"getCurrentForegroundUserId(): mInjector.getIActivityManager()\"\n                        + \".getCurrentUser() returned null, please ignore when running unit tests\");\n                return ActivityManager.getCurrentUser();\n            }\n            return currentUser.id;\n        } catch (RemoteException e) {\n            Slogf.wtf(LOG_TAG, \"cannot get current user\", e);\n        }\n        return UserHandle.USER_NULL;\n    }\n\n    @Override\n    public List<UserHandle> listForegroundAffiliatedUsers() {\n        checkIsDeviceOwner(getCallerIdentity());\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            int userId = getCurrentForegroundUserId();\n            boolean isAffiliated;\n            synchronized (getLockObject()) {\n                isAffiliated = isUserAffiliatedWithDeviceLocked(userId);\n            }\n\n            if (!isAffiliated) return Collections.emptyList();\n\n            List<UserHandle> users = new ArrayList<>(1);\n            users.add(UserHandle.of(userId));\n\n            return users;\n        });\n    }\n\n    protected int getProfileParentId(int userHandle) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            UserInfo parentUser = mUserManager.getProfileParent(userHandle);\n            return parentUser != null ? parentUser.id : userHandle;\n        });\n    }\n\n    private int getProfileParentUserIfRequested(int userHandle, boolean parent) {\n        if (parent) {\n            return getProfileParentId(userHandle);\n        }\n\n        return userHandle;\n    }\n\n    private int getCredentialOwner(final int userHandle, final boolean parent) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            int effectiveUserHandle = userHandle;\n            if (parent) {\n                UserInfo parentProfile = mUserManager.getProfileParent(userHandle);\n                if (parentProfile != null) {\n                    effectiveUserHandle = parentProfile.id;\n                }\n            }\n            return mUserManager.getCredentialOwnerProfile(effectiveUserHandle);\n        });\n    }\n\n    private boolean isManagedProfile(int userHandle) {\n        final UserInfo user = getUserInfo(userHandle);\n        return user != null && user.isManagedProfile();\n    }\n\n    private void enableIfNecessary(String packageName, int userId) {\n        try {\n            final ApplicationInfo ai = mIPackageManager.getApplicationInfo(packageName,\n                    PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, userId);\n            if (ai.enabledSetting\n                    == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED) {\n                mIPackageManager.setApplicationEnabledSetting(packageName,\n                        PackageManager.COMPONENT_ENABLED_STATE_DEFAULT,\n                        PackageManager.DONT_KILL_APP, userId, \"DevicePolicyManager\");\n            }\n        } catch (RemoteException e) {\n        }\n    }\n\n    private void dumpPerUserData(IndentingPrintWriter pw) {\n        int userCount = mUserData.size();\n        for (int i = 0; i < userCount; i++) {\n            int userId = mUserData.keyAt(i);\n            DevicePolicyData policy = getUserData(userId);\n            policy.dump(pw);\n            pw.println();\n\n            if (userId == UserHandle.USER_SYSTEM) {\n                pw.increaseIndent();\n                PersonalAppsSuspensionHelper.forUser(mContext, userId).dump(pw);\n                pw.decreaseIndent();\n                pw.println();\n            } else {\n                // pm.getUnsuspendablePackages() will fail if it's called for a different user;\n                // as this dump is mostly useful for system user anyways, we can just ignore the\n                // others (rather than changing the permission check in the PM method)\n                Slogf.d(LOG_TAG, \"skipping PersonalAppsSuspensionHelper.dump() for user \" + userId);\n            }\n        }\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter printWriter, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, LOG_TAG, printWriter)) return;\n\n        try (IndentingPrintWriter pw = new IndentingPrintWriter(printWriter, \"  \")) {\n            pw.println(\"Current Device Policy Manager state:\");\n            pw.increaseIndent();\n\n            dumpImmutableState(pw);\n            synchronized (getLockObject()) {\n                mOwners.dump(pw);\n                pw.println();\n                mDeviceAdminServiceController.dump(pw);\n                pw.println();\n                dumpPerUserData(pw);\n                pw.println();\n                mConstants.dump(pw);\n                pw.println();\n                mStatLogger.dump(pw);\n                pw.println();\n                pw.println(\"Encryption Status: \" + getEncryptionStatusName(getEncryptionStatus()));\n                pw.println(\"Logout user: \" + getLogoutUserIdUnchecked());\n                pw.println();\n\n                if (mPendingUserCreatedCallbackTokens.isEmpty()) {\n                    pw.println(\"no pending user created callback tokens\");\n                } else {\n                    int size = mPendingUserCreatedCallbackTokens.size();\n                    pw.printf(\"%d pending user created callback token%s\\n\", size,\n                            (size == 1 ? \"\" : \"s\"));\n                }\n                pw.println();\n                pw.println(\"Keep profiles running: \"\n                        + getUserData(UserHandle.USER_SYSTEM).mEffectiveKeepProfilesRunning);\n                pw.println();\n\n                mPolicyCache.dump(pw);\n                pw.println();\n                mStateCache.dump(pw);\n                pw.println();\n            }\n\n            synchronized (mSubscriptionsChangedListenerLock) {\n                pw.println(\"Subscription changed listener : \" + mSubscriptionsChangedListener);\n            }\n\n            pw.println(\"DPM global setting ALLOW_WORK_PROFILE_TELEPHONY_FOR_NON_DPM_ROLE_HOLDERS : \"\n                    + mInjector.settingsGlobalGetString(\n                    Global.ALLOW_WORK_PROFILE_TELEPHONY_FOR_NON_DPM_ROLE_HOLDERS));\n            mHandler.post(() -> handleDump(pw));\n            dumpResources(pw);\n        }\n    }\n\n    // Dump state that is guarded by the handler\n    private void handleDump(IndentingPrintWriter pw) {\n        if (mNetworkLoggingNotificationUserId != UserHandle.USER_NULL) {\n            pw.println(\"mNetworkLoggingNotificationUserId:  \" + mNetworkLoggingNotificationUserId);\n        }\n    }\n\n    private void dumpImmutableState(IndentingPrintWriter pw) {\n        pw.println(\"Immutable state:\");\n        pw.increaseIndent();\n        pw.printf(\"mHasFeature=%b\\n\", mHasFeature);\n        pw.printf(\"mIsWatch=%b\\n\", mIsWatch);\n        pw.printf(\"mIsAutomotive=%b\\n\", mIsAutomotive);\n        pw.printf(\"mHasTelephonyFeature=%b\\n\", mHasTelephonyFeature);\n        pw.printf(\"mSafetyChecker=%s\\n\", mSafetyChecker);\n        pw.decreaseIndent();\n    }\n\n    private void dumpResources(IndentingPrintWriter pw) {\n        mOverlayPackagesProvider.dump(pw);\n        pw.println();\n\n        pw.println(\"Other overlayable app resources\");\n        pw.increaseIndent();\n        dumpResources(pw, mContext, \"cross_profile_apps\", R.array.cross_profile_apps);\n        dumpResources(pw, mContext, \"vendor_cross_profile_apps\", R.array.vendor_cross_profile_apps);\n        dumpResources(pw, mContext, \"config_packagesExemptFromSuspension\",\n                R.array.config_packagesExemptFromSuspension);\n        dumpResources(pw, mContext, \"policy_exempt_apps\", R.array.policy_exempt_apps);\n        dumpResources(pw, mContext, \"vendor_policy_exempt_apps\", R.array.vendor_policy_exempt_apps);\n        pw.decreaseIndent();\n        pw.println();\n    }\n\n    static void dumpResources(IndentingPrintWriter pw, Context context, String resName, int resId) {\n        dumpApps(pw, resName, context.getResources().getStringArray(resId));\n    }\n\n    static void dumpApps(IndentingPrintWriter pw, String name, String[] apps) {\n        dumpApps(pw, name, Arrays.asList(apps));\n    }\n\n    static void dumpApps(IndentingPrintWriter pw, String name, List apps) {\n        if (apps == null || apps.isEmpty()) {\n            pw.printf(\"%s: empty\\n\", name);\n            return;\n        }\n        int size = apps.size();\n        pw.printf(\"%s: %d app%s\\n\", name, size, size == 1 ? \"\" : \"s\");\n        pw.increaseIndent();\n        for (int i = 0; i < size; i++) {\n            pw.printf(\"%d: %s\\n\", i, apps.get(i));\n        }\n        pw.decreaseIndent();\n    }\n\n    @Override\n    public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n            String[] args, ShellCallback callback, ResultReceiver resultReceiver) {\n        new DevicePolicyManagerServiceShellCommand(DevicePolicyManagerService.this).exec(\n                this, in, out, err, args, callback, resultReceiver);\n\n    }\n\n    private String getEncryptionStatusName(int encryptionStatus) {\n        switch (encryptionStatus) {\n            case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_PER_USER:\n                return \"per-user\";\n            case DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED:\n                return \"unsupported\";\n            default:\n                return \"unknown\";\n        }\n    }\n\n    @Override\n    public void addPersistentPreferredActivity(ComponentName who, String callerPackageName,\n            IntentFilter filter, ComponentName activity) {\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n\n        final int userId = caller.getUserId();\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin;\n            if (who == null) {\n                enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                        who,\n                        MANAGE_DEVICE_POLICY_LOCK_TASK,\n                        caller.getPackageName(),\n                        userId);\n            } else {\n                Preconditions.checkCallAuthorization(isProfileOwner(caller)\n                        || isDefaultDeviceOwner(caller) || isFinancedDeviceOwner(caller));\n                enforcingAdmin = getEnforcingAdminForCaller(who, callerPackageName);\n            }\n            if (!isPackageInstalledForUser(activity.getPackageName(), userId)) {\n                // Fail early as packageManager doesn't persist the activity if its not installed.\n                return;\n            }\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.PERSISTENT_PREFERRED_ACTIVITY(filter),\n                    enforcingAdmin,\n                    new ComponentNamePolicyValue(activity),\n                    userId);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwner(caller)\n                    || isDefaultDeviceOwner(caller) || isFinancedDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                long id = mInjector.binderClearCallingIdentity();\n                try {\n                    mIPackageManager.addPersistentPreferredActivity(filter, activity, userId);\n                    mIPackageManager.flushPackageRestrictionsAsUser(userId);\n                } catch (RemoteException re) {\n                    // Shouldn't happen\n                    Slog.wtf(LOG_TAG, \"Error adding persistent preferred activity\", re);\n                } finally {\n                    mInjector.binderRestoreCallingIdentity(id);\n                }\n            }\n        }\n        final String activityPackage =\n                (activity != null ? activity.getPackageName() : null);\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_PERSISTENT_PREFERRED_ACTIVITY)\n                .setAdmin(caller.getPackageName())\n                .setStrings(activityPackage, getIntentFilterActions(filter))\n                .write();\n    }\n\n    @Override\n    public void clearPackagePersistentPreferredActivities(ComponentName who,\n            String callerPackageName, String packageName) {\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        final int userId = caller.getUserId();\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin;\n            if (who == null) {\n                enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                        who,\n                        MANAGE_DEVICE_POLICY_LOCK_TASK,\n                        caller.getPackageName(),\n                        userId);\n            } else {\n                Preconditions.checkCallAuthorization(isProfileOwner(caller)\n                        || isDefaultDeviceOwner(caller) || isFinancedDeviceOwner(caller));\n                enforcingAdmin = getEnforcingAdminForCaller(who, callerPackageName);\n            }\n            clearPackagePersistentPreferredActivitiesFromPolicyEngine(\n                    enforcingAdmin,\n                    packageName,\n                    userId);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwner(caller)\n                    || isDefaultDeviceOwner(caller) || isFinancedDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                long id = mInjector.binderClearCallingIdentity();\n                try {\n                    mIPackageManager.clearPackagePersistentPreferredActivities(packageName,\n                            userId);\n                    mIPackageManager.flushPackageRestrictionsAsUser(userId);\n                } catch (RemoteException re) {\n                    // Shouldn't happen\n                    Slogf.wtf(\n                            LOG_TAG, \"Error when clearing package persistent preferred activities\",\n                            re);\n                } finally {\n                    mInjector.binderRestoreCallingIdentity(id);\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove all persistent intent handler preferences associated with the given package that were\n     * set by this admin, note that is doesn't remove preferences set by other admins for the same\n     * package.\n     */\n    private void clearPackagePersistentPreferredActivitiesFromPolicyEngine(\n            EnforcingAdmin admin, String packageName, int userId) {\n        Set<PolicyKey> keys = mDevicePolicyEngine.getLocalPolicyKeysSetByAdmin(\n                PolicyDefinition.GENERIC_PERSISTENT_PREFERRED_ACTIVITY,\n                admin,\n                userId);\n        for (PolicyKey key : keys) {\n            if (!(key instanceof IntentFilterPolicyKey)) {\n                throw new IllegalStateException(\"PolicyKey for PERSISTENT_PREFERRED_ACTIVITY is not\"\n                        + \"of type IntentFilterPolicyKey\");\n            }\n            IntentFilterPolicyKey parsedKey =\n                    (IntentFilterPolicyKey) key;\n            IntentFilter filter = Objects.requireNonNull(parsedKey.getIntentFilter());\n\n            ComponentName preferredActivity = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.PERSISTENT_PREFERRED_ACTIVITY(filter),\n                    admin,\n                    userId);\n            if (preferredActivity != null\n                    && preferredActivity.getPackageName().equals(packageName)) {\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.PERSISTENT_PREFERRED_ACTIVITY(filter),\n                        admin,\n                        userId);\n            }\n        }\n    }\n\n    @Override\n    public void setDefaultSmsApplication(ComponentName admin, String callerPackageName,\n            String packageName, boolean parent) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n\n        final int userId;\n\n        if (isPermissionCheckFlagEnabled()) {\n            enforcePermission(\n                    MANAGE_DEVICE_POLICY_DEFAULT_SMS,\n                    caller.getPackageName(),\n                    getAffectedUser(parent));\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n\n        if (!parent && isManagedProfile(caller.getUserId())\n                && getManagedSubscriptionsPolicy().getPolicyType()\n                != ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {\n            throw new IllegalStateException(\n                    \"Default sms application can only be set on the profile, when \"\n                            + \"ManagedSubscriptions policy is set\");\n        }\n\n        if (parent) {\n            userId = getProfileParentId(mInjector.userHandleGetCallingUserId());\n            mInjector.binderWithCleanCallingIdentity(() -> enforcePackageIsSystemPackage(\n                    packageName, userId));\n        } else {\n            userId = mInjector.userHandleGetCallingUserId();\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() ->\n                SmsApplication.setDefaultApplicationAsUser(packageName, mContext, userId));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin activeAdmin = getParentOfAdminIfRequired(\n                    getProfileOwnerOrDeviceOwnerLocked(caller.getUserId()), parent);\n\n            if (isManagedProfile(userId)) {\n                mInjector.binderWithCleanCallingIdentity(\n                        () -> updateDialerAndSmsManagedShortcutsOverrideCache());\n            }\n\n            if (!Objects.equals(activeAdmin.mSmsPackage, packageName)) {\n                activeAdmin.mSmsPackage = packageName;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public void setDefaultDialerApplication(String packageName) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        final int callerUserId = caller.getUserId();\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            CompletableFuture<Void> future = new CompletableFuture<>();\n            Consumer<Boolean> callback = successful -> {\n                if (successful) {\n                    future.complete(null);\n                } else {\n                    future.completeExceptionally(new IllegalArgumentException(\n                            packageName +  \" cannot be set as the dialer\"));\n                }\n            };\n            mRoleManager.addRoleHolderAsUser(\n                    RoleManager.ROLE_DIALER, packageName, 0, UserHandle.of(callerUserId),\n                    AsyncTask.THREAD_POOL_EXECUTOR, callback);\n            try {\n                future.get(20, TimeUnit.SECONDS);\n            } catch (TimeoutException e) {\n                throw new IllegalArgumentException(\"Timeout when setting the app as the dialer\", e);\n            } catch (ExecutionException e) {\n                Throwable cause = e.getCause();\n                if (cause instanceof IllegalArgumentException) {\n                    throw (IllegalArgumentException) cause;\n                } else {\n                    throw new IllegalStateException(cause);\n                }\n            }\n        });\n        // Only save the package when the setting the role succeeded without exception.\n        synchronized (getLockObject()) {\n            if (isManagedProfile(callerUserId)) {\n                mInjector.binderWithCleanCallingIdentity(\n                        () -> updateDialerAndSmsManagedShortcutsOverrideCache());\n            }\n\n            final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(callerUserId);\n            if (!Objects.equals(admin.mDialerPackage, packageName)) {\n                admin.mDialerPackage = packageName;\n                saveSettingsLocked(callerUserId);\n            }\n        }\n    }\n\n    @Override\n    public boolean setApplicationRestrictionsManagingPackage(ComponentName admin,\n            String packageName) {\n        try {\n            setDelegatedScopePreO(admin, packageName, DELEGATION_APP_RESTRICTIONS);\n        } catch (IllegalArgumentException e) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public String getApplicationRestrictionsManagingPackage(ComponentName admin) {\n        final List<String> delegatePackages = getDelegatePackages(admin,\n                DELEGATION_APP_RESTRICTIONS);\n        return delegatePackages.size() > 0 ? delegatePackages.get(0) : null;\n    }\n\n    @Override\n    public boolean isCallerApplicationRestrictionsManagingPackage(String callerPackage) {\n        return isCallerDelegate(callerPackage, getCallerIdentity().getUid(),\n                DELEGATION_APP_RESTRICTIONS);\n    }\n\n    @Override\n    public void setApplicationRestrictions(ComponentName who, String callerPackage,\n            String packageName, Bundle restrictions) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_APPLICATION_RESTRICTIONS);\n\n        if (isUnicornFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_APP_RESTRICTIONS,\n                    caller.getPackageName(),\n                    caller.getUserId()\n            );\n            // This check is eventually made in UMS, checking here to fail early.\n            String validationResult =\n                    FrameworkParsingPackageUtils.validateName(packageName, false, false);\n            if (validationResult != null) {\n                throw new IllegalArgumentException(\"Invalid package name: \" + validationResult);\n            }\n\n            if (restrictions == null || restrictions.isEmpty()) {\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.APPLICATION_RESTRICTIONS(packageName),\n                        enforcingAdmin,\n                        caller.getUserId());\n            } else {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.APPLICATION_RESTRICTIONS(packageName),\n                        enforcingAdmin,\n                        new BundlePolicyValue(restrictions),\n                        caller.getUserId());\n            }\n            setBackwardsCompatibleAppRestrictions(\n                    caller, packageName, restrictions, caller.getUserHandle());\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(caller,\n                    DELEGATION_APP_RESTRICTIONS)));\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                mUserManager.setApplicationRestrictions(packageName, restrictions,\n                        caller.getUserHandle());\n            });\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_APPLICATION_RESTRICTIONS)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ isCallerDelegate(caller))\n                .setStrings(packageName)\n                .write();\n    }\n\n    /**\n     * Set app restrictions in user manager for DPC callers only to keep backwards compatibility\n     * for the old getApplicationRestrictions API.\n     */\n    private void setBackwardsCompatibleAppRestrictions(\n            CallerIdentity caller, String packageName, Bundle restrictions, UserHandle userHandle) {\n        if ((caller.hasAdminComponent() && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_APP_RESTRICTIONS))) {\n            Bundle restrictionsToApply = restrictions == null || restrictions.isEmpty()\n                    ? getAppRestrictionsSetByAnyAdmin(packageName, userHandle)\n                    : restrictions;\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                mUserManager.setApplicationRestrictions(packageName, restrictionsToApply,\n                        userHandle);\n            });\n        } else {\n            // Notify package of changes via an intent - only sent to explicitly registered\n            // receivers. Sending here because For DPCs, this is being sent in UMS.\n            final Intent changeIntent = new Intent(Intent.ACTION_APPLICATION_RESTRICTIONS_CHANGED);\n            changeIntent.setPackage(packageName);\n            changeIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n            mContext.sendBroadcastAsUser(changeIntent, userHandle);\n        }\n    }\n\n    private Bundle getAppRestrictionsSetByAnyAdmin(String packageName, UserHandle userHandle) {\n        LinkedHashMap<EnforcingAdmin, PolicyValue<Bundle>> policies =\n                mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                        PolicyDefinition.APPLICATION_RESTRICTIONS(packageName),\n                        userHandle.getIdentifier());\n        return policies.isEmpty()\n                ? null : policies.entrySet().stream().findAny().get().getValue().getValue();\n    }\n\n    private int getUidForPackage(String packageName, int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                return mContext.getPackageManager().getApplicationInfoAsUser(\n                        packageName, /* flags= */ 0, userId).uid;\n            } catch (NameNotFoundException exception) {\n                return -1;\n            }\n        });\n    }\n\n    @Override\n    public void setTrustAgentConfiguration(\n            ComponentName admin, String callerPackageName, ComponentName agent,\n            PersistableBundle args, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n\n        if (!isPermissionCheckFlagEnabled()) {\n            Objects.requireNonNull(admin, \"admin is null\");\n        }\n\n        Objects.requireNonNull(agent, \"agent is null\");\n\n        enforceMaxPackageNameLength(agent.getPackageName());\n        final String agentAsString = agent.flattenToString();\n        enforceMaxStringLength(agentAsString, \"agent name\");\n        if (args != null) {\n            enforceMaxStringLength(args, \"args\");\n        }\n\n        int userHandle = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap;\n            if (isPermissionCheckFlagEnabled()) {\n                CallerIdentity caller = getCallerIdentity(admin, callerPackageName);\n                int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n                ap = enforcePermissionAndGetEnforcingAdmin(\n                        admin,\n                        /*permission=*/MANAGE_DEVICE_POLICY_KEYGUARD,\n                        /*adminPolicy=*/DeviceAdminInfo.USES_POLICY_DISABLE_KEYGUARD_FEATURES,\n                        caller.getPackageName(), affectedUserId).getActiveAdmin();\n            } else {\n                ap = getActiveAdminForCallerLocked(admin,\n                        DeviceAdminInfo.USES_POLICY_DISABLE_KEYGUARD_FEATURES, parent);\n            }\n            checkCanExecuteOrThrowUnsafe(\n                    DevicePolicyManager.OPERATION_SET_TRUST_AGENT_CONFIGURATION);\n\n            ap.trustAgentInfos.put(agentAsString, new TrustAgentInfo(args));\n            saveSettingsLocked(userHandle);\n        }\n    }\n\n    @Override\n    public List<PersistableBundle> getTrustAgentConfiguration(ComponentName admin,\n            ComponentName agent, int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return null;\n        }\n        Objects.requireNonNull(agent, \"agent null\");\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            final String componentName = agent.flattenToString();\n            if (admin != null) {\n                final ActiveAdmin ap = getActiveAdminUncheckedLocked(admin, userHandle, parent);\n                if (ap == null) return null;\n                TrustAgentInfo trustAgentInfo = ap.trustAgentInfos.get(componentName);\n                if (trustAgentInfo == null || trustAgentInfo.options == null) return null;\n                List<PersistableBundle> result = new ArrayList<>();\n                result.add(trustAgentInfo.options);\n                return result;\n            }\n\n            // Return strictest policy for this user and profiles that are visible from this user.\n            List<PersistableBundle> result = null;\n            // Search through all admins that use KEYGUARD_DISABLE_TRUST_AGENTS and keep track\n            // of the options. If any admin doesn't have options, discard options for the rest\n            // and return null.\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            boolean allAdminsHaveOptions = true;\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                final ActiveAdmin active = admins.get(i);\n\n                final boolean disablesTrust = (active.disabledKeyguardFeatures\n                        & DevicePolicyManager.KEYGUARD_DISABLE_TRUST_AGENTS) != 0;\n                final TrustAgentInfo info = active.trustAgentInfos.get(componentName);\n                if (info != null && info.options != null && !info.options.isEmpty()) {\n                    if (disablesTrust) {\n                        if (result == null) {\n                            result = new ArrayList<>();\n                        }\n                        result.add(info.options);\n                    } else {\n                        Slogf.w(LOG_TAG, \"Ignoring admin %s because it has trust options but \"\n                                + \"doesn't declare KEYGUARD_DISABLE_TRUST_AGENTS\", active.info);\n                    }\n                } else if (disablesTrust) {\n                    allAdminsHaveOptions = false;\n                    break;\n                }\n            }\n            return allAdminsHaveOptions ? result : null;\n        }\n    }\n\n    @Override\n    public void setRestrictionsProvider(ComponentName who, ComponentName permissionProvider) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_RESTRICTIONS_PROVIDER);\n\n        synchronized (getLockObject()) {\n            int userHandle = caller.getUserId();\n            DevicePolicyData userData = getUserData(userHandle);\n            userData.mRestrictionsProvider = permissionProvider;\n            saveSettingsLocked(userHandle);\n        }\n    }\n\n    @Override\n    public ComponentName getRestrictionsProvider(int userHandle) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"query the permission provider\"));\n        synchronized (getLockObject()) {\n            DevicePolicyData userData = getUserData(userHandle);\n            return userData != null ? userData.mRestrictionsProvider : null;\n        }\n    }\n\n    @Override\n    public void addCrossProfileIntentFilter(ComponentName who, String callerPackageName,\n            IntentFilter filter, int flags) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        int callingUserId = caller.getUserId();\n\n        if (isPermissionCheckFlagEnabled()) {\n            enforcePermission(\n                    MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                    caller.getPackageName(),\n                    callingUserId);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        }\n        synchronized (getLockObject()) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                UserInfo parent = mUserManager.getProfileParent(callingUserId);\n                if (parent == null) {\n                    Slogf.e(LOG_TAG, \"Cannot call addCrossProfileIntentFilter if there is no \"\n                            + \"parent\");\n                    return;\n                }\n                if ((flags & DevicePolicyManager.FLAG_PARENT_CAN_ACCESS_MANAGED) != 0) {\n                    mIPackageManager.addCrossProfileIntentFilter(\n                            filter, who.getPackageName(), callingUserId, parent.id, 0);\n                }\n                if ((flags & DevicePolicyManager.FLAG_MANAGED_CAN_ACCESS_PARENT) != 0) {\n                    mIPackageManager.addCrossProfileIntentFilter(filter, who.getPackageName(),\n                            parent.id, callingUserId, 0);\n                }\n            } catch (RemoteException re) {\n                // Shouldn't happen\n                Slogf.wtf(LOG_TAG, \"Error adding cross profile intent filter\", re);\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_CROSS_PROFILE_INTENT_FILTER)\n                .setAdmin(caller.getPackageName())\n                .setStrings(getIntentFilterActions(filter))\n                .setInt(flags)\n                .write();\n    }\n\n    private static String[] getIntentFilterActions(IntentFilter filter) {\n        if (filter == null) {\n            return null;\n        }\n        final int actionsCount = filter.countActions();\n        final String[] actions = new String[actionsCount];\n        for (int i = 0; i < actionsCount; i++) {\n            actions[i] = filter.getAction(i);\n        }\n        return actions;\n    }\n\n    @Override\n    public void clearCrossProfileIntentFilters(ComponentName who, String callerPackageName) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        int callingUserId = caller.getUserId();\n\n        if (isPermissionCheckFlagEnabled()) {\n            enforcePermission(\n                    MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                    caller.getPackageName(),\n                    callingUserId);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        }\n\n        synchronized (getLockObject()) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                UserInfo parent = mUserManager.getProfileParent(callingUserId);\n                if (parent == null) {\n                    Slogf.e(LOG_TAG, \"Cannot call clearCrossProfileIntentFilter if there is no \"\n                            + \"parent\");\n                    return;\n                }\n                // Removing those that go from the managed profile to the parent.\n                mIPackageManager.clearCrossProfileIntentFilters(\n                        callingUserId, who.getPackageName());\n                // And those that go from the parent to the managed profile.\n                // If we want to support multiple managed profiles, we will have to only remove\n                // those that have callingUserId as their target.\n                mIPackageManager.clearCrossProfileIntentFilters(parent.id, who.getPackageName());\n            } catch (RemoteException re) {\n                // Shouldn't happen\n                Slogf.wtf(LOG_TAG, \"Error clearing cross profile intent filters\", re);\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n    }\n\n    /**\n     * @return true if all packages in enabledPackages are either in the list\n     * permittedList or are a system app.\n     */\n    private boolean checkPackagesInPermittedListOrSystem(List<String> enabledPackages,\n            List<String> permittedList, int userIdToCheck) {\n        long id = mInjector.binderClearCallingIdentity();\n        try {\n            // If we have an enabled packages list for a managed profile the packages\n            // we should check are installed for the parent user.\n            UserInfo user = getUserInfo(userIdToCheck);\n            if (user.isManagedProfile()) {\n                userIdToCheck = user.profileGroupId;\n            }\n\n            for (String enabledPackage : enabledPackages) {\n                boolean systemService = false;\n                try {\n                    ApplicationInfo applicationInfo = mIPackageManager.getApplicationInfo(\n                            enabledPackage, PackageManager.MATCH_UNINSTALLED_PACKAGES,\n                            userIdToCheck);\n\n                    if (applicationInfo == null) {\n                        return false;\n                    }\n\n                    systemService = (applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;\n                } catch (RemoteException e) {\n                    Slogf.i(LOG_TAG, \"Can't talk to package managed\", e);\n                }\n                if (!systemService && !permittedList.contains(enabledPackage)) {\n                    return false;\n                }\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        return true;\n    }\n\n    /**\n     * Invoke a method in AccessibilityManager ensuring the client is removed.\n     */\n    private <T> T withAccessibilityManager(\n            int userId, Function<AccessibilityManager, T> function) {\n        // Not using AccessibilityManager.getInstance because that guesses\n        // at the user you require based on callingUid and caches for a given\n        // process.\n        final IBinder iBinder = ServiceManager.getService(Context.ACCESSIBILITY_SERVICE);\n        final IAccessibilityManager service = iBinder == null\n                ? null : IAccessibilityManager.Stub.asInterface(iBinder);\n        final AccessibilityManager am = new AccessibilityManager(mContext, service, userId);\n        try {\n            return function.apply(am);\n        } finally {\n            am.removeClient();\n        }\n    }\n\n    @Override\n    public boolean setPermittedAccessibilityServices(ComponentName who, List<String> packageList) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        if (packageList != null) {\n            for (String pkg : packageList) {\n                enforceMaxPackageNameLength(pkg);\n            }\n\n            int userId = caller.getUserId();\n            final List<AccessibilityServiceInfo> enabledServices;\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                UserInfo user = getUserInfo(userId);\n                if (user.isManagedProfile()) {\n                    userId = user.profileGroupId;\n                }\n                enabledServices = withAccessibilityManager(userId,\n                        am -> am.getEnabledAccessibilityServiceList(FEEDBACK_ALL_MASK));\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n\n            if (enabledServices != null) {\n                List<String> enabledPackages = new ArrayList<>();\n                for (AccessibilityServiceInfo service : enabledServices) {\n                    enabledPackages.add(service.getResolveInfo().serviceInfo.packageName);\n                }\n                if (!checkPackagesInPermittedListOrSystem(enabledPackages, packageList,\n                        userId)) {\n                    Slogf.e(LOG_TAG, \"Cannot set permitted accessibility services, \"\n                            + \"because it contains already enabled accesibility services.\");\n                    return false;\n                }\n            }\n        }\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            admin.permittedAccessiblityServices = packageList;\n            saveSettingsLocked(UserHandle.getCallingUserId());\n        }\n        final String[] packageArray =\n                packageList != null ? ((List<String>) packageList).toArray(new String[0]) : null;\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PERMITTED_ACCESSIBILITY_SERVICES)\n                .setAdmin(who)\n                .setStrings(packageArray)\n                .write();\n        return true;\n    }\n\n    @Override\n    public List<String> getPermittedAccessibilityServices(ComponentName who) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            return admin.permittedAccessiblityServices;\n        }\n    }\n\n    @Override\n    public List<String> getPermittedAccessibilityServicesForUser(int userId) {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(caller) || canQueryAdminPolicy(caller));\n\n        List<String> result = null;\n\n        synchronized (getLockObject()) {\n            // If we have multiple profiles we return the intersection of the\n            // permitted lists. This can happen in cases where we have a device\n            // and profile owner.\n            int[] profileIds = mUserManager.getProfileIdsWithDisabled(userId);\n            for (int profileId : profileIds) {\n                // Just loop though all admins, only device or profiles\n                // owners can have permitted lists set.\n                DevicePolicyData policy = getUserDataUnchecked(profileId);\n                final int N = policy.mAdminList.size();\n                for (int j = 0; j < N; j++) {\n                    ActiveAdmin admin = policy.mAdminList.get(j);\n                    List<String> fromAdmin = admin.permittedAccessiblityServices;\n                    if (fromAdmin != null) {\n                        if (result == null) {\n                            result = new ArrayList<>(fromAdmin);\n                        } else {\n                            result.retainAll(fromAdmin);\n                        }\n                    }\n                }\n            }\n        }\n\n        // If we have a permitted list add all system accessibility services.\n        if (result != null) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                UserInfo user = getUserInfo(userId);\n                if (user.isManagedProfile()) {\n                    userId = user.profileGroupId;\n                }\n                // Move AccessibilityManager out of {@link getLockObject} to prevent potential\n                // deadlock.\n                final List<AccessibilityServiceInfo> installedServices =\n                        withAccessibilityManager(userId,\n                                AccessibilityManager::getInstalledAccessibilityServiceList);\n\n                if (installedServices != null) {\n                    for (AccessibilityServiceInfo service : installedServices) {\n                        ServiceInfo serviceInfo = service.getResolveInfo().serviceInfo;\n                        ApplicationInfo applicationInfo = serviceInfo.applicationInfo;\n                        if ((applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {\n                            result.add(serviceInfo.packageName);\n                        }\n                    }\n                }\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n\n        return result;\n    }\n\n    @Override\n    public boolean isAccessibilityServicePermittedByAdmin(ComponentName who, String packageName,\n            int userHandle) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkStringNotEmpty(packageName, \"packageName is null\");\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG,\n                        \"query if an accessibility service is disabled by admin\"));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n            if (admin == null) {\n                return false;\n            }\n            if (admin.permittedAccessiblityServices == null) {\n                return true;\n            }\n            return checkPackagesInPermittedListOrSystem(Collections.singletonList(packageName),\n                    admin.permittedAccessiblityServices, userHandle);\n        }\n    }\n\n    @Override\n    public boolean setPermittedInputMethods(ComponentName who, String callerPackageName,\n            List<String> packageList, boolean calledOnParentInstance) {\n        if (!mHasFeature) {\n            return false;\n        }\n\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n        }\n\n        int userId = getProfileParentUserIfRequested(\n                caller.getUserId(), calledOnParentInstance);\n        if (calledOnParentInstance) {\n            if (!isPolicyEngineForFinanceFlagEnabled()) {\n                Preconditions.checkCallAuthorization(\n                        isProfileOwnerOfOrganizationOwnedDevice(caller));\n            }\n            Preconditions.checkArgument(packageList == null || packageList.isEmpty(),\n                    \"Permitted input methods must allow all input methods or only \"\n                            + \"system input methods when called on the parent instance of an \"\n                            + \"organization-owned device\");\n        } else if (!isPolicyEngineForFinanceFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        }\n\n        if (packageList != null) {\n            for (String pkg : packageList) {\n                enforceMaxPackageNameLength(pkg);\n            }\n\n            List<InputMethodInfo> enabledImes = mInjector.binderWithCleanCallingIdentity(() ->\n                    InputMethodManagerInternal.get().getEnabledInputMethodListAsUser(userId));\n            if (enabledImes != null) {\n                List<String> enabledPackages = new ArrayList<String>();\n                for (InputMethodInfo ime : enabledImes) {\n                    enabledPackages.add(ime.getPackageName());\n                }\n                if (!checkPackagesInPermittedListOrSystem(enabledPackages, packageList,\n                        userId)) {\n                    Slogf.e(LOG_TAG, \"Cannot set permitted input methods, because the list of \"\n                            + \"permitted input methods excludes an already-enabled input method.\");\n                    return false;\n                }\n            }\n        }\n\n        synchronized (getLockObject()) {\n            if (isPolicyEngineForFinanceFlagEnabled()) {\n                EnforcingAdmin admin = enforcePermissionAndGetEnforcingAdmin(\n                        who, MANAGE_DEVICE_POLICY_INPUT_METHODS,\n                        caller.getPackageName(), userId);\n                if (packageList == null) {\n                    mDevicePolicyEngine.removeLocalPolicy(\n                            PolicyDefinition.PERMITTED_INPUT_METHODS,\n                            admin,\n                            userId);\n                } else {\n                    mDevicePolicyEngine.setLocalPolicy(\n                            PolicyDefinition.PERMITTED_INPUT_METHODS,\n                            admin,\n                            new StringSetPolicyValue(new HashSet<>(packageList)),\n                            userId);\n                }\n            } else {\n                ActiveAdmin admin = getParentOfAdminIfRequired(\n                        getProfileOwnerOrDeviceOwnerLocked(caller.getUserId()),\n                        calledOnParentInstance);\n                admin.permittedInputMethods = packageList;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PERMITTED_INPUT_METHODS)\n                .setAdmin(caller.getPackageName())\n                .setStrings(getStringArrayForLogging(packageList, calledOnParentInstance))\n                .write();\n        return true;\n    }\n\n    private String[] getStringArrayForLogging(List list, boolean calledOnParentInstance) {\n        List<String> stringList = new ArrayList<String>();\n        stringList.add(calledOnParentInstance ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT);\n        if (list == null) {\n            stringList.add(NULL_STRING_ARRAY);\n        } else {\n            stringList.addAll((List<String>) list);\n        }\n        return stringList.toArray(new String[0]);\n    }\n\n    @Override\n    public List<String> getPermittedInputMethods(ComponentName who, String callerPackageName,\n            boolean calledOnParentInstance) {\n        if (!mHasFeature) {\n            return null;\n        }\n\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n        }\n\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            if (calledOnParentInstance) {\n                Preconditions.checkCallAuthorization(\n                        isProfileOwnerOfOrganizationOwnedDevice(caller));\n            } else {\n                Preconditions.checkCallAuthorization(\n                        isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n            }\n        }\n\n        synchronized (getLockObject()) {\n            if (isPolicyEngineForFinanceFlagEnabled()) {\n                int affectedUser = calledOnParentInstance ? getProfileParentId(\n                        caller.getUserId()) : caller.getUserId();\n                Set<String> policy = mDevicePolicyEngine.getResolvedPolicy(\n                        PolicyDefinition.PERMITTED_INPUT_METHODS, affectedUser);\n                return policy == null ? null : new ArrayList<>(policy);\n            } else {\n                ActiveAdmin admin = getParentOfAdminIfRequired(\n                        getProfileOwnerOrDeviceOwnerLocked(\n                                caller.getUserId()), calledOnParentInstance);\n                return admin.permittedInputMethods;\n            }\n        }\n    }\n\n    @Override\n    public @Nullable List<String> getPermittedInputMethodsAsUser(@UserIdInt int userId) {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userId));\n        Preconditions.checkCallAuthorization(canManageUsers(caller) || canQueryAdminPolicy(caller));\n        final long callingIdentity = Binder.clearCallingIdentity();\n        try {\n            return getPermittedInputMethodsUnchecked(userId);\n        } finally {\n            Binder.restoreCallingIdentity(callingIdentity);\n        }\n    }\n\n    private @Nullable List<String> getPermittedInputMethodsUnchecked(@UserIdInt int userId) {\n        List<String> result = null;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            Set<String> policy = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.PERMITTED_INPUT_METHODS, userId);\n            result = policy == null ? null : new ArrayList<>(policy);\n        } else {\n            synchronized (getLockObject()) {\n                // Only device or profile owners can have permitted lists set.\n                List<ActiveAdmin> admins =\n                        getActiveAdminsForAffectedUserInclPermissionBasedAdminLocked(\n                                userId);\n                for (ActiveAdmin admin : admins) {\n                    List<String> fromAdmin = admin.permittedInputMethods;\n                    if (fromAdmin != null) {\n                        if (result == null) {\n                            result = new ArrayList<String>(fromAdmin);\n                        } else {\n                            result.retainAll(fromAdmin);\n                        }\n                    }\n                }\n            }\n        }\n\n        // If we have a permitted list add all system input methods.\n        if (result != null) {\n            List<InputMethodInfo> imes = InputMethodManagerInternal\n                    .get().getInputMethodListAsUser(userId);\n            if (imes != null) {\n                for (InputMethodInfo ime : imes) {\n                    ServiceInfo serviceInfo = ime.getServiceInfo();\n                    ApplicationInfo applicationInfo = serviceInfo.applicationInfo;\n                    if ((applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {\n                        result.add(serviceInfo.packageName);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isInputMethodPermittedByAdmin(ComponentName who, String packageName,\n            int userHandle, boolean calledOnParentInstance) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkStringNotEmpty(packageName, \"packageName is null\");\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG,\n                        \"query if an input method is disabled by admin\"));\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            int affectedUser = calledOnParentInstance ? getProfileParentId(userHandle) : userHandle;\n            Map<EnforcingAdmin, PolicyValue<Set<String>>> policies =\n                    mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                            PolicyDefinition.PERMITTED_INPUT_METHODS, affectedUser);\n            EnforcingAdmin admin = null;\n            for (EnforcingAdmin a : policies.keySet()) {\n                if (a.getPackageName().equals(who.getPackageName())) {\n                    if (policies.get(a).getValue() == null) {\n                        return true;\n                    } else {\n                        return checkPackagesInPermittedListOrSystem(\n                                Collections.singletonList(packageName),\n                                new ArrayList<>(policies.get(a).getValue()), affectedUser);\n                    }\n                }\n            }\n            // Admin didn't set a policy\n            return false;\n        } else {\n            synchronized (getLockObject()) {\n                ActiveAdmin admin = getParentOfAdminIfRequired(\n                        getActiveAdminUncheckedLocked(who, userHandle), calledOnParentInstance);\n                if (admin == null) {\n                    return false;\n                }\n                if (admin.permittedInputMethods == null) {\n                    return true;\n                }\n                return checkPackagesInPermittedListOrSystem(Collections.singletonList(packageName),\n                        admin.permittedInputMethods, userHandle);\n            }\n        }\n    }\n\n    @Override\n    public boolean setPermittedCrossProfileNotificationListeners(\n            ComponentName who, List<String> packageList) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n\n        if (!isManagedProfile(caller.getUserId())) {\n            return false;\n        }\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            admin.permittedNotificationListeners = packageList;\n            saveSettingsLocked(caller.getUserId());\n        }\n        return true;\n    }\n\n    @Override\n    public List<String> getPermittedCrossProfileNotificationListeners(ComponentName who) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            // API contract is to return null if there are no permitted cross-profile notification\n            // listeners, including in Device Owner mode.\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            return admin.permittedNotificationListeners;\n        }\n    }\n\n    @Override\n    public boolean isNotificationListenerServicePermitted(String packageName, int userId) {\n        if (!mHasFeature) {\n            return true;\n        }\n\n        Preconditions.checkStringNotEmpty(packageName, \"packageName is null or empty\");\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG,\n                        \"query if a notification listener service is permitted\"));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin profileOwner = getProfileOwnerAdminLocked(userId);\n            if (profileOwner == null || profileOwner.permittedNotificationListeners == null) {\n                return true;\n            }\n            return checkPackagesInPermittedListOrSystem(Collections.singletonList(packageName),\n                    profileOwner.permittedNotificationListeners, userId);\n\n        }\n    }\n\n    private void maybeSendAdminEnabledBroadcastLocked(int userHandle) {\n        DevicePolicyData policyData = getUserData(userHandle);\n        if (policyData.mAdminBroadcastPending) {\n            // Send the initialization data to profile owner and delete the data\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userHandle);\n            boolean clearInitBundle = true;\n            if (admin != null) {\n                PersistableBundle initBundle = policyData.mInitBundle;\n                clearInitBundle = sendAdminCommandLocked(admin,\n                        DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED,\n                        initBundle == null ? null : new Bundle(initBundle),\n                        /* result= */ null ,\n                        /* inForeground= */ true);\n            }\n            if (clearInitBundle) {\n                // If there's no admin or we've successfully called the admin, clear the init bundle\n                // otherwise, keep it around\n                policyData.mInitBundle = null;\n                policyData.mAdminBroadcastPending = false;\n                saveSettingsLocked(userHandle);\n            }\n        }\n    }\n\n    @Override\n    public UserHandle createAndManageUser(ComponentName admin, String name,\n            ComponentName profileOwner, PersistableBundle adminExtras, int flags) {\n        Objects.requireNonNull(admin, \"admin is null\");\n        Objects.requireNonNull(profileOwner, \"profileOwner is null\");\n        if (!admin.getPackageName().equals(profileOwner.getPackageName())) {\n            throw new IllegalArgumentException(\"profileOwner \" + profileOwner + \" and admin \"\n                    + admin + \" are not in the same package\");\n        }\n        final CallerIdentity caller = getCallerIdentity(admin);\n        // Only allow the system user to use this method\n        Preconditions.checkCallAuthorization(caller.getUserHandle().isSystem(),\n                \"createAndManageUser was called from non-system user\");\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_CREATE_AND_MANAGE_USER);\n\n        final boolean ephemeral = (flags & DevicePolicyManager.MAKE_USER_EPHEMERAL) != 0;\n        final boolean demo = (flags & DevicePolicyManager.MAKE_USER_DEMO) != 0\n                && UserManager.isDeviceInDemoMode(mContext);\n        final boolean leaveAllSystemAppsEnabled = (flags & LEAVE_ALL_SYSTEM_APPS_ENABLED) != 0;\n        final int targetSdkVersion;\n\n        // Create user.\n        UserHandle user = null;\n        synchronized (getLockObject()) {\n            final long id = mInjector.binderClearCallingIdentity();\n            try {\n                targetSdkVersion = mInjector.getPackageManagerInternal().getUidTargetSdkVersion(\n                        caller.getUid());\n\n                // Return detail error code for checks inside\n                // UserManagerService.createUserInternalUnchecked.\n                DeviceStorageMonitorInternal deviceStorageMonitorInternal =\n                        LocalServices.getService(DeviceStorageMonitorInternal.class);\n                if (deviceStorageMonitorInternal.isMemoryLow()) {\n                    if (targetSdkVersion >= Build.VERSION_CODES.P) {\n                        throw new ServiceSpecificException(\n                                UserManager.USER_OPERATION_ERROR_LOW_STORAGE, \"low device storage\");\n                    } else {\n                        return null;\n                    }\n                }\n\n                String userType = demo ? UserManager.USER_TYPE_FULL_DEMO\n                        : UserManager.USER_TYPE_FULL_SECONDARY;\n                int userInfoFlags = ephemeral ? UserInfo.FLAG_EPHEMERAL : 0;\n\n                if (!mUserManager.canAddMoreUsers(userType)) {\n                    if (targetSdkVersion >= Build.VERSION_CODES.P) {\n                        throw new ServiceSpecificException(\n                                UserManager.USER_OPERATION_ERROR_MAX_USERS, \"user limit reached\");\n                    } else {\n                        return null;\n                    }\n                }\n\n                String[] disallowedPackages = null;\n                if (!leaveAllSystemAppsEnabled) {\n                    disallowedPackages = mOverlayPackagesProvider.getNonRequiredApps(admin,\n                            UserHandle.myUserId(), ACTION_PROVISION_MANAGED_USER).toArray(\n                            new String[0]);\n                }\n\n                Object token = new Object();\n                Slogf.d(LOG_TAG, \"Adding new pending token: \" + token);\n                mPendingUserCreatedCallbackTokens.add(token);\n                try {\n                    UserInfo userInfo = mUserManagerInternal.createUserEvenWhenDisallowed(name,\n                            userType, userInfoFlags, disallowedPackages, token);\n                    if (userInfo != null) {\n                        user = userInfo.getUserHandle();\n                    }\n                } catch (UserManager.CheckedUserOperationException e) {\n                    Slogf.e(LOG_TAG, \"Couldn't createUserEvenWhenDisallowed\", e);\n                }\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        } // synchronized\n\n        if (user == null) {\n            if (targetSdkVersion >= Build.VERSION_CODES.P) {\n                throw new ServiceSpecificException(UserManager.USER_OPERATION_ERROR_UNKNOWN,\n                        \"failed to create user\");\n            } else {\n                return null;\n            }\n        }\n\n        final int userHandle = user.getIdentifier();\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            maybeInstallDevicePolicyManagementRoleHolderInUser(userHandle);\n\n            manageUserUnchecked(admin, profileOwner, userHandle, adminExtras,\n                    /* showDisclaimer= */ true);\n\n            if ((flags & DevicePolicyManager.SKIP_SETUP_WIZARD) != 0) {\n                Settings.Secure.putIntForUser(mContext.getContentResolver(),\n                        Settings.Secure.USER_SETUP_COMPLETE, 1, userHandle);\n            }\n\n            sendProvisioningCompletedBroadcast(\n                    userHandle, ACTION_PROVISION_MANAGED_USER, leaveAllSystemAppsEnabled);\n\n            return user;\n        } catch (Throwable re) {\n            mUserManager.removeUser(userHandle);\n            if (targetSdkVersion >= Build.VERSION_CODES.P) {\n                throw new ServiceSpecificException(UserManager.USER_OPERATION_ERROR_UNKNOWN,\n                        re.getMessage());\n            } else {\n                return null;\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    private void sendProvisioningCompletedBroadcast(\n            int user, String action, boolean leaveAllSystemAppsEnabled) {\n        final Intent intent = new Intent(DevicePolicyManager.ACTION_PROVISIONING_COMPLETED)\n                .putExtra(Intent.EXTRA_USER_HANDLE, user)\n                .putExtra(Intent.EXTRA_USER, UserHandle.of(user))\n                .putExtra(\n                        DevicePolicyManager.EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED,\n                        leaveAllSystemAppsEnabled)\n                .putExtra(DevicePolicyManager.EXTRA_PROVISIONING_ACTION,\n                        action)\n                .setPackage(getManagedProvisioningPackage(mContext))\n                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        mContext.sendBroadcastAsUser(intent, UserHandle.SYSTEM);\n    }\n\n    private void manageUserUnchecked(ComponentName admin, ComponentName profileOwner,\n            @UserIdInt int userId, @Nullable PersistableBundle adminExtras,\n            boolean showDisclaimer) {\n        synchronized (getLockObject()) {\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"manageUserUnchecked(): admin=\" + admin + \", po=\" + profileOwner\n                        + \", userId=\" + userId + \", hasAdminExtras=\" + (adminExtras != null)\n                        + \", showDisclaimer=\" + showDisclaimer);\n            }\n        }\n        final String adminPkg = admin.getPackageName();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                // Install the profile owner if not present.\n                if (!mIPackageManager.isPackageAvailable(adminPkg, userId)) {\n                    mIPackageManager.installExistingPackageAsUser(adminPkg, userId,\n                            PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                            PackageManager.INSTALL_REASON_POLICY,\n                            /* allowlistedRestrictedPermissions= */ null);\n                }\n            } catch (RemoteException e) {\n                // Does not happen, same process\n                Slogf.wtf(LOG_TAG, e, \"Failed to install admin package %s for user %d\",\n                        adminPkg, userId);\n            }\n        });\n\n        // Set admin.\n        setActiveAdmin(profileOwner, /* refreshing= */ true, userId);\n        setProfileOwner(profileOwner, userId);\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(userId);\n            policyData.mInitBundle = adminExtras;\n            policyData.mAdminBroadcastPending = true;\n            policyData.mNewUserDisclaimer = showDisclaimer\n                    ? DevicePolicyData.NEW_USER_DISCLAIMER_NEEDED\n                    : DevicePolicyData.NEW_USER_DISCLAIMER_NOT_NEEDED;\n            saveSettingsLocked(userId);\n\n        }\n    }\n\n    private void handleNewUserCreated(UserInfo user, @Nullable Object token) {\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"handleNewUserCreated(): user=\" + user.toFullString()\n                    + \", token=\" + token);\n        }\n\n        final int userId = user.id;\n\n        if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n            mDevicePolicyEngine.handleUserCreated(user);\n        }\n\n        if (token != null) {\n            synchronized (getLockObject()) {\n                if (mPendingUserCreatedCallbackTokens.contains(token)) {\n                    // Ignore because it was triggered by createAndManageUser()\n                    Slogf.d(LOG_TAG, \"handleNewUserCreated(): ignoring for user \" + userId\n                            + \" due to token \" + token);\n                    mPendingUserCreatedCallbackTokens.remove(token);\n                    return;\n                }\n            }\n        }\n\n        if (!mOwners.hasDeviceOwner() || !user.isFull() || user.isManagedProfile()\n                || user.isGuest()) {\n            return;\n        }\n\n        if (mInjector.userManagerIsHeadlessSystemUserMode()) {\n            ComponentName admin = mOwners.getDeviceOwnerComponent();\n            Slogf.i(LOG_TAG, \"Automatically setting profile owner (\" + admin + \") on new user \"\n                    + userId);\n            manageUserUnchecked(/* deviceOwner= */ admin, /* profileOwner= */ admin,\n                    /* managedUser= */ userId, /* adminExtras= */ null, /* showDisclaimer= */ true);\n        } else {\n            Slogf.i(LOG_TAG, \"User %d added on DO mode; setting ShowNewUserDisclaimer\", userId);\n            setShowNewUserDisclaimer(userId, DevicePolicyData.NEW_USER_DISCLAIMER_NEEDED);\n        }\n    }\n\n    @Override\n    public void acknowledgeNewUserDisclaimer(@UserIdInt int userId) {\n        CallerIdentity callerIdentity = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(callerIdentity)\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n\n        setShowNewUserDisclaimer(userId, DevicePolicyData.NEW_USER_DISCLAIMER_ACKNOWLEDGED);\n    }\n\n    private void setShowNewUserDisclaimer(@UserIdInt int userId, String value) {\n        Slogf.i(LOG_TAG, \"Setting new user disclaimer for user \" + userId + \" as \" + value);\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(userId);\n            policyData.mNewUserDisclaimer = value;\n            saveSettingsLocked(userId);\n        }\n    }\n\n    private void showNewUserDisclaimerIfNecessary(@UserIdInt int userId) {\n        boolean mustShow;\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(userId);\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"showNewUserDisclaimerIfNecessary(\" + userId + \"): \"\n                        + policyData.mNewUserDisclaimer + \")\");\n            }\n            mustShow = DevicePolicyData.NEW_USER_DISCLAIMER_NEEDED\n                    .equals(policyData.mNewUserDisclaimer);\n        }\n        if (!mustShow) return;\n\n        Intent intent = new Intent(DevicePolicyManager.ACTION_SHOW_NEW_USER_DISCLAIMER);\n\n        // TODO(b/172691310): add CTS tests to make sure disclaimer is shown\n        Slogf.i(LOG_TAG, \"Dispatching ACTION_SHOW_NEW_USER_DISCLAIMER intent\");\n        mContext.sendBroadcastAsUser(intent, UserHandle.of(userId));\n    }\n\n    @Override\n    public boolean isNewUserDisclaimerAcknowledged(@UserIdInt int userId) {\n        CallerIdentity callerIdentity = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(callerIdentity)\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(userId);\n            return policyData.isNewUserDisclaimerAcknowledged();\n        }\n    }\n\n    @Override\n    public boolean removeUser(ComponentName who, UserHandle userHandle) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(userHandle, \"UserHandle is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_REMOVE_USER);\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            String restriction = isManagedProfile(userHandle.getIdentifier())\n                    ? UserManager.DISALLOW_REMOVE_MANAGED_PROFILE\n                    : UserManager.DISALLOW_REMOVE_USER;\n            if (isAdminAffectedByRestriction(who, restriction, caller.getUserId())) {\n                Slogf.w(LOG_TAG, \"The device owner cannot remove a user because %s is enabled, and \"\n                        + \"was not set by the device owner\", restriction);\n                return false;\n            }\n            return mUserManagerInternal.removeUserEvenWhenDisallowed(userHandle.getIdentifier());\n        });\n    }\n\n    private boolean isAdminAffectedByRestriction(\n            @Nullable ComponentName admin, String userRestriction, int userId) {\n        switch (mUserManager.getUserRestrictionSource(userRestriction, UserHandle.of(userId))) {\n            case UserManager.RESTRICTION_NOT_SET:\n                return false;\n            case UserManager.RESTRICTION_SOURCE_DEVICE_OWNER:\n            case UserManager.RESTRICTION_SOURCE_PROFILE_OWNER:\n                return !(isDeviceOwner(admin, userId) || isProfileOwner(admin, userId));\n            default:\n                return true;\n        }\n    }\n\n    @Override\n    public boolean switchUser(ComponentName who, UserHandle userHandle) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SWITCH_USER);\n\n        boolean switched = false;\n        // Save previous logout user id in case of failure\n        int logoutUserId = getLogoutUserIdUnchecked();\n        synchronized (getLockObject()) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                int userId = UserHandle.USER_SYSTEM;\n                if (userHandle != null) {\n                    userId = userHandle.getIdentifier();\n                }\n                Slogf.i(LOG_TAG, \"Switching to user %d (logout user is %d)\", userId, logoutUserId);\n                setLogoutUserIdLocked(UserHandle.USER_CURRENT);\n                switched = mInjector.getIActivityManager().switchUser(userId);\n                if (!switched) {\n                    Slogf.w(LOG_TAG, \"Failed to switch to user %d\", userId);\n                } else {\n                    Slogf.d(LOG_TAG, \"Switched\");\n                }\n                return switched;\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Couldn't switch user\", e);\n                return false;\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n                if (!switched) {\n                    setLogoutUserIdLocked(logoutUserId);\n                }\n            }\n        }\n    }\n\n    @Override\n    public int getLogoutUserId() {\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n\n        return getLogoutUserIdUnchecked();\n    }\n\n    private @UserIdInt int getLogoutUserIdUnchecked() {\n        synchronized (getLockObject()) {\n            return mLogoutUserId;\n        }\n    }\n\n    private void clearLogoutUser() {\n        synchronized (getLockObject()) {\n            setLogoutUserIdLocked(UserHandle.USER_NULL);\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void setLogoutUserIdLocked(@UserIdInt int userId) {\n        if (userId == UserHandle.USER_CURRENT) {\n            userId = getCurrentForegroundUserId();\n        }\n\n        Slogf.d(LOG_TAG, \"setLogoutUserId(): %d -> %d\", mLogoutUserId, userId);\n        mLogoutUserId = userId;\n    }\n\n    @Override\n    public int startUserInBackground(ComponentName who, UserHandle userHandle) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(userHandle, \"UserHandle is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_START_USER_IN_BACKGROUND);\n\n        final int userId = userHandle.getIdentifier();\n        if (isManagedProfile(userId)) {\n            Slogf.w(LOG_TAG, \"Managed profile cannot be started in background\");\n            return UserManager.USER_OPERATION_ERROR_MANAGED_PROFILE;\n        }\n\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            if (!mInjector.getActivityManagerInternal().canStartMoreUsers()) {\n                Slogf.w(LOG_TAG, \"Cannot start user %d, too many users in background\", userId);\n                return UserManager.USER_OPERATION_ERROR_MAX_RUNNING_USERS;\n            }\n\n            Slogf.i(LOG_TAG, \"Starting user %d in background\", userId);\n            if (mInjector.getIActivityManager().startUserInBackground(userId)) {\n                return UserManager.USER_OPERATION_SUCCESS;\n            } else {\n                Slogf.w(LOG_TAG, \"failed to start user %d in background\", userId);\n                return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n            }\n        } catch (RemoteException e) {\n            // Same process, should not happen.\n            return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    @Override\n    public int stopUser(ComponentName who, UserHandle userHandle) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(userHandle, \"UserHandle is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_STOP_USER);\n\n        final int userId = userHandle.getIdentifier();\n        if (isManagedProfile(userId)) {\n            Slogf.w(LOG_TAG, \"Managed profile cannot be stopped\");\n            return UserManager.USER_OPERATION_ERROR_MANAGED_PROFILE;\n        }\n\n        return stopUserUnchecked(userId);\n    }\n\n    @Override\n    public int logoutUser(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_LOGOUT_USER);\n\n        final int callingUserId = caller.getUserId();\n        synchronized (getLockObject()) {\n            if (!isUserAffiliatedWithDeviceLocked(callingUserId)) {\n                throw new SecurityException(\"Admin \" + who +\n                        \" is neither the device owner or affiliated user's profile owner.\");\n            }\n        }\n\n        if (isManagedProfile(callingUserId)) {\n            Slogf.w(LOG_TAG, \"Managed profile cannot be logout\");\n            return UserManager.USER_OPERATION_ERROR_MANAGED_PROFILE;\n        }\n\n        if (callingUserId != mInjector\n                .binderWithCleanCallingIdentity(() -> getCurrentForegroundUserId())) {\n            Slogf.d(LOG_TAG, \"logoutUser(): user %d is in background, just stopping, not switching\",\n                    callingUserId);\n            return stopUserUnchecked(callingUserId);\n        }\n\n        return logoutUserUnchecked(/* userIdToStop= */ callingUserId);\n    }\n\n    @Override\n    public int logoutUserInternal() {\n        CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(caller)\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n\n        int currentUserId = getCurrentForegroundUserId();\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"logout() called by uid %d; current user is %d\", caller.getUid(),\n                    currentUserId);\n        }\n        int result = logoutUserUnchecked(currentUserId);\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"Result of logout(): %d\", result);\n        }\n        return result;\n    }\n\n    private int logoutUserUnchecked(@UserIdInt int userIdToStop) {\n        int logoutUserId = getLogoutUserIdUnchecked();\n        if (logoutUserId == UserHandle.USER_NULL) {\n            // Could happen on devices using headless system user mode when called before calling\n            // switchUser() or startUserInBackground() first\n            Slogf.w(LOG_TAG, \"logoutUser(): could not determine which user to switch to\");\n            return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n        }\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            Slogf.i(LOG_TAG, \"logoutUser(): switching to user %d\", logoutUserId);\n            if (!mInjector.getIActivityManager().switchUser(logoutUserId)) {\n                Slogf.w(LOG_TAG, \"Failed to switch to user %d\", logoutUserId);\n                // This should never happen as target user is determined by getPreviousUserId()\n                return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n            }\n            clearLogoutUser();\n        } catch (RemoteException e) {\n            // Same process, should not happen.\n            return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n\n        return stopUserUnchecked(userIdToStop);\n    }\n\n    private int stopUserUnchecked(@UserIdInt int userId) {\n        Slogf.i(LOG_TAG, \"Stopping user %d\", userId);\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            switch (mInjector.getIActivityManager().stopUser(userId, true /*force*/, null)) {\n                case ActivityManager.USER_OP_SUCCESS:\n                    return UserManager.USER_OPERATION_SUCCESS;\n                case ActivityManager.USER_OP_IS_CURRENT:\n                    return UserManager.USER_OPERATION_ERROR_CURRENT_USER;\n                default:\n                    return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n            }\n        } catch (RemoteException e) {\n            // Same process, should not happen.\n            return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    @Override\n    public List<UserHandle> getSecondaryUsers(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            final List<UserInfo> userInfos = mInjector.getUserManager().getAliveUsers();\n            final List<UserHandle> userHandles = new ArrayList<>();\n            for (UserInfo userInfo : userInfos) {\n                UserHandle userHandle = userInfo.getUserHandle();\n                if (!userHandle.isSystem() && !isManagedProfile(userHandle.getIdentifier())) {\n                    userHandles.add(userInfo.getUserHandle());\n                }\n            }\n            return userHandles;\n        });\n    }\n\n    @Override\n    public boolean isEphemeralUser(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getUserManager().isUserEphemeral(caller.getUserId()));\n    }\n\n    @Override\n    public Bundle getApplicationRestrictions(ComponentName who, String callerPackage,\n            String packageName) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n\n        if (isUnicornFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforceCanQueryAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_APP_RESTRICTIONS,\n                    caller.getPackageName(),\n                    caller.getUserId()\n            );\n\n            LinkedHashMap<EnforcingAdmin, PolicyValue<Bundle>> policies =\n                    mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                            PolicyDefinition.APPLICATION_RESTRICTIONS(packageName),\n                            caller.getUserId());\n            if (policies.isEmpty() || !policies.containsKey(enforcingAdmin)) {\n                return Bundle.EMPTY;\n            }\n            return policies.get(enforcingAdmin).getValue();\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(caller,\n                    DELEGATION_APP_RESTRICTIONS)));\n            return mInjector.binderWithCleanCallingIdentity(() -> {\n                Bundle bundle = mUserManager.getApplicationRestrictions(packageName,\n                        caller.getUserHandle());\n                // if no restrictions were saved, mUserManager.getApplicationRestrictions\n                // returns null, but DPM method should return an empty Bundle as per JavaDoc\n                return bundle != null ? bundle : Bundle.EMPTY;\n            });\n        }\n    }\n\n    /**\n     * Returns the apps that are non-exempt from some policies (such as suspension), and populates\n     * the given set with the apps that are exempt.\n     *\n     * @param packageNames apps to check\n     * @param outputExemptApps will be populate with subset of {@code packageNames} that is exempt\n     * from some policy restrictions\n     *\n     * @return subset of {@code packageNames} that is affected by some policy restrictions.\n     */\n    private String[] populateNonExemptAndExemptFromPolicyApps(String[] packageNames,\n            Set<String> outputExemptApps) {\n        Preconditions.checkArgument(outputExemptApps.isEmpty(), \"outputExemptApps is not empty\");\n        List<String> exemptAppsList = listPolicyExemptAppsUnchecked(mContext);\n        if (exemptAppsList.isEmpty()) {\n            return packageNames;\n        }\n        // Using a set so contains() is O(1)\n        Set<String> exemptApps = new HashSet<>(exemptAppsList);\n        List<String> nonExemptApps = new ArrayList<>(packageNames.length);\n        for (int i = 0; i < packageNames.length; i++) {\n            String app = packageNames[i];\n            if (exemptApps.contains(app)) {\n                outputExemptApps.add(app);\n            } else {\n                nonExemptApps.add(app);\n            }\n        }\n        String[] result = new String[nonExemptApps.size()];\n        nonExemptApps.toArray(result);\n        return result;\n    }\n\n    @Override\n    public String[] setPackagesSuspended(ComponentName who, String callerPackage,\n            String[] packageNames, boolean suspended) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        ActiveAdmin admin;\n\n        if (isUnicornFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_PACKAGE_STATE,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            admin = enforcingAdmin.getActiveAdmin();\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(caller,\n                    DELEGATION_PACKAGE_ACCESS)));\n            synchronized (getLockObject()) {\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_PACKAGES_SUSPENDED);\n\n        // Must remove the exempt apps from the input before calling PM, then add them back to\n        // the array returned to the caller\n        Set<String> exemptApps = new HashSet<>();\n        packageNames = populateNonExemptAndExemptFromPolicyApps(packageNames, exemptApps);\n\n        String[] nonSuspendedPackages = null;\n        synchronized (getLockObject()) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                nonSuspendedPackages = mInjector.getPackageManagerInternal()\n                        .setPackagesSuspendedByAdmin(caller.getUserId(), packageNames, suspended);\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PACKAGES_SUSPENDED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ who == null)\n                .setStrings(packageNames)\n                .write();\n\n        if (nonSuspendedPackages == null) {\n            Slogf.w(LOG_TAG, \"PM failed to suspend packages (%s)\", Arrays.toString(packageNames));\n            return packageNames;\n        }\n\n        ArraySet<String> changed = new ArraySet<>(packageNames);\n        if (suspended) {\n            // Only save those packages that are actually suspended. If a package is exempt or is\n            // unsuspendable, it is skipped.\n            changed.removeAll(List.of(nonSuspendedPackages));\n        } else {\n            // If an admin tries to unsuspend a package that is either exempt or is not\n            // suspendable, drop it from the stored list assuming it must be already unsuspended.\n            changed.addAll(exemptApps);\n        }\n\n        synchronized (getLockObject()) {\n            ArraySet<String> current = new ArraySet<>(admin.suspendedPackages);\n            if (suspended) {\n                current.addAll(changed);\n            } else {\n                current.removeAll(changed);\n            }\n            admin.suspendedPackages = current.isEmpty() ? null : new ArrayList<>(current);\n            saveSettingsLocked(caller.getUserId());\n        }\n\n        if (exemptApps.isEmpty()) {\n            return nonSuspendedPackages;\n        }\n\n        String[] result = buildNonSuspendedPackagesUnionArray(nonSuspendedPackages, exemptApps);\n        if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"Returning %s\", Arrays.toString(result));\n        return result;\n    }\n\n    /**\n     * Returns an array containing the union of the given non-suspended packages and\n     * exempt apps. Assumes both parameters are non-null and non-empty.\n     */\n    private String[] buildNonSuspendedPackagesUnionArray(String[] nonSuspendedPackages,\n            Set<String> exemptApps) {\n        String[] result = new String[nonSuspendedPackages.length + exemptApps.size()];\n        int index = 0;\n        for (String app : nonSuspendedPackages) {\n            result[index++] = app;\n        }\n        for (String app : exemptApps) {\n            result[index++] = app;\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isPackageSuspended(ComponentName who, String callerPackage, String packageName) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n\n        if (isUnicornFlagEnabled()) {\n            enforcePermission(\n                    MANAGE_DEVICE_POLICY_PACKAGE_STATE,\n                    caller.getPackageName(),\n                    caller.getUserId());\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(caller,\n                    DELEGATION_PACKAGE_ACCESS)));\n        }\n\n        synchronized (getLockObject()) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                return mIPackageManager.isPackageSuspendedForUser(packageName, caller.getUserId());\n            } catch (RemoteException re) {\n                // Shouldn't happen.\n                Slogf.e(LOG_TAG, \"Failed talking to the package manager\", re);\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n            return false;\n        }\n    }\n\n    @Override\n    public List<String> listPolicyExemptApps() {\n        CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS)\n                        || isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        return listPolicyExemptAppsUnchecked(mContext);\n    }\n\n    private static List<String> listPolicyExemptAppsUnchecked(Context context) {\n        // TODO(b/181238156): decide whether it should only list the apps set by the resources,\n        // or also the \"critical\" apps defined by PersonalAppsSuspensionHelper (like SMS app).\n        // If it's the latter, refactor PersonalAppsSuspensionHelper so it (or a superclass) takes\n        // the resources on constructor.\n        String[] core = context.getResources().getStringArray(R.array.policy_exempt_apps);\n        String[] vendor = context.getResources().getStringArray(R.array.vendor_policy_exempt_apps);\n\n        int size = core.length + vendor.length;\n        Set<String> apps = new ArraySet<>(size);\n        for (String app : core) {\n            apps.add(app);\n        }\n        for (String app : vendor) {\n            apps.add(app);\n        }\n\n        return new ArrayList<>(apps);\n    }\n\n    @Override\n    public void setUserRestriction(\n            ComponentName who, String callerPackage, String key, boolean enabledFromThisOwner,\n            boolean parent) {\n\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackage);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        int userId = caller.getUserId();\n        int affectedUserId = parent ? getProfileParentId(userId) : userId;\n\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_USER_RESTRICTION);\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            if (!isDeviceOwner(caller) && !isProfileOwner(caller)) {\n                EnforcingAdmin admin = enforcePermissionForUserRestriction(\n                        who,\n                        key,\n                        caller.getPackageName(),\n                        affectedUserId);\n                if (!mInjector.isChangeEnabled(ENABLE_COEXISTENCE_CHANGE, callerPackage, userId)) {\n                    throw new IllegalStateException(\"Calling package is not targeting Android U.\");\n                }\n                if (!UserRestrictionsUtils.isValidRestriction(key)) {\n                    throw new IllegalArgumentException(\"Invalid restriction key: \" + key);\n                }\n                PolicyDefinition<Boolean> policyDefinition =\n                        PolicyDefinition.getPolicyDefinitionForUserRestriction(key);\n                if (enabledFromThisOwner) {\n                    setLocalUserRestrictionInternal(\n                            admin, key, /* enabled= */ true, affectedUserId);\n                } else {\n                    // Remove any local and global policy that was set by the admin\n                    if (!policyDefinition.isLocalOnlyPolicy()) {\n                        setGlobalUserRestrictionInternal(admin, key, /* enabled= */ false);\n                    }\n                    if (!policyDefinition.isGlobalOnlyPolicy()) {\n                        setLocalUserRestrictionInternal(admin, key, /* enabled= */ false,\n                                userId);\n\n                        int parentUserId = getProfileParentId(userId);\n                        if (parentUserId != userId) {\n                            setLocalUserRestrictionInternal(\n                                    admin, key, /* enabled= */ false, parentUserId);\n                        }\n                    }\n                }\n            } else {\n                if (!UserRestrictionsUtils.isValidRestriction(key)) {\n                    return;\n                }\n                Objects.requireNonNull(who, \"ComponentName is null\");\n                EnforcingAdmin admin = getEnforcingAdminForCaller(who, callerPackage);\n                checkAdminCanSetRestriction(caller, parent, key);\n                setBackwardCompatibleUserRestriction(\n                        caller, admin, key, enabledFromThisOwner, parent);\n            }\n        } else {\n            if (!UserRestrictionsUtils.isValidRestriction(key)) {\n                return;\n            }\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            checkAdminCanSetRestriction(caller, parent, key);\n            synchronized (getLockObject()) {\n                final ActiveAdmin activeAdmin = getParentOfAdminIfRequired(\n                        getProfileOwnerOrDeviceOwnerLocked(userId), parent);\n                // Save the restriction to ActiveAdmin.\n                final Bundle restrictions = activeAdmin.ensureUserRestrictions();\n                if (enabledFromThisOwner) {\n                    restrictions.putBoolean(key, true);\n                } else {\n                    restrictions.remove(key);\n                }\n                saveUserRestrictionsLocked(userId);\n            }\n        }\n        logUserRestrictionCall(key, enabledFromThisOwner, parent, caller);\n    }\n\n    private void checkAdminCanSetRestriction(CallerIdentity caller, boolean parent, String key) {\n        if (parent) {\n            Preconditions.checkCallAuthorization(\n                    isProfileOwnerOfOrganizationOwnedDevice(caller));\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isDeviceOwner(caller) || isProfileOwner(caller));\n        }\n        synchronized (getLockObject()) {\n            if (isDefaultDeviceOwner(caller)) {\n                if (!UserRestrictionsUtils.canDeviceOwnerChange(key)) {\n                    throw new SecurityException(\"Device owner cannot set user restriction \"\n                            + key);\n                }\n                Preconditions.checkArgument(!parent,\n                        \"Cannot use the parent instance in Device Owner mode\");\n            } else if (isFinancedDeviceOwner(caller)) {\n                if (!UserRestrictionsUtils.canFinancedDeviceOwnerChange(key)) {\n                    throw new SecurityException(\"Cannot set user restriction \" + key\n                            + \" when managing a financed device\");\n                }\n                Preconditions.checkArgument(!parent,\n                        \"Cannot use the parent instance in Financed Device Owner\"\n                                + \" mode\");\n            } else {\n                boolean profileOwnerCanChangeOnItself = !parent\n                        && UserRestrictionsUtils.canProfileOwnerChange(\n                        key, caller.getUserId() == getMainUserId());\n                boolean orgOwnedProfileOwnerCanChangeGlobally = parent\n                        && isProfileOwnerOfOrganizationOwnedDevice(caller)\n                        && UserRestrictionsUtils.canProfileOwnerOfOrganizationOwnedDeviceChange(\n                        key);\n\n                if (!profileOwnerCanChangeOnItself && !orgOwnedProfileOwnerCanChangeGlobally) {\n                    throw new SecurityException(\"Profile owner cannot set user restriction \"\n                            + key);\n                }\n            }\n        }\n    }\n    private void setBackwardCompatibleUserRestriction(\n            CallerIdentity caller, EnforcingAdmin admin, String key, boolean enabled,\n            boolean parent) {\n        synchronized (getLockObject()) {\n\n            int ownerType;\n            if (isDeviceOwner(caller)) {\n                ownerType = OWNER_TYPE_DEVICE_OWNER;\n            } else if (isProfileOwnerOfOrganizationOwnedDevice(caller)) {\n                ownerType = OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE;\n            } else if (isProfileOwner(caller)) {\n                ownerType = OWNER_TYPE_PROFILE_OWNER;\n            } else {\n                throw new IllegalStateException(\"Non-DO/Non-PO cannot set restriction \" + key\n                        + \" while targetSdkVersion is less than UPSIDE_DOWN_CAKE\");\n            }\n            setBackwardCompatibleUserRestrictionLocked(ownerType, admin, caller.getUserId(), key,\n                    enabled, parent);\n        }\n    }\n\n    private void setBackwardCompatibleUserRestrictionLocked(\n            int ownerType, EnforcingAdmin admin, int userId, String key, boolean enabled,\n            boolean parent) {\n        if (ownerType == OWNER_TYPE_DEVICE_OWNER) {\n            if (UserRestrictionsUtils.isGlobal(OWNER_TYPE_DEVICE_OWNER, key)) {\n                setGlobalUserRestrictionInternal(admin, key, enabled);\n            } else {\n                setLocalUserRestrictionInternal(admin, key, enabled, userId);\n            }\n        } else if (ownerType == OWNER_TYPE_PROFILE_OWNER\n                || ownerType == OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE) {\n            if (UserRestrictionsUtils.isGlobal(OWNER_TYPE_PROFILE_OWNER, key)\n                    || (parent && ownerType == OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE\n                    && UserRestrictionsUtils.isGlobal(\n                    OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE, key))) {\n                setGlobalUserRestrictionInternal(admin, key, enabled);\n            } else {\n                int affectedUserId = parent\n                        ? getProfileParentId(userId) : userId;\n                setLocalUserRestrictionInternal(admin, key, enabled, affectedUserId);\n            }\n        } else {\n            throw new IllegalStateException(\"Non-DO/Non-PO cannot set restriction \" + key\n                    + \" while targetSdkVersion is less than UPSIDE_DOWN_CAKE\");\n        }\n    }\n\n    @Override\n    public void setUserRestrictionGlobally(String callerPackage, String key) {\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n\n        EnforcingAdmin admin = enforcePermissionForUserRestriction(\n                /* who= */ null,\n                key,\n                caller.getPackageName(),\n                UserHandle.USER_ALL\n        );\n\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_USER_RESTRICTION);\n\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            throw new IllegalStateException(\"Feature flag is not enabled.\");\n        }\n        if (isDeviceOwner(caller) || isProfileOwner(caller)) {\n            throw new SecurityException(\"Admins are not allowed to call this API.\");\n        }\n        if (!mInjector.isChangeEnabled(\n                ENABLE_COEXISTENCE_CHANGE, callerPackage, caller.getUserId())) {\n            throw new IllegalStateException(\"Calling package is not targeting Android U.\");\n        }\n        if (!UserRestrictionsUtils.isValidRestriction(key)) {\n            throw new IllegalArgumentException(\"Invalid restriction key: \" + key);\n        }\n\n        setGlobalUserRestrictionInternal(admin, key, /* enabled= */ true);\n\n        logUserRestrictionCall(key, /* enabled= */ true, /* parent= */ false, caller);\n    }\n    private void setLocalUserRestrictionInternal(\n            EnforcingAdmin admin, String key, boolean enabled, int userId) {\n        PolicyDefinition<Boolean> policyDefinition =\n                PolicyDefinition.getPolicyDefinitionForUserRestriction(key);\n        if (enabled) {\n            mDevicePolicyEngine.setLocalPolicy(\n                    policyDefinition,\n                    admin,\n                    new BooleanPolicyValue(true),\n                    userId);\n        } else {\n            mDevicePolicyEngine.removeLocalPolicy(\n                    policyDefinition,\n                    admin,\n                    userId);\n        }\n    }\n    private void setGlobalUserRestrictionInternal(\n            EnforcingAdmin admin, String key, boolean enabled) {\n        PolicyDefinition<Boolean> policyDefinition =\n                PolicyDefinition.getPolicyDefinitionForUserRestriction(key);\n        if (enabled) {\n            mDevicePolicyEngine.setGlobalPolicy(\n                    PolicyDefinition.getPolicyDefinitionForUserRestriction(key),\n                    admin,\n                    new BooleanPolicyValue(true));\n        } else {\n            mDevicePolicyEngine.removeGlobalPolicy(\n                    policyDefinition,\n                    admin);\n        }\n    }\n\n    private void logUserRestrictionCall(\n            String key, boolean enabled, boolean parent, CallerIdentity caller) {\n        final int eventId = enabled\n                ? DevicePolicyEnums.ADD_USER_RESTRICTION\n                : DevicePolicyEnums.REMOVE_USER_RESTRICTION;\n        DevicePolicyEventLogger\n                .createEvent(eventId)\n                .setAdmin(caller.getComponentName())\n                .setStrings(key, parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT)\n                .write();\n        if (SecurityLog.isLoggingEnabled()) {\n            final int eventTag = enabled\n                    ? SecurityLog.TAG_USER_RESTRICTION_ADDED\n                    : SecurityLog.TAG_USER_RESTRICTION_REMOVED;\n            SecurityLog.writeEvent(eventTag, caller.getPackageName(), caller.getUserId(), key);\n        }\n    }\n\n    private void saveUserRestrictionsLocked(int userId) {\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            // User restrictions are handled in the policy engine\n            return;\n        }\n        saveSettingsLocked(userId);\n        pushUserRestrictions(userId);\n        sendChangedNotification(userId);\n    }\n\n    /**\n     * Pushes the user restrictions originating from a specific user.\n     *\n     * If called by the profile owner of an organization-owned device, the global and local\n     * user restrictions will be an accumulation of the global user restrictions from the profile\n     * owner active admin and its parent active admin. The key of the local user restrictions set\n     * will be the target user id.\n     */\n    private void pushUserRestrictions(int originatingUserId) {\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            // User restrictions are handled in the policy engine\n            return;\n        }\n        final Bundle global;\n        final RestrictionsSet local = new RestrictionsSet();\n        final boolean isDeviceOwner;\n        synchronized (getLockObject()) {\n            isDeviceOwner = mOwners.isDeviceOwnerUserId(originatingUserId);\n            if (isDeviceOwner) {\n                final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n                if (deviceOwner == null) {\n                    return; // Shouldn't happen.\n                }\n                global = deviceOwner.getGlobalUserRestrictions(OWNER_TYPE_DEVICE_OWNER);\n                local.updateRestrictions(originatingUserId, deviceOwner.getLocalUserRestrictions(\n                        OWNER_TYPE_DEVICE_OWNER));\n            } else {\n                final ActiveAdmin profileOwner = getProfileOwnerAdminLocked(originatingUserId);\n                if (profileOwner == null) {\n                    return;\n                }\n                global = profileOwner.getGlobalUserRestrictions(OWNER_TYPE_PROFILE_OWNER);\n                local.updateRestrictions(originatingUserId, profileOwner.getLocalUserRestrictions(\n                        OWNER_TYPE_PROFILE_OWNER));\n                // Global (device-wide) and local user restrictions set by the profile owner of an\n                // organization-owned device are stored in the parent ActiveAdmin instance.\n                if (isProfileOwnerOfOrganizationOwnedDevice(\n                        profileOwner.getUserHandle().getIdentifier())) {\n                    // The global restrictions set on the parent ActiveAdmin instance need to be\n                    // merged with the global restrictions set on the profile owner ActiveAdmin\n                    // instance, since both are to be applied device-wide.\n                    UserRestrictionsUtils.merge(global,\n                            profileOwner.getParentActiveAdmin().getGlobalUserRestrictions(\n                                    OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE));\n                    // The local restrictions set on the parent ActiveAdmin instance are only to be\n                    // applied to the primary user. They therefore need to be added the local\n                    // restriction set with the primary user id as the key, in this case the\n                    // primary user id is the target user.\n                    local.updateRestrictions(\n                            getProfileParentId(profileOwner.getUserHandle().getIdentifier()),\n                            profileOwner.getParentActiveAdmin().getLocalUserRestrictions(\n                                    OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE));\n                }\n            }\n        }\n        mUserManagerInternal.setDevicePolicyUserRestrictions(originatingUserId, global, local,\n                isDeviceOwner);\n    }\n\n    @Override\n    public Bundle getUserRestrictions(ComponentName who, String callerPackage, boolean parent) {\n        if (!mHasFeature) {\n            return null;\n        }\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackage);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            int targetUserId = parent\n                    ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n            EnforcingAdmin admin = getEnforcingAdminForCaller(who, callerPackage);\n            if (isDeviceOwner(caller) || isProfileOwner(caller)) {\n                Objects.requireNonNull(who, \"ComponentName is null\");\n                Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                        || isFinancedDeviceOwner(caller)\n                        || isProfileOwner(caller)\n                        || (parent && isProfileOwnerOfOrganizationOwnedDevice(caller)));\n\n                Bundle restrictions = getUserRestrictionsFromPolicyEngine(admin, targetUserId);\n                // Add global restrictions set by the admin as well.\n                restrictions.putAll(\n                        getUserRestrictionsFromPolicyEngine(admin, UserHandle.USER_ALL));\n                return restrictions;\n            } else {\n                if (!mInjector.isChangeEnabled(\n                        ENABLE_COEXISTENCE_CHANGE, callerPackage, caller.getUserId())) {\n                    throw new IllegalStateException(\"Calling package is not targeting Android U.\");\n                }\n                return getUserRestrictionsFromPolicyEngine(admin, targetUserId);\n            }\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isFinancedDeviceOwner(caller)\n                    || isProfileOwner(caller)\n                    || (parent && isProfileOwnerOfOrganizationOwnedDevice(caller)));\n            synchronized (getLockObject()) {\n                final ActiveAdmin activeAdmin = getParentOfAdminIfRequired(\n                        getProfileOwnerOrDeviceOwnerLocked(caller.getUserId()), parent);\n                return activeAdmin.userRestrictions;\n            }\n        }\n    }\n\n    // Map of user restriction to permission.\n    private static final HashMap<String, String[]> USER_RESTRICTION_PERMISSIONS = new HashMap<>();\n    {\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.ALLOW_PARENT_PROFILE_APP_LINKING, new String[]{MANAGE_DEVICE_POLICY_PROFILES});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_ADD_CLONE_PROFILE, new String[]{MANAGE_DEVICE_POLICY_PROFILES});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_ADD_USER, new String[]{MANAGE_DEVICE_POLICY_MODIFY_USERS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_ADD_WIFI_CONFIG, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_ADJUST_VOLUME, new String[]{MANAGE_DEVICE_POLICY_AUDIO_OUTPUT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_AIRPLANE_MODE, new String[]{MANAGE_DEVICE_POLICY_AIRPLANE_MODE});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_AMBIENT_DISPLAY, new String[]{MANAGE_DEVICE_POLICY_DISPLAY});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_APPS_CONTROL, new String[]{MANAGE_DEVICE_POLICY_APPS_CONTROL});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_AUTOFILL, new String[]{MANAGE_DEVICE_POLICY_AUTOFILL});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_BLUETOOTH, new String[]{MANAGE_DEVICE_POLICY_BLUETOOTH});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_BLUETOOTH_SHARING, new String[]{MANAGE_DEVICE_POLICY_BLUETOOTH});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CAMERA, new String[]{MANAGE_DEVICE_POLICY_CAMERA});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CAMERA_TOGGLE, new String[]{MANAGE_DEVICE_POLICY_CAMERA_TOGGLE});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CELLULAR_2G, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CHANGE_WIFI_STATE, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_BLUETOOTH, new String[]{MANAGE_DEVICE_POLICY_BLUETOOTH});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_BRIGHTNESS, new String[]{MANAGE_DEVICE_POLICY_DISPLAY});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_CELL_BROADCASTS, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_CREDENTIALS, new String[]{MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_DATE_TIME, new String[]{MANAGE_DEVICE_POLICY_TIME});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_DEFAULT_APPS, new String[]{MANAGE_DEFAULT_APPLICATIONS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_LOCALE, new String[]{MANAGE_DEVICE_POLICY_LOCALE});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_LOCATION, new String[]{MANAGE_DEVICE_POLICY_LOCATION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_PRIVATE_DNS, new String[]{MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_SCREEN_TIMEOUT, new String[]{MANAGE_DEVICE_POLICY_DISPLAY});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_TETHERING, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_VPN, new String[]{MANAGE_DEVICE_POLICY_VPN});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_WIFI, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONTENT_CAPTURE, new String[]{MANAGE_DEVICE_POLICY_SCREEN_CONTENT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONTENT_SUGGESTIONS, new String[]{MANAGE_DEVICE_POLICY_SCREEN_CONTENT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CREATE_WINDOWS, new String[]{MANAGE_DEVICE_POLICY_WINDOWS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CROSS_PROFILE_COPY_PASTE, new String[]{MANAGE_DEVICE_POLICY_PROFILE_INTERACTION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_DATA_ROAMING, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_DEBUGGING_FEATURES, new String[]{MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_FACTORY_RESET, new String[]{MANAGE_DEVICE_POLICY_FACTORY_RESET});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_FUN, new String[]{MANAGE_DEVICE_POLICY_FUN});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_INSTALL_APPS, new String[]{MANAGE_DEVICE_POLICY_APPS_CONTROL});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES, new String[]{MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY, new String[]{MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_MICROPHONE_TOGGLE, new String[]{MANAGE_DEVICE_POLICY_MICROPHONE_TOGGLE});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_MODIFY_ACCOUNTS, new String[]{MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA, new String[]{MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_NETWORK_RESET, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_OUTGOING_BEAM, new String[]{MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_OUTGOING_CALLS, new String[]{MANAGE_DEVICE_POLICY_CALLS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_PRINTING, new String[]{MANAGE_DEVICE_POLICY_PRINTING});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_REMOVE_USER, new String[]{MANAGE_DEVICE_POLICY_MODIFY_USERS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_RUN_IN_BACKGROUND, new String[]{MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SAFE_BOOT, new String[]{MANAGE_DEVICE_POLICY_SAFE_BOOT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SET_USER_ICON, new String[]{MANAGE_DEVICE_POLICY_MODIFY_USERS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SET_WALLPAPER, new String[]{MANAGE_DEVICE_POLICY_WALLPAPER});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SHARE_INTO_MANAGED_PROFILE, new String[]{MANAGE_DEVICE_POLICY_PROFILE_INTERACTION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SHARE_LOCATION, new String[]{MANAGE_DEVICE_POLICY_LOCATION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SHARING_ADMIN_CONFIGURED_WIFI, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SMS, new String[]{MANAGE_DEVICE_POLICY_SMS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SYSTEM_ERROR_DIALOGS, new String[]{MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_ULTRA_WIDEBAND_RADIO, new String[]{MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_UNIFIED_PASSWORD, new String[]{MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_UNINSTALL_APPS, new String[]{MANAGE_DEVICE_POLICY_APPS_CONTROL});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_UNMUTE_DEVICE, new String[]{MANAGE_DEVICE_POLICY_AUDIO_OUTPUT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_UNMUTE_MICROPHONE, new String[]{MANAGE_DEVICE_POLICY_MICROPHONE});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_USB_FILE_TRANSFER, new String[]{MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_USER_SWITCH, new String[]{MANAGE_DEVICE_POLICY_MODIFY_USERS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_WIFI_DIRECT, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_WIFI_TETHERING, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.ENSURE_VERIFY_APPS, new String[]{MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES});\n\n        // Restrictions not allowed to be set by admins.\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_RECORD_AUDIO, null);\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_WALLPAPER, null);\n    }\n\n    private EnforcingAdmin enforcePermissionForUserRestriction(ComponentName who,\n            String userRestriction, String callerPackageName, int userId) {\n        String[] permissions = USER_RESTRICTION_PERMISSIONS.get(userRestriction);\n        if (permissions.length > 0) {\n            try {\n                return enforcePermissionsAndGetEnforcingAdmin(who, permissions, callerPackageName,\n                        userId);\n            } catch (SecurityException e) {\n                throw new SecurityException(\"Caller does not hold the required permission for this \"\n                        + \"user restriction: \" + userRestriction + \".\\n\" + e.getMessage());\n            }\n         }\n        throw new SecurityException(\"Admins are not permitted to set User Restriction: \"\n                + userRestriction);\n    }\n\n    @Override\n    public Bundle getUserRestrictionsGlobally(String callerPackage) {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            throw new IllegalStateException(\"Feature flag is not enabled.\");\n        }\n\n        EnforcingAdmin admin = getEnforcingAdminForCaller(/*who=*/ null, caller.getPackageName());\n\n        return getUserRestrictionsFromPolicyEngine(admin,\n                UserHandle.USER_ALL);\n    }\n\n    /**\n     * Returns user restrictions set by the given admin for the provided {@code userId}.\n     *\n     * <p>Pass in {@link UserHandle#USER_ALL} for {@code userId} to get global restrictions set by\n     * the admin\n     */\n    private Bundle getUserRestrictionsFromPolicyEngine(EnforcingAdmin admin, int userId) {\n        Set<UserRestrictionPolicyKey> restrictionKeys =\n                mDevicePolicyEngine.getUserRestrictionPolicyKeysForAdmin(\n                        admin,\n                        userId);\n        Bundle restrictions = new Bundle();\n        for (UserRestrictionPolicyKey key : restrictionKeys) {\n            restrictions.putBoolean(key.getRestriction(), true);\n        }\n        return restrictions;\n    }\n\n    @Override\n    public boolean setApplicationHidden(ComponentName who, String callerPackage, String packageName,\n            boolean hidden, boolean parent) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        final int userId = parent ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            enforcePermission(MANAGE_DEVICE_POLICY_PACKAGE_STATE, caller.getPackageName(), userId);\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_PACKAGE_ACCESS)));\n        }\n\n        List<String> exemptApps = listPolicyExemptAppsUnchecked(mContext);\n        if (exemptApps.contains(packageName)) {\n            Slogf.d(LOG_TAG, \"setApplicationHidden(): ignoring %s as it's on policy-exempt list\",\n                    packageName);\n            return false;\n        }\n\n        boolean result;\n        synchronized (getLockObject()) {\n            if (parent) {\n                if (!isPolicyEngineForFinanceFlagEnabled()) {\n                    Preconditions.checkCallAuthorization(\n                            isProfileOwnerOfOrganizationOwnedDevice(\n                                    caller.getUserId()) && isManagedProfile(caller.getUserId()));\n                }\n                // Ensure the package provided is a system package, this is to ensure that this\n                // API cannot be used to leak if certain non-system package exists in the person\n                // profile.\n                mInjector.binderWithCleanCallingIdentity(() ->\n                        enforcePackageIsSystemPackage(packageName, userId));\n            }\n            checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_APPLICATION_HIDDEN);\n\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"calling pm.setApplicationHiddenSettingAsUser(%s, %b, %d)\",\n                        packageName, hidden, userId);\n            }\n            if (isPolicyEngineForFinanceFlagEnabled()) {\n                EnforcingAdmin admin = getEnforcingAdminForCaller(who, callerPackage);\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.APPLICATION_HIDDEN(packageName),\n                        admin,\n                        new BooleanPolicyValue(hidden),\n                        userId);\n                result = mInjector.binderWithCleanCallingIdentity(() -> {\n                    try {\n                        // This is a best effort to continue returning the same value that was\n                        // returned before the policy engine migration.\n                        return mInjector.getIPackageManager().getPackageInfo(\n                                packageName, MATCH_UNINSTALLED_PACKAGES, userId) != null\n                                && (mIPackageManager.getApplicationHiddenSettingAsUser(\n                                        packageName, userId) == hidden);\n                    } catch (RemoteException e) {\n                        return false;\n                    }\n                });\n            } else {\n                result = mInjector.binderWithCleanCallingIdentity(() -> mIPackageManager\n                        .setApplicationHiddenSettingAsUser(packageName, hidden, userId));\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_APPLICATION_HIDDEN)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ isCallerDelegate(caller))\n                .setStrings(packageName, hidden ? \"hidden\" : \"not_hidden\",\n                        parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT)\n                .write();\n        return result;\n    }\n\n    @Override\n    public boolean isApplicationHidden(ComponentName who, String callerPackage,\n            String packageName, boolean parent) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        int userId = parent ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            // TODO: Also support DELEGATION_PACKAGE_ACCESS\n            enforcePermission(MANAGE_DEVICE_POLICY_PACKAGE_STATE, caller.getPackageName(), userId);\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(\n                            caller, DELEGATION_PACKAGE_ACCESS)));\n        }\n\n        synchronized (getLockObject()) {\n            if (parent) {\n                if (!isPolicyEngineForFinanceFlagEnabled()) {\n                    Preconditions.checkCallAuthorization(\n                            isProfileOwnerOfOrganizationOwnedDevice(caller.getUserId())\n                                    && isManagedProfile(caller.getUserId()));\n                }\n                // Ensure the package provided is a system package.\n                mInjector.binderWithCleanCallingIdentity(() ->\n                        enforcePackageIsSystemPackage(packageName, userId));\n            }\n\n            return mInjector.binderWithCleanCallingIdentity(\n                    () -> mIPackageManager.getApplicationHiddenSettingAsUser(packageName, userId));\n        }\n    }\n\n    private void enforcePackageIsSystemPackage(String packageName, int userId)\n            throws RemoteException {\n        boolean isSystem;\n        try {\n            isSystem = isSystemApp(mIPackageManager, packageName, userId);\n        } catch (IllegalArgumentException e) {\n            isSystem = false;\n        }\n        if (!isSystem) {\n            throw new IllegalArgumentException(\"The provided package is not a system package\");\n        }\n    }\n\n    @Override\n    public void enableSystemApp(ComponentName who, String callerPackage, String packageName) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_ENABLE_SYSTEM_APP)));\n\n        final boolean isDemo = isCurrentUserDemo();\n        int userId = caller.getUserId();\n        long id = mInjector.binderClearCallingIdentity();\n        try {\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"installing \" + packageName + \" for \" + userId);\n            }\n\n            Preconditions.checkArgument(isDemo || isSystemApp(mIPackageManager, packageName,\n                    getProfileParentId(userId)), \"Only system apps can be enabled this way\");\n\n            // Install the app.\n            mIPackageManager.installExistingPackageAsUser(packageName, userId,\n                    PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                    PackageManager.INSTALL_REASON_POLICY, null);\n            if (isDemo) {\n                // Ensure the app is also ENABLED for demo users.\n                mIPackageManager.setApplicationEnabledSetting(packageName,\n                        PackageManager.COMPONENT_ENABLED_STATE_ENABLED,\n                        PackageManager.DONT_KILL_APP, userId, \"DevicePolicyManager\");\n            }\n        } catch (RemoteException re) {\n            // shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Failed to install \" + packageName, re);\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ENABLE_SYSTEM_APP)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ who == null)\n                .setStrings(packageName)\n                .write();\n    }\n\n    @Override\n    public int enableSystemAppWithIntent(ComponentName who, String callerPackage, Intent intent) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_ENABLE_SYSTEM_APP)));\n\n        int numberOfAppsInstalled = 0;\n        long id = mInjector.binderClearCallingIdentity();\n        try {\n            final int parentUserId = getProfileParentId(caller.getUserId());\n            List<ResolveInfo> activitiesToEnable = mIPackageManager\n                    .queryIntentActivities(intent,\n                            intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                            PackageManager.MATCH_DIRECT_BOOT_AWARE\n                                    | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n                            parentUserId)\n                    .getList();\n\n            if (VERBOSE_LOG) {\n                Slogf.d(LOG_TAG, \"Enabling system activities: \" + activitiesToEnable);\n            }\n            if (activitiesToEnable != null) {\n                for (ResolveInfo info : activitiesToEnable) {\n                    if (info.activityInfo != null) {\n                        String packageName = info.activityInfo.packageName;\n                        if (isSystemApp(mIPackageManager, packageName, parentUserId)) {\n                            numberOfAppsInstalled++;\n                            mIPackageManager.installExistingPackageAsUser(packageName,\n                                    caller.getUserId(),\n                                    PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                                    PackageManager.INSTALL_REASON_POLICY, null);\n                        } else {\n                            Slogf.d(LOG_TAG, \"Not enabling \" + packageName + \" since is not a\"\n                                    + \" system app\");\n                        }\n                    }\n                }\n            }\n        } catch (RemoteException e) {\n            // shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Failed to resolve intent for: \" + intent, e);\n            return 0;\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ENABLE_SYSTEM_APP_WITH_INTENT)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ who == null)\n                .setStrings(intent.getAction())\n                .write();\n        return numberOfAppsInstalled;\n    }\n\n    private boolean isSystemApp(IPackageManager pm, String packageName, int userId)\n            throws RemoteException {\n        ApplicationInfo appInfo = pm.getApplicationInfo(packageName, MATCH_UNINSTALLED_PACKAGES,\n                userId);\n        if (appInfo == null) {\n            throw new IllegalArgumentException(\"The application \" + packageName +\n                    \" is not present on this device\");\n        }\n        return (appInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;\n    }\n\n    @Override\n    public boolean installExistingPackage(ComponentName who, String callerPackage,\n            String packageName) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage()\n                && isCallerDelegate(caller, DELEGATION_INSTALL_EXISTING_PACKAGE)));\n\n        boolean result;\n        synchronized (getLockObject()) {\n            Preconditions.checkCallAuthorization(\n                    isUserAffiliatedWithDeviceLocked(caller.getUserId()),\n                            \"Admin %s is neither the device owner or \"\n                                    + \"affiliated user's profile owner.\", who);\n            final long id = mInjector.binderClearCallingIdentity();\n            try {\n                if (VERBOSE_LOG) {\n                    Slogf.v(LOG_TAG, \"installing \" + packageName + \" for \" + caller.getUserId());\n                }\n\n                // Install the package.\n                result = mIPackageManager.installExistingPackageAsUser(packageName,\n                        caller.getUserId(),\n                        PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                        PackageManager.INSTALL_REASON_POLICY, null)\n                        == PackageManager.INSTALL_SUCCEEDED;\n            } catch (RemoteException re) {\n                // shouldn't happen\n                Slogf.wtf(LOG_TAG, \"Error installing package\", re);\n                return false;\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n        if (result) {\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.INSTALL_EXISTING_PACKAGE)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ who == null)\n                    .setStrings(packageName)\n                    .write();\n        }\n        return result;\n    }\n\n    @Override\n    public void setAccountManagementDisabled(ComponentName who, String callerPackageName,\n            String accountType, boolean disabled, boolean parent) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        enforceMaxStringLength(accountType, \"account type\");\n\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        synchronized (getLockObject()) {\n            if (isPolicyEngineForFinanceFlagEnabled()) {\n                int affectedUser = getAffectedUser(parent);\n                EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                        who,\n                        MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT,\n                        caller.getPackageName(),\n                        affectedUser\n                );\n                if (disabled) {\n                    mDevicePolicyEngine.setLocalPolicy(\n                            PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(accountType),\n                            enforcingAdmin,\n                            new BooleanPolicyValue(disabled),\n                            affectedUser);\n                } else {\n                    mDevicePolicyEngine.removeLocalPolicy(\n                            PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(accountType),\n                            enforcingAdmin,\n                            affectedUser);\n                }\n            } else {\n                final ActiveAdmin ap;\n                Objects.requireNonNull(who, \"ComponentName is null\");\n                /*\n                 * When called on the parent DPM instance (parent == true), affects active admin\n                 * selection in two ways:\n                 * * The ActiveAdmin must be of an org-owned profile owner.\n                 * * The parent ActiveAdmin instance should be used for managing the restriction.\n                 */\n                if (parent) {\n                    ap = getParentOfAdminIfRequired(getOrganizationOwnedProfileOwnerLocked(caller),\n                            parent);\n                } else {\n                    Preconditions.checkCallAuthorization(\n                            isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n                    ap = getParentOfAdminIfRequired(\n                            getProfileOwnerOrDeviceOwnerLocked(caller.getUserId()), parent);\n                }\n                if (disabled) {\n                    ap.accountTypesWithManagementDisabled.add(accountType);\n                } else {\n                    ap.accountTypesWithManagementDisabled.remove(accountType);\n                }\n                saveSettingsLocked(UserHandle.getCallingUserId());\n            }\n        }\n    }\n\n    @Override\n    public String[] getAccountTypesWithManagementDisabled(String callerPackageName) {\n        return getAccountTypesWithManagementDisabledAsUser(UserHandle.getCallingUserId(),\n                callerPackageName, false);\n    }\n\n    @Override\n    public String[] getAccountTypesWithManagementDisabledAsUser(int userId,\n            String callerPackageName, boolean parent) {\n        if (!mHasFeature) {\n            return null;\n        }\n        CallerIdentity caller;\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n        final ArraySet<String> resultSet = new ArraySet<>();\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            int affectedUser = parent ? getProfileParentId(userId) : userId;\n            caller = getCallerIdentity(callerPackageName);\n            if (!hasPermission(MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT,\n                    callerPackageName, affectedUser)\n                    && !hasFullCrossUsersPermission(caller, userId)) {\n                throw new SecurityException(\"Caller does not have permission to call this on user: \"\n                        + affectedUser);\n            }\n            Set<PolicyKey> keys = mDevicePolicyEngine.getLocalPolicyKeysSetByAllAdmins(\n                    PolicyDefinition.GENERIC_ACCOUNT_MANAGEMENT_DISABLED,\n                    affectedUser);\n\n            for (PolicyKey key : keys) {\n                if (!(key instanceof AccountTypePolicyKey)) {\n                    throw new IllegalStateException(\"PolicyKey for \"\n                            + \"MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT is not of type \"\n                            + \"AccountTypePolicyKey\");\n                }\n                AccountTypePolicyKey parsedKey =\n                        (AccountTypePolicyKey) key;\n                String accountType = Objects.requireNonNull(parsedKey.getAccountType());\n\n                Boolean disabled = mDevicePolicyEngine.getResolvedPolicy(\n                        PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(accountType),\n                        affectedUser);\n                if (disabled != null && disabled) {\n                    resultSet.add(accountType);\n                }\n            }\n        } else {\n            caller = getCallerIdentity();\n            Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userId));\n\n            synchronized (getLockObject()) {\n                if (!parent) {\n                    final DevicePolicyData policy = getUserData(userId);\n                    for (ActiveAdmin admin : policy.mAdminList) {\n                        resultSet.addAll(admin.accountTypesWithManagementDisabled);\n                    }\n                }\n\n                // Check if there's a profile owner of an org-owned device and the method is called\n                // for the parent user of this profile owner.\n                final ActiveAdmin orgOwnedAdmin =\n                        getProfileOwnerOfOrganizationOwnedDeviceLocked(userId);\n                final boolean shouldGetParentAccounts = orgOwnedAdmin != null && (parent\n                        || UserHandle.getUserId(orgOwnedAdmin.getUid()) != userId);\n                if (shouldGetParentAccounts) {\n                    resultSet.addAll(\n                            orgOwnedAdmin.getParentActiveAdmin()\n                                    .accountTypesWithManagementDisabled);\n                }\n            }\n        }\n        return resultSet.toArray(new String[resultSet.size()]);\n    }\n\n    @Override\n    public void setUninstallBlocked(ComponentName who, String callerPackage, String packageName,\n            boolean uninstallBlocked) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionsAndGetEnforcingAdmin(\n                    who,\n                    new String[]{\n                            MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                            MANAGE_DEVICE_POLICY_BLOCK_UNINSTALL\n                    },\n                    caller.getPackageName(),\n                    caller.getUserId());\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.PACKAGE_UNINSTALL_BLOCKED(packageName),\n                    enforcingAdmin,\n                    new BooleanPolicyValue(uninstallBlocked),\n                    caller.getUserId());\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                    || isFinancedDeviceOwner(caller)))\n                    || (caller.hasPackage()\n                    && isCallerDelegate(caller, DELEGATION_BLOCK_UNINSTALL)));\n            final int userId = caller.getUserId();\n            synchronized (getLockObject()) {\n                long id = mInjector.binderClearCallingIdentity();\n                try {\n                    mIPackageManager.setBlockUninstallForUser(\n                            packageName, uninstallBlocked, userId);\n                } catch (RemoteException re) {\n                    // Shouldn't happen.\n                    Slogf.e(LOG_TAG, \"Failed to setBlockUninstallForUser\", re);\n                } finally {\n                    mInjector.binderRestoreCallingIdentity(id);\n                }\n            }\n            if (uninstallBlocked) {\n                final PackageManagerInternal pmi = mInjector.getPackageManagerInternal();\n                pmi.removeNonSystemPackageSuspensions(packageName, userId);\n                pmi.removeDistractingPackageRestrictions(packageName, userId);\n                pmi.flushPackageRestrictions(userId);\n            }\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_UNINSTALL_BLOCKED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ isCallerDelegate(caller))\n                .setStrings(packageName)\n                .write();\n    }\n\n    static void setUninstallBlockedUnchecked(\n            String packageName, boolean uninstallBlocked, int userId) {\n        Binder.withCleanCallingIdentity(() -> {\n            try {\n                AppGlobals.getPackageManager().setBlockUninstallForUser(\n                        packageName, uninstallBlocked, userId);\n            } catch (RemoteException re) {\n                // Shouldn't happen.\n                Slogf.e(LOG_TAG, \"Failed to setBlockUninstallForUser\", re);\n            }\n        });\n        if (uninstallBlocked) {\n            final PackageManagerInternal pmi = LocalServices.getService(\n                    PackageManagerInternal.class);\n            pmi.removeNonSystemPackageSuspensions(packageName, userId);\n            pmi.removeDistractingPackageRestrictions(packageName, userId);\n            pmi.flushPackageRestrictions(userId);\n        }\n    }\n\n    @Override\n    public boolean isUninstallBlocked(String packageName) {\n        // This function should return true if and only if the package is blocked by\n        // setUninstallBlocked(). It should still return false for other cases of blocks, such as\n        // when the package is a system app, or when it is an active device admin.\n        final int userId = UserHandle.getCallingUserId();\n\n        synchronized (getLockObject()) {\n            try {\n                return mIPackageManager.getBlockUninstallForUser(packageName, userId);\n            } catch (RemoteException re) {\n                // Shouldn't happen.\n                Slogf.e(LOG_TAG, \"Failed to getBlockUninstallForUser\", re);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void setCrossProfileCallerIdDisabled(ComponentName who, boolean disabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (disabled) {\n                admin.mManagedProfileCallerIdAccess =\n                        new PackagePolicy(PackagePolicy.PACKAGE_POLICY_ALLOWLIST);\n            } else {\n                admin.mManagedProfileCallerIdAccess =\n                        new PackagePolicy(PackagePolicy.PACKAGE_POLICY_BLOCKLIST);\n            }\n            saveSettingsLocked(caller.getUserId());\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CROSS_PROFILE_CALLER_ID_DISABLED)\n                .setAdmin(who)\n                .setBoolean(disabled)\n                .write();\n    }\n\n    @Override\n    public boolean getCrossProfileCallerIdDisabled(ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (admin == null) {\n                return false;\n            }\n\n            if (admin.mManagedProfileCallerIdAccess == null) {\n                return admin.disableCallerId;\n            }\n\n            if (admin.mManagedProfileCallerIdAccess.getPolicyType()\n                    == PackagePolicy.PACKAGE_POLICY_ALLOWLIST_AND_SYSTEM) {\n                Slogf.w(LOG_TAG, \"Denying callerId due to PACKAGE_POLICY_SYSTEM policyType\");\n            }\n\n            return admin.mManagedProfileCallerIdAccess.getPolicyType()\n                    != PackagePolicy.PACKAGE_POLICY_BLOCKLIST;\n        }\n    }\n\n    @Override\n    public boolean getCrossProfileCallerIdDisabledForUser(int userId) {\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            if (admin == null) {\n                return false;\n            }\n\n            if (admin.mManagedProfileCallerIdAccess == null) {\n                return admin.disableCallerId;\n            }\n\n            return admin.mManagedProfileCallerIdAccess.getPolicyType()\n                    == PackagePolicy.PACKAGE_POLICY_ALLOWLIST;\n        }\n    }\n\n    @Override\n    public void setManagedProfileCallerIdAccessPolicy(PackagePolicy policy) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId())));\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            admin.disableCallerId = false;\n            admin.mManagedProfileCallerIdAccess = policy;\n            saveSettingsLocked(caller.getUserId());\n        }\n    }\n\n    @Override\n    public PackagePolicy getManagedProfileCallerIdAccessPolicy() {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId())));\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return (admin != null) ? admin.mManagedProfileCallerIdAccess : null;\n        }\n    }\n\n    @Override\n    public boolean hasManagedProfileCallerIdAccess(int userId, String packageName) {\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            if (admin != null) {\n                if (admin.mManagedProfileCallerIdAccess == null) {\n                    return !admin.disableCallerId;\n                }\n                return admin.mManagedProfileCallerIdAccess.isPackageAllowed(packageName,\n                        mContactSystemRoleHolders);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void setManagedProfileContactsAccessPolicy(PackagePolicy policy) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId())));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            admin.disableContactsSearch = false;\n            admin.mManagedProfileContactsAccess = policy;\n            saveSettingsLocked(caller.getUserId());\n        }\n    }\n\n    @Override\n    public PackagePolicy getManagedProfileContactsAccessPolicy() {\n        if (!mHasFeature) {\n            return null;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId())));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return (admin != null) ? admin.mManagedProfileContactsAccess : null;\n        }\n    }\n\n    @Override\n    public boolean hasManagedProfileContactsAccess(int userId, String packageName) {\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            if (admin != null) {\n                if (admin.mManagedProfileContactsAccess == null) {\n                    return !admin.disableContactsSearch;\n                }\n\n                return admin.mManagedProfileContactsAccess.isPackageAllowed(packageName,\n                        mContactSystemRoleHolders);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void setCrossProfileContactsSearchDisabled(ComponentName who, boolean disabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (disabled) {\n                admin.mManagedProfileContactsAccess =\n                        new PackagePolicy(PackagePolicy.PACKAGE_POLICY_ALLOWLIST);\n            } else {\n                admin.mManagedProfileContactsAccess =\n                        new PackagePolicy(PackagePolicy.PACKAGE_POLICY_BLOCKLIST);\n            }\n            saveSettingsLocked(caller.getUserId());\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CROSS_PROFILE_CONTACTS_SEARCH_DISABLED)\n                .setAdmin(who)\n                .setBoolean(disabled)\n                .write();\n    }\n\n    @Override\n    public boolean getCrossProfileContactsSearchDisabled(ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (admin == null) {\n                return false;\n            }\n            if (admin.mManagedProfileContactsAccess == null) {\n                return admin.disableContactsSearch;\n            }\n            return admin.mManagedProfileContactsAccess.getPolicyType()\n                    != PackagePolicy.PACKAGE_POLICY_BLOCKLIST;\n        }\n    }\n\n    @Override\n    public boolean getCrossProfileContactsSearchDisabledForUser(int userId) {\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            if (admin == null) {\n                return false;\n            }\n\n            if (admin.mManagedProfileContactsAccess == null) {\n                return admin.disableContactsSearch;\n            }\n            if (admin.mManagedProfileContactsAccess.getPolicyType()\n                    == PackagePolicy.PACKAGE_POLICY_ALLOWLIST_AND_SYSTEM) {\n                Slogf.w(LOG_TAG, \"Denying contacts due to PACKAGE_POLICY_SYSTEM policyType\");\n            }\n            return admin.mManagedProfileContactsAccess.getPolicyType()\n                    != PackagePolicy.PACKAGE_POLICY_BLOCKLIST;\n        }\n    }\n\n    @Override\n    public void startManagedQuickContact(String actualLookupKey, long actualContactId,\n            boolean isContactIdIgnored, long actualDirectoryId, Intent originalIntent) {\n        final Intent intent = QuickContact.rebuildManagedQuickContactsIntent(actualLookupKey,\n                actualContactId, isContactIdIgnored, actualDirectoryId, originalIntent);\n        final int callingUserId = UserHandle.getCallingUserId();\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            synchronized (getLockObject()) {\n                final int managedUserId = getManagedUserId(callingUserId);\n                if (managedUserId < 0) {\n                    return;\n                }\n                if (isCrossProfileQuickContactDisabled(managedUserId)) {\n                    if (VERBOSE_LOG) {\n                        Slogf.v(LOG_TAG, \"Cross-profile contacts access disabled for user %d\",\n                                managedUserId);\n                    }\n                    return;\n                }\n                ContactsInternal.startQuickContactWithErrorToastForUser(\n                        mContext, intent, new UserHandle(managedUserId));\n            }\n        });\n    }\n\n    /**\n     * @return true if cross-profile QuickContact is disabled\n     */\n    private boolean isCrossProfileQuickContactDisabled(@UserIdInt int userId) {\n        return getCrossProfileCallerIdDisabledForUser(userId)\n                && getCrossProfileContactsSearchDisabledForUser(userId);\n    }\n\n    /**\n     * @return the user ID of the managed user that is linked to the current user, if any.\n     * Otherwise UserHandle.USER_NULL (-10000).\n     */\n    public int getManagedUserId(@UserIdInt int callingUserId) {\n        if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"getManagedUserId: callingUserId=%d\", callingUserId);\n\n        for (UserInfo ui : mUserManager.getProfiles(callingUserId)) {\n            if (ui.id == callingUserId || !ui.isManagedProfile()) {\n                continue; // Caller user self, or not a managed profile.  Skip.\n            }\n            if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"Managed user=%d\", ui.id);\n            return ui.id;\n        }\n        if (VERBOSE_LOG)  Slogf.v(LOG_TAG, \"Managed user not found.\");\n        return UserHandle.USER_NULL;\n    }\n\n    /**\n     * Returns the userId of the managed profile on the device.\n     * If none exists, return {@link UserHandle#USER_NULL}.\n     *\n     * We assume there is only one managed profile across all users\n     * on the device, which is true for now (HSUM or not) but could\n     * change in future.\n     */\n    private @UserIdInt int getManagedUserId() {\n        // On HSUM, there is only one main user and only the main user\n        // can have a managed profile (for now). On non-HSUM, only user 0\n        // can host the managed profile and user 0 is the main user.\n        // So in both cases, we could just get the main user and\n        // search for the profile user under it.\n        UserHandle mainUser = mUserManager.getMainUser();\n        if (mainUser == null) return UserHandle.USER_NULL;\n        return getManagedUserId(mainUser.getIdentifier());\n    }\n\n    @Override\n    public void setBluetoothContactSharingDisabled(ComponentName who, boolean disabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (admin.disableBluetoothContactSharing != disabled) {\n                admin.disableBluetoothContactSharing = disabled;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_BLUETOOTH_CONTACT_SHARING_DISABLED)\n                .setAdmin(who)\n                .setBoolean(disabled)\n                .write();\n    }\n\n    @Override\n    public boolean getBluetoothContactSharingDisabled(ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            return admin.disableBluetoothContactSharing;\n        }\n    }\n\n    @Override\n    public boolean getBluetoothContactSharingDisabledForUser(int userId) {\n        // TODO: Should there be a check to make sure this relationship is\n        // within a profile group?\n        // enforceSystemProcess(\"getCrossProfileCallerIdDisabled can only be called by system\");\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            return (admin != null) ? admin.disableBluetoothContactSharing : false;\n        }\n    }\n\n    @Override\n    public void setSecondaryLockscreenEnabled(ComponentName who, boolean enabled) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        // Check can set secondary lockscreen enabled\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        Preconditions.checkCallAuthorization(!isManagedProfile(caller.getUserId()),\n                \"User %d is not allowed to call setSecondaryLockscreenEnabled\",\n                        caller.getUserId());\n\n        synchronized (getLockObject()) {\n            // Allow testOnly admins to bypass supervision config requirement.\n            Preconditions.checkCallAuthorization(isAdminTestOnlyLocked(who, caller.getUserId())\n                    || isSupervisionComponentLocked(caller.getComponentName()), \"Admin %s is not \"\n                    + \"the default supervision component\", caller.getComponentName());\n            DevicePolicyData policy = getUserData(caller.getUserId());\n            policy.mSecondaryLockscreenEnabled = enabled;\n            saveSettingsLocked(caller.getUserId());\n        }\n    }\n\n    @Override\n    public boolean isSecondaryLockscreenEnabled(@NonNull UserHandle userHandle) {\n        synchronized (getLockObject()) {\n            return getUserData(userHandle.getIdentifier()).mSecondaryLockscreenEnabled;\n        }\n    }\n\n    private boolean isManagedProfileOwner(CallerIdentity caller) {\n        return isProfileOwner(caller) && isManagedProfile(caller.getUserId());\n    }\n\n    @Override\n    public void setPreferentialNetworkServiceConfigs(\n            List<PreferentialNetworkServiceConfig> preferentialNetworkServiceConfigs) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                        && isManagedProfile(caller.getUserId()))\n                        || isDefaultDeviceOwner(caller),\n                \"Caller is not managed profile owner or device owner;\"\n                        + \" only managed profile owner or device owner may control the preferential\"\n                        + \" network service\");\n        synchronized (getLockObject()) {\n            final ActiveAdmin requiredAdmin = getDeviceOrProfileOwnerAdminLocked(\n                    caller.getUserId());\n            if (!requiredAdmin.mPreferentialNetworkServiceConfigs.equals(\n                    preferentialNetworkServiceConfigs)) {\n                requiredAdmin.mPreferentialNetworkServiceConfigs =\n                        new ArrayList<>(preferentialNetworkServiceConfigs);\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n        updateNetworkPreferenceForUser(caller.getUserId(), preferentialNetworkServiceConfigs);\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PREFERENTIAL_NETWORK_SERVICE_ENABLED)\n                .setBoolean(preferentialNetworkServiceConfigs\n                        .stream().anyMatch(c -> c.isEnabled()))\n                .write();\n    }\n\n    @Override\n    public List<PreferentialNetworkServiceConfig> getPreferentialNetworkServiceConfigs() {\n        if (!mHasFeature) {\n            return List.of(PreferentialNetworkServiceConfig.DEFAULT);\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                        && isManagedProfile(caller.getUserId()))\n                        || isDefaultDeviceOwner(caller),\n                \"Caller is not managed profile owner or device owner;\"\n                        + \" only managed profile owner or device owner may retrieve the \"\n                        + \"preferential network service configurations\");\n        synchronized (getLockObject()) {\n            final ActiveAdmin requiredAdmin = getDeviceOrProfileOwnerAdminLocked(\n                    caller.getUserId());\n            return requiredAdmin.mPreferentialNetworkServiceConfigs;\n        }\n    }\n\n    @Override\n    public void setLockTaskPackages(ComponentName who, String callerPackageName, String[] packages)\n            throws SecurityException {\n        Objects.requireNonNull(packages, \"packages is null\");\n        for (String pkg : packages) {\n            enforceMaxPackageNameLength(pkg);\n        }\n\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_LOCK_TASK_PACKAGES);\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin;\n            synchronized (getLockObject()) {\n                enforcingAdmin = enforceCanCallLockTaskLocked(who, caller.getPackageName());\n            }\n            LockTaskPolicy currentPolicy = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.LOCK_TASK,\n                    enforcingAdmin,\n                    caller.getUserId());\n            LockTaskPolicy policy;\n            if (currentPolicy == null) {\n                policy = new LockTaskPolicy(Set.of(packages));\n            } else {\n                policy = new LockTaskPolicy(currentPolicy);\n                policy.setPackages(Set.of(packages));\n            }\n            if (policy.getPackages().isEmpty()) {\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.LOCK_TASK,\n                        enforcingAdmin,\n                        caller.getUserId());\n            } else {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.LOCK_TASK,\n                        enforcingAdmin,\n                        policy,\n                        caller.getUserId());\n            }\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            synchronized (getLockObject()) {\n                enforceCanCallLockTaskLocked(caller);\n                final int userHandle = caller.getUserId();\n                setLockTaskPackagesLocked(userHandle, new ArrayList<>(Arrays.asList(packages)));\n            }\n        }\n    }\n\n    private void setLockTaskPackagesLocked(int userHandle, List<String> packages) {\n        DevicePolicyData policy = getUserData(userHandle);\n        policy.mLockTaskPackages = packages;\n\n        // Store the settings persistently.\n        saveSettingsLocked(userHandle);\n        updateLockTaskPackagesLocked(mContext, packages, userHandle);\n    }\n\n    @Override\n    public String[] getLockTaskPackages(ComponentName who, String callerPackageName) {\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        final int userHandle = caller.getUserId();\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            synchronized (getLockObject()) {\n                enforceCanQueryLockTaskLocked(who, caller.getPackageName());\n            }\n            LockTaskPolicy policy = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.LOCK_TASK, userHandle);\n            if (policy == null) {\n                return new String[0];\n            } else {\n                return policy.getPackages().toArray(new String[policy.getPackages().size()]);\n            }\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            synchronized (getLockObject()) {\n                enforceCanCallLockTaskLocked(caller);\n                final List<String> packages = getUserData(userHandle).mLockTaskPackages;\n                return packages.toArray(new String[packages.size()]);\n            }\n        }\n    }\n\n    @Override\n    public boolean isLockTaskPermitted(String pkg) {\n        // Check policy-exempt apps first, as it doesn't require the lock\n        if (listPolicyExemptAppsUnchecked(mContext).contains(pkg)) {\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"isLockTaskPermitted(%s): returning true for policy-exempt app\",\n                            pkg);\n            }\n            return true;\n        }\n\n        final int userId = mInjector.userHandleGetCallingUserId();\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            LockTaskPolicy policy = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.LOCK_TASK, userId);\n            if (policy == null) {\n                return false;\n            }\n            return policy.getPackages().contains(pkg);\n        } else {\n            synchronized (getLockObject()) {\n                return getUserData(userId).mLockTaskPackages.contains(pkg);\n            }\n        }\n    }\n\n    @Override\n    public void setLockTaskFeatures(ComponentName who, String callerPackageName, int flags) {\n        // Throw if Overview is used without Home.\n        boolean hasHome = (flags & LOCK_TASK_FEATURE_HOME) != 0;\n        boolean hasOverview = (flags & LOCK_TASK_FEATURE_OVERVIEW) != 0;\n        Preconditions.checkArgument(hasHome || !hasOverview,\n                \"Cannot use LOCK_TASK_FEATURE_OVERVIEW without LOCK_TASK_FEATURE_HOME\");\n        boolean hasNotification = (flags & LOCK_TASK_FEATURE_NOTIFICATIONS) != 0;\n        Preconditions.checkArgument(hasHome || !hasNotification,\n            \"Cannot use LOCK_TASK_FEATURE_NOTIFICATIONS without LOCK_TASK_FEATURE_HOME\");\n\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        final int userHandle = caller.getUserId();\n        synchronized (getLockObject()) {\n            checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_LOCK_TASK_FEATURES);\n        }\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin;\n            synchronized (getLockObject()) {\n                enforcingAdmin = enforceCanCallLockTaskLocked(who, caller.getPackageName());\n                enforceCanSetLockTaskFeaturesOnFinancedDevice(caller, flags);\n            }\n            LockTaskPolicy currentPolicy = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.LOCK_TASK,\n                    enforcingAdmin,\n                    caller.getUserId());\n            LockTaskPolicy policy;\n            if (currentPolicy == null) {\n                policy = new LockTaskPolicy(flags);\n            } else {\n                policy = new LockTaskPolicy(currentPolicy);\n                policy.setFlags(flags);\n            }\n            if (policy.getPackages().isEmpty()\n                    && policy.getFlags() == DevicePolicyManager.LOCK_TASK_FEATURE_NONE) {\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.LOCK_TASK,\n                        enforcingAdmin,\n                        caller.getUserId());\n            } else {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.LOCK_TASK,\n                        enforcingAdmin,\n                        policy,\n                        caller.getUserId());\n            }\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            synchronized (getLockObject()) {\n                enforceCanCallLockTaskLocked(caller);\n                enforceCanSetLockTaskFeaturesOnFinancedDevice(caller, flags);\n                setLockTaskFeaturesLocked(userHandle, flags);\n            }\n        }\n    }\n\n    private void setLockTaskFeaturesLocked(int userHandle, int flags) {\n        DevicePolicyData policy = getUserData(userHandle);\n        policy.mLockTaskFeatures = flags;\n        saveSettingsLocked(userHandle);\n        updateLockTaskFeaturesLocked(flags, userHandle);\n    }\n\n    @Override\n    public int getLockTaskFeatures(ComponentName who, String callerPackageName) {\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        final int userHandle = caller.getUserId();\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            synchronized (getLockObject()) {\n                enforceCanQueryLockTaskLocked(who, caller.getPackageName());\n            }\n            LockTaskPolicy policy = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.LOCK_TASK, userHandle);\n            if (policy == null) {\n                // We default on the power button menu, in order to be consistent with pre-P\n                // behaviour.\n                return DevicePolicyManager.LOCK_TASK_FEATURE_GLOBAL_ACTIONS;\n            }\n            return policy.getFlags();\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            synchronized (getLockObject()) {\n                enforceCanCallLockTaskLocked(caller);\n                return getUserData(userHandle).mLockTaskFeatures;\n            }\n        }\n    }\n\n    private void maybeClearLockTaskPolicyLocked() {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            final List<UserInfo> userInfos = mUserManager.getAliveUsers();\n            for (int i = userInfos.size() - 1; i >= 0; i--) {\n                int userId = userInfos.get(i).id;\n                if (canDPCManagedUserUseLockTaskLocked(userId)) {\n                    continue;\n                }\n\n                if (isPolicyEngineForFinanceFlagEnabled()) {\n                    Map<EnforcingAdmin, PolicyValue<LockTaskPolicy>> policies =\n                            mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                                    PolicyDefinition.LOCK_TASK, userId);\n                    Set<EnforcingAdmin> admins = new HashSet<>(policies.keySet());\n                    for (EnforcingAdmin admin : admins) {\n                        if (admin.hasAuthority(EnforcingAdmin.DPC_AUTHORITY)) {\n                            mDevicePolicyEngine.removeLocalPolicy(\n                                    PolicyDefinition.LOCK_TASK, admin, userId);\n                        }\n                    }\n                } else {\n                    final List<String> lockTaskPackages = getUserData(userId).mLockTaskPackages;\n                    // TODO(b/278438525): handle in the policy engine\n                    if (!lockTaskPackages.isEmpty()) {\n                        Slogf.d(LOG_TAG,\n                                \"User id \" + userId\n                                        + \" not affiliated. Clearing lock task packages\");\n                        setLockTaskPackagesLocked(userId, Collections.<String>emptyList());\n                    }\n                    final int lockTaskFeatures = getUserData(userId).mLockTaskFeatures;\n                    if (lockTaskFeatures != DevicePolicyManager.LOCK_TASK_FEATURE_NONE) {\n                        Slogf.d(LOG_TAG,\n                                \"User id \" + userId\n                                        + \" not affiliated. Clearing lock task features\");\n                        setLockTaskFeaturesLocked(userId,\n                                DevicePolicyManager.LOCK_TASK_FEATURE_NONE);\n                    }\n                }\n            }\n        });\n    }\n\n    private void enforceCanSetLockTaskFeaturesOnFinancedDevice(CallerIdentity caller, int flags) {\n        int allowedFlags = LOCK_TASK_FEATURE_SYSTEM_INFO | LOCK_TASK_FEATURE_KEYGUARD\n                | LOCK_TASK_FEATURE_HOME | LOCK_TASK_FEATURE_GLOBAL_ACTIONS\n                | LOCK_TASK_FEATURE_NOTIFICATIONS | LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK;\n\n        if (!isFinancedDeviceOwner(caller)) {\n            return;\n        }\n\n        if ((flags & ~(allowedFlags)) != 0) {\n            throw new SecurityException(\n                    \"Permitted lock task features when managing a financed device: \"\n                            + \"LOCK_TASK_FEATURE_SYSTEM_INFO, LOCK_TASK_FEATURE_KEYGUARD, \"\n                            + \"LOCK_TASK_FEATURE_HOME, LOCK_TASK_FEATURE_GLOBAL_ACTIONS, \"\n                            + \"LOCK_TASK_FEATURE_NOTIFICATIONS\"\n                            + \" or LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK\");\n        }\n    }\n\n    @Override\n    public void notifyLockTaskModeChanged(boolean isEnabled, String pkg, int userHandle) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"call notifyLockTaskModeChanged\"));\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(userHandle);\n\n            if (policy.mStatusBarDisabled) {\n                // Status bar is managed by LockTaskController during LockTask, so we cancel this\n                // policy when LockTask starts, and reapply it when LockTask ends\n                setStatusBarDisabledInternal(!isEnabled, userHandle);\n            }\n\n            Bundle adminExtras = new Bundle();\n            adminExtras.putString(DeviceAdminReceiver.EXTRA_LOCK_TASK_PACKAGE, pkg);\n            for (ActiveAdmin admin : policy.mAdminList) {\n                final boolean ownsDevice = isDeviceOwner(admin.info.getComponent(), userHandle);\n                final boolean ownsProfile = isProfileOwner(admin.info.getComponent(), userHandle);\n                // TODO(b/281738975): Should we be logging this for all admins?\n                if (ownsDevice || ownsProfile) {\n                    if (isEnabled) {\n                        sendAdminCommandLocked(admin, DeviceAdminReceiver.ACTION_LOCK_TASK_ENTERING,\n                                adminExtras, null);\n                    } else {\n                        sendAdminCommandLocked(admin, DeviceAdminReceiver.ACTION_LOCK_TASK_EXITING);\n                    }\n                    DevicePolicyEventLogger\n                            .createEvent(DevicePolicyEnums.SET_LOCKTASK_MODE_ENABLED)\n                            .setAdmin(admin.info == null ? null : admin.info.getPackageName())\n                            .setBoolean(isEnabled)\n                            .setStrings(pkg)\n                            .write();\n                }\n            }\n        }\n        // TODO(b/281738975): Should we be logging this for all admins?\n        for(EnforcingAdmin admin : mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                PolicyDefinition.LOCK_TASK, userHandle).keySet()) {\n            if (admin.hasAuthority(EnforcingAdmin.DPC_AUTHORITY)) {\n                // already handled above\n                continue;\n            }\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_LOCKTASK_MODE_ENABLED)\n                    .setAdmin(admin.getPackageName())\n                    .setBoolean(isEnabled)\n                    .setStrings(pkg)\n                    .write();\n        }\n    }\n\n    @Override\n    public void setGlobalSetting(ComponentName who, String setting, String value) {\n        final CallerIdentity caller = getCallerIdentity(who);\n        if (Global.ALLOW_WORK_PROFILE_TELEPHONY_FOR_NON_DPM_ROLE_HOLDERS.equals(setting)) {\n            Preconditions.checkCallAuthorization(isCallerDevicePolicyManagementRoleHolder(caller));\n            mInjector.binderWithCleanCallingIdentity(\n                    () -> mInjector.settingsGlobalPutString(setting, value));\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_GLOBAL_SETTING)\n                .setAdmin(who)\n                .setStrings(setting, value)\n                .write();\n\n        synchronized (getLockObject()) {\n            // Some settings are no supported any more. However we do not want to throw a\n            // SecurityException to avoid breaking apps.\n            if (GLOBAL_SETTINGS_DEPRECATED.contains(setting)) {\n                Slogf.i(LOG_TAG, \"Global setting no longer supported: %s\", setting);\n                return;\n            }\n\n            if (!GLOBAL_SETTINGS_ALLOWLIST.contains(setting)\n                    && !UserManager.isDeviceInDemoMode(mContext)) {\n                throw new SecurityException(String.format(\n                        \"Permission denial: device owners cannot update %1$s\", setting));\n            }\n\n            if (Settings.Global.STAY_ON_WHILE_PLUGGED_IN.equals(setting)) {\n                // ignore if it contradicts an existing policy\n                long timeMs = getMaximumTimeToLock(\n                        who, mInjector.userHandleGetCallingUserId(), /* parent */ false);\n                if (timeMs > 0 && timeMs < Long.MAX_VALUE) {\n                    return;\n                }\n            }\n\n            mInjector.binderWithCleanCallingIdentity(\n                    () -> mInjector.settingsGlobalPutString(setting, value));\n        }\n    }\n\n    @Override\n    public void setSystemSetting(ComponentName who, String setting, String value) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkStringNotEmpty(setting, \"String setting is null or empty\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_SYSTEM_SETTING);\n\n        synchronized (getLockObject()) {\n            if (!SYSTEM_SETTINGS_ALLOWLIST.contains(setting)) {\n                throw new SecurityException(String.format(\n                        \"Permission denial: device owners cannot update %1$s\", setting));\n            }\n\n            mInjector.binderWithCleanCallingIdentity(() ->\n                    mInjector.settingsSystemPutStringForUser(setting, value, caller.getUserId()));\n        }\n    }\n\n    @Override\n    public void setConfiguredNetworksLockdownState(\n            ComponentName who, String callerPackageName, boolean lockdown) {\n        if (!mHasFeature) {\n            return;\n        }\n        CallerIdentity caller;\n\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n            enforcePermission(MANAGE_DEVICE_POLICY_WIFI, caller.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            caller = getCallerIdentity(who);\n            Preconditions.checkNotNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.settingsGlobalPutInt(Global.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN,\n                        lockdown ? 1 : 0));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ALLOW_MODIFICATION_OF_ADMIN_CONFIGURED_NETWORKS)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(lockdown)\n                .write();\n    }\n\n    @Override\n    public boolean hasLockdownAdminConfiguredNetworks(ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        CallerIdentity caller = getCallerIdentity(who);\n        if (isPermissionCheckFlagEnabled()) {\n            enforcePermission(MANAGE_DEVICE_POLICY_WIFI, who.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            Preconditions.checkNotNull(who, \"ComponentName is null\");\n\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.settingsGlobalGetInt(Global.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN, 0) > 0);\n    }\n\n    @Override\n    public void setLocationEnabled(ComponentName who, boolean locationEnabled) {\n        Preconditions.checkNotNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        UserHandle userHandle = caller.getUserHandle();\n        if (mIsAutomotive && !locationEnabled) {\n            Slogf.i(LOG_TAG, \"setLocationEnabled(%s, %b): ignoring for user %s on automotive build\",\n                    who.flattenToShortString(), locationEnabled, userHandle);\n            return;\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            boolean wasLocationEnabled = mInjector.getLocationManager().isLocationEnabledForUser(\n                    userHandle);\n            Slogf.v(LOG_TAG, \"calling locationMgr.setLocationEnabledForUser(%b, %s) when it was %b\",\n                    locationEnabled, userHandle, wasLocationEnabled);\n            mInjector.getLocationManager().setLocationEnabledForUser(locationEnabled, userHandle);\n\n            // make a best effort to only show the notification if the admin is actually enabling\n            // location. this is subject to race conditions with settings changes, but those are\n            // unlikely to realistically interfere\n            if (locationEnabled && !wasLocationEnabled) {\n                showLocationSettingsEnabledNotification(userHandle);\n            }\n        });\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SECURE_SETTING)\n                .setAdmin(who)\n                .setStrings(Settings.Secure.LOCATION_MODE, Integer.toString(\n                        locationEnabled ? Settings.Secure.LOCATION_MODE_ON\n                                : Settings.Secure.LOCATION_MODE_OFF))\n                .write();\n    }\n\n    private void showLocationSettingsEnabledNotification(UserHandle user) {\n        Intent intent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS)\n                .addFlags(FLAG_ACTIVITY_NEW_TASK);\n        // Fill the component explicitly to prevent the PendingIntent from being intercepted\n        // and fired with crafted target. b/155183624\n        ActivityInfo targetInfo = intent.resolveActivityInfo(\n                mInjector.getPackageManager(user.getIdentifier()),\n                PackageManager.MATCH_SYSTEM_ONLY);\n        if (targetInfo != null) {\n            intent.setComponent(targetInfo.getComponentName());\n        } else {\n            Slogf.wtf(LOG_TAG, \"Failed to resolve intent for location settings\");\n        }\n\n        // Simple notification clicks are immutable\n        PendingIntent locationSettingsIntent = mInjector.pendingIntentGetActivityAsUser(mContext, 0,\n                intent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE, null,\n                user);\n        Notification notification = new Notification.Builder(mContext,\n                SystemNotificationChannels.DEVICE_ADMIN)\n                .setSmallIcon(R.drawable.ic_info_outline)\n                .setContentTitle(getLocationChangedTitle())\n                .setContentText(getLocationChangedText())\n                .setColor(mContext.getColor(R.color.system_notification_accent_color))\n                .setShowWhen(true)\n                .setContentIntent(locationSettingsIntent)\n                .setAutoCancel(true)\n                .build();\n        mHandler.post(() -> mInjector.getNotificationManager().notify(\n                SystemMessage.NOTE_LOCATION_CHANGED, notification));\n    }\n\n    private String getLocationChangedTitle() {\n        return getUpdatableString(\n                LOCATION_CHANGED_TITLE, R.string.location_changed_notification_title);\n    }\n\n    private String getLocationChangedText() {\n        return getUpdatableString(\n                LOCATION_CHANGED_MESSAGE, R.string.location_changed_notification_text);\n    }\n\n    @Override\n    public boolean setTime(@Nullable ComponentName who, String callerPackageName, long millis) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n            // This is a global action.\n            enforcePermission(SET_TIME, caller.getPackageName(), UserHandle.USER_ALL);\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n\n        // Don't allow set time when auto time is on.\n        if (mInjector.settingsGlobalGetInt(Global.AUTO_TIME, 0) == 1) {\n            return false;\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_TIME)\n                .setAdmin(caller.getPackageName())\n                .write();\n        mInjector.binderWithCleanCallingIdentity(() -> mInjector.getAlarmManager().setTime(millis));\n        return true;\n    }\n\n    @Override\n    public boolean setTimeZone(@Nullable ComponentName who, String callerPackageName,\n            String timeZone) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n            // This is a global action.\n            enforcePermission(SET_TIME_ZONE, caller.getPackageName(), UserHandle.USER_ALL);\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n\n        // Don't allow set timezone when auto timezone is on.\n        if (mInjector.settingsGlobalGetInt(Global.AUTO_TIME_ZONE, 0) == 1) {\n            return false;\n        }\n        String logInfo = \"DevicePolicyManager.setTimeZone()\";\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.getAlarmManagerInternal()\n                        .setTimeZone(timeZone, TIME_ZONE_CONFIDENCE_HIGH, logInfo));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_TIME_ZONE)\n                .setAdmin(caller.getPackageName())\n                .write();\n        return true;\n    }\n\n    @Override\n    public void setSecureSetting(ComponentName who, String setting, String value) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        int callingUserId = caller.getUserId();\n        synchronized (getLockObject()) {\n            if (isDeviceOwner(who, callingUserId)) {\n                if (!SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST.contains(setting)\n                        && !isCurrentUserDemo()) {\n                    throw new SecurityException(String.format(\n                            \"Permission denial: Device owners cannot update %1$s\", setting));\n                }\n            } else if (!SECURE_SETTINGS_ALLOWLIST.contains(setting) && !isCurrentUserDemo()) {\n                throw new SecurityException(String.format(\n                        \"Permission denial: Profile owners cannot update %1$s\", setting));\n            }\n            if (setting.equals(Settings.Secure.LOCATION_MODE)\n                    && isSetSecureSettingLocationModeCheckEnabled(who.getPackageName(),\n                    callingUserId)) {\n                throw new UnsupportedOperationException(Settings.Secure.LOCATION_MODE + \" is \"\n                        + \"deprecated. Please use setLocationEnabled() instead.\");\n            }\n            if (setting.equals(Settings.Secure.INSTALL_NON_MARKET_APPS)) {\n                if (getTargetSdk(who.getPackageName(), callingUserId) >= Build.VERSION_CODES.O) {\n                    throw new UnsupportedOperationException(Settings.Secure.INSTALL_NON_MARKET_APPS\n                            + \" is deprecated. Please use one of the user restrictions \"\n                            + UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES + \" or \"\n                            + UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY + \" instead.\");\n                }\n                if (!mUserManager.isManagedProfile(callingUserId)) {\n                    Slogf.e(LOG_TAG, \"Ignoring setSecureSetting request for \"\n                            + setting + \". User restriction \"\n                            + UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES + \" or \"\n                            + UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY\n                            + \" should be used instead.\");\n                } else {\n                    try {\n                        setUserRestriction(who, who.getPackageName(),\n                                UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES,\n                                (Integer.parseInt(value) == 0) ? true : false, /* parent */ false);\n                        DevicePolicyEventLogger\n                                .createEvent(DevicePolicyEnums.SET_SECURE_SETTING)\n                                .setAdmin(who)\n                                .setStrings(setting, value)\n                                .write();\n                    } catch (NumberFormatException exc) {\n                        Slogf.e(LOG_TAG, \"Invalid value: \" + value + \" for setting \" + setting);\n                    }\n                }\n                return;\n            }\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                if (Settings.Secure.DEFAULT_INPUT_METHOD.equals(setting)) {\n                    final String currentValue = mInjector.settingsSecureGetStringForUser(\n                            Settings.Secure.DEFAULT_INPUT_METHOD, callingUserId);\n                    if (!TextUtils.equals(currentValue, value)) {\n                        // Tell the content observer that the next change will be due to the owner\n                        // changing the value. There is a small race condition here that we cannot\n                        // avoid: Change notifications are sent asynchronously, so it is possible\n                        // that there are prior notifications queued up before the one we are about\n                        // to trigger. This is a corner case that will have no impact in practice.\n                        mSetupContentObserver.addPendingChangeByOwnerLocked(callingUserId);\n                    }\n                    getUserData(callingUserId).mCurrentInputMethodSet = true;\n                    saveSettingsLocked(callingUserId);\n                }\n                mInjector.settingsSecurePutStringForUser(setting, value, callingUserId);\n                // Notify the user if it's the location mode setting that's been set, to any value\n                // other than 'off'.\n                if (setting.equals(Settings.Secure.LOCATION_MODE)\n                        && (Integer.parseInt(value) != 0)) {\n                    showLocationSettingsEnabledNotification(UserHandle.of(callingUserId));\n                }\n            });\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SECURE_SETTING)\n                .setAdmin(who)\n                .setStrings(setting, value)\n                .write();\n    }\n\n    private boolean isSetSecureSettingLocationModeCheckEnabled(String packageName, int userId) {\n        return mInjector.isChangeEnabled(USE_SET_LOCATION_ENABLED, packageName, userId);\n    }\n\n    @Override\n    public void setMasterVolumeMuted(ComponentName who, boolean on) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_MASTER_VOLUME_MUTED);\n\n        synchronized (getLockObject()) {\n            setUserRestriction(who, who.getPackageName(), UserManager.DISALLOW_UNMUTE_DEVICE, on,\n                    /* parent */ false);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_MASTER_VOLUME_MUTED)\n                    .setAdmin(who)\n                    .setBoolean(on)\n                    .write();\n        }\n    }\n\n    @Override\n    public boolean isMasterVolumeMuted(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            AudioManager audioManager =\n                    (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);\n            return audioManager.isMasterMute();\n        }\n    }\n\n    @Override\n    public void setUserIcon(ComponentName who, Bitmap icon) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            mInjector.binderWithCleanCallingIdentity(\n                    () -> mUserManagerInternal.setUserIcon(caller.getUserId(), icon));\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_USER_ICON)\n                .setAdmin(who)\n                .write();\n    }\n\n    @Override\n    public boolean setKeyguardDisabled(ComponentName who, boolean disabled) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        final int userId = caller.getUserId();\n        synchronized (getLockObject()) {\n            Preconditions.checkCallAuthorization(isUserAffiliatedWithDeviceLocked(userId),\n                    String.format(\n                            \"Admin %s is neither the device owner or affiliated user's profile \"\n                                    + \"owner.\", who));\n        }\n        if (isManagedProfile(userId)) {\n            throw new SecurityException(\"Managed profile cannot disable keyguard\");\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_KEYGUARD_DISABLED);\n\n        long ident = mInjector.binderClearCallingIdentity();\n        try {\n            // disallow disabling the keyguard if a password is currently set\n            if (disabled && mLockPatternUtils.isSecure(userId)) {\n                return false;\n            }\n            mLockPatternUtils.setLockScreenDisabled(disabled, userId);\n            if (disabled) {\n                mInjector\n                        .getIWindowManager()\n                        .dismissKeyguard(null /* callback */, null /* message */);\n            }\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_KEYGUARD_DISABLED)\n                    .setAdmin(who)\n                    .setBoolean(disabled)\n                    .write();\n        } catch (RemoteException e) {\n            // Same process, does not happen.\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n        return true;\n    }\n\n    @Override\n    public boolean setStatusBarDisabled(ComponentName who, String callerPackageName,\n            boolean disabled) {\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        if (isUnicornFlagEnabled()) {\n            enforcePermission(MANAGE_DEVICE_POLICY_STATUS_BAR, caller.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        }\n\n        int userId = caller.getUserId();\n        synchronized (getLockObject()) {\n            if (!isUnicornFlagEnabled()) {\n                Preconditions.checkCallAuthorization(isUserAffiliatedWithDeviceLocked(userId),\n                        \"Admin \" + who + \" is neither the device owner or affiliated \"\n                                + \"user's profile owner.\");\n                if (isManagedProfile(userId)) {\n                    throw new SecurityException(\"Managed profile cannot disable status bar\");\n                }\n            }\n            checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_STATUS_BAR_DISABLED);\n\n            DevicePolicyData policy = getUserData(userId);\n            if (policy.mStatusBarDisabled != disabled) {\n                boolean isLockTaskMode = false;\n                try {\n                    isLockTaskMode = mInjector.getIActivityTaskManager().getLockTaskModeState()\n                            != LOCK_TASK_MODE_NONE;\n                } catch (RemoteException e) {\n                    Slogf.e(LOG_TAG, \"Failed to get LockTask mode\");\n                }\n                if (!isLockTaskMode) {\n                    if (!setStatusBarDisabledInternal(disabled, userId)) {\n                        return false;\n                    }\n                }\n                policy.mStatusBarDisabled = disabled;\n                saveSettingsLocked(userId);\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_STATUS_BAR_DISABLED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(disabled)\n                .write();\n        return true;\n    }\n\n    private boolean setStatusBarDisabledInternal(boolean disabled, int userId) {\n        long ident = mInjector.binderClearCallingIdentity();\n        try {\n            IStatusBarService statusBarService = IStatusBarService.Stub.asInterface(\n                    ServiceManager.checkService(Context.STATUS_BAR_SERVICE));\n            if (statusBarService != null) {\n                int flags1 = disabled ? STATUS_BAR_DISABLE_MASK : StatusBarManager.DISABLE_NONE;\n                int flags2 = disabled ? STATUS_BAR_DISABLE2_MASK : StatusBarManager.DISABLE2_NONE;\n                statusBarService.disableForUser(flags1, mToken, mContext.getPackageName(), userId);\n                statusBarService.disable2ForUser(flags2, mToken, mContext.getPackageName(), userId);\n                return true;\n            }\n        } catch (RemoteException e) {\n            Slogf.e(LOG_TAG, \"Failed to disable the status bar\", e);\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n        return false;\n    }\n\n    @Override\n    public boolean isStatusBarDisabled(String callerPackage) {\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        if (isUnicornFlagEnabled()) {\n            enforceCanQuery(\n                    MANAGE_DEVICE_POLICY_STATUS_BAR, caller.getPackageName(), caller.getUserId());\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        }\n\n        int userId = caller.getUserId();\n        synchronized (getLockObject()) {\n            if (!isUnicornFlagEnabled()) {\n                Preconditions.checkCallAuthorization(isUserAffiliatedWithDeviceLocked(userId),\n                        \"Admin \" + callerPackage\n                                + \" is neither the device owner or affiliated user's profile owner.\");\n                if (isManagedProfile(userId)) {\n                    throw new SecurityException(\"Managed profile cannot disable status bar\");\n                }\n            }\n            DevicePolicyData policy = getUserData(userId);\n            return policy.mStatusBarDisabled;\n        }\n    }\n\n    private Set<String> getPackagesSuspendedByAdmin(@UserIdInt int userId) {\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userId);\n            if (admin == null || admin.suspendedPackages == null) {\n                return Collections.emptySet();\n            } else {\n                return new ArraySet<>(admin.suspendedPackages);\n            }\n        }\n    }\n\n    /**\n     * We need to update the internal state of whether a user has completed setup or a\n     * device has paired once. After that, we ignore any changes that reset the\n     * Settings.Secure.USER_SETUP_COMPLETE or Settings.Secure.DEVICE_PAIRED change\n     * as we don't trust any apps that might try to reset them.\n     * <p>\n     * Unfortunately, we don't know which user's setup state was changed, so we write all of\n     * them.\n     */\n    void updateUserSetupCompleteAndPaired() {\n        List<UserInfo> users = mUserManager.getAliveUsers();\n        final int N = users.size();\n        for (int i = 0; i < N; i++) {\n            int userHandle = users.get(i).id;\n            if (mInjector.settingsSecureGetIntForUser(Settings.Secure.USER_SETUP_COMPLETE, 0,\n                    userHandle) != 0) {\n                DevicePolicyData policy = getUserData(userHandle);\n                if (!policy.mUserSetupComplete) {\n                    policy.mUserSetupComplete = true;\n                    if (userHandle == UserHandle.USER_SYSTEM) {\n                        mStateCache.setDeviceProvisioned(true);\n                    }\n                    synchronized (getLockObject()) {\n                        saveSettingsLocked(userHandle);\n                    }\n                }\n            }\n            if (mIsWatch && mInjector.settingsSecureGetIntForUser(Settings.Secure.DEVICE_PAIRED, 0,\n                    userHandle) != 0) {\n                DevicePolicyData policy = getUserData(userHandle);\n                if (!policy.mPaired) {\n                    policy.mPaired = true;\n                    synchronized (getLockObject()) {\n                        saveSettingsLocked(userHandle);\n                    }\n                }\n            }\n        }\n    }\n\n    private class SetupContentObserver extends ContentObserver {\n        private final Uri mUserSetupComplete = Settings.Secure.getUriFor(\n                Settings.Secure.USER_SETUP_COMPLETE);\n        private final Uri mDeviceProvisioned = Settings.Global.getUriFor(\n                Settings.Global.DEVICE_PROVISIONED);\n        private final Uri mPaired = Settings.Secure.getUriFor(Settings.Secure.DEVICE_PAIRED);\n        private final Uri mDefaultImeChanged = Settings.Secure.getUriFor(\n                Settings.Secure.DEFAULT_INPUT_METHOD);\n\n        @GuardedBy(\"getLockObject()\")\n        private Set<Integer> mUserIdsWithPendingChangesByOwner = new ArraySet<>();\n\n        public SetupContentObserver(Handler handler) {\n            super(handler);\n        }\n\n        void register() {\n            mInjector.registerContentObserver(mUserSetupComplete, false, this, UserHandle.USER_ALL);\n            mInjector.registerContentObserver(mDeviceProvisioned, false, this, UserHandle.USER_ALL);\n            if (mIsWatch) {\n                mInjector.registerContentObserver(mPaired, false, this, UserHandle.USER_ALL);\n            }\n            mInjector.registerContentObserver(mDefaultImeChanged, false, this, UserHandle.USER_ALL);\n        }\n\n        @GuardedBy(\"getLockObject()\")\n        private void addPendingChangeByOwnerLocked(int userId) {\n            mUserIdsWithPendingChangesByOwner.add(userId);\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri, int userId) {\n            if (mUserSetupComplete.equals(uri) || (mIsWatch && mPaired.equals(uri))) {\n                updateUserSetupCompleteAndPaired();\n            } else if (mDeviceProvisioned.equals(uri)) {\n                synchronized (getLockObject()) {\n                    // Set PROPERTY_DEVICE_OWNER_PRESENT, for the SUW case where setting the property\n                    // is delayed until device is marked as provisioned.\n                    setDeviceOwnershipSystemPropertyLocked();\n                }\n            } else if (mDefaultImeChanged.equals(uri)) {\n                synchronized (getLockObject()) {\n                    if (mUserIdsWithPendingChangesByOwner.contains(userId)) {\n                        // This change notification was triggered by the owner changing the current\n                        // IME. Ignore it.\n                        mUserIdsWithPendingChangesByOwner.remove(userId);\n                    } else {\n                        // This change notification was triggered by the user manually changing the\n                        // current IME.\n                        getUserData(userId).mCurrentInputMethodSet = false;\n                        saveSettingsLocked(userId);\n                    }\n                }\n            }\n        }\n    }\n\n    private class DevicePolicyConstantsObserver extends ContentObserver {\n        final Uri mConstantsUri =\n                Settings.Global.getUriFor(Settings.Global.DEVICE_POLICY_CONSTANTS);\n\n        DevicePolicyConstantsObserver(Handler handler) {\n            super(handler);\n        }\n\n        void register() {\n            mInjector.registerContentObserver(\n                    mConstantsUri, /* notifyForDescendents= */ false, this, UserHandle.USER_ALL);\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri, int userId) {\n            mConstants = loadConstants();\n            invalidateBinderCaches();\n\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                final Intent intent = new Intent(\n                        DevicePolicyManager.ACTION_DEVICE_POLICY_CONSTANTS_CHANGED);\n                intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n                final List<UserInfo> users = mUserManager.getAliveUsers();\n                for (int i = 0; i < users.size(); i++) {\n                    mContext.sendBroadcastAsUser(intent, UserHandle.of(users.get(i).id));\n                }\n            });\n        }\n    }\n\n    @VisibleForTesting\n    final class LocalService extends DevicePolicyManagerInternal\n            implements DevicePolicyManagerLiteInternal {\n        private List<OnCrossProfileWidgetProvidersChangeListener> mWidgetProviderListeners;\n\n        @Override\n        public List<String> getCrossProfileWidgetProviders(int profileId) {\n            synchronized (getLockObject()) {\n                if (mOwners == null) {\n                    return Collections.emptyList();\n                }\n                ComponentName ownerComponent = mOwners.getProfileOwnerComponent(profileId);\n                if (ownerComponent == null) {\n                    return Collections.emptyList();\n                }\n\n                DevicePolicyData policy = getUserDataUnchecked(profileId);\n                ActiveAdmin admin = policy.mAdminMap.get(ownerComponent);\n\n                if (admin == null || admin.crossProfileWidgetProviders == null\n                        || admin.crossProfileWidgetProviders.isEmpty()) {\n                    return Collections.emptyList();\n                }\n\n                return admin.crossProfileWidgetProviders;\n            }\n        }\n\n        @Override\n        public void addOnCrossProfileWidgetProvidersChangeListener(\n                OnCrossProfileWidgetProvidersChangeListener listener) {\n            synchronized (getLockObject()) {\n                if (mWidgetProviderListeners == null) {\n                    mWidgetProviderListeners = new ArrayList<>();\n                }\n                if (!mWidgetProviderListeners.contains(listener)) {\n                    mWidgetProviderListeners.add(listener);\n                }\n            }\n        }\n\n        @Override\n        public @Nullable ComponentName getProfileOwnerOrDeviceOwnerSupervisionComponent(\n                @NonNull UserHandle userHandle) {\n            return DevicePolicyManagerService.this.getProfileOwnerOrDeviceOwnerSupervisionComponent(\n                    userHandle);\n        }\n\n        @Override\n        public boolean isActiveDeviceOwner(int uid) {\n            return isDefaultDeviceOwner(new CallerIdentity(uid, null, null));\n        }\n\n        @Override\n        public boolean isActiveProfileOwner(int uid) {\n            return isProfileOwner(new CallerIdentity(uid, null, null));\n        }\n\n        @Override\n        public boolean isActiveSupervisionApp(int uid) {\n            if (!isProfileOwner(new CallerIdentity(uid, null, null))) {\n                return false;\n            }\n            synchronized (getLockObject()) {\n                final ActiveAdmin admin = getProfileOwnerAdminLocked(UserHandle.getUserId(uid));\n                if (admin == null) {\n                    return false;\n                }\n\n                return isSupervisionComponentLocked(admin.info.getComponent());\n            }\n        }\n\n        private void notifyCrossProfileProvidersChanged(int userId, List<String> packages) {\n            final List<OnCrossProfileWidgetProvidersChangeListener> listeners;\n            synchronized (getLockObject()) {\n                listeners = new ArrayList<>(mWidgetProviderListeners);\n            }\n            final int listenerCount = listeners.size();\n            for (int i = 0; i < listenerCount; i++) {\n                OnCrossProfileWidgetProvidersChangeListener listener = listeners.get(i);\n                listener.onCrossProfileWidgetProvidersChanged(userId, packages);\n            }\n        }\n\n        @Override\n        public Intent createShowAdminSupportIntent(int userId, boolean useDefaultIfNoAdmin) {\n            // This method is called from AM with its lock held, so don't take the DPMS lock.\n            // b/29242568\n\n            if (getEnforcingAdminAndUserDetailsInternal(userId, null) != null\n                    || useDefaultIfNoAdmin) {\n                return DevicePolicyManagerService.this.createShowAdminSupportIntent(userId);\n            }\n            return null;\n        }\n\n        @Override\n        public Intent createUserRestrictionSupportIntent(int userId, String userRestriction) {\n            Intent intent = null;\n            if (getEnforcingAdminAndUserDetailsInternal(userId, userRestriction) != null) {\n                intent = DevicePolicyManagerService.this.createShowAdminSupportIntent(userId);\n                intent.putExtra(DevicePolicyManager.EXTRA_RESTRICTION, userRestriction);\n            }\n            return intent;\n        }\n\n        @Override\n        public boolean isUserAffiliatedWithDevice(int userId) {\n            return DevicePolicyManagerService.this.isUserAffiliatedWithDeviceLocked(userId);\n        }\n\n        @Override\n        public boolean canSilentlyInstallPackage(String callerPackage, int callerUid) {\n            if (callerPackage == null) {\n                return false;\n            }\n\n            CallerIdentity caller = new CallerIdentity(callerUid, null, null);\n            if (isUserAffiliatedWithDevice(UserHandle.getUserId(callerUid))\n                    && (isActiveProfileOwner(callerUid)\n                    || isDefaultDeviceOwner(caller) || isFinancedDeviceOwner(caller))) {\n                // device owner or a profile owner affiliated with the device owner\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void reportSeparateProfileChallengeChanged(@UserIdInt int userId) {\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                synchronized (getLockObject()) {\n                    updateMaximumTimeToLockLocked(userId);\n                    updatePasswordQualityCacheForUserGroup(userId);\n                }\n            });\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SEPARATE_PROFILE_CHALLENGE_CHANGED)\n                    .setBoolean(isSeparateProfileChallengeEnabled(userId))\n                    .write();\n            invalidateBinderCaches();\n        }\n\n        @Override\n        public CharSequence getPrintingDisabledReasonForUser(@UserIdInt int userId) {\n            synchronized (getLockObject()) {\n                if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_PRINTING,\n                        UserHandle.of(userId))) {\n                    Slogf.e(LOG_TAG, \"printing is enabled for user %d\", userId);\n                    return null;\n                }\n                String ownerPackage = mOwners.getProfileOwnerPackage(userId);\n                if (ownerPackage == null) {\n                    ownerPackage = mOwners.getDeviceOwnerPackageName();\n                }\n                final String packageName = ownerPackage;\n                PackageManager pm = mInjector.getPackageManager();\n                PackageInfo packageInfo = mInjector.binderWithCleanCallingIdentity(() -> {\n                    try {\n                        return pm.getPackageInfo(packageName, 0);\n                    } catch (NameNotFoundException e) {\n                        Slogf.e(LOG_TAG, \"getPackageInfo error\", e);\n                        return null;\n                    }\n                });\n                if (packageInfo == null) {\n                    Slogf.e(LOG_TAG, \"packageInfo is inexplicably null\");\n                    return null;\n                }\n                ApplicationInfo appInfo = packageInfo.applicationInfo;\n                if (appInfo == null) {\n                    Slogf.e(LOG_TAG, \"appInfo is inexplicably null\");\n                    return null;\n                }\n                CharSequence appLabel = pm.getApplicationLabel(appInfo);\n                if (appLabel == null) {\n                    Slogf.e(LOG_TAG, \"appLabel is inexplicably null\");\n                    return null;\n                }\n                return getUpdatableString(\n                        PRINTING_DISABLED_NAMED_ADMIN,\n                        R.string.printing_disabled_by,\n                        appLabel);\n            }\n        }\n\n        @Override\n        protected DevicePolicyCache getDevicePolicyCache() {\n            return mPolicyCache;\n        }\n\n        @Override\n        protected DeviceStateCache getDeviceStateCache() {\n            return mStateCache;\n        }\n\n        @Override\n        public List<String> getAllCrossProfilePackages(int userId) {\n            return DevicePolicyManagerService.this.getAllCrossProfilePackages(userId);\n        }\n\n        @Override\n        public List<String> getDefaultCrossProfilePackages() {\n            return DevicePolicyManagerService.this.getDefaultCrossProfilePackages();\n        }\n\n        @Override\n        public void broadcastIntentToManifestReceivers(\n                Intent intent, UserHandle parentHandle, boolean requiresPermission) {\n            Objects.requireNonNull(intent);\n            Objects.requireNonNull(parentHandle);\n            Slogf.i(LOG_TAG, \"Sending %s broadcast to manifest receivers.\", intent.getAction());\n            broadcastIntentToCrossProfileManifestReceivers(\n                    intent, parentHandle, requiresPermission);\n            broadcastExplicitIntentToRoleHolder(\n                    intent, RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT, parentHandle);\n        }\n\n        @Override\n        public void enforcePermission(String callerPackage, String permission, int targetUserId) {\n            DevicePolicyManagerService.this.enforcePermission(permission, callerPackage,\n                    targetUserId);\n        }\n\n        @Override\n        public boolean hasPermission(String callerPackage, String permission, int targetUserId) {\n            return DevicePolicyManagerService.this.hasPermission(permission, callerPackage,\n                    targetUserId);\n        }\n\n        private void broadcastIntentToCrossProfileManifestReceivers(\n                Intent intent, UserHandle userHandle, boolean requiresPermission) {\n            final int userId = userHandle.getIdentifier();\n            try {\n                final List<ResolveInfo> receivers = mIPackageManager.queryIntentReceivers(\n                        intent, /* resolvedType= */ null,\n                        STOCK_PM_FLAGS, userId).getList();\n                for (ResolveInfo receiver : receivers) {\n                    final String packageName = receiver.getComponentInfo().packageName;\n                    if (checkCrossProfilePackagePermissions(packageName, userId,\n                            requiresPermission)\n                            || checkModifyQuietModePermission(packageName, userId)) {\n                        Slogf.i(LOG_TAG, \"Sending %s broadcast to %s.\", intent.getAction(),\n                                packageName);\n                        final Intent packageIntent = new Intent(intent)\n                                .setComponent(receiver.getComponentInfo().getComponentName())\n                                .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n                        mContext.sendBroadcastAsUser(packageIntent, userHandle);\n                    }\n                }\n            } catch (RemoteException ex) {\n                Slogf.w(LOG_TAG, \"Cannot get list of broadcast receivers for %s because: %s.\",\n                        intent.getAction(), ex);\n            }\n        }\n\n        /**\n         * Checks whether the package {@code packageName} has the {@code MODIFY_QUIET_MODE}\n         * permission granted for the user {@code userId}.\n         */\n        private boolean checkModifyQuietModePermission(String packageName, @UserIdInt int userId) {\n            try {\n                final int uid = Objects.requireNonNull(\n                        mInjector.getPackageManager().getApplicationInfoAsUser(\n                                Objects.requireNonNull(packageName), /* flags= */ 0, userId)).uid;\n                return PackageManager.PERMISSION_GRANTED\n                        == ActivityManager.checkComponentPermission(\n                        android.Manifest.permission.MODIFY_QUIET_MODE, uid, /* owningUid= */\n                        -1, /* exported= */ true);\n            } catch (NameNotFoundException ex) {\n                Slogf.w(LOG_TAG, \"Cannot find the package %s to check for permissions.\",\n                        packageName);\n                return false;\n            }\n        }\n\n        /**\n         * Checks whether the package {@code packageName} has the required permissions to receive\n         * cross-profile broadcasts on behalf of the user {@code userId}.\n         */\n        private boolean checkCrossProfilePackagePermissions(String packageName,\n                @UserIdInt int userId, boolean requiresPermission) {\n            final PackageManagerInternal pmInternal = LocalServices.getService(\n                    PackageManagerInternal.class);\n            final AndroidPackage androidPackage = pmInternal.getPackage(packageName);\n            if (androidPackage == null || !androidPackage.isCrossProfile()) {\n                return false;\n            }\n            if (!requiresPermission) {\n                return true;\n            }\n            if (!isPackageEnabled(packageName, userId)) {\n                return false;\n            }\n            try {\n                final CrossProfileAppsInternal crossProfileAppsService = LocalServices.getService(\n                        CrossProfileAppsInternal.class);\n                return crossProfileAppsService.verifyPackageHasInteractAcrossProfilePermission(\n                        packageName, userId);\n            } catch (NameNotFoundException ex) {\n                Slogf.w(LOG_TAG, \"Cannot find the package %s to check for permissions.\",\n                        packageName);\n                return false;\n            }\n        }\n\n        private boolean isPackageEnabled(String packageName, @UserIdInt int userId) {\n            final int callingUid = Binder.getCallingUid();\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                final PackageInfo info = mInjector.getPackageManagerInternal()\n                        .getPackageInfo(\n                                packageName,\n                                MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE,\n                                callingUid,\n                                userId);\n                return info != null && info.applicationInfo.enabled;\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n\n        @Override\n        public ComponentName getProfileOwnerAsUser(@UserIdInt int userId) {\n            return DevicePolicyManagerService.this.getProfileOwnerAsUser(userId);\n        }\n\n        @Override\n        public int getDeviceOwnerUserId() {\n            return DevicePolicyManagerService.this.getDeviceOwnerUserId();\n        }\n\n        @Override\n        public boolean isDeviceOrProfileOwnerInCallingUser(String packageName) {\n            return isDeviceOwnerInCallingUser(packageName)\n                    || isProfileOwnerInCallingUser(packageName);\n        }\n\n        private boolean isDeviceOwnerInCallingUser(String packageName) {\n            final ComponentName deviceOwnerInCallingUser =\n                    DevicePolicyManagerService.this.getDeviceOwnerComponent(\n                            /* callingUserOnly= */ true);\n            return deviceOwnerInCallingUser != null\n                    && packageName.equals(deviceOwnerInCallingUser.getPackageName());\n        }\n\n        private boolean isProfileOwnerInCallingUser(String packageName) {\n            final ComponentName profileOwnerInCallingUser =\n                    getProfileOwnerAsUser(UserHandle.getCallingUserId());\n            return profileOwnerInCallingUser != null\n                    && packageName.equals(profileOwnerInCallingUser.getPackageName());\n        }\n\n        @Override\n        public boolean supportsResetOp(int op) {\n            return op == AppOpsManager.OP_INTERACT_ACROSS_PROFILES\n                    && LocalServices.getService(CrossProfileAppsInternal.class) != null;\n        }\n\n        @Override\n        public void resetOp(int op, String packageName, @UserIdInt int userId) {\n            if (op != AppOpsManager.OP_INTERACT_ACROSS_PROFILES) {\n                throw new IllegalArgumentException(\"Unsupported op for DPM reset: \" + op);\n            }\n            LocalServices.getService(CrossProfileAppsInternal.class)\n                    .setInteractAcrossProfilesAppOp(\n                            packageName, findInteractAcrossProfilesResetMode(packageName), userId);\n        }\n\n        @Override\n        public Set<String> getPackagesSuspendedByAdmin(@UserIdInt int userId) {\n            return DevicePolicyManagerService.this.getPackagesSuspendedByAdmin(userId);\n        }\n\n        @Override\n        public void notifyUnsafeOperationStateChanged(DevicePolicySafetyChecker checker, int reason,\n                boolean isSafe) {\n            // TODO(b/178494483): use EventLog instead\n            // TODO(b/178494483): log metrics?\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"notifyUnsafeOperationStateChanged(): %s=%b\",\n                        DevicePolicyManager.operationSafetyReasonToString(reason), isSafe);\n            }\n            Preconditions.checkArgument(mSafetyChecker == checker,\n                    \"invalid checker: should be %s, was %s\", mSafetyChecker, checker);\n\n            Bundle extras = new Bundle();\n            extras.putInt(DeviceAdminReceiver.EXTRA_OPERATION_SAFETY_REASON, reason);\n            extras.putBoolean(DeviceAdminReceiver.EXTRA_OPERATION_SAFETY_STATE, isSafe);\n\n            if (mOwners.hasDeviceOwner()) {\n                if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"Notifying DO\");\n                sendDeviceOwnerCommand(DeviceAdminReceiver.ACTION_OPERATION_SAFETY_STATE_CHANGED,\n                        extras);\n            }\n            for (int profileOwnerId : mOwners.getProfileOwnerKeys()) {\n                if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"Notifying PO for user \" + profileOwnerId);\n                sendProfileOwnerCommand(DeviceAdminReceiver.ACTION_OPERATION_SAFETY_STATE_CHANGED,\n                        extras, profileOwnerId);\n            }\n        }\n\n        @Override\n        public boolean isKeepProfilesRunningEnabled() {\n            return getUserDataUnchecked(UserHandle.USER_SYSTEM).mEffectiveKeepProfilesRunning;\n        }\n\n        private @Mode int findInteractAcrossProfilesResetMode(String packageName) {\n            return getDefaultCrossProfilePackages().contains(packageName)\n                    ? AppOpsManager.MODE_ALLOWED\n                    : AppOpsManager.opToDefaultMode(AppOpsManager.OP_INTERACT_ACROSS_PROFILES);\n        }\n\n        @Override\n        public boolean isUserOrganizationManaged(@UserIdInt int userHandle) {\n            return getDeviceStateCache().isUserOrganizationManaged(userHandle);\n        }\n\n        @Override\n        public boolean isApplicationExemptionsFlagEnabled() {\n            return DeviceConfig.getBoolean(\n                    NAMESPACE_DEVICE_POLICY_MANAGER,\n                    APPLICATION_EXEMPTIONS_FLAG,\n                    DEFAULT_APPLICATION_EXEMPTIONS_FLAG);\n        }\n\n        @Override\n        public List<Bundle> getApplicationRestrictionsPerAdminForUser(\n                String packageName, @UserIdInt int userId) {\n            if (UserHandle.getCallingUserId() != userId\n                    || !UserHandle.isSameApp(\n                    Binder.getCallingUid(), getUidForPackage(packageName, userId))) {\n                final int uid = Binder.getCallingUid();\n                if (!UserHandle.isSameApp(uid, Process.SYSTEM_UID) && uid != Process.ROOT_UID) {\n                    throw new SecurityException(\"Only system may: get application restrictions for \"\n                            + \"other user/app \" + packageName);\n                }\n            }\n            LinkedHashMap<EnforcingAdmin, PolicyValue<Bundle>> policies =\n                    mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                            PolicyDefinition.APPLICATION_RESTRICTIONS(packageName),\n                            userId);\n            List<Bundle> restrictions = new ArrayList<>();\n            for (EnforcingAdmin admin : policies.keySet()) {\n                restrictions.add(policies.get(admin).getValue());\n            }\n            if (!restrictions.isEmpty()) {\n                return restrictions;\n            }\n\n            return mInjector.binderWithCleanCallingIdentity(() -> {\n                // Could be a device that has a DPC that hasn't migrated yet, so just return any\n                // restrictions saved in userManager.\n                Bundle bundle = mUserManager.getApplicationRestrictions(\n                        packageName, UserHandle.of(userId));\n                if (bundle == null || bundle.isEmpty()) {\n                    return new ArrayList<>();\n                }\n                return List.of(bundle);\n            });\n        }\n\n        public List<EnforcingUser> getUserRestrictionSources(String restriction,\n                @UserIdInt int userId) {\n            PolicyDefinition<Boolean> policy =\n                    PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction);\n\n            Set<EnforcingAdmin> localAdmins =\n                    mDevicePolicyEngine.getLocalPoliciesSetByAdmins(policy, userId).keySet();\n\n            Set<EnforcingAdmin> globalAdmins =\n                    mDevicePolicyEngine.getGlobalPoliciesSetByAdmins(policy).keySet();\n\n            List<EnforcingUser> enforcingUsers = new ArrayList();\n            enforcingUsers.addAll(getEnforcingUsers(localAdmins));\n            enforcingUsers.addAll(getEnforcingUsers(globalAdmins));\n            return enforcingUsers;\n        }\n\n        private List<EnforcingUser> getEnforcingUsers(Set<EnforcingAdmin> admins) {\n            List<EnforcingUser> enforcingUsers = new ArrayList();\n            ComponentName deviceOwner = mOwners.getDeviceOwnerComponent();\n            for (EnforcingAdmin admin : admins) {\n                if (deviceOwner != null\n                        && deviceOwner.getPackageName().equals(admin.getPackageName())) {\n                    enforcingUsers.add(new EnforcingUser(admin.getUserId(),\n                            UserManager.RESTRICTION_SOURCE_DEVICE_OWNER));\n                } else {\n                    enforcingUsers.add(new EnforcingUser(admin.getUserId(),\n                            UserManager.RESTRICTION_SOURCE_PROFILE_OWNER));\n                }\n            }\n            return enforcingUsers;\n        }\n    }\n\n    private Intent createShowAdminSupportIntent(int userId) {\n        // This method is called with AMS lock held, so don't take DPMS lock\n        final Intent intent = new Intent(Settings.ACTION_SHOW_ADMIN_SUPPORT_DETAILS);\n        intent.putExtra(Intent.EXTRA_USER_ID, userId);\n        intent.setFlags(FLAG_ACTIVITY_NEW_TASK);\n        return intent;\n    }\n\n    /**\n     * @param restriction The restriction enforced by admin. It could be any user restriction or\n     *                    policy like {@link DevicePolicyManager#POLICY_DISABLE_CAMERA},\n     *                    {@link DevicePolicyManager#POLICY_DISABLE_SCREEN_CAPTURE} and  {@link\n     *                    DevicePolicyManager#POLICY_SUSPEND_PACKAGES}.\n     */\n    private Bundle getEnforcingAdminAndUserDetailsInternal(int userId, String restriction) {\n        Bundle result = null;\n\n        // For POLICY_SUSPEND_PACKAGES return PO or DO to keep the behavior same as\n        // before the bug fix for b/192245204.\n        if (restriction == null || DevicePolicyManager.POLICY_SUSPEND_PACKAGES.equals(\n                restriction)) {\n            ComponentName profileOwner = mOwners.getProfileOwnerComponent(userId);\n            if (profileOwner != null) {\n                result = new Bundle();\n                result.putInt(Intent.EXTRA_USER_ID, userId);\n                result.putParcelable(DevicePolicyManager.EXTRA_DEVICE_ADMIN,\n                        profileOwner);\n                return result;\n            }\n            final Pair<Integer, ComponentName> deviceOwner =\n                    mOwners.getDeviceOwnerUserIdAndComponent();\n            if (deviceOwner != null && deviceOwner.first == userId) {\n                result = new Bundle();\n                result.putInt(Intent.EXTRA_USER_ID, userId);\n                result.putParcelable(DevicePolicyManager.EXTRA_DEVICE_ADMIN,\n                        deviceOwner.second);\n                return result;\n            }\n        } else if (DevicePolicyManager.POLICY_DISABLE_SCREEN_CAPTURE.equals(restriction)) {\n            if (isPolicyEngineForFinanceFlagEnabled()) {\n                Boolean value = mDevicePolicyEngine.getResolvedPolicy(\n                        PolicyDefinition.SCREEN_CAPTURE_DISABLED, userId);\n                if (value != null && value) {\n                    result = new Bundle();\n                    result.putInt(Intent.EXTRA_USER_ID, userId);\n                    return result;\n                }\n            } else {\n                synchronized (getLockObject()) {\n                    final DevicePolicyData policy = getUserData(userId);\n                    final int N = policy.mAdminList.size();\n                    for (int i = 0; i < N; i++) {\n                        final ActiveAdmin admin = policy.mAdminList.get(i);\n                        if (admin.disableScreenCapture) {\n                            result = new Bundle();\n                            result.putInt(Intent.EXTRA_USER_ID, userId);\n                            result.putParcelable(DevicePolicyManager.EXTRA_DEVICE_ADMIN,\n                                    admin.info.getComponent());\n                            return result;\n                        }\n                    }\n                }\n            }\n        } else if (DevicePolicyManager.POLICY_DISABLE_CAMERA.equals(restriction)) {\n            if (isPolicyEngineForFinanceFlagEnabled()) {\n                PolicyDefinition<Boolean> policyDefinition =\n                        PolicyDefinition.getPolicyDefinitionForUserRestriction(\n                                UserManager.DISALLOW_CAMERA);\n                Boolean value = mDevicePolicyEngine.getResolvedPolicy(policyDefinition, userId);\n                if (value != null && value) {\n                    result = new Bundle();\n                    result.putInt(Intent.EXTRA_USER_ID, userId);\n                    return result;\n                }\n            } else {\n                synchronized (getLockObject()) {\n                    final DevicePolicyData policy = getUserData(userId);\n                    final int N = policy.mAdminList.size();\n                    for (int i = 0; i < N; i++) {\n                        final ActiveAdmin admin = policy.mAdminList.get(i);\n                        if (admin.disableCamera) {\n                            result = new Bundle();\n                            result.putInt(Intent.EXTRA_USER_ID, userId);\n                            result.putParcelable(DevicePolicyManager.EXTRA_DEVICE_ADMIN,\n                                    admin.info.getComponent());\n                            return result;\n                        }\n                    }\n                    // For the camera, a device owner on a different user can disable it globally,\n                    // so we need an additional check.\n                    if (result == null\n                            && DevicePolicyManager.POLICY_DISABLE_CAMERA.equals(restriction)) {\n                        final ActiveAdmin admin = getDeviceOwnerAdminLocked();\n                        if (admin != null && admin.disableCamera) {\n                            result = new Bundle();\n                            result.putInt(Intent.EXTRA_USER_ID, mOwners.getDeviceOwnerUserId());\n                            result.putParcelable(DevicePolicyManager.EXTRA_DEVICE_ADMIN,\n                                    admin.info.getComponent());\n                            return result;\n                        }\n                    }\n                }\n            }\n        } else {\n            long ident = mInjector.binderClearCallingIdentity();\n            try {\n                // TODO(b/277908283): check in the policy engine instead of calling user manager.\n                List<UserManager.EnforcingUser> sources = mUserManager\n                        .getUserRestrictionSources(restriction, UserHandle.of(userId));\n                if (sources == null) {\n                    // The restriction is not enforced.\n                    return null;\n                }\n                int sizeBefore = sources.size();\n                if (sizeBefore > 1) {\n                    Slogf.d(LOG_TAG, \"getEnforcingAdminAndUserDetailsInternal(%d, %s): \"\n                            + \"%d sources found, excluding those set by UserManager\",\n                            userId, restriction, sizeBefore);\n                    sources = getDevicePolicySources(sources);\n                }\n                if (sources.isEmpty()) {\n                    // The restriction is not enforced (or is just enforced by the system)\n                    return null;\n                }\n\n                if (sources.size() > 1) {\n                    // In this case, we'll show an admin support dialog that does not\n                    // specify the admin.\n                    // TODO(b/128928355): if this restriction is enforced by multiple DPCs, return\n                    // the admin for the calling user.\n                    Slogf.w(LOG_TAG, \"getEnforcingAdminAndUserDetailsInternal(%d, %s): multiple \"\n                            + \"sources for restriction %s on user %d\",\n                            userId, restriction, restriction, userId);\n                    result = new Bundle();\n                    result.putInt(Intent.EXTRA_USER_ID, userId);\n                    return result;\n                }\n                final UserManager.EnforcingUser enforcingUser = sources.get(0);\n                final int sourceType = enforcingUser.getUserRestrictionSource();\n                if (sourceType == UserManager.RESTRICTION_SOURCE_PROFILE_OWNER\n                        || sourceType == UserManager.RESTRICTION_SOURCE_DEVICE_OWNER) {\n                    ActiveAdmin admin = getMostProbableDPCAdminForLocalPolicy(userId);\n                    if (admin != null) {\n                        result = new Bundle();\n                        result.putInt(Intent.EXTRA_USER_ID, admin.getUserHandle().getIdentifier());\n                        result.putParcelable(DevicePolicyManager.EXTRA_DEVICE_ADMIN,\n                                admin.info.getComponent());\n                        return result;\n                    }\n                } else if (sourceType == UserManager.RESTRICTION_SOURCE_SYSTEM) {\n                    /*\n                     * In this case, the user restriction is enforced by the system.\n                     * So we won't show an admin support intent, even if it is also\n                     * enforced by a profile/device owner.\n                     */\n                    return null;\n                }\n            } finally {\n                mInjector.binderRestoreCallingIdentity(ident);\n            }\n        }\n        return null;\n    }\n\n    /**\n     *  Excludes restrictions imposed by UserManager.\n     */\n    private List<UserManager.EnforcingUser> getDevicePolicySources(\n            List<UserManager.EnforcingUser> sources) {\n        int sizeBefore = sources.size();\n        List<UserManager.EnforcingUser> realSources = new ArrayList<>(sizeBefore);\n        for (int i = 0; i < sizeBefore; i++) {\n            UserManager.EnforcingUser source = sources.get(i);\n            int type = source.getUserRestrictionSource();\n            if (type != UserManager.RESTRICTION_SOURCE_PROFILE_OWNER\n                    && type != UserManager.RESTRICTION_SOURCE_DEVICE_OWNER) {\n                // TODO(b/128928355): add unit test\n                Slogf.d(LOG_TAG, \"excluding source of type %s at index %d\",\n                        userRestrictionSourceToString(type), i);\n                continue;\n            }\n            realSources.add(source);\n        }\n        return realSources;\n    }\n\n    private static String userRestrictionSourceToString(@UserRestrictionSource int source) {\n        return DebugUtils.flagsToString(UserManager.class, \"RESTRICTION_\", source);\n    }\n\n    /**\n     * @param restriction The restriction enforced by admin. It could be any user restriction or\n     *                    policy like {@link DevicePolicyManager#POLICY_DISABLE_CAMERA} and\n     *                    {@link DevicePolicyManager#POLICY_DISABLE_SCREEN_CAPTURE}.\n     * @return Details of admin and user which enforced the restriction for the userId.\n     */\n    @Override\n    public Bundle getEnforcingAdminAndUserDetails(int userId, String restriction) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()));\n        return getEnforcingAdminAndUserDetailsInternal(userId, restriction);\n    }\n\n    /**\n     * @param restriction The restriction enforced by admin. It could be any user restriction or\n     *                    policy like {@link DevicePolicyManager#POLICY_DISABLE_CAMERA} and\n     *                    {@link DevicePolicyManager#POLICY_DISABLE_SCREEN_CAPTURE}.\n     */\n    @Override\n    public Intent createAdminSupportIntent(String restriction) {\n        Objects.requireNonNull(restriction);\n        final CallerIdentity caller = getCallerIdentity();\n        final int userId = caller.getUserId();\n        Intent intent = null;\n        if (getEnforcingAdminAndUserDetailsInternal(userId, restriction) != null) {\n            intent = createShowAdminSupportIntent(userId);\n            intent.putExtra(DevicePolicyManager.EXTRA_RESTRICTION, restriction);\n        }\n        return intent;\n    }\n\n    /**\n     * Returns true if specified admin is allowed to limit passwords and has a\n     * {@code mPasswordPolicy.quality} of at least {@code minPasswordQuality}\n     */\n    private static boolean isLimitPasswordAllowed(ActiveAdmin admin, int minPasswordQuality) {\n        if (admin.mPasswordPolicy.quality < minPasswordQuality) {\n            return false;\n        }\n        return admin.isPermissionBased || admin.info.usesPolicy(DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD);\n    }\n\n    @Override\n    public void setCredentialManagerPolicy(PackagePolicy policy) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canWriteCredentialManagerPolicy(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (Objects.equals(admin.mCredentialManagerPolicy, policy)) {\n                return;\n            }\n\n            admin.mCredentialManagerPolicy = policy;\n            saveSettingsLocked(caller.getUserId());\n        }\n    }\n\n    private boolean canWriteCredentialManagerPolicy(CallerIdentity caller) {\n        return (isProfileOwner(caller) && isManagedProfile(caller.getUserId()))\n                        || isDefaultDeviceOwner(caller)\n                        || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS);\n    }\n\n    @Override\n    public PackagePolicy getCredentialManagerPolicy(int userId) {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                canWriteCredentialManagerPolicy(caller) || canQueryAdminPolicy(caller));\n        if (userId != caller.getUserId()) {\n            Preconditions.checkCallAuthorization(\n                    hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n        }\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(userId);\n            return (admin != null) ? admin.mCredentialManagerPolicy : null;\n        }\n    }\n\n    @Override\n    public void setSystemUpdatePolicy(\n            ComponentName who, String callerPackageName, SystemUpdatePolicy policy) {\n        if (policy != null) {\n            // throws exception if policy type is invalid\n            policy.validateType();\n            // throws exception if freeze period is invalid\n            policy.validateFreezePeriods();\n            Pair<LocalDate, LocalDate> record = mOwners.getSystemUpdateFreezePeriodRecord();\n            // throws exception if freeze period is incompatible with previous freeze period record\n            policy.validateAgainstPreviousFreezePeriod(record.first, record.second,\n                    LocalDate.now());\n        }\n        CallerIdentity caller;\n\n        synchronized (getLockObject()) {\n            if (isPermissionCheckFlagEnabled()) {\n                caller = getCallerIdentity(who, callerPackageName);\n                enforcePermission(MANAGE_DEVICE_POLICY_SYSTEM_UPDATES, caller.getPackageName(),\n                        UserHandle.USER_ALL);\n            } else {\n                caller = getCallerIdentity(who);\n                Preconditions.checkCallAuthorization(\n                        isProfileOwnerOfOrganizationOwnedDevice(caller)\n                        || isDefaultDeviceOwner(caller));\n            }\n\n            checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_SYSTEM_UPDATE_POLICY);\n\n            if (policy == null) {\n                mOwners.clearSystemUpdatePolicy();\n            } else {\n                mOwners.setSystemUpdatePolicy(policy);\n                updateSystemUpdateFreezePeriodsRecord(/* saveIfChanged */ false);\n            }\n            mOwners.writeDeviceOwner();\n        }\n        mInjector.binderWithCleanCallingIdentity(() -> mContext.sendBroadcastAsUser(\n                new Intent(ACTION_SYSTEM_UPDATE_POLICY_CHANGED), UserHandle.SYSTEM));\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SYSTEM_UPDATE_POLICY)\n                .setAdmin(caller.getPackageName())\n                .setInt(policy != null ? policy.getPolicyType() : 0)\n                .write();\n    }\n\n    @Override\n    public SystemUpdatePolicy getSystemUpdatePolicy() {\n        synchronized (getLockObject()) {\n            SystemUpdatePolicy policy =  mOwners.getSystemUpdatePolicy();\n            if (policy != null && !policy.isValid()) {\n                Slogf.w(LOG_TAG, \"Stored system update policy is invalid, return null instead.\");\n                return null;\n            }\n            return policy;\n        }\n    }\n\n    private static boolean withinRange(Pair<LocalDate, LocalDate> range, LocalDate date) {\n        return (!date.isBefore(range.first) && !date.isAfter(range.second));\n    }\n\n    /**\n     * keeps track of the last continuous period when the system is under OTA freeze.\n     *\n     * DPMS keeps track of the previous dates during which OTA was freezed as a result of an\n     * system update policy with freeze periods in effect. This is needed to make robust\n     * validation on new system update polices, for example to prevent the OTA from being\n     * frozen for more than 90 days if the DPC keeps resetting a new 24-hour freeze period\n     * on midnight everyday, or having freeze periods closer than 60 days apart by DPC resetting\n     * a new freeze period after a few days.\n     *\n     * @param saveIfChanged whether to persist the result on disk if freeze period record is\n     *            updated. This should only be set to {@code false} if there is a guaranteed\n     *            mOwners.writeDeviceOwner() later in the control flow to reduce the number of\n     *            disk writes. Otherwise you risk inconsistent on-disk state.\n     *\n     * @see SystemUpdatePolicy#validateAgainstPreviousFreezePeriod\n     */\n    private void updateSystemUpdateFreezePeriodsRecord(boolean saveIfChanged) {\n        Slogf.d(LOG_TAG, \"updateSystemUpdateFreezePeriodsRecord\");\n        synchronized (getLockObject()) {\n            final SystemUpdatePolicy policy = mOwners.getSystemUpdatePolicy();\n            if (policy == null) {\n                return;\n            }\n            final LocalDate now = LocalDate.now();\n            final Pair<LocalDate, LocalDate> currentPeriod = policy.getCurrentFreezePeriod(now);\n            if (currentPeriod == null) {\n                return;\n            }\n            final Pair<LocalDate, LocalDate> record = mOwners.getSystemUpdateFreezePeriodRecord();\n            final LocalDate start = record.first;\n            final LocalDate end = record.second;\n            final boolean changed;\n            if (end == null || start == null) {\n                // Start a new period if there is none at the moment\n                changed = mOwners.setSystemUpdateFreezePeriodRecord(now, now);\n            } else if (now.equals(end.plusDays(1))) {\n                // Extend the existing period\n                changed = mOwners.setSystemUpdateFreezePeriodRecord(start, now);\n            } else if (now.isAfter(end.plusDays(1))) {\n                if (withinRange(currentPeriod, start) && withinRange(currentPeriod, end)) {\n                    // The device might be off for some period. If the past freeze record\n                    // is within range of the current freeze period, assume the device was off\n                    // during the period [end, now] and extend the freeze record to [start, now].\n                    changed = mOwners.setSystemUpdateFreezePeriodRecord(start, now);\n                } else {\n                    changed = mOwners.setSystemUpdateFreezePeriodRecord(now, now);\n                }\n            } else if (now.isBefore(start)) {\n                // Systm clock was adjusted backwards, restart record\n                changed = mOwners.setSystemUpdateFreezePeriodRecord(now, now);\n            } else /* start <= now <= end */ {\n                changed = false;\n            }\n            if (changed && saveIfChanged) {\n                mOwners.writeDeviceOwner();\n            }\n        }\n    }\n\n    @Override\n    public void clearSystemUpdatePolicyFreezePeriodRecord() {\n        Preconditions.checkCallAuthorization(isAdb(getCallerIdentity())\n                        || hasCallingOrSelfPermission(permission.CLEAR_FREEZE_PERIOD),\n                \"Caller must be shell, or hold CLEAR_FREEZE_PERIOD permission to call \"\n                        + \"clearSystemUpdatePolicyFreezePeriodRecord\");\n        synchronized (getLockObject()) {\n            // Print out current record to help diagnosed CTS failures\n            Slogf.i(LOG_TAG, \"Clear freeze period record: \"\n                    + mOwners.getSystemUpdateFreezePeriodRecordAsString());\n            if (mOwners.setSystemUpdateFreezePeriodRecord(null, null)) {\n                mOwners.writeDeviceOwner();\n            }\n        }\n    }\n\n    /**\n     * Checks if any of the packages associated with the UID of the app provided is that\n     * of the device owner.\n     * @param appUid UID of the app to check.\n     * @return {@code true} if any of the packages are the device owner, {@code false} otherwise.\n     */\n    private boolean isUidDeviceOwnerLocked(int appUid) {\n        ensureLocked();\n        final String deviceOwnerPackageName = mOwners.getDeviceOwnerComponent()\n                .getPackageName();\n        try {\n            String[] pkgs = mInjector.getIPackageManager().getPackagesForUid(appUid);\n            if (pkgs == null) {\n                return false;\n            }\n\n            for (String pkg : pkgs) {\n                if (deviceOwnerPackageName.equals(pkg)) {\n                    return true;\n                }\n            }\n        } catch (RemoteException e) {\n            return false;\n        }\n        return false;\n    }\n\n    @Override\n    public void notifyPendingSystemUpdate(@Nullable SystemUpdateInfo info) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.NOTIFY_PENDING_SYSTEM_UPDATE),\n                \"Only the system update service can broadcast update information\");\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (!mUserManager.getUserInfo(UserHandle.getCallingUserId()).isMain()) {\n                Slogf.w(LOG_TAG, \"Only the system update service in the main user can broadcast \"\n                        + \"update information.\");\n                return;\n            }\n        });\n\n        if (!mOwners.saveSystemUpdateInfo(info)) {\n            // Pending system update hasn't changed, don't send duplicate notification.\n            return;\n        }\n\n        final Intent intent = new Intent(DeviceAdminReceiver.ACTION_NOTIFY_PENDING_SYSTEM_UPDATE)\n                .putExtra(DeviceAdminReceiver.EXTRA_SYSTEM_UPDATE_RECEIVED_TIME,\n                        info == null ? -1 : info.getReceivedTime());\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            synchronized (getLockObject()) {\n                // Broadcast to device owner first if there is one.\n                if (mOwners.hasDeviceOwner()) {\n                    final UserHandle deviceOwnerUser =\n                            UserHandle.of(mOwners.getDeviceOwnerUserId());\n                    intent.setComponent(mOwners.getDeviceOwnerComponent());\n                    mContext.sendBroadcastAsUser(intent, deviceOwnerUser);\n                }\n            }\n            // Get running users.\n            final int runningUserIds[];\n            try {\n                runningUserIds = mInjector.getIActivityManager().getRunningUserIds();\n            } catch (RemoteException e) {\n                // Shouldn't happen.\n                Slogf.e(LOG_TAG, \"Could not retrieve the list of running users\", e);\n                return;\n            }\n            // Send broadcasts to corresponding profile owners if any.\n            for (final int userId : runningUserIds) {\n                synchronized (getLockObject()) {\n                    final ComponentName profileOwnerPackage =\n                            mOwners.getProfileOwnerComponent(userId);\n                    if (profileOwnerPackage != null) {\n                        intent.setComponent(profileOwnerPackage);\n                        mContext.sendBroadcastAsUser(intent, UserHandle.of(userId));\n                    }\n                }\n            }\n        });\n    }\n\n    @Override\n    public SystemUpdateInfo getPendingSystemUpdate(ComponentName admin) {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        return mOwners.getSystemUpdateInfo();\n    }\n\n    @Override\n    public void setPermissionPolicy(ComponentName admin, String callerPackage, int policy) {\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller,\n                DELEGATION_PERMISSION_GRANT)));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_PERMISSION_POLICY);\n\n        final int forUser = caller.getUserId();\n        synchronized (getLockObject()) {\n            DevicePolicyData userPolicy = getUserData(forUser);\n            if (userPolicy.mPermissionPolicy != policy) {\n                userPolicy.mPermissionPolicy = policy;\n                mPolicyCache.setPermissionPolicy(forUser, policy);\n                saveSettingsLocked(forUser);\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PERMISSION_POLICY)\n                .setAdmin(caller.getPackageName())\n                .setInt(policy)\n                .setBoolean(/* isDelegate */ admin == null)\n                .write();\n    }\n\n    private void updatePermissionPolicyCache(int userId) {\n        synchronized (getLockObject()) {\n            DevicePolicyData userPolicy = getUserData(userId);\n            mPolicyCache.setPermissionPolicy(userId, userPolicy.mPermissionPolicy);\n        }\n    }\n\n    @Override\n    public int getPermissionPolicy(ComponentName admin) throws RemoteException {\n        int userId = UserHandle.getCallingUserId();\n        return mPolicyCache.getPermissionPolicy(userId);\n    }\n\n    @Override\n    public void setPermissionGrantState(ComponentName admin, String callerPackage,\n            String packageName, String permission, int grantState, RemoteCallback callback)\n            throws RemoteException {\n        Objects.requireNonNull(callback);\n\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_PERMISSION_GRANT_STATE);\n\n        synchronized (getLockObject()) {\n            if (isFinancedDeviceOwner(caller)) {\n                enforcePermissionGrantStateOnFinancedDevice(packageName, permission);\n            }\n        }\n        EnforcingAdmin enforcingAdmin;\n        if (isUnicornFlagEnabled()) {\n            enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,\n                    callerPackage,\n                    caller.getUserId());\n            if (SENSOR_PERMISSIONS.contains(permission)\n                    && grantState == PERMISSION_GRANT_STATE_GRANTED\n                    && (!canAdminGrantSensorsPermissions() || isCallerDelegate(caller))) {\n                if (mInjector.isChangeEnabled(THROW_SECURITY_EXCEPTION_FOR_SENSOR_PERMISSIONS,\n                        caller.getPackageName(), caller.getUserId())) {\n                    throw new SecurityException(\n                            \"Caller not permitted to grant sensor permissions.\");\n                } else {\n                    // This is to match the legacy behaviour.\n                    callback.sendResult(Bundle.EMPTY);\n                    return;\n                }\n            }\n            // Check all the states where Exceptions aren't thrown but the permission\n            // isn't granted either.\n            if (!canGrantPermission(caller, permission, packageName)) {\n                callback.sendResult(null);\n                return;\n            }\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                    || isFinancedDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(caller,\n                    DELEGATION_PERMISSION_GRANT)));\n            synchronized (getLockObject()) {\n                long ident = mInjector.binderClearCallingIdentity();\n                try {\n                    boolean isPostQAdmin = getTargetSdk(caller.getPackageName(), caller.getUserId())\n                            >= android.os.Build.VERSION_CODES.Q;\n                    if (!isPostQAdmin) {\n                        // Legacy admins assume that they cannot control pre-M apps\n                        if (getTargetSdk(packageName, caller.getUserId())\n                                < android.os.Build.VERSION_CODES.M) {\n                            callback.sendResult(null);\n                            return;\n                        }\n                    }\n                    if (!isRuntimePermission(permission)) {\n                        callback.sendResult(null);\n                        return;\n                    }\n                } catch (SecurityException e) {\n                    Slogf.e(LOG_TAG, \"Could not set permission grant state\", e);\n                    callback.sendResult(null);\n                } finally {\n                    mInjector.binderRestoreCallingIdentity(ident);\n                }\n            }\n        }\n        // TODO(b/278710449): enable when we stop policy enforecer callback from blocking the main\n        //  thread\n        if (false) {\n            // TODO(b/266924257): decide how to handle the internal state if the package doesn't\n            //  exist, or the permission isn't requested by the app, because we could end up with\n            //  inconsistent state between the policy engine and package manager. Also a package\n            //  might get removed or has it's permission updated after we've set the policy.\n            if (grantState == PERMISSION_GRANT_STATE_DEFAULT) {\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.PERMISSION_GRANT(packageName, permission),\n                        enforcingAdmin,\n                        caller.getUserId());\n            } else {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.PERMISSION_GRANT(packageName, permission),\n                        enforcingAdmin,\n                        new IntegerPolicyValue(grantState),\n                        caller.getUserId());\n            }\n            int newState = mInjector.binderWithCleanCallingIdentity(() ->\n                    getPermissionGrantStateForUser(\n                            packageName, permission, caller, caller.getUserId()));\n            if (newState == grantState) {\n                callback.sendResult(Bundle.EMPTY);\n            } else {\n                callback.sendResult(null);\n            }\n        } else {\n            synchronized (getLockObject()) {\n                long ident = mInjector.binderClearCallingIdentity();\n                try {\n                    boolean isPostQAdmin = getTargetSdk(caller.getPackageName(), caller.getUserId())\n                            >= android.os.Build.VERSION_CODES.Q;\n                    if (grantState == PERMISSION_GRANT_STATE_GRANTED\n                            || grantState == DevicePolicyManager.PERMISSION_GRANT_STATE_DENIED\n                            || grantState == DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT) {\n                        AdminPermissionControlParams permissionParams =\n                                new AdminPermissionControlParams(packageName, permission,\n                                        grantState,\n                                        canAdminGrantSensorsPermissions());\n                        mInjector.getPermissionControllerManager(caller.getUserHandle())\n                                .setRuntimePermissionGrantStateByDeviceAdmin(\n                                        caller.getPackageName(),\n                                        permissionParams, mContext.getMainExecutor(),\n                                        (permissionWasSet) -> {\n                                            if (isPostQAdmin && !permissionWasSet) {\n                                                callback.sendResult(null);\n                                                return;\n                                            }\n                                            callback.sendResult(Bundle.EMPTY);\n                                        });\n                    }\n                } catch (SecurityException e) {\n                    Slogf.e(LOG_TAG, \"Could not set permission grant state\", e);\n\n                    callback.sendResult(null);\n                } finally {\n                    mInjector.binderRestoreCallingIdentity(ident);\n                }\n            }\n        }\n        DevicePolicyEventLogger.createEvent(DevicePolicyEnums.SET_PERMISSION_GRANT_STATE)\n                .setAdmin(caller.getPackageName())\n                .setStrings(permission)\n                .setInt(grantState)\n                .setBoolean(/* isDelegate */ isCallerDelegate(caller))\n                .write();\n    }\n\n    private static final List<String> SENSOR_PERMISSIONS = new ArrayList<>();\n    {\n        SENSOR_PERMISSIONS.add(Manifest.permission.ACCESS_FINE_LOCATION);\n        SENSOR_PERMISSIONS.add(Manifest.permission.ACCESS_BACKGROUND_LOCATION);\n        SENSOR_PERMISSIONS.add(Manifest.permission.ACCESS_COARSE_LOCATION);\n        SENSOR_PERMISSIONS.add(Manifest.permission.CAMERA);\n        SENSOR_PERMISSIONS.add(Manifest.permission.RECORD_AUDIO);\n        SENSOR_PERMISSIONS.add(Manifest.permission.ACTIVITY_RECOGNITION);\n        SENSOR_PERMISSIONS.add(Manifest.permission.BODY_SENSORS);\n        SENSOR_PERMISSIONS.add(Manifest.permission.BACKGROUND_CAMERA);\n        SENSOR_PERMISSIONS.add(Manifest.permission.RECORD_BACKGROUND_AUDIO);\n        SENSOR_PERMISSIONS.add(Manifest.permission.BODY_SENSORS_BACKGROUND);\n    }\n\n    private boolean canGrantPermission(CallerIdentity caller, String permission,\n            String targetPackageName) {\n        boolean isPostQAdmin = getTargetSdk(caller.getPackageName(), caller.getUserId())\n                >= android.os.Build.VERSION_CODES.Q;\n        if (!isPostQAdmin) {\n            // Legacy admins assume that they cannot control pre-M apps\n            if (getTargetSdk(targetPackageName, caller.getUserId())\n                    < android.os.Build.VERSION_CODES.M) {\n                return false;\n            }\n        }\n        if (!isRuntimePermission(permission)) {\n            return false;\n        }\n        return true;\n    }\n\n    private void enforcePermissionGrantStateOnFinancedDevice(\n            String packageName, String permission) {\n        if (!Manifest.permission.READ_PHONE_STATE.equals(permission)) {\n            throw new SecurityException(permission + \" cannot be used when managing a financed\"\n                    + \" device for permission grant state\");\n        } else if (!mOwners.getDeviceOwnerPackageName().equals(packageName)) {\n            throw new SecurityException(\"Device owner package is the only package that can be used\"\n                    + \" for permission grant state when managing a financed device\");\n        }\n    }\n\n    @Override\n    public int getPermissionGrantState(ComponentName admin, String callerPackage,\n            String packageName, String permission) throws RemoteException {\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        if (isUnicornFlagEnabled()) {\n            enforceCanQuery(MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS, caller.getPackageName(),\n                    caller.getUserId());\n        } else {\n            Preconditions.checkCallAuthorization(isSystemUid(caller) || (caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                    || isFinancedDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(caller,\n                    DELEGATION_PERMISSION_GRANT)));\n        }\n\n        synchronized (getLockObject()) {\n            if (isFinancedDeviceOwner(caller)) {\n                enforcePermissionGrantStateOnFinancedDevice(packageName, permission);\n            }\n            return mInjector.binderWithCleanCallingIdentity(() -> getPermissionGrantStateForUser(\n                    packageName, permission, caller, caller.getUserId()));\n        }\n    }\n\n    private int getPermissionGrantStateForUser(\n            String packageName, String permission, CallerIdentity caller, int userId)\n            throws RemoteException {\n        int granted;\n        if (getTargetSdk(caller.getPackageName(), caller.getUserId())\n                < android.os.Build.VERSION_CODES.Q) {\n            // The per-Q behavior was to not check the app-ops state.\n            granted = mIPackageManager.checkPermission(permission, packageName, userId);\n        } else {\n            try (var snapshot = mInjector.getPackageManagerLocal().withUnfilteredSnapshot()) {\n                var packageState = snapshot.getPackageStates().get(packageName);\n                if (packageState == null) {\n                    Slog.w(LOG_TAG, \"Can't get permission state for missing package \"\n                            + packageName);\n                    return DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;\n                } else if (!packageState.getUserStateOrDefault(userId).isInstalled()) {\n                    Slog.w(LOG_TAG, \"Can't get permission state for uninstalled package \"\n                            + packageName);\n                    return DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;\n                } else {\n                    if (PermissionChecker.checkPermissionForPreflight(mContext, permission,\n                            PermissionChecker.PID_UNKNOWN,\n                            UserHandle.getUid(userId, packageState.getAppId()), packageName)\n                            != PermissionChecker.PERMISSION_GRANTED) {\n                        granted = PackageManager.PERMISSION_DENIED;\n                    } else {\n                        granted = PackageManager.PERMISSION_GRANTED;\n                    }\n\n                }\n            }\n        }\n        int permFlags = mInjector.getPackageManager().getPermissionFlags(\n                permission, packageName, UserHandle.of(userId));\n        if ((permFlags & PackageManager.FLAG_PERMISSION_POLICY_FIXED)\n                != PackageManager.FLAG_PERMISSION_POLICY_FIXED) {\n            // Not controlled by policy\n            return DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;\n        } else {\n            // Policy controlled so return result based on permission grant state\n            return granted == PackageManager.PERMISSION_GRANTED\n                    ? DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED\n                    : DevicePolicyManager.PERMISSION_GRANT_STATE_DENIED;\n        }\n    }\n\n    boolean isPackageInstalledForUser(String packageName, int userHandle) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                PackageInfo pi = mInjector.getIPackageManager().getPackageInfo(packageName, 0,\n                        userHandle);\n                return (pi != null) && (pi.applicationInfo.flags != 0);\n            } catch (RemoteException re) {\n                throw new RuntimeException(\"Package manager has died\", re);\n            }\n        });\n    }\n\n    private boolean isRuntimePermission(String permissionName) {\n        try {\n            final PackageManager packageManager = mInjector.getPackageManager();\n            PermissionInfo permissionInfo = packageManager.getPermissionInfo(permissionName, 0);\n            return (permissionInfo.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE)\n                    == PermissionInfo.PROTECTION_DANGEROUS;\n        } catch (NameNotFoundException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public boolean isProvisioningAllowed(String action, String packageName) {\n        Objects.requireNonNull(packageName);\n        final CallerIdentity caller = getCallerIdentity();\n        final long ident = mInjector.binderClearCallingIdentity();\n        try {\n            final List<String> callerUidPackageNames = Arrays.asList(\n                    mInjector.getPackageManager().getPackagesForUid(caller.getUid()));\n            Preconditions.checkArgument(callerUidPackageNames.contains(packageName),\n                    \"Caller uid doesn't match the one for the provided package.\");\n\n            return checkProvisioningPreconditionSkipPermission(action, packageName, caller.getUserId())\n                    == STATUS_OK;\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int checkProvisioningPrecondition(String action, String packageName) {\n        Objects.requireNonNull(packageName, \"packageName is null\");\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        long originalId = mInjector.binderClearCallingIdentity();\n        try {\n            return checkProvisioningPreconditionSkipPermission(\n                    action, packageName, caller.getUserId());\n        } finally {\n            mInjector.binderRestoreCallingIdentity(originalId);\n        }\n\n    }\n    private int checkProvisioningPreconditionSkipPermission(String action,\n            String packageName, int userId) {\n        if (!mHasFeature) {\n            logMissingFeatureAction(\"Cannot check provisioning for action \" + action);\n            return STATUS_DEVICE_ADMIN_NOT_SUPPORTED;\n        }\n        if (!isProvisioningAllowed()) {\n            return STATUS_PROVISIONING_NOT_ALLOWED_FOR_NON_DEVELOPER_USERS;\n        }\n        final int code = checkProvisioningPreConditionSkipPermissionNoLog(\n                action, packageName, userId);\n        if (code != STATUS_OK) {\n            Slogf.d(LOG_TAG, \"checkProvisioningPreCondition(\" + action + \", \" + packageName\n                    + \") failed: \"\n                    + computeProvisioningErrorString(code, mInjector.userHandleGetCallingUserId()));\n        }\n        return code;\n    }\n\n    /**\n     *  Checks if provisioning is allowed during regular usage (non-developer/CTS). This could\n     *  return {@code false} if the device has an overlaid config value set to false. If not set,\n     *  the default is true.\n     */\n    private boolean isProvisioningAllowed() {\n        boolean isDeveloperMode = isDeveloperMode(mContext);\n        boolean isProvisioningAllowedForNormalUsers = SystemProperties.getBoolean(\n                ALLOW_USER_PROVISIONING_KEY, /* defValue= */ true);\n\n        return isDeveloperMode || isProvisioningAllowedForNormalUsers;\n    }\n\n    private static boolean isDeveloperMode(Context context) {\n        return Global.getInt(context.getContentResolver(), Global.ADB_ENABLED, 0) > 0;\n    }\n\n    private int checkProvisioningPreConditionSkipPermissionNoLog(String action,\n            String packageName, int userId) {\n        if (action != null) {\n            switch (action) {\n                case DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE:\n                    return checkManagedProfileProvisioningPreCondition(packageName, userId);\n                case DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE:\n                case DevicePolicyManager.ACTION_PROVISION_FINANCED_DEVICE:\n                    return checkDeviceOwnerProvisioningPreCondition(userId);\n            }\n        }\n        throw new IllegalArgumentException(\"Unknown provisioning action \" + action);\n    }\n\n    /**\n     * The device owner can only be set before the setup phase of the primary user has completed,\n     * except for adb command if no accounts or additional users are present on the device.\n     */\n    private int checkDeviceOwnerProvisioningPreConditionLocked(@Nullable ComponentName owner,\n            @UserIdInt int deviceOwnerUserId, @UserIdInt int callingUserId, boolean isAdb,\n            boolean hasIncompatibleAccountsOrNonAdb) {\n        if (mOwners.hasDeviceOwner()) {\n            return STATUS_HAS_DEVICE_OWNER;\n        }\n        if (mOwners.hasProfileOwner(deviceOwnerUserId)) {\n            return STATUS_USER_HAS_PROFILE_OWNER;\n        }\n\n        if (!mUserManager.isUserRunning(new UserHandle(deviceOwnerUserId))) {\n            return STATUS_USER_NOT_RUNNING;\n        }\n        if (mIsWatch && hasPaired(UserHandle.USER_SYSTEM)) {\n            return STATUS_HAS_PAIRED;\n        }\n\n        boolean isHeadlessSystemUserMode = mInjector.userManagerIsHeadlessSystemUserMode();\n\n        if (isHeadlessSystemUserMode) {\n            if (deviceOwnerUserId != UserHandle.USER_SYSTEM) {\n                Slogf.e(LOG_TAG, \"In headless system user mode, \"\n                        + \"device owner can only be set on headless system user.\");\n                return STATUS_NOT_SYSTEM_USER;\n            }\n\n            if (owner != null) {\n                DeviceAdminInfo adminInfo = findAdmin(\n                        owner, deviceOwnerUserId, /* throwForMissingPermission= */ false);\n\n                if (adminInfo.getHeadlessDeviceOwnerMode()\n                        != HEADLESS_DEVICE_OWNER_MODE_AFFILIATED) {\n                    return STATUS_HEADLESS_SYSTEM_USER_MODE_NOT_SUPPORTED;\n                }\n            }\n        }\n\n        if (isAdb) {\n            // If shell command runs after user setup completed check device status. Otherwise, OK.\n            if (mIsWatch || hasUserSetupCompleted(UserHandle.USER_SYSTEM)) {\n                // DO can be setup only if there are no users which are neither created by default\n                // nor marked as FOR_TESTING\n\n                if (nonTestNonPrecreatedUsersExist()) {\n                    return STATUS_NONSYSTEM_USER_EXISTS;\n                }\n\n                int currentForegroundUser = getCurrentForegroundUserId();\n                if (callingUserId != currentForegroundUser\n                        && mInjector.userManagerIsHeadlessSystemUserMode()\n                        && currentForegroundUser == UserHandle.USER_SYSTEM) {\n                    Slogf.wtf(LOG_TAG, \"In headless system user mode, \"\n                            + \"current user cannot be system user when setting device owner\");\n                    return STATUS_SYSTEM_USER;\n                }\n                if (hasIncompatibleAccountsOrNonAdb) {\n                    return STATUS_ACCOUNTS_NOT_EMPTY;\n                }\n            }\n            return STATUS_OK;\n        } else {\n            // DO has to be user 0\n            if (deviceOwnerUserId != UserHandle.USER_SYSTEM) {\n                return STATUS_NOT_SYSTEM_USER;\n            }\n            // Only provision DO before setup wizard completes\n            if (hasUserSetupCompleted(UserHandle.USER_SYSTEM)) {\n                return STATUS_USER_SETUP_COMPLETED;\n            }\n            return STATUS_OK;\n        }\n    }\n\n    /**\n     * True if there are any users on the device which were not setup by default (1 usually, 2 for\n     * devices with a headless system user) and also are not marked as FOR_TESTING.\n     */\n    private boolean nonTestNonPrecreatedUsersExist() {\n        int allowedUsers = UserManager.isHeadlessSystemUserMode() ? 2 : 1;\n        return mUserManagerInternal.getUsers(/* excludeDying= */ true).stream()\n                .filter(u -> !u.isForTesting())\n                .count() > allowedUsers;\n    }\n\n    private int checkDeviceOwnerProvisioningPreCondition(@UserIdInt int callingUserId) {\n        synchronized (getLockObject()) {\n            final int deviceOwnerUserId = mInjector.userManagerIsHeadlessSystemUserMode()\n                    ? UserHandle.USER_SYSTEM\n                    : callingUserId;\n            Slogf.i(LOG_TAG, \"Calling user %d, device owner will be set on user %d\",\n                    callingUserId, deviceOwnerUserId);\n            // hasIncompatibleAccountsOrNonAdb doesn't matter since the caller is not adb.\n            return checkDeviceOwnerProvisioningPreConditionLocked(/* owner unknown */ null,\n                    deviceOwnerUserId, callingUserId, /* isAdb= */ false,\n                    /* hasIncompatibleAccountsOrNonAdb=*/ true);\n        }\n    }\n\n    private int checkManagedProfileProvisioningPreCondition(String packageName,\n            @UserIdInt int callingUserId) {\n        if (!hasFeatureManagedUsers()) {\n            return STATUS_MANAGED_USERS_NOT_SUPPORTED;\n        }\n        if (getProfileOwnerAsUser(callingUserId) != null) {\n            // Managed user cannot have a managed profile.\n            return STATUS_USER_HAS_PROFILE_OWNER;\n        }\n\n        final long ident = mInjector.binderClearCallingIdentity();\n        try {\n            final UserHandle callingUserHandle = UserHandle.of(callingUserId);\n            final boolean hasDeviceOwner;\n            synchronized (getLockObject()) {\n                hasDeviceOwner = getDeviceOwnerAdminLocked() != null;\n            }\n\n            final boolean addingProfileRestricted = mUserManager.hasUserRestriction(\n                    UserManager.DISALLOW_ADD_MANAGED_PROFILE, callingUserHandle);\n\n            if (mUserManager.getUserInfo(callingUserId).isProfile()) {\n                Slogf.i(LOG_TAG, \"Calling user %d is a profile, cannot add another.\",\n                        callingUserId);\n                // The check is called from inside a managed profile. A managed profile cannot\n                // be provisioned from within another managed profile.\n                return STATUS_CANNOT_ADD_MANAGED_PROFILE;\n            }\n\n            // If there's a device owner, the restriction on adding a managed profile must be set.\n            if (hasDeviceOwner && !addingProfileRestricted) {\n                Slogf.wtf(LOG_TAG, \"Has a device owner but no restriction on adding a profile.\");\n            }\n\n            // Do not allow adding a managed profile if there's a restriction.\n            if (addingProfileRestricted) {\n                Slogf.i(LOG_TAG, \"Adding a profile is restricted: User %s Has device owner? %b\",\n                        callingUserHandle, hasDeviceOwner);\n                return STATUS_CANNOT_ADD_MANAGED_PROFILE;\n            }\n\n            // Bail out if we are trying to provision a work profile but one already exists.\n            if (!mUserManager.canAddMoreManagedProfiles(\n                    callingUserId, /* allowedToRemoveOne= */ false)) {\n                Slogf.i(LOG_TAG, \"Cannot add more managed profiles.\");\n                return STATUS_CANNOT_ADD_MANAGED_PROFILE;\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n        return STATUS_OK;\n    }\n\n    private void checkIsDeviceOwner(CallerIdentity caller) {\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller), caller.getUid()\n                + \" is not device owner\");\n    }\n\n    /**\n     * Return device owner or profile owner set on a given user.\n     */\n    private @Nullable ComponentName getOwnerComponent(int userId) {\n        synchronized (getLockObject()) {\n            if (mOwners.getDeviceOwnerUserId() == userId) {\n                return mOwners.getDeviceOwnerComponent();\n            }\n            if (mOwners.hasProfileOwner(userId)) {\n                return mOwners.getProfileOwnerComponent(userId);\n            }\n        }\n        return null;\n    }\n\n    private boolean hasFeatureManagedUsers() {\n        try {\n            return mIPackageManager.hasSystemFeature(PackageManager.FEATURE_MANAGED_USERS, 0);\n        } catch (RemoteException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public String getWifiMacAddress(ComponentName admin, String callerPackageName) {\n//        if (!isPermissionCheckFlagEnabled()) {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n//        }\n\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackageName);\n//        if (isPermissionCheckFlagEnabled()) {\n//            enforcePermission(MANAGE_DEVICE_POLICY_WIFI, UserHandle.USER_ALL);\n//        } else {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller));\n//        }\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            String[] macAddresses = mInjector.getWifiManager().getFactoryMacAddresses();\n            if (macAddresses == null) {\n                return null;\n            }\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.GET_WIFI_MAC_ADDRESS)\n                    .setAdmin(caller.getPackageName())\n                    .write();\n            return macAddresses.length > 0 ? macAddresses[0] : null;\n        });\n    }\n\n    /**\n     * Returns the target sdk version number that the given packageName was built for\n     * in the given user.\n     */\n    private int getTargetSdk(String packageName, int userId) {\n        final ApplicationInfo ai;\n        try {\n            ai = mIPackageManager.getApplicationInfo(packageName, 0, userId);\n            return ai == null ? 0 : ai.targetSdkVersion;\n        } catch (RemoteException e) {\n            // Shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Error getting application info\", e);\n            return 0;\n        }\n    }\n\n    @Override\n    public boolean isManagedProfile(ComponentName admin) {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        return isManagedProfile(caller.getUserId());\n    }\n\n    @Override\n    public void reboot(ComponentName admin) {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_REBOOT);\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            // Make sure there are no ongoing calls on the device.\n            if (mTelephonyManager.getCallState() != TelephonyManager.CALL_STATE_IDLE) {\n                throw new IllegalStateException(\"Cannot be called with ongoing call on the device\");\n            }\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.REBOOT)\n                    .setAdmin(admin)\n                    .write();\n            mInjector.powerManagerReboot(PowerManager.REBOOT_REQUESTED_BY_DEVICE_OWNER);\n        });\n    }\n\n    @Override\n    public void setShortSupportMessage(@Nullable ComponentName who, String callerPackageName,\n            CharSequence message) {\n        if (!mHasFeature) {\n            return;\n        }\n        CallerIdentity caller;\n        ActiveAdmin admin;\n\n        message = truncateIfLonger(message, MAX_SHORT_SUPPORT_MESSAGE_LENGTH);\n\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            admin = enforcingAdmin.getActiveAdmin();\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            synchronized (getLockObject()) {\n                admin = getActiveAdminForUidLocked(who, caller.getUid());\n            }\n        }\n\n        synchronized (getLockObject()) {\n            if (!TextUtils.equals(admin.shortSupportMessage, message)) {\n                admin.shortSupportMessage = message;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SHORT_SUPPORT_MESSAGE)\n                .setAdmin(caller.getPackageName())\n                .write();\n    }\n\n    @Override\n    public CharSequence getShortSupportMessage(@Nullable ComponentName who,\n            String callerPackageName) {\n        if (!mHasFeature) {\n            return null;\n        }\n        CallerIdentity caller;\n        ActiveAdmin admin;\n\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            admin = enforcingAdmin.getActiveAdmin();\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            synchronized (getLockObject()) {\n                admin = getActiveAdminForUidLocked(who, caller.getUid());\n            }\n        }\n        return admin.shortSupportMessage;\n    }\n\n    @Override\n    public void setLongSupportMessage(@NonNull ComponentName who, CharSequence message) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        message = truncateIfLonger(message, MAX_LONG_SUPPORT_MESSAGE_LENGTH);\n\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminForUidLocked(who, caller.getUid());\n            if (!TextUtils.equals(admin.longSupportMessage, message)) {\n                admin.longSupportMessage = message;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_LONG_SUPPORT_MESSAGE)\n                .setAdmin(who)\n                .write();\n    }\n\n    @Override\n    public CharSequence getLongSupportMessage(@NonNull ComponentName who) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminForUidLocked(who, caller.getUid());\n            return admin.longSupportMessage;\n        }\n    }\n\n    @Override\n    public CharSequence getShortSupportMessageForUser(@NonNull ComponentName who, int userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"query support message for user\"));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n            if (admin != null) {\n                return admin.shortSupportMessage;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public CharSequence getLongSupportMessageForUser(@NonNull ComponentName who, int userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"query support message for user\"));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n            if (admin != null) {\n                return admin.longSupportMessage;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void setOrganizationColor(@NonNull ComponentName who, int color) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallingUser(isManagedProfile(caller.getUserId()));\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            admin.organizationColor = color;\n            saveSettingsLocked(caller.getUserId());\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_ORGANIZATION_COLOR)\n                .setAdmin(caller.getComponentName())\n                .write();\n    }\n\n    @Override\n    public void setOrganizationColorForUser(int color, int userId) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userId));\n        Preconditions.checkCallAuthorization(canManageUsers(caller));\n        Preconditions.checkCallAuthorization(isManagedProfile(userId), \"You can not \"\n                + \"set organization color outside a managed profile, userId = %d\", userId);\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            admin.organizationColor = color;\n            saveSettingsLocked(userId);\n        }\n    }\n\n    @Override\n    public int getOrganizationColor(@NonNull ComponentName who) {\n        if (!mHasFeature) {\n            return ActiveAdmin.DEF_ORGANIZATION_COLOR;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallingUser(isManagedProfile(caller.getUserId()));\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return admin.organizationColor;\n        }\n    }\n\n    @Override\n    public int getOrganizationColorForUser(int userHandle) {\n        if (!mHasFeature) {\n            return ActiveAdmin.DEF_ORGANIZATION_COLOR;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(isManagedProfile(userHandle), \"You can \"\n                + \"not get organization color outside a managed profile, userId = %d\", userHandle);\n\n        synchronized (getLockObject()) {\n            ActiveAdmin profileOwner = getProfileOwnerAdminLocked(userHandle);\n            return (profileOwner != null)\n                    ? profileOwner.organizationColor\n                    : ActiveAdmin.DEF_ORGANIZATION_COLOR;\n        }\n    }\n\n    @Override\n    public void setOrganizationName(@Nullable ComponentName who, String callerPackageName,\n            CharSequence text) {\n        if (!mHasFeature) {\n            return;\n        }\n        CallerIdentity caller = getCallerIdentity(who);\n        ActiveAdmin admin = null;\n\n        if (isPermissionCheckFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            admin = enforcingAdmin.getActiveAdmin();\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isDeviceOwner(caller) || isProfileOwner(caller));\n        }\n\n        text = truncateIfLonger(text, MAX_ORG_NAME_LENGTH);\n\n        synchronized (getLockObject()) {\n            if (!isPermissionCheckFlagEnabled()) {\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n            if (!TextUtils.equals(admin.organizationName, text)) {\n                admin.organizationName = (text == null || text.length() == 0)\n                        ? null : text.toString();\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public CharSequence getOrganizationName(@Nullable ComponentName who, String callerPackageName) {\n        if (!mHasFeature) {\n            return null;\n        }\n        CallerIdentity caller = getCallerIdentity(who);\n        ActiveAdmin admin;\n\n        if (isPermissionCheckFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforceCanQueryAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            admin = enforcingAdmin.getActiveAdmin();\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallingUser(isManagedProfile(caller.getUserId()));\n            Preconditions.checkCallAuthorization(isDeviceOwner(caller) || isProfileOwner(caller));\n\n            synchronized (getLockObject()) {\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n        }\n\n        return admin.organizationName;\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public CharSequence getDeviceOwnerOrganizationName() {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || canManageUsers(caller) || isFinancedDeviceOwner(caller));\n        synchronized (getLockObject()) {\n            final ActiveAdmin deviceOwnerAdmin = getDeviceOwnerAdminLocked();\n            return deviceOwnerAdmin == null ? null : deviceOwnerAdmin.organizationName;\n        }\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public CharSequence getOrganizationNameForUser(int userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(canManageUsers(caller));\n        Preconditions.checkCallAuthorization(isManagedProfile(userHandle),\n                \"You can not get organization name outside a managed profile, userId = %d\",\n                userHandle);\n\n        synchronized (getLockObject()) {\n            ActiveAdmin profileOwner = getProfileOwnerAdminLocked(userHandle);\n            return (profileOwner != null)\n                    ? profileOwner.organizationName\n                    : null;\n        }\n    }\n\n    @Override\n    public List<String> setMeteredDataDisabledPackages(ComponentName who, List<String> packageNames) {\n        Objects.requireNonNull(who);\n        Objects.requireNonNull(packageNames);\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller),\n                \"Admin %s does not own the profile\", caller.getComponentName());\n\n        if (!mHasFeature) {\n            return packageNames;\n        }\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            return mInjector.binderWithCleanCallingIdentity(() -> {\n                final List<String> excludedPkgs = removeInvalidPkgsForMeteredDataRestriction(\n                        caller.getUserId(), packageNames);\n                admin.meteredDisabledPackages = packageNames;\n                pushMeteredDisabledPackages(caller.getUserId());\n                saveSettingsLocked(caller.getUserId());\n                return excludedPkgs;\n            });\n        }\n    }\n\n    private List<String> removeInvalidPkgsForMeteredDataRestriction(\n            int userId, List<String> pkgNames) {\n        final Set<String> activeAdmins = getActiveAdminPackagesLocked(userId);\n        final List<String> excludedPkgs = new ArrayList<>();\n        for (int i = pkgNames.size() - 1; i >= 0; --i) {\n            final String pkgName = pkgNames.get(i);\n            // If the package is an active admin, don't restrict it.\n            if (activeAdmins.contains(pkgName)) {\n                excludedPkgs.add(pkgName);\n                continue;\n            }\n            // If the package doesn't exist, don't restrict it.\n            try {\n                if (!mInjector.getIPackageManager().isPackageAvailable(pkgName, userId)) {\n                    excludedPkgs.add(pkgName);\n                }\n            } catch (RemoteException e) {\n                // Should not happen\n            }\n        }\n        pkgNames.removeAll(excludedPkgs);\n        return excludedPkgs;\n    }\n\n    @Override\n    public List<String> getMeteredDataDisabledPackages(ComponentName who) {\n        Objects.requireNonNull(who);\n\n        if (!mHasFeature) {\n            return new ArrayList<>();\n        }\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller),\n                \"Admin %s does not own the profile\", caller.getComponentName());\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            return admin.meteredDisabledPackages == null\n                    ? new ArrayList<>() : admin.meteredDisabledPackages;\n        }\n    }\n\n    @Override\n    public boolean isMeteredDataDisabledPackageForUser(ComponentName who,\n            String packageName, int userId) {\n        Objects.requireNonNull(who);\n\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"query restricted pkgs for a specific user\"));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userId);\n            if (admin != null && admin.meteredDisabledPackages != null) {\n                return admin.meteredDisabledPackages.contains(packageName);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void setProfileOwnerOnOrganizationOwnedDevice(ComponentName who, int userId,\n            boolean isProfileOwnerOnOrganizationOwnedDevice) {\n        if (!mHasFeature) {\n            return;\n        }\n        // As the caller is the system, it must specify the component name of the profile owner\n        // as a safety check.\n        Objects.requireNonNull(who);\n\n        final CallerIdentity caller = getCallerIdentity();\n        // Only adb or system apps with the right permission can mark a profile owner on\n        // organization-owned device.\n        if (!(isAdb(caller) || hasCallingPermission(permission.MARK_DEVICE_ORGANIZATION_OWNED)\n                || hasCallingPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS))) {\n            throw new SecurityException(\n                    \"Only the system can mark a profile owner of organization-owned device.\");\n        }\n        // Only a test admin can be unmarked as a profile owner on an organization-owned device.\n        synchronized (getLockObject()) {\n            if (!isProfileOwnerOnOrganizationOwnedDevice && !isAdminTestOnlyLocked(who, userId)) {\n                throw new SecurityException(\"Only a test admin can be unmarked as a \"\n                        + \"profile owner of organization-owned device.\");\n            }\n        }\n\n        if (isAdb(caller)) {\n            if (hasIncompatibleAccountsOrNonAdbNoLock(caller, userId, who)) {\n                throw new SecurityException(\n                        \"Can only be called from ADB if the device has no accounts.\");\n            }\n        } else {\n            if (hasUserSetupCompleted(UserHandle.USER_SYSTEM)) {\n                throw new IllegalStateException(\n                        \"Cannot mark profile owner as managing an organization-owned device after\"\n                                + \" set-up\");\n            }\n        }\n\n        // Grant access under lock.\n        synchronized (getLockObject()) {\n            setProfileOwnerOnOrganizationOwnedDeviceUncheckedLocked(who, userId,\n                    isProfileOwnerOnOrganizationOwnedDevice);\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void setProfileOwnerOnOrganizationOwnedDeviceUncheckedLocked(\n            ComponentName who, int userId, boolean isProfileOwnerOnOrganizationOwnedDevice) {\n        // Make sure that the user has a profile owner and that the specified\n        // component is the profile owner of that user.\n        if (!isProfileOwner(who, userId)) {\n            throw new IllegalArgumentException(String.format(\n                    \"Component %s is not a Profile Owner of user %d\",\n                    who.flattenToString(), userId));\n        }\n\n        Slogf.i(LOG_TAG, \"%s %s as profile owner on organization-owned device for user %d\",\n                isProfileOwnerOnOrganizationOwnedDevice ? \"Marking\" : \"Unmarking\",\n                who.flattenToString(), userId);\n\n        // First, set restriction on removing the profile.\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            // Clear restriction as user.\n            final UserHandle parentUser = mUserManager.getProfileParent(UserHandle.of(userId));\n            if (parentUser == null) {\n                throw new IllegalStateException(String.format(\"User %d is not a profile\", userId));\n            }\n\n            mUserManager.setUserRestriction(UserManager.DISALLOW_REMOVE_MANAGED_PROFILE,\n                    isProfileOwnerOnOrganizationOwnedDevice,\n                    parentUser);\n            mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_USER,\n                    isProfileOwnerOnOrganizationOwnedDevice,\n                    parentUser);\n        });\n\n        // setProfileOwnerOfOrganizationOwnedDevice will trigger writing of the profile owner\n        // data, no need to do it manually.\n        mOwners.setProfileOwnerOfOrganizationOwnedDevice(userId,\n                isProfileOwnerOnOrganizationOwnedDevice);\n    }\n\n    private void pushMeteredDisabledPackages(int userId) {\n        wtfIfInLock();\n        mInjector.getNetworkPolicyManagerInternal().setMeteredRestrictedPackages(\n                getMeteredDisabledPackages(userId), userId);\n    }\n\n    private Set<String> getMeteredDisabledPackages(int userId) {\n        synchronized (getLockObject()) {\n            final Set<String> restrictedPkgs = new ArraySet<>();\n            final ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userId);\n            if (admin != null && admin.meteredDisabledPackages != null) {\n                restrictedPkgs.addAll(admin.meteredDisabledPackages);\n            }\n\n            return restrictedPkgs;\n        }\n    }\n\n    @Override\n    public void setAffiliationIds(ComponentName admin, List<String> ids) {\n        if (!mHasFeature) {\n            return;\n        }\n        if (ids == null) {\n            throw new IllegalArgumentException(\"ids must not be null\");\n        }\n        for (String id : ids) {\n            Preconditions.checkArgument(!TextUtils.isEmpty(id), \"ids must not have empty string\");\n            enforceMaxStringLength(id, \"affiliation id\");\n        }\n\n        final Set<String> affiliationIds = new ArraySet<>(ids);\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        final int callingUserId = caller.getUserId();\n\n        synchronized (getLockObject()) {\n            getUserData(callingUserId).mAffiliationIds = affiliationIds;\n            saveSettingsLocked(callingUserId);\n            mStateCache.setHasAffiliationWithDevice(callingUserId,\n                    isUserAffiliatedWithDeviceLocked(callingUserId));\n            if (callingUserId == UserHandle.USER_SYSTEM) {\n                resetAffiliationCacheLocked();\n            } else if (callingUserId != UserHandle.USER_SYSTEM && isDeviceOwner(admin,\n                    callingUserId)) {\n                // Affiliation ids specified by the device owner are additionally stored in\n                // UserHandle.USER_SYSTEM's DevicePolicyData.\n                getUserData(UserHandle.USER_SYSTEM).mAffiliationIds = affiliationIds;\n                mStateCache.setHasAffiliationWithDevice(UserHandle.USER_SYSTEM, true);\n                saveSettingsLocked(UserHandle.USER_SYSTEM);\n            }\n\n            // Affiliation status for any user, not just the calling user, might have changed.\n            // The device owner user will still be affiliated after changing its affiliation ids,\n            // but as a result of that other users might become affiliated or un-affiliated.\n            maybePauseDeviceWideLoggingLocked();\n            maybeResumeDeviceWideLoggingLocked();\n            maybeClearLockTaskPolicyLocked();\n            updateAdminCanGrantSensorsPermissionCache(callingUserId);\n        }\n    }\n\n    private void resetAffiliationCacheLocked() {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo user : mUserManager.getUsers()) {\n                mStateCache.setHasAffiliationWithDevice(user.id,\n                        isUserAffiliatedWithDeviceLocked(user.id));\n            }\n        });\n    }\n\n    @Override\n    public List<String> getAffiliationIds(ComponentName admin) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n\n        Objects.requireNonNull(admin);\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            return new ArrayList<String>(getUserData(caller.getUserId()).mAffiliationIds);\n        }\n    }\n\n    @Override\n    public boolean isCallingUserAffiliated() {\n        if (!mHasFeature) {\n            return false;\n        }\n\n        synchronized (getLockObject()) {\n            return isUserAffiliatedWithDeviceLocked(mInjector.userHandleGetCallingUserId());\n        }\n    }\n\n    @Override\n    public boolean isAffiliatedUser(@UserIdInt int userId) {\n        if (!mHasFeature) {\n            return false;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        return isUserAffiliatedWithDevice(userId);\n    }\n\n    private boolean isUserAffiliatedWithDevice(@UserIdInt int userId) {\n        synchronized (getLockObject()) {\n            return isUserAffiliatedWithDeviceLocked(userId);\n        }\n    }\n\n    private boolean isUserAffiliatedWithDeviceLocked(@UserIdInt int userId) {\n        if (!mOwners.hasDeviceOwner()) {\n            return false;\n        }\n        if (userId == UserHandle.USER_SYSTEM) {\n            // The system user is always affiliated in a DO device,\n            // even if in headless system user mode.\n            return true;\n        }\n        if (userId == mOwners.getDeviceOwnerUserId()) {\n            // The user that the DO is installed on is always affiliated with the device.\n            return true;\n        }\n\n        final ComponentName profileOwner = getProfileOwnerAsUser(userId);\n        if (profileOwner == null) {\n            return false;\n        }\n\n        final Set<String> userAffiliationIds = getUserData(userId).mAffiliationIds;\n        final Set<String> deviceAffiliationIds =\n                getUserData(UserHandle.USER_SYSTEM).mAffiliationIds;\n        for (String id : userAffiliationIds) {\n            if (deviceAffiliationIds.contains(id)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean areAllUsersAffiliatedWithDeviceLocked() {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            final List<UserInfo> userInfos = mUserManager.getAliveUsers();\n            for (int i = 0; i < userInfos.size(); i++) {\n                int userId = userInfos.get(i).id;\n                if (!isUserAffiliatedWithDeviceLocked(userId)) {\n                    Slogf.d(LOG_TAG, \"User id \" + userId + \" not affiliated.\");\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n    private @UserIdInt int getSecurityLoggingEnabledUser() {\n        synchronized (getLockObject()) {\n            if (mOwners.hasDeviceOwner()) {\n                return UserHandle.USER_ALL;\n            }\n        }\n        // TODO: Add check for permission-based\n        return getOrganizationOwnedProfileUserId();\n    }\n\n    @Override\n    public void setSecurityLoggingEnabled(ComponentName admin, String packageName,\n            boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n\n        synchronized (getLockObject()) {\n            if (isPermissionCheckFlagEnabled()) {\n                enforcePermission(MANAGE_DEVICE_POLICY_SECURITY_LOGGING, caller.getPackageName(),\n                        UserHandle.USER_ALL);\n            } else {\n                if (admin != null) {\n                    Preconditions.checkCallAuthorization(\n                            isProfileOwnerOfOrganizationOwnedDevice(caller)\n                                    || isDefaultDeviceOwner(caller));\n                } else {\n                    // A delegate app passes a null admin component, which is expected\n                    Preconditions.checkCallAuthorization(\n                            isCallerDelegate(caller, DELEGATION_SECURITY_LOGGING));\n                }\n            }\n\n            if (enabled == mInjector.securityLogGetLoggingEnabledProperty()) {\n                return;\n            }\n            mInjector.securityLogSetLoggingEnabledProperty(enabled);\n            if (enabled) {\n                mSecurityLogMonitor.start(getSecurityLoggingEnabledUser());\n                maybePauseDeviceWideLoggingLocked();\n            } else {\n                mSecurityLogMonitor.stop();\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SECURITY_LOGGING_ENABLED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(enabled)\n                .write();\n    }\n\n    @Override\n    public boolean isSecurityLoggingEnabled(ComponentName admin, String packageName) {\n        if (!mHasFeature) {\n            return false;\n        }\n\n        synchronized (getLockObject()) {\n            if (!isSystemUid(getCallerIdentity())) {\n                final CallerIdentity caller = getCallerIdentity(admin, packageName);\n                if (isPermissionCheckFlagEnabled()) {\n                    enforcePermission(MANAGE_DEVICE_POLICY_SECURITY_LOGGING,\n                            caller.getPackageName(), UserHandle.USER_ALL);\n                } else {\n                    if (admin != null) {\n                        Preconditions.checkCallAuthorization(\n                                isProfileOwnerOfOrganizationOwnedDevice(caller)\n                                        || isDefaultDeviceOwner(caller));\n                    } else {\n                        // A delegate app passes a null admin component, which is expected\n                        Preconditions.checkCallAuthorization(\n                                isCallerDelegate(caller, DELEGATION_SECURITY_LOGGING));\n                    }\n                }\n            }\n            return mInjector.securityLogGetLoggingEnabledProperty();\n        }\n    }\n\n    private void recordSecurityLogRetrievalTime() {\n        synchronized (getLockObject()) {\n            final long currentTime = System.currentTimeMillis();\n            DevicePolicyData policyData = getUserData(UserHandle.USER_SYSTEM);\n            if (currentTime > policyData.mLastSecurityLogRetrievalTime) {\n                policyData.mLastSecurityLogRetrievalTime = currentTime;\n                saveSettingsLocked(UserHandle.USER_SYSTEM);\n            }\n        }\n    }\n\n    @Override\n    public ParceledListSlice<SecurityEvent> retrievePreRebootSecurityLogs(ComponentName admin,\n            String packageName) {\n        if (!mHasFeature) {\n            return null;\n        }\n\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n        if (isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(isOrganizationOwnedDeviceWithManagedProfile()\n                    || areAllUsersAffiliatedWithDeviceLocked());\n            enforcePermission(MANAGE_DEVICE_POLICY_SECURITY_LOGGING, caller.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            if (admin != null) {\n                Preconditions.checkCallAuthorization(\n                        isProfileOwnerOfOrganizationOwnedDevice(caller)\n                                || isDefaultDeviceOwner(caller));\n            } else {\n                // A delegate app passes a null admin component, which is expected\n                Preconditions.checkCallAuthorization(\n                        isCallerDelegate(caller, DELEGATION_SECURITY_LOGGING));\n            }\n\n            Preconditions.checkCallAuthorization(isOrganizationOwnedDeviceWithManagedProfile()\n                    || areAllUsersAffiliatedWithDeviceLocked());\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.RETRIEVE_PRE_REBOOT_SECURITY_LOGS)\n                .setAdmin(caller.getPackageName())\n                .write();\n\n        if (!mContext.getResources().getBoolean(R.bool.config_supportPreRebootSecurityLogs)\n                || !mInjector.securityLogGetLoggingEnabledProperty()) {\n            return null;\n        }\n\n        recordSecurityLogRetrievalTime();\n        ArrayList<SecurityEvent> output = new ArrayList<SecurityEvent>();\n        try {\n            SecurityLog.readPreviousEvents(output);\n            int enabledUser = getSecurityLoggingEnabledUser();\n            if (enabledUser != UserHandle.USER_ALL) {\n                SecurityLog.redactEvents(output, enabledUser);\n            }\n            return new ParceledListSlice<SecurityEvent>(output);\n        } catch (IOException e) {\n            Slogf.w(LOG_TAG, \"Fail to read previous events\" , e);\n            return new ParceledListSlice<SecurityEvent>(Collections.<SecurityEvent>emptyList());\n        }\n    }\n\n    @Override\n    public ParceledListSlice<SecurityEvent> retrieveSecurityLogs(ComponentName admin,\n            String packageName) {\n        if (!mHasFeature) {\n            return null;\n        }\n\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n        if (isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(isOrganizationOwnedDeviceWithManagedProfile()\n                    || areAllUsersAffiliatedWithDeviceLocked());\n\n            enforcePermission(MANAGE_DEVICE_POLICY_SECURITY_LOGGING, caller.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            if (admin != null) {\n                Preconditions.checkCallAuthorization(\n                        isProfileOwnerOfOrganizationOwnedDevice(caller)\n                        || isDefaultDeviceOwner(caller));\n            } else {\n                // A delegate app passes a null admin component, which is expected\n                Preconditions.checkCallAuthorization(\n                        isCallerDelegate(caller, DELEGATION_SECURITY_LOGGING));\n            }\n            Preconditions.checkCallAuthorization(isOrganizationOwnedDeviceWithManagedProfile()\n                    || areAllUsersAffiliatedWithDeviceLocked());\n        }\n\n        if (!mInjector.securityLogGetLoggingEnabledProperty()) {\n            return null;\n        }\n\n        recordSecurityLogRetrievalTime();\n\n        List<SecurityEvent> logs = mSecurityLogMonitor.retrieveLogs();\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.RETRIEVE_SECURITY_LOGS)\n                .setAdmin(caller.getPackageName())\n                .write();\n        return logs != null ? new ParceledListSlice<SecurityEvent>(logs) : null;\n    }\n\n    @Override\n    public long forceSecurityLogs() {\n        Preconditions.checkCallAuthorization(isAdb(getCallerIdentity())\n                        || hasCallingOrSelfPermission(permission.FORCE_DEVICE_POLICY_MANAGER_LOGS),\n                \"Caller must be shell or hold FORCE_DEVICE_POLICY_MANAGER_LOGS to call \"\n                        + \"forceSecurityLogs\");\n        if (!mInjector.securityLogGetLoggingEnabledProperty()) {\n            throw new IllegalStateException(\"logging is not available\");\n        }\n        return mSecurityLogMonitor.forceLogs();\n    }\n\n    @Override\n    public boolean isUninstallInQueue(final String packageName) {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n\n        UserPackage packageUserPair = UserPackage.of(caller.getUserId(), packageName);\n        synchronized (getLockObject()) {\n            return mPackagesToRemove.contains(packageUserPair);\n        }\n    }\n\n    @Override\n    public void uninstallPackageWithActiveAdmins(final String packageName) {\n        Preconditions.checkArgument(!TextUtils.isEmpty(packageName));\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n\n        final int userId = caller.getUserId();\n        enforceUserUnlocked(userId);\n\n        final ComponentName profileOwner = getProfileOwnerAsUser(userId);\n        if (profileOwner != null && packageName.equals(profileOwner.getPackageName())) {\n            throw new IllegalArgumentException(\"Cannot uninstall a package with a profile owner\");\n        }\n\n        final ComponentName deviceOwner = getDeviceOwnerComponent(/* callingUserOnly= */ false);\n        if (getDeviceOwnerUserId() == userId && deviceOwner != null\n                && packageName.equals(deviceOwner.getPackageName())) {\n            throw new IllegalArgumentException(\"Cannot uninstall a package with a device owner\");\n        }\n\n        final UserPackage packageUserPair = UserPackage.of(userId, packageName);\n        synchronized (getLockObject()) {\n            mPackagesToRemove.add(packageUserPair);\n        }\n\n        // All active admins on the user.\n        final List<ComponentName> allActiveAdmins = getActiveAdmins(userId);\n\n        // Active admins in the target package.\n        final List<ComponentName> packageActiveAdmins = new ArrayList<>();\n        if (allActiveAdmins != null) {\n            for (ComponentName activeAdmin : allActiveAdmins) {\n                if (packageName.equals(activeAdmin.getPackageName())) {\n                    packageActiveAdmins.add(activeAdmin);\n                    removeActiveAdmin(activeAdmin, userId);\n                }\n            }\n        }\n        if (packageActiveAdmins.size() == 0) {\n            startUninstallIntent(packageName, userId);\n        } else {\n            mHandler.postDelayed(new Runnable() {\n                @Override\n                public void run() {\n                    for (ComponentName activeAdmin : packageActiveAdmins) {\n                        removeAdminArtifacts(activeAdmin, userId);\n                    }\n                    startUninstallIntent(packageName, userId);\n                }\n            }, DEVICE_ADMIN_DEACTIVATE_TIMEOUT); // Start uninstall after timeout anyway.\n        }\n    }\n\n    @Override\n    public boolean isDeviceProvisioned() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(caller));\n\n        synchronized (getLockObject()) {\n            return getUserDataUnchecked(UserHandle.USER_SYSTEM).mUserSetupComplete;\n        }\n    }\n\n    private boolean isCurrentUserDemo() {\n        if (UserManager.isDeviceInDemoMode(mContext)) {\n            final int userId = mInjector.userHandleGetCallingUserId();\n            return mInjector.binderWithCleanCallingIdentity(\n                    () -> mUserManager.getUserInfo(userId).isDemo());\n        }\n        return false;\n    }\n\n    private void removePackageIfRequired(final String packageName, final int userId) {\n        if (!packageHasActiveAdmins(packageName, userId)) {\n            // Will not do anything if uninstall was not requested or was already started.\n            startUninstallIntent(packageName, userId);\n        }\n    }\n\n    private void startUninstallIntent(final String packageName, final int userId) {\n        final UserPackage packageUserPair = UserPackage.of(userId, packageName);\n        synchronized (getLockObject()) {\n            if (!mPackagesToRemove.contains(packageUserPair)) {\n                // Do nothing if uninstall was not requested or was already started.\n                return;\n            }\n            mPackagesToRemove.remove(packageUserPair);\n        }\n        if (!isPackageInstalledForUser(packageName, userId)) {\n            // Package does not exist. Nothing to do.\n            return;\n        }\n\n        try { // force stop the package before uninstalling\n            mInjector.getIActivityManager().forceStopPackage(packageName, userId);\n        } catch (RemoteException re) {\n            Slogf.e(LOG_TAG, \"Failure talking to ActivityManager while force stopping package\");\n        }\n        final Uri packageURI = Uri.parse(\"package:\" + packageName);\n        final Intent uninstallIntent = new Intent(Intent.ACTION_UNINSTALL_PACKAGE, packageURI);\n        uninstallIntent.setFlags(FLAG_ACTIVITY_NEW_TASK);\n        mContext.startActivityAsUser(uninstallIntent, UserHandle.of(userId));\n    }\n\n    /**\n     * Removes the admin from the policy. Ideally called after the admin's\n     * {@link DeviceAdminReceiver#onDisabled(Context, Intent)} has been successfully completed.\n     *\n     * @param adminReceiver The admin to remove\n     * @param userHandle The user for which this admin has to be removed.\n     */\n    private void removeAdminArtifacts(final ComponentName adminReceiver, final int userHandle) {\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n            if (admin == null) {\n                return;\n            }\n            final DevicePolicyData policy = getUserData(userHandle);\n            final boolean doProxyCleanup = admin.info.usesPolicy(\n                    DeviceAdminInfo.USES_POLICY_SETS_GLOBAL_PROXY);\n            policy.mAdminList.remove(admin);\n            policy.mAdminMap.remove(adminReceiver);\n            policy.validatePasswordOwner();\n            if (doProxyCleanup) {\n                resetGlobalProxyLocked(policy);\n            }\n            pushActiveAdminPackagesLocked(userHandle);\n            saveSettingsLocked(userHandle);\n            updateMaximumTimeToLockLocked(userHandle);\n            policy.mRemovingAdmins.remove(adminReceiver);\n            pushScreenCapturePolicy(userHandle);\n\n            Slogf.i(LOG_TAG, \"Device admin \" + adminReceiver + \" removed from user \" + userHandle);\n        }\n        pushMeteredDisabledPackages(userHandle);\n        // The removed admin might have disabled camera, so update user\n        // restrictions.\n        pushUserRestrictions(userHandle);\n    }\n\n    @Override\n    public void setDeviceProvisioningConfigApplied() {\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            policy.mDeviceProvisioningConfigApplied = true;\n            saveSettingsLocked(UserHandle.USER_SYSTEM);\n        }\n    }\n\n    @Override\n    public boolean isDeviceProvisioningConfigApplied() {\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            return policy.mDeviceProvisioningConfigApplied;\n        }\n    }\n\n    /**\n     * Force update internal persistent state from Settings.Secure.USER_SETUP_COMPLETE.\n     *\n     * It's added for testing only. Please use this API carefully if it's used by other system app\n     * and bare in mind Settings.Secure.USER_SETUP_COMPLETE can be modified by user and other system\n     * apps.\n     */\n    @Override\n    public void forceUpdateUserSetupComplete(@UserIdInt int userId) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        boolean isUserCompleted = mInjector.settingsSecureGetIntForUser(\n                Settings.Secure.USER_SETUP_COMPLETE, 0, userId) != 0;\n        DevicePolicyData policy = getUserData(userId);\n        policy.mUserSetupComplete = isUserCompleted;\n        mStateCache.setDeviceProvisioned(isUserCompleted);\n        synchronized (getLockObject()) {\n            saveSettingsLocked(userId);\n        }\n    }\n\n    @Override\n    public void setBackupServiceEnabled(ComponentName admin, boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isProfileOwner(caller) || isFinancedDeviceOwner(caller));\n\n        toggleBackupServiceActive(caller.getUserId(), enabled);\n    }\n\n    @Override\n    public boolean isBackupServiceEnabled(ComponentName admin) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isProfileOwner(caller) || isFinancedDeviceOwner(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            synchronized (getLockObject()) {\n                try {\n                    IBackupManager ibm = mInjector.getIBackupManager();\n                    return ibm != null && ibm.isBackupServiceActive(caller.getUserId());\n                } catch (RemoteException e) {\n                    throw new IllegalStateException(\"Failed requesting backup service state.\", e);\n                }\n            }\n        });\n    }\n\n    @Override\n    public boolean bindDeviceAdminServiceAsUser(\n            @NonNull ComponentName admin, @NonNull IApplicationThread caller,\n            @Nullable IBinder activtiyToken, @NonNull Intent serviceIntent,\n            @NonNull IServiceConnection connection, long flags, @UserIdInt int targetUserId) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(admin);\n        Objects.requireNonNull(caller);\n        Objects.requireNonNull(serviceIntent);\n        Preconditions.checkArgument(\n                serviceIntent.getComponent() != null || serviceIntent.getPackage() != null,\n                \"Service intent must be explicit (with a package name or component): \"\n                        + serviceIntent);\n        Objects.requireNonNull(connection);\n        Preconditions.checkArgument(mInjector.userHandleGetCallingUserId() != targetUserId,\n                \"target user id must be different from the calling user id\");\n\n        if (!getBindDeviceAdminTargetUsers(admin).contains(UserHandle.of(targetUserId))) {\n            throw new SecurityException(\"Not allowed to bind to target user id\");\n        }\n\n        final String targetPackage;\n        synchronized (getLockObject()) {\n            targetPackage = getOwnerPackageNameForUserLocked(targetUserId);\n        }\n\n        final long callingIdentity = mInjector.binderClearCallingIdentity();\n        try {\n            // Validate and sanitize the incoming service intent.\n            final Intent sanitizedIntent =\n                    createCrossUserServiceIntent(serviceIntent, targetPackage, targetUserId);\n            if (sanitizedIntent == null) {\n                // Fail, cannot lookup the target service.\n                return false;\n            }\n            // Ask ActivityManager to bind it. Notice that we are binding the service with the\n            // caller app instead of DevicePolicyManagerService.\n            return mInjector.getIActivityManager().bindService(\n                    caller, activtiyToken, serviceIntent,\n                    serviceIntent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                    connection, flags, mContext.getOpPackageName(),\n                    targetUserId) != 0;\n        } catch (RemoteException ex) {\n            // Same process, should not happen.\n        } finally {\n            mInjector.binderRestoreCallingIdentity(callingIdentity);\n        }\n\n        // Failed to bind.\n        return false;\n    }\n\n    @Override\n    public @NonNull List<UserHandle> getBindDeviceAdminTargetUsers(@NonNull ComponentName admin) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n        Objects.requireNonNull(admin);\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            final int callingUserId = caller.getUserId();\n            return mInjector.binderWithCleanCallingIdentity(() -> {\n                ArrayList<UserHandle> targetUsers = new ArrayList<>();\n                if (!isDeviceOwner(admin, callingUserId)) {\n                    // Profile owners can only bind to the device owner.\n                    if (canUserBindToDeviceOwnerLocked(callingUserId)) {\n                        targetUsers.add(UserHandle.of(mOwners.getDeviceOwnerUserId()));\n                    }\n                } else {\n                    // Caller is the device owner: Look for profile owners that it can bind to.\n                    final List<UserInfo> userInfos = mUserManager.getAliveUsers();\n                    for (int i = 0; i < userInfos.size(); i++) {\n                        final int userId = userInfos.get(i).id;\n                        if (userId != callingUserId && canUserBindToDeviceOwnerLocked(userId)) {\n                            targetUsers.add(UserHandle.of(userId));\n                        }\n                    }\n                }\n\n                return targetUsers;\n            });\n        }\n    }\n\n    private boolean canUserBindToDeviceOwnerLocked(int userId) {\n        // There has to be a device owner, under another user id.\n        if (!mOwners.hasDeviceOwner() || userId == mOwners.getDeviceOwnerUserId()) {\n            return false;\n        }\n\n        // The user must have a profile owner that belongs to the same package as the device owner.\n        if (!mOwners.hasProfileOwner(userId) || !TextUtils.equals(\n                mOwners.getDeviceOwnerPackageName(), mOwners.getProfileOwnerPackage(userId))) {\n            return false;\n        }\n\n        // The user must be affiliated.\n        return isUserAffiliatedWithDeviceLocked(userId);\n    }\n\n    private boolean hasIncompatibleAccountsOnAnyUser() {\n        if (mHasIncompatibleAccounts == null) {\n            // Hasn't loaded for the first time yet - assume the worst\n            return true;\n        }\n\n        for (boolean hasIncompatible : mHasIncompatibleAccounts.values()) {\n            if (hasIncompatible) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private boolean hasIncompatibleAccounts(int userId) {\n        return mHasIncompatibleAccounts == null ? true\n                : mHasIncompatibleAccounts.getOrDefault(userId, /* default= */ false);\n    }\n\n    /**\n     * Return true if a given user has any accounts that'll prevent installing a device or profile\n     * owner {@code owner}.\n     * - If the user has no accounts, then return false.\n     * - Otherwise, if the owner is unknown (== null), or is not test-only, then return true.\n     * - Otherwise, if there's any account that does not have ..._ALLOWED, or does have\n     *   ..._DISALLOWED, return true.\n     * - Otherwise return false.\n     *\n     * If the caller is *not* ADB, it also returns true.  The returned value shouldn't be used\n     * when the caller is not ADB.\n     *\n     * DO NOT CALL IT WITH THE DPMS LOCK HELD.\n     */\n    private boolean hasIncompatibleAccountsOrNonAdbNoLock(CallerIdentity caller,\n            int userId, @Nullable ComponentName owner) {\n        if (!isAdb(caller)) {\n            return true;\n        }\n        wtfIfInLock();\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            AccountManager am =\n                    mContext.createContextAsUser(UserHandle.of(userId), /* flags= */ 0)\n                            .getSystemService(AccountManager.class);\n            Account[] accounts = am.getAccounts();\n            if (accounts.length == 0) {\n                return false;\n            }\n            synchronized (getLockObject()) {\n                if (owner == null || !isAdminTestOnlyLocked(owner, userId)) {\n                    Slogf.w(LOG_TAG,\n                            \"Non test-only owner can't be installed with existing accounts.\");\n                    return true;\n                }\n            }\n\n            boolean compatible = !hasIncompatibleAccounts(userId);\n            if (compatible) {\n                Slogf.w(LOG_TAG, \"All accounts are compatible\");\n            } else {\n                Slogf.e(LOG_TAG, \"Found incompatible accounts\");\n            }\n            return !compatible;\n        });\n    }\n\n    ThreadPoolExecutor calculateHasIncompatibleAccountsExecutor = new ThreadPoolExecutor(\n            1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>());\n\n    @Override\n    public void calculateHasIncompatibleAccounts() {\n        if (calculateHasIncompatibleAccountsExecutor.getQueue().size() > 1) {\n            return;\n        }\n        new CalculateHasIncompatibleAccountsTask().executeOnExecutor(\n                calculateHasIncompatibleAccountsExecutor, null);\n    }\n\n    @Nullable\n    private volatile Map<Integer, Boolean> mHasIncompatibleAccounts;\n\n    class CalculateHasIncompatibleAccountsTask extends AsyncTask<\n            Void, Void, Map<Integer, Boolean>> {\n        private static final String[] FEATURE_ALLOW =\n                {DevicePolicyManager.ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED};\n        private static final String[] FEATURE_DISALLOW =\n                {DevicePolicyManager.ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED};\n\n        @Override\n        protected Map<Integer, Boolean> doInBackground(Void... args) {\n            List<UserInfo> users = mUserManagerInternal.getUsers(/* excludeDying= */ true);\n            Map<Integer, Boolean> results = new HashMap<>();\n            for (UserInfo userInfo : users) {\n                results.put(userInfo.id, userHasIncompatibleAccounts(userInfo.id));\n            }\n\n            return results;\n        }\n\n        private boolean userHasIncompatibleAccounts(int id) {\n            AccountManager am = mContext.createContextAsUser(UserHandle.of(id), /* flags= */ 0)\n                    .getSystemService(AccountManager.class);\n            Account[] accounts = am.getAccounts();\n\n            for (Account account : accounts) {\n                if (hasAccountFeatures(am, account, FEATURE_DISALLOW)) {\n                    return true;\n                }\n                if (!hasAccountFeatures(am, account, FEATURE_ALLOW)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        @Override\n        protected void onPostExecute(Map<Integer, Boolean> results) {\n            mHasIncompatibleAccounts = Collections.unmodifiableMap(results);\n\n            Slogf.i(LOG_TAG, \"Finished calculating hasIncompatibleAccountsTask\");\n        }\n\n        private static boolean hasAccountFeatures(AccountManager am, Account account,\n                String[] features) {\n            try {\n                return am.hasFeatures(account, features, null, null).getResult();\n            } catch (Exception e) {\n                Slogf.w(LOG_TAG, \"Failed to get account feature\", e);\n                return false;\n            }\n        }\n    };\n\n    private boolean isAdb(CallerIdentity caller) {\n        return isShellUid(caller) || isRootUid(caller);\n    }\n\n    @Override\n    public void setNetworkLoggingEnabled(@Nullable ComponentName admin,\n            @NonNull String packageName, boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n        final boolean isManagedProfileOwner = isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId());\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isDefaultDeviceOwner(caller) || isManagedProfileOwner))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_NETWORK_LOGGING)));\n\n        synchronized (getLockObject()) {\n            if (enabled == isNetworkLoggingEnabledInternalLocked()) {\n                // already in the requested state\n                return;\n            }\n            final ActiveAdmin activeAdmin = getDeviceOrProfileOwnerAdminLocked(caller.getUserId());\n            activeAdmin.isNetworkLoggingEnabled = enabled;\n            if (!enabled) {\n                activeAdmin.numNetworkLoggingNotifications = 0;\n                activeAdmin.lastNetworkLoggingNotificationTimeMs = 0;\n            }\n            saveSettingsLocked(caller.getUserId());\n            setNetworkLoggingActiveInternal(enabled);\n\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_NETWORK_LOGGING_ENABLED)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ admin == null)\n                    .setInt(enabled ? 1 : 0)\n                    .setStrings(isManagedProfileOwner\n                            ? LOG_TAG_PROFILE_OWNER : LOG_TAG_DEVICE_OWNER)\n                    .write();\n        }\n    }\n\n    private void setNetworkLoggingActiveInternal(boolean active) {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            boolean shouldSendNotification = false;\n            synchronized (getLockObject()) {\n                if (active) {\n                    if (mNetworkLogger == null) {\n                        final int affectedUserId = getNetworkLoggingAffectedUser();\n                        mNetworkLogger = new NetworkLogger(this,\n                                mInjector.getPackageManagerInternal(),\n                                affectedUserId == UserHandle.USER_SYSTEM\n                                        ? UserHandle.USER_ALL : affectedUserId);\n                    }\n                    if (!mNetworkLogger.startNetworkLogging()) {\n                        mNetworkLogger = null;\n                        Slogf.wtf(LOG_TAG, \"Network logging could not be started due to the logging\"\n                                + \" service not being available yet.\");\n                    }\n                    maybePauseDeviceWideLoggingLocked();\n                    shouldSendNotification = shouldSendNetworkLoggingNotificationLocked();\n                } else {\n                    if (mNetworkLogger != null && !mNetworkLogger.stopNetworkLogging()) {\n                        Slogf.wtf(LOG_TAG, \"Network logging could not be stopped due to the logging\"\n                                + \" service not being available yet.\");\n                    }\n                    mNetworkLogger = null;\n                }\n            }\n            if (active) {\n                if (shouldSendNotification) {\n                    mHandler.post(() -> handleSendNetworkLoggingNotification());\n                }\n            } else {\n                mHandler.post(() -> handleCancelNetworkLoggingNotification());\n            }\n        });\n    }\n\n    private @UserIdInt int getNetworkLoggingAffectedUser() {\n        synchronized (getLockObject()) {\n            if (mOwners.hasDeviceOwner()) {\n                return mOwners.getDeviceOwnerUserId();\n            } else {\n                return mInjector.binderWithCleanCallingIdentity(\n                        () -> getManagedUserId());\n            }\n        }\n    }\n\n    private ActiveAdmin getNetworkLoggingControllingAdminLocked() {\n        int affectedUserId = getNetworkLoggingAffectedUser();\n        if (affectedUserId < 0) {\n            return null;\n        }\n        return getDeviceOrProfileOwnerAdminLocked(affectedUserId);\n    }\n\n    @Override\n    public long forceNetworkLogs() {\n        Preconditions.checkCallAuthorization(isAdb(getCallerIdentity())\n                || hasCallingOrSelfPermission(permission.FORCE_DEVICE_POLICY_MANAGER_LOGS),\n                \"Caller must be shell or hold FORCE_DEVICE_POLICY_MANAGER_LOGS to call \"\n                        + \"forceNetworkLogs\");\n        synchronized (getLockObject()) {\n            if (!isNetworkLoggingEnabledInternalLocked()) {\n                throw new IllegalStateException(\"logging is not available\");\n            }\n            if (mNetworkLogger != null) {\n                return mInjector.binderWithCleanCallingIdentity(\n                        () -> mNetworkLogger.forceBatchFinalization());\n            }\n            return 0;\n        }\n    }\n\n    /** Pauses security and network logging if there are unaffiliated users on the device */\n    @GuardedBy(\"getLockObject()\")\n    private void maybePauseDeviceWideLoggingLocked() {\n        if (!areAllUsersAffiliatedWithDeviceLocked()) {\n            if (mOwners.hasDeviceOwner()) {\n                Slogf.i(LOG_TAG, \"There are unaffiliated users, network logging will be \"\n                        + \"paused if enabled.\");\n                if (mNetworkLogger != null) {\n                    mNetworkLogger.pause();\n                }\n            }\n            // TODO: We need to also enable this when someone is managing using permission\n            if (!isOrganizationOwnedDeviceWithManagedProfile()) {\n                Slogf.i(LOG_TAG,\n                        \"Not org-owned managed profile device, security logging will be \"\n                                + \"paused if enabled.\");\n                mSecurityLogMonitor.pause();\n            }\n        }\n    }\n\n    /** Resumes security and network logging (if they are enabled) if all users are affiliated */\n    @GuardedBy(\"getLockObject()\")\n    private void maybeResumeDeviceWideLoggingLocked() {\n        boolean allUsersAffiliated = areAllUsersAffiliatedWithDeviceLocked();\n        boolean orgOwnedProfileDevice = isOrganizationOwnedDeviceWithManagedProfile();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (allUsersAffiliated || orgOwnedProfileDevice) {\n                mSecurityLogMonitor.resume();\n            }\n            // If there is no device owner, then per-user network logging may be enabled for the\n            // managed profile. In which case, all users do not need to be affiliated.\n            if (allUsersAffiliated || !mOwners.hasDeviceOwner()) {\n                if (mNetworkLogger != null) {\n                    mNetworkLogger.resume();\n                }\n            }\n        });\n    }\n\n    /** Deletes any security and network logs that might have been collected so far */\n    @GuardedBy(\"getLockObject()\")\n    private void discardDeviceWideLogsLocked() {\n        mSecurityLogMonitor.discardLogs();\n        if (mNetworkLogger != null) {\n            mNetworkLogger.discardLogs();\n        }\n        // TODO: We should discard pre-boot security logs here too, as otherwise those\n        // logs (which might contain data from the user just removed) will be\n        // available after next boot.\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public boolean isNetworkLoggingEnabled(@Nullable ComponentName admin,\n            @NonNull String packageName) {\n        if (!mHasFeature) {\n            return false;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                &&  (isDefaultDeviceOwner(caller)\n                || (isProfileOwner(caller) && isManagedProfile(caller.getUserId()))))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_NETWORK_LOGGING))\n                || hasCallingOrSelfPermission(permission.MANAGE_USERS));\n\n        synchronized (getLockObject()) {\n            return isNetworkLoggingEnabledInternalLocked();\n        }\n    }\n\n    private boolean isNetworkLoggingEnabledInternalLocked() {\n        ActiveAdmin activeAdmin = getNetworkLoggingControllingAdminLocked();\n        return (activeAdmin != null) && activeAdmin.isNetworkLoggingEnabled;\n    }\n\n    /*\n     * A maximum of 1200 events are returned, and the total marshalled size is in the order of\n     * 100kB, so returning a List instead of ParceledListSlice is acceptable.\n     * Ideally this would be done with ParceledList, however it only supports homogeneous types.\n     *\n     * @see NetworkLoggingHandler#MAX_EVENTS_PER_BATCH\n     */\n    @Override\n    public List<NetworkEvent> retrieveNetworkLogs(@Nullable ComponentName admin,\n            @NonNull String packageName, long batchToken) {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n        final boolean isManagedProfileOwner = isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId());\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                &&  (isDefaultDeviceOwner(caller) || isManagedProfileOwner))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_NETWORK_LOGGING)));\n        if (mOwners.hasDeviceOwner()) {\n            checkAllUsersAreAffiliatedWithDevice();\n        }\n\n        synchronized (getLockObject()) {\n            if (mNetworkLogger == null || !isNetworkLoggingEnabledInternalLocked()) {\n                return null;\n            }\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.RETRIEVE_NETWORK_LOGS)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ admin == null)\n                    .setStrings(isManagedProfileOwner\n                            ? LOG_TAG_PROFILE_OWNER : LOG_TAG_DEVICE_OWNER)\n                    .write();\n\n            final long currentTime = System.currentTimeMillis();\n            DevicePolicyData policyData = getUserData(caller.getUserId());\n            if (currentTime > policyData.mLastNetworkLogsRetrievalTime) {\n                policyData.mLastNetworkLogsRetrievalTime = currentTime;\n                saveSettingsLocked(caller.getUserId());\n            }\n            return mNetworkLogger.retrieveLogs(batchToken);\n        }\n    }\n\n    /**\n     * Returns whether it's time to post another network logging notification. When returning true,\n     * this method has the side-effect of updating the recorded last network logging notification\n     * time to now.\n     */\n    private boolean shouldSendNetworkLoggingNotificationLocked() {\n        ensureLocked();\n        // Send a network logging notification if the admin is a device owner, not profile owner.\n        final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n        if (deviceOwner == null || !deviceOwner.isNetworkLoggingEnabled) {\n            return false;\n        }\n        if (deviceOwner.numNetworkLoggingNotifications\n                >= ActiveAdmin.DEF_MAXIMUM_NETWORK_LOGGING_NOTIFICATIONS_SHOWN) {\n            return false;\n        }\n        final long now = System.currentTimeMillis();\n        if (now - deviceOwner.lastNetworkLoggingNotificationTimeMs < MS_PER_DAY) {\n            return false;\n        }\n        deviceOwner.numNetworkLoggingNotifications++;\n        if (deviceOwner.numNetworkLoggingNotifications\n                >= ActiveAdmin.DEF_MAXIMUM_NETWORK_LOGGING_NOTIFICATIONS_SHOWN) {\n            deviceOwner.lastNetworkLoggingNotificationTimeMs = 0;\n        } else {\n            deviceOwner.lastNetworkLoggingNotificationTimeMs = now;\n        }\n        saveSettingsLocked(deviceOwner.getUserHandle().getIdentifier());\n        return true;\n    }\n\n    private void handleSendNetworkLoggingNotification() {\n        final PackageManagerInternal pm = mInjector.getPackageManagerInternal();\n        final Intent intent = new Intent(DevicePolicyManager.ACTION_SHOW_DEVICE_MONITORING_DIALOG);\n        intent.setPackage(pm.getSystemUiServiceComponent().getPackageName());\n        mNetworkLoggingNotificationUserId = getCurrentForegroundUserId();\n        // Simple notification clicks are immutable\n        final PendingIntent pendingIntent = PendingIntent.getBroadcastAsUser(mContext, 0, intent,\n                PendingIntent.FLAG_IMMUTABLE, UserHandle.CURRENT);\n\n        final String title = getNetworkLoggingTitle();\n        final String text = getNetworkLoggingText();\n        Notification notification =\n                new Notification.Builder(mContext, SystemNotificationChannels.DEVICE_ADMIN)\n                .setSmallIcon(R.drawable.ic_info_outline)\n                .setContentTitle(title)\n                .setContentText(text)\n                .setTicker(title)\n                .setShowWhen(true)\n                .setContentIntent(pendingIntent)\n                .setStyle(new Notification.BigTextStyle().bigText(text))\n                .build();\n        Slogf.i(LOG_TAG, \"Sending network logging notification to user %d\",\n                mNetworkLoggingNotificationUserId);\n        mInjector.getNotificationManager().notifyAsUser(/* tag= */ null,\n                SystemMessage.NOTE_NETWORK_LOGGING, notification,\n                UserHandle.of(mNetworkLoggingNotificationUserId));\n    }\n\n    private String getNetworkLoggingTitle() {\n        return getUpdatableString(\n                NETWORK_LOGGING_TITLE, R.string.network_logging_notification_title);\n    }\n\n    private String getNetworkLoggingText() {\n        return getUpdatableString(\n                NETWORK_LOGGING_MESSAGE, R.string.network_logging_notification_text);\n    }\n\n    private void handleCancelNetworkLoggingNotification() {\n        if (mNetworkLoggingNotificationUserId == UserHandle.USER_NULL) {\n            // Happens when setNetworkLoggingActive(false) is called before called with true\n            Slogf.d(LOG_TAG, \"Not cancelling network logging notification for USER_NULL\");\n            return;\n        }\n\n        Slogf.i(LOG_TAG, \"Cancelling network logging notification for user %d\",\n                mNetworkLoggingNotificationUserId);\n        mInjector.getNotificationManager().cancelAsUser(/* tag= */ null,\n                SystemMessage.NOTE_NETWORK_LOGGING,\n                UserHandle.of(mNetworkLoggingNotificationUserId));\n        mNetworkLoggingNotificationUserId = UserHandle.USER_NULL;\n    }\n\n    /**\n     * Return the package name of owner in a given user.\n     */\n    private String getOwnerPackageNameForUserLocked(int userId) {\n        return mOwners.getDeviceOwnerUserId() == userId\n                ? mOwners.getDeviceOwnerPackageName()\n                : mOwners.getProfileOwnerPackage(userId);\n    }\n\n    /**\n     * @param rawIntent Original service intent specified by caller. It must be explicit.\n     * @param expectedPackageName The expected package name of the resolved service.\n     * @return Intent that have component explicitly set. {@code null} if no service is resolved\n     *     with the given intent.\n     * @throws SecurityException if the intent is resolved to an invalid service.\n     */\n    private Intent createCrossUserServiceIntent(\n            @NonNull Intent rawIntent, @NonNull String expectedPackageName,\n            @UserIdInt int targetUserId) throws RemoteException, SecurityException {\n        ResolveInfo info = mIPackageManager.resolveService(\n                rawIntent,\n                rawIntent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                0,  // flags\n                targetUserId);\n        if (info == null || info.serviceInfo == null) {\n            Slogf.e(LOG_TAG, \"Fail to look up the service: %s or user %d is not running\", rawIntent,\n                    targetUserId);\n            return null;\n        }\n        if (!expectedPackageName.equals(info.serviceInfo.packageName)) {\n            throw new SecurityException(\"Only allow to bind service in \" + expectedPackageName);\n        }\n        // STOPSHIP(b/37624960): Remove info.serviceInfo.exported before release.\n        if (info.serviceInfo.exported && !BIND_DEVICE_ADMIN.equals(info.serviceInfo.permission)) {\n            throw new SecurityException(\n                    \"Service must be protected by BIND_DEVICE_ADMIN permission\");\n        }\n        // It is the system server to bind the service, it would be extremely dangerous if it\n        // can be exploited to bind any service. Set the component explicitly to make sure we\n        // do not bind anything accidentally.\n        rawIntent.setComponent(info.serviceInfo.getComponentName());\n        return rawIntent;\n    }\n\n    @Override\n    public long getLastSecurityLogRetrievalTime() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || canManageUsers(caller));\n        return getUserData(UserHandle.USER_SYSTEM).mLastSecurityLogRetrievalTime;\n     }\n\n    @Override\n    public long getLastBugReportRequestTime() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || canManageUsers(caller));\n        return getUserData(UserHandle.USER_SYSTEM).mLastBugReportRequestTime;\n     }\n\n    @Override\n    public long getLastNetworkLogRetrievalTime() {\n        final CallerIdentity caller = getCallerIdentity();\n\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || (isProfileOwner(caller) && isManagedProfile(caller.getUserId()))\n                || canManageUsers(caller));\n        final int affectedUserId = getNetworkLoggingAffectedUser();\n        return affectedUserId >= 0 ? getUserData(affectedUserId).mLastNetworkLogsRetrievalTime : -1;\n    }\n\n    @Override\n    public boolean setResetPasswordToken(ComponentName admin, String callerPackageName,\n            byte[] token) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return false;\n        }\n        if (token == null || token.length < 32) {\n            throw new IllegalArgumentException(\"token must be at least 32-byte long\");\n        }\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n        final int userId = caller.getUserId();\n\n        if (isUnicornFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                    caller.getPackageName(),\n                    userId);\n            Long currentTokenHandle = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.RESET_PASSWORD_TOKEN,\n                    enforcingAdmin,\n                    userId);\n            long tokenHandle = addEscrowToken(\n                    token, currentTokenHandle == null ? 0 : currentTokenHandle, userId);\n            if (tokenHandle == 0) {\n                return false;\n            }\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.RESET_PASSWORD_TOKEN,\n                    enforcingAdmin,\n                    new LongPolicyValue(tokenHandle),\n                    userId);\n            return true;\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                DevicePolicyData policy = getUserData(userId);\n                policy.mPasswordTokenHandle = addEscrowToken(\n                        token, policy.mPasswordTokenHandle, userId);\n                saveSettingsLocked(userId);\n                return policy.mPasswordTokenHandle != 0;\n            }\n        }\n    }\n\n    private long addEscrowToken(byte[] token, long currentPasswordTokenHandle, int userId) {\n        resetEscrowToken(currentPasswordTokenHandle, userId);\n        return mInjector.binderWithCleanCallingIdentity(() -> mLockPatternUtils.addEscrowToken(\n                token, userId, /* EscrowTokenStateChangeCallback= */ null));\n    }\n\n    private boolean resetEscrowToken(long tokenHandle, int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            if (tokenHandle != 0) {\n                return mLockPatternUtils.removeEscrowToken(tokenHandle, userId);\n            }\n            return false;\n        });\n    }\n\n    @Override\n    public boolean clearResetPasswordToken(ComponentName admin, String callerPackageName) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return false;\n        }\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n        final int userId = caller.getUserId();\n        boolean result = false;\n\n        if (isUnicornFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                    caller.getPackageName(),\n                    userId);\n            Long currentTokenHandle = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.RESET_PASSWORD_TOKEN,\n                    enforcingAdmin,\n                    userId);\n            if (currentTokenHandle != null) {\n                result = resetEscrowToken(currentTokenHandle, userId);\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.RESET_PASSWORD_TOKEN,\n                        enforcingAdmin,\n                        userId);\n            }\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                DevicePolicyData policy = getUserData(userId);\n                if (policy.mPasswordTokenHandle != 0) {\n                    result = resetEscrowToken(policy.mPasswordTokenHandle, userId);\n                    policy.mPasswordTokenHandle = 0;\n                    saveSettingsLocked(userId);\n                }\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isResetPasswordTokenActive(ComponentName admin, String callerPackageName) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return false;\n        }\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n        int userId = caller.getUserId();\n\n        if (isUnicornFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                    caller.getPackageName(),\n                    userId);\n            Long currentTokenHandle = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.RESET_PASSWORD_TOKEN,\n                    enforcingAdmin,\n                    userId);\n            return isResetPasswordTokenActiveForUserLocked(\n                    currentTokenHandle == null ? 0 : currentTokenHandle, userId);\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                DevicePolicyData policy = getUserData(userId);\n                return isResetPasswordTokenActiveForUserLocked(policy.mPasswordTokenHandle, userId);\n            }\n        }\n    }\n\n    private boolean isResetPasswordTokenActiveForUserLocked(\n            long passwordTokenHandle, int userHandle) {\n        if (passwordTokenHandle != 0) {\n            return mInjector.binderWithCleanCallingIdentity(() ->\n                    mLockPatternUtils.isEscrowTokenActive(passwordTokenHandle, userHandle));\n        }\n        return false;\n    }\n\n    @Override\n    public boolean resetPasswordWithToken(ComponentName admin, String callerPackageName,\n            String passwordOrNull, byte[] token,\n            int flags) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return false;\n        }\n        Objects.requireNonNull(token);\n\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n\n        int userId = caller.getUserId();\n        boolean result = false;\n        final String password = passwordOrNull != null ? passwordOrNull : \"\";\n\n        if (isUnicornFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                    caller.getPackageName(),\n                    userId);\n            Long currentTokenHandle = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.RESET_PASSWORD_TOKEN,\n                    enforcingAdmin,\n                    userId);\n            if (currentTokenHandle != null && currentTokenHandle != 0) {\n                result = resetPasswordInternal(password, currentTokenHandle, token, flags, caller);\n            } else {\n                Slogf.w(LOG_TAG, \"No saved token handle\");\n            }\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                DevicePolicyData policy = getUserData(userId);\n                if (policy.mPasswordTokenHandle != 0) {\n                    result = resetPasswordInternal(\n                            password, policy.mPasswordTokenHandle, token, flags, caller);\n                } else {\n                    Slogf.w(LOG_TAG, \"No saved token handle\");\n                }\n            }\n        }\n\n        if (result) {\n            if (isUnicornFlagEnabled()) {\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.RESET_PASSWORD_WITH_TOKEN)\n                        .setAdmin(callerPackageName)\n                        .write();\n            } else {\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.RESET_PASSWORD_WITH_TOKEN)\n                        .setAdmin(caller.getComponentName())\n                        .write();\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isCurrentInputMethodSetByOwner() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isProfileOwner(caller) || isSystemUid(caller),\n                \"Only profile owner, device owner and system may call this method.\");\n        return getUserData(caller.getUserId()).mCurrentInputMethodSet;\n    }\n\n    @Override\n    public StringParceledListSlice getOwnerInstalledCaCerts(@NonNull UserHandle user) {\n        final int userId = user.getIdentifier();\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                (isProfileOwner(caller) || isDefaultDeviceOwner(caller) || canQueryAdminPolicy(\n                        caller)) && hasFullCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            return new StringParceledListSlice(\n                    new ArrayList<>(getUserData(userId).mOwnerInstalledCaCerts));\n        }\n    }\n\n    @Override\n    public void clearApplicationUserData(ComponentName admin, String packageName,\n            IPackageDataObserver callback) {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        Objects.requireNonNull(packageName, \"packageName is null\");\n        Objects.requireNonNull(callback, \"callback is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_CLEAR_APPLICATION_USER_DATA);\n\n        long ident = mInjector.binderClearCallingIdentity();\n        try {\n            ActivityManager.getService().clearApplicationUserData(packageName, false, callback,\n                    caller.getUserId());\n        } catch(RemoteException re) {\n            // Same process, should not happen.\n        } catch (SecurityException se) {\n            // This can happen e.g. for device admin packages, do not throw out the exception,\n            // because callers have no means to know beforehand for which packages this might\n            // happen. If so, we send back that removal failed.\n            Slogf.w(LOG_TAG, \"Not allowed to clear application user data for package \"\n                    + packageName, se);\n            try {\n                callback.onRemoveCompleted(packageName, false);\n            } catch (RemoteException re) {\n                // Caller is no longer available, ignore\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void setLogoutEnabled(ComponentName admin, boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_LOGOUT_ENABLED);\n\n        synchronized (getLockObject()) {\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (deviceOwner.isLogoutEnabled == enabled) {\n                // already in the requested state\n                return;\n            }\n            deviceOwner.isLogoutEnabled = enabled;\n            saveSettingsLocked(caller.getUserId());\n        }\n    }\n\n    @Override\n    public boolean isLogoutEnabled() {\n        if (!mHasFeature) {\n            return false;\n        }\n        synchronized (getLockObject()) {\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            return (deviceOwner != null) && deviceOwner.isLogoutEnabled;\n        }\n    }\n\n    @Override\n    public List<String> getDisallowedSystemApps(ComponentName admin, int userId,\n            String provisioningAction) throws RemoteException {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        return new ArrayList<>(\n                mOverlayPackagesProvider.getNonRequiredApps(admin, userId, provisioningAction));\n    }\n\n    @Override\n    public void transferOwnership(@NonNull ComponentName admin, @NonNull ComponentName target,\n            @Nullable PersistableBundle bundle) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        Objects.requireNonNull(target, \"Target cannot be null.\");\n        Preconditions.checkArgument(!admin.equals(target),\n                \"Provided administrator and target are the same object.\");\n        Preconditions.checkArgument(!admin.getPackageName().equals(target.getPackageName()),\n                \"Provided administrator and target have the same package name.\");\n        if (bundle != null) {\n            enforceMaxStringLength(bundle, \"bundle\");\n        }\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        final int callingUserId = caller.getUserId();\n        final DevicePolicyData policy = getUserData(callingUserId);\n        final DeviceAdminInfo incomingDeviceInfo = findAdmin(target, callingUserId,\n                /* throwForMissingPermission= */ true);\n        checkActiveAdminPrecondition(target, incomingDeviceInfo, policy);\n        Preconditions.checkArgument(incomingDeviceInfo.supportsTransferOwnership(),\n                \"Provided target does not support ownership transfer.\");\n\n        final long id = mInjector.binderClearCallingIdentity();\n        String ownerType = null;\n        try {\n            synchronized (getLockObject()) {\n                /*\n                * We must ensure the whole process is atomic to prevent the device from ending up\n                * in an invalid state (e.g. no active admin). This could happen if the device\n                * is rebooted or work mode is turned off mid-transfer.\n                * In order to guarantee atomicity, we:\n                *\n                * 1. Save an atomic journal file describing the transfer process\n                * 2. Perform the transfer itself\n                * 3. Delete the journal file\n                *\n                * That way if the journal file exists on device boot, we know that the transfer\n                * must be reverted back to the original administrator. This logic is implemented in\n                * revertTransferOwnershipIfNecessaryLocked.\n                * */\n                if (bundle == null) {\n                    bundle = new PersistableBundle();\n                }\n                if (isProfileOwner(caller)) {\n                    ownerType = ADMIN_TYPE_PROFILE_OWNER;\n                    prepareTransfer(admin, target, bundle, callingUserId,\n                            ADMIN_TYPE_PROFILE_OWNER);\n                    transferProfileOwnershipLocked(admin, target, callingUserId);\n                    sendProfileOwnerCommand(DeviceAdminReceiver.ACTION_TRANSFER_OWNERSHIP_COMPLETE,\n                            getTransferOwnershipAdminExtras(bundle), callingUserId);\n                    postTransfer(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED, callingUserId);\n                    if (isUserAffiliatedWithDeviceLocked(callingUserId)) {\n                        notifyAffiliatedProfileTransferOwnershipComplete(callingUserId);\n                    }\n                } else if (isDefaultDeviceOwner(caller)) {\n                    ownerType = ADMIN_TYPE_DEVICE_OWNER;\n                    prepareTransfer(admin, target, bundle, callingUserId,\n                            ADMIN_TYPE_DEVICE_OWNER);\n                    transferDeviceOwnershipLocked(admin, target, callingUserId);\n                    sendDeviceOwnerCommand(DeviceAdminReceiver.ACTION_TRANSFER_OWNERSHIP_COMPLETE,\n                            getTransferOwnershipAdminExtras(bundle));\n                    postTransfer(DevicePolicyManager.ACTION_DEVICE_OWNER_CHANGED, callingUserId);\n                }\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.TRANSFER_OWNERSHIP)\n                .setAdmin(admin)\n                .setStrings(target.getPackageName(), ownerType)\n                .write();\n    }\n\n    private void prepareTransfer(ComponentName admin, ComponentName target,\n            PersistableBundle bundle, int callingUserId, String adminType) {\n        saveTransferOwnershipBundleLocked(bundle, callingUserId);\n        mTransferOwnershipMetadataManager.saveMetadataFile(\n                new TransferOwnershipMetadataManager.Metadata(admin, target,\n                        callingUserId, adminType));\n    }\n\n    private void postTransfer(String broadcast, int callingUserId) {\n        deleteTransferOwnershipMetadataFileLocked();\n        sendOwnerChangedBroadcast(broadcast, callingUserId);\n    }\n\n    private void notifyAffiliatedProfileTransferOwnershipComplete(int callingUserId) {\n        final Bundle extras = new Bundle();\n        extras.putParcelable(Intent.EXTRA_USER, UserHandle.of(callingUserId));\n        sendDeviceOwnerCommand(\n                DeviceAdminReceiver.ACTION_AFFILIATED_PROFILE_TRANSFER_OWNERSHIP_COMPLETE, extras);\n    }\n\n    /**\n     * Transfers the profile owner for user with id profileOwnerUserId from admin to target.\n     */\n    private void transferProfileOwnershipLocked(ComponentName admin, ComponentName target,\n            int profileOwnerUserId) {\n        transferActiveAdminUncheckedLocked(target, admin, profileOwnerUserId);\n        mOwners.transferProfileOwner(target, profileOwnerUserId);\n        Slogf.i(LOG_TAG, \"Profile owner set: \" + target + \" on user \" + profileOwnerUserId);\n        mOwners.writeProfileOwner(profileOwnerUserId);\n        mDeviceAdminServiceController.startServiceForAdmin(\n                target.getPackageName(), profileOwnerUserId, \"transfer-profile-owner\");\n    }\n\n    /**\n     * Transfers the device owner for user with id userId from admin to target.\n     */\n    private void transferDeviceOwnershipLocked(ComponentName admin, ComponentName target, int userId) {\n        transferActiveAdminUncheckedLocked(target, admin, userId);\n        mOwners.transferDeviceOwnership(target);\n        Slogf.i(LOG_TAG, \"Device owner set: \" + target + \" on user \" + userId);\n        mOwners.writeDeviceOwner();\n        mDeviceAdminServiceController.startServiceForAdmin(\n                target.getPackageName(), userId, \"transfer-device-owner\");\n    }\n\n    private Bundle getTransferOwnershipAdminExtras(PersistableBundle bundle) {\n        Bundle extras = new Bundle();\n        if (bundle != null) {\n            extras.putParcelable(EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE, bundle);\n        }\n        return extras;\n    }\n\n    @Override\n    public void setStartUserSessionMessage(\n            ComponentName admin, CharSequence startUserSessionMessage) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        final String startUserSessionMessageString =\n                startUserSessionMessage != null ? startUserSessionMessage.toString() : null;\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (TextUtils.equals(deviceOwner.startUserSessionMessage, startUserSessionMessage)) {\n                return;\n            }\n            deviceOwner.startUserSessionMessage = startUserSessionMessageString;\n            saveSettingsLocked(caller.getUserId());\n        }\n\n        mInjector.getActivityManagerInternal()\n                .setSwitchingFromSystemUserMessage(startUserSessionMessageString);\n    }\n\n    @Override\n    public void setEndUserSessionMessage(ComponentName admin, CharSequence endUserSessionMessage) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        final String endUserSessionMessageString =\n                endUserSessionMessage != null ? endUserSessionMessage.toString() : null;\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (TextUtils.equals(deviceOwner.endUserSessionMessage, endUserSessionMessage)) {\n                return;\n            }\n            deviceOwner.endUserSessionMessage = endUserSessionMessageString;\n            saveSettingsLocked(caller.getUserId());\n        }\n\n        mInjector.getActivityManagerInternal()\n                .setSwitchingToSystemUserMessage(endUserSessionMessageString);\n    }\n\n    @Override\n    public String getStartUserSessionMessage(ComponentName admin) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            return deviceOwner.startUserSessionMessage;\n        }\n    }\n\n    @Override\n    public String getEndUserSessionMessage(ComponentName admin) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            return deviceOwner.endUserSessionMessage;\n        }\n    }\n\n    private void deleteTransferOwnershipMetadataFileLocked() {\n        mTransferOwnershipMetadataManager.deleteMetadataFile();\n    }\n\n    @Override\n    @Nullable\n    public PersistableBundle getTransferOwnershipBundle() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            final int callingUserId = caller.getUserId();\n            final File bundleFile = new File(\n                    mPathProvider.getUserSystemDirectory(callingUserId),\n                    TRANSFER_OWNERSHIP_PARAMETERS_XML);\n            if (!bundleFile.exists()) {\n                return null;\n            }\n            try (FileInputStream stream = new FileInputStream(bundleFile)) {\n                TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n                parser.next();\n                return PersistableBundle.restoreFromXml(parser);\n            } catch (IOException | XmlPullParserException | IllegalArgumentException e) {\n                Slogf.e(LOG_TAG, \"Caught exception while trying to load the \"\n                        + \"owner transfer parameters from file \" + bundleFile, e);\n                return null;\n            }\n        }\n    }\n\n    @Override\n    public int addOverrideApn(@NonNull ComponentName who, @NonNull ApnSetting apnSetting) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return -1;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(apnSetting, \"ApnSetting is null in addOverrideApn\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        if (apnSetting.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isManagedProfileOwner(caller));\n        } else {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        }\n\n        TelephonyManager tm = mContext.getSystemService(TelephonyManager.class);\n        if (tm != null) {\n            return mInjector.binderWithCleanCallingIdentity(\n                    () -> tm.addDevicePolicyOverrideApn(mContext, apnSetting));\n        } else {\n            Slogf.w(LOG_TAG, \"TelephonyManager is null when trying to add override apn\");\n            return INVALID_APN_ID;\n        }\n    }\n\n    @Override\n    public boolean updateOverrideApn(@NonNull ComponentName who, int apnId,\n            @NonNull ApnSetting apnSetting) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(apnSetting, \"ApnSetting is null in updateOverrideApn\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        ApnSetting apn = getApnSetting(apnId);\n        if (apn != null && apn.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE\n                && apnSetting.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isManagedProfileOwner(caller));\n        } else {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        }\n\n        if (apnId < 0) {\n            return false;\n        }\n        TelephonyManager tm = mContext.getSystemService(TelephonyManager.class);\n        if (tm != null) {\n            return mInjector.binderWithCleanCallingIdentity(\n                    () -> tm.modifyDevicePolicyOverrideApn(mContext, apnId, apnSetting));\n        } else {\n            Slogf.w(LOG_TAG, \"TelephonyManager is null when trying to modify override apn\");\n            return false;\n        }\n    }\n\n    @Override\n    public boolean removeOverrideApn(@NonNull ComponentName who, int apnId) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        ApnSetting apn = getApnSetting(apnId);\n        if (apn != null && apn.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isManagedProfileOwner(caller));\n        } else {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        }\n        return removeOverrideApnUnchecked(apnId);\n    }\n\n    private boolean removeOverrideApnUnchecked(int apnId) {\n        if(apnId < 0) {\n            return false;\n        }\n        int numDeleted = mInjector.binderWithCleanCallingIdentity(\n                () -> mContext.getContentResolver().delete(\n                        Uri.withAppendedPath(DPC_URI, Integer.toString(apnId)), null, null));\n        return numDeleted > 0;\n    }\n\n    private ApnSetting getApnSetting(int apnId) {\n        if (apnId < 0) {\n            return null;\n        }\n        ApnSetting apnSetting = null;\n        Cursor cursor = mInjector.binderWithCleanCallingIdentity(\n                () -> mContext.getContentResolver().query(\n                        Uri.withAppendedPath(DPC_URI, Integer.toString(apnId)), null, null, null,\n                        Telephony.Carriers.DEFAULT_SORT_ORDER));\n        if (cursor != null) {\n            while (cursor.moveToNext()) {\n                apnSetting = ApnSetting.makeApnSetting(cursor);\n                if (apnSetting != null) {\n                    break;\n                }\n            }\n            cursor.close();\n        }\n        return apnSetting;\n    }\n\n    @Override\n    public List<ApnSetting> getOverrideApns(@NonNull ComponentName who) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return Collections.emptyList();\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isManagedProfileOwner(caller));\n        List<ApnSetting> apnSettings = getOverrideApnsUnchecked();\n        if (isProfileOwner(caller)) {\n            List<ApnSetting> apnSettingList = new ArrayList<>();\n            for (ApnSetting apnSetting : apnSettings) {\n                if (apnSetting.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE) {\n                    apnSettingList.add(apnSetting);\n                }\n            }\n            return apnSettingList;\n        } else {\n            return apnSettings;\n        }\n    }\n\n    private List<ApnSetting> getOverrideApnsUnchecked() {\n        TelephonyManager tm = mContext.getSystemService(TelephonyManager.class);\n        if (tm != null) {\n            return mInjector.binderWithCleanCallingIdentity(\n                    () -> tm.getDevicePolicyOverrideApns(mContext));\n        }\n        Slogf.w(LOG_TAG, \"TelephonyManager is null when trying to get override apns\");\n        return Collections.emptyList();\n    }\n\n    @Override\n    public void setOverrideApnsEnabled(@NonNull ComponentName who, boolean enabled) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_OVERRIDE_APNS_ENABLED);\n\n        setOverrideApnsEnabledUnchecked(enabled);\n    }\n\n    private void setOverrideApnsEnabledUnchecked(boolean enabled) {\n        ContentValues value = new ContentValues();\n        value.put(ENFORCE_KEY, enabled);\n        mInjector.binderWithCleanCallingIdentity(() -> mContext.getContentResolver().update(\n                    ENFORCE_MANAGED_URI, value, null, null));\n    }\n\n    @Override\n    public boolean isOverrideApnEnabled(@NonNull ComponentName who) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        Cursor enforceCursor = mInjector.binderWithCleanCallingIdentity(\n                () -> mContext.getContentResolver().query(\n                        ENFORCE_MANAGED_URI, null, null, null, null));\n\n        if (enforceCursor == null) {\n            return false;\n        }\n        try {\n            if (enforceCursor.moveToFirst()) {\n                return enforceCursor.getInt(enforceCursor.getColumnIndex(ENFORCE_KEY)) == 1;\n            }\n        } catch (IllegalArgumentException e) {\n            Slogf.e(LOG_TAG, \"Cursor returned from ENFORCE_MANAGED_URI doesn't contain \"\n                    + \"correct info.\", e);\n        } finally {\n            enforceCursor.close();\n        }\n        return false;\n    }\n\n    @VisibleForTesting\n    void saveTransferOwnershipBundleLocked(PersistableBundle bundle, int userId) {\n        final File parametersFile = new File(\n                mPathProvider.getUserSystemDirectory(userId),\n                TRANSFER_OWNERSHIP_PARAMETERS_XML);\n        final AtomicFile atomicFile = new AtomicFile(parametersFile);\n        FileOutputStream stream = null;\n        try {\n            stream = atomicFile.startWrite();\n            final TypedXmlSerializer serializer = Xml.resolveSerializer(stream);\n            serializer.startDocument(null, true);\n            serializer.startTag(null, TAG_TRANSFER_OWNERSHIP_BUNDLE);\n            bundle.saveToXml(serializer);\n            serializer.endTag(null, TAG_TRANSFER_OWNERSHIP_BUNDLE);\n            serializer.endDocument();\n            atomicFile.finishWrite(stream);\n        } catch (IOException | XmlPullParserException e) {\n            Slogf.e(LOG_TAG, \"Caught exception while trying to save the \"\n                    + \"owner transfer parameters to file \" + parametersFile, e);\n            parametersFile.delete();\n            atomicFile.failWrite(stream);\n        }\n    }\n\n    void deleteTransferOwnershipBundleLocked(int userId) {\n        final File parametersFile = new File(mPathProvider.getUserSystemDirectory(userId),\n                TRANSFER_OWNERSHIP_PARAMETERS_XML);\n        parametersFile.delete();\n    }\n\n    private void logPasswordQualitySetIfSecurityLogEnabled(ComponentName who, int userId,\n            boolean parent, PasswordPolicy passwordPolicy) {\n        if (SecurityLog.isLoggingEnabled()) {\n            final int affectedUserId = parent ? getProfileParentId(userId) : userId;\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_COMPLEXITY_SET, who.getPackageName(),\n                    userId, affectedUserId, passwordPolicy.length, passwordPolicy.quality,\n                    passwordPolicy.letters, passwordPolicy.nonLetter, passwordPolicy.numeric,\n                    passwordPolicy.upperCase, passwordPolicy.lowerCase, passwordPolicy.symbols);\n        }\n    }\n\n    private static String getManagedProvisioningPackage(Context context) {\n        return context.getResources().getString(R.string.config_managed_provisioning_package);\n    }\n\n    private void putPrivateDnsSettings(int mode, @Nullable String host) {\n        // Set Private DNS settings using system permissions, as apps cannot write\n        // to global settings.\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            ConnectivitySettingsManager.setPrivateDnsMode(mContext, mode);\n            ConnectivitySettingsManager.setPrivateDnsHostname(mContext, host);\n        });\n    }\n\n    @Override\n    public int setGlobalPrivateDns(@NonNull ComponentName who, int mode, String privateDnsHost) {\n        if (!mHasFeature) {\n            return PRIVATE_DNS_SET_ERROR_FAILURE_SETTING;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkAllUsersAreAffiliatedWithDevice();\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_GLOBAL_PRIVATE_DNS);\n\n        switch (mode) {\n            case PRIVATE_DNS_MODE_OPPORTUNISTIC:\n                if (!TextUtils.isEmpty(privateDnsHost)) {\n                    throw new IllegalArgumentException(\n                            \"Host provided for opportunistic mode, but is not needed.\");\n                }\n                putPrivateDnsSettings(ConnectivitySettingsManager.PRIVATE_DNS_MODE_OPPORTUNISTIC,\n                        null);\n                return PRIVATE_DNS_SET_NO_ERROR;\n            case PRIVATE_DNS_MODE_PROVIDER_HOSTNAME:\n                if (TextUtils.isEmpty(privateDnsHost)\n                        || !NetworkUtilsInternal.isWeaklyValidatedHostname(privateDnsHost)) {\n                    throw new IllegalArgumentException(\n                            String.format(\"Provided hostname %s is not valid\", privateDnsHost));\n                }\n\n                // Connectivity check will have been performed in the DevicePolicyManager before\n                // the call here.\n                putPrivateDnsSettings(\n                        ConnectivitySettingsManager.PRIVATE_DNS_MODE_PROVIDER_HOSTNAME,\n                        privateDnsHost);\n                return PRIVATE_DNS_SET_NO_ERROR;\n            default:\n                throw new IllegalArgumentException(\n                        String.format(\"Provided mode, %d, is not a valid mode.\", mode));\n        }\n    }\n\n    @Override\n    public int getGlobalPrivateDnsMode(@NonNull ComponentName who) {\n        if (!mHasFeature) {\n            return PRIVATE_DNS_MODE_UNKNOWN;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        final int currentMode = ConnectivitySettingsManager.getPrivateDnsMode(mContext);\n        switch (currentMode) {\n            case ConnectivitySettingsManager.PRIVATE_DNS_MODE_OFF:\n                return PRIVATE_DNS_MODE_OFF;\n            case ConnectivitySettingsManager.PRIVATE_DNS_MODE_OPPORTUNISTIC:\n                return PRIVATE_DNS_MODE_OPPORTUNISTIC;\n            case ConnectivitySettingsManager.PRIVATE_DNS_MODE_PROVIDER_HOSTNAME:\n                return PRIVATE_DNS_MODE_PROVIDER_HOSTNAME;\n        }\n\n        return PRIVATE_DNS_MODE_UNKNOWN;\n    }\n\n    @Override\n    public String getGlobalPrivateDnsHost(@NonNull ComponentName who) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        return mInjector.settingsGlobalGetString(PRIVATE_DNS_SPECIFIER);\n    }\n\n    @Override\n    public void installUpdateFromFile(ComponentName admin, String callerPackageName,\n            ParcelFileDescriptor updateFileDescriptor, StartInstallingUpdateCallback callback) {\n        if (!isPermissionCheckFlagEnabled()) {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n        }\n\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n            enforcePermission(MANAGE_DEVICE_POLICY_SYSTEM_UPDATES, caller.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            caller = getCallerIdentity(admin);\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_INSTALL_SYSTEM_UPDATE);\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.INSTALL_SYSTEM_UPDATE)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(isDeviceAB())\n                .write();\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            UpdateInstaller updateInstaller;\n            if (isDeviceAB()) {\n                updateInstaller = new AbUpdateInstaller(\n                        mContext, updateFileDescriptor, callback, mInjector, mConstants);\n            } else {\n                updateInstaller = new NonAbUpdateInstaller(\n                        mContext, updateFileDescriptor, callback, mInjector, mConstants);\n            }\n            updateInstaller.startInstallUpdate();\n        });\n    }\n\n    private boolean isDeviceAB() {\n        return \"true\".equalsIgnoreCase(android.os.SystemProperties\n                .get(AB_DEVICE_KEY, \"\"));\n    }\n\n    @Override\n    public void setCrossProfileCalendarPackages(ComponentName who, List<String> packageNames) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            admin.mCrossProfileCalendarPackages = packageNames;\n            saveSettingsLocked(caller.getUserId());\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CROSS_PROFILE_CALENDAR_PACKAGES)\n                .setAdmin(who)\n                .setStrings(packageNames == null ? null\n                        : packageNames.toArray(new String[packageNames.size()]))\n                .write();\n    }\n\n    @Override\n    public List<String> getCrossProfileCalendarPackages(ComponentName who) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return admin.mCrossProfileCalendarPackages;\n        }\n    }\n\n    @Override\n    public boolean isPackageAllowedToAccessCalendarForUser(String packageName,\n            @UserIdInt int userId) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkStringNotEmpty(packageName, \"Package name is null or empty\");\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final int packageUid;\n        try (var snapshot = mInjector.getPackageManagerLocal().withUnfilteredSnapshot()) {\n            var packageState = snapshot.getPackageStates().get(packageName);\n            if (packageState == null) {\n                Slogf.w(LOG_TAG, \"Couldn't find package %s in user %d\", packageName,\n                        userId);\n                return false;\n            } else if (!packageState.getUserStateOrDefault(userId).isInstalled()) {\n                Slogf.w(LOG_TAG, \"Couldn't find installed package %s in user %d\", packageName,\n                        userId);\n                return false;\n            } else {\n                packageUid = UserHandle.getUid(userId, packageState.getAppId());\n            }\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        if (caller.getUid() != packageUid) {\n            Preconditions.checkCallAuthorization(\n                    hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS)\n                            || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS_FULL));\n        }\n\n        synchronized (getLockObject()) {\n            if (mInjector.settingsSecureGetIntForUser(\n                    Settings.Secure.CROSS_PROFILE_CALENDAR_ENABLED, 0, userId) == 0) {\n                return false;\n            }\n            final ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            if (admin != null) {\n                if (admin.mCrossProfileCalendarPackages == null) {\n                    return true;\n                }\n                return admin.mCrossProfileCalendarPackages.contains(packageName);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public List<String> getCrossProfileCalendarPackagesForUser(int userHandle) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS)\n                        || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS_FULL));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerAdminLocked(userHandle);\n            if (admin != null) {\n                return admin.mCrossProfileCalendarPackages;\n            }\n        }\n        return Collections.emptyList();\n    }\n\n    @Override\n    public void setCrossProfilePackages(ComponentName who, List<String> packageNames) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(packageNames, \"Package names is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        final List<String> previousCrossProfilePackages;\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            previousCrossProfilePackages = admin.mCrossProfilePackages;\n            if (packageNames.equals(previousCrossProfilePackages)) {\n                return;\n            }\n            admin.mCrossProfilePackages = packageNames;\n            saveSettingsLocked(caller.getUserId());\n        }\n        logSetCrossProfilePackages(who, packageNames);\n        final CrossProfileApps crossProfileApps =\n                mContext.createContextAsUser(\n                        caller.getUserHandle(), /* flags= */ 0)\n                        .getSystemService(CrossProfileApps.class);\n        mInjector.binderWithCleanCallingIdentity(\n        () -> crossProfileApps.resetInteractAcrossProfilesAppOps(\n                        previousCrossProfilePackages, new HashSet<>(packageNames)));\n    }\n\n    private void logSetCrossProfilePackages(ComponentName who, List<String> packageNames) {\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CROSS_PROFILE_PACKAGES)\n                .setAdmin(who)\n                .setStrings(packageNames.toArray(new String[packageNames.size()]))\n                .write();\n    }\n\n    @Override\n    public List<String> getCrossProfilePackages(ComponentName who) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return admin.mCrossProfilePackages;\n        }\n    }\n\n    @Override\n    public List<String> getAllCrossProfilePackages(int userId) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isSystemUid(caller) || isRootUid(caller) || hasCallingPermission(\n                        permission.INTERACT_ACROSS_USERS) || hasCallingPermission(\n                        permission.INTERACT_ACROSS_USERS_FULL) || hasPermissionForPreflight(\n                                                caller, permission.INTERACT_ACROSS_PROFILES));\n\n        synchronized (getLockObject()) {\n            final List<ActiveAdmin> admins = getProfileOwnerAdminsForProfileGroup(userId);\n            final List<String> packages = getCrossProfilePackagesForAdmins(admins);\n\n            packages.addAll(getDefaultCrossProfilePackages());\n\n            return packages;\n        }\n    }\n\n    private List<String> getCrossProfilePackagesForAdmins(List<ActiveAdmin> admins) {\n        final List<String> packages = new ArrayList<>();\n        for (int i = 0; i < admins.size(); i++) {\n            packages.addAll(admins.get(i).mCrossProfilePackages);\n        }\n        return packages;\n    }\n\n    @Override\n    public List<String> getDefaultCrossProfilePackages() {\n        Set<String> crossProfilePackages = new HashSet<>();\n\n        Collections.addAll(crossProfilePackages, mContext.getResources()\n                .getStringArray(R.array.cross_profile_apps));\n        Collections.addAll(crossProfilePackages, mContext.getResources()\n                .getStringArray(R.array.vendor_cross_profile_apps));\n\n        return new ArrayList<>(crossProfilePackages);\n    }\n\n    private List<ActiveAdmin> getProfileOwnerAdminsForProfileGroup(int userId) {\n        synchronized (getLockObject()) {\n            final List<ActiveAdmin> admins = new ArrayList<>();\n            int[] users = mUserManager.getProfileIdsWithDisabled(userId);\n            for (int i = 0; i < users.length; i++) {\n                final ComponentName componentName = getProfileOwnerAsUser(users[i]);\n                if (componentName != null) {\n                    ActiveAdmin admin = getActiveAdminUncheckedLocked(componentName, users[i]);\n                    if (admin != null) {\n                        admins.add(admin);\n                    }\n                }\n            }\n            return admins;\n        }\n    }\n\n    @Override\n    public boolean isManagedKiosk() {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        long id = mInjector.binderClearCallingIdentity();\n        try {\n            return isManagedKioskInternal();\n        } catch (RemoteException e) {\n            throw new IllegalStateException(e);\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    private boolean isUnattendedManagedKioskUnchecked() {\n        try {\n            return isManagedKioskInternal()\n                    && getPowerManagerInternal().wasDeviceIdleFor(UNATTENDED_MANAGED_KIOSK_MS);\n        } catch (RemoteException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    @Override\n    public boolean isUnattendedManagedKiosk() {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        return mInjector.binderWithCleanCallingIdentity(() -> isUnattendedManagedKioskUnchecked());\n    }\n\n    /**\n     * Returns whether the device is currently being used as a publicly-accessible dedicated device.\n     * Assumes that feature checks and permission checks have already been performed, and that the\n     * calling identity has been cleared.\n     */\n    private boolean isManagedKioskInternal() throws RemoteException {\n        return mOwners.hasDeviceOwner()\n                && mInjector.getIActivityManager().getLockTaskModeState()\n                        == ActivityManager.LOCK_TASK_MODE_LOCKED\n                && !isLockTaskFeatureEnabled(DevicePolicyManager.LOCK_TASK_FEATURE_SYSTEM_INFO)\n                && !deviceHasKeyguard()\n                && !inEphemeralUserSession();\n    }\n\n    private boolean isLockTaskFeatureEnabled(int lockTaskFeature) throws RemoteException {\n        int lockTaskFeatures = 0;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            LockTaskPolicy policy = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.LOCK_TASK, getCurrentForegroundUserId());\n            lockTaskFeatures = policy == null\n                    // We default on the power button menu, in order to be consistent with pre-P\n                    // behaviour.\n                    ? DevicePolicyManager.LOCK_TASK_FEATURE_GLOBAL_ACTIONS\n                    : policy.getFlags();\n        } else {\n            //TODO(b/175285301): Explicitly get the user's identity to check.\n            lockTaskFeatures =\n                    getUserData(getCurrentForegroundUserId()).mLockTaskFeatures;\n        }\n        return (lockTaskFeatures & lockTaskFeature) == lockTaskFeature;\n    }\n\n    private boolean deviceHasKeyguard() {\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            if (mLockPatternUtils.isSecure(userInfo.id)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean inEphemeralUserSession() {\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            if (mInjector.getUserManager().isUserEphemeral(userInfo.id)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private PowerManagerInternal getPowerManagerInternal() {\n        return mInjector.getPowerManagerInternal();\n    }\n\n    @Override\n    public boolean startViewCalendarEventInManagedProfile(String packageName, long eventId,\n            long start, long end, boolean allDay, int flags) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkStringNotEmpty(packageName, \"Package name is empty\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        if (!isCallingFromPackage(packageName, caller.getUid())) {\n            throw new SecurityException(\"Input package name doesn't align with actual \"\n                    + \"calling package.\");\n        }\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            final int workProfileUserId = getManagedUserId(caller.getUserId());\n            if (workProfileUserId < 0) {\n                return false;\n            }\n            if (!isPackageAllowedToAccessCalendarForUser(packageName, workProfileUserId)) {\n                Slogf.d(LOG_TAG, \"Package %s is not allowed to access cross-profile calendar APIs\",\n                        packageName);\n                return false;\n            }\n            final Intent intent = new Intent(\n                    CalendarContract.ACTION_VIEW_MANAGED_PROFILE_CALENDAR_EVENT);\n            intent.setPackage(packageName);\n            intent.putExtra(CalendarContract.EXTRA_EVENT_ID, eventId);\n            intent.putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, start);\n            intent.putExtra(CalendarContract.EXTRA_EVENT_END_TIME, end);\n            intent.putExtra(CalendarContract.EXTRA_EVENT_ALL_DAY, allDay);\n            intent.setFlags(flags);\n            try {\n                mContext.startActivityAsUser(intent, UserHandle.of(workProfileUserId));\n            } catch (ActivityNotFoundException e) {\n                Slogf.e(LOG_TAG, \"View event activity not found\", e);\n                return false;\n            }\n            return true;\n        });\n    }\n\n    @Override\n    public void setApplicationExemptions(String callerPackage, String packageName,\n            int[] exemptions) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkStringNotEmpty(packageName, \"Package name cannot be empty.\");\n        Objects.requireNonNull(exemptions, \"Application exemptions must not be null.\");\n        Preconditions.checkArgument(areApplicationExemptionsValid(exemptions),\n                \"Invalid application exemption constant found in application exemptions set.\");\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_POLICY_APP_EXEMPTIONS));\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        final ApplicationInfo packageInfo;\n        packageInfo = getPackageInfoWithNullCheck(packageName, caller);\n\n        for (Map.Entry<Integer, String> entry :\n                APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.entrySet()) {\n            int currentMode = mInjector.getAppOpsManager().unsafeCheckOpNoThrow(\n                    entry.getValue(), packageInfo.uid, packageInfo.packageName);\n            int newMode = ArrayUtils.contains(exemptions, entry.getKey())\n                    ? MODE_ALLOWED : MODE_DEFAULT;\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                if (currentMode != newMode) {\n                    mInjector.getAppOpsManager()\n                            .setMode(entry.getValue(),\n                                    packageInfo.uid,\n                                    packageName,\n                                    newMode);\n                }\n            });\n        }\n        String[] appOpExemptions = new String[exemptions.length];\n        for (int i = 0; i < exemptions.length; i++) {\n            appOpExemptions[i] = APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.get(exemptions[i]);\n        }\n        DevicePolicyEventLogger\n            .createEvent(DevicePolicyEnums.SET_APPLICATION_EXEMPTIONS)\n            .setAdmin(caller.getPackageName())\n            .setStrings(packageName, appOpExemptions)\n            .write();\n    }\n\n    @Override\n    public int[] getApplicationExemptions(String packageName) {\n        if (!mHasFeature) {\n            return new int[0];\n        }\n        Preconditions.checkStringNotEmpty(packageName, \"Package name cannot be empty.\");\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_POLICY_APP_EXEMPTIONS));\n\n        final CallerIdentity caller = getCallerIdentity();\n        final ApplicationInfo packageInfo;\n        packageInfo = getPackageInfoWithNullCheck(packageName, caller);\n\n        IntArray appliedExemptions = new IntArray(0);\n        for (Map.Entry<Integer, String> entry :\n                APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.entrySet()) {\n            if (mInjector.getAppOpsManager().unsafeCheckOpNoThrow(\n                    entry.getValue(), packageInfo.uid, packageInfo.packageName) == MODE_ALLOWED) {\n                appliedExemptions.add(entry.getKey());\n            }\n        }\n        return appliedExemptions.toArray();\n    }\n\n    private ApplicationInfo getPackageInfoWithNullCheck(String packageName, CallerIdentity caller) {\n        final ApplicationInfo packageInfo =\n                mInjector.getPackageManagerInternal().getApplicationInfo(\n                        packageName,\n                        /* flags= */ 0,\n                        caller.getUid(),\n                        caller.getUserId());\n        if (packageInfo == null) {\n            throw new ServiceSpecificException(\n                    DevicePolicyManager.ERROR_PACKAGE_NAME_NOT_FOUND,\n                    \"Package name not found.\");\n        }\n        return packageInfo;\n    }\n\n    private boolean areApplicationExemptionsValid(int[] exemptions) {\n        for (int exemption : exemptions) {\n            if (!APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.containsKey(exemption)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean isCallingFromPackage(String packageName, int callingUid) {\n        try (var snapshot = mInjector.getPackageManagerLocal().withUnfilteredSnapshot()) {\n            var packageState = snapshot.getPackageStates().get(packageName);\n            var userId = UserHandle.getUserId(callingUid);\n            if (packageState == null) {\n                Slogf.d(LOG_TAG, \"Calling UID \" + callingUid + \" not found\");\n                return false;\n            } else if (!packageState.getUserStateOrDefault(userId).isInstalled()) {\n                Slogf.d(LOG_TAG, \"Calling UID \" + callingUid + \" not installed\");\n                return false;\n            } else {\n                return callingUid == UserHandle.getUid(userId, packageState.getAppId());\n            }\n        }\n    }\n\n    private DevicePolicyConstants loadConstants() {\n        return DevicePolicyConstants.loadFromString(\n                mInjector.settingsGlobalGetString(Global.DEVICE_POLICY_CONSTANTS));\n    }\n\n    @Override\n    public void setUserControlDisabledPackages(ComponentName who, String callerPackageName,\n            List<String> packages) {\n        Objects.requireNonNull(packages, \"packages is null\");\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        checkCanExecuteOrThrowUnsafe(\n                DevicePolicyManager.OPERATION_SET_USER_CONTROL_DISABLED_PACKAGES);\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            Binder.withCleanCallingIdentity(() -> {\n                if (packages.isEmpty()) {\n                    removeUserControlDisabledPackages(caller, enforcingAdmin);\n                } else {\n                    addUserControlDisabledPackages(caller, enforcingAdmin, new HashSet<>(packages));\n                }\n            });\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isProfileOwner(caller) || isFinancedDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(caller.getUserId());\n                if (!Objects.equals(admin.protectedPackages, packages)) {\n                    admin.protectedPackages = packages.isEmpty() ? null : packages;\n                    saveSettingsLocked(caller.getUserId());\n                    pushUserControlDisabledPackagesLocked(caller.getUserId());\n                }\n            }\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_USER_CONTROL_DISABLED_PACKAGES)\n                .setAdmin(caller.getPackageName())\n                .setStrings(packages.toArray(new String[packages.size()]))\n                .write();\n    }\n\n    private void addUserControlDisabledPackages(CallerIdentity caller,\n            EnforcingAdmin enforcingAdmin, Set<String> packages) {\n        if (isDeviceOwner(caller)) {\n            mDevicePolicyEngine.setGlobalPolicy(\n                    PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                    enforcingAdmin,\n                    new StringSetPolicyValue(packages));\n        } else {\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                    enforcingAdmin,\n                    new StringSetPolicyValue(packages),\n                    caller.getUserId());\n        }\n    }\n\n    private void removeUserControlDisabledPackages(CallerIdentity caller,\n            EnforcingAdmin enforcingAdmin) {\n        if (isDeviceOwner(caller)) {\n            mDevicePolicyEngine.removeGlobalPolicy(\n                    PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                    enforcingAdmin);\n        } else {\n            mDevicePolicyEngine.removeLocalPolicy(\n                    PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                    enforcingAdmin,\n                    caller.getUserId());\n        }\n    }\n\n    @Override\n    public List<String> getUserControlDisabledPackages(ComponentName who,\n            String callerPackageName) {\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            enforceCanQuery(\n                    MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            // This retrieves the policy for the calling user only, DOs for example can't know\n            // what's enforced globally or on another user.\n            Set<String> packages = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                    caller.getUserId());\n            return packages == null ? Collections.emptyList() : packages.stream().toList();\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isProfileOwner(caller) || isFinancedDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(caller.getUserId());\n                return admin.protectedPackages != null\n                        ? admin.protectedPackages : Collections.emptyList();\n            }\n        }\n    }\n\n    @Override\n    public void setCommonCriteriaModeEnabled(ComponentName who, String callerPackageName,\n            boolean enabled) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        final ActiveAdmin admin;\n\n        if (isPermissionCheckFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            admin = enforcingAdmin.getActiveAdmin();\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller),\n                    \"Common Criteria mode can only be controlled by a device owner or \"\n                            + \"a profile owner on an organization-owned device.\");\n            synchronized (getLockObject()) {\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n        }\n        synchronized (getLockObject()) {\n            admin.mCommonCriteriaMode = enabled;\n            saveSettingsLocked(caller.getUserId());\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_COMMON_CRITERIA_MODE)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(enabled)\n                .write();\n    }\n\n    @Override\n    public boolean isCommonCriteriaModeEnabled(ComponentName who) {\n        if (who != null) {\n            final CallerIdentity caller = getCallerIdentity(who);\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller),\n                    \"Common Criteria mode can only be controlled by a device owner or \"\n                            + \"a profile owner on an organization-owned device.\");\n\n            synchronized (getLockObject()) {\n                final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n                return admin.mCommonCriteriaMode;\n            }\n        }\n\n        // Return aggregated state if caller is not admin (who == null).\n        synchronized (getLockObject()) {\n            // Only DO or COPE PO can turn on CC mode, so take a shortcut here and only look at\n            // their ActiveAdmin, instead of iterating through all admins.\n            ActiveAdmin admin;\n            // TODO(b/261999445): remove\n            if (isHeadlessFlagEnabled()) {\n                admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n            } else {\n                admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked(\n                        UserHandle.USER_SYSTEM);\n            }\n            return admin != null ? admin.mCommonCriteriaMode : false;\n        }\n    }\n\n    @Override\n    public @PersonalAppsSuspensionReason int getPersonalAppsSuspendedReasons(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        // DO shouldn't be able to use this method.\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            final long deadline = admin.mProfileOffDeadline;\n            final int result = makeSuspensionReasons(admin.mSuspendPersonalApps,\n                    deadline != 0 && mInjector.systemCurrentTimeMillis() > deadline);\n            Slogf.d(LOG_TAG, \"getPersonalAppsSuspendedReasons user: %d; result: %d\",\n                    mInjector.userHandleGetCallingUserId(), result);\n            return result;\n        }\n    }\n\n    private @PersonalAppsSuspensionReason int makeSuspensionReasons(\n            boolean explicit, boolean timeout) {\n        int result = PERSONAL_APPS_NOT_SUSPENDED;\n        if (explicit) {\n            result |= PERSONAL_APPS_SUSPENDED_EXPLICITLY;\n        }\n        if (timeout) {\n            result |= PERSONAL_APPS_SUSPENDED_PROFILE_TIMEOUT;\n        }\n        return result;\n    }\n\n    @Override\n    public void setPersonalAppsSuspended(ComponentName who, boolean suspended) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n        Preconditions.checkState(canHandleCheckPolicyComplianceIntent(caller));\n\n        final int callingUserId = caller.getUserId();\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(callingUserId);\n            boolean shouldSaveSettings = false;\n            if (admin.mSuspendPersonalApps != suspended) {\n                admin.mSuspendPersonalApps = suspended;\n                shouldSaveSettings = true;\n            }\n            if (admin.mProfileOffDeadline != 0) {\n                admin.mProfileOffDeadline = 0;\n                shouldSaveSettings = true;\n            }\n            if (shouldSaveSettings) {\n                saveSettingsLocked(callingUserId);\n            }\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> updatePersonalAppsSuspension(\n                callingUserId));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PERSONAL_APPS_SUSPENDED)\n                .setAdmin(caller.getComponentName())\n                .setBoolean(suspended)\n                .write();\n    }\n\n    /** Starts an activity to check policy compliance or request compliance acknowledgement. */\n    private void triggerPolicyComplianceCheckIfNeeded(int profileUserId, boolean suspended) {\n        synchronized (getLockObject()) {\n            final ActiveAdmin profileOwner = getProfileOwnerAdminLocked(profileUserId);\n            if (profileOwner == null) {\n                Slogf.wtf(LOG_TAG, \"Profile owner not found for compliance check\");\n                return;\n            }\n            if (suspended) {\n                // If suspended, DPC will need to show an activity.\n                final Intent intent = new Intent(ACTION_CHECK_POLICY_COMPLIANCE);\n                intent.setPackage(profileOwner.info.getPackageName());\n                mContext.startActivityAsUser(intent, UserHandle.of(profileUserId));\n            } else if (profileOwner.mProfileOffDeadline > 0) {\n                // If not suspended, but deadline set, DPC needs to acknowledge compliance so that\n                // the deadline can be reset.\n                sendAdminCommandLocked(profileOwner, ACTION_COMPLIANCE_ACKNOWLEDGEMENT_REQUIRED,\n                        /* adminExtras= */ null, /* receiver= */ null, /* inForeground = */ true);\n            }\n        }\n    }\n\n    /**\n     * Checks whether personal apps should be suspended according to the policy and applies the\n     * change if needed.\n     */\n    private boolean updatePersonalAppsSuspension(int profileUserId) {\n        final boolean shouldSuspend;\n        synchronized (getLockObject()) {\n            final ActiveAdmin profileOwner = getProfileOwnerAdminLocked(profileUserId);\n            if (profileOwner != null) {\n                // Profile is considered \"off\" when it is either not running or is running locked\n                // or is in quiet mode, i.e. when the admin cannot sync policies or show UI.\n                boolean profileUserOff =\n                        !mUserManagerInternal.isUserUnlockingOrUnlocked(profileUserId)\n                        || mUserManager.isQuietModeEnabled(UserHandle.of(profileUserId));\n                final int notificationState = updateProfileOffDeadlineLocked(\n                        profileUserId, profileOwner, profileUserOff);\n                final boolean suspendedExplicitly = profileOwner.mSuspendPersonalApps;\n                final boolean suspendedByTimeout = profileOwner.mProfileOffDeadline == -1;\n                Slogf.d(LOG_TAG,\n                        \"Personal apps suspended explicitly: %b, by timeout: %b, notification: %d\",\n                        suspendedExplicitly, suspendedByTimeout, notificationState);\n                updateProfileOffDeadlineNotificationLocked(\n                        profileUserId, profileOwner, notificationState);\n                shouldSuspend = suspendedExplicitly || suspendedByTimeout;\n            } else {\n                shouldSuspend = false;\n            }\n        }\n\n        final int parentUserId = getProfileParentId(profileUserId);\n        suspendPersonalAppsInternal(parentUserId, profileUserId, shouldSuspend);\n        return shouldSuspend;\n    }\n\n    /**\n     * Checks work profile time off policy, scheduling personal apps suspension via alarm if\n     * necessary.\n     * @return notification state\n     */\n    private int updateProfileOffDeadlineLocked(\n            int profileUserId, ActiveAdmin profileOwner, boolean off) {\n        final long now = mInjector.systemCurrentTimeMillis();\n        if (profileOwner.mProfileOffDeadline != 0 && now > profileOwner.mProfileOffDeadline) {\n            Slogf.i(LOG_TAG, \"Profile off deadline has been reached, off: \" + off);\n            if (profileOwner.mProfileOffDeadline != -1) {\n                // Move the deadline far to the past so that it cannot be rolled back by TZ change.\n                profileOwner.mProfileOffDeadline = -1;\n                saveSettingsLocked(profileUserId);\n            }\n            return off ? PROFILE_OFF_NOTIFICATION_SUSPENDED : PROFILE_OFF_NOTIFICATION_NONE;\n        }\n        boolean shouldSaveSettings = false;\n        if (profileOwner.mSuspendPersonalApps) {\n            // When explicit suspension is active, deadline shouldn't be set.\n            if (profileOwner.mProfileOffDeadline != 0) {\n                profileOwner.mProfileOffDeadline = 0;\n                shouldSaveSettings = true;\n            }\n        } else if (profileOwner.mProfileOffDeadline != 0\n                && (profileOwner.mProfileMaximumTimeOffMillis == 0)) {\n            // There is a deadline but either there is no policy -> clear\n            // the deadline.\n            Slogf.i(LOG_TAG, \"Profile off deadline is reset to zero\");\n            profileOwner.mProfileOffDeadline = 0;\n            shouldSaveSettings = true;\n        } else if (profileOwner.mProfileOffDeadline == 0\n                && (profileOwner.mProfileMaximumTimeOffMillis != 0 && off)) {\n            // There profile is locked and there is a policy, but the deadline is not set -> set the\n            // deadline.\n            Slogf.i(LOG_TAG, \"Profile off deadline is set.\");\n            profileOwner.mProfileOffDeadline = now + profileOwner.mProfileMaximumTimeOffMillis;\n            shouldSaveSettings = true;\n        }\n\n        if (shouldSaveSettings) {\n            saveSettingsLocked(profileUserId);\n        }\n\n        final long alarmTime;\n        final int notificationState;\n        if (!off || profileOwner.mProfileOffDeadline == 0) {\n            alarmTime = 0;\n            notificationState = PROFILE_OFF_NOTIFICATION_NONE;\n        } else if (profileOwner.mProfileOffDeadline - now < MANAGED_PROFILE_OFF_WARNING_PERIOD) {\n            // The deadline is close, upon the alarm personal apps should be suspended.\n            alarmTime = profileOwner.mProfileOffDeadline;\n            notificationState = PROFILE_OFF_NOTIFICATION_WARNING;\n        } else {\n            // The deadline is quite far, upon the alarm we should warn the user first, so the\n            // alarm is scheduled earlier than the actual deadline.\n            alarmTime = profileOwner.mProfileOffDeadline - MANAGED_PROFILE_OFF_WARNING_PERIOD;\n            notificationState = PROFILE_OFF_NOTIFICATION_NONE;\n        }\n\n        final AlarmManager am = mInjector.getAlarmManager();\n        final Intent intent = new Intent(ACTION_PROFILE_OFF_DEADLINE);\n        intent.setPackage(mContext.getPackageName());\n        // Broadcast alarms sent by system are immutable\n        final PendingIntent pi = mInjector.pendingIntentGetBroadcast(\n                mContext, REQUEST_PROFILE_OFF_DEADLINE, intent,\n                PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_UPDATE_CURRENT\n                        | PendingIntent.FLAG_IMMUTABLE);\n\n        if (alarmTime == 0) {\n            Slogf.i(LOG_TAG, \"Profile off deadline alarm is removed.\");\n            am.cancel(pi);\n        } else {\n            Slogf.i(LOG_TAG, \"Profile off deadline alarm is set.\");\n            am.set(AlarmManager.RTC, alarmTime, pi);\n        }\n\n        return notificationState;\n    }\n\n    private void suspendPersonalAppsInternal(\n            int parentUserId, int profileUserId, boolean suspended) {\n        if (getUserData(parentUserId).mAppsSuspended == suspended) {\n            return;\n        }\n        Slogf.i(LOG_TAG, \"%s personal apps for user %d\", suspended ? \"Suspending\" : \"Unsuspending\",\n                parentUserId);\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            // TODO(b/280602237): migrate properly\n            ActiveAdmin profileOwner = getProfileOwnerAdminLocked(profileUserId);\n            if (profileOwner != null) {\n                EnforcingAdmin admin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                        profileOwner.info.getComponent(),\n                        profileUserId,\n                        profileOwner);\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.PERSONAL_APPS_SUSPENDED,\n                        admin,\n                        new BooleanPolicyValue(suspended),\n                        parentUserId);\n            }\n        } else {\n            if (suspended) {\n                suspendPersonalAppsInPackageManager(parentUserId);\n            } else {\n                mInjector.getPackageManagerInternal().unsuspendForSuspendingPackage(\n                        PLATFORM_PACKAGE_NAME, parentUserId);\n            }\n        }\n\n        synchronized (getLockObject()) {\n            getUserData(parentUserId).mAppsSuspended = suspended;\n            saveSettingsLocked(parentUserId);\n        }\n    }\n\n    private void suspendPersonalAppsInPackageManager(int userId) {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            final String[] appsToSuspend = mInjector.getPersonalAppsForSuspension(userId);\n            final String[] failedApps = mInjector.getPackageManagerInternal()\n                    .setPackagesSuspendedByAdmin(userId, appsToSuspend, true);\n            if (!ArrayUtils.isEmpty(failedApps)) {\n                Slogf.wtf(LOG_TAG, \"Failed to suspend apps: \" + String.join(\",\", failedApps));\n            }\n        });\n    }\n\n    private void notifyIfManagedSubscriptionsAreUnavailable(\n            UserHandle managedProfile, boolean managedProfileAvailable) {\n        if (!isManagedProfile(managedProfile.getIdentifier())) {\n            Slog.wtf(\n                    LOG_TAG,\n                    \"Expected managed profile when notified of profile availability change.\");\n        }\n        if (getManagedSubscriptionsPolicy().getPolicyType()\n                != ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {\n            // There may be a subscription in the personal profile, in which case calls and\n            // texts may still be available. No need to notify the user.\n            return;\n        }\n        if (managedProfileAvailable) {\n            // When quiet mode is switched off calls and texts then become available to the user,\n            // so no need to keep showing the notification.\n            mInjector\n                    .getNotificationManager()\n                    .cancel(SystemMessage.NOTE_ALL_MANAGED_SUBSCRIPTIONS_AND_MANAGED_PROFILE_OFF);\n            return;\n        }\n        final Intent intent = new Intent(ACTION_TURN_PROFILE_ON_NOTIFICATION);\n        intent.putExtra(Intent.EXTRA_USER_HANDLE, managedProfile.getIdentifier());\n        final PendingIntent pendingIntent =\n                mInjector.pendingIntentGetBroadcast(\n                        mContext,\n                        /* requestCode= */ 0,\n                        intent,\n                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n        final Notification.Action turnProfileOnButton =\n                new Notification.Action.Builder(\n                        /* icon= */ null, getUnpauseWorkAppsButtonText(), pendingIntent)\n                        .build();\n\n        final Bundle extras = new Bundle();\n        extras.putString(\n                Notification.EXTRA_SUBSTITUTE_APP_NAME, getWorkProfileContentDescription());\n        final Notification notification =\n                new Notification.Builder(mContext, SystemNotificationChannels.DEVICE_ADMIN)\n                        .setSmallIcon(R.drawable.ic_phone_disabled)\n                        .setContentTitle(getUnpauseWorkAppsForTelephonyTitle())\n                        .setContentText(getUnpauseWorkAppsForTelephonyText())\n                        .setStyle(new Notification.BigTextStyle().bigText(\n                                getUnpauseWorkAppsForTelephonyText()))\n                        .addAction(turnProfileOnButton)\n                        .addExtras(extras)\n                        .setOngoing(false)\n                        .setShowWhen(true)\n                        .setAutoCancel(true)\n                        .build();\n\n        mInjector\n                .getNotificationManager()\n                .notifyAsUser(\n                        /* tag= */ null,\n                        SystemMessage.NOTE_ALL_MANAGED_SUBSCRIPTIONS_AND_MANAGED_PROFILE_OFF,\n                        notification,\n                        UserHandle.of(getProfileParentId(managedProfile.getIdentifier())));\n    }\n\n    private String getUnpauseWorkAppsButtonText() {\n        return getUpdatableString(\n                WORK_PROFILE_TELEPHONY_PAUSED_TURN_ON_BUTTON,\n                R.string.work_profile_telephony_paused_turn_on_button);\n    }\n\n    private String getUnpauseWorkAppsForTelephonyTitle() {\n        return getUpdatableString(\n                WORK_PROFILE_TELEPHONY_PAUSED_TITLE, R.string.work_profile_telephony_paused_title);\n    }\n\n    private String getUnpauseWorkAppsForTelephonyText() {\n        return getUpdatableString(\n                WORK_PROFILE_TELEPHONY_PAUSED_BODY,\n                R.string.work_profile_telephony_paused_text);\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void updateProfileOffDeadlineNotificationLocked(\n            int profileUserId, ActiveAdmin profileOwner, int notificationState) {\n        if (notificationState == PROFILE_OFF_NOTIFICATION_NONE) {\n            mInjector.getNotificationManager().cancel(SystemMessage.NOTE_PERSONAL_APPS_SUSPENDED);\n            return;\n        }\n\n        final Intent intent = new Intent(ACTION_TURN_PROFILE_ON_NOTIFICATION);\n        intent.setPackage(mContext.getPackageName());\n        intent.putExtra(Intent.EXTRA_USER_HANDLE, profileUserId);\n\n        // Simple notification action button clicks are immutable\n        final PendingIntent pendingIntent = mInjector.pendingIntentGetBroadcast(mContext,\n                0 /* requestCode */, intent,\n                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n\n        final Notification.Action turnProfileOnButton = new Notification.Action.Builder(\n                /* icon= */ null, getPersonalAppSuspensionButtonText(), pendingIntent).build();\n\n        final String text;\n        final boolean ongoing;\n        if (notificationState == PROFILE_OFF_NOTIFICATION_WARNING) {\n            // Round to the closest integer number of days.\n            final int maxDays = (int)\n                    ((profileOwner.mProfileMaximumTimeOffMillis + MS_PER_DAY / 2) / MS_PER_DAY);\n            final String date = DateUtils.formatDateTime(\n                    mContext, profileOwner.mProfileOffDeadline, DateUtils.FORMAT_SHOW_DATE);\n            final String time = DateUtils.formatDateTime(\n                    mContext, profileOwner.mProfileOffDeadline, DateUtils.FORMAT_SHOW_TIME);\n            text = getPersonalAppSuspensionSoonText(date, time, maxDays);\n            ongoing = false;\n        } else {\n            text = getPersonalAppSuspensionText();\n            ongoing = true;\n        }\n        final int color = mContext.getColor(R.color.personal_apps_suspension_notification_color);\n        final Bundle extras = new Bundle();\n        // TODO: Create a separate string for this.\n        extras.putString(\n                Notification.EXTRA_SUBSTITUTE_APP_NAME, getWorkProfileContentDescription());\n\n        final Notification notification =\n                new Notification.Builder(mContext, SystemNotificationChannels.DEVICE_ADMIN)\n                        .setSmallIcon(R.drawable.ic_corp_badge_no_background)\n                        .setOngoing(ongoing)\n                        .setAutoCancel(false)\n                        .setContentTitle(getPersonalAppSuspensionTitle())\n                        .setContentText(text)\n                        .setStyle(new Notification.BigTextStyle().bigText(text))\n                        .setColor(color)\n                        .addAction(turnProfileOnButton)\n                        .addExtras(extras)\n                        .build();\n\n        mHandler.post(() -> mInjector.getNotificationManager().notifyAsUser(\n                null, SystemMessage.NOTE_PERSONAL_APPS_SUSPENDED, notification,\n                UserHandle.of(getProfileParentId(profileUserId))));\n    }\n\n    private String getPersonalAppSuspensionButtonText() {\n        return getUpdatableString(\n                PERSONAL_APP_SUSPENSION_TURN_ON_PROFILE,\n                R.string.personal_apps_suspended_turn_profile_on);\n    }\n\n    private String getPersonalAppSuspensionTitle() {\n        return getUpdatableString(\n                PERSONAL_APP_SUSPENSION_TITLE, R.string.personal_apps_suspension_title);\n    }\n\n    private String getPersonalAppSuspensionText() {\n        return getUpdatableString(\n                PERSONAL_APP_SUSPENSION_MESSAGE, R.string.personal_apps_suspension_text);\n    }\n\n    private String getPersonalAppSuspensionSoonText(String date, String time, int maxDays) {\n        return getUpdatableString(\n                PERSONAL_APP_SUSPENSION_SOON_MESSAGE, R.string.personal_apps_suspension_soon_text,\n                date, time, maxDays);\n    }\n\n    private String getWorkProfileContentDescription() {\n        return getUpdatableString(\n                NOTIFICATION_WORK_PROFILE_CONTENT_DESCRIPTION,\n                R.string.notification_work_profile_content_description);\n    }\n\n    @Override\n    public void setManagedProfileMaximumTimeOff(ComponentName who, long timeoutMillis) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkArgumentNonnegative(timeoutMillis, \"Timeout must be non-negative.\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        // DO shouldn't be able to use this method.\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n        Preconditions.checkState(canHandleCheckPolicyComplianceIntent(caller));\n\n        final int userId = caller.getUserId();\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(userId);\n\n            // Ensure the timeout is long enough to avoid having bad user experience.\n            if (timeoutMillis > 0 && timeoutMillis < MANAGED_PROFILE_MAXIMUM_TIME_OFF_THRESHOLD\n                    && !isAdminTestOnlyLocked(who, userId)) {\n                timeoutMillis = MANAGED_PROFILE_MAXIMUM_TIME_OFF_THRESHOLD;\n            }\n            if (admin.mProfileMaximumTimeOffMillis == timeoutMillis) {\n                return;\n            }\n            admin.mProfileMaximumTimeOffMillis = timeoutMillis;\n            saveSettingsLocked(userId);\n        }\n\n        mInjector.binderWithCleanCallingIdentity(\n                () -> updatePersonalAppsSuspension(userId));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_MANAGED_PROFILE_MAXIMUM_TIME_OFF)\n                .setAdmin(caller.getComponentName())\n                .setTimePeriod(timeoutMillis)\n                .write();\n    }\n\n    private boolean canHandleCheckPolicyComplianceIntent(CallerIdentity caller) {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            final Intent intent = new Intent(DevicePolicyManager.ACTION_CHECK_POLICY_COMPLIANCE);\n            intent.setPackage(caller.getPackageName());\n            final List<ResolveInfo> handlers =\n                    mInjector.getPackageManager().queryIntentActivitiesAsUser(intent, /* flags= */\n                            0, caller.getUserId());\n            return !handlers.isEmpty();\n        });\n        return true;\n    }\n\n    @Override\n    public long getManagedProfileMaximumTimeOff(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return admin.mProfileMaximumTimeOffMillis;\n        }\n    }\n\n    @Override\n    public void acknowledgeDeviceCompliant() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n        enforceUserUnlocked(caller.getUserId());\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (admin.mProfileOffDeadline > 0) {\n                admin.mProfileOffDeadline = 0;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public boolean isComplianceAcknowledgementRequired() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n        enforceUserUnlocked(caller.getUserId());\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return admin.mProfileOffDeadline != 0;\n        }\n    }\n\n    @Override\n    public boolean canProfileOwnerResetPasswordWhenLocked(int userId) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG,\n                        \"call canProfileOwnerResetPasswordWhenLocked\"));\n        synchronized (getLockObject()) {\n            final ActiveAdmin poAdmin = getProfileOwnerAdminLocked(userId);\n            DevicePolicyData policy = getUserData(userId);\n            if (poAdmin == null\n                    || getEncryptionStatus() != ENCRYPTION_STATUS_ACTIVE_PER_USER\n                    || !isResetPasswordTokenActiveForUserLocked(\n                            policy.mPasswordTokenHandle, userId)) {\n                return false;\n            }\n            final ApplicationInfo poAppInfo;\n            try {\n                poAppInfo = mIPackageManager.getApplicationInfo(\n                        poAdmin.info.getPackageName(), 0 /* flags */, userId);\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Failed to query PO app info\", e);\n                return false;\n            }\n            if (poAppInfo == null) {\n                Slogf.wtf(LOG_TAG, \"Cannot find AppInfo for profile owner\");\n                return false;\n            }\n            if (!poAppInfo.isEncryptionAware()) {\n                return false;\n            }\n            Slogf.d(LOG_TAG, \"PO should be able to reset password from direct boot\");\n            return true;\n        }\n    }\n\n    @Override\n    public String getEnrollmentSpecificId(String callerPackage) {\n        if (!mHasFeature) {\n            return \"\";\n        }\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller)\n                        || isCallerDelegate(caller, DELEGATION_CERT_INSTALL));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin requiredAdmin = getDeviceOrProfileOwnerAdminLocked(\n                    caller.getUserId());\n            final String esid = requiredAdmin.mEnrollmentSpecificId;\n            return esid != null ? esid : \"\";\n        }\n    }\n\n    @Override\n    public void setOrganizationIdForUser(\n            @NonNull String callerPackage, @NonNull String organizationId, int userId) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(callerPackage);\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        // Only the DPC can set this ID.\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller) || isProfileOwner(caller),\n                \"Only a Device Owner or Profile Owner may set the Enterprise ID.\");\n        // Empty enterprise ID must not be provided in calls to this method.\n        Preconditions.checkArgument(!TextUtils.isEmpty(organizationId),\n                \"Enterprise ID may not be empty.\");\n\n        Slogf.i(LOG_TAG, \"Setting Enterprise ID to %s for user %d\", organizationId, userId);\n\n        synchronized (mESIDInitilizationLock) {\n            if (mEsidCalculator == null) {\n                mInjector.binderWithCleanCallingIdentity(() -> {\n                    mEsidCalculator = mInjector.newEnterpriseSpecificIdCalculator();\n                });\n            }\n        }\n\n        final String ownerPackage;\n        synchronized (getLockObject()) {\n            final ActiveAdmin owner = getDeviceOrProfileOwnerAdminLocked(userId);\n            // As the caller is the system, it must specify the component name of the profile owner\n            // as a safety check.\n            Preconditions.checkCallAuthorization(\n                    owner != null && owner.getUserHandle().getIdentifier() == userId,\n                    String.format(\"The Profile Owner or Device Owner may only set the Enterprise ID\"\n                            + \" on its own user, called on user %d but owner user is %d\", userId,\n                            owner.getUserHandle().getIdentifier()));\n            ownerPackage = owner.info.getPackageName();\n            Preconditions.checkState(\n                    TextUtils.isEmpty(owner.mOrganizationId) || owner.mOrganizationId.equals(\n                            organizationId),\n                    \"The organization ID has been previously set to a different value and cannot \"\n                            + \"be changed\");\n            final String dpcPackage = owner.info.getPackageName();\n            final String esid = mEsidCalculator.calculateEnterpriseId(dpcPackage,\n                    organizationId);\n            owner.mOrganizationId = organizationId;\n            owner.mEnrollmentSpecificId = esid;\n            saveSettingsLocked(userId);\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_ORGANIZATION_ID)\n                .setAdmin(ownerPackage)\n                .setBoolean(isManagedProfile(userId))\n                .write();\n    }\n\n    @Override\n    public void clearOrganizationIdForUser(int userHandle) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin owner = getDeviceOrProfileOwnerAdminLocked(userHandle);\n            owner.mOrganizationId = null;\n            owner.mEnrollmentSpecificId = null;\n            saveSettingsLocked(userHandle);\n        }\n    }\n\n    @Override\n    public UserHandle createAndProvisionManagedProfile(\n            @NonNull ManagedProfileProvisioningParams provisioningParams,\n            @NonNull String callerPackage) {\n        Objects.requireNonNull(provisioningParams, \"provisioningParams is null\");\n        Objects.requireNonNull(callerPackage, \"callerPackage is null\");\n\n        final ComponentName admin = provisioningParams.getProfileAdminComponentName();\n        Objects.requireNonNull(admin, \"admin is null\");\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        provisioningParams.logParams(callerPackage);\n\n        UserInfo userInfo = null;\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int result = checkProvisioningPreconditionSkipPermission(\n                    ACTION_PROVISION_MANAGED_PROFILE, admin.getPackageName(), caller.getUserId());\n            if (result != STATUS_OK) {\n                throw new ServiceSpecificException(\n                        ERROR_PRE_CONDITION_FAILED,\n                        \"Provisioning preconditions failed with result: \" + result);\n            }\n\n            final long startTime = SystemClock.elapsedRealtime();\n\n            onCreateAndProvisionManagedProfileStarted(provisioningParams);\n\n            final Set<String> nonRequiredApps = provisioningParams.isLeaveAllSystemAppsEnabled()\n                    ? Collections.emptySet()\n                    : mOverlayPackagesProvider.getNonRequiredApps(\n                            admin, caller.getUserId(), ACTION_PROVISION_MANAGED_PROFILE);\n            if (nonRequiredApps.isEmpty()) {\n                Slogf.i(LOG_TAG, \"No disallowed packages for the managed profile.\");\n            } else {\n                for (String packageName : nonRequiredApps) {\n                    Slogf.i(LOG_TAG, \"Disallowed package [\" + packageName + \"]\");\n                }\n            }\n\n            userInfo = mUserManager.createProfileForUserEvenWhenDisallowed(\n                    provisioningParams.getProfileName(),\n                    UserManager.USER_TYPE_PROFILE_MANAGED,\n                    UserInfo.FLAG_DISABLED,\n                    caller.getUserId(),\n                    nonRequiredApps.toArray(new String[nonRequiredApps.size()]));\n            if (userInfo == null) {\n                throw new ServiceSpecificException(\n                        ERROR_PROFILE_CREATION_FAILED,\n                        \"Error creating profile, createProfileForUserEvenWhenDisallowed \"\n                                + \"returned null.\");\n            }\n            resetInteractAcrossProfilesAppOps(caller.getUserId());\n            logEventDuration(\n                    DevicePolicyEnums.PLATFORM_PROVISIONING_CREATE_PROFILE_MS,\n                    startTime,\n                    callerPackage);\n\n            maybeInstallDevicePolicyManagementRoleHolderInUser(userInfo.id);\n\n            installExistingAdminPackage(userInfo.id, admin.getPackageName());\n            if (!enableAdminAndSetProfileOwner(userInfo.id, caller.getUserId(), admin)) {\n                throw new ServiceSpecificException(\n                        ERROR_SETTING_PROFILE_OWNER_FAILED,\n                        \"Error setting profile owner.\");\n            }\n            setUserSetupComplete(userInfo.id);\n\n            startProfileForSetup(userInfo.id, callerPackage);\n            maybeMigrateAccount(\n                    userInfo.id, caller.getUserId(), provisioningParams.getAccountToMigrate(),\n                    provisioningParams.isKeepingAccountOnMigration(), callerPackage);\n\n            if (provisioningParams.isOrganizationOwnedProvisioning()) {\n                synchronized (getLockObject()) {\n                    setProfileOwnerOnOrganizationOwnedDeviceUncheckedLocked(admin, userInfo.id,\n                            true);\n                }\n            }\n\n            onCreateAndProvisionManagedProfileCompleted(provisioningParams);\n\n            sendProvisioningCompletedBroadcast(\n                    userInfo.id,\n                    ACTION_PROVISION_MANAGED_PROFILE,\n                    provisioningParams.isLeaveAllSystemAppsEnabled());\n\n            return userInfo.getUserHandle();\n        } catch (Exception e) {\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.PLATFORM_PROVISIONING_ERROR)\n                    .setStrings(callerPackage)\n                    .write();\n            // In case of any errors during provisioning, remove the newly created profile.\n            if (userInfo != null) {\n                mUserManager.removeUserEvenWhenDisallowed(userInfo.id);\n            }\n            throw e;\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void finalizeWorkProfileProvisioning(UserHandle managedProfileUser,\n            Account migratedAccount) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        if (!isManagedProfile(managedProfileUser.getIdentifier())) {\n            throw new IllegalStateException(\"Given user is not a managed profile\");\n        }\n        ComponentName profileOwnerComponent =\n                mOwners.getProfileOwnerComponent(managedProfileUser.getIdentifier());\n        if (profileOwnerComponent == null) {\n            throw new IllegalStateException(\"There is no profile owner on the given profile\");\n        }\n        Intent primaryProfileSuccessIntent = new Intent(ACTION_MANAGED_PROFILE_PROVISIONED);\n        primaryProfileSuccessIntent.setPackage(profileOwnerComponent.getPackageName());\n        primaryProfileSuccessIntent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES\n                | Intent.FLAG_RECEIVER_FOREGROUND);\n        primaryProfileSuccessIntent.putExtra(Intent.EXTRA_USER, managedProfileUser);\n\n        if (migratedAccount != null) {\n            primaryProfileSuccessIntent.putExtra(EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE,\n                    migratedAccount);\n        }\n\n        mContext.sendBroadcastAsUser(primaryProfileSuccessIntent,\n                UserHandle.of(getProfileParentId(managedProfileUser.getIdentifier())));\n    }\n\n    /**\n     * Callback called at the beginning of {@link #createAndProvisionManagedProfile(\n     * ManagedProfileProvisioningParams, String)} after the relevant prechecks have passed.\n     *\n     * <p>The logic in this method blocks provisioning.\n     *\n     * <p>This method is meant to be overridden by OEMs.\n     */\n    private void onCreateAndProvisionManagedProfileStarted(\n            ManagedProfileProvisioningParams provisioningParams) {}\n\n    /**\n     * Callback called at the end of {@link #createAndProvisionManagedProfile(\n     * ManagedProfileProvisioningParams, String)} after all the other provisioning tasks\n     * have completed successfully.\n     *\n     * <p>The logic in this method blocks provisioning.\n     *\n     * <p>This method is meant to be overridden by OEMs.\n     */\n    private void onCreateAndProvisionManagedProfileCompleted(\n            ManagedProfileProvisioningParams provisioningParams) {}\n\n    private void maybeInstallDevicePolicyManagementRoleHolderInUser(int targetUserId) {\n        String devicePolicyManagerRoleHolderPackageName =\n                getRoleHolderPackageName(mContext, RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT);\n        if (devicePolicyManagerRoleHolderPackageName == null) {\n            Slogf.d(LOG_TAG, \"No device policy management role holder specified.\");\n            return;\n        }\n        try {\n            if (mIPackageManager.isPackageAvailable(\n                    devicePolicyManagerRoleHolderPackageName, targetUserId)) {\n                Slogf.d(LOG_TAG, \"The device policy management role holder \"\n                        + devicePolicyManagerRoleHolderPackageName + \" is already installed in \"\n                        + \"user \" + targetUserId);\n                return;\n            }\n            Slogf.d(LOG_TAG, \"Installing the device policy management role holder \"\n                    + devicePolicyManagerRoleHolderPackageName + \" in user \" + targetUserId);\n            mIPackageManager.installExistingPackageAsUser(\n                    devicePolicyManagerRoleHolderPackageName,\n                    targetUserId,\n                    PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                    PackageManager.INSTALL_REASON_POLICY,\n                    /* whiteListedPermissions= */ null);\n        } catch (RemoteException e) {\n            // Does not happen, same process\n        }\n    }\n\n    /**\n     * If multiple packages hold the role, returns the first package in the list.\n     */\n    @Nullable\n    private String getRoleHolderPackageName(Context context, String role) {\n        return getRoleHolderPackageNameOnUser(context, role, Process.myUserHandle());\n    }\n\n    /**\n     * If multiple packages hold the role, returns the first package in the list.\n     */\n    @Nullable\n    private String getRoleHolderPackageNameOnUser(Context context, String role, UserHandle user) {\n        RoleManager roleManager = context.getSystemService(RoleManager.class);\n\n        // Calling identity needs to be cleared as this method is used in the permissions checks.\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            List<String> roleHolders = roleManager.getRoleHoldersAsUser(role, user);\n            if (roleHolders.isEmpty()) {\n                return null;\n            }\n            return roleHolders.get(0);\n        });\n    }\n\n    private boolean isCallerDevicePolicyManagementRoleHolder(CallerIdentity caller) {\n        return doesCallerHoldRole(caller, RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT);\n    }\n\n    private boolean isCallerSystemSupervisionRoleHolder(CallerIdentity caller) {\n        return doesCallerHoldRole(caller, RoleManager.ROLE_SYSTEM_SUPERVISION);\n    }\n\n    /**\n     * Check if the caller is holding the given role on the calling user.\n     *\n     * @param caller the caller you wish to check\n     * @param role the name of the role to check for.\n     * @return {@code true} if the caller holds the role, {@code false} otherwise.\n     */\n    private boolean doesCallerHoldRole(CallerIdentity caller, String role) {\n        int callerUid = caller.getUid();\n        String roleHolderPackageName =\n                getRoleHolderPackageNameOnUser(role, caller.getUserId());\n        int roleHolderUid = mInjector.getPackageManagerInternal().getPackageUid(\n                roleHolderPackageName, 0, caller.getUserId());\n\n        return callerUid == roleHolderUid;\n    }\n\n    /**\n     * Return the package name of the role holder on the given user.\n     *\n     * <p>If the userId passed in is {@link UserHandle.USER_ALL} then every user will be checked and\n     * the package name of the role holder on the first user where there is a role holder is\n     * returned.\n     *\n     * @param role the name of the role to check for.\n     * @param userId the userId to check for the role holder on.\n     * @return the package name of the role holder\n     */\n    @Nullable\n    private String getRoleHolderPackageNameOnUser(String role, int userId) {\n        RoleManager roleManager = mContext.getSystemService(RoleManager.class);\n\n        // Clear calling identity as the RoleManager APIs require privileged permissions.\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            List<UserInfo> users;\n            // Interpret USER_ALL as meaning \"any\" user.\n            if (userId == UserHandle.USER_ALL) {\n                users = mInjector.getUserManagerInternal().getUsers(/*excludeDying=*/ true);\n            } else {\n                users = List.of(new UserInfo(userId, /*name=*/ null, /*flags=*/ 0));\n            }\n            for (UserInfo user : users) {\n                List<String> roleHolders =\n                        roleManager.getRoleHoldersAsUser(role, user.getUserHandle());\n                if (!roleHolders.isEmpty()) {\n                    return roleHolders.get(0);\n                }\n            }\n            return null;\n        });\n    }\n\n    private void resetInteractAcrossProfilesAppOps(@UserIdInt int userId) {\n        mInjector.getCrossProfileApps(userId).clearInteractAcrossProfilesAppOps();\n        pregrantDefaultInteractAcrossProfilesAppOps(userId);\n    }\n\n    private void pregrantDefaultInteractAcrossProfilesAppOps(@UserIdInt int userId) {\n        final String op =\n                AppOpsManager.permissionToOp(Manifest.permission.INTERACT_ACROSS_PROFILES);\n        for (String packageName : getConfigurableDefaultCrossProfilePackages(userId)) {\n            if (!appOpIsDefaultOrAllowed(userId, op, packageName)) {\n                continue;\n            }\n            mInjector.getCrossProfileApps(userId).setInteractAcrossProfilesAppOp(\n                    packageName, MODE_ALLOWED);\n        }\n    }\n\n    private Set<String> getConfigurableDefaultCrossProfilePackages(@UserIdInt int userId) {\n        List<String> defaultPackages = getDefaultCrossProfilePackages();\n        return defaultPackages.stream().filter(\n                mInjector.getCrossProfileApps(userId)::canConfigureInteractAcrossProfiles).collect(\n                Collectors.toSet());\n    }\n\n    private boolean appOpIsDefaultOrAllowed(@UserIdInt int userId, String op, String packageName) {\n        try {\n            final int uid = mContext.createContextAsUser(UserHandle.of(userId), /* flags= */ 0).\n                    getPackageManager().getPackageUid(packageName, /* flags= */ 0);\n            int mode = mInjector.getAppOpsManager().unsafeCheckOpNoThrow(\n                    op, uid, packageName);\n            return mode == MODE_ALLOWED || mode == MODE_DEFAULT;\n        } catch (NameNotFoundException e) {\n            return false;\n        }\n    }\n\n    private void installExistingAdminPackage(int userId, String packageName) {\n        try {\n            final int status = mContext.getPackageManager().installExistingPackageAsUser(\n                    packageName,\n                    userId);\n            if (status != PackageManager.INSTALL_SUCCEEDED) {\n                throw new ServiceSpecificException(\n                        ERROR_ADMIN_PACKAGE_INSTALLATION_FAILED,\n                        String.format(\"Failed to install existing package %s for user %d with \"\n                                        + \"result code %d\",\n                                packageName, userId, status));\n            }\n        } catch (NameNotFoundException e) {\n            throw new ServiceSpecificException(\n                    ERROR_ADMIN_PACKAGE_INSTALLATION_FAILED,\n                    String.format(\"Failed to install existing package %s for user %d: %s\",\n                            packageName, userId, e.getMessage()));\n        }\n    }\n\n    private boolean enableAdminAndSetProfileOwner(\n            @UserIdInt int userId, @UserIdInt int callingUserId, ComponentName adminComponent) {\n        enableAndSetActiveAdmin(userId, callingUserId, adminComponent);\n        return setProfileOwner(adminComponent, userId);\n    }\n\n    private void enableAndSetActiveAdmin(\n            @UserIdInt int userId, @UserIdInt int callingUserId, ComponentName adminComponent) {\n        final String adminPackage = adminComponent.getPackageName();\n        enablePackage(adminPackage, callingUserId);\n        setActiveAdmin(adminComponent, /* refreshing= */ true, userId);\n    }\n\n    private void enablePackage(String packageName, @UserIdInt int userId) {\n        try {\n            final int enabledSetting = mIPackageManager.getApplicationEnabledSetting(\n                    packageName, userId);\n            if (enabledSetting != PackageManager.COMPONENT_ENABLED_STATE_DEFAULT\n                    && enabledSetting != PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {\n                mIPackageManager.setApplicationEnabledSetting(\n                        packageName,\n                        PackageManager.COMPONENT_ENABLED_STATE_DEFAULT,\n                        // Device policy app may have launched ManagedProvisioning, play nice and\n                        // don't kill it as a side-effect of this call.\n                        PackageManager.DONT_KILL_APP,\n                        userId,\n                        mContext.getOpPackageName());\n            }\n        } catch (RemoteException e) {\n            // Shouldn't happen.\n            Slogf.wtf(LOG_TAG, \"Error setting application enabled\", e);\n        }\n    }\n\n    private void setUserSetupComplete(@UserIdInt int userId) {\n        Settings.Secure.putIntForUser(\n                mContext.getContentResolver(), USER_SETUP_COMPLETE, 1, userId);\n    }\n\n    private void startProfileForSetup(@UserIdInt int userId, String callerPackage)\n            throws IllegalStateException {\n        Slogf.i(LOG_TAG, \"Starting profile %d as requested by package %s\", userId, callerPackage);\n        final long startTime = SystemClock.elapsedRealtime();\n        final UserUnlockedBlockingReceiver unlockedReceiver = new UserUnlockedBlockingReceiver(\n                userId);\n        mContext.registerReceiverAsUser(\n                unlockedReceiver,\n                new UserHandle(userId),\n                new IntentFilter(Intent.ACTION_USER_UNLOCKED),\n                /* broadcastPermission = */ null,\n                /* scheduler= */ null);\n        try {\n            // Must call startProfileEvenWhenDisabled(), as profile is not enabled yet\n            if (!mInjector.getActivityManagerInternal().startProfileEvenWhenDisabled(userId)) {\n                throw new ServiceSpecificException(ERROR_STARTING_PROFILE_FAILED,\n                        String.format(\"Unable to start user %d in background\", userId));\n            }\n\n            if (!unlockedReceiver.waitForUserUnlocked()) {\n                throw new ServiceSpecificException(ERROR_STARTING_PROFILE_FAILED,\n                        String.format(\"Timeout whilst waiting for unlock of user %d.\", userId));\n            }\n            logEventDuration(\n                    DevicePolicyEnums.PLATFORM_PROVISIONING_START_PROFILE_MS,\n                    startTime,\n                    callerPackage);\n        } finally {\n            mContext.unregisterReceiver(unlockedReceiver);\n        }\n    }\n\n    private void maybeMigrateAccount(\n            @UserIdInt int targetUserId, @UserIdInt int sourceUserId, Account accountToMigrate,\n            boolean keepAccountMigrated, String callerPackage) {\n        final UserHandle sourceUser = UserHandle.of(sourceUserId);\n        final UserHandle targetUser = UserHandle.of(targetUserId);\n        if (accountToMigrate == null) {\n            Slogf.d(LOG_TAG, \"No account to migrate.\");\n            return;\n        }\n        if (sourceUser.equals(targetUser)) {\n            Slogf.w(LOG_TAG, \"sourceUser and targetUser are the same, won't migrate account.\");\n            return;\n        }\n        copyAccount(targetUser, sourceUser, accountToMigrate, callerPackage);\n        if (!keepAccountMigrated) {\n            removeAccount(accountToMigrate, sourceUserId);\n        }\n    }\n\n    private void copyAccount(\n            UserHandle targetUser, UserHandle sourceUser, Account accountToMigrate,\n            String callerPackage) {\n        final long startTime = SystemClock.elapsedRealtime();\n        try {\n            final AccountManager accountManager = mContext.getSystemService(AccountManager.class);\n            final boolean copySucceeded = accountManager.copyAccountToUser(\n                    accountToMigrate,\n                    sourceUser,\n                    targetUser,\n                    /* callback= */ null, /* handler= */ null)\n                    .getResult(60 * 3, TimeUnit.SECONDS);\n            if (copySucceeded) {\n                logCopyAccountStatus(COPY_ACCOUNT_SUCCEEDED, callerPackage);\n                logEventDuration(\n                        DevicePolicyEnums.PLATFORM_PROVISIONING_COPY_ACCOUNT_MS,\n                        startTime,\n                        callerPackage);\n            } else {\n                logCopyAccountStatus(COPY_ACCOUNT_FAILED, callerPackage);\n                Slogf.e(LOG_TAG, \"Failed to copy account to \" + targetUser);\n            }\n        } catch (OperationCanceledException e) {\n            // Account migration is not considered a critical operation.\n            logCopyAccountStatus(COPY_ACCOUNT_TIMED_OUT, callerPackage);\n            Slogf.e(LOG_TAG, \"Exception copying account to \" + targetUser, e);\n        } catch (AuthenticatorException | IOException e) {\n            logCopyAccountStatus(COPY_ACCOUNT_EXCEPTION, callerPackage);\n            Slogf.e(LOG_TAG, \"Exception copying account to \" + targetUser, e);\n        }\n    }\n\n    private static void logCopyAccountStatus(@CopyAccountStatus int status, String callerPackage) {\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.PLATFORM_PROVISIONING_COPY_ACCOUNT_STATUS)\n                .setInt(status)\n                .setStrings(callerPackage)\n                .write();\n    }\n\n    private void removeAccount(Account account, @UserIdInt int sourceUserId) {\n        final AccountManager accountManager = mContext.createContextAsUser(\n                        UserHandle.of(sourceUserId), /* flags= */ 0)\n                .getSystemService(AccountManager.class);\n        try {\n            final Bundle result = accountManager.removeAccount(account,\n                    null, null /* callback */, null /* handler */).getResult(60, TimeUnit.SECONDS);\n            if (result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, /* default */ false)) {\n                Slogf.i(LOG_TAG, \"Account removed from the primary user.\");\n            } else {\n                // TODO(174768447): Revisit start activity logic.\n                final Intent removeIntent = result.getParcelable(AccountManager.KEY_INTENT, android.content.Intent.class);\n                removeIntent.addFlags(FLAG_ACTIVITY_NEW_TASK);\n                if (removeIntent != null) {\n                    Slogf.i(LOG_TAG, \"Starting activity to remove account\");\n                    new Handler(Looper.getMainLooper()).post(() -> {\n                        mContext.startActivity(removeIntent);\n                    });\n                } else {\n                    Slogf.e(LOG_TAG, \"Could not remove account from the primary user.\");\n                }\n            }\n        } catch (OperationCanceledException | AuthenticatorException | IOException e) {\n            Slogf.e(LOG_TAG, \"Exception removing account from the primary user.\", e);\n        }\n    }\n\n    @Override\n    public void provisionFullyManagedDevice(\n            @NonNull FullyManagedDeviceProvisioningParams provisioningParams,\n            @NonNull String callerPackage) {\n        Objects.requireNonNull(provisioningParams, \"provisioningParams is null.\");\n        Objects.requireNonNull(callerPackage, \"callerPackage is null.\");\n\n        ComponentName deviceAdmin = provisioningParams.getDeviceAdminComponentName();\n        Objects.requireNonNull(deviceAdmin, \"admin is null.\");\n        Objects.requireNonNull(provisioningParams.getOwnerName(), \"owner name is null.\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS)\n                        || (hasCallingOrSelfPermission(permission.PROVISION_DEMO_DEVICE)\n                        && provisioningParams.isDemoDevice()));\n\n        provisioningParams.logParams(callerPackage);\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            int result = checkProvisioningPreconditionSkipPermission(\n                    ACTION_PROVISION_MANAGED_DEVICE, deviceAdmin.getPackageName(),\n                    caller.getUserId());\n            if (result != STATUS_OK) {\n                throw new ServiceSpecificException(\n                        ERROR_PRE_CONDITION_FAILED,\n                        \"Provisioning preconditions failed with result: \" + result);\n            }\n            onProvisionFullyManagedDeviceStarted(provisioningParams);\n\n            // These properties are global so will apply on all users\n            setTimeAndTimezone(provisioningParams.getTimeZone(), provisioningParams.getLocalTime());\n            setLocale(provisioningParams.getLocale());\n\n            int deviceOwnerUserId = UserHandle.USER_SYSTEM;\n            if (!removeNonRequiredAppsForManagedDevice(\n                    deviceOwnerUserId,\n                    provisioningParams.isLeaveAllSystemAppsEnabled(),\n                    deviceAdmin)) {\n                throw new ServiceSpecificException(\n                        ERROR_REMOVE_NON_REQUIRED_APPS_FAILED,\n                        \"PackageManager failed to remove non required apps.\");\n            }\n\n\n            if (!setActiveAdminAndDeviceOwner(deviceOwnerUserId, deviceAdmin)) {\n                throw new ServiceSpecificException(\n                        ERROR_SET_DEVICE_OWNER_FAILED, \"Failed to set device owner.\");\n            }\n\n            disallowAddUser();\n            setAdminCanGrantSensorsPermissionForUserUnchecked(\n                    deviceOwnerUserId, provisioningParams.canDeviceOwnerGrantSensorsPermissions());\n            setDemoDeviceStateUnchecked(deviceOwnerUserId, provisioningParams.isDemoDevice());\n            onProvisionFullyManagedDeviceCompleted(provisioningParams);\n            sendProvisioningCompletedBroadcast(\n                    deviceOwnerUserId,\n                    ACTION_PROVISION_MANAGED_DEVICE,\n                    provisioningParams.isLeaveAllSystemAppsEnabled());\n        } catch (Exception e) {\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.PLATFORM_PROVISIONING_ERROR)\n                    .setStrings(callerPackage)\n                    .write();\n            throw e;\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * Callback called at the beginning of {@link #provisionFullyManagedDevice(\n     * FullyManagedDeviceProvisioningParams, String)} after the relevant prechecks have passed.\n     *\n     * <p>The logic in this method blocks provisioning.\n     *\n     * <p>This method is meant to be overridden by OEMs.\n     */\n    private void onProvisionFullyManagedDeviceStarted(\n            FullyManagedDeviceProvisioningParams provisioningParams) {}\n\n    /**\n     * Callback called at the end of {@link #provisionFullyManagedDevice(\n     * FullyManagedDeviceProvisioningParams, String)} after all the other provisioning tasks\n     * have completed successfully.\n     *\n     * <p>The logic in this method blocks provisioning.\n     *\n     * <p>This method is meant to be overridden by OEMs.\n     */\n    private void onProvisionFullyManagedDeviceCompleted(\n            FullyManagedDeviceProvisioningParams provisioningParams) {}\n\n    private void setTimeAndTimezone(String timeZone, long localTime) {\n        try {\n            final AlarmManager alarmManager = mContext.getSystemService(AlarmManager.class);\n            if (timeZone != null) {\n                alarmManager.setTimeZone(timeZone);\n            }\n            if (localTime > 0) {\n                alarmManager.setTime(localTime);\n            }\n        } catch (Exception e) {\n            // Do not stop provisioning and ignore this error.\n            Slogf.e(LOG_TAG, \"Alarm manager failed to set the system time/timezone.\", e);\n        }\n    }\n\n    private void setLocale(Locale locale) {\n        if (locale == null || locale.equals(Locale.getDefault())) {\n            return;\n        }\n        try {\n            // If locale is different from current locale this results in a configuration change,\n            // which will trigger the restarting of the activity.\n            LocalePicker.updateLocale(locale);\n        } catch (Exception e) {\n            // Do not stop provisioning and ignore this error.\n            Slogf.e(LOG_TAG, \"Failed to set the system locale.\", e);\n        }\n    }\n\n    private boolean removeNonRequiredAppsForManagedDevice(\n            @UserIdInt int userId, boolean leaveAllSystemAppsEnabled, ComponentName admin) {\n        Set<String> packagesToDelete = leaveAllSystemAppsEnabled\n                ? Collections.emptySet()\n                : mOverlayPackagesProvider.getNonRequiredApps(\n                        admin, userId, ACTION_PROVISION_MANAGED_DEVICE);\n\n        removeNonInstalledPackages(packagesToDelete, userId);\n        if (packagesToDelete.isEmpty()) {\n            Slogf.i(LOG_TAG, \"No packages to delete on user \" + userId);\n            return true;\n        }\n\n        NonRequiredPackageDeleteObserver packageDeleteObserver =\n                new NonRequiredPackageDeleteObserver(packagesToDelete.size());\n        for (String packageName : packagesToDelete) {\n            Slogf.i(LOG_TAG, \"Deleting package [\" + packageName + \"] as user \" + userId);\n            mContext.getPackageManager().deletePackageAsUser(\n                    packageName,\n                    packageDeleteObserver,\n                    PackageManager.DELETE_SYSTEM_APP,\n                    userId);\n        }\n        Slogf.i(LOG_TAG, \"Waiting for non required apps to be deleted\");\n        return packageDeleteObserver.awaitPackagesDeletion();\n    }\n\n    private void removeNonInstalledPackages(Set<String> packages, @UserIdInt int userId) {\n        final Set<String> toBeRemoved = new HashSet<>();\n        for (String packageName : packages) {\n            if (!isPackageInstalledForUser(packageName, userId)) {\n                toBeRemoved.add(packageName);\n            }\n        }\n        packages.removeAll(toBeRemoved);\n    }\n\n    private void disallowAddUser() {\n        if (!isHeadlessFlagEnabled() || mIsAutomotive) {\n            // Auto still enables adding users due to the communal nature of those devices\n            if (mInjector.userManagerIsHeadlessSystemUserMode()) {\n                Slogf.i(LOG_TAG, \"Not setting DISALLOW_ADD_USER on headless system user mode.\");\n                return;\n            }\n        }\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            UserHandle userHandle = userInfo.getUserHandle();\n            if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_USER, userHandle)) {\n                mUserManager.setUserRestriction(\n                        UserManager.DISALLOW_ADD_USER, /* value= */ true, userHandle);\n            }\n        }\n    }\n\n    private boolean setActiveAdminAndDeviceOwner(\n            @UserIdInt int userId, ComponentName adminComponent) {\n        enableAndSetActiveAdmin(userId, userId, adminComponent);\n        // TODO(b/178187130): Directly set DO and remove the check once silent provisioning is no\n        //  longer used.\n        if (getDeviceOwnerComponent(/* callingUserOnly= */ true) == null) {\n            return setDeviceOwner(adminComponent, userId,\n                    /* setProfileOwnerOnCurrentUserIfNecessary= */ true);\n        }\n        return true;\n    }\n\n    private static void logEventDuration(int eventId, long startTime, String callerPackage) {\n        final long duration = SystemClock.elapsedRealtime() - startTime;\n        DevicePolicyEventLogger\n                .createEvent(eventId)\n                .setTimePeriod(duration)\n                .setStrings(callerPackage)\n                .write();\n    }\n\n    @Override\n    public void resetDefaultCrossProfileIntentFilters(@UserIdInt int userId) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                final List<UserInfo> profiles = mUserManager.getProfiles(userId);\n                final int numOfProfiles = profiles.size();\n                if (numOfProfiles <= 1) {\n                    return;\n                }\n\n                final String managedProvisioningPackageName = getManagedProvisioningPackage(\n                        mContext);\n                // Removes cross profile intent filters from the parent to all the profiles.\n                mIPackageManager.clearCrossProfileIntentFilters(\n                        userId, mContext.getOpPackageName());\n                // Setting and resetting default cross profile intent filters was previously handled\n                // by Managed Provisioning. For backwards compatibility, clear any intent filters\n                // that were set by ManagedProvisioning.\n                mIPackageManager.clearCrossProfileIntentFilters(\n                        userId, managedProvisioningPackageName);\n\n                // For each profile reset cross profile intent filters\n                for (int i = 0; i < numOfProfiles; i++) {\n                    UserInfo profile = profiles.get(i);\n                    mIPackageManager.clearCrossProfileIntentFilters(\n                            profile.id, mContext.getOpPackageName());\n                    // Clear any intent filters that were set by ManagedProvisioning.\n                    mIPackageManager.clearCrossProfileIntentFilters(\n                            profile.id, managedProvisioningPackageName);\n\n                    mUserManagerInternal.setDefaultCrossProfileIntentFilters(userId, profile.id);\n                }\n            } catch (RemoteException e) {\n                // Shouldn't happen.\n                Slogf.wtf(LOG_TAG, \"Error resetting default cross profile intent filters\", e);\n            }\n        });\n    }\n\n    private void setAdminCanGrantSensorsPermissionForUserUnchecked(@UserIdInt int userId,\n            boolean canGrant) {\n        Slogf.d(LOG_TAG, \"setAdminCanGrantSensorsPermissionForUserUnchecked(%d, %b)\",\n                userId, canGrant);\n        synchronized (getLockObject()) {\n            ActiveAdmin owner = getDeviceOrProfileOwnerAdminLocked(userId);\n\n            Preconditions.checkState(\n                    isDeviceOwner(owner) && owner.getUserHandle().getIdentifier() == userId,\n                    \"May only be set on a the user of a device owner.\");\n\n            owner.mAdminCanGrantSensorsPermissions = canGrant;\n            mPolicyCache.setAdminCanGrantSensorsPermissions(canGrant);\n            saveSettingsLocked(userId);\n        }\n    }\n\n    private void setDemoDeviceStateUnchecked(@UserIdInt int userId, boolean isDemoDevice) {\n        Slogf.d(LOG_TAG, \"setDemoDeviceStateUnchecked(%d, %b)\",\n                userId, isDemoDevice);\n        if (!isDemoDevice) {\n            return;\n        }\n        synchronized (getLockObject()) {\n            mInjector.settingsGlobalPutStringForUser(\n                    Settings.Global.DEVICE_DEMO_MODE, Integer.toString(/* value= */ 1), userId);\n        }\n\n        setUserProvisioningState(STATE_USER_SETUP_FINALIZED, userId);\n    }\n\n    private void updateAdminCanGrantSensorsPermissionCache(@UserIdInt int userId) {\n        synchronized (getLockObject()) {\n\n            ActiveAdmin owner;\n            // If the user is affiliated the device (either a DO itself, or an affiliated PO),\n            // use mAdminCanGrantSensorsPermissions from the DO\n            if (isUserAffiliatedWithDeviceLocked(userId)) {\n                owner = getDeviceOwnerAdminLocked();\n            } else {\n                owner = getDeviceOrProfileOwnerAdminLocked(userId);\n            }\n            boolean canGrant = owner != null ? owner.mAdminCanGrantSensorsPermissions : false;\n            mPolicyCache.setAdminCanGrantSensorsPermissions(canGrant);\n        }\n    }\n\n    private void updateNetworkPreferenceForUser(int userId,\n            List<PreferentialNetworkServiceConfig> preferentialNetworkServiceConfigs) {\n        if (!isManagedProfile(userId) && !isDeviceOwnerUserId(userId)) {\n            return;\n        }\n        List<ProfileNetworkPreference> preferences = new ArrayList<>();\n        for (PreferentialNetworkServiceConfig preferentialNetworkServiceConfig :\n                preferentialNetworkServiceConfigs) {\n            ProfileNetworkPreference.Builder preferenceBuilder =\n                    new ProfileNetworkPreference.Builder();\n            if (preferentialNetworkServiceConfig.isEnabled()) {\n                if (preferentialNetworkServiceConfig.isFallbackToDefaultConnectionAllowed()) {\n                    preferenceBuilder.setPreference(PROFILE_NETWORK_PREFERENCE_ENTERPRISE);\n                } else if (preferentialNetworkServiceConfig.shouldBlockNonMatchingNetworks()) {\n                    preferenceBuilder.setPreference(\n                            PROFILE_NETWORK_PREFERENCE_ENTERPRISE_BLOCKING);\n                } else {\n                    preferenceBuilder.setPreference(\n                            PROFILE_NETWORK_PREFERENCE_ENTERPRISE_NO_FALLBACK);\n                }\n                preferenceBuilder.setIncludedUids(\n                        preferentialNetworkServiceConfig.getIncludedUids());\n                preferenceBuilder.setExcludedUids(\n                        preferentialNetworkServiceConfig.getExcludedUids());\n                preferenceBuilder.setPreferenceEnterpriseId(\n                        preferentialNetworkServiceConfig.getNetworkId());\n            } else {\n                preferenceBuilder.setPreference(PROFILE_NETWORK_PREFERENCE_DEFAULT);\n            }\n\n\n            preferences.add(preferenceBuilder.build());\n        }\n        Slogf.d(LOG_TAG, \"updateNetworkPreferenceForUser to \" + preferences);\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.getConnectivityManager().setProfileNetworkPreferences(\n                        UserHandle.of(userId), preferences,\n                        null /* executor */, null /* listener */));\n    }\n\n    @Override\n    public boolean canAdminGrantSensorsPermissions() {\n        if (!mHasFeature) {\n            return false;\n        }\n\n        return mPolicyCache.canAdminGrantSensorsPermissions();\n    }\n\n    @Override\n    public void setDeviceOwnerType(@NonNull ComponentName admin,\n            @DeviceOwnerType int deviceOwnerType) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        synchronized (getLockObject()) {\n            setDeviceOwnerTypeLocked(admin, deviceOwnerType);\n        }\n    }\n\n    private void setDeviceOwnerTypeLocked(ComponentName admin,\n            @DeviceOwnerType int deviceOwnerType) {\n        String packageName = admin.getPackageName();\n        boolean isAdminTestOnly;\n\n        verifyDeviceOwnerTypePreconditionsLocked(admin);\n\n        isAdminTestOnly = isAdminTestOnlyLocked(admin, mOwners.getDeviceOwnerUserId());\n        Preconditions.checkState(isAdminTestOnly\n                        || !mOwners.isDeviceOwnerTypeSetForDeviceOwner(packageName),\n                \"Test only admins can only set the device owner type more than once\");\n\n        mOwners.setDeviceOwnerType(packageName, deviceOwnerType, isAdminTestOnly);\n        setGlobalSettingDeviceOwnerType(deviceOwnerType);\n    }\n\n    // TODO(b/237065504): Allow mainline modules to get the device owner type. This is a workaround\n    // to get the device owner type in PermissionController. See HibernationPolicy.kt.\n    private void setGlobalSettingDeviceOwnerType(int deviceOwnerType) {\n        mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.settingsGlobalPutInt(\"device_owner_type\", deviceOwnerType));\n    }\n\n    @Override\n    @DeviceOwnerType\n    public int getDeviceOwnerType(@NonNull ComponentName admin) {\n        synchronized (getLockObject()) {\n            verifyDeviceOwnerTypePreconditionsLocked(admin);\n            return getDeviceOwnerTypeLocked(admin.getPackageName());\n        }\n    }\n\n    @DeviceOwnerType\n    private int getDeviceOwnerTypeLocked(String packageName) {\n        return mOwners.getDeviceOwnerType(packageName);\n    }\n\n    /**\n     * {@code true} is returned <b>only if</b> the caller is the device owner and the device owner\n     * type is {@link DevicePolicyManager#DEVICE_OWNER_TYPE_FINANCED}. {@code false} is returned for\n     * the case where the caller is not the device owner, there is no device owner, or the device\n     * owner type is not {@link DevicePolicyManager#DEVICE_OWNER_TYPE_FINANCED}.\n     */\n    private boolean isFinancedDeviceOwner(CallerIdentity caller) {\n        synchronized (getLockObject()) {\n            return isDeviceOwnerLocked(caller) && getDeviceOwnerTypeLocked(\n                    mOwners.getDeviceOwnerPackageName()) == DEVICE_OWNER_TYPE_FINANCED;\n        }\n    }\n\n    private void verifyDeviceOwnerTypePreconditionsLocked(@NonNull ComponentName admin) {\n        Preconditions.checkState(mOwners.hasDeviceOwner(), \"there is no device owner\");\n        Preconditions.checkState(mOwners.getDeviceOwnerComponent().equals(admin),\n                \"admin is not the device owner\");\n    }\n\n    @Override\n    public void setUsbDataSignalingEnabled(String packageName, boolean enabled) {\n        Objects.requireNonNull(packageName, \"Admin package name must be provided\");\n        final CallerIdentity caller = getCallerIdentity(packageName);\n        if (!isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller),\n                    \"USB data signaling can only be controlled by a device owner or \"\n                            + \"a profile owner on an organization-owned device.\");\n            Preconditions.checkState(canUsbDataSignalingBeDisabled(),\n                    \"USB data signaling cannot be disabled.\");\n        }\n\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            if (isPermissionCheckFlagEnabled()) {\n                admin = enforcePermissionAndGetEnforcingAdmin(\n                        /* admin= */ null, MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING,\n                        caller.getPackageName(),\n                        caller.getUserId()).getActiveAdmin();\n            } else {\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n\n            if (admin.mUsbDataSignalingEnabled != enabled) {\n                admin.mUsbDataSignalingEnabled = enabled;\n                saveSettingsLocked(caller.getUserId());\n                updateUsbDataSignal();\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_USB_DATA_SIGNALING)\n                .setAdmin(packageName)\n                .setBoolean(enabled)\n                .write();\n    }\n\n    private void updateUsbDataSignal() {\n        if (!canUsbDataSignalingBeDisabled()) {\n            return;\n        }\n        final boolean usbEnabled;\n        synchronized (getLockObject()) {\n            usbEnabled = isUsbDataSignalingEnabledInternalLocked();\n        }\n        if (!mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getUsbManager().enableUsbDataSignal(usbEnabled))) {\n            Slogf.w(LOG_TAG, \"Failed to set usb data signaling state\");\n        }\n    }\n\n    @Override\n    public boolean isUsbDataSignalingEnabled(String packageName) {\n        final CallerIdentity caller = getCallerIdentity(packageName);\n        synchronized (getLockObject()) {\n            // If the caller is an admin, return the policy set by itself. Otherwise\n            // return the device-wide policy.\n            if (isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller)) {\n                return getProfileOwnerOrDeviceOwnerLocked(\n                        caller.getUserId()).mUsbDataSignalingEnabled;\n            } else {\n                return isUsbDataSignalingEnabledInternalLocked();\n            }\n        }\n    }\n\n    @Override\n    public boolean isUsbDataSignalingEnabledForUser(int userId) {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isSystemUid(caller));\n\n        synchronized (getLockObject()) {\n            return isUsbDataSignalingEnabledInternalLocked();\n        }\n    }\n\n    private boolean isUsbDataSignalingEnabledInternalLocked() {\n        // TODO(b/261999445): remove\n        ActiveAdmin admin;\n        if (isHeadlessFlagEnabled()) {\n            admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n        } else {\n            admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked(\n                    UserHandle.USER_SYSTEM);\n        }\n        return admin == null || admin.mUsbDataSignalingEnabled;\n    }\n\n    @Override\n    public boolean canUsbDataSignalingBeDisabled() {\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.getUsbManager() != null\n                        && mInjector.getUsbManager().getUsbHalVersion() >= UsbManager.USB_HAL_V1_3\n        );\n    }\n\n    private void notifyMinimumRequiredWifiSecurityLevelChanged(int level) {\n        mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getWifiManager()\n                        .notifyMinimumRequiredWifiSecurityLevelChanged(level));\n    }\n\n    private void notifyWifiSsidPolicyChanged(WifiSsidPolicy policy) {\n        if (policy == null) {\n            // If policy doesn't limit SSIDs, no need to disconnect anything.\n            return;\n        }\n        mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getWifiManager().notifyWifiSsidPolicyChanged(policy));\n    }\n\n    @Override\n    public void setMinimumRequiredWifiSecurityLevel(String callerPackageName, int level) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(callerPackageName);\n        } else {\n            caller = getCallerIdentity();\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller),\n                    \"Wi-Fi minimum security level can only be controlled by a device owner or \"\n                            + \"a profile owner on an organization-owned device.\");\n        }\n\n        boolean valueChanged = false;\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            if (isPermissionCheckFlagEnabled()) {\n                admin = enforcePermissionAndGetEnforcingAdmin(/* admin= */ null,\n                        MANAGE_DEVICE_POLICY_WIFI, caller.getPackageName(), caller.getUserId())\n                        .getActiveAdmin();\n            } else {\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n            if (admin.mWifiMinimumSecurityLevel != level) {\n                admin.mWifiMinimumSecurityLevel = level;\n                saveSettingsLocked(caller.getUserId());\n                valueChanged = true;\n            }\n        }\n        if (valueChanged) notifyMinimumRequiredWifiSecurityLevelChanged(level);\n    }\n\n    @Override\n    public int getMinimumRequiredWifiSecurityLevel() {\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            // TODO(b/261999445): remove\n            if (isHeadlessFlagEnabled()) {\n                admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n            } else {\n                admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked(\n                        UserHandle.USER_SYSTEM);\n            }\n            return (admin == null) ? DevicePolicyManager.WIFI_SECURITY_OPEN\n                    : admin.mWifiMinimumSecurityLevel;\n        }\n    }\n\n    @Override\n    public WifiSsidPolicy getWifiSsidPolicy(String callerPackageName) {\n        final CallerIdentity caller = getCallerIdentity();\n        if (isPermissionCheckFlagEnabled()) {\n            enforcePermission(MANAGE_DEVICE_POLICY_WIFI, callerPackageName,\n                    caller.getUserId());\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller)\n                            || canQueryAdminPolicy(caller),\n                    \"SSID policy can only be retrieved by a device owner or \"\n                            + \"a profile owner on an organization-owned device or \"\n                            + \"an app with the QUERY_ADMIN_POLICY permission.\");\n        }\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceOrSystemPermissionBasedAdminLocked();\n            return admin != null ? admin.mWifiSsidPolicy : null;\n        }\n    }\n\n    @Override\n    public void setWifiSsidPolicy(String callerPackageName, WifiSsidPolicy policy) {\n        CallerIdentity caller;\n\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(callerPackageName);\n        } else {\n            caller = getCallerIdentity();\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller),\n                    \"SSID denylist can only be controlled by a device owner or \"\n                            + \"a profile owner on an organization-owned device.\");\n        }\n\n        boolean changed = false;\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            if (isPermissionCheckFlagEnabled()) {\n                admin = enforcePermissionAndGetEnforcingAdmin(\n                        /* admin= */ null, MANAGE_DEVICE_POLICY_WIFI,\n                        caller.getPackageName(),\n                        caller.getUserId()).getActiveAdmin();\n            } else {\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n            if (!Objects.equals(policy, admin.mWifiSsidPolicy)) {\n                admin.mWifiSsidPolicy = policy;\n                changed = true;\n            }\n            if (changed) saveSettingsLocked(caller.getUserId());\n        }\n        if (changed) {\n            notifyWifiSsidPolicyChanged(policy);\n        }\n    }\n\n    @Override\n    public void setDrawables(@NonNull List<DevicePolicyDrawableResource> drawables) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                android.Manifest.permission.UPDATE_DEVICE_MANAGEMENT_RESOURCES));\n\n        Objects.requireNonNull(drawables, \"drawables must be provided.\");\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (mDeviceManagementResourcesProvider.updateDrawables(drawables)) {\n                sendDrawableUpdatedBroadcast(\n                        drawables.stream().map(s -> s.getDrawableId()).collect(\n                                Collectors.toList()));\n            }\n        });\n    }\n\n    @Override\n    public void resetDrawables(@NonNull List<String> drawableIds) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                android.Manifest.permission.UPDATE_DEVICE_MANAGEMENT_RESOURCES));\n\n        Objects.requireNonNull(drawableIds, \"drawableIds must be provided.\");\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (mDeviceManagementResourcesProvider.removeDrawables(drawableIds)) {\n                sendDrawableUpdatedBroadcast(drawableIds);\n            }\n        });\n    }\n\n    @Override\n    public ParcelableResource getDrawable(\n            String drawableId, String drawableStyle, String drawableSource) {\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mDeviceManagementResourcesProvider.getDrawable(\n                        drawableId, drawableStyle, drawableSource));\n    }\n\n    private void sendDrawableUpdatedBroadcast(List<String> drawableIds) {\n        sendResourceUpdatedBroadcast(EXTRA_RESOURCE_TYPE_DRAWABLE, drawableIds);\n    }\n\n    @Override\n    public void setStrings(@NonNull List<DevicePolicyStringResource> strings) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                android.Manifest.permission.UPDATE_DEVICE_MANAGEMENT_RESOURCES));\n\n        Objects.requireNonNull(strings, \"strings must be provided.\");\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (mDeviceManagementResourcesProvider.updateStrings(strings)) {\n                sendStringsUpdatedBroadcast(\n                        strings.stream().map(s -> s.getStringId()).collect(Collectors.toList()));\n            }\n        });\n    }\n\n    @Override\n    public void resetStrings(@NonNull List<String> stringIds) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                android.Manifest.permission.UPDATE_DEVICE_MANAGEMENT_RESOURCES));\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (mDeviceManagementResourcesProvider.removeStrings(stringIds)) {\n                sendStringsUpdatedBroadcast(stringIds);\n            }\n        });\n    }\n\n    @Override\n    public ParcelableResource getString(String stringId) {\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mDeviceManagementResourcesProvider.getString(stringId));\n    }\n\n    private void sendStringsUpdatedBroadcast(List<String> stringIds) {\n        sendResourceUpdatedBroadcast(EXTRA_RESOURCE_TYPE_STRING, stringIds);\n    }\n\n    private void sendResourceUpdatedBroadcast(int resourceType, List<String> resourceIds) {\n        final Intent intent = new Intent(ACTION_DEVICE_POLICY_RESOURCE_UPDATED);\n        intent.putExtra(EXTRA_RESOURCE_IDS, resourceIds.toArray(String[]::new));\n        intent.putExtra(EXTRA_RESOURCE_TYPE, resourceType);\n        intent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n\n        List<UserInfo> users = mUserManager.getAliveUsers();\n        for (int i = 0; i < users.size(); i++) {\n            UserHandle user = users.get(i).getUserHandle();\n            mContext.sendBroadcastAsUser(intent, user);\n        }\n    }\n\n    private String getUpdatableString(\n            String updatableStringId, int defaultStringId, Object... formatArgs) {\n        ParcelableResource resource = mDeviceManagementResourcesProvider.getString(\n                updatableStringId);\n        if (resource == null) {\n            return ParcelableResource.loadDefaultString(() ->\n                    mContext.getString(defaultStringId, formatArgs));\n        }\n        return resource.getString(\n                mContext, () -> mContext.getString(defaultStringId, formatArgs), formatArgs);\n    }\n\n    public boolean isDpcDownloaded() {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        ContentResolver cr = mContext.getContentResolver();\n\n        return mInjector.binderWithCleanCallingIdentity(() -> Settings.Secure.getIntForUser(\n                cr, MANAGED_PROVISIONING_DPC_DOWNLOADED,\n                /* def= */ 0, /* userHandle= */ cr.getUserId())\n                == 1);\n    }\n\n    public void setDpcDownloaded(boolean downloaded) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        int setTo = downloaded ? 1 : 0;\n\n        mInjector.binderWithCleanCallingIdentity(() -> Settings.Secure.putInt(\n                mContext.getContentResolver(), MANAGED_PROVISIONING_DPC_DOWNLOADED, setTo));\n    }\n\n    @Override\n    public void resetShouldAllowBypassingDevicePolicyManagementRoleQualificationState() {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                android.Manifest.permission.MANAGE_ROLE_HOLDERS));\n        setBypassDevicePolicyManagementRoleQualificationStateInternal(\n                /* currentRoleHolder= */ null, /* allowBypass= */ false);\n    }\n\n    @Override\n    public boolean shouldAllowBypassingDevicePolicyManagementRoleQualification() {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                android.Manifest.permission.MANAGE_ROLE_HOLDERS));\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            if (getUserData(\n                    UserHandle.USER_SYSTEM).mBypassDevicePolicyManagementRoleQualifications) {\n                return true;\n            }\n            return shouldAllowBypassingDevicePolicyManagementRoleQualificationInternal();\n        });\n    }\n\n    private boolean shouldAllowBypassingDevicePolicyManagementRoleQualificationInternal() {\n        if (nonTestNonPrecreatedUsersExist()) {\n            return false;\n        }\n\n\n        return !hasIncompatibleAccountsOnAnyUser();\n    }\n\n    private boolean hasAccountsOnAnyUser() {\n        long callingIdentity = Binder.clearCallingIdentity();\n        try {\n            for (UserInfo user : mUserManagerInternal.getUsers(/* excludeDying= */ true)) {\n                AccountManager am = mContext.createContextAsUser(\n                                UserHandle.of(user.id), /* flags= */ 0)\n                        .getSystemService(AccountManager.class);\n                Account[] accounts = am.getAccounts();\n                if (accounts.length != 0) {\n                    return true;\n                }\n            }\n\n            return false;\n        } finally {\n            Binder.restoreCallingIdentity(callingIdentity);\n        }\n    }\n\n    private void setBypassDevicePolicyManagementRoleQualificationStateInternal(\n            String currentRoleHolder, boolean allowBypass) {\n        boolean stateChanged = false;\n        DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n        if (policy.mBypassDevicePolicyManagementRoleQualifications != allowBypass) {\n            policy.mBypassDevicePolicyManagementRoleQualifications = allowBypass;\n            stateChanged = true;\n        }\n        if (!Objects.equals(currentRoleHolder, policy.mCurrentRoleHolder)) {\n            policy.mCurrentRoleHolder = currentRoleHolder;\n            stateChanged = true;\n        }\n        if (stateChanged) {\n            synchronized (getLockObject()) {\n                saveSettingsLocked(UserHandle.USER_SYSTEM);\n            }\n        }\n    }\n\n    private final class DevicePolicyManagementRoleObserver implements OnRoleHoldersChangedListener {\n        private RoleManager mRm;\n        private final Executor mExecutor;\n        private final Context mContext;\n\n        DevicePolicyManagementRoleObserver(@NonNull Context context) {\n            mContext = context;\n            mExecutor = mContext.getMainExecutor();\n            mRm = mContext.getSystemService(RoleManager.class);\n        }\n\n        public void register() {\n            mRm.addOnRoleHoldersChangedListenerAsUser(mExecutor, this, UserHandle.ALL);\n        }\n\n        @Override\n        public void onRoleHoldersChanged(@NonNull String roleName, @NonNull UserHandle user) {\n            mDevicePolicyEngine.handleRoleChanged(roleName, user.getIdentifier());\n            if (RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT.equals(roleName)) {\n                handleDevicePolicyManagementRoleChange(user);\n                return;\n            }\n            if (RoleManager.ROLE_FINANCED_DEVICE_KIOSK.equals(roleName)) {\n                handleFinancedDeviceKioskRoleChange();\n                return;\n            }\n        }\n\n        private void handleDevicePolicyManagementRoleChange(UserHandle user) {\n            String newRoleHolder = getDeviceManagementRoleHolder(user);\n            if (isDefaultRoleHolder(newRoleHolder)) {\n                Slogf.i(LOG_TAG,\n                        \"onRoleHoldersChanged: Default role holder is set, returning early\");\n                return;\n            }\n            if (newRoleHolder == null) {\n                Slogf.i(LOG_TAG,\n                        \"onRoleHoldersChanged: New role holder is null, returning early\");\n                return;\n            }\n            if (shouldAllowBypassingDevicePolicyManagementRoleQualificationInternal()) {\n                Slogf.w(LOG_TAG,\n                        \"onRoleHoldersChanged: Updating current role holder to \" + newRoleHolder);\n                setBypassDevicePolicyManagementRoleQualificationStateInternal(\n                        newRoleHolder, /* allowBypass= */ true);\n                return;\n            }\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            if (!newRoleHolder.equals(policy.mCurrentRoleHolder)) {\n                Slogf.w(LOG_TAG,\n                        \"onRoleHoldersChanged: You can't set a different role holder, role \"\n                                + \"is getting revoked from \" + newRoleHolder);\n                setBypassDevicePolicyManagementRoleQualificationStateInternal(\n                        /* currentRoleHolder= */ null, /* allowBypass= */ false);\n                mRm.removeRoleHolderAsUser(\n                        RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT,\n                        newRoleHolder,\n                        /* flags= */ 0,\n                        user,\n                        mExecutor,\n                        successful -> {});\n            }\n        }\n\n        private void handleFinancedDeviceKioskRoleChange() {\n            if (!isPolicyEngineForFinanceFlagEnabled()) {\n                return;\n            }\n            Slog.i(LOG_TAG, \"Handling action \" + ACTION_DEVICE_FINANCING_STATE_CHANGED);\n            Intent intent = new Intent(ACTION_DEVICE_FINANCING_STATE_CHANGED);\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                for (UserInfo userInfo : mUserManager.getUsers()) {\n                    UserHandle user = userInfo.getUserHandle();\n                    broadcastExplicitIntentToRoleHolder(\n                            intent, RoleManager.ROLE_SYSTEM_SUPERVISION, user);\n                    broadcastExplicitIntentToRoleHolder(\n                            intent, RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT, user);\n                    ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(user.getIdentifier());\n                    if (admin == null) {\n                        continue;\n                    }\n                    if (!isProfileOwnerOfOrganizationOwnedDevice(\n                            admin.info.getComponent(), user.getIdentifier())\n                            && !isDeviceOwner(admin)\n                            && !(isProfileOwner(admin.info.getComponent(), user.getIdentifier())\n                            && admin.getUserHandle().isSystem())) {\n                        continue;\n                    }\n                    // Don't send the broadcast twice if the DPC is the same package as the\n                    // DMRH\n                    if (admin.info.getPackageName().equals(getDeviceManagementRoleHolder(user))) {\n                        continue;\n                    }\n                    broadcastExplicitIntentToPackage(\n                            intent, admin.info.getPackageName(), admin.getUserHandle());\n                }\n            });\n        }\n\n        private String getDeviceManagementRoleHolder(UserHandle user) {\n            return DevicePolicyManagerService.this.getRoleHolderPackageNameOnUser(\n                    mContext, RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT, user);\n        }\n\n        private boolean isDefaultRoleHolder(String packageName) {\n            String defaultRoleHolder = getDefaultRoleHolderPackageName();\n            if (packageName == null || defaultRoleHolder == null) {\n                return false;\n            }\n            if (!defaultRoleHolder.equals(packageName)) {\n                return false;\n            }\n            return hasSigningCertificate(\n                    packageName, getDefaultRoleHolderPackageSignature());\n        }\n\n        private boolean hasSigningCertificate(String packageName, String  certificateString) {\n            if (packageName == null || certificateString == null) {\n                return false;\n            }\n            byte[] certificate;\n            try {\n                certificate = new Signature(certificateString).toByteArray();\n            } catch (IllegalArgumentException e) {\n                Slogf.w(LOG_TAG, \"Cannot parse signing certificate: \" + certificateString, e);\n                return false;\n            }\n            PackageManager pm = mInjector.getPackageManager();\n            return pm.hasSigningCertificate(\n                    packageName, certificate, PackageManager.CERT_INPUT_SHA256);\n        }\n\n        private String getDefaultRoleHolderPackageName() {\n            String[] info = getDefaultRoleHolderPackageNameAndSignature();\n            if (info == null) {\n                return null;\n            }\n            return info[0];\n        }\n\n        private String getDefaultRoleHolderPackageSignature() {\n            String[] info = getDefaultRoleHolderPackageNameAndSignature();\n            if (info == null || info.length < 2) {\n                return null;\n            }\n            return info[1];\n        }\n\n        private String[] getDefaultRoleHolderPackageNameAndSignature() {\n            String packageNameAndSignature = mContext.getString(\n                    com.android.internal.R.string.config_devicePolicyManagement);\n            if (TextUtils.isEmpty(packageNameAndSignature)) {\n                return null;\n            }\n            if (packageNameAndSignature.contains(\":\")) {\n                return packageNameAndSignature.split(\":\");\n            }\n            return new String[]{packageNameAndSignature};\n        }\n    }\n\n    private void broadcastExplicitIntentToRoleHolder(\n            Intent intent, String role, UserHandle userHandle) {\n        String packageName = getRoleHolderPackageNameOnUser(mContext, role, userHandle);\n        if (packageName == null) {\n            return;\n        }\n        broadcastExplicitIntentToPackage(intent, packageName, userHandle);\n    }\n\n    private void broadcastExplicitIntentToPackage(\n            Intent intent, String packageName, UserHandle userHandle) {\n        int userId = userHandle.getIdentifier();\n        if (packageName == null) {\n            return;\n        }\n        Intent packageIntent = new Intent(intent)\n                .setPackage(packageName);\n        List<ResolveInfo> receivers = mContext.getPackageManager().queryBroadcastReceiversAsUser(\n                packageIntent,\n                PackageManager.ResolveInfoFlags.of(PackageManager.GET_RECEIVERS),\n                userId);\n        if (receivers.isEmpty()) {\n            Slog.i(LOG_TAG, \"Found no receivers to handle intent \" + intent\n                    + \" in package \" + packageName);\n            return;\n        }\n        for (ResolveInfo receiver : receivers) {\n            Intent componentIntent = new Intent(packageIntent)\n                    .setComponent(receiver.getComponentInfo().getComponentName())\n                    .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n            mContext.sendBroadcastAsUser(componentIntent, userHandle);\n        }\n    }\n\n    @Override\n    public List<UserHandle> getPolicyManagedProfiles(@NonNull UserHandle user) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        int userId = user.getIdentifier();\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            List<UserInfo> userProfiles = mUserManager.getProfiles(userId);\n            List<UserHandle> result = new ArrayList<>();\n            for (int i = 0; i < userProfiles.size(); i++) {\n                UserInfo userInfo = userProfiles.get(i);\n                if (userInfo.isManagedProfile() && hasProfileOwner(userInfo.id)) {\n                    result.add(new UserHandle(userInfo.id));\n                }\n            }\n            return result;\n        });\n    }\n\n    // Permission that will need to be created in V.\n    private static final String MANAGE_DEVICE_POLICY_BLOCK_UNINSTALL =\n            \"manage_device_policy_block_uninstall\";\n    private static final String MANAGE_DEVICE_POLICY_CAMERA_TOGGLE =\n            \"manage_device_policy_camera_toggle\";\n    private static final String MANAGE_DEVICE_POLICY_MICROPHONE_TOGGLE =\n            \"manage_device_policy_microphone_toggle\";\n\n    // DPC types\n    private static final int NOT_A_DPC = -1;\n    private static final int DEFAULT_DEVICE_OWNER = 0;\n    private static final int FINANCED_DEVICE_OWNER = 1;\n    private static final int PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE = 2;\n    private static final int PROFILE_OWNER_ON_USER_0 = 3;\n    private static final int PROFILE_OWNER = 4;\n    private static final int PROFILE_OWNER_ON_USER = 5;\n    private static final int AFFILIATED_PROFILE_OWNER_ON_USER = 6;\n    // DPC types\n    @IntDef(value = {\n            NOT_A_DPC,\n            DEFAULT_DEVICE_OWNER,\n            FINANCED_DEVICE_OWNER,\n            PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE,\n            PROFILE_OWNER_ON_USER_0,\n            PROFILE_OWNER,\n            PROFILE_OWNER_ON_USER,\n            AFFILIATED_PROFILE_OWNER_ON_USER\n    })\n    private @interface DpcType {}\n\n    // Permissions of existing DPC types.\n    private static final List<String> DEFAULT_DEVICE_OWNER_PERMISSIONS = List.of(\n            MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT,\n            MANAGE_DEVICE_POLICY_ACROSS_USERS,\n            MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL,\n            MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL,\n            MANAGE_DEVICE_POLICY_AIRPLANE_MODE,\n            MANAGE_DEVICE_POLICY_APPS_CONTROL,\n            MANAGE_DEVICE_POLICY_APP_RESTRICTIONS,\n            MANAGE_DEVICE_POLICY_AUDIO_OUTPUT,\n            MANAGE_DEVICE_POLICY_AUTOFILL,\n            MANAGE_DEVICE_POLICY_BLUETOOTH,\n            MANAGE_DEVICE_POLICY_CALLS,\n            MANAGE_DEVICE_POLICY_CAMERA,\n            MANAGE_DEVICE_POLICY_CERTIFICATES,\n            MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE,\n            MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES,\n            MANAGE_DEVICE_POLICY_DEFAULT_SMS,\n            MANAGE_DEVICE_POLICY_DISPLAY,\n            MANAGE_DEVICE_POLICY_FACTORY_RESET,\n            MANAGE_DEVICE_POLICY_FUN,\n            MANAGE_DEVICE_POLICY_INPUT_METHODS,\n            MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES,\n            MANAGE_DEVICE_POLICY_KEYGUARD,\n            MANAGE_DEVICE_POLICY_LOCALE,\n            MANAGE_DEVICE_POLICY_LOCATION,\n            MANAGE_DEVICE_POLICY_LOCK,\n            MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n            MANAGE_DEVICE_POLICY_LOCK_TASK,\n            MANAGE_DEVICE_POLICY_MICROPHONE,\n            MANAGE_DEVICE_POLICY_MOBILE_NETWORK,\n            MANAGE_DEVICE_POLICY_MODIFY_USERS,\n            MANAGE_DEVICE_POLICY_MTE,\n            MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION,\n            MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,\n            MANAGE_DEVICE_POLICY_PACKAGE_STATE,\n            MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA,\n            MANAGE_DEVICE_POLICY_PRINTING,\n            MANAGE_DEVICE_POLICY_PROFILES,\n            MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n            MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n            MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS,\n            MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,\n            MANAGE_DEVICE_POLICY_SAFE_BOOT,\n            MANAGE_DEVICE_POLICY_SCREEN_CAPTURE,\n            MANAGE_DEVICE_POLICY_SCREEN_CONTENT,\n            MANAGE_DEVICE_POLICY_SECURITY_LOGGING,\n            MANAGE_DEVICE_POLICY_SMS,\n            MANAGE_DEVICE_POLICY_STATUS_BAR,\n            MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,\n            MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS,\n            MANAGE_DEVICE_POLICY_SYSTEM_UPDATES,\n            MANAGE_DEVICE_POLICY_TIME,\n            MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING,\n            MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER,\n            MANAGE_DEVICE_POLICY_VPN,\n            MANAGE_DEVICE_POLICY_WALLPAPER,\n            MANAGE_DEVICE_POLICY_WIFI,\n            MANAGE_DEVICE_POLICY_WINDOWS,\n            MANAGE_DEVICE_POLICY_WIPE_DATA,\n            SET_TIME,\n            SET_TIME_ZONE\n    );\n    private static final List<String> FINANCED_DEVICE_OWNER_PERMISSIONS = List.of(\n            MANAGE_DEVICE_POLICY_ACROSS_USERS,\n            MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL,\n            MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL,\n            MANAGE_DEVICE_POLICY_APPS_CONTROL,\n            MANAGE_DEVICE_POLICY_CALLS,\n            MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES,\n            MANAGE_DEVICE_POLICY_FACTORY_RESET,\n            MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES,\n            MANAGE_DEVICE_POLICY_KEYGUARD,\n            MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n            MANAGE_DEVICE_POLICY_LOCK_TASK,\n            MANAGE_DEVICE_POLICY_MODIFY_USERS,\n            MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,\n            MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,\n            MANAGE_DEVICE_POLICY_SAFE_BOOT,\n            MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,\n            MANAGE_DEVICE_POLICY_TIME,\n            MANAGE_DEVICE_POLICY_WIPE_DATA\n    );\n\n    /**\n     * All the permissions granted to a profile owner.\n     */\n    private static final List<String> PROFILE_OWNER_PERMISSIONS  =\n            List.of(\n                    MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT,\n                    MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL,\n                    MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                    MANAGE_DEVICE_POLICY_APP_RESTRICTIONS,\n                    MANAGE_DEVICE_POLICY_AUDIO_OUTPUT,\n                    MANAGE_DEVICE_POLICY_AUTOFILL,\n                    MANAGE_DEVICE_POLICY_BLUETOOTH,\n                    MANAGE_DEVICE_POLICY_CALLS,\n                    MANAGE_DEVICE_POLICY_CAMERA,\n                    MANAGE_DEVICE_POLICY_CERTIFICATES,\n                    MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES,\n                    MANAGE_DEVICE_POLICY_DISPLAY,\n                    MANAGE_DEVICE_POLICY_FACTORY_RESET,\n                    MANAGE_DEVICE_POLICY_INPUT_METHODS,\n                    MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES,\n                    MANAGE_DEVICE_POLICY_KEYGUARD,\n                    MANAGE_DEVICE_POLICY_LOCALE,\n                    MANAGE_DEVICE_POLICY_LOCATION,\n                    MANAGE_DEVICE_POLICY_LOCK,\n                    MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                    MANAGE_DEVICE_POLICY_CERTIFICATES,\n                    MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION,\n                    MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,\n                    MANAGE_DEVICE_POLICY_PACKAGE_STATE,\n                    MANAGE_DEVICE_POLICY_PRINTING,\n                    MANAGE_DEVICE_POLICY_PROFILES,\n                    MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                    MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                    MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,\n                    MANAGE_DEVICE_POLICY_SCREEN_CAPTURE,\n                    MANAGE_DEVICE_POLICY_SCREEN_CONTENT,\n                    MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,\n                    MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS,\n                    MANAGE_DEVICE_POLICY_TIME,\n                    MANAGE_DEVICE_POLICY_VPN,\n                    MANAGE_DEVICE_POLICY_WIPE_DATA\n            );\n\n    /**\n     * All the additional permissions granted to an organisation owned profile owner.\n     */\n    private static final List<String>\n            ADDITIONAL_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS =\n            List.of(\n                    MANAGE_DEVICE_POLICY_ACROSS_USERS,\n                    MANAGE_DEVICE_POLICY_AIRPLANE_MODE,\n                    MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                    MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE,\n                    MANAGE_DEVICE_POLICY_DEFAULT_SMS,\n                    MANAGE_DEVICE_POLICY_LOCALE,\n                    MANAGE_DEVICE_POLICY_MICROPHONE,\n                    MANAGE_DEVICE_POLICY_MOBILE_NETWORK,\n                    MANAGE_DEVICE_POLICY_MTE,\n                    MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION,\n                    MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA,\n                    MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS,\n                    MANAGE_DEVICE_POLICY_SAFE_BOOT,\n                    MANAGE_DEVICE_POLICY_SECURITY_LOGGING,\n                    MANAGE_DEVICE_POLICY_SMS,\n                    MANAGE_DEVICE_POLICY_SYSTEM_UPDATES,\n                    MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING,\n                    MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER,\n                    MANAGE_DEVICE_POLICY_WIFI,\n                    SET_TIME,\n                    SET_TIME_ZONE\n            );\n\n    /**\n     * All the additional permissions granted to a Profile Owner on user 0.\n     */\n    private static final List<String> ADDITIONAL_PROFILE_OWNER_ON_USER_0_PERMISSIONS =\n            List.of(\n                    MANAGE_DEVICE_POLICY_AIRPLANE_MODE,\n                    MANAGE_DEVICE_POLICY_DISPLAY,\n                    MANAGE_DEVICE_POLICY_FUN,\n                    MANAGE_DEVICE_POLICY_LOCK_TASK,\n                    MANAGE_DEVICE_POLICY_MOBILE_NETWORK,\n                    MANAGE_DEVICE_POLICY_MODIFY_USERS,\n                    MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA,\n                    MANAGE_DEVICE_POLICY_PRINTING,\n                    MANAGE_DEVICE_POLICY_PROFILES,\n                    MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                    MANAGE_DEVICE_POLICY_SAFE_BOOT,\n                    MANAGE_DEVICE_POLICY_SMS,\n                    MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS,\n                    MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER,\n                    MANAGE_DEVICE_POLICY_WINDOWS,\n                    SET_TIME,\n                    SET_TIME_ZONE\n            );\n\n    /**\n     * All the additional permissions granted to a Profile Owner on an unaffiliated user.\n     */\n    private static final List<String> ADDITIONAL_PROFILE_OWNER_ON_USER_PERMISSIONS =\n            List.of(\n                    MANAGE_DEVICE_POLICY_LOCK_TASK\n            );\n\n    /**\n     * All the additional permissions granted to a Profile Owner on an affiliated user.\n     */\n    private static final List<String> ADDITIONAL_AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS =\n            List.of(\n                    MANAGE_DEVICE_POLICY_STATUS_BAR\n            );\n\n    /**\n     * Combination of {@link PROFILE_OWNER_PERMISSIONS} and\n     * {@link ADDITIONAL_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS}.\n     */\n    private static final List<String> PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS =\n            new ArrayList();\n\n    /**\n     * Combination of {@link PROFILE_OWNER_PERMISSIONS} and\n     * {@link ADDITIONAL_PROFILE_OWNER_ON_USER_0_PERMISSIONS}.\n     */\n    private static final List<String> PROFILE_OWNER_ON_USER_0_PERMISSIONS  =\n            new ArrayList();\n\n    /**\n     * Combination of {@link PROFILE_OWNER_PERMISSIONS} and\n     * {@link ADDITIONAL_AFFILIATED_PROFIL_OWNER_ON_USER_PERMISSIONS}.\n     */\n    private static final List<String> AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS =\n            new ArrayList();\n\n    /**\n     * Combination of {@link PROFILE_OWNER_PERMISSIONS} and\n     * {@link ADDITIONAL_PROFILE_OWNER_ON_USER_PERMISSIONS}.\n     */\n    private static final List<String> PROFILE_OWNER_ON_USER_PERMISSIONS =\n            new ArrayList();\n\n\n    private static final HashMap<Integer, List<String>> DPC_PERMISSIONS = new HashMap<>();\n    {\n        // Organisation owned profile owners have all the permission of a profile owner plus\n        // some extra permissions.\n        PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS.addAll(PROFILE_OWNER_PERMISSIONS);\n        PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS.addAll(\n                ADDITIONAL_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS);\n        // Profile owners on user 0 have all the permission of a profile owner plus\n        // some extra permissions.\n        PROFILE_OWNER_ON_USER_0_PERMISSIONS.addAll(PROFILE_OWNER_PERMISSIONS);\n        PROFILE_OWNER_ON_USER_0_PERMISSIONS.addAll(ADDITIONAL_PROFILE_OWNER_ON_USER_0_PERMISSIONS);\n        // Profile owners on users have all the permission of a profile owner plus\n        // some extra permissions.\n        PROFILE_OWNER_ON_USER_PERMISSIONS.addAll(PROFILE_OWNER_PERMISSIONS);\n        PROFILE_OWNER_ON_USER_PERMISSIONS.addAll(\n                ADDITIONAL_PROFILE_OWNER_ON_USER_PERMISSIONS);\n        // Profile owners on affiliated users have all the permission of a profile owner on a user\n        // plus some extra permissions.\n        AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS.addAll(PROFILE_OWNER_ON_USER_PERMISSIONS);\n        AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS.addAll(\n                ADDITIONAL_AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS);\n\n        DPC_PERMISSIONS.put(DEFAULT_DEVICE_OWNER, DEFAULT_DEVICE_OWNER_PERMISSIONS);\n        DPC_PERMISSIONS.put(FINANCED_DEVICE_OWNER, FINANCED_DEVICE_OWNER_PERMISSIONS);\n        DPC_PERMISSIONS.put(PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE,\n                PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS);\n        DPC_PERMISSIONS.put(PROFILE_OWNER_ON_USER_0, PROFILE_OWNER_ON_USER_0_PERMISSIONS);\n        DPC_PERMISSIONS.put(PROFILE_OWNER, PROFILE_OWNER_PERMISSIONS);\n        DPC_PERMISSIONS.put(PROFILE_OWNER_ON_USER, PROFILE_OWNER_ON_USER_PERMISSIONS);\n        DPC_PERMISSIONS.put(AFFILIATED_PROFILE_OWNER_ON_USER,\n                AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS);\n    }\n    //Map of Permission to Delegate Scope.\n    private static final HashMap<String, String> DELEGATE_SCOPES = new HashMap<>();\n    {\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_APP_RESTRICTIONS, DELEGATION_APP_RESTRICTIONS);\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_BLOCK_UNINSTALL, DELEGATION_BLOCK_UNINSTALL);\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_CERTIFICATES, DELEGATION_CERT_INSTALL);\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_PACKAGE_STATE, DELEGATION_PACKAGE_ACCESS);\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS, DELEGATION_PERMISSION_GRANT);\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_SECURITY_LOGGING, DELEGATION_SECURITY_LOGGING);\n    }\n\n    private static final HashMap<String, String> CROSS_USER_PERMISSIONS =\n            new HashMap<>();\n    {\n        // The permissions are all intrinsically global and therefore have no cross-user permission.\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_FACTORY_RESET, null);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MTE, null);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SECURITY_LOGGING, null);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_STATUS_BAR, null);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SYSTEM_UPDATES, null);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING, null);\n        CROSS_USER_PERMISSIONS.put(SET_TIME, null);\n        CROSS_USER_PERMISSIONS.put(SET_TIME_ZONE, null);\n\n        // The permissions are all critical for securing data within the current user and\n        // therefore are protected with MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL for\n        // cross-user calls.\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_KEYGUARD,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL);\n\n        // These permissions are required for securing device ownership without accessing user data\n        // and therefore are protected with MANAGE_DEVICE_POLICY_ACROSS_USERS for cross-user calls.\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_AIRPLANE_MODE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_BLUETOOTH,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_CALLS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_CAMERA,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_DEFAULT_SMS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_INPUT_METHODS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MICROPHONE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MOBILE_NETWORK,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PACKAGE_STATE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SCREEN_CAPTURE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SMS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SAFE_BOOT,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_TIME,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_WIFI,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_WIPE_DATA,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n\n        // These permissions may grant access to user data and therefore must be protected with\n        // MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL for cross-user calls.\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_APP_RESTRICTIONS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_AUDIO_OUTPUT,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_AUTOFILL,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_BLOCK_UNINSTALL,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_CAMERA_TOGGLE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_DISPLAY,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_FUN,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCALE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCATION,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCK,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCK_TASK,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MODIFY_USERS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MICROPHONE_TOGGLE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PROFILES,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PRINTING,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SCREEN_CONTENT,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_VPN,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_WALLPAPER,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_WINDOWS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user. Only one permission provided in the list needs to be granted to pass this\n     * check.\n     * The given permissions will be checked along with their associated cross-user permissions if\n     * they exists and the target user is different to the calling user.\n     * Returns an {@link EnforcingAdmin} for the caller.\n     *\n     * @param admin the component name of the admin.\n     * @param callerPackageName The package name of the calling application.\n     * @param permissions an array of permission names to be checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private EnforcingAdmin enforcePermissionsAndGetEnforcingAdmin(@Nullable ComponentName admin,\n            String[] permissions, String callerPackageName, int targetUserId) {\n        enforcePermissions(permissions, callerPackageName, targetUserId);\n        return getEnforcingAdminForCaller(admin, callerPackageName);\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user.\n     * The given permission will be checked along with its associated cross-user permission if it\n     * exists and the target user is different to the calling user.\n     * Returns an {@link EnforcingAdmin} for the caller.\n     *\n     * @param admin the component name of the admin.\n     * @param callerPackageName The package name of the calling application.\n     * @param permission The name of the permission being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private EnforcingAdmin enforcePermissionAndGetEnforcingAdmin(@Nullable ComponentName admin,\n            String permission, String callerPackageName, int targetUserId) {\n        enforcePermission(permission, callerPackageName, targetUserId);\n        return getEnforcingAdminForCaller(admin, callerPackageName);\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user.\n     * The given permission will be checked along with its associated cross-user permission if it\n     * exists and the target user is different to the calling user.\n     * Returns an {@link EnforcingAdmin} for the caller.\n     *\n     * @param admin the component name of the admin.\n     * @param callerPackageName The package name  of the calling application.\n     * @param permission The name of the permission being checked.\n     * @param deviceAdminPolicy The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private EnforcingAdmin enforcePermissionAndGetEnforcingAdmin(@Nullable ComponentName admin,\n            String permission, int deviceAdminPolicy, String callerPackageName, int targetUserId) {\n        enforcePermission(permission, deviceAdminPolicy, callerPackageName, targetUserId);\n        return getEnforcingAdminForCaller(admin, callerPackageName);\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user.  Only one permission provided in the list needs to be granted to pass this\n     * check.\n     * The given permissions will be checked along with their associated cross-user permissions if\n     * they exist and the target user is different to the calling user.\n     * Returns an {@link EnforcingAdmin} for the caller.\n     *\n     * @param admin the component name of the admin.\n     * @param callerPackageName The package name of the calling application.\n     * @param permissions The names of the permissions being checked.\n     * @param deviceAdminPolicy The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private EnforcingAdmin enforcePermissionsAndGetEnforcingAdmin(@Nullable ComponentName admin,\n            String[] permissions, int deviceAdminPolicy, String callerPackageName,\n            int targetUserId) {\n        enforcePermissions(permissions, deviceAdminPolicy, callerPackageName, targetUserId);\n        return getEnforcingAdminForCaller(admin, callerPackageName);\n    }\n\n    /**\n     * Checks whether the calling process has been granted permission to query a device policy on\n     * a specific user.\n     * The given permission will be checked along with its associated cross-user permission if it\n     * exists and the target user is different to the calling user.\n     *\n     * @param permission The name of the permission being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private EnforcingAdmin enforceCanQueryAndGetEnforcingAdmin(@Nullable ComponentName admin,\n            String permission, String callerPackageName, int targetUserId) {\n        enforceCanQuery(permission, callerPackageName, targetUserId);\n        return getEnforcingAdminForCaller(admin, callerPackageName);\n    }\n\n    private static final HashMap<String, String> POLICY_IDENTIFIER_TO_PERMISSION = new HashMap<>();\n    {\n        POLICY_IDENTIFIER_TO_PERMISSION.put(AUTO_TIMEZONE_POLICY, SET_TIME_ZONE);\n    }\n\n    private static final HashMap<String, Integer> POLICY_IDENTIFIER_TO_ACTIVE_ADMIN_POLICY =\n            new HashMap<>();\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param permission The name of the permission being checked.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private void enforcePermission(String permission, String callerPackageName)\n            throws SecurityException {\n        if (!hasPermission(permission, callerPackageName)) {\n            throw new SecurityException(\"Caller does not have the required permissions for \"\n                    + \"this user. Permission required: \"\n                    + permission\n                    + \".\");\n        }\n    }\n\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user. Only one permission provided in the list needs to be granted to pass this\n     * check.\n     * The given permissions will be checked along with their associated cross-user permissions if\n     * they exists and the target user is different to the calling user.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param permissions The names of the permissions being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private void enforcePermission(String permission, String callerPackageName, int targetUserId)\n            throws SecurityException {\n        enforcePermission(permission, callerPackageName);\n        if (targetUserId != getCallerIdentity(callerPackageName).getUserId()) {\n            enforcePermission(CROSS_USER_PERMISSIONS.get(permission), callerPackageName);\n        }\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user. Only one of the given permissions will be required to be held to pass this\n     * check.\n     * The given permissions will be checked along with their associated cross-user permissions if\n     * they exist and the target user is different to the calling user.\n     *\n     * @param permissions An array of the names of the permissions being checked.\n     * @param callerPackageName The package name  of the calling application.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private void enforcePermissions(String[] permissions, String callerPackageName,\n            int targetUserId) throws SecurityException {\n        String heldPermission = \"\";\n        for (String permission : permissions) {\n            if (hasPermission(permission, callerPackageName)) {\n                heldPermission = permission;\n                break;\n            }\n        }\n        if (heldPermission.isEmpty()) {\n            throw new SecurityException(\"Caller does not have the required permissions for \"\n                    + \"this user. One of the following permission required: \"\n                    + Arrays.toString(permissions));\n        }\n        enforcePermission(heldPermission, callerPackageName, targetUserId);\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user.\n     * The given permission will be checked along with its associated cross-user permission if it\n     * exists and the target user is different to the calling user.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param adminPolicy The admin policy that should grant holders permission.\n     * @param permission The name of the permission being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private void enforcePermission(String permission, int adminPolicy,\n            String callerPackageName, int targetUserId) throws SecurityException {\n        if (hasAdminPolicy(adminPolicy, callerPackageName)) {\n            return;\n        }\n        enforcePermission(permission, callerPackageName, targetUserId);\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user.\n     * The given permission will be checked along with its associated cross-user permission if it\n     * exists and the target user is different to the calling user.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param adminPolicy The admin policy that should grant holders permission.\n     * @param permissions The names of the permissions being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private void enforcePermissions(String[] permissions, int adminPolicy,\n            String callerPackageName, int targetUserId) throws SecurityException {\n        if (hasAdminPolicy(adminPolicy, callerPackageName)\n                && mInjector.userHandleGetCallingUserId() == targetUserId) {\n            return;\n        }\n        enforcePermissions(permissions, callerPackageName, targetUserId);\n    }\n\n    /**\n     * Checks whether the calling process has been granted permission to query a device policy on\n     * a specific user.\n     * The given permission will be checked along with its associated cross-user permission if it\n     * exists and the target user is different to the calling user.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param permission The name of the permission being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user\n     * and if the user has not been granted {@link QUERY_ADMIN_POLICY}.\n     */\n    private void enforceCanQuery(String permission, String callerPackageName, int targetUserId)\n            throws SecurityException {\n        if (hasPermission(QUERY_ADMIN_POLICY, callerPackageName)) {\n            return;\n        }\n        enforcePermission(permission, callerPackageName, targetUserId);\n    }\n\n    private boolean hasAdminPolicy(int adminPolicy, String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        ActiveAdmin deviceAdmin = getActiveAdminWithPolicyForUidLocked(\n                null, adminPolicy, caller.getUid());\n        return deviceAdmin != null;\n    }\n\n    /**\n     * Return whether the calling process has been granted permission to apply a device policy on\n     * a specific user.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param permission The name of the permission being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     */\n    private boolean hasPermission(String permission, String callerPackageName, int targetUserId) {\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        boolean hasPermissionOnOwnUser = hasPermission(permission, caller.getPackageName());\n        boolean hasPermissionOnTargetUser = true;\n        if (hasPermissionOnOwnUser && caller.getUserId() != targetUserId) {\n            hasPermissionOnTargetUser = hasPermissionOnTargetUser\n                    && hasPermission(CROSS_USER_PERMISSIONS.get(permission),\n                        caller.getPackageName());\n        }\n\n        return hasPermissionOnOwnUser && hasPermissionOnTargetUser;\n    }\n\n    /**\n     * Return whether the calling process has been granted the given permission.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param permission The name of the permission being checked.\n     */\n    private boolean hasPermission(String permission, @NonNull String callerPackageName) {\n        Objects.requireNonNull(callerPackageName, \"callerPackageName is null\");\n        if (permission == null) {\n            return true;\n        }\n\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n\n        // Check if the caller holds the permission\n        if (mContext.checkCallingOrSelfPermission(permission) == PERMISSION_GRANTED) {\n            return true;\n        }\n        int dpcType = getDpcType(caller);\n        if (dpcType != NOT_A_DPC) {\n            return DPC_PERMISSIONS.get(dpcType).contains(permission);\n        }\n        // Check the permission for the role-holder\n        if (isCallerDevicePolicyManagementRoleHolder(caller)) {\n            return anyDpcHasPermission(permission, caller.getUserId());\n        }\n        if (DELEGATE_SCOPES.containsKey(permission)) {\n            return isCallerDelegate(caller, DELEGATE_SCOPES.get(permission));\n        }\n        return false;\n    }\n\n    /**\n     * Returns whether there is a DPC on the given user that has been granted the given permission.\n     *\n     * @param permission The name of the permission being checked.\n     * @param userId The id of the user to check.\n     */\n    private boolean anyDpcHasPermission(String permission, int userId) {\n        if (mOwners.isDefaultDeviceOwnerUserId(userId)) {\n            return DPC_PERMISSIONS.get(DEFAULT_DEVICE_OWNER).contains(permission);\n        }\n        if (mOwners.isFinancedDeviceOwnerUserId(userId)) {\n            return DPC_PERMISSIONS.get(FINANCED_DEVICE_OWNER).contains(permission);\n        }\n        if (mOwners.isProfileOwnerOfOrganizationOwnedDevice(userId)) {\n            return DPC_PERMISSIONS.get(PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE).contains(\n                    permission);\n        }\n        if (userId == 0 && mOwners.hasProfileOwner(0)) {\n            return DPC_PERMISSIONS.get(PROFILE_OWNER_ON_USER_0).contains(permission);\n        }\n        if (mOwners.hasProfileOwner(userId)) {\n            return DPC_PERMISSIONS.get(PROFILE_OWNER).contains(permission);\n        }\n        return false;\n    }\n\n    private EnforcingAdmin getEnforcingAdminForCaller(@Nullable ComponentName who,\n            String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        int userId = caller.getUserId();\n        ActiveAdmin admin;\n        if (isDeviceOwner(caller) || isProfileOwner(caller) || isCallerDelegate(caller)) {\n            ComponentName component;\n            synchronized (getLockObject()) {\n                if (who != null) {\n                    admin = getActiveAdminUncheckedLocked(who, userId);\n                    component = who;\n                } else {\n                    admin = getDeviceOrProfileOwnerAdminLocked(userId);\n                    component = admin.info.getComponent();\n                }\n            }\n            return EnforcingAdmin.createEnterpriseEnforcingAdmin(component, userId, admin);\n        }\n        // Check for non-DPC active admins.\n        admin = getActiveAdminForCaller(who, caller);\n        if (admin != null) {\n            return EnforcingAdmin.createDeviceAdminEnforcingAdmin(admin.info.getComponent(), userId,\n                    admin);\n        }\n        admin = getUserData(userId).createOrGetPermissionBasedAdmin(userId);\n        return  EnforcingAdmin.createEnforcingAdmin(caller.getPackageName(), userId, admin);\n    }\n\n    private EnforcingAdmin getEnforcingAdminForPackage(@Nullable ComponentName who,\n            String packageName, int userId) {\n        ActiveAdmin admin;\n        if (who != null) {\n            if (isDeviceOwner(who, userId) || isProfileOwner(who, userId)) {\n                synchronized (getLockObject()) {\n                    admin = getActiveAdminUncheckedLocked(who, userId);\n                }\n                if (admin != null) {\n                    return EnforcingAdmin.createEnterpriseEnforcingAdmin(who, userId, admin);\n                }\n            } else {\n                // Check for non-DPC active admins.\n                admin = getActiveAdminUncheckedLocked(who, userId);\n                if (admin != null) {\n                    return EnforcingAdmin.createDeviceAdminEnforcingAdmin(who, userId, admin);\n                }\n            }\n        }\n\n        admin = getUserData(userId).createOrGetPermissionBasedAdmin(userId);\n        return  EnforcingAdmin.createEnforcingAdmin(packageName, userId, admin);\n    }\n\n    private int getAffectedUser(boolean calledOnParent) {\n        int callingUserId = mInjector.userHandleGetCallingUserId();\n        return calledOnParent ? getProfileParentId(callingUserId) : callingUserId;\n    }\n\n    /**\n     * Return the DPC type of the given caller.\n     */\n    private @DpcType int getDpcType(CallerIdentity caller) {\n        // Check the permissions of DPCs\n        if (isDefaultDeviceOwner(caller)) {\n            return DEFAULT_DEVICE_OWNER;\n        }\n        if (isFinancedDeviceOwner(caller)) {\n            return FINANCED_DEVICE_OWNER;\n        }\n        if (isProfileOwner(caller)) {\n            if (isProfileOwnerOfOrganizationOwnedDevice(caller)) {\n                return PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE;\n            }\n            if (isManagedProfile(caller.getUserId())) {\n                return PROFILE_OWNER;\n            }\n            if (isProfileOwnerOnUser0(caller)) {\n                return PROFILE_OWNER_ON_USER_0;\n            }\n            if (isUserAffiliatedWithDevice(caller.getUserId())) {\n                return AFFILIATED_PROFILE_OWNER_ON_USER;\n            }\n            return PROFILE_OWNER_ON_USER;\n        }\n        return NOT_A_DPC;\n    }\n\n    private boolean isPermissionCheckFlagEnabled() {\n        return DeviceConfig.getBoolean(\n                NAMESPACE_DEVICE_POLICY_MANAGER,\n                PERMISSION_BASED_ACCESS_EXPERIMENT_FLAG,\n                DEFAULT_VALUE_PERMISSION_BASED_ACCESS_FLAG);\n    }\n\n    static boolean isPolicyEngineForFinanceFlagEnabled() {\n        return DeviceConfig.getBoolean(\n                NAMESPACE_DEVICE_POLICY_MANAGER,\n                ENABLE_DEVICE_POLICY_ENGINE_FOR_FINANCE_FLAG,\n                DEFAULT_ENABLE_DEVICE_POLICY_ENGINE_FOR_FINANCE_FLAG);\n    }\n\n    private static boolean isKeepProfilesRunningFlagEnabled() {\n        return DeviceConfig.getBoolean(\n                NAMESPACE_DEVICE_POLICY_MANAGER,\n                KEEP_PROFILES_RUNNING_FLAG,\n                DEFAULT_KEEP_PROFILES_RUNNING_FLAG);\n    }\n\n    private boolean isUnicornFlagEnabled() {\n        return false;\n    }\n\n    private void setKeepProfileRunningEnabledUnchecked(boolean keepProfileRunning) {\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserDataUnchecked(UserHandle.USER_SYSTEM);\n            if (policyData.mEffectiveKeepProfilesRunning == keepProfileRunning) {\n                return;\n            }\n            policyData.mEffectiveKeepProfilesRunning = keepProfileRunning;\n            saveSettingsLocked(UserHandle.USER_SYSTEM);\n        }\n        suspendAppsForQuietProfiles(keepProfileRunning);\n    }\n\n    @Override\n    public void setOverrideKeepProfilesRunning(boolean enabled) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        setKeepProfileRunningEnabledUnchecked(enabled);\n        Slog.i(LOG_TAG, \"Keep profiles running overridden to: \" + enabled);\n    }\n\n    public void setMtePolicy(int flags, String callerPackageName) {\n        final Set<Integer> allowedModes =\n                Set.of(\n                        DevicePolicyManager.MTE_NOT_CONTROLLED_BY_POLICY,\n                        DevicePolicyManager.MTE_DISABLED,\n                        DevicePolicyManager.MTE_ENABLED);\n        Preconditions.checkArgument(\n                allowedModes.contains(flags), \"Provided mode is not one of the allowed values.\");\n        // In general, this API should be available when \"bootctl_settings_toggle\" is set, which\n        // signals that there is a control for MTE in the user settings and this API fundamentally\n        // is a way for the device admin to override that setting.\n        // Allow bootctl_device_policy_manager as an override, e.g. to offer the\n        // DevicePolicyManager only without a visible user setting.\n        if (!mInjector.systemPropertiesGetBoolean(\n                \"ro.arm64.memtag.bootctl_device_policy_manager\",\n                mInjector.systemPropertiesGetBoolean(\n                        \"ro.arm64.memtag.bootctl_settings_toggle\", false))) {\n            throw new UnsupportedOperationException(\"device does not support MTE\");\n        }\n        final CallerIdentity caller = getCallerIdentity(callerPackageName);\n        // For now we continue to restrict the DISABLED setting to device owner - we might need\n        // another permission for this in future.\n        if (flags == DevicePolicyManager.MTE_DISABLED) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        }\n\n        if (isPermissionCheckFlagEnabled()) {\n            enforcePermission(MANAGE_DEVICE_POLICY_MTE, caller.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n        synchronized (getLockObject()) {\n            // TODO(b/261999445): Remove\n            ActiveAdmin admin;\n            if (isHeadlessFlagEnabled()) {\n                admin =\n                        getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n            } else {\n                admin =\n                        getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked(\n                                UserHandle.USER_SYSTEM);\n            }\n\n            if (admin != null) {\n                final String memtagProperty = \"arm64.memtag.bootctl\";\n                if (flags == DevicePolicyManager.MTE_ENABLED) {\n                    mInjector.systemPropertiesSet(memtagProperty, \"memtag\");\n                } else if (flags == DevicePolicyManager.MTE_DISABLED) {\n                    mInjector.systemPropertiesSet(memtagProperty, \"memtag-off\");\n                }\n                admin.mtePolicy = flags;\n                saveSettingsLocked(caller.getUserId());\n\n                DevicePolicyEventLogger.createEvent(DevicePolicyEnums.SET_MTE_POLICY)\n                        .setInt(flags)\n                        .setAdmin(caller.getPackageName())\n                        .write();\n            }\n        }\n    }\n\n    @Override\n    public int getMtePolicy(String callerPackageName) {\n        final CallerIdentity caller = getCallerIdentity(callerPackageName);\n        if (isPermissionCheckFlagEnabled()) {\n            enforcePermission(MANAGE_DEVICE_POLICY_MTE, caller.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller)\n                            || isSystemUid(caller));\n        }\n        synchronized (getLockObject()) {\n            // TODO(b/261999445): Remove\n            ActiveAdmin admin;\n            if (isHeadlessFlagEnabled()) {\n                admin =\n                        getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n            } else {\n                admin =\n                        getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked(\n                                UserHandle.USER_SYSTEM);\n            }\n            return admin != null\n                    ? admin.mtePolicy\n                    : DevicePolicyManager.MTE_NOT_CONTROLLED_BY_POLICY;\n        }\n    }\n\n    private boolean isHeadlessFlagEnabled() {\n        return DeviceConfig.getBoolean(\n                NAMESPACE_DEVICE_POLICY_MANAGER,\n                HEADLESS_FLAG,\n                DEFAULT_HEADLESS_FLAG);\n    }\n\n    @Override\n    public ManagedSubscriptionsPolicy getManagedSubscriptionsPolicy() {\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOfOrganizationOwnedDeviceLocked();\n            if (admin != null && admin.mManagedSubscriptionsPolicy != null) {\n                return admin.mManagedSubscriptionsPolicy;\n            }\n        }\n        return new ManagedSubscriptionsPolicy(\n                ManagedSubscriptionsPolicy.TYPE_ALL_PERSONAL_SUBSCRIPTIONS);\n    }\n\n    @Override\n    public void setManagedSubscriptionsPolicy(ManagedSubscriptionsPolicy policy) {\n        CallerIdentity caller = getCallerIdentity();\n\n        if (!isCallerDevicePolicyManagementRoleHolder(caller)\n                && !Objects.equals(mInjector.settingsGlobalGetString(\n                        Global.ALLOW_WORK_PROFILE_TELEPHONY_FOR_NON_DPM_ROLE_HOLDERS), \"1\")) {\n            throw new UnsupportedOperationException(\"This api is not enabled\");\n        }\n\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller),\n                \"This policy can only be set by a profile owner on an organization-owned \"\n                        + \"device.\");\n\n        int parentUserId = getProfileParentId(caller.getUserId());\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (hasUserSetupCompleted(parentUserId) && !isAdminTestOnlyLocked(\n                    admin.info.getComponent(), caller.getUserId())) {\n                throw new IllegalStateException(\"Not allowed to apply this policy after setup\");\n            }\n            boolean changed = false;\n            if (!Objects.equals(policy, admin.mManagedSubscriptionsPolicy)) {\n                admin.mManagedSubscriptionsPolicy = policy;\n                changed = true;\n            }\n            if (changed) {\n                saveSettingsLocked(caller.getUserId());\n            } else {\n                return;\n            }\n        }\n\n        applyManagedSubscriptionsPolicyIfRequired();\n\n        int policyType = getManagedSubscriptionsPolicy().getPolicyType();\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            if (policyType == ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {\n                installOemDefaultDialerAndSmsApp(caller.getUserId());\n                updateTelephonyCrossProfileIntentFilters(parentUserId, caller.getUserId(), true);\n            } else if (policyType == ManagedSubscriptionsPolicy.TYPE_ALL_PERSONAL_SUBSCRIPTIONS) {\n                updateTelephonyCrossProfileIntentFilters(parentUserId, caller.getUserId(), false);\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    private void installOemDefaultDialerAndSmsApp(int targetUserId) {\n        try {\n            String defaultDialerPackageName = getOemDefaultDialerPackage();\n            String defaultSmsPackageName = getOemDefaultSmsPackage();\n\n            if (defaultDialerPackageName != null) {\n                mIPackageManager.installExistingPackageAsUser(defaultDialerPackageName,\n                        targetUserId, PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                        PackageManager.INSTALL_REASON_POLICY, null);\n            } else {\n                Slogf.w(LOG_TAG, \"Couldn't install dialer app, dialer app package is null\");\n            }\n\n            if (defaultSmsPackageName != null) {\n                mIPackageManager.installExistingPackageAsUser(defaultSmsPackageName, targetUserId,\n                        PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                        PackageManager.INSTALL_REASON_POLICY, null);\n            } else {\n                Slogf.w(LOG_TAG, \"Couldn't install sms app, sms app package is null\");\n            }\n\n            updateDialerAndSmsManagedShortcutsOverrideCache();\n        } catch (RemoteException re) {\n            // shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Failed to install dialer/sms app\", re);\n        }\n    }\n\n    private String getOemDefaultDialerPackage() {\n        TelecomManager telecomManager = mContext.getSystemService(TelecomManager.class);\n        return telecomManager.getSystemDialerPackage();\n    }\n\n    private String getOemDefaultSmsPackage() {\n        return mContext.getString(R.string.config_defaultSms);\n    }\n\n    private void updateDialerAndSmsManagedShortcutsOverrideCache() {\n        ArrayMap<String, String> shortcutOverrides = new ArrayMap<>();\n        int managedUserId = getManagedUserId();\n        List<String> dialerRoleHolders = mRoleManager.getRoleHoldersAsUser(RoleManager.ROLE_DIALER,\n                UserHandle.of(managedUserId));\n        List<String> smsRoleHolders = mRoleManager.getRoleHoldersAsUser(RoleManager.ROLE_SMS,\n                UserHandle.of(managedUserId));\n\n        String dialerPackageToOverride = getOemDefaultDialerPackage();\n        String smsPackageToOverride = getOemDefaultSmsPackage();\n\n        // To get the default app, we can get all the role holders and get the first element.\n        if (dialerPackageToOverride != null) {\n            shortcutOverrides.put(dialerPackageToOverride,\n                    dialerRoleHolders.isEmpty() ? dialerPackageToOverride\n                            : dialerRoleHolders.get(0));\n        }\n        if (smsPackageToOverride != null) {\n            shortcutOverrides.put(smsPackageToOverride,\n                    smsRoleHolders.isEmpty() ? smsPackageToOverride : smsRoleHolders.get(0));\n        }\n\n        mPolicyCache.setLauncherShortcutOverrides(shortcutOverrides);\n    }\n\n    private void registerListenerToAssignSubscriptionsToUser(int userId) {\n        synchronized (mSubscriptionsChangedListenerLock) {\n            if (mSubscriptionsChangedListener != null) {\n                return;\n            }\n            SubscriptionManager subscriptionManager = mContext.getSystemService(\n                    SubscriptionManager.class);\n            // Listener to assign all current and future subs to managed profile.\n            mSubscriptionsChangedListener = new SubscriptionManager.OnSubscriptionsChangedListener(\n                    mHandler.getLooper()) {\n                @Override\n                public void onSubscriptionsChanged() {\n                    final long id = mInjector.binderClearCallingIdentity();\n                    try {\n                        int[] subscriptionIds = subscriptionManager.getActiveSubscriptionIdList(\n                                false);\n                        for (int subId : subscriptionIds) {\n                            UserHandle associatedUserHandle =\n                                    subscriptionManager.getSubscriptionUserHandle(subId);\n                            if (associatedUserHandle == null\n                                    || associatedUserHandle.getIdentifier() != userId) {\n                                subscriptionManager.setSubscriptionUserHandle(subId,\n                                        UserHandle.of(userId));\n                            }\n                        }\n                    } finally {\n                        mInjector.binderRestoreCallingIdentity(id);\n                    }\n                }\n            };\n\n            final long id = mInjector.binderClearCallingIdentity();\n            try {\n                // When listener is added onSubscriptionsChanged gets called immediately for once\n                // (even if subscriptions are not changed) and later on when subscriptions changes.\n                subscriptionManager.addOnSubscriptionsChangedListener(\n                        mSubscriptionsChangedListener.getHandlerExecutor(),\n                        mSubscriptionsChangedListener);\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n    }\n\n    private void unregisterOnSubscriptionsChangedListener() {\n        synchronized (mSubscriptionsChangedListenerLock) {\n            if (mSubscriptionsChangedListener != null) {\n                SubscriptionManager subscriptionManager = mContext.getSystemService(\n                        SubscriptionManager.class);\n                subscriptionManager.removeOnSubscriptionsChangedListener(\n                        mSubscriptionsChangedListener);\n                mSubscriptionsChangedListener = null;\n            }\n        }\n    }\n\n    @Override\n    public DevicePolicyState getDevicePolicyState() {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        return mInjector.binderWithCleanCallingIdentity(mDevicePolicyEngine::getDevicePolicyState);\n    }\n\n    @Override\n    public boolean triggerDevicePolicyEngineMigration(boolean forceMigration) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            synchronized (getLockObject()) {\n                boolean canForceMigration = forceMigration && !hasNonTestOnlyActiveAdmins();\n                if (!canForceMigration && !shouldMigrateToDevicePolicyEngine()) {\n                    return false;\n                }\n                boolean migrated = migratePoliciesToDevicePolicyEngine();\n                migrated &= migratePoliciesPostUpgradeToDevicePolicyEngineLocked();\n                return migrated;\n            }\n        });\n    }\n\n    private boolean hasNonTestOnlyActiveAdmins() {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo userInfo : mUserManager.getUsers()) {\n                synchronized (getLockObject()) {\n                    List<ComponentName> activeAdmins = getActiveAdmins(userInfo.id);\n                    if (activeAdmins == null) {\n                        continue;\n                    }\n                    for (ComponentName admin : activeAdmins) {\n                        if (!isAdminTestOnlyLocked(admin, userInfo.id)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        });\n    }\n\n    private boolean shouldMigrateToDevicePolicyEngine() {\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                (isPermissionCheckFlagEnabled() || isPolicyEngineForFinanceFlagEnabled())\n                        && !mOwners.isMigratedToPolicyEngine());\n    }\n\n    /**\n     * [b/318497672] Migrate policies that weren't migrated properly in the initial migration on\n     * update from Android T to Android U\n     */\n    private void maybeMigratePoliciesPostUpgradeToDevicePolicyEngineLocked() {\n        if (!mOwners.isMigratedToPolicyEngine() || mOwners.isMigratedPostUpdate()) {\n            return;\n        }\n        migratePoliciesPostUpgradeToDevicePolicyEngineLocked();\n        mOwners.markPostUpgradeMigration();\n    }\n\n    private boolean migratePoliciesPostUpgradeToDevicePolicyEngineLocked() {\n        try {\n            migrateScreenCapturePolicyLocked();\n            migrateLockTaskPolicyLocked();\n            migrateUserRestrictionsLocked();\n            return true;\n        } catch (Exception e) {\n            Slogf.e(LOG_TAG, e, \"Error occurred during post upgrade migration to the device \"\n                    + \"policy engine.\");\n            return false;\n        }\n    }\n\n    /**\n     * @return {@code true} if policies were migrated successfully, {@code false} otherwise.\n     */\n    private boolean migratePoliciesToDevicePolicyEngine() {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                synchronized (getLockObject()) {\n                    Slogf.i(LOG_TAG,\n                            \"Started device policies migration to the device policy engine.\");\n                    if (isUnicornFlagEnabled()) {\n                        migrateAutoTimezonePolicy();\n                        migratePermissionGrantStatePolicies();\n                    }\n                    migratePermittedInputMethodsPolicyLocked();\n                    migrateAccountManagementDisabledPolicyLocked();\n                    migrateUserControlDisabledPackagesLocked();\n\n                    mOwners.markMigrationToPolicyEngine();\n                    return true;\n                }\n            } catch (Exception e) {\n                mDevicePolicyEngine.clearAllPolicies();\n                Slogf.e(LOG_TAG, e, \"Error occurred during device policy migration, will \"\n                        + \"reattempt on the next system server restart.\");\n                return false;\n            }\n        });\n    }\n\n    private void migrateAutoTimezonePolicy() {\n        Slogf.i(LOG_TAG, \"Skipping Migration of AUTO_TIMEZONE policy to device policy engine,\"\n                + \"as no way to identify if the value was set by the admin or the user.\");\n    }\n\n    private void migratePermissionGrantStatePolicies() {\n        Slogf.i(LOG_TAG, \"Migrating PERMISSION_GRANT policy to device policy engine.\");\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            ActiveAdmin admin = getMostProbableDPCAdminForLocalPolicy(userInfo.id);\n            if (admin == null) {\n                Slogf.i(LOG_TAG, \"No admin found that can set permission grant state on user \"\n                        + userInfo.id);\n                continue;\n            }\n            for (PackageInfo packageInfo : getInstalledPackagesOnUser(userInfo.id)) {\n                if (packageInfo.requestedPermissions == null) {\n                    continue;\n                }\n                for (String permission : packageInfo.requestedPermissions) {\n                    if (!isRuntimePermission(permission)) {\n                        continue;\n                    }\n                    int grantState = DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;\n                    try {\n                        grantState = getPermissionGrantStateForUser(\n                                packageInfo.packageName, permission,\n                                new CallerIdentity(\n                                        mInjector.binderGetCallingUid(),\n                                        admin.info.getComponent().getPackageName(),\n                                        admin.info.getComponent()),\n                                userInfo.id);\n                    } catch (RemoteException e) {\n                        Slogf.e(LOG_TAG, e, \"Error retrieving permission grant state for %s \"\n                                        + \"and %s\", packageInfo.packageName, permission);\n                    }\n                    if (grantState == DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT) {\n                        // Not Controlled by a policy\n                        continue;\n                    }\n\n                    mDevicePolicyEngine.setLocalPolicy(\n                            PolicyDefinition.PERMISSION_GRANT(packageInfo.packageName,\n                                    permission),\n                            EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                                    admin.info.getComponent(),\n                                    admin.getUserHandle().getIdentifier()),\n                            new IntegerPolicyValue(grantState),\n                            userInfo.id,\n                            /* skipEnforcePolicy= */ true);\n                }\n            }\n        }\n    }\n\n    private void migrateScreenCapturePolicyLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            ActiveAdmin admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n            if (admin != null\n                    && ((isDeviceOwner(admin) && admin.disableScreenCapture)\n                    || (admin.getParentActiveAdmin() != null\n                    && admin.getParentActiveAdmin().disableScreenCapture))) {\n\n                EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                        admin.info.getComponent(),\n                        admin.getUserHandle().getIdentifier(),\n                        admin);\n                mDevicePolicyEngine.setGlobalPolicy(\n                        PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                        enforcingAdmin,\n                        new BooleanPolicyValue(true));\n            }\n\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                ActiveAdmin profileOwner = getProfileOwnerLocked(userInfo.id);\n                if (profileOwner != null && profileOwner.disableScreenCapture) {\n                    EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            profileOwner.info.getComponent(),\n                            profileOwner.getUserHandle().getIdentifier(),\n                            profileOwner);\n                    mDevicePolicyEngine.setLocalPolicy(\n                            PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                            enforcingAdmin,\n                            new BooleanPolicyValue(true),\n                            profileOwner.getUserHandle().getIdentifier());\n                }\n            }\n        });\n    }\n\n    private void migrateLockTaskPolicyLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (deviceOwner != null) {\n                int doUserId = deviceOwner.getUserHandle().getIdentifier();\n                DevicePolicyData policies = getUserData(doUserId);\n                List<String> packages = policies.mLockTaskPackages;\n                int features = policies.mLockTaskFeatures;\n                // TODO: find out about persistent preferred activities\n                if (!packages.isEmpty()) {\n                    setLockTaskPolicyInPolicyEngine(deviceOwner, doUserId, packages, features);\n                }\n            }\n\n            for (int userId : mUserManagerInternal.getUserIds()) {\n                ActiveAdmin profileOwner = getProfileOwnerLocked(userId);\n                if (profileOwner != null && canDPCManagedUserUseLockTaskLocked(userId)) {\n                    DevicePolicyData policies = getUserData(userId);\n                    List<String> packages = policies.mLockTaskPackages;\n                    int features = policies.mLockTaskFeatures;\n                    if (!packages.isEmpty()) {\n                        setLockTaskPolicyInPolicyEngine(profileOwner, userId, packages, features);\n                    }\n                }\n            }\n        });\n    }\n\n    private void setLockTaskPolicyInPolicyEngine(\n            ActiveAdmin admin, int userId, List<String> packages, int features) {\n        EnforcingAdmin enforcingAdmin =\n                EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                        admin.info.getComponent(),\n                        userId,\n                        admin);\n        mDevicePolicyEngine.setLocalPolicy(\n                PolicyDefinition.LOCK_TASK,\n                enforcingAdmin,\n                new LockTaskPolicy(new HashSet<>(packages), features),\n                userId);\n    }\n\n    private void migratePermittedInputMethodsPolicyLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(userInfo.id);\n                if (admin != null) {\n                    EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(),\n                            admin.getUserHandle().getIdentifier(),\n                            admin);\n                    if (admin.permittedInputMethods != null) {\n                        mDevicePolicyEngine.setLocalPolicy(\n                                PolicyDefinition.PERMITTED_INPUT_METHODS,\n                                enforcingAdmin,\n                                new StringSetPolicyValue(\n                                        new HashSet<>(admin.permittedInputMethods)),\n                                admin.getUserHandle().getIdentifier());\n                    }\n                    if (admin.getParentActiveAdmin() != null\n                            && admin.getParentActiveAdmin().permittedInputMethods != null) {\n                        mDevicePolicyEngine.setLocalPolicy(\n                                PolicyDefinition.PERMITTED_INPUT_METHODS,\n                                enforcingAdmin,\n                                new StringSetPolicyValue(\n                                        new HashSet<>(admin.getParentActiveAdmin()\n                                                .permittedInputMethods)),\n                                getProfileParentId(admin.getUserHandle().getIdentifier()));\n                    }\n                }\n            }\n        });\n    }\n\n    private void migrateAccountManagementDisabledPolicyLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(userInfo.id);\n                if (admin != null) {\n                    EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(),\n                            admin.getUserHandle().getIdentifier(),\n                            admin);\n                    for (String accountType : admin.accountTypesWithManagementDisabled) {\n                        mDevicePolicyEngine.setLocalPolicy(\n                                PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(accountType),\n                                enforcingAdmin,\n                                new BooleanPolicyValue(true),\n                                admin.getUserHandle().getIdentifier());\n                    }\n                    if (admin.getParentActiveAdmin() != null) {\n                        for (String accountType : admin.getParentActiveAdmin()\n                                .accountTypesWithManagementDisabled) {\n                            mDevicePolicyEngine.setLocalPolicy(\n                                    PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(accountType),\n                                    enforcingAdmin,\n                                    new BooleanPolicyValue(true),\n                                    getProfileParentId(admin.getUserHandle().getIdentifier()));\n                        }\n                    }\n                }\n            }\n        });\n    }\n    \n    private void migrateUserControlDisabledPackagesLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(userInfo.id);\n                if (admin != null && admin.protectedPackages != null) {\n                    EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(),\n                            admin.getUserHandle().getIdentifier(),\n                            admin);\n                    if (isDeviceOwner(admin)) {\n                        mDevicePolicyEngine.setGlobalPolicy(\n                                PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                                enforcingAdmin,\n                                new StringSetPolicyValue(new HashSet<>(admin.protectedPackages)));\n                    } else {\n                        mDevicePolicyEngine.setLocalPolicy(\n                                PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                                enforcingAdmin,\n                                new StringSetPolicyValue(new HashSet<>(admin.protectedPackages)),\n                                admin.getUserHandle().getIdentifier());\n                    }\n                }\n            }\n        });\n    }\n\n    private void migrateUserRestrictionsLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(userInfo.id);\n                if (admin == null) continue;\n                ComponentName adminComponent = admin.info.getComponent();\n                int userId = userInfo.id;\n                EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                        adminComponent,\n                        userId,\n                        admin);\n                int ownerType;\n                if (isDeviceOwner(admin)) {\n                    ownerType = OWNER_TYPE_DEVICE_OWNER;\n                } else if (isProfileOwnerOfOrganizationOwnedDevice(adminComponent, userId)) {\n                    ownerType = OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE;\n                } else if (isProfileOwner(adminComponent, userId)) {\n                    ownerType = OWNER_TYPE_PROFILE_OWNER;\n                } else {\n                    throw new IllegalStateException(\"Invalid DO/PO state\");\n                }\n\n                for (final String restriction : admin.ensureUserRestrictions().keySet()) {\n                    setBackwardCompatibleUserRestrictionLocked(ownerType, enforcingAdmin, userId,\n                            restriction, /* enabled */ true, /* parent */ false);\n                }\n                for (final String restriction : admin.getParentActiveAdmin()\n                        .ensureUserRestrictions().keySet()) {\n                    setBackwardCompatibleUserRestrictionLocked(ownerType, enforcingAdmin, userId,\n                            restriction, /* enabled */ true, /* parent */ true);\n                }\n            }\n        });\n    }\n\n    private List<PackageInfo> getInstalledPackagesOnUser(int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mContext.getPackageManager().getInstalledPackagesAsUser(\n                        PackageManager.PackageInfoFlags.of(\n                                PackageManager.GET_PERMISSIONS), userId));\n    }\n\n    /**\n     * Returns the most probable admin to have set a global policy according to the following\n     * heuristics:\n     *\n     * <ul>\n     * <li>The device owner on any user</li>\n     * <li>The org owned profile owner on any user</li>\n     * <li>The profile owner on any user</li>\n     * </ul>\n     */\n    @Nullable\n    // TODO(b/266928216): Check what the admin capabilities are when deciding which admin to return.\n    private ActiveAdmin getMostProbableDPCAdminForGlobalPolicy() {\n        synchronized (getLockObject()) {\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (deviceOwner != null) {\n                return deviceOwner;\n            }\n\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                if (isProfileOwnerOfOrganizationOwnedDevice(userInfo.id)) {\n                    return getProfileOwnerAdminLocked(userInfo.id);\n                }\n            }\n\n            for (UserInfo userInfo : users) {\n                ActiveAdmin profileOwner = getProfileOwnerLocked(userInfo.id);\n                if (profileOwner != null) {\n                    return profileOwner;\n                }\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Returns the most probable admin to have set a policy on the given {@code userId} according\n     * to the following heuristics:\n     *\n     * <ul>\n     * <li>The device owner on the given userId</li>\n     * <li>The profile owner on the given userId</li>\n     * <li>The org owned profile owner of which the given userId is its parent</li>\n     * <li>The profile owner of which the given userId is its parent</li>\n     * <li>The device owner on any user</li>\n     * <li>The profile owner on any user</li>\n     * </ul>\n     */\n    @Nullable\n    // TODO(b/266928216): Check what the admin capabilities are when deciding which admin to return.\n    private ActiveAdmin getMostProbableDPCAdminForLocalPolicy(int userId) {\n        synchronized (getLockObject()) {\n            ActiveAdmin localDeviceOwner = getDeviceOwnerLocked(userId);\n            if (localDeviceOwner != null) {\n                return localDeviceOwner;\n            }\n\n            ActiveAdmin localProfileOwner = getProfileOwnerLocked(userId);\n            if (localProfileOwner != null) {\n                return localProfileOwner;\n            }\n\n            int[] profileIds = mUserManager.getProfileIds(userId, /* enabledOnly= */ false);\n            for (int id : profileIds) {\n                if (id == userId) {\n                    continue;\n                }\n                if (isProfileOwnerOfOrganizationOwnedDevice(id)) {\n                    return getProfileOwnerAdminLocked(id);\n                }\n            }\n\n            for (int id : profileIds) {\n                if (id == userId) {\n                    continue;\n                }\n                if (isManagedProfile(id)) {\n                    return getProfileOwnerAdminLocked(id);\n                }\n            }\n\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (deviceOwner != null) {\n                return deviceOwner;\n            }\n\n            for (UserInfo userInfo : mUserManager.getUsers()) {\n                ActiveAdmin profileOwner = getProfileOwnerLocked(userInfo.id);\n                if (profileOwner != null) {\n                    return profileOwner;\n                }\n            }\n            return null;\n        }\n    }\n\n    // We need to add a mapping of policyId to permission in POLICY_IDENTIFIER_TO_PERMISSION\n    // for each migrated permission.\n    private List<ActiveAdmin> getNonDPCActiveAdminsForPolicyLocked(String policyIdentifier) {\n        Integer activeAdminPolicy = POLICY_IDENTIFIER_TO_ACTIVE_ADMIN_POLICY.get(policyIdentifier);\n        if (activeAdminPolicy == null) {\n            Slogf.e(LOG_TAG,\n                    \"Can't find a active admin policy for %s in POLICY_IDENTIFIER_TO_PERMISSION\",\n                    policyIdentifier);\n            return new ArrayList<>();\n        }\n\n        List<ActiveAdmin> admins = new ArrayList<>();\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            List<ComponentName> activeAdmins = getActiveAdmins(userInfo.id);\n            for (ComponentName admin : activeAdmins) {\n                if (isDeviceOwner(admin, userInfo.id) || isProfileOwner(admin, userInfo.id)) {\n                    continue;\n                }\n                DevicePolicyData policy = getUserDataUnchecked(userInfo.id);\n                if (isActiveAdminWithPolicyForUserLocked(\n                        policy.mAdminMap.get(admin), activeAdminPolicy,\n                        userInfo.id)) {\n                    admins.add(policy.mAdminMap.get(admin));\n                }\n            }\n        }\n        return admins;\n    }\n\n    // TODO: this can actually accept an EnforcingAdmin that gets created in the permission\n    //  check method.\n    private boolean isCallerActiveAdminOrDelegate(\n            CallerIdentity caller, @Nullable String delegateScope) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            List<ComponentName> activeAdmins = getActiveAdmins(caller.getUserId());\n            if (activeAdmins != null) {\n                for (ComponentName admin : activeAdmins) {\n                    if (admin.getPackageName().equals(caller.getPackageName())) {\n                        return true;\n                    }\n                }\n            }\n            return delegateScope != null && isCallerDelegate(caller, delegateScope);\n        });\n    }\n\n    /**\n     * Truncates char sequence to maximum length, nulls are ignored.\n     */\n    private static CharSequence truncateIfLonger(CharSequence input, int maxLength) {\n        return input == null || input.length() <= maxLength\n                ? input\n                : input.subSequence(0, maxLength);\n    }\n\n    /**\n     * Throw if string argument is too long to be serialized.\n     */\n    private static void enforceMaxStringLength(String str, String argName) {\n        Preconditions.checkArgument(\n                str.length() <= MAX_POLICY_STRING_LENGTH, argName + \" loo long\");\n    }\n\n    private static void enforceMaxPackageNameLength(String pkg) {\n        Preconditions.checkArgument(\n                pkg.length() <= MAX_PACKAGE_NAME_LENGTH, \"Package name too long\");\n    }\n\n    /**\n     * Throw if persistable bundle contains any string that we can't serialize.\n     */\n    private static void enforceMaxStringLength(PersistableBundle bundle, String argName) {\n        // Persistable bundles can have other persistable bundles as values, traverse with a queue.\n        Queue<PersistableBundle> queue = new ArrayDeque<>();\n        queue.add(bundle);\n        while (!queue.isEmpty()) {\n            PersistableBundle current = queue.remove();\n            for (String key : current.keySet()) {\n                enforceMaxStringLength(key, \"key in \" + argName);\n                Object value = current.get(key);\n                if (value instanceof String) {\n                    enforceMaxStringLength((String) value, \"string value in \" + argName);\n                } else if (value instanceof String[]) {\n                    for (String str : (String[]) value) {\n                        enforceMaxStringLength(str, \"string value in \" + argName);\n                    }\n                } else if (value instanceof PersistableBundle) {\n                    queue.add((PersistableBundle) value);\n                }\n            }\n        }\n    }\n\n    private ActiveAdmin getActiveAdminForCaller(@Nullable ComponentName who,\n            CallerIdentity caller) {\n        synchronized (getLockObject()) {\n            if (who != null) {\n                return getActiveAdminUncheckedLocked(who, caller.getUserId());\n            }\n            return mInjector.binderWithCleanCallingIdentity(() -> {\n                List<ComponentName> activeAdmins = getActiveAdmins(caller.getUserId());\n                if (activeAdmins != null) {\n                    for (ComponentName admin : activeAdmins) {\n                        if (admin.getPackageName().equals(caller.getPackageName())) {\n                            return getActiveAdminUncheckedLocked(admin, caller.getUserId());\n                        }\n                    }\n                }\n                return null;\n            });\n        }\n    }\n\n    @Override\n    public boolean isDeviceFinanced(String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        Preconditions.checkCallAuthorization(isDeviceOwner(caller)\n                || isProfileOwnerOfOrganizationOwnedDevice(caller)\n                || isProfileOwnerOnUser0(caller)\n                || isCallerDevicePolicyManagementRoleHolder(caller)\n                || isCallerSystemSupervisionRoleHolder(caller));\n        return getFinancedDeviceKioskRoleHolderOnAnyUser() != null;\n    };\n\n    @Override\n    public String getFinancedDeviceKioskRoleHolder(String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        enforcePermission(MANAGE_PROFILE_AND_DEVICE_OWNERS, caller.getPackageName(),\n                caller.getUserId());\n        return getFinancedDeviceKioskRoleHolderOnAnyUser();\n    }\n\n    private String getFinancedDeviceKioskRoleHolderOnAnyUser() {\n        return getRoleHolderPackageNameOnUser(\n                RoleManager.ROLE_FINANCED_DEVICE_KIOSK, UserHandle.USER_ALL);\n    }\n}\n```",
                        "downstream_file_tokens": {
                            "openai": 208694,
                            "general": {
                                "word_based": 76703,
                                "char_based": 281581
                            },
                            "gemini": 247365
                        },
                        "downstream_file_content_context_3": [
                            "        applyProfileRestrictionsIfDeviceOwnerLocked();\n        setNetworkLoggingActiveInternal(false);\n\n        if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n            mDevicePolicyEngine.removePoliciesForAdmin(\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(), userId, admin));\n        }\n    }\n\n    @Override\n    public void setDeviceOwnerLockScreenInfo(ComponentName who, CharSequence info) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mLockPatternUtils.setDeviceOwnerInfo(info != null ? info.toString() : null));\n"
                        ],
                        "downstream_file_content_context_5": [
                            "        deleteTransferOwnershipBundleLocked(userId);\n        toggleBackupServiceActive(userId, true);\n        applyProfileRestrictionsIfDeviceOwnerLocked();\n        setNetworkLoggingActiveInternal(false);\n\n        if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n            mDevicePolicyEngine.removePoliciesForAdmin(\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(), userId, admin));\n        }\n    }\n\n    @Override\n    public void setDeviceOwnerLockScreenInfo(ComponentName who, CharSequence info) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mLockPatternUtils.setDeviceOwnerInfo(info != null ? info.toString() : null));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_DEVICE_OWNER_LOCK_SCREEN_INFO)"
                        ],
                        "downstream_file_content_context_10": [
                            "        saveSettingsLocked(userId);\n        clearUserPoliciesLocked(userId);\n        clearApplicationRestrictions(userId);\n        mOwners.removeProfileOwner(userId);\n        mOwners.writeProfileOwner(userId);\n        deleteTransferOwnershipBundleLocked(userId);\n        toggleBackupServiceActive(userId, true);\n        applyProfileRestrictionsIfDeviceOwnerLocked();\n        setNetworkLoggingActiveInternal(false);\n\n        if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n            mDevicePolicyEngine.removePoliciesForAdmin(\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(), userId, admin));\n        }\n    }\n\n    @Override\n    public void setDeviceOwnerLockScreenInfo(ComponentName who, CharSequence info) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mLockPatternUtils.setDeviceOwnerInfo(info != null ? info.toString() : null));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_DEVICE_OWNER_LOCK_SCREEN_INFO)\n                .setAdmin(caller.getComponentName())\n                .write();\n    }\n\n    @Override"
                        ],
                        "downstream_file_content_context_20": [
                            "        }\n\n        if (admin != null) {\n            admin.disableCamera = false;\n            admin.userRestrictions = null;\n            admin.defaultEnabledRestrictionsAlreadySet.clear();\n        }\n        final DevicePolicyData policyData = getUserData(userId);\n        policyData.mCurrentInputMethodSet = false;\n        policyData.mOwnerInstalledCaCerts.clear();\n        saveSettingsLocked(userId);\n        clearUserPoliciesLocked(userId);\n        clearApplicationRestrictions(userId);\n        mOwners.removeProfileOwner(userId);\n        mOwners.writeProfileOwner(userId);\n        deleteTransferOwnershipBundleLocked(userId);\n        toggleBackupServiceActive(userId, true);\n        applyProfileRestrictionsIfDeviceOwnerLocked();\n        setNetworkLoggingActiveInternal(false);\n\n        if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n            mDevicePolicyEngine.removePoliciesForAdmin(\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(), userId, admin));\n        }\n    }\n\n    @Override\n    public void setDeviceOwnerLockScreenInfo(ComponentName who, CharSequence info) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mLockPatternUtils.setDeviceOwnerInfo(info != null ? info.toString() : null));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_DEVICE_OWNER_LOCK_SCREEN_INFO)\n                .setAdmin(caller.getComponentName())\n                .write();\n    }\n\n    @Override\n    public CharSequence getDeviceOwnerLockScreenInfo() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        return mInjector.binderWithCleanCallingIdentity(() ->\n            mLockPatternUtils.getDeviceOwnerInfo());\n    }\n\n    private void clearUserPoliciesLocked(int userId) {\n        // Reset some of the user-specific policies."
                        ],
                        "downstream_patched_file_llm_output": "skipped",
                        "llm_time_taken_seconds": 599.73
                    }
                ]
            }
        ]
    }
]