{
    "run_timestamp": "20250604_231036",
    "target_downstream_version": "all_versions",
    "input_json_file": "inputs/top_11_vulns_2425.json",
    "main_output_json_file_with_diffs": "outputs/approach2_results/approach2_output_diff_android_all_versions_20250604_231036.json",
    "summary": {
        "total_file_conflicts_matching_version": 6,
        "files_attempted_for_llm_diff_generation": 6,
        "files_with_llm_diff_successfully_generated": 3,
        "files_skipped_pre_llm_call": 0,
        "files_with_llm_diff_generation_errors_or_skipped_in_func": 2,
        "successful_attempts_histogram": {
            "1 run": 2,
            "2 runs": 1
        },
        "total_runtime_seconds_all": 2759.27,
        "total_runtime_seconds_successful": 1768.5,
        "system_prompt": "You are an expert software patch generation assistant.\nYour primary task is to generate *perfectly formatted* unified diffs, enclosed in a ```diff markdown block, to resolve software conflicts presented in `.rej` files.\nAdherence to the unified diff format and the specified output structure is paramount.\n\nKey Objectives:\n1.  **Analyze Rejects**: Carefully examine the provided '.rej File Content' and 'Original Source File'.\n2.  **Generate Corrected Diff**: Create a new unified diff that incorporates the intended changes from the .rej file, adjusted to apply successfully to the 'Original Source File'.\n3.  **Minimal Changes**: Modify *only* what is absolutely necessary within the rejected hunks to ensure they apply correctly and preserve the original intent of the patch.\n4.  **Security Focus**: While ensuring correct formatting, the goal is to apply a security patch. Ensure your corrections maintain or achieve the intended security remediation.\n\nSTRICT FORMATTING AND OUTPUT REQUIREMENTS:\n*   **Markdown Diff Block**: Your entire response MUST be a single markdown code block of type 'diff'. Start with ```diff (with a newline after it) and end with ```.\n*   **No Extra Text**: Absolutely NO explanations, NO comments, NO apologies, NO summaries, or any other text outside this single ```diff ... ``` block.\n*   **Diff Content - Headers**: Inside the block, the diff MUST start with `--- a/FILENAME` and `+++ b/FILENAME` lines, where FILENAME is the target filename provided to you in the task.\n*   **Diff Content - Hunk Structure and Line Counts**:\n    *   You MUST generate hunks that precisely match the line counts implied by the input `.rej` file's hunk headers (e.g., `@@ -old_start,old_lines +new_start,new_lines @@`).\n    *   The output hunk should contain `old_lines` from the original (prefixed with ' ' for context, '-' for removed) and `new_lines` for the patched version (prefixed with ' ' for context, '+' for added).\n    *   Do NOT add extraneous context lines beyond what is necessary to make the patch apply cleanly and match the implied line counts.\n*   **Diff Content - Line Prefixes**: Every content line *within* a diff hunk (after the `@@ ... @@` header) MUST start with a ' ' (space for context), '-' (for removed lines), or '+' (for added lines).\n*   **No Nested Code Blocks**: Do NOT use further markdown code fences (like ```) *inside* the main diff content.\n\nHere is an example of a successful transformation. Pay close attention to how the `.rej` file is resolved against the original source snippets to produce the \"Expected Output Diff\".\n\n**Few-Shot Example:**\n\n**Target Filename:**\n`services/usb/java/com/android/server/usb/UsbDeviceManager.java`\n\n**Original Source (services/usb/java/com/android/server/usb/UsbDeviceManager.java):**\n```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.IUsbGadget;\nimport android.hardware.usb.gadget.V1_0.IUsbGadgetCallback;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hidl.manager.V1_0.IServiceManager;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String AUDIO_SOURCE_PCM_PATH =\n            \"/sys/class/android_usb/android0/f_audio_source/pcm\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n\n    private static final int AUDIO_MODE_SOURCE = 1;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sBlackListedInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    static {\n        sBlackListedInterfaces = new HashSet<>();\n        sBlackListedInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sBlackListedInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sBlackListedInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sBlackListedInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sBlackListedInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sBlackListedInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sBlackListedInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sBlackListedInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sBlackListedInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sBlackListedInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sBlackListedInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n\n            String state = event.get(\"USB_STATE\");\n            String accessory = event.get(\"ACCESSORY\");\n            if (state != null) {\n                mHandler.updateState(state);\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                startAccessoryMode();\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        boolean halNotPresent = false;\n        try {\n            IUsbGadget.getService(true);\n        } catch (RemoteException e) {\n            Slog.e(TAG, \"USB GADGET HAL present but exception thrown\", e);\n        } catch (NoSuchElementException e) {\n            halNotPresent = true;\n            Slog.i(TAG, \"USB GADGET HAL not present in the device\", e);\n        }\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (halNotPresent) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(USB_STATE_MATCH);\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        boolean enableAudio = (nativeGetAudioMode() == AUDIO_MODE_SOURCE);\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n        if (enableAudio) {\n            functions |= UsbManager.FUNCTION_AUDIO_SOURCE;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            setCurrentFunctions(functions);\n        }\n    }\n\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.e(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mConfigured;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        protected boolean mConnected;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            removeMessages(MSG_UPDATE_STATE);\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            // debounce disconnects to avoid problems bringing up USB tethering\n            sendMessageDelayed(msg, (connected == 0) ? UPDATE_DELAY : 0);\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit();\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        private void notifyAccessoryModeExit() {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    Scanner scanner = null;\n                    try {\n                        scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                        mMidiCard = scanner.nextInt();\n                        mMidiDevice = scanner.nextInt();\n                    } catch (FileNotFoundException e) {\n                        Slog.e(TAG, \"could not open MIDI file\", e);\n                        enabled = false;\n                    } finally {\n                        if (scanner != null) {\n                            scanner.close();\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        private void setScreenUnlockedFunctions() {\n            setEnabledFunctions(mScreenUnlockedFunctions, false);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions();\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n                    mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                    mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                    mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                    mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n                    // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                    // But, this should be suffice, since, all four combinations are only supported\n                    // when PR_SWAP and DR_SWAP are supported.\n                    mSupportsAllCombinations = status.isRoleCombinationSupported(\n                            POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                            && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                            && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                            DATA_ROLE_DEVICE)\n                            && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    boolean connected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + connected);\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sBlackListedInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    setEnabledFunctions(functions, false);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions();\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions();\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot();\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    mBootCompleted = true;\n                    finishBoot();\n                    break;\n                case MSG_USER_SWITCHED: {\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit();\n                    }\n                    break;\n                }\n            }\n        }\n\n        protected void finishBoot() {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions();\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                }\n\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if (mHideUsbNotification && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_RNDIS) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && mUsbCharging) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive.\n                if (mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, 0, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            pi = PendingIntent.getActivity(mContext, 0, intent, 0);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions, boolean forceRestart);\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions + \", \"\n                        + \"forceRestart=\" + forceRestart + \", usbDataUnlocked=\" + usbDataUnlocked);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + functions);\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        /**\n         * Proxy object for the usb gadget hal daemon.\n         */\n        @GuardedBy(\"mGadgetProxyLock\")\n        private IUsbGadget mGadgetProxy;\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                ServiceNotification serviceNotification = new ServiceNotification();\n\n                boolean ret = IServiceManager.getService()\n                        .registerForNotifications(GADGET_HAL_FQ_NAME, \"\", serviceNotification);\n                if (!ret) {\n                    Slog.e(TAG, \"Failed to register usb gadget service start notification\");\n                    return;\n                }\n\n                synchronized (mGadgetProxyLock) {\n                    mGadgetProxy = IUsbGadget.getService(true);\n                    mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                            USB_GADGET_HAL_DEATH_COOKIE);\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mGadgetProxy.getCurrentUsbFunctions(new UsbGadgetCallback());\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (RemoteException e) {\n                Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mGadgetProxy = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\");\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.e(TAG, \"prcessing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.e(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.e(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot();\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mGadgetProxy = IUsbGadget.getService();\n                            mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                                    USB_GADGET_HAL_DEATH_COOKIE);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            gadgetProxy.reset();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                        }\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        private class UsbGadgetCallback extends IUsbGadgetCallback.Stub {\n            int mRequest;\n            long mFunctions;\n            boolean mChargingFunctions;\n\n            UsbGadgetCallback() {\n            }\n\n            UsbGadgetCallback(int request, long functions,\n                    boolean chargingFunctions) {\n                mRequest = request;\n                mFunctions = functions;\n                mChargingFunctions = chargingFunctions;\n            }\n\n            @Override\n            public void setCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                /**\n                 * Callback called for a previous setCurrenUsbFunction\n                 */\n                if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                        || (mFunctions != functions)) {\n                    return;\n                }\n\n                removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n                Slog.e(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n                if (status == Status.SUCCESS) {\n                    mCurrentFunctionsApplied = true;\n                } else if (!mChargingFunctions) {\n                    Slog.e(TAG, \"Setting default fuctions\");\n                    sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n                }\n            }\n\n            @Override\n            public void getCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                        status == Status.FUNCTIONS_APPLIED);\n            }\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mGadgetProxy == null) {\n                    Slog.e(TAG, \"setUsbConfig mGadgetProxy is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    UsbGadgetCallback usbGadgetCallback = new UsbGadgetCallback(mCurrentRequest,\n                            config, chargingFunctions);\n                    mGadgetProxy.setCurrentUsbFunctions(config, usbGadgetCallback,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + functions + \", \"\n                        + \"forceRestart=\" + forceRestart);\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n        }\n\n        dump.end(token);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native int nativeGetAudioMode();\n}\n```\n\n**.rej File Content:**\n```text\n--- services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -80,9 +80,9 @@ import android.os.storage.StorageVolume;\n import android.provider.Settings;\n import android.service.usb.UsbDeviceManagerProto;\n import android.service.usb.UsbHandlerProto;\n+import android.text.TextUtils;\n import android.util.Pair;\n import android.util.Slog;\n-import android.text.TextUtils;\n \n import com.android.internal.R;\n import com.android.internal.annotations.GuardedBy;\n@@ -880,7 +880,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit(int operationId) {\n+        protected void notifyAccessoryModeExit(int operationId) {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -2313,8 +2313,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      */\n                     operationId = sUsbOperationCount.incrementAndGet();\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit(operationId);\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:\n```\n\n**Expected Output Diff:**\n```diff\n--- a/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -719,7 +719,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit() {\n+        protected void notifyAccessoryModeExit() {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -1957,8 +1957,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      * Dont force to default when the configuration is already set to default.\n                      */\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit();\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:\n```\n",
        "base_task_prompt": "Your task is to resolve the conflicts in the provided `.rej` file by generating a corrected unified diff that applies cleanly to the 'Original Source File'.\nAdhere strictly to the unified diff format instructions, hunk construction rules, and output requirements detailed in your system guidelines.\n\nInputs:\n1.  **Original Source File Content**: The content of the file that needs to be patched.\n    ```text\n    {dependencies.original_source_file_content}\n    ```\n\n2.  **.rej File Content**: The rejected hunks from a previous patch attempt. These are the changes you MUST adapt and correct. Pay close attention to the `@@ ... @@` headers in this content to determine the correct number of lines for your output hunk.\n    ```text\n    {dependencies.rej_file_content}\n    ```\n\n3.  **Target Filename**: Use this exact name for the `--- a/` and `+++ b/` lines in your diff.\n    `{target_filename_for_diff}`\n\nYour Specific Task:\nBased on the inputs above, generate a corrected unified diff.\n*   The diff must take the changes described in the '.rej File Content' and make them apply cleanly to the 'Original Source File'.\n*   Address line number offsets or context mismatches.\n*   Preserve the original intent of the security patch.\n*   Strictly adhere to line counts and structure indicated by the `.rej` file's hunk headers as per your system guidelines.\n*   Ensure all lines within your generated hunks start with ' ' (space), '+', or '-' as per your system guidelines.\n\nGenerate the corrected unified diff:\n    "
    },
    "successfully_generated_diffs_log": [
        {
            "vulnerability_id": "ASB-A-353712853",
            "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
            "patch_sha": "37be5d18e529877fcd3c62063aec205a96660449",
            "downstream_version": "14",
            "diff_preview": "```diff\n--- a/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ b/services/usb/java..."
        },
        {
            "vulnerability_id": "ASB-A-353712853",
            "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
            "patch_sha": "aec6c731bfdbe7f0fe537948563a7aeee5cf05e2",
            "downstream_version": "13",
            "diff_preview": "```diff\n--- a/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ b/services/usb/java..."
        },
        {
            "vulnerability_id": "ASB-A-382064697",
            "file_name": "services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java",
            "patch_sha": "3461e84908b46b6fe82ac391d43a43f23c0b1d3e",
            "downstream_version": "14",
            "diff_preview": "```diff\n--- a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService...."
        }
    ],
    "skipped_or_errored_diff_generation_log": [
        {
            "vulnerability_id": "ASB-A-353712853",
            "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
            "patch_sha": "643bea502a92329e72585050fb7fa5535456094f",
            "reason": "Last Format Error: Invalid patch format: Hunk is longer than expected, Last Apply Error: Skipped due to format error",
            "last_format_error": "Invalid patch format: Hunk is longer than expected",
            "last_apply_error": "Skipped due to format error"
        },
        {
            "vulnerability_id": "ASB-A-353712853",
            "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
            "patch_sha": "ef6f37e5292ae3491de1857751dc01a319bb61d1",
            "reason": "Last Format Error: Invalid patch format: Hunk is longer than expected, Last Apply Error: Skipped due to format error",
            "last_format_error": "Invalid patch format: Hunk is longer than expected",
            "last_apply_error": "Skipped due to format error"
        }
    ]
}