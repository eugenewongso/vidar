[
  {
    "id": "ASB-A-300090204",
    "total_gemini_token_usage": 119871,
    "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-300090204",
    "severity": "High",
    "upstream_patch_content": "From 2ce1b7fd37273ea19fbbb6daeeaa6212357b9a70 Mon Sep 17 00:00:00 2001\nFrom: Lucas Silva <lusilva@google.com>\nDate: Tue, 30 Aug 2022 15:29:11 -0400\nSubject: [PATCH] Fix vulnerability that allowed attackers to start arbitary\n activities\n\nTest: atest DreamServiceTest\nTest: flashed device and verified dream settings works as expected\nFixes: 242845514\nChange-Id: I6e90e3a0d513dceb7d7f5c59d6807ebe164c5716\n---\n core/api/test-current.txt                     | 10 ++++++\n .../android/service/dreams/DreamService.java  | 20 +++++++++--\n .../tests/servicestests/AndroidManifest.xml   | 13 +++++++\n .../res/xml/test_dream_metadata.xml           |  2 +-\n .../res/xml/test_dream_metadata_invalid.xml   | 20 +++++++++++\n .../server/dreams/DreamServiceTest.java       | 36 +++++++++++++------\n .../TestDreamServiceWithInvalidSettings.java  | 25 +++++++++++++\n 7 files changed, 112 insertions(+), 14 deletions(-)\n create mode 100644 services/tests/servicestests/res/xml/test_dream_metadata_invalid.xml\n create mode 100644 services/tests/servicestests/src/com/android/server/dreams/TestDreamServiceWithInvalidSettings.java\n\ndiff --git a/core/api/test-current.txt b/core/api/test-current.txt\nindex 521793b0ec43..18723527ce19 100644\n--- a/core/api/test-current.txt\n+++ b/core/api/test-current.txt\n@@ -2412,6 +2412,16 @@ package android.service.dreams {\n     method public final boolean shouldShowComplications();\n   }\n \n+  public class DreamService extends android.app.Service implements android.view.Window.Callback {\n+    method @Nullable public static android.service.dreams.DreamService.DreamMetadata getDreamMetadata(@NonNull android.content.Context, @Nullable android.content.pm.ServiceInfo);\n+  }\n+\n+  public static final class DreamService.DreamMetadata {\n+    field @Nullable public final android.graphics.drawable.Drawable previewImage;\n+    field @Nullable public final android.content.ComponentName settingsActivity;\n+    field @NonNull public final boolean showComplications;\n+  }\n+\n }\n \n package android.service.notification {\ndiff --git a/core/java/android/service/dreams/DreamService.java b/core/java/android/service/dreams/DreamService.java\nindex 2d461c6cf92e..75155383855b 100644\n--- a/core/java/android/service/dreams/DreamService.java\n+++ b/core/java/android/service/dreams/DreamService.java\n@@ -22,6 +22,7 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.annotation.SdkConstant;\n import android.annotation.SdkConstant.SdkConstantType;\n+import android.annotation.TestApi;\n import android.app.Activity;\n import android.app.ActivityTaskManager;\n import android.app.AlarmManager;\n@@ -1124,7 +1125,8 @@ public class DreamService extends Service implements Window.Callback {\n      * @hide\n      */\n     @Nullable\n-    public static DreamMetadata getDreamMetadata(Context context,\n+    @TestApi\n+    public static DreamMetadata getDreamMetadata(@NonNull Context context,\n             @Nullable ServiceInfo serviceInfo) {\n         if (serviceInfo == null) return null;\n \n@@ -1183,7 +1185,8 @@ public class DreamService extends Service implements Window.Callback {\n         }\n     }\n \n-    private static ComponentName convertToComponentName(String flattenedString,\n+    @Nullable\n+    private static ComponentName convertToComponentName(@Nullable String flattenedString,\n             ServiceInfo serviceInfo) {\n         if (flattenedString == null) {\n             return null;\n@@ -1193,7 +1196,17 @@ public class DreamService extends Service implements Window.Callback {\n             return new ComponentName(serviceInfo.packageName, flattenedString);\n         }\n \n-        return ComponentName.unflattenFromString(flattenedString);\n+        // Ensure that the component is from the same package as the dream service. If not,\n+        // treat the component as invalid and return null instead.\n+        final ComponentName cn = ComponentName.unflattenFromString(flattenedString);\n+        if (cn == null) return null;\n+        if (!cn.getPackageName().equals(serviceInfo.packageName)) {\n+            Log.w(TAG,\n+                    \"Inconsistent package name in component: \" + cn.getPackageName()\n+                            + \", should be: \" + serviceInfo.packageName);\n+            return null;\n+        }\n+        return cn;\n     }\n \n     /**\n@@ -1489,6 +1502,7 @@ public class DreamService extends Service implements Window.Callback {\n      *\n      * @hide\n      */\n+    @TestApi\n     public static final class DreamMetadata {\n         @Nullable\n         public final ComponentName settingsActivity;\ndiff --git a/services/tests/servicestests/AndroidManifest.xml b/services/tests/servicestests/AndroidManifest.xml\nindex 0483a60ca378..7ae70eb6886b 100644\n--- a/services/tests/servicestests/AndroidManifest.xml\n+++ b/services/tests/servicestests/AndroidManifest.xml\n@@ -147,6 +147,19 @@\n                 android:resource=\"@xml/test_dream_metadata\" />\n         </service>\n \n+        <service\n+            android:name=\"com.android.server.dreams.TestDreamServiceWithInvalidSettings\"\n+            android:exported=\"false\"\n+            android:label=\"Test Dream\" >\n+            <intent-filter>\n+                <action android:name=\"android.service.dreams.DreamService\" />\n+                <category android:name=\"android.intent.category.DEFAULT\" />\n+            </intent-filter>\n+            <meta-data\n+                android:name=\"android.service.dream\"\n+                android:resource=\"@xml/test_dream_metadata_invalid\" />\n+        </service>\n+\n         <receiver android:name=\"com.android.server.devicepolicy.ApplicationRestrictionsTest$AdminReceiver\"\n              android:permission=\"android.permission.BIND_DEVICE_ADMIN\"\n              android:exported=\"true\">\ndiff --git a/services/tests/servicestests/res/xml/test_dream_metadata.xml b/services/tests/servicestests/res/xml/test_dream_metadata.xml\nindex aa054f1e9fa4..9905c69474ad 100644\n--- a/services/tests/servicestests/res/xml/test_dream_metadata.xml\n+++ b/services/tests/servicestests/res/xml/test_dream_metadata.xml\n@@ -15,5 +15,5 @@\n   -->\n \n <dream xmlns:android=\"http://schemas.android.com/apk/res/android\"\n-       android:settingsActivity=\"com.android.server.dreams/.TestDreamSettingsActivity\"\n+       android:settingsActivity=\"com.android.frameworks.servicestests/.TestDreamSettingsActivity\"\n        android:showClockAndComplications=\"false\" />\ndiff --git a/services/tests/servicestests/res/xml/test_dream_metadata_invalid.xml b/services/tests/servicestests/res/xml/test_dream_metadata_invalid.xml\nnew file mode 100644\nindex 000000000000..47864d9cf62d\n--- /dev/null\n+++ b/services/tests/servicestests/res/xml/test_dream_metadata_invalid.xml\n@@ -0,0 +1,20 @@\n+<!--\n+  ~ Copyright (C) 2022 The Android Open Source Project\n+  ~\n+  ~ Licensed under the Apache License, Version 2.0 (the \"License\");\n+  ~ you may not use this file except in compliance with the License.\n+  ~ You may obtain a copy of the License at\n+  ~\n+  ~      http://www.apache.org/licenses/LICENSE-2.0\n+  ~\n+  ~ Unless required by applicable law or agreed to in writing, software\n+  ~ distributed under the License is distributed on an \"AS IS\" BASIS,\n+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  ~ See the License for the specific language governing permissions and\n+  ~ limitations under the License.\n+  -->\n+\n+<!-- The settings activity is in a different package, which is invalid -->\n+<dream xmlns:android=\"http://schemas.android.com/apk/res/android\"\n+       android:settingsActivity=\"com.android.server.dreams/.TestDreamSettingsActivity\"\n+       android:showClockAndComplications=\"false\"/>\ndiff --git a/services/tests/servicestests/src/com/android/server/dreams/DreamServiceTest.java b/services/tests/servicestests/src/com/android/server/dreams/DreamServiceTest.java\nindex 74d2e0f231bb..0efd296fd8b6 100644\n--- a/services/tests/servicestests/src/com/android/server/dreams/DreamServiceTest.java\n+++ b/services/tests/servicestests/src/com/android/server/dreams/DreamServiceTest.java\n@@ -16,7 +16,8 @@\n \n package com.android.server.dreams;\n \n-import static org.junit.Assert.assertEquals;\n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.junit.Assert.assertFalse;\n \n import android.content.ComponentName;\n@@ -35,21 +36,36 @@ import org.junit.runner.RunWith;\n @SmallTest\n @RunWith(AndroidJUnit4.class)\n public class DreamServiceTest {\n+    private static final String TEST_PACKAGE_NAME = \"com.android.frameworks.servicestests\";\n+\n     @Test\n     public void testMetadataParsing() throws PackageManager.NameNotFoundException {\n-        final String testPackageName = \"com.android.frameworks.servicestests\";\n         final String testDreamClassName = \"com.android.server.dreams.TestDreamService\";\n-        final String testSettingsActivity = \"com.android.server.dreams/.TestDreamSettingsActivity\";\n+        final String testSettingsActivity =\n+                \"com.android.frameworks.servicestests/.TestDreamSettingsActivity\";\n+        final DreamService.DreamMetadata metadata = getDreamMetadata(testDreamClassName);\n \n-        final Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();\n+        assertThat(metadata.settingsActivity).isEqualTo(\n+                ComponentName.unflattenFromString(testSettingsActivity));\n+        assertFalse(metadata.showComplications);\n+    }\n+\n+    @Test\n+    public void testMetadataParsing_invalidSettingsActivity()\n+            throws PackageManager.NameNotFoundException {\n+        final String testDreamClassName =\n+                \"com.android.server.dreams.TestDreamServiceWithInvalidSettings\";\n+        final DreamService.DreamMetadata metadata = getDreamMetadata(testDreamClassName);\n+\n+        assertThat(metadata.settingsActivity).isNull();\n+    }\n \n+    private DreamService.DreamMetadata getDreamMetadata(String dreamClassName)\n+            throws PackageManager.NameNotFoundException {\n+        final Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();\n         final ServiceInfo si = context.getPackageManager().getServiceInfo(\n-                new ComponentName(testPackageName, testDreamClassName),\n+                new ComponentName(TEST_PACKAGE_NAME, dreamClassName),\n                 PackageManager.ComponentInfoFlags.of(PackageManager.GET_META_DATA));\n-        final DreamService.DreamMetadata metadata = DreamService.getDreamMetadata(context, si);\n-\n-        assertEquals(0, metadata.settingsActivity.compareTo(\n-                ComponentName.unflattenFromString(testSettingsActivity)));\n-        assertFalse(metadata.showComplications);\n+        return DreamService.getDreamMetadata(context, si);\n     }\n }\ndiff --git a/services/tests/servicestests/src/com/android/server/dreams/TestDreamServiceWithInvalidSettings.java b/services/tests/servicestests/src/com/android/server/dreams/TestDreamServiceWithInvalidSettings.java\nnew file mode 100644\nindex 000000000000..5c7d02fb755c\n--- /dev/null\n+++ b/services/tests/servicestests/src/com/android/server/dreams/TestDreamServiceWithInvalidSettings.java\n@@ -0,0 +1,25 @@\n+/*\n+ * Copyright (C) 2022 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.android.server.dreams;\n+\n+import android.service.dreams.DreamService;\n+\n+/**\n+ * Dream service implementation for unit testing, where the settings activity is invalid.\n+ */\n+public class TestDreamServiceWithInvalidSettings extends DreamService {\n+}\n-- \n2.39.5 (Apple Git-154)\n\n",
    "upstream_commits": [
      "2ce1b7fd37273ea19fbbb6daeeaa6212357b9a70"
    ],
    "upstream_patch_tokens": {
      "openai": 2777,
      "general": {
        "word_based": 1234,
        "char_based": 2998
      },
      "gemini": 3433
    },
    "failures": [
      {
        "downstream_version": "12L",
        "gemini_token_usage": 38858,
        "branch_used": "android12L-release",
        "downstream_patch": "6926fd15fb16c51468dde270bd61ee68772b8c14",
        "repo_path": "android_repos/base",
        "result": "failure",
        "downstream_patch_content": "commit 6926fd15fb16c51468dde270bd61ee68772b8c14\nAuthor: Will Leshner <wleshner@google.com>\nDate:   Tue Oct 31 13:23:08 2023 -0700\n\n    Fix vulnerability that allowed attackers to start arbitary activities\n    \n    Test: Flashed device and verified dream settings works as expected\n    Test: Installed APK from bug and verified the dream didn't allow\n    launching the inappropriate settings activity.\n    Fixes: 300090204\n    \n    Merged-In: I6e90e3a0d513dceb7d7f5c59d6807ebe164c5716\n    Merged-In: I146415ad400827d0a798e27f34f098feb5e96422\n    Merged-In: I7f2351fc7d9a82778ce21f67018a45ac67c9aaf8\n    Change-Id: I573040df84bf98a493b39f96c8581e4303206bac\n\ndiff --git a/packages/SettingsLib/src/com/android/settingslib/dream/DreamBackend.java b/packages/SettingsLib/src/com/android/settingslib/dream/DreamBackend.java\nindex ab7b54d98285..beadd821957b 100644\n--- a/packages/SettingsLib/src/com/android/settingslib/dream/DreamBackend.java\n+++ b/packages/SettingsLib/src/com/android/settingslib/dream/DreamBackend.java\n@@ -351,7 +351,17 @@ public class DreamBackend {\n         if (cn != null && cn.indexOf('/') < 0) {\n             cn = resolveInfo.serviceInfo.packageName + \"/\" + cn;\n         }\n-        return cn == null ? null : ComponentName.unflattenFromString(cn);\n+        // Ensure that the component is from the same package as the dream service. If not,\n+        // treat the component as invalid and return null instead.\n+        final ComponentName result = cn != null ? ComponentName.unflattenFromString(cn) : null;\n+        if (result != null\n+                && !result.getPackageName().equals(resolveInfo.serviceInfo.packageName)) {\n+            Log.w(TAG,\n+                    \"Inconsistent package name in component: \" + result.getPackageName()\n+                            + \", should be: \" + resolveInfo.serviceInfo.packageName);\n+            return null;\n+        }\n+        return result;\n     }\n \n     private static void logd(String msg, Object... args) {\n",
        "downstream_patch_tokens": {
          "openai": 532,
          "general": {
            "word_based": 207,
            "char_based": 493
          },
          "gemini": 692
        },
        "file_conflicts": [
          {
            "file_name": "core/java/android/service/dreams/DreamService.java",
            "total_hunks": 5,
            "failed_hunks": [
              2,
              3,
              4,
              5
            ],
            "inline_merge_conflicts": [
              {
                "hunk_number": 1,
                "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n        mDreamToken = null;\n        mCanDoze = false;\n=======\n        // Ensure that the component is from the same package as the dream service. If not,\n        // treat the component as invalid and return null instead.\n        final ComponentName cn = ComponentName.unflattenFromString(flattenedString);\n        if (cn == null) return null;\n        if (!cn.getPackageName().equals(serviceInfo.packageName)) {\n            Log.w(TAG,\n                    \"Inconsistent package name in component: \" + cn.getPackageName()\n                            + \", should be: \" + serviceInfo.packageName);\n            return null;\n        }\n        return cn;\n>>>>>>> UPSTREAM PATCH (commit 2ce1b7fd37273ea19fbbb6daeeaa6212357b9a70)",
                "merge_conflict_tokens": {
                  "openai": 170,
                  "general": {
                    "word_based": 70,
                    "char_based": 188
                  },
                  "gemini": 198
                }
              }
            ],
            "inline_merge_token_summary": {
              "gemini": 13464,
              "openai": 11730,
              "general_word": 4830,
              "general_char": 12972
            },
            "rej_file_content": "```diff\n--- core/java/android/service/dreams/DreamService.java\n+++ core/java/android/service/dreams/DreamService.java\n@@ -1125,7 +1126,8 @@ public class DreamService extends Service implements Window.Callback {\n      * @hide\n      */\n     @Nullable\n-    public static DreamMetadata getDreamMetadata(Context context,\n+    @TestApi\n+    public static DreamMetadata getDreamMetadata(@NonNull Context context,\n             @Nullable ServiceInfo serviceInfo) {\n         if (serviceInfo == null) return null;\n \n@@ -1184,7 +1186,8 @@ public class DreamService extends Service implements Window.Callback {\n         }\n     }\n \n-    private static ComponentName convertToComponentName(String flattenedString,\n+    @Nullable\n+    private static ComponentName convertToComponentName(@Nullable String flattenedString,\n             ServiceInfo serviceInfo) {\n         if (flattenedString == null) {\n             return null;\n@@ -1194,7 +1197,17 @@ public class DreamService extends Service implements Window.Callback {\n             return new ComponentName(serviceInfo.packageName, flattenedString);\n         }\n \n-        return ComponentName.unflattenFromString(flattenedString);\n+        // Ensure that the component is from the same package as the dream service. If not,\n+        // treat the component as invalid and return null instead.\n+        final ComponentName cn = ComponentName.unflattenFromString(flattenedString);\n+        if (cn == null) return null;\n+        if (!cn.getPackageName().equals(serviceInfo.packageName)) {\n+            Log.w(TAG,\n+                    \"Inconsistent package name in component: \" + cn.getPackageName()\n+                            + \", should be: \" + serviceInfo.packageName);\n+            return null;\n+        }\n+        return cn;\n     }\n \n     /**\n@@ -1490,6 +1503,7 @@ public class DreamService extends Service implements Window.Callback {\n      *\n      * @hide\n      */\n+    @TestApi\n     public static final class DreamMetadata {\n         @Nullable\n         public final ComponentName settingsActivity;\n```",
            "rej_file_tokens": {
              "openai": 434,
              "general": {
                "word_based": 188,
                "char_based": 507
              },
              "gemini": 504
            },
            "patch_apply_output": "patching file core/java/android/service/dreams/DreamService.java\nHunk #1 succeeded at 21 (offset -1 lines).\nHunk #2 FAILED at 1125.\nHunk #3 FAILED at 1184.\nHunk #4 FAILED at 1194.\nHunk #5 FAILED at 1490.\n4 out of 5 hunks FAILED -- saving rejects to file core/java/android/service/dreams/DreamService.java.rej",
            "inline_merge_output": "patching file core/java/android/service/dreams/DreamService.java\nHunk #1 already applied at 25.\nHunk #2 already applied at 1128-1129.\nHunk #3 already applied at 1188-1189.\nHunk #4 NOT MERGED at 1230-1245.\nHunk #5 already applied at 1519.",
            "upstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage android.service.dreams;\n\nimport android.annotation.IdRes;\nimport android.annotation.LayoutRes;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.SdkConstant;\nimport android.annotation.SdkConstant.SdkConstantType;\nimport android.annotation.TestApi;\nimport android.app.Activity;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.Service;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ServiceInfo;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.graphics.drawable.Drawable;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.IRemoteCallback;\nimport android.os.Looper;\nimport android.os.PowerManager;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.util.MathUtils;\nimport android.util.Slog;\nimport android.util.Xml;\nimport android.view.ActionMode;\nimport android.view.Display;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SearchEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowInsets;\nimport android.view.WindowManager;\nimport android.view.WindowManager.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.R;\nimport com.android.internal.util.DumpUtils;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.FileDescriptor;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.function.Consumer;\n\n/**\n * Extend this class to implement a custom dream (available to the user as a \"Daydream\").\n *\n * <p>Dreams are interactive screensavers launched when a charging device is idle, or docked in a\n * desk dock. Dreams provide another modality for apps to express themselves, tailored for\n * an exhibition/lean-back experience.</p>\n *\n * <p>The {@code DreamService} lifecycle is as follows:</p>\n * <ol>\n *   <li>{@link #onAttachedToWindow}\n *     <p>Use this for initial setup, such as calling {@link #setContentView setContentView()}.</li>\n *   <li>{@link #onDreamingStarted}\n *     <p>Your dream has started, so you should begin animations or other behaviors here.</li>\n *   <li>{@link #onDreamingStopped}\n *     <p>Use this to stop the things you started in {@link #onDreamingStarted}.</li>\n *   <li>{@link #onDetachedFromWindow}\n *     <p>Use this to dismantle resources (for example, detach from handlers\n *        and listeners).</li>\n * </ol>\n *\n * <p>In addition, onCreate and onDestroy (from the Service interface) will also be called, but\n * initialization and teardown should be done by overriding the hooks above.</p>\n *\n * <p>To be available to the system, your {@code DreamService} should be declared in the\n * manifest as follows:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\" >\n *\n *     &lt;intent-filter>\n *         &lt;action android:name=\"android.service.dreams.DreamService\" />\n *         &lt;category android:name=\"android.intent.category.DEFAULT\" />\n *     &lt;/intent-filter>\n *\n *     &lt;!-- Point to additional information for this dream (optional) -->\n *     &lt;meta-data\n *         android:name=\"android.service.dream\"\n *         android:resource=\"@xml/my_dream\" />\n * &lt;/service>\n * </pre>\n *\n * <p>If specified with the {@code <meta-data>} element,\n * additional information for the dream is defined using the\n * {@link android.R.styleable#Dream &lt;dream&gt;} element in a separate XML file.\n * Currently, the only additional\n * information you can provide is for a settings activity that allows the user to configure\n * the dream behavior. For example:</p>\n * <p class=\"code-caption\">res/xml/my_dream.xml</p>\n * <pre>\n * &lt;dream xmlns:android=\"http://schemas.android.com/apk/res/android\"\n *     android:settingsActivity=\"com.example.app/.MyDreamSettingsActivity\" />\n * </pre>\n * <p>This makes a Settings button available alongside your dream's listing in the\n * system settings, which when pressed opens the specified activity.</p>\n *\n *\n * <p>To specify your dream layout, call {@link #setContentView}, typically during the\n * {@link #onAttachedToWindow} callback. For example:</p>\n * <pre>\n * public class MyDream extends DreamService {\n *\n *     &#64;Override\n *     public void onAttachedToWindow() {\n *         super.onAttachedToWindow();\n *\n *         // Exit dream upon user touch\n *         setInteractive(false);\n *         // Hide system UI\n *         setFullscreen(true);\n *         // Set the dream layout\n *         setContentView(R.layout.dream);\n *     }\n * }\n * </pre>\n *\n * <p>When targeting api level 21 and above, you must declare the service in your manifest file\n * with the {@link android.Manifest.permission#BIND_DREAM_SERVICE} permission. For example:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\"\n *     android:permission=\"android.permission.BIND_DREAM_SERVICE\">\n *   &lt;intent-filter>\n *     &lt;action android:name=\u201dandroid.service.dreams.DreamService\u201d />\n *     &lt;category android:name=\u201dandroid.intent.category.DEFAULT\u201d />\n *   &lt;/intent-filter>\n * &lt;/service>\n * </pre>\n */\npublic class DreamService extends Service implements Window.Callback {\n    private static final String TAG = DreamService.class.getSimpleName();\n    private final String mTag = TAG + \"[\" + getClass().getSimpleName() + \"]\";\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n\n    /**\n     * The name of the dream manager service.\n     * @hide\n     */\n    public static final String DREAM_SERVICE = \"dreams\";\n\n    /**\n     * The {@link Intent} that must be declared as handled by the service.\n     */\n    @SdkConstant(SdkConstantType.SERVICE_ACTION)\n    public static final String SERVICE_INTERFACE =\n            \"android.service.dreams.DreamService\";\n\n    /**\n     * The name of the extra where the dream overlay component is stored.\n     * @hide\n     */\n    public static final String EXTRA_DREAM_OVERLAY_COMPONENT =\n            \"android.service.dream.DreamService.dream_overlay_component\";\n\n    /**\n     * Name under which a Dream publishes information about itself.\n     * This meta-data must reference an XML resource containing\n     * a <code>&lt;{@link android.R.styleable#Dream dream}&gt;</code>\n     * tag.\n     */\n    public static final String DREAM_META_DATA = \"android.service.dream\";\n\n    /**\n     * Name of the root tag under which a Dream defines its metadata in an XML file.\n     */\n    private static final String DREAM_META_DATA_ROOT_TAG = \"dream\";\n\n    /**\n     * Extra containing a boolean for whether to show complications on the overlay.\n     * @hide\n     */\n    public static final String EXTRA_SHOW_COMPLICATIONS =\n            \"android.service.dreams.SHOW_COMPLICATIONS\";\n\n    /**\n     * The default value for whether to show complications on the overlay.\n     * @hide\n     */\n    public static final boolean DEFAULT_SHOW_COMPLICATIONS = false;\n\n    private final IDreamManager mDreamManager;\n    private final Handler mHandler = new Handler(Looper.getMainLooper());\n    private IBinder mDreamToken;\n    private Window mWindow;\n    private Activity mActivity;\n    private boolean mInteractive;\n    private boolean mFullscreen;\n    private boolean mScreenBright = true;\n    private boolean mStarted;\n    private boolean mWaking;\n    private boolean mFinished;\n    private boolean mCanDoze;\n    private boolean mDozing;\n    private boolean mWindowless;\n    private int mDozeScreenState = Display.STATE_UNKNOWN;\n    private int mDozeScreenBrightness = PowerManager.BRIGHTNESS_DEFAULT;\n\n    private boolean mDebug = false;\n\n    private DreamServiceWrapper mDreamServiceWrapper;\n    private Runnable mDispatchAfterOnAttachedToWindow;\n\n    private final OverlayConnection mOverlayConnection;\n\n    private static class OverlayConnection implements ServiceConnection {\n        // Overlay set during onBind.\n        private IDreamOverlay mOverlay;\n        // A Queue of pending requests to execute on the overlay.\n        private final ArrayDeque<Consumer<IDreamOverlay>> mRequests;\n\n        private boolean mBound;\n\n        OverlayConnection() {\n            mRequests = new ArrayDeque<>();\n        }\n\n        public void bind(Context context, @Nullable ComponentName overlayService,\n                ComponentName dreamService) {\n            if (overlayService == null) {\n                return;\n            }\n\n            final ServiceInfo serviceInfo = fetchServiceInfo(context, dreamService);\n\n            final Intent overlayIntent = new Intent();\n            overlayIntent.setComponent(overlayService);\n            overlayIntent.putExtra(EXTRA_SHOW_COMPLICATIONS,\n                    fetchShouldShowComplications(context, serviceInfo));\n\n            context.bindService(overlayIntent,\n                    this, Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE);\n            mBound = true;\n        }\n\n        public void unbind(Context context) {\n            if (!mBound) {\n                return;\n            }\n\n            context.unbindService(this);\n            mBound = false;\n        }\n\n        public void request(Consumer<IDreamOverlay> request) {\n            mRequests.push(request);\n            evaluate();\n        }\n\n        private void evaluate() {\n            if (mOverlay == null) {\n                return;\n            }\n\n            // Any new requests that arrive during this loop will be processed synchronously after\n            // the loop exits.\n            while (!mRequests.isEmpty()) {\n                final Consumer<IDreamOverlay> request = mRequests.pop();\n                request.accept(mOverlay);\n            }\n        }\n\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            // Store Overlay and execute pending requests.\n            mOverlay = IDreamOverlay.Stub.asInterface(service);\n            evaluate();\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            // Clear Overlay binder to prevent further request processing.\n            mOverlay = null;\n        }\n    }\n\n    private final IDreamOverlayCallback mOverlayCallback = new IDreamOverlayCallback.Stub() {\n        @Override\n        public void onExitRequested() {\n            // Simply finish dream when exit is requested.\n            finish();\n        }\n    };\n\n\n    public DreamService() {\n        mDreamManager = IDreamManager.Stub.asInterface(ServiceManager.getService(DREAM_SERVICE));\n        mOverlayConnection = new OverlayConnection();\n    }\n\n    /**\n     * @hide\n     */\n    public void setDebug(boolean dbg) {\n        mDebug = dbg;\n    }\n\n    // begin Window.Callback methods\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK\n        if (!mInteractive) {\n            if (mDebug) Slog.v(mTag, \"Waking up on keyEvent\");\n            wakeUp();\n            return true;\n        } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {\n            if (mDebug) Slog.v(mTag, \"Waking up on back key\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyShortcutEvent(KeyEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(mTag, \"Waking up on keyShortcutEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyShortcutEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // TODO: create more flexible version of mInteractive that allows clicks\n        // but finish()es on any other kind of activity\n        if (!mInteractive && event.getActionMasked() == MotionEvent.ACTION_UP) {\n            if (mDebug) Slog.v(mTag, \"Waking up on touchEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTouchEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTrackballEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(mTag, \"Waking up on trackballEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTrackballEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchGenericMotionEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(mTag, \"Waking up on genericMotionEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchGenericMotionEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public View onCreatePanelView(int featureId) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onCreatePanelMenu(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onPreparePanel(int featureId, View view, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuOpened(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowAttributesChanged(LayoutParams attrs) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onContentChanged() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowFocusChanged(boolean hasFocus) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onAttachedToWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDetachedFromWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onPanelClosed(int featureId, Menu menu) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested(SearchEvent event) {\n        return onSearchRequested();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested() {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(\n            android.view.ActionMode.Callback callback, int type) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeStarted(ActionMode mode) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeFinished(ActionMode mode) {\n    }\n    // end Window.Callback methods\n\n    // begin public api\n    /**\n     * Retrieves the current {@link android.view.WindowManager} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindowManager()}.\n     *\n     * @return The current window manager, or null if the dream is not started.\n     */\n    public WindowManager getWindowManager() {\n        return mWindow != null ? mWindow.getWindowManager() : null;\n    }\n\n    /**\n     * Retrieves the current {@link android.view.Window} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindow()}.\n     *\n     * @return The current window, or null if the dream is not started.\n     */\n    public Window getWindow() {\n        return mWindow;\n    }\n\n   /**\n     * Inflates a layout resource and set it to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(int)}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param layoutResID Resource ID to be inflated.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(android.view.View)} in an activity,\n     * including using {@link ViewGroup.LayoutParams#MATCH_PARENT} as the layout height and width of the view.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @see #setContentView(int)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(View view) {\n        getWindow().setContentView(view);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to\n     * {@link android.app.Activity#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)}\n     * in an activity.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(int)\n     */\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().setContentView(view, params);\n    }\n\n    /**\n     * Adds a view to the Dream's window, leaving other content views in place.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     */\n    public void addContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().addContentView(view, params);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that\n     * was processed in {@link #onCreate}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return The view if found or null otherwise.\n     * @see View#findViewById(int)\n     * @see DreamService#requireViewById(int)\n     */\n    @Nullable\n    public <T extends View> T findViewById(@IdRes int id) {\n        return getWindow().findViewById(id);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that was processed in\n     * {@link #onCreate}, or throws an IllegalArgumentException if the ID is invalid or there is no\n     * matching view in the hierarchy.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return a view with given ID\n     * @see View#requireViewById(int)\n     * @see DreamService#findViewById(int)\n     */\n    @NonNull\n    public final <T extends View> T requireViewById(@IdRes int id) {\n        T view = findViewById(id);\n        if (view == null) {\n            throw new IllegalArgumentException(\n                    \"ID does not reference a View inside this DreamService\");\n        }\n        return view;\n    }\n\n    /**\n     * Marks this dream as interactive to receive input events.\n     *\n     * <p>Non-interactive dreams (default) will dismiss on the first input event.</p>\n     *\n     * <p>Interactive dreams should call {@link #finish()} to dismiss themselves.</p>\n     *\n     * @param interactive True if this dream will handle input events.\n     */\n    public void setInteractive(boolean interactive) {\n        mInteractive = interactive;\n    }\n\n    /**\n     * Returns whether this dream is interactive. Defaults to false.\n     *\n     * @see #setInteractive(boolean)\n     */\n    public boolean isInteractive() {\n        return mInteractive;\n    }\n\n    /**\n     * Controls {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN}\n     * on the dream's window.\n     *\n     * @param fullscreen If true, the fullscreen flag will be set; else it\n     * will be cleared.\n     */\n    public void setFullscreen(boolean fullscreen) {\n        if (mFullscreen != fullscreen) {\n            mFullscreen = fullscreen;\n            int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;\n            applyWindowFlags(mFullscreen ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether this dream is in fullscreen mode. Defaults to false.\n     *\n     * @see #setFullscreen(boolean)\n     */\n    public boolean isFullscreen() {\n        return mFullscreen;\n    }\n\n    /**\n     * Marks this dream as keeping the screen bright while dreaming.\n     *\n     * @param screenBright True to keep the screen bright while dreaming.\n     */\n    public void setScreenBright(boolean screenBright) {\n        if (mScreenBright != screenBright) {\n            mScreenBright = screenBright;\n            int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;\n            applyWindowFlags(mScreenBright ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether this dream keeps the screen bright while dreaming.\n     * Defaults to false, allowing the screen to dim if necessary.\n     *\n     * @see #setScreenBright(boolean)\n     */\n    public boolean isScreenBright() {\n        return getWindowFlagValue(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, mScreenBright);\n    }\n\n    /**\n     * Marks this dream as windowless. Only available to doze dreams.\n     *\n     * @hide\n     *\n     */\n    public void setWindowless(boolean windowless) {\n        mWindowless = windowless;\n    }\n\n    /**\n     * Returns whether this dream is windowless. Only available to doze dreams.\n     *\n     * @hide\n     */\n    public boolean isWindowless() {\n        return mWindowless;\n    }\n\n    /**\n     * Returns true if this dream is allowed to doze.\n     * <p>\n     * The value returned by this method is only meaningful when the dream has started.\n     * </p>\n     *\n     * @return True if this dream can doze.\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean canDoze() {\n        return mCanDoze;\n    }\n\n    /**\n     * Starts dozing, entering a deep dreamy sleep.\n     * <p>\n     * Dozing enables the system to conserve power while the user is not actively interacting\n     * with the device. While dozing, the display will remain on in a low-power state\n     * and will continue to show its previous contents but the application processor and\n     * other system components will be allowed to suspend when possible.\n     * </p><p>\n     * While the application processor is suspended, the dream may stop executing code\n     * for long periods of time. Prior to being suspended, the dream may schedule periodic\n     * wake-ups to render new content by scheduling an alarm with the {@link AlarmManager}.\n     * The dream may also keep the CPU awake by acquiring a\n     * {@link android.os.PowerManager#PARTIAL_WAKE_LOCK partial wake lock} when necessary.\n     * Note that since the purpose of doze mode is to conserve power (especially when\n     * running on battery), the dream should not wake the CPU very often or keep it\n     * awake for very long.\n     * </p><p>\n     * It is a good idea to call this method some time after the dream's entry animation\n     * has completed and the dream is ready to doze. It is important to completely\n     * finish all of the work needed before dozing since the application processor may\n     * be suspended at any moment once this method is called unless other wake locks\n     * are being held.\n     * </p><p>\n     * Call {@link #stopDozing} or {@link #finish} to stop dozing.\n     * </p>\n     *\n     * @see #stopDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void startDozing() {\n        if (mCanDoze && !mDozing) {\n            mDozing = true;\n            updateDoze();\n        }\n    }\n\n    private void updateDoze() {\n        if (mDreamToken == null) {\n            Slog.w(mTag, \"Updating doze without a dream token.\");\n            return;\n        }\n\n        if (mDozing) {\n            try {\n                mDreamManager.startDozing(mDreamToken, mDozeScreenState, mDozeScreenBrightness);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Stops dozing, returns to active dreaming.\n     * <p>\n     * This method reverses the effect of {@link #startDozing}. From this moment onward,\n     * the application processor will be kept awake as long as the dream is running\n     * or until the dream starts dozing again.\n     * </p>\n     *\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public void stopDozing() {\n        if (mDozing) {\n            mDozing = false;\n            try {\n                mDreamManager.stopDozing(mDreamToken);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Returns true if the dream will allow the system to enter a low-power state while\n     * it is running without actually turning off the screen. Defaults to false,\n     * keeping the application processor awake while the dream is running.\n     *\n     * @return True if the dream is dozing.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean isDozing() {\n        return mDozing;\n    }\n\n    /**\n     * Gets the screen state to use while dozing.\n     *\n     * @return The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @see #setDozeScreenState\n     * @hide For use by system UI components only.\n     */\n    public int getDozeScreenState() {\n        return mDozeScreenState;\n    }\n\n    /**\n     * Sets the screen state to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called. The default value is\n     * {@link Display#STATE_UNKNOWN} which lets the system decide.\n     * The dream may set a different state before starting to doze and may\n     * perform transitions between states while dozing to conserve power and\n     * achieve various effects.\n     * </p><p>\n     * Some devices will have dedicated hardware (\"Sidekick\") to animate\n     * the display content while the CPU sleeps. If the dream and the hardware support\n     * this, {@link Display#STATE_ON_SUSPEND} or {@link Display#STATE_DOZE_SUSPEND}\n     * will switch control to the Sidekick.\n     * </p><p>\n     * If not using Sidekick, it is recommended that the state be set to\n     * {@link Display#STATE_DOZE_SUSPEND} once the dream has completely\n     * finished drawing and before it releases its wakelock\n     * to allow the display hardware to be fully suspended. While suspended,\n     * the display will preserve its on-screen contents.\n     * </p><p>\n     * If the doze suspend state is used, the dream must make sure to set the mode back\n     * to {@link Display#STATE_DOZE} or {@link Display#STATE_ON} before drawing again\n     * since the display updates may be ignored and not seen by the user otherwise.\n     * </p><p>\n     * The set of available display power states and their behavior while dozing is\n     * hardware dependent and may vary across devices. The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param state The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenState(int state) {\n        if (mDozeScreenState != state) {\n            mDozeScreenState = state;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Gets the screen brightness to use while dozing.\n     *\n     * @return The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @see #setDozeScreenBrightness\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)\n    public int getDozeScreenBrightness() {\n        return mDozeScreenBrightness;\n    }\n\n    /**\n     * Sets the screen brightness to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called. The default value is\n     * {@link PowerManager#BRIGHTNESS_DEFAULT} which lets the system decide.\n     * The dream may set a different brightness before starting to doze and may adjust\n     * the brightness while dozing to conserve power and achieve various effects.\n     * </p><p>\n     * Note that dream may specify any brightness in the full 0-255 range, including\n     * values that are less than the minimum value for manual screen brightness\n     * adjustments by the user. In particular, the value may be set to 0 which may\n     * turn off the backlight entirely while still leaving the screen on although\n     * this behavior is device dependent and not guaranteed.\n     * </p><p>\n     * The available range of display brightness values and their behavior while dozing is\n     * hardware dependent and may vary across devices. The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param brightness The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenBrightness(int brightness) {\n        if (brightness != PowerManager.BRIGHTNESS_DEFAULT) {\n            brightness = clampAbsoluteBrightness(brightness);\n        }\n        if (mDozeScreenBrightness != brightness) {\n            mDozeScreenBrightness = brightness;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Called when this Dream is constructed.\n     */\n    @Override\n    public void onCreate() {\n        if (mDebug) Slog.v(mTag, \"onCreate()\");\n        super.onCreate();\n    }\n\n    /**\n     * Called when the dream's window has been created and is visible and animation may now begin.\n     */\n    public void onDreamingStarted() {\n        if (mDebug) Slog.v(mTag, \"onDreamingStarted()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when this Dream is stopped, either by external request or by calling finish(),\n     * before the window has been removed.\n     */\n    public void onDreamingStopped() {\n        if (mDebug) Slog.v(mTag, \"onDreamingStopped()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when the dream is being asked to stop itself and wake.\n     * <p>\n     * The default implementation simply calls {@link #finish} which ends the dream\n     * immediately. Subclasses may override this function to perform a smooth exit\n     * transition then call {@link #finish} afterwards.\n     * </p><p>\n     * Note that the dream will only be given a short period of time (currently about\n     * five seconds) to wake up. If the dream does not finish itself in a timely manner\n     * then the system will forcibly finish it once the time allowance is up.\n     * </p>\n     */\n    public void onWakeUp() {\n        finish();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public final IBinder onBind(Intent intent) {\n        if (mDebug) Slog.v(mTag, \"onBind() intent = \" + intent);\n        mDreamServiceWrapper = new DreamServiceWrapper();\n\n        // Connect to the overlay service if present.\n        if (!mWindowless) {\n            mOverlayConnection.bind(\n                    /* context= */ this,\n                    intent.getParcelableExtra(EXTRA_DREAM_OVERLAY_COMPONENT),\n                    new ComponentName(this, getClass()));\n        }\n\n        return mDreamServiceWrapper;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        // We must unbind from any overlay connection if we are unbound before finishing.\n        mOverlayConnection.unbind(this);\n\n        return super.onUnbind(intent);\n    }\n\n    /**\n     * Stops the dream and detaches from the window.\n     * <p>\n     * When the dream ends, the system will be allowed to go to sleep fully unless there\n     * is a reason for it to be awake such as recent user activity or wake locks being held.\n     * </p>\n     */\n    public final void finish() {\n        if (mDebug) Slog.v(mTag, \"finish(): mFinished=\" + mFinished);\n\n        Activity activity = mActivity;\n        if (activity != null) {\n            if (!activity.isFinishing()) {\n                // In case the activity is not finished yet, do it now.\n                activity.finishAndRemoveTask();\n            }\n            return;\n        }\n\n        if (mFinished) {\n            return;\n        }\n        mFinished = true;\n\n        mOverlayConnection.unbind(this);\n\n        if (mDreamToken == null) {\n            Slog.w(mTag, \"Finish was called before the dream was attached.\");\n            stopSelf();\n            return;\n        }\n\n        try {\n            // finishSelf will unbind the dream controller from the dream service. This will\n            // trigger DreamService.this.onDestroy and DreamService.this will die.\n            mDreamManager.finishSelf(mDreamToken, true /*immediate*/);\n        } catch (RemoteException ex) {\n            // system server died\n        }\n    }\n\n    /**\n     * Wakes the dream up gently.\n     * <p>\n     * Calls {@link #onWakeUp} to give the dream a chance to perform an exit transition.\n     * When the transition is over, the dream should call {@link #finish}.\n     * </p>\n     */\n    public final void wakeUp() {\n        wakeUp(false);\n    }\n\n    private void wakeUp(boolean fromSystem) {\n        if (mDebug) {\n            Slog.v(mTag, \"wakeUp(): fromSystem=\" + fromSystem + \", mWaking=\" + mWaking\n                    + \", mFinished=\" + mFinished);\n        }\n\n        if (!mWaking && !mFinished) {\n            mWaking = true;\n\n            if (mActivity != null) {\n                // During wake up the activity should be translucent to allow the application\n                // underneath to start drawing. Normally, the WM animation system takes care of\n                // this, but here we give the dream application some time to perform a custom exit\n                // animation. If it uses a view animation, the WM doesn't know about it and can't\n                // make the activity translucent in the normal way. Therefore, here we ensure that\n                // the activity is translucent during wake up regardless of what animation is used\n                // in onWakeUp().\n                mActivity.convertToTranslucent(null, null);\n            }\n\n            // As a minor optimization, invoke the callback first in case it simply\n            // calls finish() immediately so there wouldn't be much point in telling\n            // the system that we are finishing the dream gently.\n            onWakeUp();\n\n            // Now tell the system we are waking gently, unless we already told\n            // it we were finishing immediately.\n            if (!fromSystem && !mFinished) {\n                if (mActivity == null) {\n                    Slog.w(mTag, \"WakeUp was called before the dream was attached.\");\n                } else {\n                    try {\n                        mDreamManager.finishSelf(mDreamToken, false /*immediate*/);\n                    } catch (RemoteException ex) {\n                        // system server died\n                    }\n                }\n            }\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDestroy() {\n        if (mDebug) Slog.v(mTag, \"onDestroy()\");\n        // hook for subclasses\n\n        // Just in case destroy came in before detach, let's take care of that now\n        detach();\n\n        super.onDestroy();\n    }\n\n    // end public api\n\n    /**\n     * Parses and returns metadata of the dream service indicated by the service info. Returns null\n     * if metadata cannot be found.\n     *\n     * Note that {@link ServiceInfo} must be fetched with {@link PackageManager#GET_META_DATA} flag.\n     *\n     * @hide\n     */\n    @Nullable\n    @TestApi\n    public static DreamMetadata getDreamMetadata(@NonNull Context context,\n            @Nullable ServiceInfo serviceInfo) {\n        if (serviceInfo == null) return null;\n\n        final PackageManager pm = context.getPackageManager();\n\n        try (TypedArray rawMetadata = readMetadata(pm, serviceInfo)) {\n            if (rawMetadata == null) return null;\n            return new DreamMetadata(\n                    convertToComponentName(rawMetadata.getString(\n                            com.android.internal.R.styleable.Dream_settingsActivity), serviceInfo),\n                    rawMetadata.getDrawable(\n                            com.android.internal.R.styleable.Dream_previewImage),\n                    rawMetadata.getBoolean(R.styleable.Dream_showClockAndComplications,\n                            DEFAULT_SHOW_COMPLICATIONS));\n        }\n    }\n\n    /**\n     * Returns the raw XML metadata fetched from the {@link ServiceInfo}.\n     *\n     * Returns <code>null</code> if the {@link ServiceInfo} doesn't contain valid dream metadata.\n     */\n    @Nullable\n    private static TypedArray readMetadata(PackageManager pm, ServiceInfo serviceInfo) {\n        if (serviceInfo == null || serviceInfo.metaData == null) {\n            return null;\n        }\n\n        try (XmlResourceParser parser =\n                     serviceInfo.loadXmlMetaData(pm, DreamService.DREAM_META_DATA)) {\n            if (parser == null) {\n                if (DEBUG) Log.w(TAG, \"No \" + DreamService.DREAM_META_DATA + \" metadata\");\n                return null;\n            }\n\n            final AttributeSet attrs = Xml.asAttributeSet(parser);\n            while (true) {\n                final int type = parser.next();\n                if (type == XmlPullParser.END_DOCUMENT || type == XmlPullParser.START_TAG) {\n                    break;\n                }\n            }\n\n            if (!parser.getName().equals(DREAM_META_DATA_ROOT_TAG)) {\n                if (DEBUG) {\n                    Log.w(TAG, \"Metadata does not start with \" + DREAM_META_DATA_ROOT_TAG + \" tag\");\n                }\n                return null;\n            }\n\n            return pm.getResourcesForApplication(serviceInfo.applicationInfo).obtainAttributes(\n                    attrs, com.android.internal.R.styleable.Dream);\n        } catch (PackageManager.NameNotFoundException | IOException | XmlPullParserException e) {\n            if (DEBUG) Log.e(TAG, \"Error parsing: \" + serviceInfo.packageName, e);\n            return null;\n        }\n    }\n\n    @Nullable\n    private static ComponentName convertToComponentName(@Nullable String flattenedString,\n            ServiceInfo serviceInfo) {\n        if (flattenedString == null) {\n            return null;\n        }\n\n        if (!flattenedString.contains(\"/\")) {\n            return new ComponentName(serviceInfo.packageName, flattenedString);\n        }\n\n        // Ensure that the component is from the same package as the dream service. If not,\n        // treat the component as invalid and return null instead.\n        final ComponentName cn = ComponentName.unflattenFromString(flattenedString);\n        if (cn == null) return null;\n        if (!cn.getPackageName().equals(serviceInfo.packageName)) {\n            Log.w(TAG,\n                    \"Inconsistent package name in component: \" + cn.getPackageName()\n                            + \", should be: \" + serviceInfo.packageName);\n            return null;\n        }\n        return cn;\n    }\n\n    /**\n     * Called by DreamController.stopDream() when the Dream is about to be unbound and destroyed.\n     *\n     * Must run on mHandler.\n     */\n    private void detach() {\n        if (mStarted) {\n            if (mDebug) Slog.v(mTag, \"detach(): Calling onDreamingStopped()\");\n            mStarted = false;\n            onDreamingStopped();\n        }\n\n        if (mActivity != null && !mActivity.isFinishing()) {\n            mActivity.finishAndRemoveTask();\n        } else {\n            finish();\n        }\n\n        mDreamToken = null;\n        mCanDoze = false;\n    }\n\n    /**\n     * Called when the Dream is ready to be shown.\n     *\n     * Must run on mHandler.\n     *\n     * @param dreamToken Token for this dream service.\n     * @param started A callback that will be invoked once onDreamingStarted has completed.\n     */\n    private void attach(IBinder dreamToken, boolean canDoze, IRemoteCallback started) {\n        if (mDreamToken != null) {\n            Slog.e(mTag, \"attach() called when dream with token=\" + mDreamToken\n                    + \" already attached\");\n            return;\n        }\n        if (mFinished || mWaking) {\n            Slog.w(mTag, \"attach() called after dream already finished\");\n            try {\n                mDreamManager.finishSelf(dreamToken, true /*immediate*/);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n            return;\n        }\n\n        mDreamToken = dreamToken;\n        mCanDoze = canDoze;\n        if (mWindowless && !mCanDoze) {\n            throw new IllegalStateException(\"Only doze dreams can be windowless\");\n        }\n\n        mDispatchAfterOnAttachedToWindow = () -> {\n            if (mWindow != null || mWindowless) {\n                mStarted = true;\n                try {\n                    onDreamingStarted();\n                } finally {\n                    try {\n                        started.sendResult(null);\n                    } catch (RemoteException e) {\n                        throw e.rethrowFromSystemServer();\n                    }\n                }\n            }\n        };\n\n        // We need to defer calling onDreamingStarted until after the activity is created.\n        // If the dream is windowless, we can call it immediately. Otherwise, we wait\n        // for the DreamActivity to report onActivityCreated via\n        // DreamServiceWrapper.onActivityCreated.\n        if (!mWindowless) {\n            Intent i = new Intent(this, DreamActivity.class);\n            i.setPackage(getApplicationContext().getPackageName());\n            i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            i.putExtra(DreamActivity.EXTRA_CALLBACK, new DreamActivityCallback(mDreamToken));\n            final ServiceInfo serviceInfo = fetchServiceInfo(this,\n                    new ComponentName(this, getClass()));\n            i.putExtra(DreamActivity.EXTRA_DREAM_TITLE, fetchDreamLabel(this, serviceInfo));\n\n            try {\n                if (!ActivityTaskManager.getService().startDreamActivity(i)) {\n                    detach();\n                }\n            } catch (RemoteException e) {\n                Log.w(mTag, \"Could not connect to activity task manager to start dream activity\");\n                e.rethrowFromSystemServer();\n            }\n        } else {\n            mDispatchAfterOnAttachedToWindow.run();\n        }\n    }\n\n    private void onWindowCreated(Window w) {\n        mWindow = w;\n        mWindow.setCallback(this);\n        mWindow.requestFeature(Window.FEATURE_NO_TITLE);\n\n        WindowManager.LayoutParams lp = mWindow.getAttributes();\n        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN\n                    | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR\n                    | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED\n                    | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD\n                    | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON\n                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED\n                    | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0)\n                    | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0)\n                    );\n        lp.layoutInDisplayCutoutMode =\n                WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS;\n        mWindow.setAttributes(lp);\n        // Workaround: Currently low-profile and in-window system bar backgrounds don't go\n        // along well. Dreams usually don't need such bars anyways, so disable them by default.\n        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n\n        // Hide all insets when the dream is showing\n        mWindow.getDecorView().getWindowInsetsController().hide(WindowInsets.Type.systemBars());\n        mWindow.setDecorFitsSystemWindows(false);\n\n        mWindow.getDecorView().addOnAttachStateChangeListener(\n                new View.OnAttachStateChangeListener() {\n                    @Override\n                    public void onViewAttachedToWindow(View v) {\n                        mDispatchAfterOnAttachedToWindow.run();\n\n                        // Request the DreamOverlay be told to dream with dream's window parameters\n                        // once the window has been attached.\n                        mOverlayConnection.request(overlay -> {\n                            try {\n                                overlay.startDream(mWindow.getAttributes(), mOverlayCallback);\n                            } catch (RemoteException e) {\n                                Log.e(mTag, \"could not send window attributes:\" + e);\n                            }\n                        });\n                    }\n\n                    @Override\n                    public void onViewDetachedFromWindow(View v) {\n                        if (mActivity == null || !mActivity.isChangingConfigurations()) {\n                            // Only stop the dream if the view is not detached by relaunching\n                            // activity for configuration changes. It is important to also clear\n                            // the window reference in order to fully release the DreamActivity.\n                            mWindow = null;\n                            mActivity = null;\n                            finish();\n                        }\n                    }\n                });\n    }\n\n    private boolean getWindowFlagValue(int flag, boolean defaultValue) {\n        return mWindow == null ? defaultValue : (mWindow.getAttributes().flags & flag) != 0;\n    }\n\n    private void applyWindowFlags(int flags, int mask) {\n        if (mWindow != null) {\n            WindowManager.LayoutParams lp = mWindow.getAttributes();\n            lp.flags = applyFlags(lp.flags, flags, mask);\n            mWindow.setAttributes(lp);\n            mWindow.getWindowManager().updateViewLayout(mWindow.getDecorView(), lp);\n        }\n    }\n\n    private int applyFlags(int oldFlags, int flags, int mask) {\n        return (oldFlags&~mask) | (flags&mask);\n    }\n\n    /**\n     * Fetches metadata of the dream indicated by the {@link ComponentName}, and returns whether\n     * the dream should show complications on the overlay. If not defined, returns\n     * {@link DreamService#DEFAULT_SHOW_COMPLICATIONS}.\n     */\n    private static boolean fetchShouldShowComplications(Context context,\n            @Nullable ServiceInfo serviceInfo) {\n        final DreamMetadata metadata = getDreamMetadata(context, serviceInfo);\n        if (metadata != null) {\n            return metadata.showComplications;\n        }\n        return DEFAULT_SHOW_COMPLICATIONS;\n    }\n\n    @Nullable\n    private static CharSequence fetchDreamLabel(Context context,\n            @Nullable ServiceInfo serviceInfo) {\n        if (serviceInfo == null) return null;\n        final PackageManager pm = context.getPackageManager();\n        return serviceInfo.loadLabel(pm);\n    }\n\n    @Nullable\n    private static ServiceInfo fetchServiceInfo(Context context, ComponentName componentName) {\n        final PackageManager pm = context.getPackageManager();\n\n        try {\n            return pm.getServiceInfo(componentName,\n                    PackageManager.ComponentInfoFlags.of(PackageManager.GET_META_DATA));\n        } catch (PackageManager.NameNotFoundException e) {\n            if (DEBUG) Log.w(TAG, \"cannot find component \" + componentName.flattenToShortString());\n        }\n        return null;\n    }\n\n    @Override\n    protected void dump(final FileDescriptor fd, PrintWriter pw, final String[] args) {\n        DumpUtils.dumpAsync(mHandler, (pw1, prefix) -> dumpOnHandler(fd, pw1, args), pw, \"\", 1000);\n    }\n\n    /** @hide */\n    protected void dumpOnHandler(FileDescriptor fd, PrintWriter pw, String[] args) {\n        pw.print(mTag + \": \");\n        if (mFinished) {\n            pw.println(\"stopped\");\n        } else {\n            pw.println(\"running (dreamToken=\" + mDreamToken + \")\");\n        }\n        pw.println(\"  window: \" + mWindow);\n        pw.print(\"  flags:\");\n        if (isInteractive()) pw.print(\" interactive\");\n        if (isFullscreen()) pw.print(\" fullscreen\");\n        if (isScreenBright()) pw.print(\" bright\");\n        if (isWindowless()) pw.print(\" windowless\");\n        if (isDozing()) pw.print(\" dozing\");\n        else if (canDoze()) pw.print(\" candoze\");\n        pw.println();\n        if (canDoze()) {\n            pw.println(\"  doze screen state: \" + Display.stateToString(mDozeScreenState));\n            pw.println(\"  doze screen brightness: \" + mDozeScreenBrightness);\n        }\n    }\n\n    private static int clampAbsoluteBrightness(int value) {\n        return MathUtils.constrain(value, PowerManager.BRIGHTNESS_OFF, PowerManager.BRIGHTNESS_ON);\n    }\n\n    /**\n     * The DreamServiceWrapper is used as a gateway to the system_server, where DreamController\n     * uses it to control the DreamService. It is also used to receive callbacks from the\n     * DreamActivity.\n     */\n    final class DreamServiceWrapper extends IDreamService.Stub {\n        @Override\n        public void attach(final IBinder dreamToken, final boolean canDoze,\n                IRemoteCallback started) {\n            mHandler.post(() -> DreamService.this.attach(dreamToken, canDoze, started));\n        }\n\n        @Override\n        public void detach() {\n            mHandler.post(DreamService.this::detach);\n        }\n\n        @Override\n        public void wakeUp() {\n            mHandler.post(() -> DreamService.this.wakeUp(true /*fromSystem*/));\n        }\n    }\n\n    /** @hide */\n    final class DreamActivityCallback extends Binder {\n        private final IBinder mActivityDreamToken;\n\n        DreamActivityCallback(IBinder token) {\n            mActivityDreamToken = token;\n        }\n\n        void onActivityCreated(DreamActivity activity) {\n            if (mActivityDreamToken != mDreamToken || mFinished) {\n                Slog.d(TAG, \"DreamActivity was created after the dream was finished or \"\n                        + \"a new dream started, finishing DreamActivity\");\n                if (!activity.isFinishing()) {\n                    activity.finishAndRemoveTask();\n                }\n                return;\n            }\n            if (mActivity != null) {\n                Slog.w(TAG, \"A DreamActivity has already been started, \"\n                        + \"finishing latest DreamActivity\");\n                if (!activity.isFinishing()) {\n                    activity.finishAndRemoveTask();\n                }\n                return;\n            }\n\n            mActivity = activity;\n            onWindowCreated(activity.getWindow());\n        }\n    }\n\n    /**\n     * Represents metadata defined in {@link android.R.styleable#Dream &lt;dream&gt;}.\n     *\n     * @hide\n     */\n    @TestApi\n    public static final class DreamMetadata {\n        @Nullable\n        public final ComponentName settingsActivity;\n\n        @Nullable\n        public final Drawable previewImage;\n\n        @NonNull\n        public final boolean showComplications;\n\n        DreamMetadata(ComponentName settingsActivity, Drawable previewImage,\n                boolean showComplications) {\n            this.settingsActivity = settingsActivity;\n            this.previewImage = previewImage;\n            this.showComplications = showComplications;\n        }\n    }\n}\n```",
            "upstream_file_tokens": {
              "openai": 11711,
              "general": {
                "word_based": 5538,
                "char_based": 13777
              },
              "gemini": 13587
            },
            "downstream_file_content": "```java\n/**\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage android.service.dreams;\n\nimport android.annotation.IdRes;\nimport android.annotation.LayoutRes;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.SdkConstant;\nimport android.annotation.SdkConstant.SdkConstantType;\nimport android.annotation.TestApi;\nimport android.app.Activity;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.Service;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.Intent;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.IRemoteCallback;\nimport android.os.Looper;\nimport android.os.PowerManager;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.util.Log;\nimport android.util.MathUtils;\nimport android.util.Slog;\nimport android.view.ActionMode;\nimport android.view.Display;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SearchEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.WindowManager.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.DumpUtils.Dump;\n\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\n\n/**\n * Extend this class to implement a custom dream (available to the user as a \"Daydream\").\n *\n * <p>Dreams are interactive screensavers launched when a charging device is idle, or docked in a\n * desk dock. Dreams provide another modality for apps to express themselves, tailored for\n * an exhibition/lean-back experience.</p>\n *\n * <p>The {@code DreamService} lifecycle is as follows:</p>\n * <ol>\n *   <li>{@link #onAttachedToWindow}\n *     <p>Use this for initial setup, such as calling {@link #setContentView setContentView()}.</li>\n *   <li>{@link #onDreamingStarted}\n *     <p>Your dream has started, so you should begin animations or other behaviors here.</li>\n *   <li>{@link #onDreamingStopped}\n *     <p>Use this to stop the things you started in {@link #onDreamingStarted}.</li>\n *   <li>{@link #onDetachedFromWindow}\n *     <p>Use this to dismantle resources (for example, detach from handlers\n *        and listeners).</li>\n * </ol>\n *\n * <p>In addition, onCreate and onDestroy (from the Service interface) will also be called, but\n * initialization and teardown should be done by overriding the hooks above.</p>\n *\n * <p>To be available to the system, your {@code DreamService} should be declared in the\n * manifest as follows:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\" >\n *\n *     &lt;intent-filter>\n *         &lt;action android:name=\"android.service.dreams.DreamService\" />\n *         &lt;category android:name=\"android.intent.category.DEFAULT\" />\n *     &lt;/intent-filter>\n *\n *     &lt;!-- Point to additional information for this dream (optional) -->\n *     &lt;meta-data\n *         android:name=\"android.service.dream\"\n *         android:resource=\"@xml/my_dream\" />\n * &lt;/service>\n * </pre>\n *\n * <p>If specified with the {@code <meta-data>} element,\n * additional information for the dream is defined using the\n * {@link android.R.styleable#Dream &lt;dream&gt;} element in a separate XML file.\n * Currently, the only addtional\n * information you can provide is for a settings activity that allows the user to configure\n * the dream behavior. For example:</p>\n * <p class=\"code-caption\">res/xml/my_dream.xml</p>\n * <pre>\n * &lt;dream xmlns:android=\"http://schemas.android.com/apk/res/android\"\n *     android:settingsActivity=\"com.example.app/.MyDreamSettingsActivity\" />\n * </pre>\n * <p>This makes a Settings button available alongside your dream's listing in the\n * system settings, which when pressed opens the specified activity.</p>\n *\n *\n * <p>To specify your dream layout, call {@link #setContentView}, typically during the\n * {@link #onAttachedToWindow} callback. For example:</p>\n * <pre>\n * public class MyDream extends DreamService {\n *\n *     &#64;Override\n *     public void onAttachedToWindow() {\n *         super.onAttachedToWindow();\n *\n *         // Exit dream upon user touch\n *         setInteractive(false);\n *         // Hide system UI\n *         setFullscreen(true);\n *         // Set the dream layout\n *         setContentView(R.layout.dream);\n *     }\n * }\n * </pre>\n *\n * <p>When targeting api level 21 and above, you must declare the service in your manifest file\n * with the {@link android.Manifest.permission#BIND_DREAM_SERVICE} permission. For example:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\"\n *     android:permission=\"android.permission.BIND_DREAM_SERVICE\">\n *   &lt;intent-filter>\n *     &lt;action android:name=\u201dandroid.service.dreams.DreamService\u201d />\n *     &lt;category android:name=\u201dandroid.intent.category.DEFAULT\u201d />\n *   &lt;/intent-filter>\n * &lt;/service>\n * </pre>\n */\npublic class DreamService extends Service implements Window.Callback {\n    private final String TAG = DreamService.class.getSimpleName() + \"[\" + getClass().getSimpleName() + \"]\";\n\n    /**\n     * The name of the dream manager service.\n     * @hide\n     */\n    public static final String DREAM_SERVICE = \"dreams\";\n\n    /**\n     * The {@link Intent} that must be declared as handled by the service.\n     */\n    @SdkConstant(SdkConstantType.SERVICE_ACTION)\n    public static final String SERVICE_INTERFACE =\n            \"android.service.dreams.DreamService\";\n\n    /**\n     * Name under which a Dream publishes information about itself.\n     * This meta-data must reference an XML resource containing\n     * a <code>&lt;{@link android.R.styleable#Dream dream}&gt;</code>\n     * tag.\n     */\n    public static final String DREAM_META_DATA = \"android.service.dream\";\n\n    private final IDreamManager mDreamManager;\n    private final Handler mHandler = new Handler(Looper.getMainLooper());\n    private IBinder mDreamToken;\n    private Window mWindow;\n    private Activity mActivity;\n    private boolean mInteractive;\n    private boolean mFullscreen;\n    private boolean mScreenBright = true;\n    private boolean mStarted;\n    private boolean mWaking;\n    private boolean mFinished;\n    private boolean mCanDoze;\n    private boolean mDozing;\n    private boolean mWindowless;\n    private int mDozeScreenState = Display.STATE_UNKNOWN;\n    private int mDozeScreenBrightness = PowerManager.BRIGHTNESS_DEFAULT;\n\n    private boolean mDebug = false;\n\n    private DreamServiceWrapper mDreamServiceWrapper;\n    private Runnable mDispatchAfterOnAttachedToWindow;\n\n    public DreamService() {\n        mDreamManager = IDreamManager.Stub.asInterface(ServiceManager.getService(DREAM_SERVICE));\n    }\n\n    /**\n     * @hide\n     */\n    public void setDebug(boolean dbg) {\n        mDebug = dbg;\n    }\n\n    // begin Window.Callback methods\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyEvent\");\n            wakeUp();\n            return true;\n        } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {\n            if (mDebug) Slog.v(TAG, \"Waking up on back key\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyShortcutEvent(KeyEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyShortcutEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyShortcutEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // TODO: create more flexible version of mInteractive that allows clicks\n        // but finish()es on any other kind of activity\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on touchEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTouchEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTrackballEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on trackballEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTrackballEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchGenericMotionEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on genericMotionEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchGenericMotionEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public View onCreatePanelView(int featureId) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onCreatePanelMenu(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onPreparePanel(int featureId, View view, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuOpened(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowAttributesChanged(LayoutParams attrs) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onContentChanged() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowFocusChanged(boolean hasFocus) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onAttachedToWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDetachedFromWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onPanelClosed(int featureId, Menu menu) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested(SearchEvent event) {\n        return onSearchRequested();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested() {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(\n            android.view.ActionMode.Callback callback, int type) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeStarted(ActionMode mode) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeFinished(ActionMode mode) {\n    }\n    // end Window.Callback methods\n\n    // begin public api\n    /**\n     * Retrieves the current {@link android.view.WindowManager} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindowManager()}.\n     *\n     * @return The current window manager, or null if the dream is not started.\n     */\n    public WindowManager getWindowManager() {\n        return mWindow != null ? mWindow.getWindowManager() : null;\n    }\n\n    /**\n     * Retrieves the current {@link android.view.Window} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindow()}.\n     *\n     * @return The current window, or null if the dream is not started.\n     */\n    public Window getWindow() {\n        return mWindow;\n    }\n\n   /**\n     * Inflates a layout resource and set it to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(int)}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param layoutResID Resource ID to be inflated.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(android.view.View)} in an activity,\n     * including using {@link ViewGroup.LayoutParams#MATCH_PARENT} as the layout height and width of the view.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @see #setContentView(int)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(View view) {\n        getWindow().setContentView(view);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to\n     * {@link android.app.Activity#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)}\n     * in an activity.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(int)\n     */\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().setContentView(view, params);\n    }\n\n    /**\n     * Adds a view to the Dream's window, leaving other content views in place.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     */\n    public void addContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().addContentView(view, params);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that\n     * was processed in {@link #onCreate}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return The view if found or null otherwise.\n     * @see View#findViewById(int)\n     * @see DreamService#requireViewById(int)\n     */\n    @Nullable\n    public <T extends View> T findViewById(@IdRes int id) {\n        return getWindow().findViewById(id);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that was processed in\n     * {@link #onCreate}, or throws an IllegalArgumentException if the ID is invalid or there is no\n     * matching view in the hierarchy.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return a view with given ID\n     * @see View#requireViewById(int)\n     * @see DreamService#findViewById(int)\n     */\n    @NonNull\n    public final <T extends View> T requireViewById(@IdRes int id) {\n        T view = findViewById(id);\n        if (view == null) {\n            throw new IllegalArgumentException(\n                    \"ID does not reference a View inside this DreamService\");\n        }\n        return view;\n    }\n\n    /**\n     * Marks this dream as interactive to receive input events.\n     *\n     * <p>Non-interactive dreams (default) will dismiss on the first input event.</p>\n     *\n     * <p>Interactive dreams should call {@link #finish()} to dismiss themselves.</p>\n     *\n     * @param interactive True if this dream will handle input events.\n     */\n    public void setInteractive(boolean interactive) {\n        mInteractive = interactive;\n    }\n\n    /**\n     * Returns whether or not this dream is interactive.  Defaults to false.\n     *\n     * @see #setInteractive(boolean)\n     */\n    public boolean isInteractive() {\n        return mInteractive;\n    }\n\n    /**\n     * Controls {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN}\n     * on the dream's window.\n     *\n     * @param fullscreen If true, the fullscreen flag will be set; else it\n     * will be cleared.\n     */\n    public void setFullscreen(boolean fullscreen) {\n        if (mFullscreen != fullscreen) {\n            mFullscreen = fullscreen;\n            int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;\n            applyWindowFlags(mFullscreen ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream is in fullscreen mode. Defaults to false.\n     *\n     * @see #setFullscreen(boolean)\n     */\n    public boolean isFullscreen() {\n        return mFullscreen;\n    }\n\n    /**\n     * Marks this dream as keeping the screen bright while dreaming.\n     *\n     * @param screenBright True to keep the screen bright while dreaming.\n     */\n    public void setScreenBright(boolean screenBright) {\n        if (mScreenBright != screenBright) {\n            mScreenBright = screenBright;\n            int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;\n            applyWindowFlags(mScreenBright ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream keeps the screen bright while dreaming.\n     * Defaults to false, allowing the screen to dim if necessary.\n     *\n     * @see #setScreenBright(boolean)\n     */\n    public boolean isScreenBright() {\n        return getWindowFlagValue(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, mScreenBright);\n    }\n\n    /**\n     * Marks this dream as windowless.  Only available to doze dreams.\n     *\n     * @hide\n     *\n     */\n    public void setWindowless(boolean windowless) {\n        mWindowless = windowless;\n    }\n\n    /**\n     * Returns whether or not this dream is windowless.  Only available to doze dreams.\n     *\n     * @hide\n     */\n    public boolean isWindowless() {\n        return mWindowless;\n    }\n\n    /**\n     * Returns true if this dream is allowed to doze.\n     * <p>\n     * The value returned by this method is only meaningful when the dream has started.\n     * </p>\n     *\n     * @return True if this dream can doze.\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean canDoze() {\n        return mCanDoze;\n    }\n\n    /**\n     * Starts dozing, entering a deep dreamy sleep.\n     * <p>\n     * Dozing enables the system to conserve power while the user is not actively interacting\n     * with the device.  While dozing, the display will remain on in a low-power state\n     * and will continue to show its previous contents but the application processor and\n     * other system components will be allowed to suspend when possible.\n     * </p><p>\n     * While the application processor is suspended, the dream may stop executing code\n     * for long periods of time.  Prior to being suspended, the dream may schedule periodic\n     * wake-ups to render new content by scheduling an alarm with the {@link AlarmManager}.\n     * The dream may also keep the CPU awake by acquiring a\n     * {@link android.os.PowerManager#PARTIAL_WAKE_LOCK partial wake lock} when necessary.\n     * Note that since the purpose of doze mode is to conserve power (especially when\n     * running on battery), the dream should not wake the CPU very often or keep it\n     * awake for very long.\n     * </p><p>\n     * It is a good idea to call this method some time after the dream's entry animation\n     * has completed and the dream is ready to doze.  It is important to completely\n     * finish all of the work needed before dozing since the application processor may\n     * be suspended at any moment once this method is called unless other wake locks\n     * are being held.\n     * </p><p>\n     * Call {@link #stopDozing} or {@link #finish} to stop dozing.\n     * </p>\n     *\n     * @see #stopDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void startDozing() {\n        if (mCanDoze && !mDozing) {\n            mDozing = true;\n            updateDoze();\n        }\n    }\n\n    private void updateDoze() {\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Updating doze without a dream token.\");\n            return;\n        }\n\n        if (mDozing) {\n            try {\n                mDreamManager.startDozing(mDreamToken, mDozeScreenState, mDozeScreenBrightness);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Stops dozing, returns to active dreaming.\n     * <p>\n     * This method reverses the effect of {@link #startDozing}.  From this moment onward,\n     * the application processor will be kept awake as long as the dream is running\n     * or until the dream starts dozing again.\n     * </p>\n     *\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public void stopDozing() {\n        if (mDozing) {\n            mDozing = false;\n            try {\n                mDreamManager.stopDozing(mDreamToken);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Returns true if the dream will allow the system to enter a low-power state while\n     * it is running without actually turning off the screen.  Defaults to false,\n     * keeping the application processor awake while the dream is running.\n     *\n     * @return True if the dream is dozing.\n     *\n     * @see #setDozing(boolean)\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean isDozing() {\n        return mDozing;\n    }\n\n    /**\n     * Gets the screen state to use while dozing.\n     *\n     * @return The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @see #setDozeScreenState\n     * @hide For use by system UI components only.\n     */\n    public int getDozeScreenState() {\n        return mDozeScreenState;\n    }\n\n    /**\n     * Sets the screen state to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link Display#STATE_UNKNOWN} which lets the system decide.\n     * The dream may set a different state before starting to doze and may\n     * perform transitions between states while dozing to conserve power and\n     * achieve various effects.\n     * </p><p>\n     * Some devices will have dedicated hardware (\"Sidekick\") to animate\n     * the display content while the CPU sleeps. If the dream and the hardware support\n     * this, {@link Display#STATE_ON_SUSPEND} or {@link Display#STATE_DOZE_SUSPEND}\n     * will switch control to the Sidekick.\n     * </p><p>\n     * If not using Sidekick, it is recommended that the state be set to\n     * {@link Display#STATE_DOZE_SUSPEND} once the dream has completely\n     * finished drawing and before it releases its wakelock\n     * to allow the display hardware to be fully suspended.  While suspended,\n     * the display will preserve its on-screen contents.\n     * </p><p>\n     * If the doze suspend state is used, the dream must make sure to set the mode back\n     * to {@link Display#STATE_DOZE} or {@link Display#STATE_ON} before drawing again\n     * since the display updates may be ignored and not seen by the user otherwise.\n     * </p><p>\n     * The set of available display power states and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param state The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenState(int state) {\n        if (mDozeScreenState != state) {\n            mDozeScreenState = state;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Gets the screen brightness to use while dozing.\n     *\n     * @return The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @see #setDozeScreenBrightness\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public int getDozeScreenBrightness() {\n        return mDozeScreenBrightness;\n    }\n\n    /**\n     * Sets the screen brightness to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link PowerManager#BRIGHTNESS_DEFAULT} which lets the system decide.\n     * The dream may set a different brightness before starting to doze and may adjust\n     * the brightness while dozing to conserve power and achieve various effects.\n     * </p><p>\n     * Note that dream may specify any brightness in the full 0-255 range, including\n     * values that are less than the minimum value for manual screen brightness\n     * adjustments by the user.  In particular, the value may be set to 0 which may\n     * turn off the backlight entirely while still leaving the screen on although\n     * this behavior is device dependent and not guaranteed.\n     * </p><p>\n     * The available range of display brightness values and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param brightness The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenBrightness(int brightness) {\n        if (brightness != PowerManager.BRIGHTNESS_DEFAULT) {\n            brightness = clampAbsoluteBrightness(brightness);\n        }\n        if (mDozeScreenBrightness != brightness) {\n            mDozeScreenBrightness = brightness;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Called when this Dream is constructed.\n     */\n    @Override\n    public void onCreate() {\n        if (mDebug) Slog.v(TAG, \"onCreate()\");\n        super.onCreate();\n    }\n\n    /**\n     * Called when the dream's window has been created and is visible and animation may now begin.\n     */\n    public void onDreamingStarted() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStarted()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when this Dream is stopped, either by external request or by calling finish(),\n     * before the window has been removed.\n     */\n    public void onDreamingStopped() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStopped()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when the dream is being asked to stop itself and wake.\n     * <p>\n     * The default implementation simply calls {@link #finish} which ends the dream\n     * immediately.  Subclasses may override this function to perform a smooth exit\n     * transition then call {@link #finish} afterwards.\n     * </p><p>\n     * Note that the dream will only be given a short period of time (currently about\n     * five seconds) to wake up.  If the dream does not finish itself in a timely manner\n     * then the system will forcibly finish it once the time allowance is up.\n     * </p>\n     */\n    public void onWakeUp() {\n        finish();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public final IBinder onBind(Intent intent) {\n        if (mDebug) Slog.v(TAG, \"onBind() intent = \" + intent);\n        mDreamServiceWrapper = new DreamServiceWrapper();\n        return mDreamServiceWrapper;\n    }\n\n    /**\n     * Stops the dream and detaches from the window.\n     * <p>\n     * When the dream ends, the system will be allowed to go to sleep fully unless there\n     * is a reason for it to be awake such as recent user activity or wake locks being held.\n     * </p>\n     */\n    public final void finish() {\n        if (mDebug) Slog.v(TAG, \"finish(): mFinished=\" + mFinished);\n\n        Activity activity = mActivity;\n        if (activity != null) {\n            if (!activity.isFinishing()) {\n                // In case the activity is not finished yet, do it now.\n                activity.finishAndRemoveTask();\n            }\n            return;\n        }\n\n        if (mFinished) {\n            return;\n        }\n        mFinished = true;\n\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Finish was called before the dream was attached.\");\n            stopSelf();\n            return;\n        }\n\n        try {\n            // finishSelf will unbind the dream controller from the dream service. This will\n            // trigger DreamService.this.onDestroy and DreamService.this will die.\n            mDreamManager.finishSelf(mDreamToken, true /*immediate*/);\n        } catch (RemoteException ex) {\n            // system server died\n        }\n    }\n\n    /**\n     * Wakes the dream up gently.\n     * <p>\n     * Calls {@link #onWakeUp} to give the dream a chance to perform an exit transition.\n     * When the transition is over, the dream should call {@link #finish}.\n     * </p>\n     */\n    public final void wakeUp() {\n        wakeUp(false);\n    }\n\n    private void wakeUp(boolean fromSystem) {\n        if (mDebug) Slog.v(TAG, \"wakeUp(): fromSystem=\" + fromSystem\n                + \", mWaking=\" + mWaking + \", mFinished=\" + mFinished);\n\n        if (!mWaking && !mFinished) {\n            mWaking = true;\n\n            // As a minor optimization, invoke the callback first in case it simply\n            // calls finish() immediately so there wouldn't be much point in telling\n            // the system that we are finishing the dream gently.\n            onWakeUp();\n\n            // Now tell the system we are waking gently, unless we already told\n            // it we were finishing immediately.\n            if (!fromSystem && !mFinished) {\n                if (mActivity == null) {\n                    Slog.w(TAG, \"WakeUp was called before the dream was attached.\");\n                } else {\n                    try {\n                        mDreamManager.finishSelf(mDreamToken, false /*immediate*/);\n                    } catch (RemoteException ex) {\n                        // system server died\n                    }\n                }\n            }\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDestroy() {\n        if (mDebug) Slog.v(TAG, \"onDestroy()\");\n        // hook for subclasses\n\n        // Just in case destroy came in before detach, let's take care of that now\n        detach();\n\n        super.onDestroy();\n    }\n\n    // end public api\n\n    /**\n     * Called by DreamController.stopDream() when the Dream is about to be unbound and destroyed.\n     *\n     * Must run on mHandler.\n     */\n    private final void detach() {\n        if (mStarted) {\n            if (mDebug) Slog.v(TAG, \"detach(): Calling onDreamingStopped()\");\n            mStarted = false;\n            onDreamingStopped();\n        }\n\n        if (mActivity != null && !mActivity.isFinishing()) {\n            mActivity.finishAndRemoveTask();\n        } else {\n            finish();\n        }\n\n        mDreamToken = null;\n        mCanDoze = false;\n    }\n\n    /**\n     * Called when the Dream is ready to be shown.\n     *\n     * Must run on mHandler.\n     *\n     * @param dreamToken Token for this dream service.\n     * @param started A callback that will be invoked once onDreamingStarted has completed.\n     */\n    private void attach(IBinder dreamToken, boolean canDoze, IRemoteCallback started) {\n        if (mDreamToken != null) {\n            Slog.e(TAG, \"attach() called when dream with token=\" + mDreamToken\n                    + \" already attached\");\n            return;\n        }\n        if (mFinished || mWaking) {\n            Slog.w(TAG, \"attach() called after dream already finished\");\n            try {\n                mDreamManager.finishSelf(dreamToken, true /*immediate*/);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n            return;\n        }\n\n        mDreamToken = dreamToken;\n        mCanDoze = canDoze;\n        if (mWindowless && !mCanDoze) {\n            throw new IllegalStateException(\"Only doze dreams can be windowless\");\n        }\n\n        mDispatchAfterOnAttachedToWindow = () -> {\n            if (mWindow != null || mWindowless) {\n                mStarted = true;\n                try {\n                    onDreamingStarted();\n                } finally {\n                    try {\n                        started.sendResult(null);\n                    } catch (RemoteException e) {\n                        throw e.rethrowFromSystemServer();\n                    }\n                }\n            }\n        };\n\n        // We need to defer calling onDreamingStarted until after the activity is created.\n        // If the dream is windowless, we can call it immediately. Otherwise, we wait\n        // for the DreamActivity to report onActivityCreated via\n        // DreamServiceWrapper.onActivityCreated.\n        if (!mWindowless) {\n            Intent i = new Intent(this, DreamActivity.class);\n            i.setPackage(getApplicationContext().getPackageName());\n            i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            i.putExtra(DreamActivity.EXTRA_CALLBACK, mDreamServiceWrapper);\n\n            try {\n                if (!ActivityTaskManager.getService().startDreamActivity(i)) {\n                    detach();\n                    return;\n                }\n            } catch (RemoteException e) {\n                Log.w(TAG, \"Could not connect to activity task manager to start dream activity\");\n                e.rethrowFromSystemServer();\n            }\n        } else {\n            mDispatchAfterOnAttachedToWindow.run();\n        }\n    }\n\n    private void onWindowCreated(Window w) {\n        mWindow = w;\n        mWindow.setCallback(this);\n        mWindow.requestFeature(Window.FEATURE_NO_TITLE);\n\n        WindowManager.LayoutParams lp = mWindow.getAttributes();\n        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN\n                    | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR\n                    | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED\n                    | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD\n                    | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON\n                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED\n                    | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0)\n                    | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0)\n                    );\n        mWindow.setAttributes(lp);\n        // Workaround: Currently low-profile and in-window system bar backgrounds don't go\n        // along well. Dreams usually don't need such bars anyways, so disable them by default.\n        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n\n        mWindow.getDecorView().addOnAttachStateChangeListener(\n                new View.OnAttachStateChangeListener() {\n                    @Override\n                    public void onViewAttachedToWindow(View v) {\n                        mDispatchAfterOnAttachedToWindow.run();\n                    }\n\n                    @Override\n                    public void onViewDetachedFromWindow(View v) {\n                        if (mActivity == null || !mActivity.isChangingConfigurations()) {\n                            // Only stop the dream if the view is not detached by relaunching\n                            // activity for configuration changes.\n                            mActivity = null;\n                            finish();\n                        }\n                    }\n                });\n    }\n\n    private boolean getWindowFlagValue(int flag, boolean defaultValue) {\n        return mWindow == null ? defaultValue : (mWindow.getAttributes().flags & flag) != 0;\n    }\n\n    private void applyWindowFlags(int flags, int mask) {\n        if (mWindow != null) {\n            WindowManager.LayoutParams lp = mWindow.getAttributes();\n            lp.flags = applyFlags(lp.flags, flags, mask);\n            mWindow.setAttributes(lp);\n            mWindow.getWindowManager().updateViewLayout(mWindow.getDecorView(), lp);\n        }\n    }\n\n    private int applyFlags(int oldFlags, int flags, int mask) {\n        return (oldFlags&~mask) | (flags&mask);\n    }\n\n    @Override\n    protected void dump(final FileDescriptor fd, PrintWriter pw, final String[] args) {\n        DumpUtils.dumpAsync(mHandler, new Dump() {\n            @Override\n            public void dump(PrintWriter pw, String prefix) {\n                dumpOnHandler(fd, pw, args);\n            }\n        }, pw, \"\", 1000);\n    }\n\n    /** @hide */\n    protected void dumpOnHandler(FileDescriptor fd, PrintWriter pw, String[] args) {\n        pw.print(TAG + \": \");\n        if (mFinished) {\n            pw.println(\"stopped\");\n        } else {\n            pw.println(\"running (dreamToken=\" + mDreamToken + \")\");\n        }\n        pw.println(\"  window: \" + mWindow);\n        pw.print(\"  flags:\");\n        if (isInteractive()) pw.print(\" interactive\");\n        if (isFullscreen()) pw.print(\" fullscreen\");\n        if (isScreenBright()) pw.print(\" bright\");\n        if (isWindowless()) pw.print(\" windowless\");\n        if (isDozing()) pw.print(\" dozing\");\n        else if (canDoze()) pw.print(\" candoze\");\n        pw.println();\n        if (canDoze()) {\n            pw.println(\"  doze screen state: \" + Display.stateToString(mDozeScreenState));\n            pw.println(\"  doze screen brightness: \" + mDozeScreenBrightness);\n        }\n    }\n\n    private static int clampAbsoluteBrightness(int value) {\n        return MathUtils.constrain(value, PowerManager.BRIGHTNESS_OFF, PowerManager.BRIGHTNESS_ON);\n    }\n\n    /**\n     * The DreamServiceWrapper is used as a gateway to the system_server, where DreamController\n     * uses it to control the DreamService. It is also used to receive callbacks from the\n     * DreamActivity.\n     */\n    final class DreamServiceWrapper extends IDreamService.Stub {\n        @Override\n        public void attach(final IBinder dreamToken, final boolean canDoze,\n                IRemoteCallback started) {\n            mHandler.post(() -> DreamService.this.attach(dreamToken, canDoze, started));\n        }\n\n        @Override\n        public void detach() {\n            mHandler.post(DreamService.this::detach);\n        }\n\n        @Override\n        public void wakeUp() {\n            mHandler.post(() -> DreamService.this.wakeUp(true /*fromSystem*/));\n        }\n\n        /** @hide */\n        void onActivityCreated(DreamActivity a) {\n            mActivity = a;\n            onWindowCreated(a.getWindow());\n        }\n    }\n}\n```",
            "downstream_file_tokens": {
              "openai": 9213,
              "general": {
                "word_based": 4398,
                "char_based": 10396
              },
              "gemini": 10611
            },
            "downstream_file_content_ground_truth": "/**\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage android.service.dreams;\n\nimport android.annotation.IdRes;\nimport android.annotation.LayoutRes;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.SdkConstant;\nimport android.annotation.SdkConstant.SdkConstantType;\nimport android.app.Activity;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.Service;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.Intent;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.IRemoteCallback;\nimport android.os.Looper;\nimport android.os.PowerManager;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.util.Log;\nimport android.util.MathUtils;\nimport android.util.Slog;\nimport android.view.ActionMode;\nimport android.view.Display;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SearchEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.WindowManager.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.DumpUtils.Dump;\n\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\n\n/**\n * Extend this class to implement a custom dream (available to the user as a \"Daydream\").\n *\n * <p>Dreams are interactive screensavers launched when a charging device is idle, or docked in a\n * desk dock. Dreams provide another modality for apps to express themselves, tailored for\n * an exhibition/lean-back experience.</p>\n *\n * <p>The {@code DreamService} lifecycle is as follows:</p>\n * <ol>\n *   <li>{@link #onAttachedToWindow}\n *     <p>Use this for initial setup, such as calling {@link #setContentView setContentView()}.</li>\n *   <li>{@link #onDreamingStarted}\n *     <p>Your dream has started, so you should begin animations or other behaviors here.</li>\n *   <li>{@link #onDreamingStopped}\n *     <p>Use this to stop the things you started in {@link #onDreamingStarted}.</li>\n *   <li>{@link #onDetachedFromWindow}\n *     <p>Use this to dismantle resources (for example, detach from handlers\n *        and listeners).</li>\n * </ol>\n *\n * <p>In addition, onCreate and onDestroy (from the Service interface) will also be called, but\n * initialization and teardown should be done by overriding the hooks above.</p>\n *\n * <p>To be available to the system, your {@code DreamService} should be declared in the\n * manifest as follows:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\" >\n *\n *     &lt;intent-filter>\n *         &lt;action android:name=\"android.service.dreams.DreamService\" />\n *         &lt;category android:name=\"android.intent.category.DEFAULT\" />\n *     &lt;/intent-filter>\n *\n *     &lt;!-- Point to additional information for this dream (optional) -->\n *     &lt;meta-data\n *         android:name=\"android.service.dream\"\n *         android:resource=\"@xml/my_dream\" />\n * &lt;/service>\n * </pre>\n *\n * <p>If specified with the {@code <meta-data>} element,\n * additional information for the dream is defined using the\n * {@link android.R.styleable#Dream &lt;dream&gt;} element in a separate XML file.\n * Currently, the only addtional\n * information you can provide is for a settings activity that allows the user to configure\n * the dream behavior. For example:</p>\n * <p class=\"code-caption\">res/xml/my_dream.xml</p>\n * <pre>\n * &lt;dream xmlns:android=\"http://schemas.android.com/apk/res/android\"\n *     android:settingsActivity=\"com.example.app/.MyDreamSettingsActivity\" />\n * </pre>\n * <p>This makes a Settings button available alongside your dream's listing in the\n * system settings, which when pressed opens the specified activity.</p>\n *\n *\n * <p>To specify your dream layout, call {@link #setContentView}, typically during the\n * {@link #onAttachedToWindow} callback. For example:</p>\n * <pre>\n * public class MyDream extends DreamService {\n *\n *     &#64;Override\n *     public void onAttachedToWindow() {\n *         super.onAttachedToWindow();\n *\n *         // Exit dream upon user touch\n *         setInteractive(false);\n *         // Hide system UI\n *         setFullscreen(true);\n *         // Set the dream layout\n *         setContentView(R.layout.dream);\n *     }\n * }\n * </pre>\n *\n * <p>When targeting api level 21 and above, you must declare the service in your manifest file\n * with the {@link android.Manifest.permission#BIND_DREAM_SERVICE} permission. For example:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\"\n *     android:permission=\"android.permission.BIND_DREAM_SERVICE\">\n *   &lt;intent-filter>\n *     &lt;action android:name=\u201dandroid.service.dreams.DreamService\u201d />\n *     &lt;category android:name=\u201dandroid.intent.category.DEFAULT\u201d />\n *   &lt;/intent-filter>\n * &lt;/service>\n * </pre>\n */\npublic class DreamService extends Service implements Window.Callback {\n    private final String TAG = DreamService.class.getSimpleName() + \"[\" + getClass().getSimpleName() + \"]\";\n\n    /**\n     * The name of the dream manager service.\n     * @hide\n     */\n    public static final String DREAM_SERVICE = \"dreams\";\n\n    /**\n     * The {@link Intent} that must be declared as handled by the service.\n     */\n    @SdkConstant(SdkConstantType.SERVICE_ACTION)\n    public static final String SERVICE_INTERFACE =\n            \"android.service.dreams.DreamService\";\n\n    /**\n     * Name under which a Dream publishes information about itself.\n     * This meta-data must reference an XML resource containing\n     * a <code>&lt;{@link android.R.styleable#Dream dream}&gt;</code>\n     * tag.\n     */\n    public static final String DREAM_META_DATA = \"android.service.dream\";\n\n    private final IDreamManager mDreamManager;\n    private final Handler mHandler = new Handler(Looper.getMainLooper());\n    private IBinder mDreamToken;\n    private Window mWindow;\n    private Activity mActivity;\n    private boolean mInteractive;\n    private boolean mFullscreen;\n    private boolean mScreenBright = true;\n    private boolean mStarted;\n    private boolean mWaking;\n    private boolean mFinished;\n    private boolean mCanDoze;\n    private boolean mDozing;\n    private boolean mWindowless;\n    private int mDozeScreenState = Display.STATE_UNKNOWN;\n    private int mDozeScreenBrightness = PowerManager.BRIGHTNESS_DEFAULT;\n\n    private boolean mDebug = false;\n\n    private DreamServiceWrapper mDreamServiceWrapper;\n    private Runnable mDispatchAfterOnAttachedToWindow;\n\n    public DreamService() {\n        mDreamManager = IDreamManager.Stub.asInterface(ServiceManager.getService(DREAM_SERVICE));\n    }\n\n    /**\n     * @hide\n     */\n    public void setDebug(boolean dbg) {\n        mDebug = dbg;\n    }\n\n    // begin Window.Callback methods\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyEvent\");\n            wakeUp();\n            return true;\n        } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {\n            if (mDebug) Slog.v(TAG, \"Waking up on back key\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyShortcutEvent(KeyEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyShortcutEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyShortcutEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // TODO: create more flexible version of mInteractive that allows clicks\n        // but finish()es on any other kind of activity\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on touchEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTouchEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTrackballEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on trackballEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTrackballEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchGenericMotionEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on genericMotionEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchGenericMotionEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public View onCreatePanelView(int featureId) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onCreatePanelMenu(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onPreparePanel(int featureId, View view, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuOpened(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowAttributesChanged(LayoutParams attrs) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onContentChanged() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowFocusChanged(boolean hasFocus) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onAttachedToWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDetachedFromWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onPanelClosed(int featureId, Menu menu) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested(SearchEvent event) {\n        return onSearchRequested();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested() {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(\n            android.view.ActionMode.Callback callback, int type) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeStarted(ActionMode mode) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeFinished(ActionMode mode) {\n    }\n    // end Window.Callback methods\n\n    // begin public api\n    /**\n     * Retrieves the current {@link android.view.WindowManager} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindowManager()}.\n     *\n     * @return The current window manager, or null if the dream is not started.\n     */\n    public WindowManager getWindowManager() {\n        return mWindow != null ? mWindow.getWindowManager() : null;\n    }\n\n    /**\n     * Retrieves the current {@link android.view.Window} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindow()}.\n     *\n     * @return The current window, or null if the dream is not started.\n     */\n    public Window getWindow() {\n        return mWindow;\n    }\n\n   /**\n     * Inflates a layout resource and set it to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(int)}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param layoutResID Resource ID to be inflated.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(android.view.View)} in an activity,\n     * including using {@link ViewGroup.LayoutParams#MATCH_PARENT} as the layout height and width of the view.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @see #setContentView(int)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(View view) {\n        getWindow().setContentView(view);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to\n     * {@link android.app.Activity#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)}\n     * in an activity.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(int)\n     */\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().setContentView(view, params);\n    }\n\n    /**\n     * Adds a view to the Dream's window, leaving other content views in place.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     */\n    public void addContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().addContentView(view, params);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that\n     * was processed in {@link #onCreate}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return The view if found or null otherwise.\n     * @see View#findViewById(int)\n     * @see DreamService#requireViewById(int)\n     */\n    @Nullable\n    public <T extends View> T findViewById(@IdRes int id) {\n        return getWindow().findViewById(id);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that was processed in\n     * {@link #onCreate}, or throws an IllegalArgumentException if the ID is invalid or there is no\n     * matching view in the hierarchy.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return a view with given ID\n     * @see View#requireViewById(int)\n     * @see DreamService#findViewById(int)\n     */\n    @NonNull\n    public final <T extends View> T requireViewById(@IdRes int id) {\n        T view = findViewById(id);\n        if (view == null) {\n            throw new IllegalArgumentException(\n                    \"ID does not reference a View inside this DreamService\");\n        }\n        return view;\n    }\n\n    /**\n     * Marks this dream as interactive to receive input events.\n     *\n     * <p>Non-interactive dreams (default) will dismiss on the first input event.</p>\n     *\n     * <p>Interactive dreams should call {@link #finish()} to dismiss themselves.</p>\n     *\n     * @param interactive True if this dream will handle input events.\n     */\n    public void setInteractive(boolean interactive) {\n        mInteractive = interactive;\n    }\n\n    /**\n     * Returns whether or not this dream is interactive.  Defaults to false.\n     *\n     * @see #setInteractive(boolean)\n     */\n    public boolean isInteractive() {\n        return mInteractive;\n    }\n\n    /**\n     * Controls {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN}\n     * on the dream's window.\n     *\n     * @param fullscreen If true, the fullscreen flag will be set; else it\n     * will be cleared.\n     */\n    public void setFullscreen(boolean fullscreen) {\n        if (mFullscreen != fullscreen) {\n            mFullscreen = fullscreen;\n            int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;\n            applyWindowFlags(mFullscreen ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream is in fullscreen mode. Defaults to false.\n     *\n     * @see #setFullscreen(boolean)\n     */\n    public boolean isFullscreen() {\n        return mFullscreen;\n    }\n\n    /**\n     * Marks this dream as keeping the screen bright while dreaming.\n     *\n     * @param screenBright True to keep the screen bright while dreaming.\n     */\n    public void setScreenBright(boolean screenBright) {\n        if (mScreenBright != screenBright) {\n            mScreenBright = screenBright;\n            int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;\n            applyWindowFlags(mScreenBright ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream keeps the screen bright while dreaming.\n     * Defaults to false, allowing the screen to dim if necessary.\n     *\n     * @see #setScreenBright(boolean)\n     */\n    public boolean isScreenBright() {\n        return getWindowFlagValue(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, mScreenBright);\n    }\n\n    /**\n     * Marks this dream as windowless.  Only available to doze dreams.\n     *\n     * @hide\n     *\n     */\n    public void setWindowless(boolean windowless) {\n        mWindowless = windowless;\n    }\n\n    /**\n     * Returns whether or not this dream is windowless.  Only available to doze dreams.\n     *\n     * @hide\n     */\n    public boolean isWindowless() {\n        return mWindowless;\n    }\n\n    /**\n     * Returns true if this dream is allowed to doze.\n     * <p>\n     * The value returned by this method is only meaningful when the dream has started.\n     * </p>\n     *\n     * @return True if this dream can doze.\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean canDoze() {\n        return mCanDoze;\n    }\n\n    /**\n     * Starts dozing, entering a deep dreamy sleep.\n     * <p>\n     * Dozing enables the system to conserve power while the user is not actively interacting\n     * with the device.  While dozing, the display will remain on in a low-power state\n     * and will continue to show its previous contents but the application processor and\n     * other system components will be allowed to suspend when possible.\n     * </p><p>\n     * While the application processor is suspended, the dream may stop executing code\n     * for long periods of time.  Prior to being suspended, the dream may schedule periodic\n     * wake-ups to render new content by scheduling an alarm with the {@link AlarmManager}.\n     * The dream may also keep the CPU awake by acquiring a\n     * {@link android.os.PowerManager#PARTIAL_WAKE_LOCK partial wake lock} when necessary.\n     * Note that since the purpose of doze mode is to conserve power (especially when\n     * running on battery), the dream should not wake the CPU very often or keep it\n     * awake for very long.\n     * </p><p>\n     * It is a good idea to call this method some time after the dream's entry animation\n     * has completed and the dream is ready to doze.  It is important to completely\n     * finish all of the work needed before dozing since the application processor may\n     * be suspended at any moment once this method is called unless other wake locks\n     * are being held.\n     * </p><p>\n     * Call {@link #stopDozing} or {@link #finish} to stop dozing.\n     * </p>\n     *\n     * @see #stopDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void startDozing() {\n        if (mCanDoze && !mDozing) {\n            mDozing = true;\n            updateDoze();\n        }\n    }\n\n    private void updateDoze() {\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Updating doze without a dream token.\");\n            return;\n        }\n\n        if (mDozing) {\n            try {\n                mDreamManager.startDozing(mDreamToken, mDozeScreenState, mDozeScreenBrightness);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Stops dozing, returns to active dreaming.\n     * <p>\n     * This method reverses the effect of {@link #startDozing}.  From this moment onward,\n     * the application processor will be kept awake as long as the dream is running\n     * or until the dream starts dozing again.\n     * </p>\n     *\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public void stopDozing() {\n        if (mDozing) {\n            mDozing = false;\n            try {\n                mDreamManager.stopDozing(mDreamToken);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Returns true if the dream will allow the system to enter a low-power state while\n     * it is running without actually turning off the screen.  Defaults to false,\n     * keeping the application processor awake while the dream is running.\n     *\n     * @return True if the dream is dozing.\n     *\n     * @see #setDozing(boolean)\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean isDozing() {\n        return mDozing;\n    }\n\n    /**\n     * Gets the screen state to use while dozing.\n     *\n     * @return The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @see #setDozeScreenState\n     * @hide For use by system UI components only.\n     */\n    public int getDozeScreenState() {\n        return mDozeScreenState;\n    }\n\n    /**\n     * Sets the screen state to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link Display#STATE_UNKNOWN} which lets the system decide.\n     * The dream may set a different state before starting to doze and may\n     * perform transitions between states while dozing to conserve power and\n     * achieve various effects.\n     * </p><p>\n     * Some devices will have dedicated hardware (\"Sidekick\") to animate\n     * the display content while the CPU sleeps. If the dream and the hardware support\n     * this, {@link Display#STATE_ON_SUSPEND} or {@link Display#STATE_DOZE_SUSPEND}\n     * will switch control to the Sidekick.\n     * </p><p>\n     * If not using Sidekick, it is recommended that the state be set to\n     * {@link Display#STATE_DOZE_SUSPEND} once the dream has completely\n     * finished drawing and before it releases its wakelock\n     * to allow the display hardware to be fully suspended.  While suspended,\n     * the display will preserve its on-screen contents.\n     * </p><p>\n     * If the doze suspend state is used, the dream must make sure to set the mode back\n     * to {@link Display#STATE_DOZE} or {@link Display#STATE_ON} before drawing again\n     * since the display updates may be ignored and not seen by the user otherwise.\n     * </p><p>\n     * The set of available display power states and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param state The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenState(int state) {\n        if (mDozeScreenState != state) {\n            mDozeScreenState = state;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Gets the screen brightness to use while dozing.\n     *\n     * @return The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @see #setDozeScreenBrightness\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public int getDozeScreenBrightness() {\n        return mDozeScreenBrightness;\n    }\n\n    /**\n     * Sets the screen brightness to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link PowerManager#BRIGHTNESS_DEFAULT} which lets the system decide.\n     * The dream may set a different brightness before starting to doze and may adjust\n     * the brightness while dozing to conserve power and achieve various effects.\n     * </p><p>\n     * Note that dream may specify any brightness in the full 0-255 range, including\n     * values that are less than the minimum value for manual screen brightness\n     * adjustments by the user.  In particular, the value may be set to 0 which may\n     * turn off the backlight entirely while still leaving the screen on although\n     * this behavior is device dependent and not guaranteed.\n     * </p><p>\n     * The available range of display brightness values and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param brightness The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenBrightness(int brightness) {\n        if (brightness != PowerManager.BRIGHTNESS_DEFAULT) {\n            brightness = clampAbsoluteBrightness(brightness);\n        }\n        if (mDozeScreenBrightness != brightness) {\n            mDozeScreenBrightness = brightness;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Called when this Dream is constructed.\n     */\n    @Override\n    public void onCreate() {\n        if (mDebug) Slog.v(TAG, \"onCreate()\");\n        super.onCreate();\n    }\n\n    /**\n     * Called when the dream's window has been created and is visible and animation may now begin.\n     */\n    public void onDreamingStarted() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStarted()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when this Dream is stopped, either by external request or by calling finish(),\n     * before the window has been removed.\n     */\n    public void onDreamingStopped() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStopped()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when the dream is being asked to stop itself and wake.\n     * <p>\n     * The default implementation simply calls {@link #finish} which ends the dream\n     * immediately.  Subclasses may override this function to perform a smooth exit\n     * transition then call {@link #finish} afterwards.\n     * </p><p>\n     * Note that the dream will only be given a short period of time (currently about\n     * five seconds) to wake up.  If the dream does not finish itself in a timely manner\n     * then the system will forcibly finish it once the time allowance is up.\n     * </p>\n     */\n    public void onWakeUp() {\n        finish();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public final IBinder onBind(Intent intent) {\n        if (mDebug) Slog.v(TAG, \"onBind() intent = \" + intent);\n        mDreamServiceWrapper = new DreamServiceWrapper();\n        return mDreamServiceWrapper;\n    }\n\n    /**\n     * Stops the dream and detaches from the window.\n     * <p>\n     * When the dream ends, the system will be allowed to go to sleep fully unless there\n     * is a reason for it to be awake such as recent user activity or wake locks being held.\n     * </p>\n     */\n    public final void finish() {\n        if (mDebug) Slog.v(TAG, \"finish(): mFinished=\" + mFinished);\n\n        Activity activity = mActivity;\n        if (activity != null) {\n            if (!activity.isFinishing()) {\n                // In case the activity is not finished yet, do it now.\n                activity.finishAndRemoveTask();\n            }\n            return;\n        }\n\n        if (mFinished) {\n            return;\n        }\n        mFinished = true;\n\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Finish was called before the dream was attached.\");\n            stopSelf();\n            return;\n        }\n\n        try {\n            // finishSelf will unbind the dream controller from the dream service. This will\n            // trigger DreamService.this.onDestroy and DreamService.this will die.\n            mDreamManager.finishSelf(mDreamToken, true /*immediate*/);\n        } catch (RemoteException ex) {\n            // system server died\n        }\n    }\n\n    /**\n     * Wakes the dream up gently.\n     * <p>\n     * Calls {@link #onWakeUp} to give the dream a chance to perform an exit transition.\n     * When the transition is over, the dream should call {@link #finish}.\n     * </p>\n     */\n    public final void wakeUp() {\n        wakeUp(false);\n    }\n\n    private void wakeUp(boolean fromSystem) {\n        if (mDebug) Slog.v(TAG, \"wakeUp(): fromSystem=\" + fromSystem\n                + \", mWaking=\" + mWaking + \", mFinished=\" + mFinished);\n\n        if (!mWaking && !mFinished) {\n            mWaking = true;\n\n            // As a minor optimization, invoke the callback first in case it simply\n            // calls finish() immediately so there wouldn't be much point in telling\n            // the system that we are finishing the dream gently.\n            onWakeUp();\n\n            // Now tell the system we are waking gently, unless we already told\n            // it we were finishing immediately.\n            if (!fromSystem && !mFinished) {\n                if (mActivity == null) {\n                    Slog.w(TAG, \"WakeUp was called before the dream was attached.\");\n                } else {\n                    try {\n                        mDreamManager.finishSelf(mDreamToken, false /*immediate*/);\n                    } catch (RemoteException ex) {\n                        // system server died\n                    }\n                }\n            }\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDestroy() {\n        if (mDebug) Slog.v(TAG, \"onDestroy()\");\n        // hook for subclasses\n\n        // Just in case destroy came in before detach, let's take care of that now\n        detach();\n\n        super.onDestroy();\n    }\n\n    // end public api\n\n    /**\n     * Called by DreamController.stopDream() when the Dream is about to be unbound and destroyed.\n     *\n     * Must run on mHandler.\n     */\n    private final void detach() {\n        if (mStarted) {\n            if (mDebug) Slog.v(TAG, \"detach(): Calling onDreamingStopped()\");\n            mStarted = false;\n            onDreamingStopped();\n        }\n\n        if (mActivity != null && !mActivity.isFinishing()) {\n            mActivity.finishAndRemoveTask();\n        } else {\n            finish();\n        }\n\n        mDreamToken = null;\n        mCanDoze = false;\n    }\n\n    /**\n     * Called when the Dream is ready to be shown.\n     *\n     * Must run on mHandler.\n     *\n     * @param dreamToken Token for this dream service.\n     * @param started A callback that will be invoked once onDreamingStarted has completed.\n     */\n    private void attach(IBinder dreamToken, boolean canDoze, IRemoteCallback started) {\n        if (mDreamToken != null) {\n            Slog.e(TAG, \"attach() called when dream with token=\" + mDreamToken\n                    + \" already attached\");\n            return;\n        }\n        if (mFinished || mWaking) {\n            Slog.w(TAG, \"attach() called after dream already finished\");\n            try {\n                mDreamManager.finishSelf(dreamToken, true /*immediate*/);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n            return;\n        }\n\n        mDreamToken = dreamToken;\n        mCanDoze = canDoze;\n        if (mWindowless && !mCanDoze) {\n            throw new IllegalStateException(\"Only doze dreams can be windowless\");\n        }\n\n        mDispatchAfterOnAttachedToWindow = () -> {\n            if (mWindow != null || mWindowless) {\n                mStarted = true;\n                try {\n                    onDreamingStarted();\n                } finally {\n                    try {\n                        started.sendResult(null);\n                    } catch (RemoteException e) {\n                        throw e.rethrowFromSystemServer();\n                    }\n                }\n            }\n        };\n\n        // We need to defer calling onDreamingStarted until after the activity is created.\n        // If the dream is windowless, we can call it immediately. Otherwise, we wait\n        // for the DreamActivity to report onActivityCreated via\n        // DreamServiceWrapper.onActivityCreated.\n        if (!mWindowless) {\n            Intent i = new Intent(this, DreamActivity.class);\n            i.setPackage(getApplicationContext().getPackageName());\n            i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            i.putExtra(DreamActivity.EXTRA_CALLBACK, mDreamServiceWrapper);\n\n            try {\n                if (!ActivityTaskManager.getService().startDreamActivity(i)) {\n                    detach();\n                    return;\n                }\n            } catch (RemoteException e) {\n                Log.w(TAG, \"Could not connect to activity task manager to start dream activity\");\n                e.rethrowFromSystemServer();\n            }\n        } else {\n            mDispatchAfterOnAttachedToWindow.run();\n        }\n    }\n\n    private void onWindowCreated(Window w) {\n        mWindow = w;\n        mWindow.setCallback(this);\n        mWindow.requestFeature(Window.FEATURE_NO_TITLE);\n\n        WindowManager.LayoutParams lp = mWindow.getAttributes();\n        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN\n                    | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR\n                    | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED\n                    | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD\n                    | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON\n                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED\n                    | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0)\n                    | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0)\n                    );\n        mWindow.setAttributes(lp);\n        // Workaround: Currently low-profile and in-window system bar backgrounds don't go\n        // along well. Dreams usually don't need such bars anyways, so disable them by default.\n        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n\n        mWindow.getDecorView().addOnAttachStateChangeListener(\n                new View.OnAttachStateChangeListener() {\n                    @Override\n                    public void onViewAttachedToWindow(View v) {\n                        mDispatchAfterOnAttachedToWindow.run();\n                    }\n\n                    @Override\n                    public void onViewDetachedFromWindow(View v) {\n                        if (mActivity == null || !mActivity.isChangingConfigurations()) {\n                            // Only stop the dream if the view is not detached by relaunching\n                            // activity for configuration changes.\n                            mActivity = null;\n                            finish();\n                        }\n                    }\n                });\n    }\n\n    private boolean getWindowFlagValue(int flag, boolean defaultValue) {\n        return mWindow == null ? defaultValue : (mWindow.getAttributes().flags & flag) != 0;\n    }\n\n    private void applyWindowFlags(int flags, int mask) {\n        if (mWindow != null) {\n            WindowManager.LayoutParams lp = mWindow.getAttributes();\n            lp.flags = applyFlags(lp.flags, flags, mask);\n            mWindow.setAttributes(lp);\n            mWindow.getWindowManager().updateViewLayout(mWindow.getDecorView(), lp);\n        }\n    }\n\n    private int applyFlags(int oldFlags, int flags, int mask) {\n        return (oldFlags&~mask) | (flags&mask);\n    }\n\n    @Override\n    protected void dump(final FileDescriptor fd, PrintWriter pw, final String[] args) {\n        DumpUtils.dumpAsync(mHandler, new Dump() {\n            @Override\n            public void dump(PrintWriter pw, String prefix) {\n                dumpOnHandler(fd, pw, args);\n            }\n        }, pw, \"\", 1000);\n    }\n\n    /** @hide */\n    protected void dumpOnHandler(FileDescriptor fd, PrintWriter pw, String[] args) {\n        pw.print(TAG + \": \");\n        if (mFinished) {\n            pw.println(\"stopped\");\n        } else {\n            pw.println(\"running (dreamToken=\" + mDreamToken + \")\");\n        }\n        pw.println(\"  window: \" + mWindow);\n        pw.print(\"  flags:\");\n        if (isInteractive()) pw.print(\" interactive\");\n        if (isFullscreen()) pw.print(\" fullscreen\");\n        if (isScreenBright()) pw.print(\" bright\");\n        if (isWindowless()) pw.print(\" windowless\");\n        if (isDozing()) pw.print(\" dozing\");\n        else if (canDoze()) pw.print(\" candoze\");\n        pw.println();\n        if (canDoze()) {\n            pw.println(\"  doze screen state: \" + Display.stateToString(mDozeScreenState));\n            pw.println(\"  doze screen brightness: \" + mDozeScreenBrightness);\n        }\n    }\n\n    private static int clampAbsoluteBrightness(int value) {\n        return MathUtils.constrain(value, PowerManager.BRIGHTNESS_OFF, PowerManager.BRIGHTNESS_ON);\n    }\n\n    /**\n     * The DreamServiceWrapper is used as a gateway to the system_server, where DreamController\n     * uses it to control the DreamService. It is also used to receive callbacks from the\n     * DreamActivity.\n     */\n    final class DreamServiceWrapper extends IDreamService.Stub {\n        @Override\n        public void attach(final IBinder dreamToken, final boolean canDoze,\n                IRemoteCallback started) {\n            mHandler.post(() -> DreamService.this.attach(dreamToken, canDoze, started));\n        }\n\n        @Override\n        public void detach() {\n            mHandler.post(DreamService.this::detach);\n        }\n\n        @Override\n        public void wakeUp() {\n            mHandler.post(() -> DreamService.this.wakeUp(true /*fromSystem*/));\n        }\n\n        /** @hide */\n        void onActivityCreated(DreamActivity a) {\n            mActivity = a;\n            onWindowCreated(a.getWindow());\n        }\n    }\n}",
            "downstream_file_ground_truth_tokens": {
              "openai": 9207,
              "general": {
                "word_based": 4394,
                "char_based": 10387
              },
              "gemini": 10602
            },
            "downstream_file_content_patched_upstream_only": "```java\n/**\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage android.service.dreams;\n\nimport android.annotation.IdRes;\nimport android.annotation.LayoutRes;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.SdkConstant;\nimport android.annotation.SdkConstant.SdkConstantType;\nimport android.annotation.TestApi;\nimport android.app.Activity;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.Service;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.Intent;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.IRemoteCallback;\nimport android.os.Looper;\nimport android.os.PowerManager;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.util.Log;\nimport android.util.MathUtils;\nimport android.util.Slog;\nimport android.view.ActionMode;\nimport android.view.Display;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SearchEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.WindowManager.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.DumpUtils.Dump;\n\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\n\n/**\n * Extend this class to implement a custom dream (available to the user as a \"Daydream\").\n *\n * <p>Dreams are interactive screensavers launched when a charging device is idle, or docked in a\n * desk dock. Dreams provide another modality for apps to express themselves, tailored for\n * an exhibition/lean-back experience.</p>\n *\n * <p>The {@code DreamService} lifecycle is as follows:</p>\n * <ol>\n *   <li>{@link #onAttachedToWindow}\n *     <p>Use this for initial setup, such as calling {@link #setContentView setContentView()}.</li>\n *   <li>{@link #onDreamingStarted}\n *     <p>Your dream has started, so you should begin animations or other behaviors here.</li>\n *   <li>{@link #onDreamingStopped}\n *     <p>Use this to stop the things you started in {@link #onDreamingStarted}.</li>\n *   <li>{@link #onDetachedFromWindow}\n *     <p>Use this to dismantle resources (for example, detach from handlers\n *        and listeners).</li>\n * </ol>\n *\n * <p>In addition, onCreate and onDestroy (from the Service interface) will also be called, but\n * initialization and teardown should be done by overriding the hooks above.</p>\n *\n * <p>To be available to the system, your {@code DreamService} should be declared in the\n * manifest as follows:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\" >\n *\n *     &lt;intent-filter>\n *         &lt;action android:name=\"android.service.dreams.DreamService\" />\n *         &lt;category android:name=\"android.intent.category.DEFAULT\" />\n *     &lt;/intent-filter>\n *\n *     &lt;!-- Point to additional information for this dream (optional) -->\n *     &lt;meta-data\n *         android:name=\"android.service.dream\"\n *         android:resource=\"@xml/my_dream\" />\n * &lt;/service>\n * </pre>\n *\n * <p>If specified with the {@code <meta-data>} element,\n * additional information for the dream is defined using the\n * {@link android.R.styleable#Dream &lt;dream&gt;} element in a separate XML file.\n * Currently, the only addtional\n * information you can provide is for a settings activity that allows the user to configure\n * the dream behavior. For example:</p>\n * <p class=\"code-caption\">res/xml/my_dream.xml</p>\n * <pre>\n * &lt;dream xmlns:android=\"http://schemas.android.com/apk/res/android\"\n *     android:settingsActivity=\"com.example.app/.MyDreamSettingsActivity\" />\n * </pre>\n * <p>This makes a Settings button available alongside your dream's listing in the\n * system settings, which when pressed opens the specified activity.</p>\n *\n *\n * <p>To specify your dream layout, call {@link #setContentView}, typically during the\n * {@link #onAttachedToWindow} callback. For example:</p>\n * <pre>\n * public class MyDream extends DreamService {\n *\n *     &#64;Override\n *     public void onAttachedToWindow() {\n *         super.onAttachedToWindow();\n *\n *         // Exit dream upon user touch\n *         setInteractive(false);\n *         // Hide system UI\n *         setFullscreen(true);\n *         // Set the dream layout\n *         setContentView(R.layout.dream);\n *     }\n * }\n * </pre>\n *\n * <p>When targeting api level 21 and above, you must declare the service in your manifest file\n * with the {@link android.Manifest.permission#BIND_DREAM_SERVICE} permission. For example:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\"\n *     android:permission=\"android.permission.BIND_DREAM_SERVICE\">\n *   &lt;intent-filter>\n *     &lt;action android:name=\u201dandroid.service.dreams.DreamService\u201d />\n *     &lt;category android:name=\u201dandroid.intent.category.DEFAULT\u201d />\n *   &lt;/intent-filter>\n * &lt;/service>\n * </pre>\n */\npublic class DreamService extends Service implements Window.Callback {\n    private final String TAG = DreamService.class.getSimpleName() + \"[\" + getClass().getSimpleName() + \"]\";\n\n    /**\n     * The name of the dream manager service.\n     * @hide\n     */\n    public static final String DREAM_SERVICE = \"dreams\";\n\n    /**\n     * The {@link Intent} that must be declared as handled by the service.\n     */\n    @SdkConstant(SdkConstantType.SERVICE_ACTION)\n    public static final String SERVICE_INTERFACE =\n            \"android.service.dreams.DreamService\";\n\n    /**\n     * Name under which a Dream publishes information about itself.\n     * This meta-data must reference an XML resource containing\n     * a <code>&lt;{@link android.R.styleable#Dream dream}&gt;</code>\n     * tag.\n     */\n    public static final String DREAM_META_DATA = \"android.service.dream\";\n\n    private final IDreamManager mDreamManager;\n    private final Handler mHandler = new Handler(Looper.getMainLooper());\n    private IBinder mDreamToken;\n    private Window mWindow;\n    private Activity mActivity;\n    private boolean mInteractive;\n    private boolean mFullscreen;\n    private boolean mScreenBright = true;\n    private boolean mStarted;\n    private boolean mWaking;\n    private boolean mFinished;\n    private boolean mCanDoze;\n    private boolean mDozing;\n    private boolean mWindowless;\n    private int mDozeScreenState = Display.STATE_UNKNOWN;\n    private int mDozeScreenBrightness = PowerManager.BRIGHTNESS_DEFAULT;\n\n    private boolean mDebug = false;\n\n    private DreamServiceWrapper mDreamServiceWrapper;\n    private Runnable mDispatchAfterOnAttachedToWindow;\n\n    public DreamService() {\n        mDreamManager = IDreamManager.Stub.asInterface(ServiceManager.getService(DREAM_SERVICE));\n    }\n\n    /**\n     * @hide\n     */\n    public void setDebug(boolean dbg) {\n        mDebug = dbg;\n    }\n\n    // begin Window.Callback methods\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyEvent\");\n            wakeUp();\n            return true;\n        } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {\n            if (mDebug) Slog.v(TAG, \"Waking up on back key\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyShortcutEvent(KeyEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyShortcutEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyShortcutEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // TODO: create more flexible version of mInteractive that allows clicks\n        // but finish()es on any other kind of activity\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on touchEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTouchEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTrackballEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on trackballEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTrackballEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchGenericMotionEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on genericMotionEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchGenericMotionEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public View onCreatePanelView(int featureId) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onCreatePanelMenu(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onPreparePanel(int featureId, View view, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuOpened(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowAttributesChanged(LayoutParams attrs) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onContentChanged() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowFocusChanged(boolean hasFocus) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onAttachedToWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDetachedFromWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onPanelClosed(int featureId, Menu menu) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested(SearchEvent event) {\n        return onSearchRequested();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested() {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(\n            android.view.ActionMode.Callback callback, int type) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeStarted(ActionMode mode) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeFinished(ActionMode mode) {\n    }\n    // end Window.Callback methods\n\n    // begin public api\n    /**\n     * Retrieves the current {@link android.view.WindowManager} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindowManager()}.\n     *\n     * @return The current window manager, or null if the dream is not started.\n     */\n    public WindowManager getWindowManager() {\n        return mWindow != null ? mWindow.getWindowManager() : null;\n    }\n\n    /**\n     * Retrieves the current {@link android.view.Window} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindow()}.\n     *\n     * @return The current window, or null if the dream is not started.\n     */\n    public Window getWindow() {\n        return mWindow;\n    }\n\n   /**\n     * Inflates a layout resource and set it to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(int)}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param layoutResID Resource ID to be inflated.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(android.view.View)} in an activity,\n     * including using {@link ViewGroup.LayoutParams#MATCH_PARENT} as the layout height and width of the view.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @see #setContentView(int)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(View view) {\n        getWindow().setContentView(view);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to\n     * {@link android.app.Activity#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)}\n     * in an activity.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(int)\n     */\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().setContentView(view, params);\n    }\n\n    /**\n     * Adds a view to the Dream's window, leaving other content views in place.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     */\n    public void addContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().addContentView(view, params);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that\n     * was processed in {@link #onCreate}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return The view if found or null otherwise.\n     * @see View#findViewById(int)\n     * @see DreamService#requireViewById(int)\n     */\n    @Nullable\n    public <T extends View> T findViewById(@IdRes int id) {\n        return getWindow().findViewById(id);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that was processed in\n     * {@link #onCreate}, or throws an IllegalArgumentException if the ID is invalid or there is no\n     * matching view in the hierarchy.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return a view with given ID\n     * @see View#requireViewById(int)\n     * @see DreamService#findViewById(int)\n     */\n    @NonNull\n    public final <T extends View> T requireViewById(@IdRes int id) {\n        T view = findViewById(id);\n        if (view == null) {\n            throw new IllegalArgumentException(\n                    \"ID does not reference a View inside this DreamService\");\n        }\n        return view;\n    }\n\n    /**\n     * Marks this dream as interactive to receive input events.\n     *\n     * <p>Non-interactive dreams (default) will dismiss on the first input event.</p>\n     *\n     * <p>Interactive dreams should call {@link #finish()} to dismiss themselves.</p>\n     *\n     * @param interactive True if this dream will handle input events.\n     */\n    public void setInteractive(boolean interactive) {\n        mInteractive = interactive;\n    }\n\n    /**\n     * Returns whether or not this dream is interactive.  Defaults to false.\n     *\n     * @see #setInteractive(boolean)\n     */\n    public boolean isInteractive() {\n        return mInteractive;\n    }\n\n    /**\n     * Controls {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN}\n     * on the dream's window.\n     *\n     * @param fullscreen If true, the fullscreen flag will be set; else it\n     * will be cleared.\n     */\n    public void setFullscreen(boolean fullscreen) {\n        if (mFullscreen != fullscreen) {\n            mFullscreen = fullscreen;\n            int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;\n            applyWindowFlags(mFullscreen ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream is in fullscreen mode. Defaults to false.\n     *\n     * @see #setFullscreen(boolean)\n     */\n    public boolean isFullscreen() {\n        return mFullscreen;\n    }\n\n    /**\n     * Marks this dream as keeping the screen bright while dreaming.\n     *\n     * @param screenBright True to keep the screen bright while dreaming.\n     */\n    public void setScreenBright(boolean screenBright) {\n        if (mScreenBright != screenBright) {\n            mScreenBright = screenBright;\n            int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;\n            applyWindowFlags(mScreenBright ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream keeps the screen bright while dreaming.\n     * Defaults to false, allowing the screen to dim if necessary.\n     *\n     * @see #setScreenBright(boolean)\n     */\n    public boolean isScreenBright() {\n        return getWindowFlagValue(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, mScreenBright);\n    }\n\n    /**\n     * Marks this dream as windowless.  Only available to doze dreams.\n     *\n     * @hide\n     *\n     */\n    public void setWindowless(boolean windowless) {\n        mWindowless = windowless;\n    }\n\n    /**\n     * Returns whether or not this dream is windowless.  Only available to doze dreams.\n     *\n     * @hide\n     */\n    public boolean isWindowless() {\n        return mWindowless;\n    }\n\n    /**\n     * Returns true if this dream is allowed to doze.\n     * <p>\n     * The value returned by this method is only meaningful when the dream has started.\n     * </p>\n     *\n     * @return True if this dream can doze.\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean canDoze() {\n        return mCanDoze;\n    }\n\n    /**\n     * Starts dozing, entering a deep dreamy sleep.\n     * <p>\n     * Dozing enables the system to conserve power while the user is not actively interacting\n     * with the device.  While dozing, the display will remain on in a low-power state\n     * and will continue to show its previous contents but the application processor and\n     * other system components will be allowed to suspend when possible.\n     * </p><p>\n     * While the application processor is suspended, the dream may stop executing code\n     * for long periods of time.  Prior to being suspended, the dream may schedule periodic\n     * wake-ups to render new content by scheduling an alarm with the {@link AlarmManager}.\n     * The dream may also keep the CPU awake by acquiring a\n     * {@link android.os.PowerManager#PARTIAL_WAKE_LOCK partial wake lock} when necessary.\n     * Note that since the purpose of doze mode is to conserve power (especially when\n     * running on battery), the dream should not wake the CPU very often or keep it\n     * awake for very long.\n     * </p><p>\n     * It is a good idea to call this method some time after the dream's entry animation\n     * has completed and the dream is ready to doze.  It is important to completely\n     * finish all of the work needed before dozing since the application processor may\n     * be suspended at any moment once this method is called unless other wake locks\n     * are being held.\n     * </p><p>\n     * Call {@link #stopDozing} or {@link #finish} to stop dozing.\n     * </p>\n     *\n     * @see #stopDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void startDozing() {\n        if (mCanDoze && !mDozing) {\n            mDozing = true;\n            updateDoze();\n        }\n    }\n\n    private void updateDoze() {\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Updating doze without a dream token.\");\n            return;\n        }\n\n        if (mDozing) {\n            try {\n                mDreamManager.startDozing(mDreamToken, mDozeScreenState, mDozeScreenBrightness);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Stops dozing, returns to active dreaming.\n     * <p>\n     * This method reverses the effect of {@link #startDozing}.  From this moment onward,\n     * the application processor will be kept awake as long as the dream is running\n     * or until the dream starts dozing again.\n     * </p>\n     *\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public void stopDozing() {\n        if (mDozing) {\n            mDozing = false;\n            try {\n                mDreamManager.stopDozing(mDreamToken);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Returns true if the dream will allow the system to enter a low-power state while\n     * it is running without actually turning off the screen.  Defaults to false,\n     * keeping the application processor awake while the dream is running.\n     *\n     * @return True if the dream is dozing.\n     *\n     * @see #setDozing(boolean)\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean isDozing() {\n        return mDozing;\n    }\n\n    /**\n     * Gets the screen state to use while dozing.\n     *\n     * @return The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @see #setDozeScreenState\n     * @hide For use by system UI components only.\n     */\n    public int getDozeScreenState() {\n        return mDozeScreenState;\n    }\n\n    /**\n     * Sets the screen state to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link Display#STATE_UNKNOWN} which lets the system decide.\n     * The dream may set a different state before starting to doze and may\n     * perform transitions between states while dozing to conserve power and\n     * achieve various effects.\n     * </p><p>\n     * Some devices will have dedicated hardware (\"Sidekick\") to animate\n     * the display content while the CPU sleeps. If the dream and the hardware support\n     * this, {@link Display#STATE_ON_SUSPEND} or {@link Display#STATE_DOZE_SUSPEND}\n     * will switch control to the Sidekick.\n     * </p><p>\n     * If not using Sidekick, it is recommended that the state be set to\n     * {@link Display#STATE_DOZE_SUSPEND} once the dream has completely\n     * finished drawing and before it releases its wakelock\n     * to allow the display hardware to be fully suspended.  While suspended,\n     * the display will preserve its on-screen contents.\n     * </p><p>\n     * If the doze suspend state is used, the dream must make sure to set the mode back\n     * to {@link Display#STATE_DOZE} or {@link Display#STATE_ON} before drawing again\n     * since the display updates may be ignored and not seen by the user otherwise.\n     * </p><p>\n     * The set of available display power states and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param state The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenState(int state) {\n        if (mDozeScreenState != state) {\n            mDozeScreenState = state;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Gets the screen brightness to use while dozing.\n     *\n     * @return The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @see #setDozeScreenBrightness\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public int getDozeScreenBrightness() {\n        return mDozeScreenBrightness;\n    }\n\n    /**\n     * Sets the screen brightness to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link PowerManager#BRIGHTNESS_DEFAULT} which lets the system decide.\n     * The dream may set a different brightness before starting to doze and may adjust\n     * the brightness while dozing to conserve power and achieve various effects.\n     * </p><p>\n     * Note that dream may specify any brightness in the full 0-255 range, including\n     * values that are less than the minimum value for manual screen brightness\n     * adjustments by the user.  In particular, the value may be set to 0 which may\n     * turn off the backlight entirely while still leaving the screen on although\n     * this behavior is device dependent and not guaranteed.\n     * </p><p>\n     * The available range of display brightness values and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param brightness The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenBrightness(int brightness) {\n        if (brightness != PowerManager.BRIGHTNESS_DEFAULT) {\n            brightness = clampAbsoluteBrightness(brightness);\n        }\n        if (mDozeScreenBrightness != brightness) {\n            mDozeScreenBrightness = brightness;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Called when this Dream is constructed.\n     */\n    @Override\n    public void onCreate() {\n        if (mDebug) Slog.v(TAG, \"onCreate()\");\n        super.onCreate();\n    }\n\n    /**\n     * Called when the dream's window has been created and is visible and animation may now begin.\n     */\n    public void onDreamingStarted() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStarted()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when this Dream is stopped, either by external request or by calling finish(),\n     * before the window has been removed.\n     */\n    public void onDreamingStopped() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStopped()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when the dream is being asked to stop itself and wake.\n     * <p>\n     * The default implementation simply calls {@link #finish} which ends the dream\n     * immediately.  Subclasses may override this function to perform a smooth exit\n     * transition then call {@link #finish} afterwards.\n     * </p><p>\n     * Note that the dream will only be given a short period of time (currently about\n     * five seconds) to wake up.  If the dream does not finish itself in a timely manner\n     * then the system will forcibly finish it once the time allowance is up.\n     * </p>\n     */\n    public void onWakeUp() {\n        finish();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public final IBinder onBind(Intent intent) {\n        if (mDebug) Slog.v(TAG, \"onBind() intent = \" + intent);\n        mDreamServiceWrapper = new DreamServiceWrapper();\n        return mDreamServiceWrapper;\n    }\n\n    /**\n     * Stops the dream and detaches from the window.\n     * <p>\n     * When the dream ends, the system will be allowed to go to sleep fully unless there\n     * is a reason for it to be awake such as recent user activity or wake locks being held.\n     * </p>\n     */\n    public final void finish() {\n        if (mDebug) Slog.v(TAG, \"finish(): mFinished=\" + mFinished);\n\n        Activity activity = mActivity;\n        if (activity != null) {\n            if (!activity.isFinishing()) {\n                // In case the activity is not finished yet, do it now.\n                activity.finishAndRemoveTask();\n            }\n            return;\n        }\n\n        if (mFinished) {\n            return;\n        }\n        mFinished = true;\n\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Finish was called before the dream was attached.\");\n            stopSelf();\n            return;\n        }\n\n        try {\n            // finishSelf will unbind the dream controller from the dream service. This will\n            // trigger DreamService.this.onDestroy and DreamService.this will die.\n            mDreamManager.finishSelf(mDreamToken, true /*immediate*/);\n        } catch (RemoteException ex) {\n            // system server died\n        }\n    }\n\n    /**\n     * Wakes the dream up gently.\n     * <p>\n     * Calls {@link #onWakeUp} to give the dream a chance to perform an exit transition.\n     * When the transition is over, the dream should call {@link #finish}.\n     * </p>\n     */\n    public final void wakeUp() {\n        wakeUp(false);\n    }\n\n    private void wakeUp(boolean fromSystem) {\n        if (mDebug) Slog.v(TAG, \"wakeUp(): fromSystem=\" + fromSystem\n                + \", mWaking=\" + mWaking + \", mFinished=\" + mFinished);\n\n        if (!mWaking && !mFinished) {\n            mWaking = true;\n\n            // As a minor optimization, invoke the callback first in case it simply\n            // calls finish() immediately so there wouldn't be much point in telling\n            // the system that we are finishing the dream gently.\n            onWakeUp();\n\n            // Now tell the system we are waking gently, unless we already told\n            // it we were finishing immediately.\n            if (!fromSystem && !mFinished) {\n                if (mActivity == null) {\n                    Slog.w(TAG, \"WakeUp was called before the dream was attached.\");\n                } else {\n                    try {\n                        mDreamManager.finishSelf(mDreamToken, false /*immediate*/);\n                    } catch (RemoteException ex) {\n                        // system server died\n                    }\n                }\n            }\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDestroy() {\n        if (mDebug) Slog.v(TAG, \"onDestroy()\");\n        // hook for subclasses\n\n        // Just in case destroy came in before detach, let's take care of that now\n        detach();\n\n        super.onDestroy();\n    }\n\n    // end public api\n\n    /**\n     * Called by DreamController.stopDream() when the Dream is about to be unbound and destroyed.\n     *\n     * Must run on mHandler.\n     */\n    private final void detach() {\n        if (mStarted) {\n            if (mDebug) Slog.v(TAG, \"detach(): Calling onDreamingStopped()\");\n            mStarted = false;\n            onDreamingStopped();\n        }\n\n        if (mActivity != null && !mActivity.isFinishing()) {\n            mActivity.finishAndRemoveTask();\n        } else {\n            finish();\n        }\n\n        mDreamToken = null;\n        mCanDoze = false;\n    }\n\n    /**\n     * Called when the Dream is ready to be shown.\n     *\n     * Must run on mHandler.\n     *\n     * @param dreamToken Token for this dream service.\n     * @param started A callback that will be invoked once onDreamingStarted has completed.\n     */\n    private void attach(IBinder dreamToken, boolean canDoze, IRemoteCallback started) {\n        if (mDreamToken != null) {\n            Slog.e(TAG, \"attach() called when dream with token=\" + mDreamToken\n                    + \" already attached\");\n            return;\n        }\n        if (mFinished || mWaking) {\n            Slog.w(TAG, \"attach() called after dream already finished\");\n            try {\n                mDreamManager.finishSelf(dreamToken, true /*immediate*/);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n            return;\n        }\n\n        mDreamToken = dreamToken;\n        mCanDoze = canDoze;\n        if (mWindowless && !mCanDoze) {\n            throw new IllegalStateException(\"Only doze dreams can be windowless\");\n        }\n\n        mDispatchAfterOnAttachedToWindow = () -> {\n            if (mWindow != null || mWindowless) {\n                mStarted = true;\n                try {\n                    onDreamingStarted();\n                } finally {\n                    try {\n                        started.sendResult(null);\n                    } catch (RemoteException e) {\n                        throw e.rethrowFromSystemServer();\n                    }\n                }\n            }\n        };\n\n        // We need to defer calling onDreamingStarted until after the activity is created.\n        // If the dream is windowless, we can call it immediately. Otherwise, we wait\n        // for the DreamActivity to report onActivityCreated via\n        // DreamServiceWrapper.onActivityCreated.\n        if (!mWindowless) {\n            Intent i = new Intent(this, DreamActivity.class);\n            i.setPackage(getApplicationContext().getPackageName());\n            i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            i.putExtra(DreamActivity.EXTRA_CALLBACK, mDreamServiceWrapper);\n\n            try {\n                if (!ActivityTaskManager.getService().startDreamActivity(i)) {\n                    detach();\n                    return;\n                }\n            } catch (RemoteException e) {\n                Log.w(TAG, \"Could not connect to activity task manager to start dream activity\");\n                e.rethrowFromSystemServer();\n            }\n        } else {\n            mDispatchAfterOnAttachedToWindow.run();\n        }\n    }\n\n    private void onWindowCreated(Window w) {\n        mWindow = w;\n        mWindow.setCallback(this);\n        mWindow.requestFeature(Window.FEATURE_NO_TITLE);\n\n        WindowManager.LayoutParams lp = mWindow.getAttributes();\n        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN\n                    | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR\n                    | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED\n                    | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD\n                    | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON\n                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED\n                    | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0)\n                    | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0)\n                    );\n        mWindow.setAttributes(lp);\n        // Workaround: Currently low-profile and in-window system bar backgrounds don't go\n        // along well. Dreams usually don't need such bars anyways, so disable them by default.\n        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n\n        mWindow.getDecorView().addOnAttachStateChangeListener(\n                new View.OnAttachStateChangeListener() {\n                    @Override\n                    public void onViewAttachedToWindow(View v) {\n                        mDispatchAfterOnAttachedToWindow.run();\n                    }\n\n                    @Override\n                    public void onViewDetachedFromWindow(View v) {\n                        if (mActivity == null || !mActivity.isChangingConfigurations()) {\n                            // Only stop the dream if the view is not detached by relaunching\n                            // activity for configuration changes.\n                            mActivity = null;\n                            finish();\n                        }\n                    }\n                });\n    }\n\n    private boolean getWindowFlagValue(int flag, boolean defaultValue) {\n        return mWindow == null ? defaultValue : (mWindow.getAttributes().flags & flag) != 0;\n    }\n\n    private void applyWindowFlags(int flags, int mask) {\n        if (mWindow != null) {\n            WindowManager.LayoutParams lp = mWindow.getAttributes();\n            lp.flags = applyFlags(lp.flags, flags, mask);\n            mWindow.setAttributes(lp);\n            mWindow.getWindowManager().updateViewLayout(mWindow.getDecorView(), lp);\n        }\n    }\n\n    private int applyFlags(int oldFlags, int flags, int mask) {\n        return (oldFlags&~mask) | (flags&mask);\n    }\n\n    @Override\n    protected void dump(final FileDescriptor fd, PrintWriter pw, final String[] args) {\n        DumpUtils.dumpAsync(mHandler, new Dump() {\n            @Override\n            public void dump(PrintWriter pw, String prefix) {\n                dumpOnHandler(fd, pw, args);\n            }\n        }, pw, \"\", 1000);\n    }\n\n    /** @hide */\n    protected void dumpOnHandler(FileDescriptor fd, PrintWriter pw, String[] args) {\n        pw.print(TAG + \": \");\n        if (mFinished) {\n            pw.println(\"stopped\");\n        } else {\n            pw.println(\"running (dreamToken=\" + mDreamToken + \")\");\n        }\n        pw.println(\"  window: \" + mWindow);\n        pw.print(\"  flags:\");\n        if (isInteractive()) pw.print(\" interactive\");\n        if (isFullscreen()) pw.print(\" fullscreen\");\n        if (isScreenBright()) pw.print(\" bright\");\n        if (isWindowless()) pw.print(\" windowless\");\n        if (isDozing()) pw.print(\" dozing\");\n        else if (canDoze()) pw.print(\" candoze\");\n        pw.println();\n        if (canDoze()) {\n            pw.println(\"  doze screen state: \" + Display.stateToString(mDozeScreenState));\n            pw.println(\"  doze screen brightness: \" + mDozeScreenBrightness);\n        }\n    }\n\n    private static int clampAbsoluteBrightness(int value) {\n        return MathUtils.constrain(value, PowerManager.BRIGHTNESS_OFF, PowerManager.BRIGHTNESS_ON);\n    }\n\n    /**\n     * The DreamServiceWrapper is used as a gateway to the system_server, where DreamController\n     * uses it to control the DreamService. It is also used to receive callbacks from the\n     * DreamActivity.\n     */\n    final class DreamServiceWrapper extends IDreamService.Stub {\n        @Override\n        public void attach(final IBinder dreamToken, final boolean canDoze,\n                IRemoteCallback started) {\n            mHandler.post(() -> DreamService.this.attach(dreamToken, canDoze, started));\n        }\n\n        @Override\n        public void detach() {\n            mHandler.post(DreamService.this::detach);\n        }\n\n        @Override\n        public void wakeUp() {\n            mHandler.post(() -> DreamService.this.wakeUp(true /*fromSystem*/));\n        }\n\n        /** @hide */\n        void onActivityCreated(DreamActivity a) {\n            mActivity = a;\n            onWindowCreated(a.getWindow());\n        }\n    }\n}\n```",
            "diff_patched_upstream_only": "--- original_downstream_file\n+++ patched_upstream_only\n@@ -1,4 +1,3 @@\n-```java\n /**\n  * Copyright (C) 2012 The Android Open Source Project\n  *\n@@ -1169,5 +1168,4 @@\n             onWindowCreated(a.getWindow());\n         }\n     }\n-}\n-```+}",
            "downstream_llm_diff_output": null,
            "runtime_seconds": 489.75,
            "llm_output_valid": false,
            "attempts_made": 3,
            "validation_results": [
              {
                "attempt": 1,
                "format_valid": false,
                "format_error": "Invalid patch format: Unexpected hunk found: @@ -174,6 +186,27 @@\n",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 126.6
              },
              {
                "attempt": 2,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk is longer than expected",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 191.94
              },
              {
                "attempt": 3,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk diff line expected: ```",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 171.22
              }
            ],
            "error": "All validation attempts failed",
            "last_format_error": "Invalid patch format: Hunk diff line expected: ```",
            "last_apply_error": "Skipped due to format error"
          }
        ]
      },
      {
        "downstream_version": "11",
        "gemini_token_usage": 38790,
        "branch_used": "android11-release",
        "downstream_patch": "6926fd15fb16c51468dde270bd61ee68772b8c14",
        "repo_path": "android_repos/base",
        "result": "failure",
        "downstream_patch_content": "commit 6926fd15fb16c51468dde270bd61ee68772b8c14\nAuthor: Will Leshner <wleshner@google.com>\nDate:   Tue Oct 31 13:23:08 2023 -0700\n\n    Fix vulnerability that allowed attackers to start arbitary activities\n    \n    Test: Flashed device and verified dream settings works as expected\n    Test: Installed APK from bug and verified the dream didn't allow\n    launching the inappropriate settings activity.\n    Fixes: 300090204\n    \n    Merged-In: I6e90e3a0d513dceb7d7f5c59d6807ebe164c5716\n    Merged-In: I146415ad400827d0a798e27f34f098feb5e96422\n    Merged-In: I7f2351fc7d9a82778ce21f67018a45ac67c9aaf8\n    Change-Id: I573040df84bf98a493b39f96c8581e4303206bac\n\ndiff --git a/packages/SettingsLib/src/com/android/settingslib/dream/DreamBackend.java b/packages/SettingsLib/src/com/android/settingslib/dream/DreamBackend.java\nindex ab7b54d98285..beadd821957b 100644\n--- a/packages/SettingsLib/src/com/android/settingslib/dream/DreamBackend.java\n+++ b/packages/SettingsLib/src/com/android/settingslib/dream/DreamBackend.java\n@@ -351,7 +351,17 @@ public class DreamBackend {\n         if (cn != null && cn.indexOf('/') < 0) {\n             cn = resolveInfo.serviceInfo.packageName + \"/\" + cn;\n         }\n-        return cn == null ? null : ComponentName.unflattenFromString(cn);\n+        // Ensure that the component is from the same package as the dream service. If not,\n+        // treat the component as invalid and return null instead.\n+        final ComponentName result = cn != null ? ComponentName.unflattenFromString(cn) : null;\n+        if (result != null\n+                && !result.getPackageName().equals(resolveInfo.serviceInfo.packageName)) {\n+            Log.w(TAG,\n+                    \"Inconsistent package name in component: \" + result.getPackageName()\n+                            + \", should be: \" + resolveInfo.serviceInfo.packageName);\n+            return null;\n+        }\n+        return result;\n     }\n \n     private static void logd(String msg, Object... args) {\n",
        "downstream_patch_tokens": {
          "openai": 532,
          "general": {
            "word_based": 207,
            "char_based": 493
          },
          "gemini": 692
        },
        "file_conflicts": [
          {
            "file_name": "core/java/android/service/dreams/DreamService.java",
            "total_hunks": 5,
            "failed_hunks": [
              2,
              3,
              4,
              5
            ],
            "inline_merge_conflicts": [
              {
                "hunk_number": 1,
                "merge_conflict": "<<<<<<< DOWNSTREAM (version 11)\n        mDreamToken = null;\n        mCanDoze = false;\n=======\n        // Ensure that the component is from the same package as the dream service. If not,\n        // treat the component as invalid and return null instead.\n        final ComponentName cn = ComponentName.unflattenFromString(flattenedString);\n        if (cn == null) return null;\n        if (!cn.getPackageName().equals(serviceInfo.packageName)) {\n            Log.w(TAG,\n                    \"Inconsistent package name in component: \" + cn.getPackageName()\n                            + \", should be: \" + serviceInfo.packageName);\n            return null;\n        }\n        return cn;\n>>>>>>> UPSTREAM PATCH (commit 2ce1b7fd37273ea19fbbb6daeeaa6212357b9a70)",
                "merge_conflict_tokens": {
                  "openai": 169,
                  "general": {
                    "word_based": 70,
                    "char_based": 187
                  },
                  "gemini": 197
                }
              }
            ],
            "inline_merge_token_summary": {
              "gemini": 13396,
              "openai": 11661,
              "general_word": 4830,
              "general_char": 12903
            },
            "rej_file_content": "```diff\n--- core/java/android/service/dreams/DreamService.java\n+++ core/java/android/service/dreams/DreamService.java\n@@ -1125,7 +1126,8 @@ public class DreamService extends Service implements Window.Callback {\n      * @hide\n      */\n     @Nullable\n-    public static DreamMetadata getDreamMetadata(Context context,\n+    @TestApi\n+    public static DreamMetadata getDreamMetadata(@NonNull Context context,\n             @Nullable ServiceInfo serviceInfo) {\n         if (serviceInfo == null) return null;\n \n@@ -1184,7 +1186,8 @@ public class DreamService extends Service implements Window.Callback {\n         }\n     }\n \n-    private static ComponentName convertToComponentName(String flattenedString,\n+    @Nullable\n+    private static ComponentName convertToComponentName(@Nullable String flattenedString,\n             ServiceInfo serviceInfo) {\n         if (flattenedString == null) {\n             return null;\n@@ -1194,7 +1197,17 @@ public class DreamService extends Service implements Window.Callback {\n             return new ComponentName(serviceInfo.packageName, flattenedString);\n         }\n \n-        return ComponentName.unflattenFromString(flattenedString);\n+        // Ensure that the component is from the same package as the dream service. If not,\n+        // treat the component as invalid and return null instead.\n+        final ComponentName cn = ComponentName.unflattenFromString(flattenedString);\n+        if (cn == null) return null;\n+        if (!cn.getPackageName().equals(serviceInfo.packageName)) {\n+            Log.w(TAG,\n+                    \"Inconsistent package name in component: \" + cn.getPackageName()\n+                            + \", should be: \" + serviceInfo.packageName);\n+            return null;\n+        }\n+        return cn;\n     }\n \n     /**\n@@ -1490,6 +1503,7 @@ public class DreamService extends Service implements Window.Callback {\n      *\n      * @hide\n      */\n+    @TestApi\n     public static final class DreamMetadata {\n         @Nullable\n         public final ComponentName settingsActivity;\n```",
            "rej_file_tokens": {
              "openai": 434,
              "general": {
                "word_based": 188,
                "char_based": 507
              },
              "gemini": 504
            },
            "patch_apply_output": "patching file core/java/android/service/dreams/DreamService.java\nHunk #1 succeeded at 21 (offset -1 lines).\nHunk #2 FAILED at 1125.\nHunk #3 FAILED at 1184.\nHunk #4 FAILED at 1194.\nHunk #5 FAILED at 1490.\n4 out of 5 hunks FAILED -- saving rejects to file core/java/android/service/dreams/DreamService.java.rej",
            "inline_merge_output": "patching file core/java/android/service/dreams/DreamService.java\nHunk #1 already applied at 25.\nHunk #2 already applied at 1128-1129.\nHunk #3 already applied at 1188-1189.\nHunk #4 NOT MERGED at 1230-1245.\nHunk #5 already applied at 1519.",
            "upstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage android.service.dreams;\n\nimport android.annotation.IdRes;\nimport android.annotation.LayoutRes;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.SdkConstant;\nimport android.annotation.SdkConstant.SdkConstantType;\nimport android.annotation.TestApi;\nimport android.app.Activity;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.Service;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ServiceInfo;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.graphics.drawable.Drawable;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.IRemoteCallback;\nimport android.os.Looper;\nimport android.os.PowerManager;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.util.MathUtils;\nimport android.util.Slog;\nimport android.util.Xml;\nimport android.view.ActionMode;\nimport android.view.Display;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SearchEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowInsets;\nimport android.view.WindowManager;\nimport android.view.WindowManager.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.R;\nimport com.android.internal.util.DumpUtils;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.FileDescriptor;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.function.Consumer;\n\n/**\n * Extend this class to implement a custom dream (available to the user as a \"Daydream\").\n *\n * <p>Dreams are interactive screensavers launched when a charging device is idle, or docked in a\n * desk dock. Dreams provide another modality for apps to express themselves, tailored for\n * an exhibition/lean-back experience.</p>\n *\n * <p>The {@code DreamService} lifecycle is as follows:</p>\n * <ol>\n *   <li>{@link #onAttachedToWindow}\n *     <p>Use this for initial setup, such as calling {@link #setContentView setContentView()}.</li>\n *   <li>{@link #onDreamingStarted}\n *     <p>Your dream has started, so you should begin animations or other behaviors here.</li>\n *   <li>{@link #onDreamingStopped}\n *     <p>Use this to stop the things you started in {@link #onDreamingStarted}.</li>\n *   <li>{@link #onDetachedFromWindow}\n *     <p>Use this to dismantle resources (for example, detach from handlers\n *        and listeners).</li>\n * </ol>\n *\n * <p>In addition, onCreate and onDestroy (from the Service interface) will also be called, but\n * initialization and teardown should be done by overriding the hooks above.</p>\n *\n * <p>To be available to the system, your {@code DreamService} should be declared in the\n * manifest as follows:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\" >\n *\n *     &lt;intent-filter>\n *         &lt;action android:name=\"android.service.dreams.DreamService\" />\n *         &lt;category android:name=\"android.intent.category.DEFAULT\" />\n *     &lt;/intent-filter>\n *\n *     &lt;!-- Point to additional information for this dream (optional) -->\n *     &lt;meta-data\n *         android:name=\"android.service.dream\"\n *         android:resource=\"@xml/my_dream\" />\n * &lt;/service>\n * </pre>\n *\n * <p>If specified with the {@code <meta-data>} element,\n * additional information for the dream is defined using the\n * {@link android.R.styleable#Dream &lt;dream&gt;} element in a separate XML file.\n * Currently, the only additional\n * information you can provide is for a settings activity that allows the user to configure\n * the dream behavior. For example:</p>\n * <p class=\"code-caption\">res/xml/my_dream.xml</p>\n * <pre>\n * &lt;dream xmlns:android=\"http://schemas.android.com/apk/res/android\"\n *     android:settingsActivity=\"com.example.app/.MyDreamSettingsActivity\" />\n * </pre>\n * <p>This makes a Settings button available alongside your dream's listing in the\n * system settings, which when pressed opens the specified activity.</p>\n *\n *\n * <p>To specify your dream layout, call {@link #setContentView}, typically during the\n * {@link #onAttachedToWindow} callback. For example:</p>\n * <pre>\n * public class MyDream extends DreamService {\n *\n *     &#64;Override\n *     public void onAttachedToWindow() {\n *         super.onAttachedToWindow();\n *\n *         // Exit dream upon user touch\n *         setInteractive(false);\n *         // Hide system UI\n *         setFullscreen(true);\n *         // Set the dream layout\n *         setContentView(R.layout.dream);\n *     }\n * }\n * </pre>\n *\n * <p>When targeting api level 21 and above, you must declare the service in your manifest file\n * with the {@link android.Manifest.permission#BIND_DREAM_SERVICE} permission. For example:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\"\n *     android:permission=\"android.permission.BIND_DREAM_SERVICE\">\n *   &lt;intent-filter>\n *     &lt;action android:name=\u201dandroid.service.dreams.DreamService\u201d />\n *     &lt;category android:name=\u201dandroid.intent.category.DEFAULT\u201d />\n *   &lt;/intent-filter>\n * &lt;/service>\n * </pre>\n */\npublic class DreamService extends Service implements Window.Callback {\n    private static final String TAG = DreamService.class.getSimpleName();\n    private final String mTag = TAG + \"[\" + getClass().getSimpleName() + \"]\";\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n\n    /**\n     * The name of the dream manager service.\n     * @hide\n     */\n    public static final String DREAM_SERVICE = \"dreams\";\n\n    /**\n     * The {@link Intent} that must be declared as handled by the service.\n     */\n    @SdkConstant(SdkConstantType.SERVICE_ACTION)\n    public static final String SERVICE_INTERFACE =\n            \"android.service.dreams.DreamService\";\n\n    /**\n     * The name of the extra where the dream overlay component is stored.\n     * @hide\n     */\n    public static final String EXTRA_DREAM_OVERLAY_COMPONENT =\n            \"android.service.dream.DreamService.dream_overlay_component\";\n\n    /**\n     * Name under which a Dream publishes information about itself.\n     * This meta-data must reference an XML resource containing\n     * a <code>&lt;{@link android.R.styleable#Dream dream}&gt;</code>\n     * tag.\n     */\n    public static final String DREAM_META_DATA = \"android.service.dream\";\n\n    /**\n     * Name of the root tag under which a Dream defines its metadata in an XML file.\n     */\n    private static final String DREAM_META_DATA_ROOT_TAG = \"dream\";\n\n    /**\n     * Extra containing a boolean for whether to show complications on the overlay.\n     * @hide\n     */\n    public static final String EXTRA_SHOW_COMPLICATIONS =\n            \"android.service.dreams.SHOW_COMPLICATIONS\";\n\n    /**\n     * The default value for whether to show complications on the overlay.\n     * @hide\n     */\n    public static final boolean DEFAULT_SHOW_COMPLICATIONS = false;\n\n    private final IDreamManager mDreamManager;\n    private final Handler mHandler = new Handler(Looper.getMainLooper());\n    private IBinder mDreamToken;\n    private Window mWindow;\n    private Activity mActivity;\n    private boolean mInteractive;\n    private boolean mFullscreen;\n    private boolean mScreenBright = true;\n    private boolean mStarted;\n    private boolean mWaking;\n    private boolean mFinished;\n    private boolean mCanDoze;\n    private boolean mDozing;\n    private boolean mWindowless;\n    private int mDozeScreenState = Display.STATE_UNKNOWN;\n    private int mDozeScreenBrightness = PowerManager.BRIGHTNESS_DEFAULT;\n\n    private boolean mDebug = false;\n\n    private DreamServiceWrapper mDreamServiceWrapper;\n    private Runnable mDispatchAfterOnAttachedToWindow;\n\n    private final OverlayConnection mOverlayConnection;\n\n    private static class OverlayConnection implements ServiceConnection {\n        // Overlay set during onBind.\n        private IDreamOverlay mOverlay;\n        // A Queue of pending requests to execute on the overlay.\n        private final ArrayDeque<Consumer<IDreamOverlay>> mRequests;\n\n        private boolean mBound;\n\n        OverlayConnection() {\n            mRequests = new ArrayDeque<>();\n        }\n\n        public void bind(Context context, @Nullable ComponentName overlayService,\n                ComponentName dreamService) {\n            if (overlayService == null) {\n                return;\n            }\n\n            final ServiceInfo serviceInfo = fetchServiceInfo(context, dreamService);\n\n            final Intent overlayIntent = new Intent();\n            overlayIntent.setComponent(overlayService);\n            overlayIntent.putExtra(EXTRA_SHOW_COMPLICATIONS,\n                    fetchShouldShowComplications(context, serviceInfo));\n\n            context.bindService(overlayIntent,\n                    this, Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE);\n            mBound = true;\n        }\n\n        public void unbind(Context context) {\n            if (!mBound) {\n                return;\n            }\n\n            context.unbindService(this);\n            mBound = false;\n        }\n\n        public void request(Consumer<IDreamOverlay> request) {\n            mRequests.push(request);\n            evaluate();\n        }\n\n        private void evaluate() {\n            if (mOverlay == null) {\n                return;\n            }\n\n            // Any new requests that arrive during this loop will be processed synchronously after\n            // the loop exits.\n            while (!mRequests.isEmpty()) {\n                final Consumer<IDreamOverlay> request = mRequests.pop();\n                request.accept(mOverlay);\n            }\n        }\n\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            // Store Overlay and execute pending requests.\n            mOverlay = IDreamOverlay.Stub.asInterface(service);\n            evaluate();\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            // Clear Overlay binder to prevent further request processing.\n            mOverlay = null;\n        }\n    }\n\n    private final IDreamOverlayCallback mOverlayCallback = new IDreamOverlayCallback.Stub() {\n        @Override\n        public void onExitRequested() {\n            // Simply finish dream when exit is requested.\n            finish();\n        }\n    };\n\n\n    public DreamService() {\n        mDreamManager = IDreamManager.Stub.asInterface(ServiceManager.getService(DREAM_SERVICE));\n        mOverlayConnection = new OverlayConnection();\n    }\n\n    /**\n     * @hide\n     */\n    public void setDebug(boolean dbg) {\n        mDebug = dbg;\n    }\n\n    // begin Window.Callback methods\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK\n        if (!mInteractive) {\n            if (mDebug) Slog.v(mTag, \"Waking up on keyEvent\");\n            wakeUp();\n            return true;\n        } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {\n            if (mDebug) Slog.v(mTag, \"Waking up on back key\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyShortcutEvent(KeyEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(mTag, \"Waking up on keyShortcutEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyShortcutEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // TODO: create more flexible version of mInteractive that allows clicks\n        // but finish()es on any other kind of activity\n        if (!mInteractive && event.getActionMasked() == MotionEvent.ACTION_UP) {\n            if (mDebug) Slog.v(mTag, \"Waking up on touchEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTouchEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTrackballEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(mTag, \"Waking up on trackballEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTrackballEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchGenericMotionEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(mTag, \"Waking up on genericMotionEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchGenericMotionEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public View onCreatePanelView(int featureId) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onCreatePanelMenu(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onPreparePanel(int featureId, View view, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuOpened(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowAttributesChanged(LayoutParams attrs) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onContentChanged() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowFocusChanged(boolean hasFocus) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onAttachedToWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDetachedFromWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onPanelClosed(int featureId, Menu menu) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested(SearchEvent event) {\n        return onSearchRequested();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested() {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(\n            android.view.ActionMode.Callback callback, int type) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeStarted(ActionMode mode) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeFinished(ActionMode mode) {\n    }\n    // end Window.Callback methods\n\n    // begin public api\n    /**\n     * Retrieves the current {@link android.view.WindowManager} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindowManager()}.\n     *\n     * @return The current window manager, or null if the dream is not started.\n     */\n    public WindowManager getWindowManager() {\n        return mWindow != null ? mWindow.getWindowManager() : null;\n    }\n\n    /**\n     * Retrieves the current {@link android.view.Window} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindow()}.\n     *\n     * @return The current window, or null if the dream is not started.\n     */\n    public Window getWindow() {\n        return mWindow;\n    }\n\n   /**\n     * Inflates a layout resource and set it to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(int)}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param layoutResID Resource ID to be inflated.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(android.view.View)} in an activity,\n     * including using {@link ViewGroup.LayoutParams#MATCH_PARENT} as the layout height and width of the view.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @see #setContentView(int)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(View view) {\n        getWindow().setContentView(view);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to\n     * {@link android.app.Activity#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)}\n     * in an activity.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(int)\n     */\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().setContentView(view, params);\n    }\n\n    /**\n     * Adds a view to the Dream's window, leaving other content views in place.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     */\n    public void addContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().addContentView(view, params);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that\n     * was processed in {@link #onCreate}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return The view if found or null otherwise.\n     * @see View#findViewById(int)\n     * @see DreamService#requireViewById(int)\n     */\n    @Nullable\n    public <T extends View> T findViewById(@IdRes int id) {\n        return getWindow().findViewById(id);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that was processed in\n     * {@link #onCreate}, or throws an IllegalArgumentException if the ID is invalid or there is no\n     * matching view in the hierarchy.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return a view with given ID\n     * @see View#requireViewById(int)\n     * @see DreamService#findViewById(int)\n     */\n    @NonNull\n    public final <T extends View> T requireViewById(@IdRes int id) {\n        T view = findViewById(id);\n        if (view == null) {\n            throw new IllegalArgumentException(\n                    \"ID does not reference a View inside this DreamService\");\n        }\n        return view;\n    }\n\n    /**\n     * Marks this dream as interactive to receive input events.\n     *\n     * <p>Non-interactive dreams (default) will dismiss on the first input event.</p>\n     *\n     * <p>Interactive dreams should call {@link #finish()} to dismiss themselves.</p>\n     *\n     * @param interactive True if this dream will handle input events.\n     */\n    public void setInteractive(boolean interactive) {\n        mInteractive = interactive;\n    }\n\n    /**\n     * Returns whether this dream is interactive. Defaults to false.\n     *\n     * @see #setInteractive(boolean)\n     */\n    public boolean isInteractive() {\n        return mInteractive;\n    }\n\n    /**\n     * Controls {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN}\n     * on the dream's window.\n     *\n     * @param fullscreen If true, the fullscreen flag will be set; else it\n     * will be cleared.\n     */\n    public void setFullscreen(boolean fullscreen) {\n        if (mFullscreen != fullscreen) {\n            mFullscreen = fullscreen;\n            int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;\n            applyWindowFlags(mFullscreen ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether this dream is in fullscreen mode. Defaults to false.\n     *\n     * @see #setFullscreen(boolean)\n     */\n    public boolean isFullscreen() {\n        return mFullscreen;\n    }\n\n    /**\n     * Marks this dream as keeping the screen bright while dreaming.\n     *\n     * @param screenBright True to keep the screen bright while dreaming.\n     */\n    public void setScreenBright(boolean screenBright) {\n        if (mScreenBright != screenBright) {\n            mScreenBright = screenBright;\n            int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;\n            applyWindowFlags(mScreenBright ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether this dream keeps the screen bright while dreaming.\n     * Defaults to false, allowing the screen to dim if necessary.\n     *\n     * @see #setScreenBright(boolean)\n     */\n    public boolean isScreenBright() {\n        return getWindowFlagValue(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, mScreenBright);\n    }\n\n    /**\n     * Marks this dream as windowless. Only available to doze dreams.\n     *\n     * @hide\n     *\n     */\n    public void setWindowless(boolean windowless) {\n        mWindowless = windowless;\n    }\n\n    /**\n     * Returns whether this dream is windowless. Only available to doze dreams.\n     *\n     * @hide\n     */\n    public boolean isWindowless() {\n        return mWindowless;\n    }\n\n    /**\n     * Returns true if this dream is allowed to doze.\n     * <p>\n     * The value returned by this method is only meaningful when the dream has started.\n     * </p>\n     *\n     * @return True if this dream can doze.\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean canDoze() {\n        return mCanDoze;\n    }\n\n    /**\n     * Starts dozing, entering a deep dreamy sleep.\n     * <p>\n     * Dozing enables the system to conserve power while the user is not actively interacting\n     * with the device. While dozing, the display will remain on in a low-power state\n     * and will continue to show its previous contents but the application processor and\n     * other system components will be allowed to suspend when possible.\n     * </p><p>\n     * While the application processor is suspended, the dream may stop executing code\n     * for long periods of time. Prior to being suspended, the dream may schedule periodic\n     * wake-ups to render new content by scheduling an alarm with the {@link AlarmManager}.\n     * The dream may also keep the CPU awake by acquiring a\n     * {@link android.os.PowerManager#PARTIAL_WAKE_LOCK partial wake lock} when necessary.\n     * Note that since the purpose of doze mode is to conserve power (especially when\n     * running on battery), the dream should not wake the CPU very often or keep it\n     * awake for very long.\n     * </p><p>\n     * It is a good idea to call this method some time after the dream's entry animation\n     * has completed and the dream is ready to doze. It is important to completely\n     * finish all of the work needed before dozing since the application processor may\n     * be suspended at any moment once this method is called unless other wake locks\n     * are being held.\n     * </p><p>\n     * Call {@link #stopDozing} or {@link #finish} to stop dozing.\n     * </p>\n     *\n     * @see #stopDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void startDozing() {\n        if (mCanDoze && !mDozing) {\n            mDozing = true;\n            updateDoze();\n        }\n    }\n\n    private void updateDoze() {\n        if (mDreamToken == null) {\n            Slog.w(mTag, \"Updating doze without a dream token.\");\n            return;\n        }\n\n        if (mDozing) {\n            try {\n                mDreamManager.startDozing(mDreamToken, mDozeScreenState, mDozeScreenBrightness);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Stops dozing, returns to active dreaming.\n     * <p>\n     * This method reverses the effect of {@link #startDozing}. From this moment onward,\n     * the application processor will be kept awake as long as the dream is running\n     * or until the dream starts dozing again.\n     * </p>\n     *\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public void stopDozing() {\n        if (mDozing) {\n            mDozing = false;\n            try {\n                mDreamManager.stopDozing(mDreamToken);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Returns true if the dream will allow the system to enter a low-power state while\n     * it is running without actually turning off the screen. Defaults to false,\n     * keeping the application processor awake while the dream is running.\n     *\n     * @return True if the dream is dozing.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean isDozing() {\n        return mDozing;\n    }\n\n    /**\n     * Gets the screen state to use while dozing.\n     *\n     * @return The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @see #setDozeScreenState\n     * @hide For use by system UI components only.\n     */\n    public int getDozeScreenState() {\n        return mDozeScreenState;\n    }\n\n    /**\n     * Sets the screen state to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called. The default value is\n     * {@link Display#STATE_UNKNOWN} which lets the system decide.\n     * The dream may set a different state before starting to doze and may\n     * perform transitions between states while dozing to conserve power and\n     * achieve various effects.\n     * </p><p>\n     * Some devices will have dedicated hardware (\"Sidekick\") to animate\n     * the display content while the CPU sleeps. If the dream and the hardware support\n     * this, {@link Display#STATE_ON_SUSPEND} or {@link Display#STATE_DOZE_SUSPEND}\n     * will switch control to the Sidekick.\n     * </p><p>\n     * If not using Sidekick, it is recommended that the state be set to\n     * {@link Display#STATE_DOZE_SUSPEND} once the dream has completely\n     * finished drawing and before it releases its wakelock\n     * to allow the display hardware to be fully suspended. While suspended,\n     * the display will preserve its on-screen contents.\n     * </p><p>\n     * If the doze suspend state is used, the dream must make sure to set the mode back\n     * to {@link Display#STATE_DOZE} or {@link Display#STATE_ON} before drawing again\n     * since the display updates may be ignored and not seen by the user otherwise.\n     * </p><p>\n     * The set of available display power states and their behavior while dozing is\n     * hardware dependent and may vary across devices. The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param state The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenState(int state) {\n        if (mDozeScreenState != state) {\n            mDozeScreenState = state;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Gets the screen brightness to use while dozing.\n     *\n     * @return The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @see #setDozeScreenBrightness\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)\n    public int getDozeScreenBrightness() {\n        return mDozeScreenBrightness;\n    }\n\n    /**\n     * Sets the screen brightness to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called. The default value is\n     * {@link PowerManager#BRIGHTNESS_DEFAULT} which lets the system decide.\n     * The dream may set a different brightness before starting to doze and may adjust\n     * the brightness while dozing to conserve power and achieve various effects.\n     * </p><p>\n     * Note that dream may specify any brightness in the full 0-255 range, including\n     * values that are less than the minimum value for manual screen brightness\n     * adjustments by the user. In particular, the value may be set to 0 which may\n     * turn off the backlight entirely while still leaving the screen on although\n     * this behavior is device dependent and not guaranteed.\n     * </p><p>\n     * The available range of display brightness values and their behavior while dozing is\n     * hardware dependent and may vary across devices. The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param brightness The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenBrightness(int brightness) {\n        if (brightness != PowerManager.BRIGHTNESS_DEFAULT) {\n            brightness = clampAbsoluteBrightness(brightness);\n        }\n        if (mDozeScreenBrightness != brightness) {\n            mDozeScreenBrightness = brightness;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Called when this Dream is constructed.\n     */\n    @Override\n    public void onCreate() {\n        if (mDebug) Slog.v(mTag, \"onCreate()\");\n        super.onCreate();\n    }\n\n    /**\n     * Called when the dream's window has been created and is visible and animation may now begin.\n     */\n    public void onDreamingStarted() {\n        if (mDebug) Slog.v(mTag, \"onDreamingStarted()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when this Dream is stopped, either by external request or by calling finish(),\n     * before the window has been removed.\n     */\n    public void onDreamingStopped() {\n        if (mDebug) Slog.v(mTag, \"onDreamingStopped()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when the dream is being asked to stop itself and wake.\n     * <p>\n     * The default implementation simply calls {@link #finish} which ends the dream\n     * immediately. Subclasses may override this function to perform a smooth exit\n     * transition then call {@link #finish} afterwards.\n     * </p><p>\n     * Note that the dream will only be given a short period of time (currently about\n     * five seconds) to wake up. If the dream does not finish itself in a timely manner\n     * then the system will forcibly finish it once the time allowance is up.\n     * </p>\n     */\n    public void onWakeUp() {\n        finish();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public final IBinder onBind(Intent intent) {\n        if (mDebug) Slog.v(mTag, \"onBind() intent = \" + intent);\n        mDreamServiceWrapper = new DreamServiceWrapper();\n\n        // Connect to the overlay service if present.\n        if (!mWindowless) {\n            mOverlayConnection.bind(\n                    /* context= */ this,\n                    intent.getParcelableExtra(EXTRA_DREAM_OVERLAY_COMPONENT),\n                    new ComponentName(this, getClass()));\n        }\n\n        return mDreamServiceWrapper;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        // We must unbind from any overlay connection if we are unbound before finishing.\n        mOverlayConnection.unbind(this);\n\n        return super.onUnbind(intent);\n    }\n\n    /**\n     * Stops the dream and detaches from the window.\n     * <p>\n     * When the dream ends, the system will be allowed to go to sleep fully unless there\n     * is a reason for it to be awake such as recent user activity or wake locks being held.\n     * </p>\n     */\n    public final void finish() {\n        if (mDebug) Slog.v(mTag, \"finish(): mFinished=\" + mFinished);\n\n        Activity activity = mActivity;\n        if (activity != null) {\n            if (!activity.isFinishing()) {\n                // In case the activity is not finished yet, do it now.\n                activity.finishAndRemoveTask();\n            }\n            return;\n        }\n\n        if (mFinished) {\n            return;\n        }\n        mFinished = true;\n\n        mOverlayConnection.unbind(this);\n\n        if (mDreamToken == null) {\n            Slog.w(mTag, \"Finish was called before the dream was attached.\");\n            stopSelf();\n            return;\n        }\n\n        try {\n            // finishSelf will unbind the dream controller from the dream service. This will\n            // trigger DreamService.this.onDestroy and DreamService.this will die.\n            mDreamManager.finishSelf(mDreamToken, true /*immediate*/);\n        } catch (RemoteException ex) {\n            // system server died\n        }\n    }\n\n    /**\n     * Wakes the dream up gently.\n     * <p>\n     * Calls {@link #onWakeUp} to give the dream a chance to perform an exit transition.\n     * When the transition is over, the dream should call {@link #finish}.\n     * </p>\n     */\n    public final void wakeUp() {\n        wakeUp(false);\n    }\n\n    private void wakeUp(boolean fromSystem) {\n        if (mDebug) {\n            Slog.v(mTag, \"wakeUp(): fromSystem=\" + fromSystem + \", mWaking=\" + mWaking\n                    + \", mFinished=\" + mFinished);\n        }\n\n        if (!mWaking && !mFinished) {\n            mWaking = true;\n\n            if (mActivity != null) {\n                // During wake up the activity should be translucent to allow the application\n                // underneath to start drawing. Normally, the WM animation system takes care of\n                // this, but here we give the dream application some time to perform a custom exit\n                // animation. If it uses a view animation, the WM doesn't know about it and can't\n                // make the activity translucent in the normal way. Therefore, here we ensure that\n                // the activity is translucent during wake up regardless of what animation is used\n                // in onWakeUp().\n                mActivity.convertToTranslucent(null, null);\n            }\n\n            // As a minor optimization, invoke the callback first in case it simply\n            // calls finish() immediately so there wouldn't be much point in telling\n            // the system that we are finishing the dream gently.\n            onWakeUp();\n\n            // Now tell the system we are waking gently, unless we already told\n            // it we were finishing immediately.\n            if (!fromSystem && !mFinished) {\n                if (mActivity == null) {\n                    Slog.w(mTag, \"WakeUp was called before the dream was attached.\");\n                } else {\n                    try {\n                        mDreamManager.finishSelf(mDreamToken, false /*immediate*/);\n                    } catch (RemoteException ex) {\n                        // system server died\n                    }\n                }\n            }\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDestroy() {\n        if (mDebug) Slog.v(mTag, \"onDestroy()\");\n        // hook for subclasses\n\n        // Just in case destroy came in before detach, let's take care of that now\n        detach();\n\n        super.onDestroy();\n    }\n\n    // end public api\n\n    /**\n     * Parses and returns metadata of the dream service indicated by the service info. Returns null\n     * if metadata cannot be found.\n     *\n     * Note that {@link ServiceInfo} must be fetched with {@link PackageManager#GET_META_DATA} flag.\n     *\n     * @hide\n     */\n    @Nullable\n    @TestApi\n    public static DreamMetadata getDreamMetadata(@NonNull Context context,\n            @Nullable ServiceInfo serviceInfo) {\n        if (serviceInfo == null) return null;\n\n        final PackageManager pm = context.getPackageManager();\n\n        try (TypedArray rawMetadata = readMetadata(pm, serviceInfo)) {\n            if (rawMetadata == null) return null;\n            return new DreamMetadata(\n                    convertToComponentName(rawMetadata.getString(\n                            com.android.internal.R.styleable.Dream_settingsActivity), serviceInfo),\n                    rawMetadata.getDrawable(\n                            com.android.internal.R.styleable.Dream_previewImage),\n                    rawMetadata.getBoolean(R.styleable.Dream_showClockAndComplications,\n                            DEFAULT_SHOW_COMPLICATIONS));\n        }\n    }\n\n    /**\n     * Returns the raw XML metadata fetched from the {@link ServiceInfo}.\n     *\n     * Returns <code>null</code> if the {@link ServiceInfo} doesn't contain valid dream metadata.\n     */\n    @Nullable\n    private static TypedArray readMetadata(PackageManager pm, ServiceInfo serviceInfo) {\n        if (serviceInfo == null || serviceInfo.metaData == null) {\n            return null;\n        }\n\n        try (XmlResourceParser parser =\n                     serviceInfo.loadXmlMetaData(pm, DreamService.DREAM_META_DATA)) {\n            if (parser == null) {\n                if (DEBUG) Log.w(TAG, \"No \" + DreamService.DREAM_META_DATA + \" metadata\");\n                return null;\n            }\n\n            final AttributeSet attrs = Xml.asAttributeSet(parser);\n            while (true) {\n                final int type = parser.next();\n                if (type == XmlPullParser.END_DOCUMENT || type == XmlPullParser.START_TAG) {\n                    break;\n                }\n            }\n\n            if (!parser.getName().equals(DREAM_META_DATA_ROOT_TAG)) {\n                if (DEBUG) {\n                    Log.w(TAG, \"Metadata does not start with \" + DREAM_META_DATA_ROOT_TAG + \" tag\");\n                }\n                return null;\n            }\n\n            return pm.getResourcesForApplication(serviceInfo.applicationInfo).obtainAttributes(\n                    attrs, com.android.internal.R.styleable.Dream);\n        } catch (PackageManager.NameNotFoundException | IOException | XmlPullParserException e) {\n            if (DEBUG) Log.e(TAG, \"Error parsing: \" + serviceInfo.packageName, e);\n            return null;\n        }\n    }\n\n    @Nullable\n    private static ComponentName convertToComponentName(@Nullable String flattenedString,\n            ServiceInfo serviceInfo) {\n        if (flattenedString == null) {\n            return null;\n        }\n\n        if (!flattenedString.contains(\"/\")) {\n            return new ComponentName(serviceInfo.packageName, flattenedString);\n        }\n\n        // Ensure that the component is from the same package as the dream service. If not,\n        // treat the component as invalid and return null instead.\n        final ComponentName cn = ComponentName.unflattenFromString(flattenedString);\n        if (cn == null) return null;\n        if (!cn.getPackageName().equals(serviceInfo.packageName)) {\n            Log.w(TAG,\n                    \"Inconsistent package name in component: \" + cn.getPackageName()\n                            + \", should be: \" + serviceInfo.packageName);\n            return null;\n        }\n        return cn;\n    }\n\n    /**\n     * Called by DreamController.stopDream() when the Dream is about to be unbound and destroyed.\n     *\n     * Must run on mHandler.\n     */\n    private void detach() {\n        if (mStarted) {\n            if (mDebug) Slog.v(mTag, \"detach(): Calling onDreamingStopped()\");\n            mStarted = false;\n            onDreamingStopped();\n        }\n\n        if (mActivity != null && !mActivity.isFinishing()) {\n            mActivity.finishAndRemoveTask();\n        } else {\n            finish();\n        }\n\n        mDreamToken = null;\n        mCanDoze = false;\n    }\n\n    /**\n     * Called when the Dream is ready to be shown.\n     *\n     * Must run on mHandler.\n     *\n     * @param dreamToken Token for this dream service.\n     * @param started A callback that will be invoked once onDreamingStarted has completed.\n     */\n    private void attach(IBinder dreamToken, boolean canDoze, IRemoteCallback started) {\n        if (mDreamToken != null) {\n            Slog.e(mTag, \"attach() called when dream with token=\" + mDreamToken\n                    + \" already attached\");\n            return;\n        }\n        if (mFinished || mWaking) {\n            Slog.w(mTag, \"attach() called after dream already finished\");\n            try {\n                mDreamManager.finishSelf(dreamToken, true /*immediate*/);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n            return;\n        }\n\n        mDreamToken = dreamToken;\n        mCanDoze = canDoze;\n        if (mWindowless && !mCanDoze) {\n            throw new IllegalStateException(\"Only doze dreams can be windowless\");\n        }\n\n        mDispatchAfterOnAttachedToWindow = () -> {\n            if (mWindow != null || mWindowless) {\n                mStarted = true;\n                try {\n                    onDreamingStarted();\n                } finally {\n                    try {\n                        started.sendResult(null);\n                    } catch (RemoteException e) {\n                        throw e.rethrowFromSystemServer();\n                    }\n                }\n            }\n        };\n\n        // We need to defer calling onDreamingStarted until after the activity is created.\n        // If the dream is windowless, we can call it immediately. Otherwise, we wait\n        // for the DreamActivity to report onActivityCreated via\n        // DreamServiceWrapper.onActivityCreated.\n        if (!mWindowless) {\n            Intent i = new Intent(this, DreamActivity.class);\n            i.setPackage(getApplicationContext().getPackageName());\n            i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            i.putExtra(DreamActivity.EXTRA_CALLBACK, new DreamActivityCallback(mDreamToken));\n            final ServiceInfo serviceInfo = fetchServiceInfo(this,\n                    new ComponentName(this, getClass()));\n            i.putExtra(DreamActivity.EXTRA_DREAM_TITLE, fetchDreamLabel(this, serviceInfo));\n\n            try {\n                if (!ActivityTaskManager.getService().startDreamActivity(i)) {\n                    detach();\n                }\n            } catch (RemoteException e) {\n                Log.w(mTag, \"Could not connect to activity task manager to start dream activity\");\n                e.rethrowFromSystemServer();\n            }\n        } else {\n            mDispatchAfterOnAttachedToWindow.run();\n        }\n    }\n\n    private void onWindowCreated(Window w) {\n        mWindow = w;\n        mWindow.setCallback(this);\n        mWindow.requestFeature(Window.FEATURE_NO_TITLE);\n\n        WindowManager.LayoutParams lp = mWindow.getAttributes();\n        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN\n                    | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR\n                    | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED\n                    | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD\n                    | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON\n                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED\n                    | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0)\n                    | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0)\n                    );\n        lp.layoutInDisplayCutoutMode =\n                WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS;\n        mWindow.setAttributes(lp);\n        // Workaround: Currently low-profile and in-window system bar backgrounds don't go\n        // along well. Dreams usually don't need such bars anyways, so disable them by default.\n        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n\n        // Hide all insets when the dream is showing\n        mWindow.getDecorView().getWindowInsetsController().hide(WindowInsets.Type.systemBars());\n        mWindow.setDecorFitsSystemWindows(false);\n\n        mWindow.getDecorView().addOnAttachStateChangeListener(\n                new View.OnAttachStateChangeListener() {\n                    @Override\n                    public void onViewAttachedToWindow(View v) {\n                        mDispatchAfterOnAttachedToWindow.run();\n\n                        // Request the DreamOverlay be told to dream with dream's window parameters\n                        // once the window has been attached.\n                        mOverlayConnection.request(overlay -> {\n                            try {\n                                overlay.startDream(mWindow.getAttributes(), mOverlayCallback);\n                            } catch (RemoteException e) {\n                                Log.e(mTag, \"could not send window attributes:\" + e);\n                            }\n                        });\n                    }\n\n                    @Override\n                    public void onViewDetachedFromWindow(View v) {\n                        if (mActivity == null || !mActivity.isChangingConfigurations()) {\n                            // Only stop the dream if the view is not detached by relaunching\n                            // activity for configuration changes. It is important to also clear\n                            // the window reference in order to fully release the DreamActivity.\n                            mWindow = null;\n                            mActivity = null;\n                            finish();\n                        }\n                    }\n                });\n    }\n\n    private boolean getWindowFlagValue(int flag, boolean defaultValue) {\n        return mWindow == null ? defaultValue : (mWindow.getAttributes().flags & flag) != 0;\n    }\n\n    private void applyWindowFlags(int flags, int mask) {\n        if (mWindow != null) {\n            WindowManager.LayoutParams lp = mWindow.getAttributes();\n            lp.flags = applyFlags(lp.flags, flags, mask);\n            mWindow.setAttributes(lp);\n            mWindow.getWindowManager().updateViewLayout(mWindow.getDecorView(), lp);\n        }\n    }\n\n    private int applyFlags(int oldFlags, int flags, int mask) {\n        return (oldFlags&~mask) | (flags&mask);\n    }\n\n    /**\n     * Fetches metadata of the dream indicated by the {@link ComponentName}, and returns whether\n     * the dream should show complications on the overlay. If not defined, returns\n     * {@link DreamService#DEFAULT_SHOW_COMPLICATIONS}.\n     */\n    private static boolean fetchShouldShowComplications(Context context,\n            @Nullable ServiceInfo serviceInfo) {\n        final DreamMetadata metadata = getDreamMetadata(context, serviceInfo);\n        if (metadata != null) {\n            return metadata.showComplications;\n        }\n        return DEFAULT_SHOW_COMPLICATIONS;\n    }\n\n    @Nullable\n    private static CharSequence fetchDreamLabel(Context context,\n            @Nullable ServiceInfo serviceInfo) {\n        if (serviceInfo == null) return null;\n        final PackageManager pm = context.getPackageManager();\n        return serviceInfo.loadLabel(pm);\n    }\n\n    @Nullable\n    private static ServiceInfo fetchServiceInfo(Context context, ComponentName componentName) {\n        final PackageManager pm = context.getPackageManager();\n\n        try {\n            return pm.getServiceInfo(componentName,\n                    PackageManager.ComponentInfoFlags.of(PackageManager.GET_META_DATA));\n        } catch (PackageManager.NameNotFoundException e) {\n            if (DEBUG) Log.w(TAG, \"cannot find component \" + componentName.flattenToShortString());\n        }\n        return null;\n    }\n\n    @Override\n    protected void dump(final FileDescriptor fd, PrintWriter pw, final String[] args) {\n        DumpUtils.dumpAsync(mHandler, (pw1, prefix) -> dumpOnHandler(fd, pw1, args), pw, \"\", 1000);\n    }\n\n    /** @hide */\n    protected void dumpOnHandler(FileDescriptor fd, PrintWriter pw, String[] args) {\n        pw.print(mTag + \": \");\n        if (mFinished) {\n            pw.println(\"stopped\");\n        } else {\n            pw.println(\"running (dreamToken=\" + mDreamToken + \")\");\n        }\n        pw.println(\"  window: \" + mWindow);\n        pw.print(\"  flags:\");\n        if (isInteractive()) pw.print(\" interactive\");\n        if (isFullscreen()) pw.print(\" fullscreen\");\n        if (isScreenBright()) pw.print(\" bright\");\n        if (isWindowless()) pw.print(\" windowless\");\n        if (isDozing()) pw.print(\" dozing\");\n        else if (canDoze()) pw.print(\" candoze\");\n        pw.println();\n        if (canDoze()) {\n            pw.println(\"  doze screen state: \" + Display.stateToString(mDozeScreenState));\n            pw.println(\"  doze screen brightness: \" + mDozeScreenBrightness);\n        }\n    }\n\n    private static int clampAbsoluteBrightness(int value) {\n        return MathUtils.constrain(value, PowerManager.BRIGHTNESS_OFF, PowerManager.BRIGHTNESS_ON);\n    }\n\n    /**\n     * The DreamServiceWrapper is used as a gateway to the system_server, where DreamController\n     * uses it to control the DreamService. It is also used to receive callbacks from the\n     * DreamActivity.\n     */\n    final class DreamServiceWrapper extends IDreamService.Stub {\n        @Override\n        public void attach(final IBinder dreamToken, final boolean canDoze,\n                IRemoteCallback started) {\n            mHandler.post(() -> DreamService.this.attach(dreamToken, canDoze, started));\n        }\n\n        @Override\n        public void detach() {\n            mHandler.post(DreamService.this::detach);\n        }\n\n        @Override\n        public void wakeUp() {\n            mHandler.post(() -> DreamService.this.wakeUp(true /*fromSystem*/));\n        }\n    }\n\n    /** @hide */\n    final class DreamActivityCallback extends Binder {\n        private final IBinder mActivityDreamToken;\n\n        DreamActivityCallback(IBinder token) {\n            mActivityDreamToken = token;\n        }\n\n        void onActivityCreated(DreamActivity activity) {\n            if (mActivityDreamToken != mDreamToken || mFinished) {\n                Slog.d(TAG, \"DreamActivity was created after the dream was finished or \"\n                        + \"a new dream started, finishing DreamActivity\");\n                if (!activity.isFinishing()) {\n                    activity.finishAndRemoveTask();\n                }\n                return;\n            }\n            if (mActivity != null) {\n                Slog.w(TAG, \"A DreamActivity has already been started, \"\n                        + \"finishing latest DreamActivity\");\n                if (!activity.isFinishing()) {\n                    activity.finishAndRemoveTask();\n                }\n                return;\n            }\n\n            mActivity = activity;\n            onWindowCreated(activity.getWindow());\n        }\n    }\n\n    /**\n     * Represents metadata defined in {@link android.R.styleable#Dream &lt;dream&gt;}.\n     *\n     * @hide\n     */\n    @TestApi\n    public static final class DreamMetadata {\n        @Nullable\n        public final ComponentName settingsActivity;\n\n        @Nullable\n        public final Drawable previewImage;\n\n        @NonNull\n        public final boolean showComplications;\n\n        DreamMetadata(ComponentName settingsActivity, Drawable previewImage,\n                boolean showComplications) {\n            this.settingsActivity = settingsActivity;\n            this.previewImage = previewImage;\n            this.showComplications = showComplications;\n        }\n    }\n}\n```",
            "upstream_file_tokens": {
              "openai": 11711,
              "general": {
                "word_based": 5538,
                "char_based": 13777
              },
              "gemini": 13587
            },
            "downstream_file_content": "```java\n/**\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage android.service.dreams;\n\nimport android.annotation.IdRes;\nimport android.annotation.LayoutRes;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.SdkConstant;\nimport android.annotation.SdkConstant.SdkConstantType;\nimport android.annotation.TestApi;\nimport android.app.Activity;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.Service;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.Intent;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.IRemoteCallback;\nimport android.os.Looper;\nimport android.os.PowerManager;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.util.Log;\nimport android.util.MathUtils;\nimport android.util.Slog;\nimport android.view.ActionMode;\nimport android.view.Display;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SearchEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.WindowManager.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.DumpUtils.Dump;\n\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\n\n/**\n * Extend this class to implement a custom dream (available to the user as a \"Daydream\").\n *\n * <p>Dreams are interactive screensavers launched when a charging device is idle, or docked in a\n * desk dock. Dreams provide another modality for apps to express themselves, tailored for\n * an exhibition/lean-back experience.</p>\n *\n * <p>The {@code DreamService} lifecycle is as follows:</p>\n * <ol>\n *   <li>{@link #onAttachedToWindow}\n *     <p>Use this for initial setup, such as calling {@link #setContentView setContentView()}.</li>\n *   <li>{@link #onDreamingStarted}\n *     <p>Your dream has started, so you should begin animations or other behaviors here.</li>\n *   <li>{@link #onDreamingStopped}\n *     <p>Use this to stop the things you started in {@link #onDreamingStarted}.</li>\n *   <li>{@link #onDetachedFromWindow}\n *     <p>Use this to dismantle resources (for example, detach from handlers\n *        and listeners).</li>\n * </ol>\n *\n * <p>In addition, onCreate and onDestroy (from the Service interface) will also be called, but\n * initialization and teardown should be done by overriding the hooks above.</p>\n *\n * <p>To be available to the system, your {@code DreamService} should be declared in the\n * manifest as follows:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\" >\n *\n *     &lt;intent-filter>\n *         &lt;action android:name=\"android.service.dreams.DreamService\" />\n *         &lt;category android:name=\"android.intent.category.DEFAULT\" />\n *     &lt;/intent-filter>\n *\n *     &lt;!-- Point to additional information for this dream (optional) -->\n *     &lt;meta-data\n *         android:name=\"android.service.dream\"\n *         android:resource=\"@xml/my_dream\" />\n * &lt;/service>\n * </pre>\n *\n * <p>If specified with the {@code <meta-data>} element,\n * additional information for the dream is defined using the\n * {@link android.R.styleable#Dream &lt;dream&gt;} element in a separate XML file.\n * Currently, the only addtional\n * information you can provide is for a settings activity that allows the user to configure\n * the dream behavior. For example:</p>\n * <p class=\"code-caption\">res/xml/my_dream.xml</p>\n * <pre>\n * &lt;dream xmlns:android=\"http://schemas.android.com/apk/res/android\"\n *     android:settingsActivity=\"com.example.app/.MyDreamSettingsActivity\" />\n * </pre>\n * <p>This makes a Settings button available alongside your dream's listing in the\n * system settings, which when pressed opens the specified activity.</p>\n *\n *\n * <p>To specify your dream layout, call {@link #setContentView}, typically during the\n * {@link #onAttachedToWindow} callback. For example:</p>\n * <pre>\n * public class MyDream extends DreamService {\n *\n *     &#64;Override\n *     public void onAttachedToWindow() {\n *         super.onAttachedToWindow();\n *\n *         // Exit dream upon user touch\n *         setInteractive(false);\n *         // Hide system UI\n *         setFullscreen(true);\n *         // Set the dream layout\n *         setContentView(R.layout.dream);\n *     }\n * }\n * </pre>\n *\n * <p>When targeting api level 21 and above, you must declare the service in your manifest file\n * with the {@link android.Manifest.permission#BIND_DREAM_SERVICE} permission. For example:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\"\n *     android:permission=\"android.permission.BIND_DREAM_SERVICE\">\n *   &lt;intent-filter>\n *     &lt;action android:name=\u201dandroid.service.dreams.DreamService\u201d />\n *     &lt;category android:name=\u201dandroid.intent.category.DEFAULT\u201d />\n *   &lt;/intent-filter>\n * &lt;/service>\n * </pre>\n */\npublic class DreamService extends Service implements Window.Callback {\n    private final String TAG = DreamService.class.getSimpleName() + \"[\" + getClass().getSimpleName() + \"]\";\n\n    /**\n     * The name of the dream manager service.\n     * @hide\n     */\n    public static final String DREAM_SERVICE = \"dreams\";\n\n    /**\n     * The {@link Intent} that must be declared as handled by the service.\n     */\n    @SdkConstant(SdkConstantType.SERVICE_ACTION)\n    public static final String SERVICE_INTERFACE =\n            \"android.service.dreams.DreamService\";\n\n    /**\n     * Name under which a Dream publishes information about itself.\n     * This meta-data must reference an XML resource containing\n     * a <code>&lt;{@link android.R.styleable#Dream dream}&gt;</code>\n     * tag.\n     */\n    public static final String DREAM_META_DATA = \"android.service.dream\";\n\n    private final IDreamManager mDreamManager;\n    private final Handler mHandler = new Handler(Looper.getMainLooper());\n    private IBinder mDreamToken;\n    private Window mWindow;\n    private Activity mActivity;\n    private boolean mInteractive;\n    private boolean mFullscreen;\n    private boolean mScreenBright = true;\n    private boolean mStarted;\n    private boolean mWaking;\n    private boolean mFinished;\n    private boolean mCanDoze;\n    private boolean mDozing;\n    private boolean mWindowless;\n    private int mDozeScreenState = Display.STATE_UNKNOWN;\n    private int mDozeScreenBrightness = PowerManager.BRIGHTNESS_DEFAULT;\n\n    private boolean mDebug = false;\n\n    private DreamServiceWrapper mDreamServiceWrapper;\n    private Runnable mDispatchAfterOnAttachedToWindow;\n\n    public DreamService() {\n        mDreamManager = IDreamManager.Stub.asInterface(ServiceManager.getService(DREAM_SERVICE));\n    }\n\n    /**\n     * @hide\n     */\n    public void setDebug(boolean dbg) {\n        mDebug = dbg;\n    }\n\n    // begin Window.Callback methods\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyEvent\");\n            wakeUp();\n            return true;\n        } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {\n            if (mDebug) Slog.v(TAG, \"Waking up on back key\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyShortcutEvent(KeyEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyShortcutEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyShortcutEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // TODO: create more flexible version of mInteractive that allows clicks\n        // but finish()es on any other kind of activity\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on touchEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTouchEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTrackballEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on trackballEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTrackballEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchGenericMotionEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on genericMotionEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchGenericMotionEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public View onCreatePanelView(int featureId) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onCreatePanelMenu(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onPreparePanel(int featureId, View view, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuOpened(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowAttributesChanged(LayoutParams attrs) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onContentChanged() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowFocusChanged(boolean hasFocus) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onAttachedToWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDetachedFromWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onPanelClosed(int featureId, Menu menu) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested(SearchEvent event) {\n        return onSearchRequested();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested() {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(\n            android.view.ActionMode.Callback callback, int type) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeStarted(ActionMode mode) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeFinished(ActionMode mode) {\n    }\n    // end Window.Callback methods\n\n    // begin public api\n    /**\n     * Retrieves the current {@link android.view.WindowManager} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindowManager()}.\n     *\n     * @return The current window manager, or null if the dream is not started.\n     */\n    public WindowManager getWindowManager() {\n        return mWindow != null ? mWindow.getWindowManager() : null;\n    }\n\n    /**\n     * Retrieves the current {@link android.view.Window} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindow()}.\n     *\n     * @return The current window, or null if the dream is not started.\n     */\n    public Window getWindow() {\n        return mWindow;\n    }\n\n   /**\n     * Inflates a layout resource and set it to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(int)}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param layoutResID Resource ID to be inflated.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(android.view.View)} in an activity,\n     * including using {@link ViewGroup.LayoutParams#MATCH_PARENT} as the layout height and width of the view.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @see #setContentView(int)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(View view) {\n        getWindow().setContentView(view);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to\n     * {@link android.app.Activity#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)}\n     * in an activity.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(int)\n     */\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().setContentView(view, params);\n    }\n\n    /**\n     * Adds a view to the Dream's window, leaving other content views in place.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     */\n    public void addContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().addContentView(view, params);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that\n     * was processed in {@link #onCreate}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return The view if found or null otherwise.\n     * @see View#findViewById(int)\n     * @see DreamService#requireViewById(int)\n     */\n    @Nullable\n    public <T extends View> T findViewById(@IdRes int id) {\n        return getWindow().findViewById(id);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that was processed in\n     * {@link #onCreate}, or throws an IllegalArgumentException if the ID is invalid or there is no\n     * matching view in the hierarchy.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return a view with given ID\n     * @see View#requireViewById(int)\n     * @see DreamService#findViewById(int)\n     */\n    @NonNull\n    public final <T extends View> T requireViewById(@IdRes int id) {\n        T view = findViewById(id);\n        if (view == null) {\n            throw new IllegalArgumentException(\n                    \"ID does not reference a View inside this DreamService\");\n        }\n        return view;\n    }\n\n    /**\n     * Marks this dream as interactive to receive input events.\n     *\n     * <p>Non-interactive dreams (default) will dismiss on the first input event.</p>\n     *\n     * <p>Interactive dreams should call {@link #finish()} to dismiss themselves.</p>\n     *\n     * @param interactive True if this dream will handle input events.\n     */\n    public void setInteractive(boolean interactive) {\n        mInteractive = interactive;\n    }\n\n    /**\n     * Returns whether or not this dream is interactive.  Defaults to false.\n     *\n     * @see #setInteractive(boolean)\n     */\n    public boolean isInteractive() {\n        return mInteractive;\n    }\n\n    /**\n     * Controls {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN}\n     * on the dream's window.\n     *\n     * @param fullscreen If true, the fullscreen flag will be set; else it\n     * will be cleared.\n     */\n    public void setFullscreen(boolean fullscreen) {\n        if (mFullscreen != fullscreen) {\n            mFullscreen = fullscreen;\n            int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;\n            applyWindowFlags(mFullscreen ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream is in fullscreen mode. Defaults to false.\n     *\n     * @see #setFullscreen(boolean)\n     */\n    public boolean isFullscreen() {\n        return mFullscreen;\n    }\n\n    /**\n     * Marks this dream as keeping the screen bright while dreaming.\n     *\n     * @param screenBright True to keep the screen bright while dreaming.\n     */\n    public void setScreenBright(boolean screenBright) {\n        if (mScreenBright != screenBright) {\n            mScreenBright = screenBright;\n            int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;\n            applyWindowFlags(mScreenBright ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream keeps the screen bright while dreaming.\n     * Defaults to false, allowing the screen to dim if necessary.\n     *\n     * @see #setScreenBright(boolean)\n     */\n    public boolean isScreenBright() {\n        return getWindowFlagValue(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, mScreenBright);\n    }\n\n    /**\n     * Marks this dream as windowless.  Only available to doze dreams.\n     *\n     * @hide\n     *\n     */\n    public void setWindowless(boolean windowless) {\n        mWindowless = windowless;\n    }\n\n    /**\n     * Returns whether or not this dream is windowless.  Only available to doze dreams.\n     *\n     * @hide\n     */\n    public boolean isWindowless() {\n        return mWindowless;\n    }\n\n    /**\n     * Returns true if this dream is allowed to doze.\n     * <p>\n     * The value returned by this method is only meaningful when the dream has started.\n     * </p>\n     *\n     * @return True if this dream can doze.\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean canDoze() {\n        return mCanDoze;\n    }\n\n    /**\n     * Starts dozing, entering a deep dreamy sleep.\n     * <p>\n     * Dozing enables the system to conserve power while the user is not actively interacting\n     * with the device.  While dozing, the display will remain on in a low-power state\n     * and will continue to show its previous contents but the application processor and\n     * other system components will be allowed to suspend when possible.\n     * </p><p>\n     * While the application processor is suspended, the dream may stop executing code\n     * for long periods of time.  Prior to being suspended, the dream may schedule periodic\n     * wake-ups to render new content by scheduling an alarm with the {@link AlarmManager}.\n     * The dream may also keep the CPU awake by acquiring a\n     * {@link android.os.PowerManager#PARTIAL_WAKE_LOCK partial wake lock} when necessary.\n     * Note that since the purpose of doze mode is to conserve power (especially when\n     * running on battery), the dream should not wake the CPU very often or keep it\n     * awake for very long.\n     * </p><p>\n     * It is a good idea to call this method some time after the dream's entry animation\n     * has completed and the dream is ready to doze.  It is important to completely\n     * finish all of the work needed before dozing since the application processor may\n     * be suspended at any moment once this method is called unless other wake locks\n     * are being held.\n     * </p><p>\n     * Call {@link #stopDozing} or {@link #finish} to stop dozing.\n     * </p>\n     *\n     * @see #stopDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void startDozing() {\n        if (mCanDoze && !mDozing) {\n            mDozing = true;\n            updateDoze();\n        }\n    }\n\n    private void updateDoze() {\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Updating doze without a dream token.\");\n            return;\n        }\n\n        if (mDozing) {\n            try {\n                mDreamManager.startDozing(mDreamToken, mDozeScreenState, mDozeScreenBrightness);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Stops dozing, returns to active dreaming.\n     * <p>\n     * This method reverses the effect of {@link #startDozing}.  From this moment onward,\n     * the application processor will be kept awake as long as the dream is running\n     * or until the dream starts dozing again.\n     * </p>\n     *\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public void stopDozing() {\n        if (mDozing) {\n            mDozing = false;\n            try {\n                mDreamManager.stopDozing(mDreamToken);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Returns true if the dream will allow the system to enter a low-power state while\n     * it is running without actually turning off the screen.  Defaults to false,\n     * keeping the application processor awake while the dream is running.\n     *\n     * @return True if the dream is dozing.\n     *\n     * @see #setDozing(boolean)\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean isDozing() {\n        return mDozing;\n    }\n\n    /**\n     * Gets the screen state to use while dozing.\n     *\n     * @return The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @see #setDozeScreenState\n     * @hide For use by system UI components only.\n     */\n    public int getDozeScreenState() {\n        return mDozeScreenState;\n    }\n\n    /**\n     * Sets the screen state to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link Display#STATE_UNKNOWN} which lets the system decide.\n     * The dream may set a different state before starting to doze and may\n     * perform transitions between states while dozing to conserve power and\n     * achieve various effects.\n     * </p><p>\n     * Some devices will have dedicated hardware (\"Sidekick\") to animate\n     * the display content while the CPU sleeps. If the dream and the hardware support\n     * this, {@link Display#STATE_ON_SUSPEND} or {@link Display#STATE_DOZE_SUSPEND}\n     * will switch control to the Sidekick.\n     * </p><p>\n     * If not using Sidekick, it is recommended that the state be set to\n     * {@link Display#STATE_DOZE_SUSPEND} once the dream has completely\n     * finished drawing and before it releases its wakelock\n     * to allow the display hardware to be fully suspended.  While suspended,\n     * the display will preserve its on-screen contents.\n     * </p><p>\n     * If the doze suspend state is used, the dream must make sure to set the mode back\n     * to {@link Display#STATE_DOZE} or {@link Display#STATE_ON} before drawing again\n     * since the display updates may be ignored and not seen by the user otherwise.\n     * </p><p>\n     * The set of available display power states and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param state The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenState(int state) {\n        if (mDozeScreenState != state) {\n            mDozeScreenState = state;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Gets the screen brightness to use while dozing.\n     *\n     * @return The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @see #setDozeScreenBrightness\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public int getDozeScreenBrightness() {\n        return mDozeScreenBrightness;\n    }\n\n    /**\n     * Sets the screen brightness to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link PowerManager#BRIGHTNESS_DEFAULT} which lets the system decide.\n     * The dream may set a different brightness before starting to doze and may adjust\n     * the brightness while dozing to conserve power and achieve various effects.\n     * </p><p>\n     * Note that dream may specify any brightness in the full 0-255 range, including\n     * values that are less than the minimum value for manual screen brightness\n     * adjustments by the user.  In particular, the value may be set to 0 which may\n     * turn off the backlight entirely while still leaving the screen on although\n     * this behavior is device dependent and not guaranteed.\n     * </p><p>\n     * The available range of display brightness values and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param brightness The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenBrightness(int brightness) {\n        if (brightness != PowerManager.BRIGHTNESS_DEFAULT) {\n            brightness = clampAbsoluteBrightness(brightness);\n        }\n        if (mDozeScreenBrightness != brightness) {\n            mDozeScreenBrightness = brightness;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Called when this Dream is constructed.\n     */\n    @Override\n    public void onCreate() {\n        if (mDebug) Slog.v(TAG, \"onCreate()\");\n        super.onCreate();\n    }\n\n    /**\n     * Called when the dream's window has been created and is visible and animation may now begin.\n     */\n    public void onDreamingStarted() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStarted()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when this Dream is stopped, either by external request or by calling finish(),\n     * before the window has been removed.\n     */\n    public void onDreamingStopped() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStopped()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when the dream is being asked to stop itself and wake.\n     * <p>\n     * The default implementation simply calls {@link #finish} which ends the dream\n     * immediately.  Subclasses may override this function to perform a smooth exit\n     * transition then call {@link #finish} afterwards.\n     * </p><p>\n     * Note that the dream will only be given a short period of time (currently about\n     * five seconds) to wake up.  If the dream does not finish itself in a timely manner\n     * then the system will forcibly finish it once the time allowance is up.\n     * </p>\n     */\n    public void onWakeUp() {\n        finish();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public final IBinder onBind(Intent intent) {\n        if (mDebug) Slog.v(TAG, \"onBind() intent = \" + intent);\n        mDreamServiceWrapper = new DreamServiceWrapper();\n        return mDreamServiceWrapper;\n    }\n\n    /**\n     * Stops the dream and detaches from the window.\n     * <p>\n     * When the dream ends, the system will be allowed to go to sleep fully unless there\n     * is a reason for it to be awake such as recent user activity or wake locks being held.\n     * </p>\n     */\n    public final void finish() {\n        if (mDebug) Slog.v(TAG, \"finish(): mFinished=\" + mFinished);\n\n        Activity activity = mActivity;\n        if (activity != null) {\n            if (!activity.isFinishing()) {\n                // In case the activity is not finished yet, do it now.\n                activity.finishAndRemoveTask();\n            }\n            return;\n        }\n\n        if (mFinished) {\n            return;\n        }\n        mFinished = true;\n\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Finish was called before the dream was attached.\");\n            stopSelf();\n            return;\n        }\n\n        try {\n            // finishSelf will unbind the dream controller from the dream service. This will\n            // trigger DreamService.this.onDestroy and DreamService.this will die.\n            mDreamManager.finishSelf(mDreamToken, true /*immediate*/);\n        } catch (RemoteException ex) {\n            // system server died\n        }\n    }\n\n    /**\n     * Wakes the dream up gently.\n     * <p>\n     * Calls {@link #onWakeUp} to give the dream a chance to perform an exit transition.\n     * When the transition is over, the dream should call {@link #finish}.\n     * </p>\n     */\n    public final void wakeUp() {\n        wakeUp(false);\n    }\n\n    private void wakeUp(boolean fromSystem) {\n        if (mDebug) Slog.v(TAG, \"wakeUp(): fromSystem=\" + fromSystem\n                + \", mWaking=\" + mWaking + \", mFinished=\" + mFinished);\n\n        if (!mWaking && !mFinished) {\n            mWaking = true;\n\n            // As a minor optimization, invoke the callback first in case it simply\n            // calls finish() immediately so there wouldn't be much point in telling\n            // the system that we are finishing the dream gently.\n            onWakeUp();\n\n            // Now tell the system we are waking gently, unless we already told\n            // it we were finishing immediately.\n            if (!fromSystem && !mFinished) {\n                if (mActivity == null) {\n                    Slog.w(TAG, \"WakeUp was called before the dream was attached.\");\n                } else {\n                    try {\n                        mDreamManager.finishSelf(mDreamToken, false /*immediate*/);\n                    } catch (RemoteException ex) {\n                        // system server died\n                    }\n                }\n            }\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDestroy() {\n        if (mDebug) Slog.v(TAG, \"onDestroy()\");\n        // hook for subclasses\n\n        // Just in case destroy came in before detach, let's take care of that now\n        detach();\n\n        super.onDestroy();\n    }\n\n    // end public api\n\n    /**\n     * Called by DreamController.stopDream() when the Dream is about to be unbound and destroyed.\n     *\n     * Must run on mHandler.\n     */\n    private final void detach() {\n        if (mStarted) {\n            if (mDebug) Slog.v(TAG, \"detach(): Calling onDreamingStopped()\");\n            mStarted = false;\n            onDreamingStopped();\n        }\n\n        if (mActivity != null && !mActivity.isFinishing()) {\n            mActivity.finishAndRemoveTask();\n        } else {\n            finish();\n        }\n\n        mDreamToken = null;\n        mCanDoze = false;\n    }\n\n    /**\n     * Called when the Dream is ready to be shown.\n     *\n     * Must run on mHandler.\n     *\n     * @param dreamToken Token for this dream service.\n     * @param started A callback that will be invoked once onDreamingStarted has completed.\n     */\n    private void attach(IBinder dreamToken, boolean canDoze, IRemoteCallback started) {\n        if (mDreamToken != null) {\n            Slog.e(TAG, \"attach() called when dream with token=\" + mDreamToken\n                    + \" already attached\");\n            return;\n        }\n        if (mFinished || mWaking) {\n            Slog.w(TAG, \"attach() called after dream already finished\");\n            try {\n                mDreamManager.finishSelf(dreamToken, true /*immediate*/);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n            return;\n        }\n\n        mDreamToken = dreamToken;\n        mCanDoze = canDoze;\n        if (mWindowless && !mCanDoze) {\n            throw new IllegalStateException(\"Only doze dreams can be windowless\");\n        }\n\n        mDispatchAfterOnAttachedToWindow = () -> {\n            if (mWindow != null || mWindowless) {\n                mStarted = true;\n                try {\n                    onDreamingStarted();\n                } finally {\n                    try {\n                        started.sendResult(null);\n                    } catch (RemoteException e) {\n                        throw e.rethrowFromSystemServer();\n                    }\n                }\n            }\n        };\n\n        // We need to defer calling onDreamingStarted until after the activity is created.\n        // If the dream is windowless, we can call it immediately. Otherwise, we wait\n        // for the DreamActivity to report onActivityCreated via\n        // DreamServiceWrapper.onActivityCreated.\n        if (!mWindowless) {\n            Intent i = new Intent(this, DreamActivity.class);\n            i.setPackage(getApplicationContext().getPackageName());\n            i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            i.putExtra(DreamActivity.EXTRA_CALLBACK, mDreamServiceWrapper);\n\n            try {\n                if (!ActivityTaskManager.getService().startDreamActivity(i)) {\n                    detach();\n                    return;\n                }\n            } catch (RemoteException e) {\n                Log.w(TAG, \"Could not connect to activity task manager to start dream activity\");\n                e.rethrowFromSystemServer();\n            }\n        } else {\n            mDispatchAfterOnAttachedToWindow.run();\n        }\n    }\n\n    private void onWindowCreated(Window w) {\n        mWindow = w;\n        mWindow.setCallback(this);\n        mWindow.requestFeature(Window.FEATURE_NO_TITLE);\n\n        WindowManager.LayoutParams lp = mWindow.getAttributes();\n        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN\n                    | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR\n                    | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED\n                    | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD\n                    | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON\n                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED\n                    | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0)\n                    | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0)\n                    );\n        mWindow.setAttributes(lp);\n        // Workaround: Currently low-profile and in-window system bar backgrounds don't go\n        // along well. Dreams usually don't need such bars anyways, so disable them by default.\n        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n\n        mWindow.getDecorView().addOnAttachStateChangeListener(\n                new View.OnAttachStateChangeListener() {\n                    @Override\n                    public void onViewAttachedToWindow(View v) {\n                        mDispatchAfterOnAttachedToWindow.run();\n                    }\n\n                    @Override\n                    public void onViewDetachedFromWindow(View v) {\n                        if (mActivity == null || !mActivity.isChangingConfigurations()) {\n                            // Only stop the dream if the view is not detached by relaunching\n                            // activity for configuration changes.\n                            mActivity = null;\n                            finish();\n                        }\n                    }\n                });\n    }\n\n    private boolean getWindowFlagValue(int flag, boolean defaultValue) {\n        return mWindow == null ? defaultValue : (mWindow.getAttributes().flags & flag) != 0;\n    }\n\n    private void applyWindowFlags(int flags, int mask) {\n        if (mWindow != null) {\n            WindowManager.LayoutParams lp = mWindow.getAttributes();\n            lp.flags = applyFlags(lp.flags, flags, mask);\n            mWindow.setAttributes(lp);\n            mWindow.getWindowManager().updateViewLayout(mWindow.getDecorView(), lp);\n        }\n    }\n\n    private int applyFlags(int oldFlags, int flags, int mask) {\n        return (oldFlags&~mask) | (flags&mask);\n    }\n\n    @Override\n    protected void dump(final FileDescriptor fd, PrintWriter pw, final String[] args) {\n        DumpUtils.dumpAsync(mHandler, new Dump() {\n            @Override\n            public void dump(PrintWriter pw, String prefix) {\n                dumpOnHandler(fd, pw, args);\n            }\n        }, pw, \"\", 1000);\n    }\n\n    /** @hide */\n    protected void dumpOnHandler(FileDescriptor fd, PrintWriter pw, String[] args) {\n        pw.print(TAG + \": \");\n        if (mFinished) {\n            pw.println(\"stopped\");\n        } else {\n            pw.println(\"running (dreamToken=\" + mDreamToken + \")\");\n        }\n        pw.println(\"  window: \" + mWindow);\n        pw.print(\"  flags:\");\n        if (isInteractive()) pw.print(\" interactive\");\n        if (isFullscreen()) pw.print(\" fullscreen\");\n        if (isScreenBright()) pw.print(\" bright\");\n        if (isWindowless()) pw.print(\" windowless\");\n        if (isDozing()) pw.print(\" dozing\");\n        else if (canDoze()) pw.print(\" candoze\");\n        pw.println();\n        if (canDoze()) {\n            pw.println(\"  doze screen state: \" + Display.stateToString(mDozeScreenState));\n            pw.println(\"  doze screen brightness: \" + mDozeScreenBrightness);\n        }\n    }\n\n    private static int clampAbsoluteBrightness(int value) {\n        return MathUtils.constrain(value, PowerManager.BRIGHTNESS_OFF, PowerManager.BRIGHTNESS_ON);\n    }\n\n    /**\n     * The DreamServiceWrapper is used as a gateway to the system_server, where DreamController\n     * uses it to control the DreamService. It is also used to receive callbacks from the\n     * DreamActivity.\n     */\n    final class DreamServiceWrapper extends IDreamService.Stub {\n        @Override\n        public void attach(final IBinder dreamToken, final boolean canDoze,\n                IRemoteCallback started) {\n            mHandler.post(() -> DreamService.this.attach(dreamToken, canDoze, started));\n        }\n\n        @Override\n        public void detach() {\n            mHandler.post(DreamService.this::detach);\n        }\n\n        @Override\n        public void wakeUp() {\n            mHandler.post(() -> DreamService.this.wakeUp(true /*fromSystem*/));\n        }\n\n        /** @hide */\n        void onActivityCreated(DreamActivity a) {\n            mActivity = a;\n            onWindowCreated(a.getWindow());\n        }\n    }\n}\n```",
            "downstream_file_tokens": {
              "openai": 9213,
              "general": {
                "word_based": 4398,
                "char_based": 10396
              },
              "gemini": 10611
            },
            "downstream_file_content_ground_truth": "/**\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage android.service.dreams;\n\nimport android.annotation.IdRes;\nimport android.annotation.LayoutRes;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.SdkConstant;\nimport android.annotation.SdkConstant.SdkConstantType;\nimport android.app.Activity;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.Service;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.Intent;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.IRemoteCallback;\nimport android.os.Looper;\nimport android.os.PowerManager;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.util.Log;\nimport android.util.MathUtils;\nimport android.util.Slog;\nimport android.view.ActionMode;\nimport android.view.Display;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SearchEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.WindowManager.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.DumpUtils.Dump;\n\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\n\n/**\n * Extend this class to implement a custom dream (available to the user as a \"Daydream\").\n *\n * <p>Dreams are interactive screensavers launched when a charging device is idle, or docked in a\n * desk dock. Dreams provide another modality for apps to express themselves, tailored for\n * an exhibition/lean-back experience.</p>\n *\n * <p>The {@code DreamService} lifecycle is as follows:</p>\n * <ol>\n *   <li>{@link #onAttachedToWindow}\n *     <p>Use this for initial setup, such as calling {@link #setContentView setContentView()}.</li>\n *   <li>{@link #onDreamingStarted}\n *     <p>Your dream has started, so you should begin animations or other behaviors here.</li>\n *   <li>{@link #onDreamingStopped}\n *     <p>Use this to stop the things you started in {@link #onDreamingStarted}.</li>\n *   <li>{@link #onDetachedFromWindow}\n *     <p>Use this to dismantle resources (for example, detach from handlers\n *        and listeners).</li>\n * </ol>\n *\n * <p>In addition, onCreate and onDestroy (from the Service interface) will also be called, but\n * initialization and teardown should be done by overriding the hooks above.</p>\n *\n * <p>To be available to the system, your {@code DreamService} should be declared in the\n * manifest as follows:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\" >\n *\n *     &lt;intent-filter>\n *         &lt;action android:name=\"android.service.dreams.DreamService\" />\n *         &lt;category android:name=\"android.intent.category.DEFAULT\" />\n *     &lt;/intent-filter>\n *\n *     &lt;!-- Point to additional information for this dream (optional) -->\n *     &lt;meta-data\n *         android:name=\"android.service.dream\"\n *         android:resource=\"@xml/my_dream\" />\n * &lt;/service>\n * </pre>\n *\n * <p>If specified with the {@code <meta-data>} element,\n * additional information for the dream is defined using the\n * {@link android.R.styleable#Dream &lt;dream&gt;} element in a separate XML file.\n * Currently, the only addtional\n * information you can provide is for a settings activity that allows the user to configure\n * the dream behavior. For example:</p>\n * <p class=\"code-caption\">res/xml/my_dream.xml</p>\n * <pre>\n * &lt;dream xmlns:android=\"http://schemas.android.com/apk/res/android\"\n *     android:settingsActivity=\"com.example.app/.MyDreamSettingsActivity\" />\n * </pre>\n * <p>This makes a Settings button available alongside your dream's listing in the\n * system settings, which when pressed opens the specified activity.</p>\n *\n *\n * <p>To specify your dream layout, call {@link #setContentView}, typically during the\n * {@link #onAttachedToWindow} callback. For example:</p>\n * <pre>\n * public class MyDream extends DreamService {\n *\n *     &#64;Override\n *     public void onAttachedToWindow() {\n *         super.onAttachedToWindow();\n *\n *         // Exit dream upon user touch\n *         setInteractive(false);\n *         // Hide system UI\n *         setFullscreen(true);\n *         // Set the dream layout\n *         setContentView(R.layout.dream);\n *     }\n * }\n * </pre>\n *\n * <p>When targeting api level 21 and above, you must declare the service in your manifest file\n * with the {@link android.Manifest.permission#BIND_DREAM_SERVICE} permission. For example:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\"\n *     android:permission=\"android.permission.BIND_DREAM_SERVICE\">\n *   &lt;intent-filter>\n *     &lt;action android:name=\u201dandroid.service.dreams.DreamService\u201d />\n *     &lt;category android:name=\u201dandroid.intent.category.DEFAULT\u201d />\n *   &lt;/intent-filter>\n * &lt;/service>\n * </pre>\n */\npublic class DreamService extends Service implements Window.Callback {\n    private final String TAG = DreamService.class.getSimpleName() + \"[\" + getClass().getSimpleName() + \"]\";\n\n    /**\n     * The name of the dream manager service.\n     * @hide\n     */\n    public static final String DREAM_SERVICE = \"dreams\";\n\n    /**\n     * The {@link Intent} that must be declared as handled by the service.\n     */\n    @SdkConstant(SdkConstantType.SERVICE_ACTION)\n    public static final String SERVICE_INTERFACE =\n            \"android.service.dreams.DreamService\";\n\n    /**\n     * Name under which a Dream publishes information about itself.\n     * This meta-data must reference an XML resource containing\n     * a <code>&lt;{@link android.R.styleable#Dream dream}&gt;</code>\n     * tag.\n     */\n    public static final String DREAM_META_DATA = \"android.service.dream\";\n\n    private final IDreamManager mDreamManager;\n    private final Handler mHandler = new Handler(Looper.getMainLooper());\n    private IBinder mDreamToken;\n    private Window mWindow;\n    private Activity mActivity;\n    private boolean mInteractive;\n    private boolean mFullscreen;\n    private boolean mScreenBright = true;\n    private boolean mStarted;\n    private boolean mWaking;\n    private boolean mFinished;\n    private boolean mCanDoze;\n    private boolean mDozing;\n    private boolean mWindowless;\n    private int mDozeScreenState = Display.STATE_UNKNOWN;\n    private int mDozeScreenBrightness = PowerManager.BRIGHTNESS_DEFAULT;\n\n    private boolean mDebug = false;\n\n    private DreamServiceWrapper mDreamServiceWrapper;\n    private Runnable mDispatchAfterOnAttachedToWindow;\n\n    public DreamService() {\n        mDreamManager = IDreamManager.Stub.asInterface(ServiceManager.getService(DREAM_SERVICE));\n    }\n\n    /**\n     * @hide\n     */\n    public void setDebug(boolean dbg) {\n        mDebug = dbg;\n    }\n\n    // begin Window.Callback methods\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyEvent\");\n            wakeUp();\n            return true;\n        } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {\n            if (mDebug) Slog.v(TAG, \"Waking up on back key\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyShortcutEvent(KeyEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyShortcutEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyShortcutEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // TODO: create more flexible version of mInteractive that allows clicks\n        // but finish()es on any other kind of activity\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on touchEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTouchEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTrackballEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on trackballEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTrackballEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchGenericMotionEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on genericMotionEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchGenericMotionEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public View onCreatePanelView(int featureId) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onCreatePanelMenu(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onPreparePanel(int featureId, View view, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuOpened(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowAttributesChanged(LayoutParams attrs) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onContentChanged() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowFocusChanged(boolean hasFocus) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onAttachedToWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDetachedFromWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onPanelClosed(int featureId, Menu menu) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested(SearchEvent event) {\n        return onSearchRequested();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested() {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(\n            android.view.ActionMode.Callback callback, int type) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeStarted(ActionMode mode) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeFinished(ActionMode mode) {\n    }\n    // end Window.Callback methods\n\n    // begin public api\n    /**\n     * Retrieves the current {@link android.view.WindowManager} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindowManager()}.\n     *\n     * @return The current window manager, or null if the dream is not started.\n     */\n    public WindowManager getWindowManager() {\n        return mWindow != null ? mWindow.getWindowManager() : null;\n    }\n\n    /**\n     * Retrieves the current {@link android.view.Window} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindow()}.\n     *\n     * @return The current window, or null if the dream is not started.\n     */\n    public Window getWindow() {\n        return mWindow;\n    }\n\n   /**\n     * Inflates a layout resource and set it to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(int)}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param layoutResID Resource ID to be inflated.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(android.view.View)} in an activity,\n     * including using {@link ViewGroup.LayoutParams#MATCH_PARENT} as the layout height and width of the view.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @see #setContentView(int)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(View view) {\n        getWindow().setContentView(view);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to\n     * {@link android.app.Activity#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)}\n     * in an activity.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(int)\n     */\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().setContentView(view, params);\n    }\n\n    /**\n     * Adds a view to the Dream's window, leaving other content views in place.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     */\n    public void addContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().addContentView(view, params);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that\n     * was processed in {@link #onCreate}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return The view if found or null otherwise.\n     * @see View#findViewById(int)\n     * @see DreamService#requireViewById(int)\n     */\n    @Nullable\n    public <T extends View> T findViewById(@IdRes int id) {\n        return getWindow().findViewById(id);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that was processed in\n     * {@link #onCreate}, or throws an IllegalArgumentException if the ID is invalid or there is no\n     * matching view in the hierarchy.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return a view with given ID\n     * @see View#requireViewById(int)\n     * @see DreamService#findViewById(int)\n     */\n    @NonNull\n    public final <T extends View> T requireViewById(@IdRes int id) {\n        T view = findViewById(id);\n        if (view == null) {\n            throw new IllegalArgumentException(\n                    \"ID does not reference a View inside this DreamService\");\n        }\n        return view;\n    }\n\n    /**\n     * Marks this dream as interactive to receive input events.\n     *\n     * <p>Non-interactive dreams (default) will dismiss on the first input event.</p>\n     *\n     * <p>Interactive dreams should call {@link #finish()} to dismiss themselves.</p>\n     *\n     * @param interactive True if this dream will handle input events.\n     */\n    public void setInteractive(boolean interactive) {\n        mInteractive = interactive;\n    }\n\n    /**\n     * Returns whether or not this dream is interactive.  Defaults to false.\n     *\n     * @see #setInteractive(boolean)\n     */\n    public boolean isInteractive() {\n        return mInteractive;\n    }\n\n    /**\n     * Controls {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN}\n     * on the dream's window.\n     *\n     * @param fullscreen If true, the fullscreen flag will be set; else it\n     * will be cleared.\n     */\n    public void setFullscreen(boolean fullscreen) {\n        if (mFullscreen != fullscreen) {\n            mFullscreen = fullscreen;\n            int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;\n            applyWindowFlags(mFullscreen ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream is in fullscreen mode. Defaults to false.\n     *\n     * @see #setFullscreen(boolean)\n     */\n    public boolean isFullscreen() {\n        return mFullscreen;\n    }\n\n    /**\n     * Marks this dream as keeping the screen bright while dreaming.\n     *\n     * @param screenBright True to keep the screen bright while dreaming.\n     */\n    public void setScreenBright(boolean screenBright) {\n        if (mScreenBright != screenBright) {\n            mScreenBright = screenBright;\n            int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;\n            applyWindowFlags(mScreenBright ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream keeps the screen bright while dreaming.\n     * Defaults to false, allowing the screen to dim if necessary.\n     *\n     * @see #setScreenBright(boolean)\n     */\n    public boolean isScreenBright() {\n        return getWindowFlagValue(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, mScreenBright);\n    }\n\n    /**\n     * Marks this dream as windowless.  Only available to doze dreams.\n     *\n     * @hide\n     *\n     */\n    public void setWindowless(boolean windowless) {\n        mWindowless = windowless;\n    }\n\n    /**\n     * Returns whether or not this dream is windowless.  Only available to doze dreams.\n     *\n     * @hide\n     */\n    public boolean isWindowless() {\n        return mWindowless;\n    }\n\n    /**\n     * Returns true if this dream is allowed to doze.\n     * <p>\n     * The value returned by this method is only meaningful when the dream has started.\n     * </p>\n     *\n     * @return True if this dream can doze.\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean canDoze() {\n        return mCanDoze;\n    }\n\n    /**\n     * Starts dozing, entering a deep dreamy sleep.\n     * <p>\n     * Dozing enables the system to conserve power while the user is not actively interacting\n     * with the device.  While dozing, the display will remain on in a low-power state\n     * and will continue to show its previous contents but the application processor and\n     * other system components will be allowed to suspend when possible.\n     * </p><p>\n     * While the application processor is suspended, the dream may stop executing code\n     * for long periods of time.  Prior to being suspended, the dream may schedule periodic\n     * wake-ups to render new content by scheduling an alarm with the {@link AlarmManager}.\n     * The dream may also keep the CPU awake by acquiring a\n     * {@link android.os.PowerManager#PARTIAL_WAKE_LOCK partial wake lock} when necessary.\n     * Note that since the purpose of doze mode is to conserve power (especially when\n     * running on battery), the dream should not wake the CPU very often or keep it\n     * awake for very long.\n     * </p><p>\n     * It is a good idea to call this method some time after the dream's entry animation\n     * has completed and the dream is ready to doze.  It is important to completely\n     * finish all of the work needed before dozing since the application processor may\n     * be suspended at any moment once this method is called unless other wake locks\n     * are being held.\n     * </p><p>\n     * Call {@link #stopDozing} or {@link #finish} to stop dozing.\n     * </p>\n     *\n     * @see #stopDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void startDozing() {\n        if (mCanDoze && !mDozing) {\n            mDozing = true;\n            updateDoze();\n        }\n    }\n\n    private void updateDoze() {\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Updating doze without a dream token.\");\n            return;\n        }\n\n        if (mDozing) {\n            try {\n                mDreamManager.startDozing(mDreamToken, mDozeScreenState, mDozeScreenBrightness);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Stops dozing, returns to active dreaming.\n     * <p>\n     * This method reverses the effect of {@link #startDozing}.  From this moment onward,\n     * the application processor will be kept awake as long as the dream is running\n     * or until the dream starts dozing again.\n     * </p>\n     *\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public void stopDozing() {\n        if (mDozing) {\n            mDozing = false;\n            try {\n                mDreamManager.stopDozing(mDreamToken);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Returns true if the dream will allow the system to enter a low-power state while\n     * it is running without actually turning off the screen.  Defaults to false,\n     * keeping the application processor awake while the dream is running.\n     *\n     * @return True if the dream is dozing.\n     *\n     * @see #setDozing(boolean)\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean isDozing() {\n        return mDozing;\n    }\n\n    /**\n     * Gets the screen state to use while dozing.\n     *\n     * @return The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @see #setDozeScreenState\n     * @hide For use by system UI components only.\n     */\n    public int getDozeScreenState() {\n        return mDozeScreenState;\n    }\n\n    /**\n     * Sets the screen state to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link Display#STATE_UNKNOWN} which lets the system decide.\n     * The dream may set a different state before starting to doze and may\n     * perform transitions between states while dozing to conserve power and\n     * achieve various effects.\n     * </p><p>\n     * Some devices will have dedicated hardware (\"Sidekick\") to animate\n     * the display content while the CPU sleeps. If the dream and the hardware support\n     * this, {@link Display#STATE_ON_SUSPEND} or {@link Display#STATE_DOZE_SUSPEND}\n     * will switch control to the Sidekick.\n     * </p><p>\n     * If not using Sidekick, it is recommended that the state be set to\n     * {@link Display#STATE_DOZE_SUSPEND} once the dream has completely\n     * finished drawing and before it releases its wakelock\n     * to allow the display hardware to be fully suspended.  While suspended,\n     * the display will preserve its on-screen contents.\n     * </p><p>\n     * If the doze suspend state is used, the dream must make sure to set the mode back\n     * to {@link Display#STATE_DOZE} or {@link Display#STATE_ON} before drawing again\n     * since the display updates may be ignored and not seen by the user otherwise.\n     * </p><p>\n     * The set of available display power states and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param state The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenState(int state) {\n        if (mDozeScreenState != state) {\n            mDozeScreenState = state;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Gets the screen brightness to use while dozing.\n     *\n     * @return The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @see #setDozeScreenBrightness\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public int getDozeScreenBrightness() {\n        return mDozeScreenBrightness;\n    }\n\n    /**\n     * Sets the screen brightness to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link PowerManager#BRIGHTNESS_DEFAULT} which lets the system decide.\n     * The dream may set a different brightness before starting to doze and may adjust\n     * the brightness while dozing to conserve power and achieve various effects.\n     * </p><p>\n     * Note that dream may specify any brightness in the full 0-255 range, including\n     * values that are less than the minimum value for manual screen brightness\n     * adjustments by the user.  In particular, the value may be set to 0 which may\n     * turn off the backlight entirely while still leaving the screen on although\n     * this behavior is device dependent and not guaranteed.\n     * </p><p>\n     * The available range of display brightness values and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param brightness The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenBrightness(int brightness) {\n        if (brightness != PowerManager.BRIGHTNESS_DEFAULT) {\n            brightness = clampAbsoluteBrightness(brightness);\n        }\n        if (mDozeScreenBrightness != brightness) {\n            mDozeScreenBrightness = brightness;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Called when this Dream is constructed.\n     */\n    @Override\n    public void onCreate() {\n        if (mDebug) Slog.v(TAG, \"onCreate()\");\n        super.onCreate();\n    }\n\n    /**\n     * Called when the dream's window has been created and is visible and animation may now begin.\n     */\n    public void onDreamingStarted() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStarted()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when this Dream is stopped, either by external request or by calling finish(),\n     * before the window has been removed.\n     */\n    public void onDreamingStopped() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStopped()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when the dream is being asked to stop itself and wake.\n     * <p>\n     * The default implementation simply calls {@link #finish} which ends the dream\n     * immediately.  Subclasses may override this function to perform a smooth exit\n     * transition then call {@link #finish} afterwards.\n     * </p><p>\n     * Note that the dream will only be given a short period of time (currently about\n     * five seconds) to wake up.  If the dream does not finish itself in a timely manner\n     * then the system will forcibly finish it once the time allowance is up.\n     * </p>\n     */\n    public void onWakeUp() {\n        finish();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public final IBinder onBind(Intent intent) {\n        if (mDebug) Slog.v(TAG, \"onBind() intent = \" + intent);\n        mDreamServiceWrapper = new DreamServiceWrapper();\n        return mDreamServiceWrapper;\n    }\n\n    /**\n     * Stops the dream and detaches from the window.\n     * <p>\n     * When the dream ends, the system will be allowed to go to sleep fully unless there\n     * is a reason for it to be awake such as recent user activity or wake locks being held.\n     * </p>\n     */\n    public final void finish() {\n        if (mDebug) Slog.v(TAG, \"finish(): mFinished=\" + mFinished);\n\n        Activity activity = mActivity;\n        if (activity != null) {\n            if (!activity.isFinishing()) {\n                // In case the activity is not finished yet, do it now.\n                activity.finishAndRemoveTask();\n            }\n            return;\n        }\n\n        if (mFinished) {\n            return;\n        }\n        mFinished = true;\n\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Finish was called before the dream was attached.\");\n            stopSelf();\n            return;\n        }\n\n        try {\n            // finishSelf will unbind the dream controller from the dream service. This will\n            // trigger DreamService.this.onDestroy and DreamService.this will die.\n            mDreamManager.finishSelf(mDreamToken, true /*immediate*/);\n        } catch (RemoteException ex) {\n            // system server died\n        }\n    }\n\n    /**\n     * Wakes the dream up gently.\n     * <p>\n     * Calls {@link #onWakeUp} to give the dream a chance to perform an exit transition.\n     * When the transition is over, the dream should call {@link #finish}.\n     * </p>\n     */\n    public final void wakeUp() {\n        wakeUp(false);\n    }\n\n    private void wakeUp(boolean fromSystem) {\n        if (mDebug) Slog.v(TAG, \"wakeUp(): fromSystem=\" + fromSystem\n                + \", mWaking=\" + mWaking + \", mFinished=\" + mFinished);\n\n        if (!mWaking && !mFinished) {\n            mWaking = true;\n\n            // As a minor optimization, invoke the callback first in case it simply\n            // calls finish() immediately so there wouldn't be much point in telling\n            // the system that we are finishing the dream gently.\n            onWakeUp();\n\n            // Now tell the system we are waking gently, unless we already told\n            // it we were finishing immediately.\n            if (!fromSystem && !mFinished) {\n                if (mActivity == null) {\n                    Slog.w(TAG, \"WakeUp was called before the dream was attached.\");\n                } else {\n                    try {\n                        mDreamManager.finishSelf(mDreamToken, false /*immediate*/);\n                    } catch (RemoteException ex) {\n                        // system server died\n                    }\n                }\n            }\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDestroy() {\n        if (mDebug) Slog.v(TAG, \"onDestroy()\");\n        // hook for subclasses\n\n        // Just in case destroy came in before detach, let's take care of that now\n        detach();\n\n        super.onDestroy();\n    }\n\n    // end public api\n\n    /**\n     * Called by DreamController.stopDream() when the Dream is about to be unbound and destroyed.\n     *\n     * Must run on mHandler.\n     */\n    private final void detach() {\n        if (mStarted) {\n            if (mDebug) Slog.v(TAG, \"detach(): Calling onDreamingStopped()\");\n            mStarted = false;\n            onDreamingStopped();\n        }\n\n        if (mActivity != null && !mActivity.isFinishing()) {\n            mActivity.finishAndRemoveTask();\n        } else {\n            finish();\n        }\n\n        mDreamToken = null;\n        mCanDoze = false;\n    }\n\n    /**\n     * Called when the Dream is ready to be shown.\n     *\n     * Must run on mHandler.\n     *\n     * @param dreamToken Token for this dream service.\n     * @param started A callback that will be invoked once onDreamingStarted has completed.\n     */\n    private void attach(IBinder dreamToken, boolean canDoze, IRemoteCallback started) {\n        if (mDreamToken != null) {\n            Slog.e(TAG, \"attach() called when dream with token=\" + mDreamToken\n                    + \" already attached\");\n            return;\n        }\n        if (mFinished || mWaking) {\n            Slog.w(TAG, \"attach() called after dream already finished\");\n            try {\n                mDreamManager.finishSelf(dreamToken, true /*immediate*/);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n            return;\n        }\n\n        mDreamToken = dreamToken;\n        mCanDoze = canDoze;\n        if (mWindowless && !mCanDoze) {\n            throw new IllegalStateException(\"Only doze dreams can be windowless\");\n        }\n\n        mDispatchAfterOnAttachedToWindow = () -> {\n            if (mWindow != null || mWindowless) {\n                mStarted = true;\n                try {\n                    onDreamingStarted();\n                } finally {\n                    try {\n                        started.sendResult(null);\n                    } catch (RemoteException e) {\n                        throw e.rethrowFromSystemServer();\n                    }\n                }\n            }\n        };\n\n        // We need to defer calling onDreamingStarted until after the activity is created.\n        // If the dream is windowless, we can call it immediately. Otherwise, we wait\n        // for the DreamActivity to report onActivityCreated via\n        // DreamServiceWrapper.onActivityCreated.\n        if (!mWindowless) {\n            Intent i = new Intent(this, DreamActivity.class);\n            i.setPackage(getApplicationContext().getPackageName());\n            i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            i.putExtra(DreamActivity.EXTRA_CALLBACK, mDreamServiceWrapper);\n\n            try {\n                if (!ActivityTaskManager.getService().startDreamActivity(i)) {\n                    detach();\n                    return;\n                }\n            } catch (RemoteException e) {\n                Log.w(TAG, \"Could not connect to activity task manager to start dream activity\");\n                e.rethrowFromSystemServer();\n            }\n        } else {\n            mDispatchAfterOnAttachedToWindow.run();\n        }\n    }\n\n    private void onWindowCreated(Window w) {\n        mWindow = w;\n        mWindow.setCallback(this);\n        mWindow.requestFeature(Window.FEATURE_NO_TITLE);\n\n        WindowManager.LayoutParams lp = mWindow.getAttributes();\n        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN\n                    | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR\n                    | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED\n                    | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD\n                    | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON\n                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED\n                    | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0)\n                    | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0)\n                    );\n        mWindow.setAttributes(lp);\n        // Workaround: Currently low-profile and in-window system bar backgrounds don't go\n        // along well. Dreams usually don't need such bars anyways, so disable them by default.\n        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n\n        mWindow.getDecorView().addOnAttachStateChangeListener(\n                new View.OnAttachStateChangeListener() {\n                    @Override\n                    public void onViewAttachedToWindow(View v) {\n                        mDispatchAfterOnAttachedToWindow.run();\n                    }\n\n                    @Override\n                    public void onViewDetachedFromWindow(View v) {\n                        if (mActivity == null || !mActivity.isChangingConfigurations()) {\n                            // Only stop the dream if the view is not detached by relaunching\n                            // activity for configuration changes.\n                            mActivity = null;\n                            finish();\n                        }\n                    }\n                });\n    }\n\n    private boolean getWindowFlagValue(int flag, boolean defaultValue) {\n        return mWindow == null ? defaultValue : (mWindow.getAttributes().flags & flag) != 0;\n    }\n\n    private void applyWindowFlags(int flags, int mask) {\n        if (mWindow != null) {\n            WindowManager.LayoutParams lp = mWindow.getAttributes();\n            lp.flags = applyFlags(lp.flags, flags, mask);\n            mWindow.setAttributes(lp);\n            mWindow.getWindowManager().updateViewLayout(mWindow.getDecorView(), lp);\n        }\n    }\n\n    private int applyFlags(int oldFlags, int flags, int mask) {\n        return (oldFlags&~mask) | (flags&mask);\n    }\n\n    @Override\n    protected void dump(final FileDescriptor fd, PrintWriter pw, final String[] args) {\n        DumpUtils.dumpAsync(mHandler, new Dump() {\n            @Override\n            public void dump(PrintWriter pw, String prefix) {\n                dumpOnHandler(fd, pw, args);\n            }\n        }, pw, \"\", 1000);\n    }\n\n    /** @hide */\n    protected void dumpOnHandler(FileDescriptor fd, PrintWriter pw, String[] args) {\n        pw.print(TAG + \": \");\n        if (mFinished) {\n            pw.println(\"stopped\");\n        } else {\n            pw.println(\"running (dreamToken=\" + mDreamToken + \")\");\n        }\n        pw.println(\"  window: \" + mWindow);\n        pw.print(\"  flags:\");\n        if (isInteractive()) pw.print(\" interactive\");\n        if (isFullscreen()) pw.print(\" fullscreen\");\n        if (isScreenBright()) pw.print(\" bright\");\n        if (isWindowless()) pw.print(\" windowless\");\n        if (isDozing()) pw.print(\" dozing\");\n        else if (canDoze()) pw.print(\" candoze\");\n        pw.println();\n        if (canDoze()) {\n            pw.println(\"  doze screen state: \" + Display.stateToString(mDozeScreenState));\n            pw.println(\"  doze screen brightness: \" + mDozeScreenBrightness);\n        }\n    }\n\n    private static int clampAbsoluteBrightness(int value) {\n        return MathUtils.constrain(value, PowerManager.BRIGHTNESS_OFF, PowerManager.BRIGHTNESS_ON);\n    }\n\n    /**\n     * The DreamServiceWrapper is used as a gateway to the system_server, where DreamController\n     * uses it to control the DreamService. It is also used to receive callbacks from the\n     * DreamActivity.\n     */\n    final class DreamServiceWrapper extends IDreamService.Stub {\n        @Override\n        public void attach(final IBinder dreamToken, final boolean canDoze,\n                IRemoteCallback started) {\n            mHandler.post(() -> DreamService.this.attach(dreamToken, canDoze, started));\n        }\n\n        @Override\n        public void detach() {\n            mHandler.post(DreamService.this::detach);\n        }\n\n        @Override\n        public void wakeUp() {\n            mHandler.post(() -> DreamService.this.wakeUp(true /*fromSystem*/));\n        }\n\n        /** @hide */\n        void onActivityCreated(DreamActivity a) {\n            mActivity = a;\n            onWindowCreated(a.getWindow());\n        }\n    }\n}",
            "downstream_file_ground_truth_tokens": {
              "openai": 9207,
              "general": {
                "word_based": 4394,
                "char_based": 10387
              },
              "gemini": 10602
            },
            "downstream_file_content_patched_upstream_only": "```java\n/**\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage android.service.dreams;\n\nimport android.annotation.IdRes;\nimport android.annotation.LayoutRes;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.SdkConstant;\nimport android.annotation.SdkConstant.SdkConstantType;\nimport android.annotation.TestApi;\nimport android.app.Activity;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.Service;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.Intent;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.IRemoteCallback;\nimport android.os.Looper;\nimport android.os.PowerManager;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.util.Log;\nimport android.util.MathUtils;\nimport android.util.Slog;\nimport android.view.ActionMode;\nimport android.view.Display;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SearchEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.WindowManager.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.DumpUtils.Dump;\n\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\n\n/**\n * Extend this class to implement a custom dream (available to the user as a \"Daydream\").\n *\n * <p>Dreams are interactive screensavers launched when a charging device is idle, or docked in a\n * desk dock. Dreams provide another modality for apps to express themselves, tailored for\n * an exhibition/lean-back experience.</p>\n *\n * <p>The {@code DreamService} lifecycle is as follows:</p>\n * <ol>\n *   <li>{@link #onAttachedToWindow}\n *     <p>Use this for initial setup, such as calling {@link #setContentView setContentView()}.</li>\n *   <li>{@link #onDreamingStarted}\n *     <p>Your dream has started, so you should begin animations or other behaviors here.</li>\n *   <li>{@link #onDreamingStopped}\n *     <p>Use this to stop the things you started in {@link #onDreamingStarted}.</li>\n *   <li>{@link #onDetachedFromWindow}\n *     <p>Use this to dismantle resources (for example, detach from handlers\n *        and listeners).</li>\n * </ol>\n *\n * <p>In addition, onCreate and onDestroy (from the Service interface) will also be called, but\n * initialization and teardown should be done by overriding the hooks above.</p>\n *\n * <p>To be available to the system, your {@code DreamService} should be declared in the\n * manifest as follows:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\" >\n *\n *     &lt;intent-filter>\n *         &lt;action android:name=\"android.service.dreams.DreamService\" />\n *         &lt;category android:name=\"android.intent.category.DEFAULT\" />\n *     &lt;/intent-filter>\n *\n *     &lt;!-- Point to additional information for this dream (optional) -->\n *     &lt;meta-data\n *         android:name=\"android.service.dream\"\n *         android:resource=\"@xml/my_dream\" />\n * &lt;/service>\n * </pre>\n *\n * <p>If specified with the {@code <meta-data>} element,\n * additional information for the dream is defined using the\n * {@link android.R.styleable#Dream &lt;dream&gt;} element in a separate XML file.\n * Currently, the only addtional\n * information you can provide is for a settings activity that allows the user to configure\n * the dream behavior. For example:</p>\n * <p class=\"code-caption\">res/xml/my_dream.xml</p>\n * <pre>\n * &lt;dream xmlns:android=\"http://schemas.android.com/apk/res/android\"\n *     android:settingsActivity=\"com.example.app/.MyDreamSettingsActivity\" />\n * </pre>\n * <p>This makes a Settings button available alongside your dream's listing in the\n * system settings, which when pressed opens the specified activity.</p>\n *\n *\n * <p>To specify your dream layout, call {@link #setContentView}, typically during the\n * {@link #onAttachedToWindow} callback. For example:</p>\n * <pre>\n * public class MyDream extends DreamService {\n *\n *     &#64;Override\n *     public void onAttachedToWindow() {\n *         super.onAttachedToWindow();\n *\n *         // Exit dream upon user touch\n *         setInteractive(false);\n *         // Hide system UI\n *         setFullscreen(true);\n *         // Set the dream layout\n *         setContentView(R.layout.dream);\n *     }\n * }\n * </pre>\n *\n * <p>When targeting api level 21 and above, you must declare the service in your manifest file\n * with the {@link android.Manifest.permission#BIND_DREAM_SERVICE} permission. For example:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\"\n *     android:permission=\"android.permission.BIND_DREAM_SERVICE\">\n *   &lt;intent-filter>\n *     &lt;action android:name=\u201dandroid.service.dreams.DreamService\u201d />\n *     &lt;category android:name=\u201dandroid.intent.category.DEFAULT\u201d />\n *   &lt;/intent-filter>\n * &lt;/service>\n * </pre>\n */\npublic class DreamService extends Service implements Window.Callback {\n    private final String TAG = DreamService.class.getSimpleName() + \"[\" + getClass().getSimpleName() + \"]\";\n\n    /**\n     * The name of the dream manager service.\n     * @hide\n     */\n    public static final String DREAM_SERVICE = \"dreams\";\n\n    /**\n     * The {@link Intent} that must be declared as handled by the service.\n     */\n    @SdkConstant(SdkConstantType.SERVICE_ACTION)\n    public static final String SERVICE_INTERFACE =\n            \"android.service.dreams.DreamService\";\n\n    /**\n     * Name under which a Dream publishes information about itself.\n     * This meta-data must reference an XML resource containing\n     * a <code>&lt;{@link android.R.styleable#Dream dream}&gt;</code>\n     * tag.\n     */\n    public static final String DREAM_META_DATA = \"android.service.dream\";\n\n    private final IDreamManager mDreamManager;\n    private final Handler mHandler = new Handler(Looper.getMainLooper());\n    private IBinder mDreamToken;\n    private Window mWindow;\n    private Activity mActivity;\n    private boolean mInteractive;\n    private boolean mFullscreen;\n    private boolean mScreenBright = true;\n    private boolean mStarted;\n    private boolean mWaking;\n    private boolean mFinished;\n    private boolean mCanDoze;\n    private boolean mDozing;\n    private boolean mWindowless;\n    private int mDozeScreenState = Display.STATE_UNKNOWN;\n    private int mDozeScreenBrightness = PowerManager.BRIGHTNESS_DEFAULT;\n\n    private boolean mDebug = false;\n\n    private DreamServiceWrapper mDreamServiceWrapper;\n    private Runnable mDispatchAfterOnAttachedToWindow;\n\n    public DreamService() {\n        mDreamManager = IDreamManager.Stub.asInterface(ServiceManager.getService(DREAM_SERVICE));\n    }\n\n    /**\n     * @hide\n     */\n    public void setDebug(boolean dbg) {\n        mDebug = dbg;\n    }\n\n    // begin Window.Callback methods\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyEvent\");\n            wakeUp();\n            return true;\n        } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {\n            if (mDebug) Slog.v(TAG, \"Waking up on back key\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyShortcutEvent(KeyEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyShortcutEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyShortcutEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // TODO: create more flexible version of mInteractive that allows clicks\n        // but finish()es on any other kind of activity\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on touchEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTouchEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTrackballEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on trackballEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTrackballEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchGenericMotionEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on genericMotionEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchGenericMotionEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public View onCreatePanelView(int featureId) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onCreatePanelMenu(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onPreparePanel(int featureId, View view, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuOpened(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowAttributesChanged(LayoutParams attrs) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onContentChanged() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowFocusChanged(boolean hasFocus) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onAttachedToWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDetachedFromWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onPanelClosed(int featureId, Menu menu) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested(SearchEvent event) {\n        return onSearchRequested();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested() {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(\n            android.view.ActionMode.Callback callback, int type) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeStarted(ActionMode mode) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeFinished(ActionMode mode) {\n    }\n    // end Window.Callback methods\n\n    // begin public api\n    /**\n     * Retrieves the current {@link android.view.WindowManager} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindowManager()}.\n     *\n     * @return The current window manager, or null if the dream is not started.\n     */\n    public WindowManager getWindowManager() {\n        return mWindow != null ? mWindow.getWindowManager() : null;\n    }\n\n    /**\n     * Retrieves the current {@link android.view.Window} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindow()}.\n     *\n     * @return The current window, or null if the dream is not started.\n     */\n    public Window getWindow() {\n        return mWindow;\n    }\n\n   /**\n     * Inflates a layout resource and set it to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(int)}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param layoutResID Resource ID to be inflated.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(android.view.View)} in an activity,\n     * including using {@link ViewGroup.LayoutParams#MATCH_PARENT} as the layout height and width of the view.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @see #setContentView(int)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(View view) {\n        getWindow().setContentView(view);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to\n     * {@link android.app.Activity#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)}\n     * in an activity.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(int)\n     */\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().setContentView(view, params);\n    }\n\n    /**\n     * Adds a view to the Dream's window, leaving other content views in place.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     */\n    public void addContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().addContentView(view, params);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that\n     * was processed in {@link #onCreate}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return The view if found or null otherwise.\n     * @see View#findViewById(int)\n     * @see DreamService#requireViewById(int)\n     */\n    @Nullable\n    public <T extends View> T findViewById(@IdRes int id) {\n        return getWindow().findViewById(id);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that was processed in\n     * {@link #onCreate}, or throws an IllegalArgumentException if the ID is invalid or there is no\n     * matching view in the hierarchy.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return a view with given ID\n     * @see View#requireViewById(int)\n     * @see DreamService#findViewById(int)\n     */\n    @NonNull\n    public final <T extends View> T requireViewById(@IdRes int id) {\n        T view = findViewById(id);\n        if (view == null) {\n            throw new IllegalArgumentException(\n                    \"ID does not reference a View inside this DreamService\");\n        }\n        return view;\n    }\n\n    /**\n     * Marks this dream as interactive to receive input events.\n     *\n     * <p>Non-interactive dreams (default) will dismiss on the first input event.</p>\n     *\n     * <p>Interactive dreams should call {@link #finish()} to dismiss themselves.</p>\n     *\n     * @param interactive True if this dream will handle input events.\n     */\n    public void setInteractive(boolean interactive) {\n        mInteractive = interactive;\n    }\n\n    /**\n     * Returns whether or not this dream is interactive.  Defaults to false.\n     *\n     * @see #setInteractive(boolean)\n     */\n    public boolean isInteractive() {\n        return mInteractive;\n    }\n\n    /**\n     * Controls {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN}\n     * on the dream's window.\n     *\n     * @param fullscreen If true, the fullscreen flag will be set; else it\n     * will be cleared.\n     */\n    public void setFullscreen(boolean fullscreen) {\n        if (mFullscreen != fullscreen) {\n            mFullscreen = fullscreen;\n            int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;\n            applyWindowFlags(mFullscreen ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream is in fullscreen mode. Defaults to false.\n     *\n     * @see #setFullscreen(boolean)\n     */\n    public boolean isFullscreen() {\n        return mFullscreen;\n    }\n\n    /**\n     * Marks this dream as keeping the screen bright while dreaming.\n     *\n     * @param screenBright True to keep the screen bright while dreaming.\n     */\n    public void setScreenBright(boolean screenBright) {\n        if (mScreenBright != screenBright) {\n            mScreenBright = screenBright;\n            int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;\n            applyWindowFlags(mScreenBright ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream keeps the screen bright while dreaming.\n     * Defaults to false, allowing the screen to dim if necessary.\n     *\n     * @see #setScreenBright(boolean)\n     */\n    public boolean isScreenBright() {\n        return getWindowFlagValue(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, mScreenBright);\n    }\n\n    /**\n     * Marks this dream as windowless.  Only available to doze dreams.\n     *\n     * @hide\n     *\n     */\n    public void setWindowless(boolean windowless) {\n        mWindowless = windowless;\n    }\n\n    /**\n     * Returns whether or not this dream is windowless.  Only available to doze dreams.\n     *\n     * @hide\n     */\n    public boolean isWindowless() {\n        return mWindowless;\n    }\n\n    /**\n     * Returns true if this dream is allowed to doze.\n     * <p>\n     * The value returned by this method is only meaningful when the dream has started.\n     * </p>\n     *\n     * @return True if this dream can doze.\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean canDoze() {\n        return mCanDoze;\n    }\n\n    /**\n     * Starts dozing, entering a deep dreamy sleep.\n     * <p>\n     * Dozing enables the system to conserve power while the user is not actively interacting\n     * with the device.  While dozing, the display will remain on in a low-power state\n     * and will continue to show its previous contents but the application processor and\n     * other system components will be allowed to suspend when possible.\n     * </p><p>\n     * While the application processor is suspended, the dream may stop executing code\n     * for long periods of time.  Prior to being suspended, the dream may schedule periodic\n     * wake-ups to render new content by scheduling an alarm with the {@link AlarmManager}.\n     * The dream may also keep the CPU awake by acquiring a\n     * {@link android.os.PowerManager#PARTIAL_WAKE_LOCK partial wake lock} when necessary.\n     * Note that since the purpose of doze mode is to conserve power (especially when\n     * running on battery), the dream should not wake the CPU very often or keep it\n     * awake for very long.\n     * </p><p>\n     * It is a good idea to call this method some time after the dream's entry animation\n     * has completed and the dream is ready to doze.  It is important to completely\n     * finish all of the work needed before dozing since the application processor may\n     * be suspended at any moment once this method is called unless other wake locks\n     * are being held.\n     * </p><p>\n     * Call {@link #stopDozing} or {@link #finish} to stop dozing.\n     * </p>\n     *\n     * @see #stopDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void startDozing() {\n        if (mCanDoze && !mDozing) {\n            mDozing = true;\n            updateDoze();\n        }\n    }\n\n    private void updateDoze() {\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Updating doze without a dream token.\");\n            return;\n        }\n\n        if (mDozing) {\n            try {\n                mDreamManager.startDozing(mDreamToken, mDozeScreenState, mDozeScreenBrightness);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Stops dozing, returns to active dreaming.\n     * <p>\n     * This method reverses the effect of {@link #startDozing}.  From this moment onward,\n     * the application processor will be kept awake as long as the dream is running\n     * or until the dream starts dozing again.\n     * </p>\n     *\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public void stopDozing() {\n        if (mDozing) {\n            mDozing = false;\n            try {\n                mDreamManager.stopDozing(mDreamToken);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Returns true if the dream will allow the system to enter a low-power state while\n     * it is running without actually turning off the screen.  Defaults to false,\n     * keeping the application processor awake while the dream is running.\n     *\n     * @return True if the dream is dozing.\n     *\n     * @see #setDozing(boolean)\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean isDozing() {\n        return mDozing;\n    }\n\n    /**\n     * Gets the screen state to use while dozing.\n     *\n     * @return The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @see #setDozeScreenState\n     * @hide For use by system UI components only.\n     */\n    public int getDozeScreenState() {\n        return mDozeScreenState;\n    }\n\n    /**\n     * Sets the screen state to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link Display#STATE_UNKNOWN} which lets the system decide.\n     * The dream may set a different state before starting to doze and may\n     * perform transitions between states while dozing to conserve power and\n     * achieve various effects.\n     * </p><p>\n     * Some devices will have dedicated hardware (\"Sidekick\") to animate\n     * the display content while the CPU sleeps. If the dream and the hardware support\n     * this, {@link Display#STATE_ON_SUSPEND} or {@link Display#STATE_DOZE_SUSPEND}\n     * will switch control to the Sidekick.\n     * </p><p>\n     * If not using Sidekick, it is recommended that the state be set to\n     * {@link Display#STATE_DOZE_SUSPEND} once the dream has completely\n     * finished drawing and before it releases its wakelock\n     * to allow the display hardware to be fully suspended.  While suspended,\n     * the display will preserve its on-screen contents.\n     * </p><p>\n     * If the doze suspend state is used, the dream must make sure to set the mode back\n     * to {@link Display#STATE_DOZE} or {@link Display#STATE_ON} before drawing again\n     * since the display updates may be ignored and not seen by the user otherwise.\n     * </p><p>\n     * The set of available display power states and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param state The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenState(int state) {\n        if (mDozeScreenState != state) {\n            mDozeScreenState = state;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Gets the screen brightness to use while dozing.\n     *\n     * @return The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @see #setDozeScreenBrightness\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public int getDozeScreenBrightness() {\n        return mDozeScreenBrightness;\n    }\n\n    /**\n     * Sets the screen brightness to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link PowerManager#BRIGHTNESS_DEFAULT} which lets the system decide.\n     * The dream may set a different brightness before starting to doze and may adjust\n     * the brightness while dozing to conserve power and achieve various effects.\n     * </p><p>\n     * Note that dream may specify any brightness in the full 0-255 range, including\n     * values that are less than the minimum value for manual screen brightness\n     * adjustments by the user.  In particular, the value may be set to 0 which may\n     * turn off the backlight entirely while still leaving the screen on although\n     * this behavior is device dependent and not guaranteed.\n     * </p><p>\n     * The available range of display brightness values and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param brightness The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenBrightness(int brightness) {\n        if (brightness != PowerManager.BRIGHTNESS_DEFAULT) {\n            brightness = clampAbsoluteBrightness(brightness);\n        }\n        if (mDozeScreenBrightness != brightness) {\n            mDozeScreenBrightness = brightness;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Called when this Dream is constructed.\n     */\n    @Override\n    public void onCreate() {\n        if (mDebug) Slog.v(TAG, \"onCreate()\");\n        super.onCreate();\n    }\n\n    /**\n     * Called when the dream's window has been created and is visible and animation may now begin.\n     */\n    public void onDreamingStarted() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStarted()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when this Dream is stopped, either by external request or by calling finish(),\n     * before the window has been removed.\n     */\n    public void onDreamingStopped() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStopped()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when the dream is being asked to stop itself and wake.\n     * <p>\n     * The default implementation simply calls {@link #finish} which ends the dream\n     * immediately.  Subclasses may override this function to perform a smooth exit\n     * transition then call {@link #finish} afterwards.\n     * </p><p>\n     * Note that the dream will only be given a short period of time (currently about\n     * five seconds) to wake up.  If the dream does not finish itself in a timely manner\n     * then the system will forcibly finish it once the time allowance is up.\n     * </p>\n     */\n    public void onWakeUp() {\n        finish();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public final IBinder onBind(Intent intent) {\n        if (mDebug) Slog.v(TAG, \"onBind() intent = \" + intent);\n        mDreamServiceWrapper = new DreamServiceWrapper();\n        return mDreamServiceWrapper;\n    }\n\n    /**\n     * Stops the dream and detaches from the window.\n     * <p>\n     * When the dream ends, the system will be allowed to go to sleep fully unless there\n     * is a reason for it to be awake such as recent user activity or wake locks being held.\n     * </p>\n     */\n    public final void finish() {\n        if (mDebug) Slog.v(TAG, \"finish(): mFinished=\" + mFinished);\n\n        Activity activity = mActivity;\n        if (activity != null) {\n            if (!activity.isFinishing()) {\n                // In case the activity is not finished yet, do it now.\n                activity.finishAndRemoveTask();\n            }\n            return;\n        }\n\n        if (mFinished) {\n            return;\n        }\n        mFinished = true;\n\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Finish was called before the dream was attached.\");\n            stopSelf();\n            return;\n        }\n\n        try {\n            // finishSelf will unbind the dream controller from the dream service. This will\n            // trigger DreamService.this.onDestroy and DreamService.this will die.\n            mDreamManager.finishSelf(mDreamToken, true /*immediate*/);\n        } catch (RemoteException ex) {\n            // system server died\n        }\n    }\n\n    /**\n     * Wakes the dream up gently.\n     * <p>\n     * Calls {@link #onWakeUp} to give the dream a chance to perform an exit transition.\n     * When the transition is over, the dream should call {@link #finish}.\n     * </p>\n     */\n    public final void wakeUp() {\n        wakeUp(false);\n    }\n\n    private void wakeUp(boolean fromSystem) {\n        if (mDebug) Slog.v(TAG, \"wakeUp(): fromSystem=\" + fromSystem\n                + \", mWaking=\" + mWaking + \", mFinished=\" + mFinished);\n\n        if (!mWaking && !mFinished) {\n            mWaking = true;\n\n            // As a minor optimization, invoke the callback first in case it simply\n            // calls finish() immediately so there wouldn't be much point in telling\n            // the system that we are finishing the dream gently.\n            onWakeUp();\n\n            // Now tell the system we are waking gently, unless we already told\n            // it we were finishing immediately.\n            if (!fromSystem && !mFinished) {\n                if (mActivity == null) {\n                    Slog.w(TAG, \"WakeUp was called before the dream was attached.\");\n                } else {\n                    try {\n                        mDreamManager.finishSelf(mDreamToken, false /*immediate*/);\n                    } catch (RemoteException ex) {\n                        // system server died\n                    }\n                }\n            }\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDestroy() {\n        if (mDebug) Slog.v(TAG, \"onDestroy()\");\n        // hook for subclasses\n\n        // Just in case destroy came in before detach, let's take care of that now\n        detach();\n\n        super.onDestroy();\n    }\n\n    // end public api\n\n    /**\n     * Called by DreamController.stopDream() when the Dream is about to be unbound and destroyed.\n     *\n     * Must run on mHandler.\n     */\n    private final void detach() {\n        if (mStarted) {\n            if (mDebug) Slog.v(TAG, \"detach(): Calling onDreamingStopped()\");\n            mStarted = false;\n            onDreamingStopped();\n        }\n\n        if (mActivity != null && !mActivity.isFinishing()) {\n            mActivity.finishAndRemoveTask();\n        } else {\n            finish();\n        }\n\n        mDreamToken = null;\n        mCanDoze = false;\n    }\n\n    /**\n     * Called when the Dream is ready to be shown.\n     *\n     * Must run on mHandler.\n     *\n     * @param dreamToken Token for this dream service.\n     * @param started A callback that will be invoked once onDreamingStarted has completed.\n     */\n    private void attach(IBinder dreamToken, boolean canDoze, IRemoteCallback started) {\n        if (mDreamToken != null) {\n            Slog.e(TAG, \"attach() called when dream with token=\" + mDreamToken\n                    + \" already attached\");\n            return;\n        }\n        if (mFinished || mWaking) {\n            Slog.w(TAG, \"attach() called after dream already finished\");\n            try {\n                mDreamManager.finishSelf(dreamToken, true /*immediate*/);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n            return;\n        }\n\n        mDreamToken = dreamToken;\n        mCanDoze = canDoze;\n        if (mWindowless && !mCanDoze) {\n            throw new IllegalStateException(\"Only doze dreams can be windowless\");\n        }\n\n        mDispatchAfterOnAttachedToWindow = () -> {\n            if (mWindow != null || mWindowless) {\n                mStarted = true;\n                try {\n                    onDreamingStarted();\n                } finally {\n                    try {\n                        started.sendResult(null);\n                    } catch (RemoteException e) {\n                        throw e.rethrowFromSystemServer();\n                    }\n                }\n            }\n        };\n\n        // We need to defer calling onDreamingStarted until after the activity is created.\n        // If the dream is windowless, we can call it immediately. Otherwise, we wait\n        // for the DreamActivity to report onActivityCreated via\n        // DreamServiceWrapper.onActivityCreated.\n        if (!mWindowless) {\n            Intent i = new Intent(this, DreamActivity.class);\n            i.setPackage(getApplicationContext().getPackageName());\n            i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            i.putExtra(DreamActivity.EXTRA_CALLBACK, mDreamServiceWrapper);\n\n            try {\n                if (!ActivityTaskManager.getService().startDreamActivity(i)) {\n                    detach();\n                    return;\n                }\n            } catch (RemoteException e) {\n                Log.w(TAG, \"Could not connect to activity task manager to start dream activity\");\n                e.rethrowFromSystemServer();\n            }\n        } else {\n            mDispatchAfterOnAttachedToWindow.run();\n        }\n    }\n\n    private void onWindowCreated(Window w) {\n        mWindow = w;\n        mWindow.setCallback(this);\n        mWindow.requestFeature(Window.FEATURE_NO_TITLE);\n\n        WindowManager.LayoutParams lp = mWindow.getAttributes();\n        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN\n                    | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR\n                    | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED\n                    | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD\n                    | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON\n                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED\n                    | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0)\n                    | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0)\n                    );\n        mWindow.setAttributes(lp);\n        // Workaround: Currently low-profile and in-window system bar backgrounds don't go\n        // along well. Dreams usually don't need such bars anyways, so disable them by default.\n        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n\n        mWindow.getDecorView().addOnAttachStateChangeListener(\n                new View.OnAttachStateChangeListener() {\n                    @Override\n                    public void onViewAttachedToWindow(View v) {\n                        mDispatchAfterOnAttachedToWindow.run();\n                    }\n\n                    @Override\n                    public void onViewDetachedFromWindow(View v) {\n                        if (mActivity == null || !mActivity.isChangingConfigurations()) {\n                            // Only stop the dream if the view is not detached by relaunching\n                            // activity for configuration changes.\n                            mActivity = null;\n                            finish();\n                        }\n                    }\n                });\n    }\n\n    private boolean getWindowFlagValue(int flag, boolean defaultValue) {\n        return mWindow == null ? defaultValue : (mWindow.getAttributes().flags & flag) != 0;\n    }\n\n    private void applyWindowFlags(int flags, int mask) {\n        if (mWindow != null) {\n            WindowManager.LayoutParams lp = mWindow.getAttributes();\n            lp.flags = applyFlags(lp.flags, flags, mask);\n            mWindow.setAttributes(lp);\n            mWindow.getWindowManager().updateViewLayout(mWindow.getDecorView(), lp);\n        }\n    }\n\n    private int applyFlags(int oldFlags, int flags, int mask) {\n        return (oldFlags&~mask) | (flags&mask);\n    }\n\n    @Override\n    protected void dump(final FileDescriptor fd, PrintWriter pw, final String[] args) {\n        DumpUtils.dumpAsync(mHandler, new Dump() {\n            @Override\n            public void dump(PrintWriter pw, String prefix) {\n                dumpOnHandler(fd, pw, args);\n            }\n        }, pw, \"\", 1000);\n    }\n\n    /** @hide */\n    protected void dumpOnHandler(FileDescriptor fd, PrintWriter pw, String[] args) {\n        pw.print(TAG + \": \");\n        if (mFinished) {\n            pw.println(\"stopped\");\n        } else {\n            pw.println(\"running (dreamToken=\" + mDreamToken + \")\");\n        }\n        pw.println(\"  window: \" + mWindow);\n        pw.print(\"  flags:\");\n        if (isInteractive()) pw.print(\" interactive\");\n        if (isFullscreen()) pw.print(\" fullscreen\");\n        if (isScreenBright()) pw.print(\" bright\");\n        if (isWindowless()) pw.print(\" windowless\");\n        if (isDozing()) pw.print(\" dozing\");\n        else if (canDoze()) pw.print(\" candoze\");\n        pw.println();\n        if (canDoze()) {\n            pw.println(\"  doze screen state: \" + Display.stateToString(mDozeScreenState));\n            pw.println(\"  doze screen brightness: \" + mDozeScreenBrightness);\n        }\n    }\n\n    private static int clampAbsoluteBrightness(int value) {\n        return MathUtils.constrain(value, PowerManager.BRIGHTNESS_OFF, PowerManager.BRIGHTNESS_ON);\n    }\n\n    /**\n     * The DreamServiceWrapper is used as a gateway to the system_server, where DreamController\n     * uses it to control the DreamService. It is also used to receive callbacks from the\n     * DreamActivity.\n     */\n    final class DreamServiceWrapper extends IDreamService.Stub {\n        @Override\n        public void attach(final IBinder dreamToken, final boolean canDoze,\n                IRemoteCallback started) {\n            mHandler.post(() -> DreamService.this.attach(dreamToken, canDoze, started));\n        }\n\n        @Override\n        public void detach() {\n            mHandler.post(DreamService.this::detach);\n        }\n\n        @Override\n        public void wakeUp() {\n            mHandler.post(() -> DreamService.this.wakeUp(true /*fromSystem*/));\n        }\n\n        /** @hide */\n        void onActivityCreated(DreamActivity a) {\n            mActivity = a;\n            onWindowCreated(a.getWindow());\n        }\n    }\n}\n```",
            "diff_patched_upstream_only": "--- original_downstream_file\n+++ patched_upstream_only\n@@ -1,4 +1,3 @@\n-```java\n /**\n  * Copyright (C) 2012 The Android Open Source Project\n  *\n@@ -1169,5 +1168,4 @@\n             onWindowCreated(a.getWindow());\n         }\n     }\n-}\n-```+}",
            "downstream_llm_diff_output": "```diff\n--- a/core/java/android/service/dreams/DreamService.java\n+++ b/core/java/android/service/dreams/DreamService.java\n@@ -40,12 +40,17 @@\n import android.view.WindowManager.LayoutParams;\n import android.view.accessibility.AccessibilityEvent;\n \n+import com.android.internal.R;\n import com.android.internal.util.DumpUtils;\n import com.android.internal.util.DumpUtils.Dump;\n \n import java.io.FileDescriptor;\n+import java.io.IOException;\n import java.io.PrintWriter;\n \n+import org.xmlpull.v1.XmlPullParser;\n+import org.xmlpull.v1.XmlPullParserException;\n+\n /**\n  * Extend this class to implement a custom dream (available to the user as a \"Daydream\").\n  *\n@@ -136,6 +141,7 @@\n  * </pre>\n  */\n public class DreamService extends Service implements Window.Callback {\n+    // TAG is already defined\n     private final String TAG = DreamService.class.getSimpleName() + \"[\" + getClass().getSimpleName() + \"]\";\n \n     /**\n@@ -968,4 +974,98 @@\n             onWindowCreated(a.getWindow());\n         }\n     }\n+\n+    /**\n+     * Retrieves the metadata for a dream service.\n+     * @param context The context.\n+     * @param serviceInfo The ServiceInfo of the dream service.\n+     * @return The DreamMetadata, or null if not found or invalid.\n+     * @hide\n+     */\n+    @Nullable\n+    @TestApi\n+    public static DreamMetadata getDreamMetadata(@NonNull Context context,\n+            @Nullable ServiceInfo serviceInfo) {\n+        if (serviceInfo == null) return null;\n+\n+        PackageManager pm = context.getPackageManager();\n+        try {\n+            XmlResourceParser parser = serviceInfo.loadXmlMetaData(pm, DREAM_META_DATA);\n+            if (parser == null) {\n+                Log.w(TAG, \"No \" + DREAM_META_DATA + \" meta-data\");\n+                return null;\n+            }\n+            Resources res = pm.getResourcesForApplication(serviceInfo.applicationInfo);\n+            AttributeSet attrs = Xml.asAttributeSet(parser);\n+\n+            int type;\n+            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n+                    && type != XmlPullParser.START_TAG) {\n+            }\n+\n+            String nodeName = parser.getName();\n+            if (!\"dream\".equals(nodeName)) {\n+                Log.w(TAG, \"Meta-data does not start with dream tag\");\n+                if (parser != null) parser.close();\n+                return null;\n+            }\n+\n+            TypedArray sa = res.obtainAttributes(attrs, R.styleable.Dream);\n+            String settingsActivity = sa.getString(R.styleable.Dream_settingsActivity);\n+\n+            ComponentName settingsCN = convertToComponentName(settingsActivity, serviceInfo);\n+            boolean showWarning = sa.getBoolean(R.styleable.Dream_showWarningDialog, false);\n+            sa.recycle();\n+            if (parser != null) parser.close();\n+\n+            return new DreamMetadata(settingsCN, showWarning);\n+        } catch (PackageManager.NameNotFoundException e) {\n+            Log.w(TAG, \"Unable to load metadata for \" + serviceInfo.packageName, e);\n+        } catch (IOException e) {\n+            Log.w(TAG, \"Unable to load metadata for \" + serviceInfo.packageName, e);\n+        } catch (XmlPullParserException e) {\n+            Log.w(TAG, \"Unable to load metadata for \" + serviceInfo.packageName, e);\n+        }\n+        return null;\n+    }\n+\n+    @Nullable\n+    private static ComponentName convertToComponentName(@Nullable String flattenedString,\n+            ServiceInfo serviceInfo) {\n+        if (flattenedString == null) {\n+            return null;\n+        }\n+        if (flattenedString.indexOf('/') < 0) {\n+            return new ComponentName(serviceInfo.packageName, flattenedString);\n+        }\n+\n+        // Ensure that the component is from the same package as the dream service. If not,\n+        // treat the component as invalid and return null instead.\n+        final ComponentName cn = ComponentName.unflattenFromString(flattenedString);\n+        if (cn == null) return null;\n+        if (!cn.getPackageName().equals(serviceInfo.packageName)) {\n+            Log.w(TAG,\n+                    \"Inconsistent package name in component: \" + cn.getPackageName()\n+                            + \", should be: \" + serviceInfo.packageName);\n+            return null;\n+        }\n+        return cn;\n+    }\n+\n+    /**\n+     * Metadata about a dream.\n+     *\n+     * @hide\n+     */\n+    @TestApi\n+    public static final class DreamMetadata {\n+        @Nullable\n+        public final ComponentName settingsActivity;\n+        public final boolean showWarningDialog;\n+\n+        private DreamMetadata(ComponentName settingsActivity, boolean showWarningDialog) {\n+            this.settingsActivity = settingsActivity;\n+            this.showWarningDialog = showWarningDialog;\n+        }\n+    }\n }\n```",
            "llm_output_valid": true,
            "runtime_seconds": 596.83,
            "attempts_made": 3,
            "validation_results": [
              {
                "attempt": 1,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk is longer than expected",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 136.73
              },
              {
                "attempt": 2,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk diff line expected: ```",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 211.95
              },
              {
                "attempt": 3,
                "format_valid": true,
                "format_error": "Valid patch format",
                "apply_valid": true,
                "apply_error": "Patch applies cleanly in repo",
                "valid": true,
                "runtime_seconds": 237.51
              }
            ],
            "token_counts": {
              "openai": 1045,
              "general": {
                "word_based": 438,
                "char_based": 1189
              },
              "gemini": 34174
            }
          }
        ]
      },
      {
        "downstream_version": "12",
        "gemini_token_usage": 38790,
        "branch_used": "android12-release",
        "downstream_patch": "6926fd15fb16c51468dde270bd61ee68772b8c14",
        "repo_path": "android_repos/base",
        "result": "failure",
        "downstream_patch_content": "commit 6926fd15fb16c51468dde270bd61ee68772b8c14\nAuthor: Will Leshner <wleshner@google.com>\nDate:   Tue Oct 31 13:23:08 2023 -0700\n\n    Fix vulnerability that allowed attackers to start arbitary activities\n    \n    Test: Flashed device and verified dream settings works as expected\n    Test: Installed APK from bug and verified the dream didn't allow\n    launching the inappropriate settings activity.\n    Fixes: 300090204\n    \n    Merged-In: I6e90e3a0d513dceb7d7f5c59d6807ebe164c5716\n    Merged-In: I146415ad400827d0a798e27f34f098feb5e96422\n    Merged-In: I7f2351fc7d9a82778ce21f67018a45ac67c9aaf8\n    Change-Id: I573040df84bf98a493b39f96c8581e4303206bac\n\ndiff --git a/packages/SettingsLib/src/com/android/settingslib/dream/DreamBackend.java b/packages/SettingsLib/src/com/android/settingslib/dream/DreamBackend.java\nindex ab7b54d98285..beadd821957b 100644\n--- a/packages/SettingsLib/src/com/android/settingslib/dream/DreamBackend.java\n+++ b/packages/SettingsLib/src/com/android/settingslib/dream/DreamBackend.java\n@@ -351,7 +351,17 @@ public class DreamBackend {\n         if (cn != null && cn.indexOf('/') < 0) {\n             cn = resolveInfo.serviceInfo.packageName + \"/\" + cn;\n         }\n-        return cn == null ? null : ComponentName.unflattenFromString(cn);\n+        // Ensure that the component is from the same package as the dream service. If not,\n+        // treat the component as invalid and return null instead.\n+        final ComponentName result = cn != null ? ComponentName.unflattenFromString(cn) : null;\n+        if (result != null\n+                && !result.getPackageName().equals(resolveInfo.serviceInfo.packageName)) {\n+            Log.w(TAG,\n+                    \"Inconsistent package name in component: \" + result.getPackageName()\n+                            + \", should be: \" + resolveInfo.serviceInfo.packageName);\n+            return null;\n+        }\n+        return result;\n     }\n \n     private static void logd(String msg, Object... args) {\n",
        "downstream_patch_tokens": {
          "openai": 532,
          "general": {
            "word_based": 207,
            "char_based": 493
          },
          "gemini": 692
        },
        "file_conflicts": [
          {
            "file_name": "core/java/android/service/dreams/DreamService.java",
            "total_hunks": 5,
            "failed_hunks": [
              2,
              3,
              4,
              5
            ],
            "inline_merge_conflicts": [
              {
                "hunk_number": 1,
                "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n        mDreamToken = null;\n        mCanDoze = false;\n=======\n        // Ensure that the component is from the same package as the dream service. If not,\n        // treat the component as invalid and return null instead.\n        final ComponentName cn = ComponentName.unflattenFromString(flattenedString);\n        if (cn == null) return null;\n        if (!cn.getPackageName().equals(serviceInfo.packageName)) {\n            Log.w(TAG,\n                    \"Inconsistent package name in component: \" + cn.getPackageName()\n                            + \", should be: \" + serviceInfo.packageName);\n            return null;\n        }\n        return cn;\n>>>>>>> UPSTREAM PATCH (commit 2ce1b7fd37273ea19fbbb6daeeaa6212357b9a70)",
                "merge_conflict_tokens": {
                  "openai": 169,
                  "general": {
                    "word_based": 70,
                    "char_based": 187
                  },
                  "gemini": 197
                }
              }
            ],
            "inline_merge_token_summary": {
              "gemini": 13396,
              "openai": 11661,
              "general_word": 4830,
              "general_char": 12903
            },
            "rej_file_content": "```diff\n--- core/java/android/service/dreams/DreamService.java\n+++ core/java/android/service/dreams/DreamService.java\n@@ -1125,7 +1126,8 @@ public class DreamService extends Service implements Window.Callback {\n      * @hide\n      */\n     @Nullable\n-    public static DreamMetadata getDreamMetadata(Context context,\n+    @TestApi\n+    public static DreamMetadata getDreamMetadata(@NonNull Context context,\n             @Nullable ServiceInfo serviceInfo) {\n         if (serviceInfo == null) return null;\n \n@@ -1184,7 +1186,8 @@ public class DreamService extends Service implements Window.Callback {\n         }\n     }\n \n-    private static ComponentName convertToComponentName(String flattenedString,\n+    @Nullable\n+    private static ComponentName convertToComponentName(@Nullable String flattenedString,\n             ServiceInfo serviceInfo) {\n         if (flattenedString == null) {\n             return null;\n@@ -1194,7 +1197,17 @@ public class DreamService extends Service implements Window.Callback {\n             return new ComponentName(serviceInfo.packageName, flattenedString);\n         }\n \n-        return ComponentName.unflattenFromString(flattenedString);\n+        // Ensure that the component is from the same package as the dream service. If not,\n+        // treat the component as invalid and return null instead.\n+        final ComponentName cn = ComponentName.unflattenFromString(flattenedString);\n+        if (cn == null) return null;\n+        if (!cn.getPackageName().equals(serviceInfo.packageName)) {\n+            Log.w(TAG,\n+                    \"Inconsistent package name in component: \" + cn.getPackageName()\n+                            + \", should be: \" + serviceInfo.packageName);\n+            return null;\n+        }\n+        return cn;\n     }\n \n     /**\n@@ -1490,6 +1503,7 @@ public class DreamService extends Service implements Window.Callback {\n      *\n      * @hide\n      */\n+    @TestApi\n     public static final class DreamMetadata {\n         @Nullable\n         public final ComponentName settingsActivity;\n```",
            "rej_file_tokens": {
              "openai": 434,
              "general": {
                "word_based": 188,
                "char_based": 507
              },
              "gemini": 504
            },
            "patch_apply_output": "patching file core/java/android/service/dreams/DreamService.java\nHunk #1 succeeded at 21 (offset -1 lines).\nHunk #2 FAILED at 1125.\nHunk #3 FAILED at 1184.\nHunk #4 FAILED at 1194.\nHunk #5 FAILED at 1490.\n4 out of 5 hunks FAILED -- saving rejects to file core/java/android/service/dreams/DreamService.java.rej",
            "inline_merge_output": "patching file core/java/android/service/dreams/DreamService.java\nHunk #1 already applied at 25.\nHunk #2 already applied at 1128-1129.\nHunk #3 already applied at 1188-1189.\nHunk #4 NOT MERGED at 1230-1245.\nHunk #5 already applied at 1519.",
            "upstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage android.service.dreams;\n\nimport android.annotation.IdRes;\nimport android.annotation.LayoutRes;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.SdkConstant;\nimport android.annotation.SdkConstant.SdkConstantType;\nimport android.annotation.TestApi;\nimport android.app.Activity;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.Service;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ServiceInfo;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.graphics.drawable.Drawable;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.IRemoteCallback;\nimport android.os.Looper;\nimport android.os.PowerManager;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.util.MathUtils;\nimport android.util.Slog;\nimport android.util.Xml;\nimport android.view.ActionMode;\nimport android.view.Display;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SearchEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowInsets;\nimport android.view.WindowManager;\nimport android.view.WindowManager.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.R;\nimport com.android.internal.util.DumpUtils;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.FileDescriptor;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.function.Consumer;\n\n/**\n * Extend this class to implement a custom dream (available to the user as a \"Daydream\").\n *\n * <p>Dreams are interactive screensavers launched when a charging device is idle, or docked in a\n * desk dock. Dreams provide another modality for apps to express themselves, tailored for\n * an exhibition/lean-back experience.</p>\n *\n * <p>The {@code DreamService} lifecycle is as follows:</p>\n * <ol>\n *   <li>{@link #onAttachedToWindow}\n *     <p>Use this for initial setup, such as calling {@link #setContentView setContentView()}.</li>\n *   <li>{@link #onDreamingStarted}\n *     <p>Your dream has started, so you should begin animations or other behaviors here.</li>\n *   <li>{@link #onDreamingStopped}\n *     <p>Use this to stop the things you started in {@link #onDreamingStarted}.</li>\n *   <li>{@link #onDetachedFromWindow}\n *     <p>Use this to dismantle resources (for example, detach from handlers\n *        and listeners).</li>\n * </ol>\n *\n * <p>In addition, onCreate and onDestroy (from the Service interface) will also be called, but\n * initialization and teardown should be done by overriding the hooks above.</p>\n *\n * <p>To be available to the system, your {@code DreamService} should be declared in the\n * manifest as follows:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\" >\n *\n *     &lt;intent-filter>\n *         &lt;action android:name=\"android.service.dreams.DreamService\" />\n *         &lt;category android:name=\"android.intent.category.DEFAULT\" />\n *     &lt;/intent-filter>\n *\n *     &lt;!-- Point to additional information for this dream (optional) -->\n *     &lt;meta-data\n *         android:name=\"android.service.dream\"\n *         android:resource=\"@xml/my_dream\" />\n * &lt;/service>\n * </pre>\n *\n * <p>If specified with the {@code <meta-data>} element,\n * additional information for the dream is defined using the\n * {@link android.R.styleable#Dream &lt;dream&gt;} element in a separate XML file.\n * Currently, the only additional\n * information you can provide is for a settings activity that allows the user to configure\n * the dream behavior. For example:</p>\n * <p class=\"code-caption\">res/xml/my_dream.xml</p>\n * <pre>\n * &lt;dream xmlns:android=\"http://schemas.android.com/apk/res/android\"\n *     android:settingsActivity=\"com.example.app/.MyDreamSettingsActivity\" />\n * </pre>\n * <p>This makes a Settings button available alongside your dream's listing in the\n * system settings, which when pressed opens the specified activity.</p>\n *\n *\n * <p>To specify your dream layout, call {@link #setContentView}, typically during the\n * {@link #onAttachedToWindow} callback. For example:</p>\n * <pre>\n * public class MyDream extends DreamService {\n *\n *     &#64;Override\n *     public void onAttachedToWindow() {\n *         super.onAttachedToWindow();\n *\n *         // Exit dream upon user touch\n *         setInteractive(false);\n *         // Hide system UI\n *         setFullscreen(true);\n *         // Set the dream layout\n *         setContentView(R.layout.dream);\n *     }\n * }\n * </pre>\n *\n * <p>When targeting api level 21 and above, you must declare the service in your manifest file\n * with the {@link android.Manifest.permission#BIND_DREAM_SERVICE} permission. For example:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\"\n *     android:permission=\"android.permission.BIND_DREAM_SERVICE\">\n *   &lt;intent-filter>\n *     &lt;action android:name=\u201dandroid.service.dreams.DreamService\u201d />\n *     &lt;category android:name=\u201dandroid.intent.category.DEFAULT\u201d />\n *   &lt;/intent-filter>\n * &lt;/service>\n * </pre>\n */\npublic class DreamService extends Service implements Window.Callback {\n    private static final String TAG = DreamService.class.getSimpleName();\n    private final String mTag = TAG + \"[\" + getClass().getSimpleName() + \"]\";\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n\n    /**\n     * The name of the dream manager service.\n     * @hide\n     */\n    public static final String DREAM_SERVICE = \"dreams\";\n\n    /**\n     * The {@link Intent} that must be declared as handled by the service.\n     */\n    @SdkConstant(SdkConstantType.SERVICE_ACTION)\n    public static final String SERVICE_INTERFACE =\n            \"android.service.dreams.DreamService\";\n\n    /**\n     * The name of the extra where the dream overlay component is stored.\n     * @hide\n     */\n    public static final String EXTRA_DREAM_OVERLAY_COMPONENT =\n            \"android.service.dream.DreamService.dream_overlay_component\";\n\n    /**\n     * Name under which a Dream publishes information about itself.\n     * This meta-data must reference an XML resource containing\n     * a <code>&lt;{@link android.R.styleable#Dream dream}&gt;</code>\n     * tag.\n     */\n    public static final String DREAM_META_DATA = \"android.service.dream\";\n\n    /**\n     * Name of the root tag under which a Dream defines its metadata in an XML file.\n     */\n    private static final String DREAM_META_DATA_ROOT_TAG = \"dream\";\n\n    /**\n     * Extra containing a boolean for whether to show complications on the overlay.\n     * @hide\n     */\n    public static final String EXTRA_SHOW_COMPLICATIONS =\n            \"android.service.dreams.SHOW_COMPLICATIONS\";\n\n    /**\n     * The default value for whether to show complications on the overlay.\n     * @hide\n     */\n    public static final boolean DEFAULT_SHOW_COMPLICATIONS = false;\n\n    private final IDreamManager mDreamManager;\n    private final Handler mHandler = new Handler(Looper.getMainLooper());\n    private IBinder mDreamToken;\n    private Window mWindow;\n    private Activity mActivity;\n    private boolean mInteractive;\n    private boolean mFullscreen;\n    private boolean mScreenBright = true;\n    private boolean mStarted;\n    private boolean mWaking;\n    private boolean mFinished;\n    private boolean mCanDoze;\n    private boolean mDozing;\n    private boolean mWindowless;\n    private int mDozeScreenState = Display.STATE_UNKNOWN;\n    private int mDozeScreenBrightness = PowerManager.BRIGHTNESS_DEFAULT;\n\n    private boolean mDebug = false;\n\n    private DreamServiceWrapper mDreamServiceWrapper;\n    private Runnable mDispatchAfterOnAttachedToWindow;\n\n    private final OverlayConnection mOverlayConnection;\n\n    private static class OverlayConnection implements ServiceConnection {\n        // Overlay set during onBind.\n        private IDreamOverlay mOverlay;\n        // A Queue of pending requests to execute on the overlay.\n        private final ArrayDeque<Consumer<IDreamOverlay>> mRequests;\n\n        private boolean mBound;\n\n        OverlayConnection() {\n            mRequests = new ArrayDeque<>();\n        }\n\n        public void bind(Context context, @Nullable ComponentName overlayService,\n                ComponentName dreamService) {\n            if (overlayService == null) {\n                return;\n            }\n\n            final ServiceInfo serviceInfo = fetchServiceInfo(context, dreamService);\n\n            final Intent overlayIntent = new Intent();\n            overlayIntent.setComponent(overlayService);\n            overlayIntent.putExtra(EXTRA_SHOW_COMPLICATIONS,\n                    fetchShouldShowComplications(context, serviceInfo));\n\n            context.bindService(overlayIntent,\n                    this, Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE);\n            mBound = true;\n        }\n\n        public void unbind(Context context) {\n            if (!mBound) {\n                return;\n            }\n\n            context.unbindService(this);\n            mBound = false;\n        }\n\n        public void request(Consumer<IDreamOverlay> request) {\n            mRequests.push(request);\n            evaluate();\n        }\n\n        private void evaluate() {\n            if (mOverlay == null) {\n                return;\n            }\n\n            // Any new requests that arrive during this loop will be processed synchronously after\n            // the loop exits.\n            while (!mRequests.isEmpty()) {\n                final Consumer<IDreamOverlay> request = mRequests.pop();\n                request.accept(mOverlay);\n            }\n        }\n\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            // Store Overlay and execute pending requests.\n            mOverlay = IDreamOverlay.Stub.asInterface(service);\n            evaluate();\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            // Clear Overlay binder to prevent further request processing.\n            mOverlay = null;\n        }\n    }\n\n    private final IDreamOverlayCallback mOverlayCallback = new IDreamOverlayCallback.Stub() {\n        @Override\n        public void onExitRequested() {\n            // Simply finish dream when exit is requested.\n            finish();\n        }\n    };\n\n\n    public DreamService() {\n        mDreamManager = IDreamManager.Stub.asInterface(ServiceManager.getService(DREAM_SERVICE));\n        mOverlayConnection = new OverlayConnection();\n    }\n\n    /**\n     * @hide\n     */\n    public void setDebug(boolean dbg) {\n        mDebug = dbg;\n    }\n\n    // begin Window.Callback methods\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK\n        if (!mInteractive) {\n            if (mDebug) Slog.v(mTag, \"Waking up on keyEvent\");\n            wakeUp();\n            return true;\n        } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {\n            if (mDebug) Slog.v(mTag, \"Waking up on back key\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyShortcutEvent(KeyEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(mTag, \"Waking up on keyShortcutEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyShortcutEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // TODO: create more flexible version of mInteractive that allows clicks\n        // but finish()es on any other kind of activity\n        if (!mInteractive && event.getActionMasked() == MotionEvent.ACTION_UP) {\n            if (mDebug) Slog.v(mTag, \"Waking up on touchEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTouchEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTrackballEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(mTag, \"Waking up on trackballEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTrackballEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchGenericMotionEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(mTag, \"Waking up on genericMotionEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchGenericMotionEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public View onCreatePanelView(int featureId) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onCreatePanelMenu(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onPreparePanel(int featureId, View view, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuOpened(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowAttributesChanged(LayoutParams attrs) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onContentChanged() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowFocusChanged(boolean hasFocus) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onAttachedToWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDetachedFromWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onPanelClosed(int featureId, Menu menu) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested(SearchEvent event) {\n        return onSearchRequested();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested() {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(\n            android.view.ActionMode.Callback callback, int type) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeStarted(ActionMode mode) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeFinished(ActionMode mode) {\n    }\n    // end Window.Callback methods\n\n    // begin public api\n    /**\n     * Retrieves the current {@link android.view.WindowManager} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindowManager()}.\n     *\n     * @return The current window manager, or null if the dream is not started.\n     */\n    public WindowManager getWindowManager() {\n        return mWindow != null ? mWindow.getWindowManager() : null;\n    }\n\n    /**\n     * Retrieves the current {@link android.view.Window} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindow()}.\n     *\n     * @return The current window, or null if the dream is not started.\n     */\n    public Window getWindow() {\n        return mWindow;\n    }\n\n   /**\n     * Inflates a layout resource and set it to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(int)}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param layoutResID Resource ID to be inflated.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(android.view.View)} in an activity,\n     * including using {@link ViewGroup.LayoutParams#MATCH_PARENT} as the layout height and width of the view.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @see #setContentView(int)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(View view) {\n        getWindow().setContentView(view);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to\n     * {@link android.app.Activity#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)}\n     * in an activity.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(int)\n     */\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().setContentView(view, params);\n    }\n\n    /**\n     * Adds a view to the Dream's window, leaving other content views in place.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     */\n    public void addContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().addContentView(view, params);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that\n     * was processed in {@link #onCreate}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return The view if found or null otherwise.\n     * @see View#findViewById(int)\n     * @see DreamService#requireViewById(int)\n     */\n    @Nullable\n    public <T extends View> T findViewById(@IdRes int id) {\n        return getWindow().findViewById(id);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that was processed in\n     * {@link #onCreate}, or throws an IllegalArgumentException if the ID is invalid or there is no\n     * matching view in the hierarchy.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return a view with given ID\n     * @see View#requireViewById(int)\n     * @see DreamService#findViewById(int)\n     */\n    @NonNull\n    public final <T extends View> T requireViewById(@IdRes int id) {\n        T view = findViewById(id);\n        if (view == null) {\n            throw new IllegalArgumentException(\n                    \"ID does not reference a View inside this DreamService\");\n        }\n        return view;\n    }\n\n    /**\n     * Marks this dream as interactive to receive input events.\n     *\n     * <p>Non-interactive dreams (default) will dismiss on the first input event.</p>\n     *\n     * <p>Interactive dreams should call {@link #finish()} to dismiss themselves.</p>\n     *\n     * @param interactive True if this dream will handle input events.\n     */\n    public void setInteractive(boolean interactive) {\n        mInteractive = interactive;\n    }\n\n    /**\n     * Returns whether this dream is interactive. Defaults to false.\n     *\n     * @see #setInteractive(boolean)\n     */\n    public boolean isInteractive() {\n        return mInteractive;\n    }\n\n    /**\n     * Controls {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN}\n     * on the dream's window.\n     *\n     * @param fullscreen If true, the fullscreen flag will be set; else it\n     * will be cleared.\n     */\n    public void setFullscreen(boolean fullscreen) {\n        if (mFullscreen != fullscreen) {\n            mFullscreen = fullscreen;\n            int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;\n            applyWindowFlags(mFullscreen ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether this dream is in fullscreen mode. Defaults to false.\n     *\n     * @see #setFullscreen(boolean)\n     */\n    public boolean isFullscreen() {\n        return mFullscreen;\n    }\n\n    /**\n     * Marks this dream as keeping the screen bright while dreaming.\n     *\n     * @param screenBright True to keep the screen bright while dreaming.\n     */\n    public void setScreenBright(boolean screenBright) {\n        if (mScreenBright != screenBright) {\n            mScreenBright = screenBright;\n            int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;\n            applyWindowFlags(mScreenBright ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether this dream keeps the screen bright while dreaming.\n     * Defaults to false, allowing the screen to dim if necessary.\n     *\n     * @see #setScreenBright(boolean)\n     */\n    public boolean isScreenBright() {\n        return getWindowFlagValue(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, mScreenBright);\n    }\n\n    /**\n     * Marks this dream as windowless. Only available to doze dreams.\n     *\n     * @hide\n     *\n     */\n    public void setWindowless(boolean windowless) {\n        mWindowless = windowless;\n    }\n\n    /**\n     * Returns whether this dream is windowless. Only available to doze dreams.\n     *\n     * @hide\n     */\n    public boolean isWindowless() {\n        return mWindowless;\n    }\n\n    /**\n     * Returns true if this dream is allowed to doze.\n     * <p>\n     * The value returned by this method is only meaningful when the dream has started.\n     * </p>\n     *\n     * @return True if this dream can doze.\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean canDoze() {\n        return mCanDoze;\n    }\n\n    /**\n     * Starts dozing, entering a deep dreamy sleep.\n     * <p>\n     * Dozing enables the system to conserve power while the user is not actively interacting\n     * with the device. While dozing, the display will remain on in a low-power state\n     * and will continue to show its previous contents but the application processor and\n     * other system components will be allowed to suspend when possible.\n     * </p><p>\n     * While the application processor is suspended, the dream may stop executing code\n     * for long periods of time. Prior to being suspended, the dream may schedule periodic\n     * wake-ups to render new content by scheduling an alarm with the {@link AlarmManager}.\n     * The dream may also keep the CPU awake by acquiring a\n     * {@link android.os.PowerManager#PARTIAL_WAKE_LOCK partial wake lock} when necessary.\n     * Note that since the purpose of doze mode is to conserve power (especially when\n     * running on battery), the dream should not wake the CPU very often or keep it\n     * awake for very long.\n     * </p><p>\n     * It is a good idea to call this method some time after the dream's entry animation\n     * has completed and the dream is ready to doze. It is important to completely\n     * finish all of the work needed before dozing since the application processor may\n     * be suspended at any moment once this method is called unless other wake locks\n     * are being held.\n     * </p><p>\n     * Call {@link #stopDozing} or {@link #finish} to stop dozing.\n     * </p>\n     *\n     * @see #stopDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void startDozing() {\n        if (mCanDoze && !mDozing) {\n            mDozing = true;\n            updateDoze();\n        }\n    }\n\n    private void updateDoze() {\n        if (mDreamToken == null) {\n            Slog.w(mTag, \"Updating doze without a dream token.\");\n            return;\n        }\n\n        if (mDozing) {\n            try {\n                mDreamManager.startDozing(mDreamToken, mDozeScreenState, mDozeScreenBrightness);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Stops dozing, returns to active dreaming.\n     * <p>\n     * This method reverses the effect of {@link #startDozing}. From this moment onward,\n     * the application processor will be kept awake as long as the dream is running\n     * or until the dream starts dozing again.\n     * </p>\n     *\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public void stopDozing() {\n        if (mDozing) {\n            mDozing = false;\n            try {\n                mDreamManager.stopDozing(mDreamToken);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Returns true if the dream will allow the system to enter a low-power state while\n     * it is running without actually turning off the screen. Defaults to false,\n     * keeping the application processor awake while the dream is running.\n     *\n     * @return True if the dream is dozing.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean isDozing() {\n        return mDozing;\n    }\n\n    /**\n     * Gets the screen state to use while dozing.\n     *\n     * @return The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @see #setDozeScreenState\n     * @hide For use by system UI components only.\n     */\n    public int getDozeScreenState() {\n        return mDozeScreenState;\n    }\n\n    /**\n     * Sets the screen state to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called. The default value is\n     * {@link Display#STATE_UNKNOWN} which lets the system decide.\n     * The dream may set a different state before starting to doze and may\n     * perform transitions between states while dozing to conserve power and\n     * achieve various effects.\n     * </p><p>\n     * Some devices will have dedicated hardware (\"Sidekick\") to animate\n     * the display content while the CPU sleeps. If the dream and the hardware support\n     * this, {@link Display#STATE_ON_SUSPEND} or {@link Display#STATE_DOZE_SUSPEND}\n     * will switch control to the Sidekick.\n     * </p><p>\n     * If not using Sidekick, it is recommended that the state be set to\n     * {@link Display#STATE_DOZE_SUSPEND} once the dream has completely\n     * finished drawing and before it releases its wakelock\n     * to allow the display hardware to be fully suspended. While suspended,\n     * the display will preserve its on-screen contents.\n     * </p><p>\n     * If the doze suspend state is used, the dream must make sure to set the mode back\n     * to {@link Display#STATE_DOZE} or {@link Display#STATE_ON} before drawing again\n     * since the display updates may be ignored and not seen by the user otherwise.\n     * </p><p>\n     * The set of available display power states and their behavior while dozing is\n     * hardware dependent and may vary across devices. The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param state The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenState(int state) {\n        if (mDozeScreenState != state) {\n            mDozeScreenState = state;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Gets the screen brightness to use while dozing.\n     *\n     * @return The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @see #setDozeScreenBrightness\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)\n    public int getDozeScreenBrightness() {\n        return mDozeScreenBrightness;\n    }\n\n    /**\n     * Sets the screen brightness to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called. The default value is\n     * {@link PowerManager#BRIGHTNESS_DEFAULT} which lets the system decide.\n     * The dream may set a different brightness before starting to doze and may adjust\n     * the brightness while dozing to conserve power and achieve various effects.\n     * </p><p>\n     * Note that dream may specify any brightness in the full 0-255 range, including\n     * values that are less than the minimum value for manual screen brightness\n     * adjustments by the user. In particular, the value may be set to 0 which may\n     * turn off the backlight entirely while still leaving the screen on although\n     * this behavior is device dependent and not guaranteed.\n     * </p><p>\n     * The available range of display brightness values and their behavior while dozing is\n     * hardware dependent and may vary across devices. The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param brightness The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenBrightness(int brightness) {\n        if (brightness != PowerManager.BRIGHTNESS_DEFAULT) {\n            brightness = clampAbsoluteBrightness(brightness);\n        }\n        if (mDozeScreenBrightness != brightness) {\n            mDozeScreenBrightness = brightness;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Called when this Dream is constructed.\n     */\n    @Override\n    public void onCreate() {\n        if (mDebug) Slog.v(mTag, \"onCreate()\");\n        super.onCreate();\n    }\n\n    /**\n     * Called when the dream's window has been created and is visible and animation may now begin.\n     */\n    public void onDreamingStarted() {\n        if (mDebug) Slog.v(mTag, \"onDreamingStarted()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when this Dream is stopped, either by external request or by calling finish(),\n     * before the window has been removed.\n     */\n    public void onDreamingStopped() {\n        if (mDebug) Slog.v(mTag, \"onDreamingStopped()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when the dream is being asked to stop itself and wake.\n     * <p>\n     * The default implementation simply calls {@link #finish} which ends the dream\n     * immediately. Subclasses may override this function to perform a smooth exit\n     * transition then call {@link #finish} afterwards.\n     * </p><p>\n     * Note that the dream will only be given a short period of time (currently about\n     * five seconds) to wake up. If the dream does not finish itself in a timely manner\n     * then the system will forcibly finish it once the time allowance is up.\n     * </p>\n     */\n    public void onWakeUp() {\n        finish();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public final IBinder onBind(Intent intent) {\n        if (mDebug) Slog.v(mTag, \"onBind() intent = \" + intent);\n        mDreamServiceWrapper = new DreamServiceWrapper();\n\n        // Connect to the overlay service if present.\n        if (!mWindowless) {\n            mOverlayConnection.bind(\n                    /* context= */ this,\n                    intent.getParcelableExtra(EXTRA_DREAM_OVERLAY_COMPONENT),\n                    new ComponentName(this, getClass()));\n        }\n\n        return mDreamServiceWrapper;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        // We must unbind from any overlay connection if we are unbound before finishing.\n        mOverlayConnection.unbind(this);\n\n        return super.onUnbind(intent);\n    }\n\n    /**\n     * Stops the dream and detaches from the window.\n     * <p>\n     * When the dream ends, the system will be allowed to go to sleep fully unless there\n     * is a reason for it to be awake such as recent user activity or wake locks being held.\n     * </p>\n     */\n    public final void finish() {\n        if (mDebug) Slog.v(mTag, \"finish(): mFinished=\" + mFinished);\n\n        Activity activity = mActivity;\n        if (activity != null) {\n            if (!activity.isFinishing()) {\n                // In case the activity is not finished yet, do it now.\n                activity.finishAndRemoveTask();\n            }\n            return;\n        }\n\n        if (mFinished) {\n            return;\n        }\n        mFinished = true;\n\n        mOverlayConnection.unbind(this);\n\n        if (mDreamToken == null) {\n            Slog.w(mTag, \"Finish was called before the dream was attached.\");\n            stopSelf();\n            return;\n        }\n\n        try {\n            // finishSelf will unbind the dream controller from the dream service. This will\n            // trigger DreamService.this.onDestroy and DreamService.this will die.\n            mDreamManager.finishSelf(mDreamToken, true /*immediate*/);\n        } catch (RemoteException ex) {\n            // system server died\n        }\n    }\n\n    /**\n     * Wakes the dream up gently.\n     * <p>\n     * Calls {@link #onWakeUp} to give the dream a chance to perform an exit transition.\n     * When the transition is over, the dream should call {@link #finish}.\n     * </p>\n     */\n    public final void wakeUp() {\n        wakeUp(false);\n    }\n\n    private void wakeUp(boolean fromSystem) {\n        if (mDebug) {\n            Slog.v(mTag, \"wakeUp(): fromSystem=\" + fromSystem + \", mWaking=\" + mWaking\n                    + \", mFinished=\" + mFinished);\n        }\n\n        if (!mWaking && !mFinished) {\n            mWaking = true;\n\n            if (mActivity != null) {\n                // During wake up the activity should be translucent to allow the application\n                // underneath to start drawing. Normally, the WM animation system takes care of\n                // this, but here we give the dream application some time to perform a custom exit\n                // animation. If it uses a view animation, the WM doesn't know about it and can't\n                // make the activity translucent in the normal way. Therefore, here we ensure that\n                // the activity is translucent during wake up regardless of what animation is used\n                // in onWakeUp().\n                mActivity.convertToTranslucent(null, null);\n            }\n\n            // As a minor optimization, invoke the callback first in case it simply\n            // calls finish() immediately so there wouldn't be much point in telling\n            // the system that we are finishing the dream gently.\n            onWakeUp();\n\n            // Now tell the system we are waking gently, unless we already told\n            // it we were finishing immediately.\n            if (!fromSystem && !mFinished) {\n                if (mActivity == null) {\n                    Slog.w(mTag, \"WakeUp was called before the dream was attached.\");\n                } else {\n                    try {\n                        mDreamManager.finishSelf(mDreamToken, false /*immediate*/);\n                    } catch (RemoteException ex) {\n                        // system server died\n                    }\n                }\n            }\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDestroy() {\n        if (mDebug) Slog.v(mTag, \"onDestroy()\");\n        // hook for subclasses\n\n        // Just in case destroy came in before detach, let's take care of that now\n        detach();\n\n        super.onDestroy();\n    }\n\n    // end public api\n\n    /**\n     * Parses and returns metadata of the dream service indicated by the service info. Returns null\n     * if metadata cannot be found.\n     *\n     * Note that {@link ServiceInfo} must be fetched with {@link PackageManager#GET_META_DATA} flag.\n     *\n     * @hide\n     */\n    @Nullable\n    @TestApi\n    public static DreamMetadata getDreamMetadata(@NonNull Context context,\n            @Nullable ServiceInfo serviceInfo) {\n        if (serviceInfo == null) return null;\n\n        final PackageManager pm = context.getPackageManager();\n\n        try (TypedArray rawMetadata = readMetadata(pm, serviceInfo)) {\n            if (rawMetadata == null) return null;\n            return new DreamMetadata(\n                    convertToComponentName(rawMetadata.getString(\n                            com.android.internal.R.styleable.Dream_settingsActivity), serviceInfo),\n                    rawMetadata.getDrawable(\n                            com.android.internal.R.styleable.Dream_previewImage),\n                    rawMetadata.getBoolean(R.styleable.Dream_showClockAndComplications,\n                            DEFAULT_SHOW_COMPLICATIONS));\n        }\n    }\n\n    /**\n     * Returns the raw XML metadata fetched from the {@link ServiceInfo}.\n     *\n     * Returns <code>null</code> if the {@link ServiceInfo} doesn't contain valid dream metadata.\n     */\n    @Nullable\n    private static TypedArray readMetadata(PackageManager pm, ServiceInfo serviceInfo) {\n        if (serviceInfo == null || serviceInfo.metaData == null) {\n            return null;\n        }\n\n        try (XmlResourceParser parser =\n                     serviceInfo.loadXmlMetaData(pm, DreamService.DREAM_META_DATA)) {\n            if (parser == null) {\n                if (DEBUG) Log.w(TAG, \"No \" + DreamService.DREAM_META_DATA + \" metadata\");\n                return null;\n            }\n\n            final AttributeSet attrs = Xml.asAttributeSet(parser);\n            while (true) {\n                final int type = parser.next();\n                if (type == XmlPullParser.END_DOCUMENT || type == XmlPullParser.START_TAG) {\n                    break;\n                }\n            }\n\n            if (!parser.getName().equals(DREAM_META_DATA_ROOT_TAG)) {\n                if (DEBUG) {\n                    Log.w(TAG, \"Metadata does not start with \" + DREAM_META_DATA_ROOT_TAG + \" tag\");\n                }\n                return null;\n            }\n\n            return pm.getResourcesForApplication(serviceInfo.applicationInfo).obtainAttributes(\n                    attrs, com.android.internal.R.styleable.Dream);\n        } catch (PackageManager.NameNotFoundException | IOException | XmlPullParserException e) {\n            if (DEBUG) Log.e(TAG, \"Error parsing: \" + serviceInfo.packageName, e);\n            return null;\n        }\n    }\n\n    @Nullable\n    private static ComponentName convertToComponentName(@Nullable String flattenedString,\n            ServiceInfo serviceInfo) {\n        if (flattenedString == null) {\n            return null;\n        }\n\n        if (!flattenedString.contains(\"/\")) {\n            return new ComponentName(serviceInfo.packageName, flattenedString);\n        }\n\n        // Ensure that the component is from the same package as the dream service. If not,\n        // treat the component as invalid and return null instead.\n        final ComponentName cn = ComponentName.unflattenFromString(flattenedString);\n        if (cn == null) return null;\n        if (!cn.getPackageName().equals(serviceInfo.packageName)) {\n            Log.w(TAG,\n                    \"Inconsistent package name in component: \" + cn.getPackageName()\n                            + \", should be: \" + serviceInfo.packageName);\n            return null;\n        }\n        return cn;\n    }\n\n    /**\n     * Called by DreamController.stopDream() when the Dream is about to be unbound and destroyed.\n     *\n     * Must run on mHandler.\n     */\n    private void detach() {\n        if (mStarted) {\n            if (mDebug) Slog.v(mTag, \"detach(): Calling onDreamingStopped()\");\n            mStarted = false;\n            onDreamingStopped();\n        }\n\n        if (mActivity != null && !mActivity.isFinishing()) {\n            mActivity.finishAndRemoveTask();\n        } else {\n            finish();\n        }\n\n        mDreamToken = null;\n        mCanDoze = false;\n    }\n\n    /**\n     * Called when the Dream is ready to be shown.\n     *\n     * Must run on mHandler.\n     *\n     * @param dreamToken Token for this dream service.\n     * @param started A callback that will be invoked once onDreamingStarted has completed.\n     */\n    private void attach(IBinder dreamToken, boolean canDoze, IRemoteCallback started) {\n        if (mDreamToken != null) {\n            Slog.e(mTag, \"attach() called when dream with token=\" + mDreamToken\n                    + \" already attached\");\n            return;\n        }\n        if (mFinished || mWaking) {\n            Slog.w(mTag, \"attach() called after dream already finished\");\n            try {\n                mDreamManager.finishSelf(dreamToken, true /*immediate*/);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n            return;\n        }\n\n        mDreamToken = dreamToken;\n        mCanDoze = canDoze;\n        if (mWindowless && !mCanDoze) {\n            throw new IllegalStateException(\"Only doze dreams can be windowless\");\n        }\n\n        mDispatchAfterOnAttachedToWindow = () -> {\n            if (mWindow != null || mWindowless) {\n                mStarted = true;\n                try {\n                    onDreamingStarted();\n                } finally {\n                    try {\n                        started.sendResult(null);\n                    } catch (RemoteException e) {\n                        throw e.rethrowFromSystemServer();\n                    }\n                }\n            }\n        };\n\n        // We need to defer calling onDreamingStarted until after the activity is created.\n        // If the dream is windowless, we can call it immediately. Otherwise, we wait\n        // for the DreamActivity to report onActivityCreated via\n        // DreamServiceWrapper.onActivityCreated.\n        if (!mWindowless) {\n            Intent i = new Intent(this, DreamActivity.class);\n            i.setPackage(getApplicationContext().getPackageName());\n            i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            i.putExtra(DreamActivity.EXTRA_CALLBACK, new DreamActivityCallback(mDreamToken));\n            final ServiceInfo serviceInfo = fetchServiceInfo(this,\n                    new ComponentName(this, getClass()));\n            i.putExtra(DreamActivity.EXTRA_DREAM_TITLE, fetchDreamLabel(this, serviceInfo));\n\n            try {\n                if (!ActivityTaskManager.getService().startDreamActivity(i)) {\n                    detach();\n                }\n            } catch (RemoteException e) {\n                Log.w(mTag, \"Could not connect to activity task manager to start dream activity\");\n                e.rethrowFromSystemServer();\n            }\n        } else {\n            mDispatchAfterOnAttachedToWindow.run();\n        }\n    }\n\n    private void onWindowCreated(Window w) {\n        mWindow = w;\n        mWindow.setCallback(this);\n        mWindow.requestFeature(Window.FEATURE_NO_TITLE);\n\n        WindowManager.LayoutParams lp = mWindow.getAttributes();\n        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN\n                    | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR\n                    | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED\n                    | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD\n                    | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON\n                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED\n                    | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0)\n                    | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0)\n                    );\n        lp.layoutInDisplayCutoutMode =\n                WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS;\n        mWindow.setAttributes(lp);\n        // Workaround: Currently low-profile and in-window system bar backgrounds don't go\n        // along well. Dreams usually don't need such bars anyways, so disable them by default.\n        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n\n        // Hide all insets when the dream is showing\n        mWindow.getDecorView().getWindowInsetsController().hide(WindowInsets.Type.systemBars());\n        mWindow.setDecorFitsSystemWindows(false);\n\n        mWindow.getDecorView().addOnAttachStateChangeListener(\n                new View.OnAttachStateChangeListener() {\n                    @Override\n                    public void onViewAttachedToWindow(View v) {\n                        mDispatchAfterOnAttachedToWindow.run();\n\n                        // Request the DreamOverlay be told to dream with dream's window parameters\n                        // once the window has been attached.\n                        mOverlayConnection.request(overlay -> {\n                            try {\n                                overlay.startDream(mWindow.getAttributes(), mOverlayCallback);\n                            } catch (RemoteException e) {\n                                Log.e(mTag, \"could not send window attributes:\" + e);\n                            }\n                        });\n                    }\n\n                    @Override\n                    public void onViewDetachedFromWindow(View v) {\n                        if (mActivity == null || !mActivity.isChangingConfigurations()) {\n                            // Only stop the dream if the view is not detached by relaunching\n                            // activity for configuration changes. It is important to also clear\n                            // the window reference in order to fully release the DreamActivity.\n                            mWindow = null;\n                            mActivity = null;\n                            finish();\n                        }\n                    }\n                });\n    }\n\n    private boolean getWindowFlagValue(int flag, boolean defaultValue) {\n        return mWindow == null ? defaultValue : (mWindow.getAttributes().flags & flag) != 0;\n    }\n\n    private void applyWindowFlags(int flags, int mask) {\n        if (mWindow != null) {\n            WindowManager.LayoutParams lp = mWindow.getAttributes();\n            lp.flags = applyFlags(lp.flags, flags, mask);\n            mWindow.setAttributes(lp);\n            mWindow.getWindowManager().updateViewLayout(mWindow.getDecorView(), lp);\n        }\n    }\n\n    private int applyFlags(int oldFlags, int flags, int mask) {\n        return (oldFlags&~mask) | (flags&mask);\n    }\n\n    /**\n     * Fetches metadata of the dream indicated by the {@link ComponentName}, and returns whether\n     * the dream should show complications on the overlay. If not defined, returns\n     * {@link DreamService#DEFAULT_SHOW_COMPLICATIONS}.\n     */\n    private static boolean fetchShouldShowComplications(Context context,\n            @Nullable ServiceInfo serviceInfo) {\n        final DreamMetadata metadata = getDreamMetadata(context, serviceInfo);\n        if (metadata != null) {\n            return metadata.showComplications;\n        }\n        return DEFAULT_SHOW_COMPLICATIONS;\n    }\n\n    @Nullable\n    private static CharSequence fetchDreamLabel(Context context,\n            @Nullable ServiceInfo serviceInfo) {\n        if (serviceInfo == null) return null;\n        final PackageManager pm = context.getPackageManager();\n        return serviceInfo.loadLabel(pm);\n    }\n\n    @Nullable\n    private static ServiceInfo fetchServiceInfo(Context context, ComponentName componentName) {\n        final PackageManager pm = context.getPackageManager();\n\n        try {\n            return pm.getServiceInfo(componentName,\n                    PackageManager.ComponentInfoFlags.of(PackageManager.GET_META_DATA));\n        } catch (PackageManager.NameNotFoundException e) {\n            if (DEBUG) Log.w(TAG, \"cannot find component \" + componentName.flattenToShortString());\n        }\n        return null;\n    }\n\n    @Override\n    protected void dump(final FileDescriptor fd, PrintWriter pw, final String[] args) {\n        DumpUtils.dumpAsync(mHandler, (pw1, prefix) -> dumpOnHandler(fd, pw1, args), pw, \"\", 1000);\n    }\n\n    /** @hide */\n    protected void dumpOnHandler(FileDescriptor fd, PrintWriter pw, String[] args) {\n        pw.print(mTag + \": \");\n        if (mFinished) {\n            pw.println(\"stopped\");\n        } else {\n            pw.println(\"running (dreamToken=\" + mDreamToken + \")\");\n        }\n        pw.println(\"  window: \" + mWindow);\n        pw.print(\"  flags:\");\n        if (isInteractive()) pw.print(\" interactive\");\n        if (isFullscreen()) pw.print(\" fullscreen\");\n        if (isScreenBright()) pw.print(\" bright\");\n        if (isWindowless()) pw.print(\" windowless\");\n        if (isDozing()) pw.print(\" dozing\");\n        else if (canDoze()) pw.print(\" candoze\");\n        pw.println();\n        if (canDoze()) {\n            pw.println(\"  doze screen state: \" + Display.stateToString(mDozeScreenState));\n            pw.println(\"  doze screen brightness: \" + mDozeScreenBrightness);\n        }\n    }\n\n    private static int clampAbsoluteBrightness(int value) {\n        return MathUtils.constrain(value, PowerManager.BRIGHTNESS_OFF, PowerManager.BRIGHTNESS_ON);\n    }\n\n    /**\n     * The DreamServiceWrapper is used as a gateway to the system_server, where DreamController\n     * uses it to control the DreamService. It is also used to receive callbacks from the\n     * DreamActivity.\n     */\n    final class DreamServiceWrapper extends IDreamService.Stub {\n        @Override\n        public void attach(final IBinder dreamToken, final boolean canDoze,\n                IRemoteCallback started) {\n            mHandler.post(() -> DreamService.this.attach(dreamToken, canDoze, started));\n        }\n\n        @Override\n        public void detach() {\n            mHandler.post(DreamService.this::detach);\n        }\n\n        @Override\n        public void wakeUp() {\n            mHandler.post(() -> DreamService.this.wakeUp(true /*fromSystem*/));\n        }\n    }\n\n    /** @hide */\n    final class DreamActivityCallback extends Binder {\n        private final IBinder mActivityDreamToken;\n\n        DreamActivityCallback(IBinder token) {\n            mActivityDreamToken = token;\n        }\n\n        void onActivityCreated(DreamActivity activity) {\n            if (mActivityDreamToken != mDreamToken || mFinished) {\n                Slog.d(TAG, \"DreamActivity was created after the dream was finished or \"\n                        + \"a new dream started, finishing DreamActivity\");\n                if (!activity.isFinishing()) {\n                    activity.finishAndRemoveTask();\n                }\n                return;\n            }\n            if (mActivity != null) {\n                Slog.w(TAG, \"A DreamActivity has already been started, \"\n                        + \"finishing latest DreamActivity\");\n                if (!activity.isFinishing()) {\n                    activity.finishAndRemoveTask();\n                }\n                return;\n            }\n\n            mActivity = activity;\n            onWindowCreated(activity.getWindow());\n        }\n    }\n\n    /**\n     * Represents metadata defined in {@link android.R.styleable#Dream &lt;dream&gt;}.\n     *\n     * @hide\n     */\n    @TestApi\n    public static final class DreamMetadata {\n        @Nullable\n        public final ComponentName settingsActivity;\n\n        @Nullable\n        public final Drawable previewImage;\n\n        @NonNull\n        public final boolean showComplications;\n\n        DreamMetadata(ComponentName settingsActivity, Drawable previewImage,\n                boolean showComplications) {\n            this.settingsActivity = settingsActivity;\n            this.previewImage = previewImage;\n            this.showComplications = showComplications;\n        }\n    }\n}\n```",
            "upstream_file_tokens": {
              "openai": 11711,
              "general": {
                "word_based": 5538,
                "char_based": 13777
              },
              "gemini": 13587
            },
            "downstream_file_content": "```java\n/**\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage android.service.dreams;\n\nimport android.annotation.IdRes;\nimport android.annotation.LayoutRes;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.SdkConstant;\nimport android.annotation.SdkConstant.SdkConstantType;\nimport android.annotation.TestApi;\nimport android.app.Activity;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.Service;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.Intent;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.IRemoteCallback;\nimport android.os.Looper;\nimport android.os.PowerManager;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.util.Log;\nimport android.util.MathUtils;\nimport android.util.Slog;\nimport android.view.ActionMode;\nimport android.view.Display;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SearchEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.WindowManager.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.DumpUtils.Dump;\n\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\n\n/**\n * Extend this class to implement a custom dream (available to the user as a \"Daydream\").\n *\n * <p>Dreams are interactive screensavers launched when a charging device is idle, or docked in a\n * desk dock. Dreams provide another modality for apps to express themselves, tailored for\n * an exhibition/lean-back experience.</p>\n *\n * <p>The {@code DreamService} lifecycle is as follows:</p>\n * <ol>\n *   <li>{@link #onAttachedToWindow}\n *     <p>Use this for initial setup, such as calling {@link #setContentView setContentView()}.</li>\n *   <li>{@link #onDreamingStarted}\n *     <p>Your dream has started, so you should begin animations or other behaviors here.</li>\n *   <li>{@link #onDreamingStopped}\n *     <p>Use this to stop the things you started in {@link #onDreamingStarted}.</li>\n *   <li>{@link #onDetachedFromWindow}\n *     <p>Use this to dismantle resources (for example, detach from handlers\n *        and listeners).</li>\n * </ol>\n *\n * <p>In addition, onCreate and onDestroy (from the Service interface) will also be called, but\n * initialization and teardown should be done by overriding the hooks above.</p>\n *\n * <p>To be available to the system, your {@code DreamService} should be declared in the\n * manifest as follows:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\" >\n *\n *     &lt;intent-filter>\n *         &lt;action android:name=\"android.service.dreams.DreamService\" />\n *         &lt;category android:name=\"android.intent.category.DEFAULT\" />\n *     &lt;/intent-filter>\n *\n *     &lt;!-- Point to additional information for this dream (optional) -->\n *     &lt;meta-data\n *         android:name=\"android.service.dream\"\n *         android:resource=\"@xml/my_dream\" />\n * &lt;/service>\n * </pre>\n *\n * <p>If specified with the {@code <meta-data>} element,\n * additional information for the dream is defined using the\n * {@link android.R.styleable#Dream &lt;dream&gt;} element in a separate XML file.\n * Currently, the only addtional\n * information you can provide is for a settings activity that allows the user to configure\n * the dream behavior. For example:</p>\n * <p class=\"code-caption\">res/xml/my_dream.xml</p>\n * <pre>\n * &lt;dream xmlns:android=\"http://schemas.android.com/apk/res/android\"\n *     android:settingsActivity=\"com.example.app/.MyDreamSettingsActivity\" />\n * </pre>\n * <p>This makes a Settings button available alongside your dream's listing in the\n * system settings, which when pressed opens the specified activity.</p>\n *\n *\n * <p>To specify your dream layout, call {@link #setContentView}, typically during the\n * {@link #onAttachedToWindow} callback. For example:</p>\n * <pre>\n * public class MyDream extends DreamService {\n *\n *     &#64;Override\n *     public void onAttachedToWindow() {\n *         super.onAttachedToWindow();\n *\n *         // Exit dream upon user touch\n *         setInteractive(false);\n *         // Hide system UI\n *         setFullscreen(true);\n *         // Set the dream layout\n *         setContentView(R.layout.dream);\n *     }\n * }\n * </pre>\n *\n * <p>When targeting api level 21 and above, you must declare the service in your manifest file\n * with the {@link android.Manifest.permission#BIND_DREAM_SERVICE} permission. For example:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\"\n *     android:permission=\"android.permission.BIND_DREAM_SERVICE\">\n *   &lt;intent-filter>\n *     &lt;action android:name=\u201dandroid.service.dreams.DreamService\u201d />\n *     &lt;category android:name=\u201dandroid.intent.category.DEFAULT\u201d />\n *   &lt;/intent-filter>\n * &lt;/service>\n * </pre>\n */\npublic class DreamService extends Service implements Window.Callback {\n    private final String TAG = DreamService.class.getSimpleName() + \"[\" + getClass().getSimpleName() + \"]\";\n\n    /**\n     * The name of the dream manager service.\n     * @hide\n     */\n    public static final String DREAM_SERVICE = \"dreams\";\n\n    /**\n     * The {@link Intent} that must be declared as handled by the service.\n     */\n    @SdkConstant(SdkConstantType.SERVICE_ACTION)\n    public static final String SERVICE_INTERFACE =\n            \"android.service.dreams.DreamService\";\n\n    /**\n     * Name under which a Dream publishes information about itself.\n     * This meta-data must reference an XML resource containing\n     * a <code>&lt;{@link android.R.styleable#Dream dream}&gt;</code>\n     * tag.\n     */\n    public static final String DREAM_META_DATA = \"android.service.dream\";\n\n    private final IDreamManager mDreamManager;\n    private final Handler mHandler = new Handler(Looper.getMainLooper());\n    private IBinder mDreamToken;\n    private Window mWindow;\n    private Activity mActivity;\n    private boolean mInteractive;\n    private boolean mFullscreen;\n    private boolean mScreenBright = true;\n    private boolean mStarted;\n    private boolean mWaking;\n    private boolean mFinished;\n    private boolean mCanDoze;\n    private boolean mDozing;\n    private boolean mWindowless;\n    private int mDozeScreenState = Display.STATE_UNKNOWN;\n    private int mDozeScreenBrightness = PowerManager.BRIGHTNESS_DEFAULT;\n\n    private boolean mDebug = false;\n\n    private DreamServiceWrapper mDreamServiceWrapper;\n    private Runnable mDispatchAfterOnAttachedToWindow;\n\n    public DreamService() {\n        mDreamManager = IDreamManager.Stub.asInterface(ServiceManager.getService(DREAM_SERVICE));\n    }\n\n    /**\n     * @hide\n     */\n    public void setDebug(boolean dbg) {\n        mDebug = dbg;\n    }\n\n    // begin Window.Callback methods\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyEvent\");\n            wakeUp();\n            return true;\n        } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {\n            if (mDebug) Slog.v(TAG, \"Waking up on back key\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyShortcutEvent(KeyEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyShortcutEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyShortcutEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // TODO: create more flexible version of mInteractive that allows clicks\n        // but finish()es on any other kind of activity\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on touchEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTouchEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTrackballEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on trackballEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTrackballEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchGenericMotionEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on genericMotionEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchGenericMotionEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public View onCreatePanelView(int featureId) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onCreatePanelMenu(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onPreparePanel(int featureId, View view, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuOpened(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowAttributesChanged(LayoutParams attrs) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onContentChanged() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowFocusChanged(boolean hasFocus) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onAttachedToWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDetachedFromWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onPanelClosed(int featureId, Menu menu) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested(SearchEvent event) {\n        return onSearchRequested();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested() {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(\n            android.view.ActionMode.Callback callback, int type) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeStarted(ActionMode mode) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeFinished(ActionMode mode) {\n    }\n    // end Window.Callback methods\n\n    // begin public api\n    /**\n     * Retrieves the current {@link android.view.WindowManager} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindowManager()}.\n     *\n     * @return The current window manager, or null if the dream is not started.\n     */\n    public WindowManager getWindowManager() {\n        return mWindow != null ? mWindow.getWindowManager() : null;\n    }\n\n    /**\n     * Retrieves the current {@link android.view.Window} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindow()}.\n     *\n     * @return The current window, or null if the dream is not started.\n     */\n    public Window getWindow() {\n        return mWindow;\n    }\n\n   /**\n     * Inflates a layout resource and set it to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(int)}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param layoutResID Resource ID to be inflated.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(android.view.View)} in an activity,\n     * including using {@link ViewGroup.LayoutParams#MATCH_PARENT} as the layout height and width of the view.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @see #setContentView(int)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(View view) {\n        getWindow().setContentView(view);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to\n     * {@link android.app.Activity#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)}\n     * in an activity.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(int)\n     */\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().setContentView(view, params);\n    }\n\n    /**\n     * Adds a view to the Dream's window, leaving other content views in place.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     */\n    public void addContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().addContentView(view, params);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that\n     * was processed in {@link #onCreate}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return The view if found or null otherwise.\n     * @see View#findViewById(int)\n     * @see DreamService#requireViewById(int)\n     */\n    @Nullable\n    public <T extends View> T findViewById(@IdRes int id) {\n        return getWindow().findViewById(id);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that was processed in\n     * {@link #onCreate}, or throws an IllegalArgumentException if the ID is invalid or there is no\n     * matching view in the hierarchy.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return a view with given ID\n     * @see View#requireViewById(int)\n     * @see DreamService#findViewById(int)\n     */\n    @NonNull\n    public final <T extends View> T requireViewById(@IdRes int id) {\n        T view = findViewById(id);\n        if (view == null) {\n            throw new IllegalArgumentException(\n                    \"ID does not reference a View inside this DreamService\");\n        }\n        return view;\n    }\n\n    /**\n     * Marks this dream as interactive to receive input events.\n     *\n     * <p>Non-interactive dreams (default) will dismiss on the first input event.</p>\n     *\n     * <p>Interactive dreams should call {@link #finish()} to dismiss themselves.</p>\n     *\n     * @param interactive True if this dream will handle input events.\n     */\n    public void setInteractive(boolean interactive) {\n        mInteractive = interactive;\n    }\n\n    /**\n     * Returns whether or not this dream is interactive.  Defaults to false.\n     *\n     * @see #setInteractive(boolean)\n     */\n    public boolean isInteractive() {\n        return mInteractive;\n    }\n\n    /**\n     * Controls {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN}\n     * on the dream's window.\n     *\n     * @param fullscreen If true, the fullscreen flag will be set; else it\n     * will be cleared.\n     */\n    public void setFullscreen(boolean fullscreen) {\n        if (mFullscreen != fullscreen) {\n            mFullscreen = fullscreen;\n            int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;\n            applyWindowFlags(mFullscreen ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream is in fullscreen mode. Defaults to false.\n     *\n     * @see #setFullscreen(boolean)\n     */\n    public boolean isFullscreen() {\n        return mFullscreen;\n    }\n\n    /**\n     * Marks this dream as keeping the screen bright while dreaming.\n     *\n     * @param screenBright True to keep the screen bright while dreaming.\n     */\n    public void setScreenBright(boolean screenBright) {\n        if (mScreenBright != screenBright) {\n            mScreenBright = screenBright;\n            int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;\n            applyWindowFlags(mScreenBright ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream keeps the screen bright while dreaming.\n     * Defaults to false, allowing the screen to dim if necessary.\n     *\n     * @see #setScreenBright(boolean)\n     */\n    public boolean isScreenBright() {\n        return getWindowFlagValue(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, mScreenBright);\n    }\n\n    /**\n     * Marks this dream as windowless.  Only available to doze dreams.\n     *\n     * @hide\n     *\n     */\n    public void setWindowless(boolean windowless) {\n        mWindowless = windowless;\n    }\n\n    /**\n     * Returns whether or not this dream is windowless.  Only available to doze dreams.\n     *\n     * @hide\n     */\n    public boolean isWindowless() {\n        return mWindowless;\n    }\n\n    /**\n     * Returns true if this dream is allowed to doze.\n     * <p>\n     * The value returned by this method is only meaningful when the dream has started.\n     * </p>\n     *\n     * @return True if this dream can doze.\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean canDoze() {\n        return mCanDoze;\n    }\n\n    /**\n     * Starts dozing, entering a deep dreamy sleep.\n     * <p>\n     * Dozing enables the system to conserve power while the user is not actively interacting\n     * with the device.  While dozing, the display will remain on in a low-power state\n     * and will continue to show its previous contents but the application processor and\n     * other system components will be allowed to suspend when possible.\n     * </p><p>\n     * While the application processor is suspended, the dream may stop executing code\n     * for long periods of time.  Prior to being suspended, the dream may schedule periodic\n     * wake-ups to render new content by scheduling an alarm with the {@link AlarmManager}.\n     * The dream may also keep the CPU awake by acquiring a\n     * {@link android.os.PowerManager#PARTIAL_WAKE_LOCK partial wake lock} when necessary.\n     * Note that since the purpose of doze mode is to conserve power (especially when\n     * running on battery), the dream should not wake the CPU very often or keep it\n     * awake for very long.\n     * </p><p>\n     * It is a good idea to call this method some time after the dream's entry animation\n     * has completed and the dream is ready to doze.  It is important to completely\n     * finish all of the work needed before dozing since the application processor may\n     * be suspended at any moment once this method is called unless other wake locks\n     * are being held.\n     * </p><p>\n     * Call {@link #stopDozing} or {@link #finish} to stop dozing.\n     * </p>\n     *\n     * @see #stopDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void startDozing() {\n        if (mCanDoze && !mDozing) {\n            mDozing = true;\n            updateDoze();\n        }\n    }\n\n    private void updateDoze() {\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Updating doze without a dream token.\");\n            return;\n        }\n\n        if (mDozing) {\n            try {\n                mDreamManager.startDozing(mDreamToken, mDozeScreenState, mDozeScreenBrightness);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Stops dozing, returns to active dreaming.\n     * <p>\n     * This method reverses the effect of {@link #startDozing}.  From this moment onward,\n     * the application processor will be kept awake as long as the dream is running\n     * or until the dream starts dozing again.\n     * </p>\n     *\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public void stopDozing() {\n        if (mDozing) {\n            mDozing = false;\n            try {\n                mDreamManager.stopDozing(mDreamToken);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Returns true if the dream will allow the system to enter a low-power state while\n     * it is running without actually turning off the screen.  Defaults to false,\n     * keeping the application processor awake while the dream is running.\n     *\n     * @return True if the dream is dozing.\n     *\n     * @see #setDozing(boolean)\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean isDozing() {\n        return mDozing;\n    }\n\n    /**\n     * Gets the screen state to use while dozing.\n     *\n     * @return The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @see #setDozeScreenState\n     * @hide For use by system UI components only.\n     */\n    public int getDozeScreenState() {\n        return mDozeScreenState;\n    }\n\n    /**\n     * Sets the screen state to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link Display#STATE_UNKNOWN} which lets the system decide.\n     * The dream may set a different state before starting to doze and may\n     * perform transitions between states while dozing to conserve power and\n     * achieve various effects.\n     * </p><p>\n     * Some devices will have dedicated hardware (\"Sidekick\") to animate\n     * the display content while the CPU sleeps. If the dream and the hardware support\n     * this, {@link Display#STATE_ON_SUSPEND} or {@link Display#STATE_DOZE_SUSPEND}\n     * will switch control to the Sidekick.\n     * </p><p>\n     * If not using Sidekick, it is recommended that the state be set to\n     * {@link Display#STATE_DOZE_SUSPEND} once the dream has completely\n     * finished drawing and before it releases its wakelock\n     * to allow the display hardware to be fully suspended.  While suspended,\n     * the display will preserve its on-screen contents.\n     * </p><p>\n     * If the doze suspend state is used, the dream must make sure to set the mode back\n     * to {@link Display#STATE_DOZE} or {@link Display#STATE_ON} before drawing again\n     * since the display updates may be ignored and not seen by the user otherwise.\n     * </p><p>\n     * The set of available display power states and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param state The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenState(int state) {\n        if (mDozeScreenState != state) {\n            mDozeScreenState = state;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Gets the screen brightness to use while dozing.\n     *\n     * @return The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @see #setDozeScreenBrightness\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public int getDozeScreenBrightness() {\n        return mDozeScreenBrightness;\n    }\n\n    /**\n     * Sets the screen brightness to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link PowerManager#BRIGHTNESS_DEFAULT} which lets the system decide.\n     * The dream may set a different brightness before starting to doze and may adjust\n     * the brightness while dozing to conserve power and achieve various effects.\n     * </p><p>\n     * Note that dream may specify any brightness in the full 0-255 range, including\n     * values that are less than the minimum value for manual screen brightness\n     * adjustments by the user.  In particular, the value may be set to 0 which may\n     * turn off the backlight entirely while still leaving the screen on although\n     * this behavior is device dependent and not guaranteed.\n     * </p><p>\n     * The available range of display brightness values and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param brightness The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenBrightness(int brightness) {\n        if (brightness != PowerManager.BRIGHTNESS_DEFAULT) {\n            brightness = clampAbsoluteBrightness(brightness);\n        }\n        if (mDozeScreenBrightness != brightness) {\n            mDozeScreenBrightness = brightness;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Called when this Dream is constructed.\n     */\n    @Override\n    public void onCreate() {\n        if (mDebug) Slog.v(TAG, \"onCreate()\");\n        super.onCreate();\n    }\n\n    /**\n     * Called when the dream's window has been created and is visible and animation may now begin.\n     */\n    public void onDreamingStarted() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStarted()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when this Dream is stopped, either by external request or by calling finish(),\n     * before the window has been removed.\n     */\n    public void onDreamingStopped() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStopped()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when the dream is being asked to stop itself and wake.\n     * <p>\n     * The default implementation simply calls {@link #finish} which ends the dream\n     * immediately.  Subclasses may override this function to perform a smooth exit\n     * transition then call {@link #finish} afterwards.\n     * </p><p>\n     * Note that the dream will only be given a short period of time (currently about\n     * five seconds) to wake up.  If the dream does not finish itself in a timely manner\n     * then the system will forcibly finish it once the time allowance is up.\n     * </p>\n     */\n    public void onWakeUp() {\n        finish();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public final IBinder onBind(Intent intent) {\n        if (mDebug) Slog.v(TAG, \"onBind() intent = \" + intent);\n        mDreamServiceWrapper = new DreamServiceWrapper();\n        return mDreamServiceWrapper;\n    }\n\n    /**\n     * Stops the dream and detaches from the window.\n     * <p>\n     * When the dream ends, the system will be allowed to go to sleep fully unless there\n     * is a reason for it to be awake such as recent user activity or wake locks being held.\n     * </p>\n     */\n    public final void finish() {\n        if (mDebug) Slog.v(TAG, \"finish(): mFinished=\" + mFinished);\n\n        Activity activity = mActivity;\n        if (activity != null) {\n            if (!activity.isFinishing()) {\n                // In case the activity is not finished yet, do it now.\n                activity.finishAndRemoveTask();\n            }\n            return;\n        }\n\n        if (mFinished) {\n            return;\n        }\n        mFinished = true;\n\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Finish was called before the dream was attached.\");\n            stopSelf();\n            return;\n        }\n\n        try {\n            // finishSelf will unbind the dream controller from the dream service. This will\n            // trigger DreamService.this.onDestroy and DreamService.this will die.\n            mDreamManager.finishSelf(mDreamToken, true /*immediate*/);\n        } catch (RemoteException ex) {\n            // system server died\n        }\n    }\n\n    /**\n     * Wakes the dream up gently.\n     * <p>\n     * Calls {@link #onWakeUp} to give the dream a chance to perform an exit transition.\n     * When the transition is over, the dream should call {@link #finish}.\n     * </p>\n     */\n    public final void wakeUp() {\n        wakeUp(false);\n    }\n\n    private void wakeUp(boolean fromSystem) {\n        if (mDebug) Slog.v(TAG, \"wakeUp(): fromSystem=\" + fromSystem\n                + \", mWaking=\" + mWaking + \", mFinished=\" + mFinished);\n\n        if (!mWaking && !mFinished) {\n            mWaking = true;\n\n            // As a minor optimization, invoke the callback first in case it simply\n            // calls finish() immediately so there wouldn't be much point in telling\n            // the system that we are finishing the dream gently.\n            onWakeUp();\n\n            // Now tell the system we are waking gently, unless we already told\n            // it we were finishing immediately.\n            if (!fromSystem && !mFinished) {\n                if (mActivity == null) {\n                    Slog.w(TAG, \"WakeUp was called before the dream was attached.\");\n                } else {\n                    try {\n                        mDreamManager.finishSelf(mDreamToken, false /*immediate*/);\n                    } catch (RemoteException ex) {\n                        // system server died\n                    }\n                }\n            }\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDestroy() {\n        if (mDebug) Slog.v(TAG, \"onDestroy()\");\n        // hook for subclasses\n\n        // Just in case destroy came in before detach, let's take care of that now\n        detach();\n\n        super.onDestroy();\n    }\n\n    // end public api\n\n    /**\n     * Called by DreamController.stopDream() when the Dream is about to be unbound and destroyed.\n     *\n     * Must run on mHandler.\n     */\n    private final void detach() {\n        if (mStarted) {\n            if (mDebug) Slog.v(TAG, \"detach(): Calling onDreamingStopped()\");\n            mStarted = false;\n            onDreamingStopped();\n        }\n\n        if (mActivity != null && !mActivity.isFinishing()) {\n            mActivity.finishAndRemoveTask();\n        } else {\n            finish();\n        }\n\n        mDreamToken = null;\n        mCanDoze = false;\n    }\n\n    /**\n     * Called when the Dream is ready to be shown.\n     *\n     * Must run on mHandler.\n     *\n     * @param dreamToken Token for this dream service.\n     * @param started A callback that will be invoked once onDreamingStarted has completed.\n     */\n    private void attach(IBinder dreamToken, boolean canDoze, IRemoteCallback started) {\n        if (mDreamToken != null) {\n            Slog.e(TAG, \"attach() called when dream with token=\" + mDreamToken\n                    + \" already attached\");\n            return;\n        }\n        if (mFinished || mWaking) {\n            Slog.w(TAG, \"attach() called after dream already finished\");\n            try {\n                mDreamManager.finishSelf(dreamToken, true /*immediate*/);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n            return;\n        }\n\n        mDreamToken = dreamToken;\n        mCanDoze = canDoze;\n        if (mWindowless && !mCanDoze) {\n            throw new IllegalStateException(\"Only doze dreams can be windowless\");\n        }\n\n        mDispatchAfterOnAttachedToWindow = () -> {\n            if (mWindow != null || mWindowless) {\n                mStarted = true;\n                try {\n                    onDreamingStarted();\n                } finally {\n                    try {\n                        started.sendResult(null);\n                    } catch (RemoteException e) {\n                        throw e.rethrowFromSystemServer();\n                    }\n                }\n            }\n        };\n\n        // We need to defer calling onDreamingStarted until after the activity is created.\n        // If the dream is windowless, we can call it immediately. Otherwise, we wait\n        // for the DreamActivity to report onActivityCreated via\n        // DreamServiceWrapper.onActivityCreated.\n        if (!mWindowless) {\n            Intent i = new Intent(this, DreamActivity.class);\n            i.setPackage(getApplicationContext().getPackageName());\n            i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            i.putExtra(DreamActivity.EXTRA_CALLBACK, mDreamServiceWrapper);\n\n            try {\n                if (!ActivityTaskManager.getService().startDreamActivity(i)) {\n                    detach();\n                    return;\n                }\n            } catch (RemoteException e) {\n                Log.w(TAG, \"Could not connect to activity task manager to start dream activity\");\n                e.rethrowFromSystemServer();\n            }\n        } else {\n            mDispatchAfterOnAttachedToWindow.run();\n        }\n    }\n\n    private void onWindowCreated(Window w) {\n        mWindow = w;\n        mWindow.setCallback(this);\n        mWindow.requestFeature(Window.FEATURE_NO_TITLE);\n\n        WindowManager.LayoutParams lp = mWindow.getAttributes();\n        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN\n                    | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR\n                    | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED\n                    | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD\n                    | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON\n                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED\n                    | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0)\n                    | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0)\n                    );\n        mWindow.setAttributes(lp);\n        // Workaround: Currently low-profile and in-window system bar backgrounds don't go\n        // along well. Dreams usually don't need such bars anyways, so disable them by default.\n        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n\n        mWindow.getDecorView().addOnAttachStateChangeListener(\n                new View.OnAttachStateChangeListener() {\n                    @Override\n                    public void onViewAttachedToWindow(View v) {\n                        mDispatchAfterOnAttachedToWindow.run();\n                    }\n\n                    @Override\n                    public void onViewDetachedFromWindow(View v) {\n                        if (mActivity == null || !mActivity.isChangingConfigurations()) {\n                            // Only stop the dream if the view is not detached by relaunching\n                            // activity for configuration changes.\n                            mActivity = null;\n                            finish();\n                        }\n                    }\n                });\n    }\n\n    private boolean getWindowFlagValue(int flag, boolean defaultValue) {\n        return mWindow == null ? defaultValue : (mWindow.getAttributes().flags & flag) != 0;\n    }\n\n    private void applyWindowFlags(int flags, int mask) {\n        if (mWindow != null) {\n            WindowManager.LayoutParams lp = mWindow.getAttributes();\n            lp.flags = applyFlags(lp.flags, flags, mask);\n            mWindow.setAttributes(lp);\n            mWindow.getWindowManager().updateViewLayout(mWindow.getDecorView(), lp);\n        }\n    }\n\n    private int applyFlags(int oldFlags, int flags, int mask) {\n        return (oldFlags&~mask) | (flags&mask);\n    }\n\n    @Override\n    protected void dump(final FileDescriptor fd, PrintWriter pw, final String[] args) {\n        DumpUtils.dumpAsync(mHandler, new Dump() {\n            @Override\n            public void dump(PrintWriter pw, String prefix) {\n                dumpOnHandler(fd, pw, args);\n            }\n        }, pw, \"\", 1000);\n    }\n\n    /** @hide */\n    protected void dumpOnHandler(FileDescriptor fd, PrintWriter pw, String[] args) {\n        pw.print(TAG + \": \");\n        if (mFinished) {\n            pw.println(\"stopped\");\n        } else {\n            pw.println(\"running (dreamToken=\" + mDreamToken + \")\");\n        }\n        pw.println(\"  window: \" + mWindow);\n        pw.print(\"  flags:\");\n        if (isInteractive()) pw.print(\" interactive\");\n        if (isFullscreen()) pw.print(\" fullscreen\");\n        if (isScreenBright()) pw.print(\" bright\");\n        if (isWindowless()) pw.print(\" windowless\");\n        if (isDozing()) pw.print(\" dozing\");\n        else if (canDoze()) pw.print(\" candoze\");\n        pw.println();\n        if (canDoze()) {\n            pw.println(\"  doze screen state: \" + Display.stateToString(mDozeScreenState));\n            pw.println(\"  doze screen brightness: \" + mDozeScreenBrightness);\n        }\n    }\n\n    private static int clampAbsoluteBrightness(int value) {\n        return MathUtils.constrain(value, PowerManager.BRIGHTNESS_OFF, PowerManager.BRIGHTNESS_ON);\n    }\n\n    /**\n     * The DreamServiceWrapper is used as a gateway to the system_server, where DreamController\n     * uses it to control the DreamService. It is also used to receive callbacks from the\n     * DreamActivity.\n     */\n    final class DreamServiceWrapper extends IDreamService.Stub {\n        @Override\n        public void attach(final IBinder dreamToken, final boolean canDoze,\n                IRemoteCallback started) {\n            mHandler.post(() -> DreamService.this.attach(dreamToken, canDoze, started));\n        }\n\n        @Override\n        public void detach() {\n            mHandler.post(DreamService.this::detach);\n        }\n\n        @Override\n        public void wakeUp() {\n            mHandler.post(() -> DreamService.this.wakeUp(true /*fromSystem*/));\n        }\n\n        /** @hide */\n        void onActivityCreated(DreamActivity a) {\n            mActivity = a;\n            onWindowCreated(a.getWindow());\n        }\n    }\n}\n```",
            "downstream_file_tokens": {
              "openai": 9213,
              "general": {
                "word_based": 4398,
                "char_based": 10396
              },
              "gemini": 10611
            },
            "downstream_file_content_ground_truth": "/**\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage android.service.dreams;\n\nimport android.annotation.IdRes;\nimport android.annotation.LayoutRes;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.SdkConstant;\nimport android.annotation.SdkConstant.SdkConstantType;\nimport android.app.Activity;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.Service;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.Intent;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.IRemoteCallback;\nimport android.os.Looper;\nimport android.os.PowerManager;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.util.Log;\nimport android.util.MathUtils;\nimport android.util.Slog;\nimport android.view.ActionMode;\nimport android.view.Display;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SearchEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.WindowManager.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.DumpUtils.Dump;\n\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\n\n/**\n * Extend this class to implement a custom dream (available to the user as a \"Daydream\").\n *\n * <p>Dreams are interactive screensavers launched when a charging device is idle, or docked in a\n * desk dock. Dreams provide another modality for apps to express themselves, tailored for\n * an exhibition/lean-back experience.</p>\n *\n * <p>The {@code DreamService} lifecycle is as follows:</p>\n * <ol>\n *   <li>{@link #onAttachedToWindow}\n *     <p>Use this for initial setup, such as calling {@link #setContentView setContentView()}.</li>\n *   <li>{@link #onDreamingStarted}\n *     <p>Your dream has started, so you should begin animations or other behaviors here.</li>\n *   <li>{@link #onDreamingStopped}\n *     <p>Use this to stop the things you started in {@link #onDreamingStarted}.</li>\n *   <li>{@link #onDetachedFromWindow}\n *     <p>Use this to dismantle resources (for example, detach from handlers\n *        and listeners).</li>\n * </ol>\n *\n * <p>In addition, onCreate and onDestroy (from the Service interface) will also be called, but\n * initialization and teardown should be done by overriding the hooks above.</p>\n *\n * <p>To be available to the system, your {@code DreamService} should be declared in the\n * manifest as follows:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\" >\n *\n *     &lt;intent-filter>\n *         &lt;action android:name=\"android.service.dreams.DreamService\" />\n *         &lt;category android:name=\"android.intent.category.DEFAULT\" />\n *     &lt;/intent-filter>\n *\n *     &lt;!-- Point to additional information for this dream (optional) -->\n *     &lt;meta-data\n *         android:name=\"android.service.dream\"\n *         android:resource=\"@xml/my_dream\" />\n * &lt;/service>\n * </pre>\n *\n * <p>If specified with the {@code <meta-data>} element,\n * additional information for the dream is defined using the\n * {@link android.R.styleable#Dream &lt;dream&gt;} element in a separate XML file.\n * Currently, the only addtional\n * information you can provide is for a settings activity that allows the user to configure\n * the dream behavior. For example:</p>\n * <p class=\"code-caption\">res/xml/my_dream.xml</p>\n * <pre>\n * &lt;dream xmlns:android=\"http://schemas.android.com/apk/res/android\"\n *     android:settingsActivity=\"com.example.app/.MyDreamSettingsActivity\" />\n * </pre>\n * <p>This makes a Settings button available alongside your dream's listing in the\n * system settings, which when pressed opens the specified activity.</p>\n *\n *\n * <p>To specify your dream layout, call {@link #setContentView}, typically during the\n * {@link #onAttachedToWindow} callback. For example:</p>\n * <pre>\n * public class MyDream extends DreamService {\n *\n *     &#64;Override\n *     public void onAttachedToWindow() {\n *         super.onAttachedToWindow();\n *\n *         // Exit dream upon user touch\n *         setInteractive(false);\n *         // Hide system UI\n *         setFullscreen(true);\n *         // Set the dream layout\n *         setContentView(R.layout.dream);\n *     }\n * }\n * </pre>\n *\n * <p>When targeting api level 21 and above, you must declare the service in your manifest file\n * with the {@link android.Manifest.permission#BIND_DREAM_SERVICE} permission. For example:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\"\n *     android:permission=\"android.permission.BIND_DREAM_SERVICE\">\n *   &lt;intent-filter>\n *     &lt;action android:name=\u201dandroid.service.dreams.DreamService\u201d />\n *     &lt;category android:name=\u201dandroid.intent.category.DEFAULT\u201d />\n *   &lt;/intent-filter>\n * &lt;/service>\n * </pre>\n */\npublic class DreamService extends Service implements Window.Callback {\n    private final String TAG = DreamService.class.getSimpleName() + \"[\" + getClass().getSimpleName() + \"]\";\n\n    /**\n     * The name of the dream manager service.\n     * @hide\n     */\n    public static final String DREAM_SERVICE = \"dreams\";\n\n    /**\n     * The {@link Intent} that must be declared as handled by the service.\n     */\n    @SdkConstant(SdkConstantType.SERVICE_ACTION)\n    public static final String SERVICE_INTERFACE =\n            \"android.service.dreams.DreamService\";\n\n    /**\n     * Name under which a Dream publishes information about itself.\n     * This meta-data must reference an XML resource containing\n     * a <code>&lt;{@link android.R.styleable#Dream dream}&gt;</code>\n     * tag.\n     */\n    public static final String DREAM_META_DATA = \"android.service.dream\";\n\n    private final IDreamManager mDreamManager;\n    private final Handler mHandler = new Handler(Looper.getMainLooper());\n    private IBinder mDreamToken;\n    private Window mWindow;\n    private Activity mActivity;\n    private boolean mInteractive;\n    private boolean mFullscreen;\n    private boolean mScreenBright = true;\n    private boolean mStarted;\n    private boolean mWaking;\n    private boolean mFinished;\n    private boolean mCanDoze;\n    private boolean mDozing;\n    private boolean mWindowless;\n    private int mDozeScreenState = Display.STATE_UNKNOWN;\n    private int mDozeScreenBrightness = PowerManager.BRIGHTNESS_DEFAULT;\n\n    private boolean mDebug = false;\n\n    private DreamServiceWrapper mDreamServiceWrapper;\n    private Runnable mDispatchAfterOnAttachedToWindow;\n\n    public DreamService() {\n        mDreamManager = IDreamManager.Stub.asInterface(ServiceManager.getService(DREAM_SERVICE));\n    }\n\n    /**\n     * @hide\n     */\n    public void setDebug(boolean dbg) {\n        mDebug = dbg;\n    }\n\n    // begin Window.Callback methods\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyEvent\");\n            wakeUp();\n            return true;\n        } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {\n            if (mDebug) Slog.v(TAG, \"Waking up on back key\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyShortcutEvent(KeyEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyShortcutEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyShortcutEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // TODO: create more flexible version of mInteractive that allows clicks\n        // but finish()es on any other kind of activity\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on touchEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTouchEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTrackballEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on trackballEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTrackballEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchGenericMotionEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on genericMotionEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchGenericMotionEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public View onCreatePanelView(int featureId) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onCreatePanelMenu(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onPreparePanel(int featureId, View view, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuOpened(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowAttributesChanged(LayoutParams attrs) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onContentChanged() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowFocusChanged(boolean hasFocus) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onAttachedToWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDetachedFromWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onPanelClosed(int featureId, Menu menu) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested(SearchEvent event) {\n        return onSearchRequested();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested() {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(\n            android.view.ActionMode.Callback callback, int type) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeStarted(ActionMode mode) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeFinished(ActionMode mode) {\n    }\n    // end Window.Callback methods\n\n    // begin public api\n    /**\n     * Retrieves the current {@link android.view.WindowManager} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindowManager()}.\n     *\n     * @return The current window manager, or null if the dream is not started.\n     */\n    public WindowManager getWindowManager() {\n        return mWindow != null ? mWindow.getWindowManager() : null;\n    }\n\n    /**\n     * Retrieves the current {@link android.view.Window} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindow()}.\n     *\n     * @return The current window, or null if the dream is not started.\n     */\n    public Window getWindow() {\n        return mWindow;\n    }\n\n   /**\n     * Inflates a layout resource and set it to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(int)}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param layoutResID Resource ID to be inflated.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(android.view.View)} in an activity,\n     * including using {@link ViewGroup.LayoutParams#MATCH_PARENT} as the layout height and width of the view.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @see #setContentView(int)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(View view) {\n        getWindow().setContentView(view);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to\n     * {@link android.app.Activity#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)}\n     * in an activity.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(int)\n     */\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().setContentView(view, params);\n    }\n\n    /**\n     * Adds a view to the Dream's window, leaving other content views in place.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     */\n    public void addContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().addContentView(view, params);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that\n     * was processed in {@link #onCreate}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return The view if found or null otherwise.\n     * @see View#findViewById(int)\n     * @see DreamService#requireViewById(int)\n     */\n    @Nullable\n    public <T extends View> T findViewById(@IdRes int id) {\n        return getWindow().findViewById(id);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that was processed in\n     * {@link #onCreate}, or throws an IllegalArgumentException if the ID is invalid or there is no\n     * matching view in the hierarchy.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return a view with given ID\n     * @see View#requireViewById(int)\n     * @see DreamService#findViewById(int)\n     */\n    @NonNull\n    public final <T extends View> T requireViewById(@IdRes int id) {\n        T view = findViewById(id);\n        if (view == null) {\n            throw new IllegalArgumentException(\n                    \"ID does not reference a View inside this DreamService\");\n        }\n        return view;\n    }\n\n    /**\n     * Marks this dream as interactive to receive input events.\n     *\n     * <p>Non-interactive dreams (default) will dismiss on the first input event.</p>\n     *\n     * <p>Interactive dreams should call {@link #finish()} to dismiss themselves.</p>\n     *\n     * @param interactive True if this dream will handle input events.\n     */\n    public void setInteractive(boolean interactive) {\n        mInteractive = interactive;\n    }\n\n    /**\n     * Returns whether or not this dream is interactive.  Defaults to false.\n     *\n     * @see #setInteractive(boolean)\n     */\n    public boolean isInteractive() {\n        return mInteractive;\n    }\n\n    /**\n     * Controls {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN}\n     * on the dream's window.\n     *\n     * @param fullscreen If true, the fullscreen flag will be set; else it\n     * will be cleared.\n     */\n    public void setFullscreen(boolean fullscreen) {\n        if (mFullscreen != fullscreen) {\n            mFullscreen = fullscreen;\n            int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;\n            applyWindowFlags(mFullscreen ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream is in fullscreen mode. Defaults to false.\n     *\n     * @see #setFullscreen(boolean)\n     */\n    public boolean isFullscreen() {\n        return mFullscreen;\n    }\n\n    /**\n     * Marks this dream as keeping the screen bright while dreaming.\n     *\n     * @param screenBright True to keep the screen bright while dreaming.\n     */\n    public void setScreenBright(boolean screenBright) {\n        if (mScreenBright != screenBright) {\n            mScreenBright = screenBright;\n            int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;\n            applyWindowFlags(mScreenBright ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream keeps the screen bright while dreaming.\n     * Defaults to false, allowing the screen to dim if necessary.\n     *\n     * @see #setScreenBright(boolean)\n     */\n    public boolean isScreenBright() {\n        return getWindowFlagValue(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, mScreenBright);\n    }\n\n    /**\n     * Marks this dream as windowless.  Only available to doze dreams.\n     *\n     * @hide\n     *\n     */\n    public void setWindowless(boolean windowless) {\n        mWindowless = windowless;\n    }\n\n    /**\n     * Returns whether or not this dream is windowless.  Only available to doze dreams.\n     *\n     * @hide\n     */\n    public boolean isWindowless() {\n        return mWindowless;\n    }\n\n    /**\n     * Returns true if this dream is allowed to doze.\n     * <p>\n     * The value returned by this method is only meaningful when the dream has started.\n     * </p>\n     *\n     * @return True if this dream can doze.\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean canDoze() {\n        return mCanDoze;\n    }\n\n    /**\n     * Starts dozing, entering a deep dreamy sleep.\n     * <p>\n     * Dozing enables the system to conserve power while the user is not actively interacting\n     * with the device.  While dozing, the display will remain on in a low-power state\n     * and will continue to show its previous contents but the application processor and\n     * other system components will be allowed to suspend when possible.\n     * </p><p>\n     * While the application processor is suspended, the dream may stop executing code\n     * for long periods of time.  Prior to being suspended, the dream may schedule periodic\n     * wake-ups to render new content by scheduling an alarm with the {@link AlarmManager}.\n     * The dream may also keep the CPU awake by acquiring a\n     * {@link android.os.PowerManager#PARTIAL_WAKE_LOCK partial wake lock} when necessary.\n     * Note that since the purpose of doze mode is to conserve power (especially when\n     * running on battery), the dream should not wake the CPU very often or keep it\n     * awake for very long.\n     * </p><p>\n     * It is a good idea to call this method some time after the dream's entry animation\n     * has completed and the dream is ready to doze.  It is important to completely\n     * finish all of the work needed before dozing since the application processor may\n     * be suspended at any moment once this method is called unless other wake locks\n     * are being held.\n     * </p><p>\n     * Call {@link #stopDozing} or {@link #finish} to stop dozing.\n     * </p>\n     *\n     * @see #stopDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void startDozing() {\n        if (mCanDoze && !mDozing) {\n            mDozing = true;\n            updateDoze();\n        }\n    }\n\n    private void updateDoze() {\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Updating doze without a dream token.\");\n            return;\n        }\n\n        if (mDozing) {\n            try {\n                mDreamManager.startDozing(mDreamToken, mDozeScreenState, mDozeScreenBrightness);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Stops dozing, returns to active dreaming.\n     * <p>\n     * This method reverses the effect of {@link #startDozing}.  From this moment onward,\n     * the application processor will be kept awake as long as the dream is running\n     * or until the dream starts dozing again.\n     * </p>\n     *\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public void stopDozing() {\n        if (mDozing) {\n            mDozing = false;\n            try {\n                mDreamManager.stopDozing(mDreamToken);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Returns true if the dream will allow the system to enter a low-power state while\n     * it is running without actually turning off the screen.  Defaults to false,\n     * keeping the application processor awake while the dream is running.\n     *\n     * @return True if the dream is dozing.\n     *\n     * @see #setDozing(boolean)\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean isDozing() {\n        return mDozing;\n    }\n\n    /**\n     * Gets the screen state to use while dozing.\n     *\n     * @return The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @see #setDozeScreenState\n     * @hide For use by system UI components only.\n     */\n    public int getDozeScreenState() {\n        return mDozeScreenState;\n    }\n\n    /**\n     * Sets the screen state to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link Display#STATE_UNKNOWN} which lets the system decide.\n     * The dream may set a different state before starting to doze and may\n     * perform transitions between states while dozing to conserve power and\n     * achieve various effects.\n     * </p><p>\n     * Some devices will have dedicated hardware (\"Sidekick\") to animate\n     * the display content while the CPU sleeps. If the dream and the hardware support\n     * this, {@link Display#STATE_ON_SUSPEND} or {@link Display#STATE_DOZE_SUSPEND}\n     * will switch control to the Sidekick.\n     * </p><p>\n     * If not using Sidekick, it is recommended that the state be set to\n     * {@link Display#STATE_DOZE_SUSPEND} once the dream has completely\n     * finished drawing and before it releases its wakelock\n     * to allow the display hardware to be fully suspended.  While suspended,\n     * the display will preserve its on-screen contents.\n     * </p><p>\n     * If the doze suspend state is used, the dream must make sure to set the mode back\n     * to {@link Display#STATE_DOZE} or {@link Display#STATE_ON} before drawing again\n     * since the display updates may be ignored and not seen by the user otherwise.\n     * </p><p>\n     * The set of available display power states and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param state The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenState(int state) {\n        if (mDozeScreenState != state) {\n            mDozeScreenState = state;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Gets the screen brightness to use while dozing.\n     *\n     * @return The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @see #setDozeScreenBrightness\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public int getDozeScreenBrightness() {\n        return mDozeScreenBrightness;\n    }\n\n    /**\n     * Sets the screen brightness to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link PowerManager#BRIGHTNESS_DEFAULT} which lets the system decide.\n     * The dream may set a different brightness before starting to doze and may adjust\n     * the brightness while dozing to conserve power and achieve various effects.\n     * </p><p>\n     * Note that dream may specify any brightness in the full 0-255 range, including\n     * values that are less than the minimum value for manual screen brightness\n     * adjustments by the user.  In particular, the value may be set to 0 which may\n     * turn off the backlight entirely while still leaving the screen on although\n     * this behavior is device dependent and not guaranteed.\n     * </p><p>\n     * The available range of display brightness values and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param brightness The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenBrightness(int brightness) {\n        if (brightness != PowerManager.BRIGHTNESS_DEFAULT) {\n            brightness = clampAbsoluteBrightness(brightness);\n        }\n        if (mDozeScreenBrightness != brightness) {\n            mDozeScreenBrightness = brightness;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Called when this Dream is constructed.\n     */\n    @Override\n    public void onCreate() {\n        if (mDebug) Slog.v(TAG, \"onCreate()\");\n        super.onCreate();\n    }\n\n    /**\n     * Called when the dream's window has been created and is visible and animation may now begin.\n     */\n    public void onDreamingStarted() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStarted()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when this Dream is stopped, either by external request or by calling finish(),\n     * before the window has been removed.\n     */\n    public void onDreamingStopped() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStopped()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when the dream is being asked to stop itself and wake.\n     * <p>\n     * The default implementation simply calls {@link #finish} which ends the dream\n     * immediately.  Subclasses may override this function to perform a smooth exit\n     * transition then call {@link #finish} afterwards.\n     * </p><p>\n     * Note that the dream will only be given a short period of time (currently about\n     * five seconds) to wake up.  If the dream does not finish itself in a timely manner\n     * then the system will forcibly finish it once the time allowance is up.\n     * </p>\n     */\n    public void onWakeUp() {\n        finish();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public final IBinder onBind(Intent intent) {\n        if (mDebug) Slog.v(TAG, \"onBind() intent = \" + intent);\n        mDreamServiceWrapper = new DreamServiceWrapper();\n        return mDreamServiceWrapper;\n    }\n\n    /**\n     * Stops the dream and detaches from the window.\n     * <p>\n     * When the dream ends, the system will be allowed to go to sleep fully unless there\n     * is a reason for it to be awake such as recent user activity or wake locks being held.\n     * </p>\n     */\n    public final void finish() {\n        if (mDebug) Slog.v(TAG, \"finish(): mFinished=\" + mFinished);\n\n        Activity activity = mActivity;\n        if (activity != null) {\n            if (!activity.isFinishing()) {\n                // In case the activity is not finished yet, do it now.\n                activity.finishAndRemoveTask();\n            }\n            return;\n        }\n\n        if (mFinished) {\n            return;\n        }\n        mFinished = true;\n\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Finish was called before the dream was attached.\");\n            stopSelf();\n            return;\n        }\n\n        try {\n            // finishSelf will unbind the dream controller from the dream service. This will\n            // trigger DreamService.this.onDestroy and DreamService.this will die.\n            mDreamManager.finishSelf(mDreamToken, true /*immediate*/);\n        } catch (RemoteException ex) {\n            // system server died\n        }\n    }\n\n    /**\n     * Wakes the dream up gently.\n     * <p>\n     * Calls {@link #onWakeUp} to give the dream a chance to perform an exit transition.\n     * When the transition is over, the dream should call {@link #finish}.\n     * </p>\n     */\n    public final void wakeUp() {\n        wakeUp(false);\n    }\n\n    private void wakeUp(boolean fromSystem) {\n        if (mDebug) Slog.v(TAG, \"wakeUp(): fromSystem=\" + fromSystem\n                + \", mWaking=\" + mWaking + \", mFinished=\" + mFinished);\n\n        if (!mWaking && !mFinished) {\n            mWaking = true;\n\n            // As a minor optimization, invoke the callback first in case it simply\n            // calls finish() immediately so there wouldn't be much point in telling\n            // the system that we are finishing the dream gently.\n            onWakeUp();\n\n            // Now tell the system we are waking gently, unless we already told\n            // it we were finishing immediately.\n            if (!fromSystem && !mFinished) {\n                if (mActivity == null) {\n                    Slog.w(TAG, \"WakeUp was called before the dream was attached.\");\n                } else {\n                    try {\n                        mDreamManager.finishSelf(mDreamToken, false /*immediate*/);\n                    } catch (RemoteException ex) {\n                        // system server died\n                    }\n                }\n            }\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDestroy() {\n        if (mDebug) Slog.v(TAG, \"onDestroy()\");\n        // hook for subclasses\n\n        // Just in case destroy came in before detach, let's take care of that now\n        detach();\n\n        super.onDestroy();\n    }\n\n    // end public api\n\n    /**\n     * Called by DreamController.stopDream() when the Dream is about to be unbound and destroyed.\n     *\n     * Must run on mHandler.\n     */\n    private final void detach() {\n        if (mStarted) {\n            if (mDebug) Slog.v(TAG, \"detach(): Calling onDreamingStopped()\");\n            mStarted = false;\n            onDreamingStopped();\n        }\n\n        if (mActivity != null && !mActivity.isFinishing()) {\n            mActivity.finishAndRemoveTask();\n        } else {\n            finish();\n        }\n\n        mDreamToken = null;\n        mCanDoze = false;\n    }\n\n    /**\n     * Called when the Dream is ready to be shown.\n     *\n     * Must run on mHandler.\n     *\n     * @param dreamToken Token for this dream service.\n     * @param started A callback that will be invoked once onDreamingStarted has completed.\n     */\n    private void attach(IBinder dreamToken, boolean canDoze, IRemoteCallback started) {\n        if (mDreamToken != null) {\n            Slog.e(TAG, \"attach() called when dream with token=\" + mDreamToken\n                    + \" already attached\");\n            return;\n        }\n        if (mFinished || mWaking) {\n            Slog.w(TAG, \"attach() called after dream already finished\");\n            try {\n                mDreamManager.finishSelf(dreamToken, true /*immediate*/);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n            return;\n        }\n\n        mDreamToken = dreamToken;\n        mCanDoze = canDoze;\n        if (mWindowless && !mCanDoze) {\n            throw new IllegalStateException(\"Only doze dreams can be windowless\");\n        }\n\n        mDispatchAfterOnAttachedToWindow = () -> {\n            if (mWindow != null || mWindowless) {\n                mStarted = true;\n                try {\n                    onDreamingStarted();\n                } finally {\n                    try {\n                        started.sendResult(null);\n                    } catch (RemoteException e) {\n                        throw e.rethrowFromSystemServer();\n                    }\n                }\n            }\n        };\n\n        // We need to defer calling onDreamingStarted until after the activity is created.\n        // If the dream is windowless, we can call it immediately. Otherwise, we wait\n        // for the DreamActivity to report onActivityCreated via\n        // DreamServiceWrapper.onActivityCreated.\n        if (!mWindowless) {\n            Intent i = new Intent(this, DreamActivity.class);\n            i.setPackage(getApplicationContext().getPackageName());\n            i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            i.putExtra(DreamActivity.EXTRA_CALLBACK, mDreamServiceWrapper);\n\n            try {\n                if (!ActivityTaskManager.getService().startDreamActivity(i)) {\n                    detach();\n                    return;\n                }\n            } catch (RemoteException e) {\n                Log.w(TAG, \"Could not connect to activity task manager to start dream activity\");\n                e.rethrowFromSystemServer();\n            }\n        } else {\n            mDispatchAfterOnAttachedToWindow.run();\n        }\n    }\n\n    private void onWindowCreated(Window w) {\n        mWindow = w;\n        mWindow.setCallback(this);\n        mWindow.requestFeature(Window.FEATURE_NO_TITLE);\n\n        WindowManager.LayoutParams lp = mWindow.getAttributes();\n        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN\n                    | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR\n                    | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED\n                    | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD\n                    | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON\n                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED\n                    | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0)\n                    | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0)\n                    );\n        mWindow.setAttributes(lp);\n        // Workaround: Currently low-profile and in-window system bar backgrounds don't go\n        // along well. Dreams usually don't need such bars anyways, so disable them by default.\n        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n\n        mWindow.getDecorView().addOnAttachStateChangeListener(\n                new View.OnAttachStateChangeListener() {\n                    @Override\n                    public void onViewAttachedToWindow(View v) {\n                        mDispatchAfterOnAttachedToWindow.run();\n                    }\n\n                    @Override\n                    public void onViewDetachedFromWindow(View v) {\n                        if (mActivity == null || !mActivity.isChangingConfigurations()) {\n                            // Only stop the dream if the view is not detached by relaunching\n                            // activity for configuration changes.\n                            mActivity = null;\n                            finish();\n                        }\n                    }\n                });\n    }\n\n    private boolean getWindowFlagValue(int flag, boolean defaultValue) {\n        return mWindow == null ? defaultValue : (mWindow.getAttributes().flags & flag) != 0;\n    }\n\n    private void applyWindowFlags(int flags, int mask) {\n        if (mWindow != null) {\n            WindowManager.LayoutParams lp = mWindow.getAttributes();\n            lp.flags = applyFlags(lp.flags, flags, mask);\n            mWindow.setAttributes(lp);\n            mWindow.getWindowManager().updateViewLayout(mWindow.getDecorView(), lp);\n        }\n    }\n\n    private int applyFlags(int oldFlags, int flags, int mask) {\n        return (oldFlags&~mask) | (flags&mask);\n    }\n\n    @Override\n    protected void dump(final FileDescriptor fd, PrintWriter pw, final String[] args) {\n        DumpUtils.dumpAsync(mHandler, new Dump() {\n            @Override\n            public void dump(PrintWriter pw, String prefix) {\n                dumpOnHandler(fd, pw, args);\n            }\n        }, pw, \"\", 1000);\n    }\n\n    /** @hide */\n    protected void dumpOnHandler(FileDescriptor fd, PrintWriter pw, String[] args) {\n        pw.print(TAG + \": \");\n        if (mFinished) {\n            pw.println(\"stopped\");\n        } else {\n            pw.println(\"running (dreamToken=\" + mDreamToken + \")\");\n        }\n        pw.println(\"  window: \" + mWindow);\n        pw.print(\"  flags:\");\n        if (isInteractive()) pw.print(\" interactive\");\n        if (isFullscreen()) pw.print(\" fullscreen\");\n        if (isScreenBright()) pw.print(\" bright\");\n        if (isWindowless()) pw.print(\" windowless\");\n        if (isDozing()) pw.print(\" dozing\");\n        else if (canDoze()) pw.print(\" candoze\");\n        pw.println();\n        if (canDoze()) {\n            pw.println(\"  doze screen state: \" + Display.stateToString(mDozeScreenState));\n            pw.println(\"  doze screen brightness: \" + mDozeScreenBrightness);\n        }\n    }\n\n    private static int clampAbsoluteBrightness(int value) {\n        return MathUtils.constrain(value, PowerManager.BRIGHTNESS_OFF, PowerManager.BRIGHTNESS_ON);\n    }\n\n    /**\n     * The DreamServiceWrapper is used as a gateway to the system_server, where DreamController\n     * uses it to control the DreamService. It is also used to receive callbacks from the\n     * DreamActivity.\n     */\n    final class DreamServiceWrapper extends IDreamService.Stub {\n        @Override\n        public void attach(final IBinder dreamToken, final boolean canDoze,\n                IRemoteCallback started) {\n            mHandler.post(() -> DreamService.this.attach(dreamToken, canDoze, started));\n        }\n\n        @Override\n        public void detach() {\n            mHandler.post(DreamService.this::detach);\n        }\n\n        @Override\n        public void wakeUp() {\n            mHandler.post(() -> DreamService.this.wakeUp(true /*fromSystem*/));\n        }\n\n        /** @hide */\n        void onActivityCreated(DreamActivity a) {\n            mActivity = a;\n            onWindowCreated(a.getWindow());\n        }\n    }\n}",
            "downstream_file_ground_truth_tokens": {
              "openai": 9207,
              "general": {
                "word_based": 4394,
                "char_based": 10387
              },
              "gemini": 10602
            },
            "downstream_file_content_patched_upstream_only": "```java\n/**\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage android.service.dreams;\n\nimport android.annotation.IdRes;\nimport android.annotation.LayoutRes;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.SdkConstant;\nimport android.annotation.SdkConstant.SdkConstantType;\nimport android.annotation.TestApi;\nimport android.app.Activity;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.Service;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.Intent;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.IRemoteCallback;\nimport android.os.Looper;\nimport android.os.PowerManager;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.util.Log;\nimport android.util.MathUtils;\nimport android.util.Slog;\nimport android.view.ActionMode;\nimport android.view.Display;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SearchEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.WindowManager.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.DumpUtils.Dump;\n\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\n\n/**\n * Extend this class to implement a custom dream (available to the user as a \"Daydream\").\n *\n * <p>Dreams are interactive screensavers launched when a charging device is idle, or docked in a\n * desk dock. Dreams provide another modality for apps to express themselves, tailored for\n * an exhibition/lean-back experience.</p>\n *\n * <p>The {@code DreamService} lifecycle is as follows:</p>\n * <ol>\n *   <li>{@link #onAttachedToWindow}\n *     <p>Use this for initial setup, such as calling {@link #setContentView setContentView()}.</li>\n *   <li>{@link #onDreamingStarted}\n *     <p>Your dream has started, so you should begin animations or other behaviors here.</li>\n *   <li>{@link #onDreamingStopped}\n *     <p>Use this to stop the things you started in {@link #onDreamingStarted}.</li>\n *   <li>{@link #onDetachedFromWindow}\n *     <p>Use this to dismantle resources (for example, detach from handlers\n *        and listeners).</li>\n * </ol>\n *\n * <p>In addition, onCreate and onDestroy (from the Service interface) will also be called, but\n * initialization and teardown should be done by overriding the hooks above.</p>\n *\n * <p>To be available to the system, your {@code DreamService} should be declared in the\n * manifest as follows:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\" >\n *\n *     &lt;intent-filter>\n *         &lt;action android:name=\"android.service.dreams.DreamService\" />\n *         &lt;category android:name=\"android.intent.category.DEFAULT\" />\n *     &lt;/intent-filter>\n *\n *     &lt;!-- Point to additional information for this dream (optional) -->\n *     &lt;meta-data\n *         android:name=\"android.service.dream\"\n *         android:resource=\"@xml/my_dream\" />\n * &lt;/service>\n * </pre>\n *\n * <p>If specified with the {@code <meta-data>} element,\n * additional information for the dream is defined using the\n * {@link android.R.styleable#Dream &lt;dream&gt;} element in a separate XML file.\n * Currently, the only addtional\n * information you can provide is for a settings activity that allows the user to configure\n * the dream behavior. For example:</p>\n * <p class=\"code-caption\">res/xml/my_dream.xml</p>\n * <pre>\n * &lt;dream xmlns:android=\"http://schemas.android.com/apk/res/android\"\n *     android:settingsActivity=\"com.example.app/.MyDreamSettingsActivity\" />\n * </pre>\n * <p>This makes a Settings button available alongside your dream's listing in the\n * system settings, which when pressed opens the specified activity.</p>\n *\n *\n * <p>To specify your dream layout, call {@link #setContentView}, typically during the\n * {@link #onAttachedToWindow} callback. For example:</p>\n * <pre>\n * public class MyDream extends DreamService {\n *\n *     &#64;Override\n *     public void onAttachedToWindow() {\n *         super.onAttachedToWindow();\n *\n *         // Exit dream upon user touch\n *         setInteractive(false);\n *         // Hide system UI\n *         setFullscreen(true);\n *         // Set the dream layout\n *         setContentView(R.layout.dream);\n *     }\n * }\n * </pre>\n *\n * <p>When targeting api level 21 and above, you must declare the service in your manifest file\n * with the {@link android.Manifest.permission#BIND_DREAM_SERVICE} permission. For example:</p>\n * <pre>\n * &lt;service\n *     android:name=\".MyDream\"\n *     android:exported=\"true\"\n *     android:icon=\"@drawable/my_icon\"\n *     android:label=\"@string/my_dream_label\"\n *     android:permission=\"android.permission.BIND_DREAM_SERVICE\">\n *   &lt;intent-filter>\n *     &lt;action android:name=\u201dandroid.service.dreams.DreamService\u201d />\n *     &lt;category android:name=\u201dandroid.intent.category.DEFAULT\u201d />\n *   &lt;/intent-filter>\n * &lt;/service>\n * </pre>\n */\npublic class DreamService extends Service implements Window.Callback {\n    private final String TAG = DreamService.class.getSimpleName() + \"[\" + getClass().getSimpleName() + \"]\";\n\n    /**\n     * The name of the dream manager service.\n     * @hide\n     */\n    public static final String DREAM_SERVICE = \"dreams\";\n\n    /**\n     * The {@link Intent} that must be declared as handled by the service.\n     */\n    @SdkConstant(SdkConstantType.SERVICE_ACTION)\n    public static final String SERVICE_INTERFACE =\n            \"android.service.dreams.DreamService\";\n\n    /**\n     * Name under which a Dream publishes information about itself.\n     * This meta-data must reference an XML resource containing\n     * a <code>&lt;{@link android.R.styleable#Dream dream}&gt;</code>\n     * tag.\n     */\n    public static final String DREAM_META_DATA = \"android.service.dream\";\n\n    private final IDreamManager mDreamManager;\n    private final Handler mHandler = new Handler(Looper.getMainLooper());\n    private IBinder mDreamToken;\n    private Window mWindow;\n    private Activity mActivity;\n    private boolean mInteractive;\n    private boolean mFullscreen;\n    private boolean mScreenBright = true;\n    private boolean mStarted;\n    private boolean mWaking;\n    private boolean mFinished;\n    private boolean mCanDoze;\n    private boolean mDozing;\n    private boolean mWindowless;\n    private int mDozeScreenState = Display.STATE_UNKNOWN;\n    private int mDozeScreenBrightness = PowerManager.BRIGHTNESS_DEFAULT;\n\n    private boolean mDebug = false;\n\n    private DreamServiceWrapper mDreamServiceWrapper;\n    private Runnable mDispatchAfterOnAttachedToWindow;\n\n    public DreamService() {\n        mDreamManager = IDreamManager.Stub.asInterface(ServiceManager.getService(DREAM_SERVICE));\n    }\n\n    /**\n     * @hide\n     */\n    public void setDebug(boolean dbg) {\n        mDebug = dbg;\n    }\n\n    // begin Window.Callback methods\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyEvent\");\n            wakeUp();\n            return true;\n        } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {\n            if (mDebug) Slog.v(TAG, \"Waking up on back key\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchKeyShortcutEvent(KeyEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on keyShortcutEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchKeyShortcutEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // TODO: create more flexible version of mInteractive that allows clicks\n        // but finish()es on any other kind of activity\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on touchEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTouchEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchTrackballEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on trackballEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchTrackballEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchGenericMotionEvent(MotionEvent event) {\n        if (!mInteractive) {\n            if (mDebug) Slog.v(TAG, \"Waking up on genericMotionEvent\");\n            wakeUp();\n            return true;\n        }\n        return mWindow.superDispatchGenericMotionEvent(event);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public View onCreatePanelView(int featureId) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onCreatePanelMenu(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onPreparePanel(int featureId, View view, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuOpened(int featureId, Menu menu) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item) {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowAttributesChanged(LayoutParams attrs) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onContentChanged() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onWindowFocusChanged(boolean hasFocus) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onAttachedToWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDetachedFromWindow() {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onPanelClosed(int featureId, Menu menu) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested(SearchEvent event) {\n        return onSearchRequested();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean onSearchRequested() {\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ActionMode onWindowStartingActionMode(\n            android.view.ActionMode.Callback callback, int type) {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeStarted(ActionMode mode) {\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onActionModeFinished(ActionMode mode) {\n    }\n    // end Window.Callback methods\n\n    // begin public api\n    /**\n     * Retrieves the current {@link android.view.WindowManager} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindowManager()}.\n     *\n     * @return The current window manager, or null if the dream is not started.\n     */\n    public WindowManager getWindowManager() {\n        return mWindow != null ? mWindow.getWindowManager() : null;\n    }\n\n    /**\n     * Retrieves the current {@link android.view.Window} for the dream.\n     * Behaves similarly to {@link android.app.Activity#getWindow()}.\n     *\n     * @return The current window, or null if the dream is not started.\n     */\n    public Window getWindow() {\n        return mWindow;\n    }\n\n   /**\n     * Inflates a layout resource and set it to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(int)}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param layoutResID Resource ID to be inflated.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to {@link android.app.Activity#setContentView(android.view.View)} in an activity,\n     * including using {@link ViewGroup.LayoutParams#MATCH_PARENT} as the layout height and width of the view.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @see #setContentView(int)\n     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)\n     */\n    public void setContentView(View view) {\n        getWindow().setContentView(view);\n    }\n\n    /**\n     * Sets a view to be the content view for this Dream.\n     * Behaves similarly to\n     * {@link android.app.Activity#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)}\n     * in an activity.\n     *\n     * <p>Note: This requires a window, so you should usually call it during\n     * {@link #onAttachedToWindow()} and never earlier (you <strong>cannot</strong> call it\n     * during {@link #onCreate}).</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     *\n     * @see #setContentView(android.view.View)\n     * @see #setContentView(int)\n     */\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().setContentView(view, params);\n    }\n\n    /**\n     * Adds a view to the Dream's window, leaving other content views in place.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     *\n     * @param view The desired content to display.\n     * @param params Layout parameters for the view.\n     */\n    public void addContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().addContentView(view, params);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that\n     * was processed in {@link #onCreate}.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return The view if found or null otherwise.\n     * @see View#findViewById(int)\n     * @see DreamService#requireViewById(int)\n     */\n    @Nullable\n    public <T extends View> T findViewById(@IdRes int id) {\n        return getWindow().findViewById(id);\n    }\n\n    /**\n     * Finds a view that was identified by the id attribute from the XML that was processed in\n     * {@link #onCreate}, or throws an IllegalArgumentException if the ID is invalid or there is no\n     * matching view in the hierarchy.\n     *\n     * <p>Note: Requires a window, do not call before {@link #onAttachedToWindow()}</p>\n     * <p>\n     * <strong>Note:</strong> In most cases -- depending on compiler support --\n     * the resulting view is automatically cast to the target class type. If\n     * the target class type is unconstrained, an explicit cast may be\n     * necessary.\n     *\n     * @param id the ID to search for\n     * @return a view with given ID\n     * @see View#requireViewById(int)\n     * @see DreamService#findViewById(int)\n     */\n    @NonNull\n    public final <T extends View> T requireViewById(@IdRes int id) {\n        T view = findViewById(id);\n        if (view == null) {\n            throw new IllegalArgumentException(\n                    \"ID does not reference a View inside this DreamService\");\n        }\n        return view;\n    }\n\n    /**\n     * Marks this dream as interactive to receive input events.\n     *\n     * <p>Non-interactive dreams (default) will dismiss on the first input event.</p>\n     *\n     * <p>Interactive dreams should call {@link #finish()} to dismiss themselves.</p>\n     *\n     * @param interactive True if this dream will handle input events.\n     */\n    public void setInteractive(boolean interactive) {\n        mInteractive = interactive;\n    }\n\n    /**\n     * Returns whether or not this dream is interactive.  Defaults to false.\n     *\n     * @see #setInteractive(boolean)\n     */\n    public boolean isInteractive() {\n        return mInteractive;\n    }\n\n    /**\n     * Controls {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN}\n     * on the dream's window.\n     *\n     * @param fullscreen If true, the fullscreen flag will be set; else it\n     * will be cleared.\n     */\n    public void setFullscreen(boolean fullscreen) {\n        if (mFullscreen != fullscreen) {\n            mFullscreen = fullscreen;\n            int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;\n            applyWindowFlags(mFullscreen ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream is in fullscreen mode. Defaults to false.\n     *\n     * @see #setFullscreen(boolean)\n     */\n    public boolean isFullscreen() {\n        return mFullscreen;\n    }\n\n    /**\n     * Marks this dream as keeping the screen bright while dreaming.\n     *\n     * @param screenBright True to keep the screen bright while dreaming.\n     */\n    public void setScreenBright(boolean screenBright) {\n        if (mScreenBright != screenBright) {\n            mScreenBright = screenBright;\n            int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;\n            applyWindowFlags(mScreenBright ? flag : 0, flag);\n        }\n    }\n\n    /**\n     * Returns whether or not this dream keeps the screen bright while dreaming.\n     * Defaults to false, allowing the screen to dim if necessary.\n     *\n     * @see #setScreenBright(boolean)\n     */\n    public boolean isScreenBright() {\n        return getWindowFlagValue(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, mScreenBright);\n    }\n\n    /**\n     * Marks this dream as windowless.  Only available to doze dreams.\n     *\n     * @hide\n     *\n     */\n    public void setWindowless(boolean windowless) {\n        mWindowless = windowless;\n    }\n\n    /**\n     * Returns whether or not this dream is windowless.  Only available to doze dreams.\n     *\n     * @hide\n     */\n    public boolean isWindowless() {\n        return mWindowless;\n    }\n\n    /**\n     * Returns true if this dream is allowed to doze.\n     * <p>\n     * The value returned by this method is only meaningful when the dream has started.\n     * </p>\n     *\n     * @return True if this dream can doze.\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean canDoze() {\n        return mCanDoze;\n    }\n\n    /**\n     * Starts dozing, entering a deep dreamy sleep.\n     * <p>\n     * Dozing enables the system to conserve power while the user is not actively interacting\n     * with the device.  While dozing, the display will remain on in a low-power state\n     * and will continue to show its previous contents but the application processor and\n     * other system components will be allowed to suspend when possible.\n     * </p><p>\n     * While the application processor is suspended, the dream may stop executing code\n     * for long periods of time.  Prior to being suspended, the dream may schedule periodic\n     * wake-ups to render new content by scheduling an alarm with the {@link AlarmManager}.\n     * The dream may also keep the CPU awake by acquiring a\n     * {@link android.os.PowerManager#PARTIAL_WAKE_LOCK partial wake lock} when necessary.\n     * Note that since the purpose of doze mode is to conserve power (especially when\n     * running on battery), the dream should not wake the CPU very often or keep it\n     * awake for very long.\n     * </p><p>\n     * It is a good idea to call this method some time after the dream's entry animation\n     * has completed and the dream is ready to doze.  It is important to completely\n     * finish all of the work needed before dozing since the application processor may\n     * be suspended at any moment once this method is called unless other wake locks\n     * are being held.\n     * </p><p>\n     * Call {@link #stopDozing} or {@link #finish} to stop dozing.\n     * </p>\n     *\n     * @see #stopDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void startDozing() {\n        if (mCanDoze && !mDozing) {\n            mDozing = true;\n            updateDoze();\n        }\n    }\n\n    private void updateDoze() {\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Updating doze without a dream token.\");\n            return;\n        }\n\n        if (mDozing) {\n            try {\n                mDreamManager.startDozing(mDreamToken, mDozeScreenState, mDozeScreenBrightness);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Stops dozing, returns to active dreaming.\n     * <p>\n     * This method reverses the effect of {@link #startDozing}.  From this moment onward,\n     * the application processor will be kept awake as long as the dream is running\n     * or until the dream starts dozing again.\n     * </p>\n     *\n     * @see #startDozing\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public void stopDozing() {\n        if (mDozing) {\n            mDozing = false;\n            try {\n                mDreamManager.stopDozing(mDreamToken);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n        }\n    }\n\n    /**\n     * Returns true if the dream will allow the system to enter a low-power state while\n     * it is running without actually turning off the screen.  Defaults to false,\n     * keeping the application processor awake while the dream is running.\n     *\n     * @return True if the dream is dozing.\n     *\n     * @see #setDozing(boolean)\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    public boolean isDozing() {\n        return mDozing;\n    }\n\n    /**\n     * Gets the screen state to use while dozing.\n     *\n     * @return The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @see #setDozeScreenState\n     * @hide For use by system UI components only.\n     */\n    public int getDozeScreenState() {\n        return mDozeScreenState;\n    }\n\n    /**\n     * Sets the screen state to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link Display#STATE_UNKNOWN} which lets the system decide.\n     * The dream may set a different state before starting to doze and may\n     * perform transitions between states while dozing to conserve power and\n     * achieve various effects.\n     * </p><p>\n     * Some devices will have dedicated hardware (\"Sidekick\") to animate\n     * the display content while the CPU sleeps. If the dream and the hardware support\n     * this, {@link Display#STATE_ON_SUSPEND} or {@link Display#STATE_DOZE_SUSPEND}\n     * will switch control to the Sidekick.\n     * </p><p>\n     * If not using Sidekick, it is recommended that the state be set to\n     * {@link Display#STATE_DOZE_SUSPEND} once the dream has completely\n     * finished drawing and before it releases its wakelock\n     * to allow the display hardware to be fully suspended.  While suspended,\n     * the display will preserve its on-screen contents.\n     * </p><p>\n     * If the doze suspend state is used, the dream must make sure to set the mode back\n     * to {@link Display#STATE_DOZE} or {@link Display#STATE_ON} before drawing again\n     * since the display updates may be ignored and not seen by the user otherwise.\n     * </p><p>\n     * The set of available display power states and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param state The screen state to use while dozing, such as {@link Display#STATE_ON},\n     * {@link Display#STATE_DOZE}, {@link Display#STATE_DOZE_SUSPEND},\n     * {@link Display#STATE_ON_SUSPEND}, {@link Display#STATE_OFF}, or {@link Display#STATE_UNKNOWN}\n     * for the default behavior.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenState(int state) {\n        if (mDozeScreenState != state) {\n            mDozeScreenState = state;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Gets the screen brightness to use while dozing.\n     *\n     * @return The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @see #setDozeScreenBrightness\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public int getDozeScreenBrightness() {\n        return mDozeScreenBrightness;\n    }\n\n    /**\n     * Sets the screen brightness to use while dozing.\n     * <p>\n     * The value of this property determines the power state of the primary display\n     * once {@link #startDozing} has been called.  The default value is\n     * {@link PowerManager#BRIGHTNESS_DEFAULT} which lets the system decide.\n     * The dream may set a different brightness before starting to doze and may adjust\n     * the brightness while dozing to conserve power and achieve various effects.\n     * </p><p>\n     * Note that dream may specify any brightness in the full 0-255 range, including\n     * values that are less than the minimum value for manual screen brightness\n     * adjustments by the user.  In particular, the value may be set to 0 which may\n     * turn off the backlight entirely while still leaving the screen on although\n     * this behavior is device dependent and not guaranteed.\n     * </p><p>\n     * The available range of display brightness values and their behavior while dozing is\n     * hardware dependent and may vary across devices.  The dream may therefore\n     * need to be modified or configured to correctly support the hardware.\n     * </p>\n     *\n     * @param brightness The screen brightness while dozing as a value between\n     * {@link PowerManager#BRIGHTNESS_OFF} (0) and {@link PowerManager#BRIGHTNESS_ON} (255),\n     * or {@link PowerManager#BRIGHTNESS_DEFAULT} (-1) to ask the system to apply\n     * its default policy based on the screen state.\n     *\n     * @hide For use by system UI components only.\n     */\n    @UnsupportedAppUsage\n    public void setDozeScreenBrightness(int brightness) {\n        if (brightness != PowerManager.BRIGHTNESS_DEFAULT) {\n            brightness = clampAbsoluteBrightness(brightness);\n        }\n        if (mDozeScreenBrightness != brightness) {\n            mDozeScreenBrightness = brightness;\n            updateDoze();\n        }\n    }\n\n    /**\n     * Called when this Dream is constructed.\n     */\n    @Override\n    public void onCreate() {\n        if (mDebug) Slog.v(TAG, \"onCreate()\");\n        super.onCreate();\n    }\n\n    /**\n     * Called when the dream's window has been created and is visible and animation may now begin.\n     */\n    public void onDreamingStarted() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStarted()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when this Dream is stopped, either by external request or by calling finish(),\n     * before the window has been removed.\n     */\n    public void onDreamingStopped() {\n        if (mDebug) Slog.v(TAG, \"onDreamingStopped()\");\n        // hook for subclasses\n    }\n\n    /**\n     * Called when the dream is being asked to stop itself and wake.\n     * <p>\n     * The default implementation simply calls {@link #finish} which ends the dream\n     * immediately.  Subclasses may override this function to perform a smooth exit\n     * transition then call {@link #finish} afterwards.\n     * </p><p>\n     * Note that the dream will only be given a short period of time (currently about\n     * five seconds) to wake up.  If the dream does not finish itself in a timely manner\n     * then the system will forcibly finish it once the time allowance is up.\n     * </p>\n     */\n    public void onWakeUp() {\n        finish();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public final IBinder onBind(Intent intent) {\n        if (mDebug) Slog.v(TAG, \"onBind() intent = \" + intent);\n        mDreamServiceWrapper = new DreamServiceWrapper();\n        return mDreamServiceWrapper;\n    }\n\n    /**\n     * Stops the dream and detaches from the window.\n     * <p>\n     * When the dream ends, the system will be allowed to go to sleep fully unless there\n     * is a reason for it to be awake such as recent user activity or wake locks being held.\n     * </p>\n     */\n    public final void finish() {\n        if (mDebug) Slog.v(TAG, \"finish(): mFinished=\" + mFinished);\n\n        Activity activity = mActivity;\n        if (activity != null) {\n            if (!activity.isFinishing()) {\n                // In case the activity is not finished yet, do it now.\n                activity.finishAndRemoveTask();\n            }\n            return;\n        }\n\n        if (mFinished) {\n            return;\n        }\n        mFinished = true;\n\n        if (mDreamToken == null) {\n            Slog.w(TAG, \"Finish was called before the dream was attached.\");\n            stopSelf();\n            return;\n        }\n\n        try {\n            // finishSelf will unbind the dream controller from the dream service. This will\n            // trigger DreamService.this.onDestroy and DreamService.this will die.\n            mDreamManager.finishSelf(mDreamToken, true /*immediate*/);\n        } catch (RemoteException ex) {\n            // system server died\n        }\n    }\n\n    /**\n     * Wakes the dream up gently.\n     * <p>\n     * Calls {@link #onWakeUp} to give the dream a chance to perform an exit transition.\n     * When the transition is over, the dream should call {@link #finish}.\n     * </p>\n     */\n    public final void wakeUp() {\n        wakeUp(false);\n    }\n\n    private void wakeUp(boolean fromSystem) {\n        if (mDebug) Slog.v(TAG, \"wakeUp(): fromSystem=\" + fromSystem\n                + \", mWaking=\" + mWaking + \", mFinished=\" + mFinished);\n\n        if (!mWaking && !mFinished) {\n            mWaking = true;\n\n            // As a minor optimization, invoke the callback first in case it simply\n            // calls finish() immediately so there wouldn't be much point in telling\n            // the system that we are finishing the dream gently.\n            onWakeUp();\n\n            // Now tell the system we are waking gently, unless we already told\n            // it we were finishing immediately.\n            if (!fromSystem && !mFinished) {\n                if (mActivity == null) {\n                    Slog.w(TAG, \"WakeUp was called before the dream was attached.\");\n                } else {\n                    try {\n                        mDreamManager.finishSelf(mDreamToken, false /*immediate*/);\n                    } catch (RemoteException ex) {\n                        // system server died\n                    }\n                }\n            }\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void onDestroy() {\n        if (mDebug) Slog.v(TAG, \"onDestroy()\");\n        // hook for subclasses\n\n        // Just in case destroy came in before detach, let's take care of that now\n        detach();\n\n        super.onDestroy();\n    }\n\n    // end public api\n\n    /**\n     * Called by DreamController.stopDream() when the Dream is about to be unbound and destroyed.\n     *\n     * Must run on mHandler.\n     */\n    private final void detach() {\n        if (mStarted) {\n            if (mDebug) Slog.v(TAG, \"detach(): Calling onDreamingStopped()\");\n            mStarted = false;\n            onDreamingStopped();\n        }\n\n        if (mActivity != null && !mActivity.isFinishing()) {\n            mActivity.finishAndRemoveTask();\n        } else {\n            finish();\n        }\n\n        mDreamToken = null;\n        mCanDoze = false;\n    }\n\n    /**\n     * Called when the Dream is ready to be shown.\n     *\n     * Must run on mHandler.\n     *\n     * @param dreamToken Token for this dream service.\n     * @param started A callback that will be invoked once onDreamingStarted has completed.\n     */\n    private void attach(IBinder dreamToken, boolean canDoze, IRemoteCallback started) {\n        if (mDreamToken != null) {\n            Slog.e(TAG, \"attach() called when dream with token=\" + mDreamToken\n                    + \" already attached\");\n            return;\n        }\n        if (mFinished || mWaking) {\n            Slog.w(TAG, \"attach() called after dream already finished\");\n            try {\n                mDreamManager.finishSelf(dreamToken, true /*immediate*/);\n            } catch (RemoteException ex) {\n                // system server died\n            }\n            return;\n        }\n\n        mDreamToken = dreamToken;\n        mCanDoze = canDoze;\n        if (mWindowless && !mCanDoze) {\n            throw new IllegalStateException(\"Only doze dreams can be windowless\");\n        }\n\n        mDispatchAfterOnAttachedToWindow = () -> {\n            if (mWindow != null || mWindowless) {\n                mStarted = true;\n                try {\n                    onDreamingStarted();\n                } finally {\n                    try {\n                        started.sendResult(null);\n                    } catch (RemoteException e) {\n                        throw e.rethrowFromSystemServer();\n                    }\n                }\n            }\n        };\n\n        // We need to defer calling onDreamingStarted until after the activity is created.\n        // If the dream is windowless, we can call it immediately. Otherwise, we wait\n        // for the DreamActivity to report onActivityCreated via\n        // DreamServiceWrapper.onActivityCreated.\n        if (!mWindowless) {\n            Intent i = new Intent(this, DreamActivity.class);\n            i.setPackage(getApplicationContext().getPackageName());\n            i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            i.putExtra(DreamActivity.EXTRA_CALLBACK, mDreamServiceWrapper);\n\n            try {\n                if (!ActivityTaskManager.getService().startDreamActivity(i)) {\n                    detach();\n                    return;\n                }\n            } catch (RemoteException e) {\n                Log.w(TAG, \"Could not connect to activity task manager to start dream activity\");\n                e.rethrowFromSystemServer();\n            }\n        } else {\n            mDispatchAfterOnAttachedToWindow.run();\n        }\n    }\n\n    private void onWindowCreated(Window w) {\n        mWindow = w;\n        mWindow.setCallback(this);\n        mWindow.requestFeature(Window.FEATURE_NO_TITLE);\n\n        WindowManager.LayoutParams lp = mWindow.getAttributes();\n        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN\n                    | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR\n                    | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED\n                    | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD\n                    | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON\n                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED\n                    | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0)\n                    | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0)\n                    );\n        mWindow.setAttributes(lp);\n        // Workaround: Currently low-profile and in-window system bar backgrounds don't go\n        // along well. Dreams usually don't need such bars anyways, so disable them by default.\n        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n\n        mWindow.getDecorView().addOnAttachStateChangeListener(\n                new View.OnAttachStateChangeListener() {\n                    @Override\n                    public void onViewAttachedToWindow(View v) {\n                        mDispatchAfterOnAttachedToWindow.run();\n                    }\n\n                    @Override\n                    public void onViewDetachedFromWindow(View v) {\n                        if (mActivity == null || !mActivity.isChangingConfigurations()) {\n                            // Only stop the dream if the view is not detached by relaunching\n                            // activity for configuration changes.\n                            mActivity = null;\n                            finish();\n                        }\n                    }\n                });\n    }\n\n    private boolean getWindowFlagValue(int flag, boolean defaultValue) {\n        return mWindow == null ? defaultValue : (mWindow.getAttributes().flags & flag) != 0;\n    }\n\n    private void applyWindowFlags(int flags, int mask) {\n        if (mWindow != null) {\n            WindowManager.LayoutParams lp = mWindow.getAttributes();\n            lp.flags = applyFlags(lp.flags, flags, mask);\n            mWindow.setAttributes(lp);\n            mWindow.getWindowManager().updateViewLayout(mWindow.getDecorView(), lp);\n        }\n    }\n\n    private int applyFlags(int oldFlags, int flags, int mask) {\n        return (oldFlags&~mask) | (flags&mask);\n    }\n\n    @Override\n    protected void dump(final FileDescriptor fd, PrintWriter pw, final String[] args) {\n        DumpUtils.dumpAsync(mHandler, new Dump() {\n            @Override\n            public void dump(PrintWriter pw, String prefix) {\n                dumpOnHandler(fd, pw, args);\n            }\n        }, pw, \"\", 1000);\n    }\n\n    /** @hide */\n    protected void dumpOnHandler(FileDescriptor fd, PrintWriter pw, String[] args) {\n        pw.print(TAG + \": \");\n        if (mFinished) {\n            pw.println(\"stopped\");\n        } else {\n            pw.println(\"running (dreamToken=\" + mDreamToken + \")\");\n        }\n        pw.println(\"  window: \" + mWindow);\n        pw.print(\"  flags:\");\n        if (isInteractive()) pw.print(\" interactive\");\n        if (isFullscreen()) pw.print(\" fullscreen\");\n        if (isScreenBright()) pw.print(\" bright\");\n        if (isWindowless()) pw.print(\" windowless\");\n        if (isDozing()) pw.print(\" dozing\");\n        else if (canDoze()) pw.print(\" candoze\");\n        pw.println();\n        if (canDoze()) {\n            pw.println(\"  doze screen state: \" + Display.stateToString(mDozeScreenState));\n            pw.println(\"  doze screen brightness: \" + mDozeScreenBrightness);\n        }\n    }\n\n    private static int clampAbsoluteBrightness(int value) {\n        return MathUtils.constrain(value, PowerManager.BRIGHTNESS_OFF, PowerManager.BRIGHTNESS_ON);\n    }\n\n    /**\n     * The DreamServiceWrapper is used as a gateway to the system_server, where DreamController\n     * uses it to control the DreamService. It is also used to receive callbacks from the\n     * DreamActivity.\n     */\n    final class DreamServiceWrapper extends IDreamService.Stub {\n        @Override\n        public void attach(final IBinder dreamToken, final boolean canDoze,\n                IRemoteCallback started) {\n            mHandler.post(() -> DreamService.this.attach(dreamToken, canDoze, started));\n        }\n\n        @Override\n        public void detach() {\n            mHandler.post(DreamService.this::detach);\n        }\n\n        @Override\n        public void wakeUp() {\n            mHandler.post(() -> DreamService.this.wakeUp(true /*fromSystem*/));\n        }\n\n        /** @hide */\n        void onActivityCreated(DreamActivity a) {\n            mActivity = a;\n            onWindowCreated(a.getWindow());\n        }\n    }\n}\n```",
            "diff_patched_upstream_only": "--- original_downstream_file\n+++ patched_upstream_only\n@@ -1,4 +1,3 @@\n-```java\n /**\n  * Copyright (C) 2012 The Android Open Source Project\n  *\n@@ -1169,5 +1168,4 @@\n             onWindowCreated(a.getWindow());\n         }\n     }\n-}\n-```+}",
            "downstream_llm_diff_output": "```diff\n--- a/core/java/android/service/dreams/DreamService.java\n+++ b/core/java/android/service/dreams/DreamService.java\n@@ -937,2 +937,100 @@\n     }\n \n+    /**\n+     * @hide\n+     */\n+    @Nullable\n+    @TestApi\n+    public static DreamMetadata getDreamMetadata(@NonNull Context context,\n+            @Nullable ServiceInfo serviceInfo) {\n+        if (serviceInfo == null) return null;\n+\n+        PackageManager pm = context.getPackageManager();\n+        try {\n+            // Get the dream <meta-data>.\n+            Bundle metadata = serviceInfo.metaData;\n+            if (metadata == null) return null;\n+\n+            String dreamMetadataXmlPath = metadata.getString(DREAM_META_DATA);\n+            if (dreamMetadataXmlPath == null) return null;\n+\n+            // Get the settings activity component.\n+            ComponentName settingsActivityComponent = null;\n+            XmlResourceParser parser = serviceInfo.loadXmlMetaData(pm, DREAM_META_DATA);\n+            if (parser == null) {\n+                Log.w(TAG, \"Cannot find \" + dreamMetadataXmlPath + \" for \"\n+                        + serviceInfo.packageName);\n+                return null;\n+            }\n+\n+            Resources res = pm.getResourcesForApplication(serviceInfo.applicationInfo);\n+            AttributeSet attrs = Xml.asAttributeSet(parser);\n+            int type;\n+            while ((type=parser.next()) != XmlPullParser.END_DOCUMENT\n+                    && type != XmlPullParser.START_TAG) {\n+            }\n+            String nodeName = parser.getName();\n+            if (!\"dream\".equals(nodeName)) {\n+                Log.w(TAG, \"Meta-data does not start with dream tag for \"\n+                        + serviceInfo.packageName);\n+                return null;\n+            }\n+\n+            TypedArray sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.Dream);\n+            String settingsActivity = sa.getString(\n+                    com.android.internal.R.styleable.Dream_settingsActivity);\n+            if (settingsActivity != null && settingsActivity.isEmpty()) settingsActivity = null;\n+\n+            settingsActivityComponent = convertToComponentName(settingsActivity, serviceInfo);\n+            sa.recycle();\n+            parser.close();\n+            return new DreamMetadata(settingsActivityComponent);\n+        } catch (PackageManager.NameNotFoundException | XmlPullParserException | IOException e) {\n+            Log.w(TAG, \"Error parsing dream metadata for \" + serviceInfo.packageName, e);\n+            return null;\n+        }\n+    }\n+\n+    @Nullable\n+    private static ComponentName convertToComponentName(@Nullable String flattenedString,\n+            ServiceInfo serviceInfo) {\n+        if (flattenedString == null) {\n+            return null;\n+        }\n+        if (flattenedString.indexOf('/') < 0) {\n+            return new ComponentName(serviceInfo.packageName, flattenedString);\n+        }\n+\n+        // Ensure that the component is from the same package as the dream service. If not,\n+        // treat the component as invalid and return null instead.\n+        final ComponentName cn = ComponentName.unflattenFromString(flattenedString);\n+        if (cn == null) return null;\n+        if (!cn.getPackageName().equals(serviceInfo.packageName)) {\n+            Log.w(TAG,\n+                    \"Inconsistent package name in component: \" + cn.getPackageName()\n+                            + \", should be: \" + serviceInfo.packageName);\n+            return null;\n+        }\n+        return cn;\n+    }\n+\n+    /**\n+     * Describes metadata of a dream.\n+     *\n+     * @hide\n+     */\n+    @TestApi\n+    public static final class DreamMetadata {\n+        @Nullable\n+        public final ComponentName settingsActivity;\n+\n+        private DreamMetadata(@Nullable ComponentName settingsActivity) {\n+            this.settingsActivity = settingsActivity;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"DreamMetadata{\"\n+                    + \"settingsActivity=\" + settingsActivity\n+                    + \"}\";\n+        }\n+    }\n }\n```",
            "llm_output_valid": true,
            "runtime_seconds": 291.44,
            "attempts_made": 2,
            "validation_results": [
              {
                "attempt": 1,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk is longer than expected",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 121.39
              },
              {
                "attempt": 2,
                "format_valid": true,
                "format_error": "Valid patch format",
                "apply_valid": true,
                "apply_error": "Patch applies cleanly in repo",
                "valid": true,
                "runtime_seconds": 159.48
              }
            ],
            "token_counts": {
              "openai": 855,
              "general": {
                "word_based": 318,
                "char_based": 1018
              },
              "gemini": 27809
            }
          }
        ]
      }
    ]
  }
]