[
  {
    "id": "ASB-A-307948424",
    "total_gemini_token_usage": 68559,
    "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-307948424",
    "severity": "High",
    "upstream_patch_content": "From da6a9ea6deece5b2505d5facdf5d44cfc08057f3 Mon Sep 17 00:00:00 2001\nFrom: Valentin Iftime <valiiftime@google.com>\nDate: Wed, 8 Nov 2023 11:01:32 +0100\nSubject: [PATCH] Enforce persisted snoozed notifications limits\n\n Prevent DoS attack that causes boot-looping by serializing a huge amount of snoozed notifications:\n  - Check snooze limits for persisted notifications\n  - Remove persisted group summary notification when in-memory counterpart is removed\n  - Prevent unpriviledged API calls that allow 3P apps to snooze notifications with context/criterion\n\nTest: atest SnoozeHelperTest\nTest: atest NotificationManagerServiceTest\nBug: 307948424\nBug: 308414141\n\nChange-Id: I3571fa9207b778def652130d3ca840183a9a8414\n(cherry picked from commit 965ff2d3c5487f72a77f6153ed8542cb2621d93c)\nMerged-In: I3571fa9207b778def652130d3ca840183a9a8414\n---\n .../server/notification/SnoozeHelper.java     |  8 +-\n .../server/notification/SnoozeHelperTest.java | 99 ++++++++++++++++++-\n 2 files changed, 104 insertions(+), 3 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/notification/SnoozeHelper.java b/services/core/java/com/android/server/notification/SnoozeHelper.java\nindex 017698943fc9..e8f78f31729c 100644\n--- a/services/core/java/com/android/server/notification/SnoozeHelper.java\n+++ b/services/core/java/com/android/server/notification/SnoozeHelper.java\n@@ -118,7 +118,10 @@ public final class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mSnoozedNotifications.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mSnoozedNotifications.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                    || (mPersistedSnoozedNotifications.size()\n+                    + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n+                    > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n@@ -343,6 +346,9 @@ public final class SnoozeHelper {\n \n             if (groupSummaryKey != null) {\n                 NotificationRecord record = mSnoozedNotifications.remove(groupSummaryKey);\n+                String trimmedKey = getTrimmedString(groupSummaryKey);\n+                mPersistedSnoozedNotificationsWithContext.remove(trimmedKey);\n+                mPersistedSnoozedNotifications.remove(trimmedKey);\n \n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\ndiff --git a/services/tests/uiservicestests/src/com/android/server/notification/SnoozeHelperTest.java b/services/tests/uiservicestests/src/com/android/server/notification/SnoozeHelperTest.java\nindex 51b9c176a245..22c7f9c88867 100644\n--- a/services/tests/uiservicestests/src/com/android/server/notification/SnoozeHelperTest.java\n+++ b/services/tests/uiservicestests/src/com/android/server/notification/SnoozeHelperTest.java\n@@ -18,6 +18,8 @@ package com.android.server.notification;\n import static com.android.server.notification.SnoozeHelper.CONCURRENT_SNOOZE_LIMIT;\n import static com.android.server.notification.SnoozeHelper.EXTRA_KEY;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static junit.framework.Assert.assertEquals;\n import static junit.framework.Assert.assertFalse;\n import static junit.framework.Assert.assertNotNull;\n@@ -72,6 +74,14 @@ import java.io.IOException;\n public class SnoozeHelperTest extends UiServiceTestCase {\n     private static final String TEST_CHANNEL_ID = \"test_channel_id\";\n \n+    private static final String XML_TAG_NAME = \"snoozed-notifications\";\n+    private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n+    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT = \"context\";\n+    private static final String XML_SNOOZED_NOTIFICATION_KEY = \"key\";\n+    private static final String XML_SNOOZED_NOTIFICATION_TIME = \"time\";\n+    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT_ID = \"id\";\n+    private static final String XML_SNOOZED_NOTIFICATION_VERSION_LABEL = \"version\";\n+\n     @Mock SnoozeHelper.Callback mCallback;\n     @Mock AlarmManager mAm;\n     @Mock ManagedServices.UserProfiles mUserProfiles;\n@@ -314,6 +324,53 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n         assertFalse(mSnoozeHelper.canSnooze(1));\n     }\n \n+    @Test\n+    public void testSnoozeLimit_maximumPersisted() throws XmlPullParserException, IOException {\n+        final long snoozeTimeout = 1234;\n+        final String snoozeContext = \"ctx\";\n+        // Serialize & deserialize notifications so that only persisted lists are used\n+        TypedXmlSerializer serializer = Xml.newFastSerializer();\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        serializer.setOutput(new BufferedOutputStream(baos), \"utf-8\");\n+        serializer.startDocument(null, true);\n+        serializer.startTag(null, XML_TAG_NAME);\n+        // Serialize maximum number of timed + context snoozed notifications, half of each\n+        for (int i = 0; i < CONCURRENT_SNOOZE_LIMIT; i++) {\n+            final boolean timedNotification = i % 2 == 0;\n+            if (timedNotification) {\n+                serializer.startTag(null, XML_SNOOZED_NOTIFICATION);\n+            } else {\n+                serializer.startTag(null, XML_SNOOZED_NOTIFICATION_CONTEXT);\n+            }\n+            serializer.attributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL, 1);\n+            serializer.attribute(null, XML_SNOOZED_NOTIFICATION_KEY, \"key\" + i);\n+            if (timedNotification) {\n+                serializer.attributeLong(null, XML_SNOOZED_NOTIFICATION_TIME, snoozeTimeout);\n+                serializer.endTag(null, XML_SNOOZED_NOTIFICATION);\n+            } else {\n+                serializer.attribute(null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID, snoozeContext);\n+                serializer.endTag(null, XML_SNOOZED_NOTIFICATION_CONTEXT);\n+            }\n+        }\n+        serializer.endTag(null, XML_TAG_NAME);\n+        serializer.endDocument();\n+        serializer.flush();\n+\n+        TypedXmlPullParser parser = Xml.newFastPullParser();\n+        parser.setInput(new BufferedInputStream(\n+                new ByteArrayInputStream(baos.toByteArray())), \"utf-8\");\n+        mSnoozeHelper.readXml(parser, 1);\n+        // Verify that we can't snooze any more notifications\n+        //  and that the limit is caused by persisted notifications\n+        assertThat(mSnoozeHelper.canSnooze(1)).isFalse();\n+        assertThat(mSnoozeHelper.isSnoozed(UserHandle.USER_SYSTEM, \"pkg\", \"key0\")).isFalse();\n+        assertThat(mSnoozeHelper.getSnoozeTimeForUnpostedNotification(UserHandle.USER_SYSTEM,\n+                \"pkg\", \"key0\")).isEqualTo(snoozeTimeout);\n+        assertThat(\n+            mSnoozeHelper.getSnoozeContextForUnpostedNotification(UserHandle.USER_SYSTEM, \"pkg\",\n+                \"key1\")).isEqualTo(snoozeContext);\n+    }\n+\n     @Test\n     public void testCancelByApp() throws Exception {\n         NotificationRecord r = getNotificationRecord(\"pkg\", 1, \"one\", UserHandle.SYSTEM);\n@@ -587,6 +644,7 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n \n     @Test\n     public void repostGroupSummary_repostsSummary() throws Exception {\n+        final int snoozeDuration = 1000;\n         IntArray profileIds = new IntArray();\n         profileIds.add(UserHandle.USER_SYSTEM);\n         when(mUserProfiles.getCurrentProfileIds()).thenReturn(profileIds);\n@@ -594,10 +652,44 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n                 \"pkg\", 1, \"one\", UserHandle.SYSTEM, \"group1\", true);\n         NotificationRecord r2 = getNotificationRecord(\n                 \"pkg\", 2, \"two\", UserHandle.SYSTEM, \"group1\", false);\n-        mSnoozeHelper.snooze(r, 1000);\n-        mSnoozeHelper.snooze(r2, 1000);\n+        final long snoozeTime = System.currentTimeMillis() + snoozeDuration;\n+        mSnoozeHelper.snooze(r, snoozeDuration);\n+        mSnoozeHelper.snooze(r2, snoozeDuration);\n+        assertEquals(2, mSnoozeHelper.getSnoozed().size());\n+        assertEquals(2, mSnoozeHelper.getSnoozed(UserHandle.USER_SYSTEM, \"pkg\").size());\n+        // Verify that summary notification was added to the persisted list\n+        assertThat(mSnoozeHelper.getSnoozeTimeForUnpostedNotification(UserHandle.USER_SYSTEM, \"pkg\",\n+                r.getKey())).isAtLeast(snoozeTime);\n+\n+        mSnoozeHelper.repostGroupSummary(\"pkg\", UserHandle.USER_SYSTEM, r.getGroupKey());\n+\n+        verify(mCallback, times(1)).repost(UserHandle.USER_SYSTEM, r, false);\n+        verify(mCallback, never()).repost(UserHandle.USER_SYSTEM, r2, false);\n+\n+        assertEquals(1, mSnoozeHelper.getSnoozed().size());\n+        assertEquals(1, mSnoozeHelper.getSnoozed(UserHandle.USER_SYSTEM, \"pkg\").size());\n+        // Verify that summary notification was removed from the persisted list\n+        assertThat(mSnoozeHelper.getSnoozeTimeForUnpostedNotification(UserHandle.USER_SYSTEM, \"pkg\",\n+                r.getKey())).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void snoozeWithContext_repostGroupSummary_removesPersisted() throws Exception {\n+        final String snoozeContext = \"zzzzz\";\n+        IntArray profileIds = new IntArray();\n+        profileIds.add(UserHandle.USER_SYSTEM);\n+        when(mUserProfiles.getCurrentProfileIds()).thenReturn(profileIds);\n+        NotificationRecord r = getNotificationRecord(\n+                \"pkg\", 1, \"one\", UserHandle.SYSTEM, \"group1\", true);\n+        NotificationRecord r2 = getNotificationRecord(\n+                \"pkg\", 2, \"two\", UserHandle.SYSTEM, \"group1\", false);\n+        mSnoozeHelper.snooze(r, snoozeContext);\n+        mSnoozeHelper.snooze(r2, snoozeContext);\n         assertEquals(2, mSnoozeHelper.getSnoozed().size());\n         assertEquals(2, mSnoozeHelper.getSnoozed(UserHandle.USER_SYSTEM, \"pkg\").size());\n+        // Verify that summary notification was added to the persisted list\n+        assertThat(mSnoozeHelper.getSnoozeContextForUnpostedNotification(UserHandle.USER_SYSTEM,\n+            \"pkg\", r.getKey())).isEqualTo(snoozeContext);\n \n         mSnoozeHelper.repostGroupSummary(\"pkg\", UserHandle.USER_SYSTEM, r.getGroupKey());\n \n@@ -606,6 +698,9 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n \n         assertEquals(1, mSnoozeHelper.getSnoozed().size());\n         assertEquals(1, mSnoozeHelper.getSnoozed(UserHandle.USER_SYSTEM, \"pkg\").size());\n+        // Verify that summary notification was removed from the persisted list\n+        assertThat(mSnoozeHelper.getSnoozeContextForUnpostedNotification(UserHandle.USER_SYSTEM,\n+                \"pkg\", r.getKey())).isNull();\n     }\n \n     @Test\n-- \n2.39.5 (Apple Git-154)\n\n",
    "upstream_commits": [
      "da6a9ea6deece5b2505d5facdf5d44cfc08057f3"
    ],
    "upstream_patch_tokens": {
      "openai": 2611,
      "general": {
        "word_based": 927,
        "char_based": 2659
      },
      "gemini": 3148
    },
    "failures": [
      {
        "downstream_version": "12L",
        "gemini_token_usage": 21833,
        "branch_used": "android12L-release",
        "downstream_patch": "ade22bfdf6698cb97b4edc303e8952d6cc1a2f73",
        "repo_path": "android_repos/base",
        "result": "failure",
        "downstream_patch_content": "commit ade22bfdf6698cb97b4edc303e8952d6cc1a2f73\nAuthor: Valentin Iftime <valiiftime@google.com>\nDate:   Wed Nov 8 11:01:32 2023 +0100\n\n    Enforce persisted snoozed notifications limits\n    \n     Prevent DoS attack that causes boot-looping by serializing a huge amount of snoozed notifications:\n      - Check snooze limits for persisted notifications\n      - Remove persisted group summary notification when in-memory counterpart is removed\n      - Prevent unpriviledged API calls that allow 3P apps to snooze notifications with context/criterion\n    \n    Test: atest SnoozeHelperTest\n    Test: atest NotificationManagerServiceTest\n    Bug: 307948424\n    Bug: 308414141\n    \n    Change-Id: I3571fa9207b778def652130d3ca840183a9a8414\n    (cherry picked from commit 965ff2d3c5487f72a77f6153ed8542cb2621d93c)\n    Merged-In: I3571fa9207b778def652130d3ca840183a9a8414\n\ndiff --git a/services/core/java/com/android/server/notification/SnoozeHelper.java b/services/core/java/com/android/server/notification/SnoozeHelper.java\nindex f3b92eaf6473..966560359b39 100644\n--- a/services/core/java/com/android/server/notification/SnoozeHelper.java\n+++ b/services/core/java/com/android/server/notification/SnoozeHelper.java\n@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()\ndiff --git a/services/tests/uiservicestests/src/com/android/server/notification/SnoozeHelperTest.java b/services/tests/uiservicestests/src/com/android/server/notification/SnoozeHelperTest.java\nindex 883613f6a2b6..c1da6693bc1c 100644\n--- a/services/tests/uiservicestests/src/com/android/server/notification/SnoozeHelperTest.java\n+++ b/services/tests/uiservicestests/src/com/android/server/notification/SnoozeHelperTest.java\n@@ -18,6 +18,8 @@ package com.android.server.notification;\n import static com.android.server.notification.SnoozeHelper.CONCURRENT_SNOOZE_LIMIT;\n import static com.android.server.notification.SnoozeHelper.EXTRA_KEY;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static junit.framework.Assert.assertEquals;\n import static junit.framework.Assert.assertFalse;\n import static junit.framework.Assert.assertNull;\n@@ -76,6 +78,16 @@ import java.util.Collections;\n public class SnoozeHelperTest extends UiServiceTestCase {\n     private static final String TEST_CHANNEL_ID = \"test_channel_id\";\n \n+    private static final String XML_TAG_NAME = \"snoozed-notifications\";\n+    private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n+    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT = \"context\";\n+    private static final String XML_SNOOZED_NOTIFICATION_KEY = \"key\";\n+    private static final String XML_SNOOZED_NOTIFICATION_TIME = \"time\";\n+    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT_ID = \"id\";\n+    private static final String XML_SNOOZED_NOTIFICATION_VERSION_LABEL = \"version\";\n+    private static final String XML_SNOOZED_NOTIFICATION_PKG = \"pkg\";\n+    private static final String XML_SNOOZED_NOTIFICATION_USER_ID = \"user-id\";\n+\n     @Mock SnoozeHelper.Callback mCallback;\n     @Mock AlarmManager mAm;\n     @Mock ManagedServices.UserProfiles mUserProfiles;\n@@ -329,6 +341,56 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n         assertFalse(mSnoozeHelper.canSnooze(1));\n     }\n \n+    @Test\n+    public void testSnoozeLimit_maximumPersisted() throws XmlPullParserException, IOException {\n+        final long snoozeTimeout = 1234;\n+        final String snoozeContext = \"ctx\";\n+        // Serialize & deserialize notifications so that only persisted lists are used\n+        TypedXmlSerializer serializer = Xml.newFastSerializer();\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        serializer.setOutput(new BufferedOutputStream(baos), \"utf-8\");\n+        serializer.startDocument(null, true);\n+        serializer.startTag(null, XML_TAG_NAME);\n+        // Serialize maximum number of timed + context snoozed notifications, half of each\n+        for (int i = 0; i < CONCURRENT_SNOOZE_LIMIT; i++) {\n+            final boolean timedNotification = i % 2 == 0;\n+            if (timedNotification) {\n+                serializer.startTag(null, XML_SNOOZED_NOTIFICATION);\n+            } else {\n+                serializer.startTag(null, XML_SNOOZED_NOTIFICATION_CONTEXT);\n+            }\n+            serializer.attribute(null, XML_SNOOZED_NOTIFICATION_PKG, \"pkg\");\n+            serializer.attributeInt(null, XML_SNOOZED_NOTIFICATION_USER_ID,\n+                UserHandle.USER_SYSTEM);\n+            serializer.attributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL, 1);\n+            serializer.attribute(null, XML_SNOOZED_NOTIFICATION_KEY, \"key\" + i);\n+            if (timedNotification) {\n+                serializer.attributeLong(null, XML_SNOOZED_NOTIFICATION_TIME, snoozeTimeout);\n+                serializer.endTag(null, XML_SNOOZED_NOTIFICATION);\n+            } else {\n+                serializer.attribute(null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID, snoozeContext);\n+                serializer.endTag(null, XML_SNOOZED_NOTIFICATION_CONTEXT);\n+            }\n+        }\n+        serializer.endTag(null, XML_TAG_NAME);\n+        serializer.endDocument();\n+        serializer.flush();\n+\n+        TypedXmlPullParser parser = Xml.newFastPullParser();\n+        parser.setInput(new BufferedInputStream(\n+                new ByteArrayInputStream(baos.toByteArray())), \"utf-8\");\n+        mSnoozeHelper.readXml(parser, 1);\n+        // Verify that we can't snooze any more notifications\n+        //  and that the limit is caused by persisted notifications\n+        assertThat(mSnoozeHelper.canSnooze(1)).isFalse();\n+        assertThat(mSnoozeHelper.isSnoozed(UserHandle.USER_SYSTEM, \"pkg\", \"key0\")).isFalse();\n+        assertThat(mSnoozeHelper.getSnoozeTimeForUnpostedNotification(UserHandle.USER_SYSTEM,\n+                \"pkg\", \"key0\")).isEqualTo(snoozeTimeout);\n+        assertThat(\n+            mSnoozeHelper.getSnoozeContextForUnpostedNotification(UserHandle.USER_SYSTEM, \"pkg\",\n+                \"key1\")).isEqualTo(snoozeContext);\n+    }\n+\n     @Test\n     public void testCancelByApp() throws Exception {\n         NotificationRecord r = getNotificationRecord(\"pkg\", 1, \"one\", UserHandle.SYSTEM);\n@@ -602,6 +664,7 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n \n     @Test\n     public void repostGroupSummary_repostsSummary() throws Exception {\n+        final int snoozeDuration = 1000;\n         IntArray profileIds = new IntArray();\n         profileIds.add(UserHandle.USER_SYSTEM);\n         when(mUserProfiles.getCurrentProfileIds()).thenReturn(profileIds);\n@@ -609,10 +672,44 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n                 \"pkg\", 1, \"one\", UserHandle.SYSTEM, \"group1\", true);\n         NotificationRecord r2 = getNotificationRecord(\n                 \"pkg\", 2, \"two\", UserHandle.SYSTEM, \"group1\", false);\n-        mSnoozeHelper.snooze(r, 1000);\n-        mSnoozeHelper.snooze(r2, 1000);\n+        final long snoozeTime = System.currentTimeMillis() + snoozeDuration;\n+        mSnoozeHelper.snooze(r, snoozeDuration);\n+        mSnoozeHelper.snooze(r2, snoozeDuration);\n+        assertEquals(2, mSnoozeHelper.getSnoozed().size());\n+        assertEquals(2, mSnoozeHelper.getSnoozed(UserHandle.USER_SYSTEM, \"pkg\").size());\n+        // Verify that summary notification was added to the persisted list\n+        assertThat(mSnoozeHelper.getSnoozeTimeForUnpostedNotification(UserHandle.USER_SYSTEM, \"pkg\",\n+                r.getKey())).isAtLeast(snoozeTime);\n+\n+        mSnoozeHelper.repostGroupSummary(\"pkg\", UserHandle.USER_SYSTEM, r.getGroupKey());\n+\n+        verify(mCallback, times(1)).repost(UserHandle.USER_SYSTEM, r, false);\n+        verify(mCallback, never()).repost(UserHandle.USER_SYSTEM, r2, false);\n+\n+        assertEquals(1, mSnoozeHelper.getSnoozed().size());\n+        assertEquals(1, mSnoozeHelper.getSnoozed(UserHandle.USER_SYSTEM, \"pkg\").size());\n+        // Verify that summary notification was removed from the persisted list\n+        assertThat(mSnoozeHelper.getSnoozeTimeForUnpostedNotification(UserHandle.USER_SYSTEM, \"pkg\",\n+                r.getKey())).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void snoozeWithContext_repostGroupSummary_removesPersisted() throws Exception {\n+        final String snoozeContext = \"zzzzz\";\n+        IntArray profileIds = new IntArray();\n+        profileIds.add(UserHandle.USER_SYSTEM);\n+        when(mUserProfiles.getCurrentProfileIds()).thenReturn(profileIds);\n+        NotificationRecord r = getNotificationRecord(\n+                \"pkg\", 1, \"one\", UserHandle.SYSTEM, \"group1\", true);\n+        NotificationRecord r2 = getNotificationRecord(\n+                \"pkg\", 2, \"two\", UserHandle.SYSTEM, \"group1\", false);\n+        mSnoozeHelper.snooze(r, snoozeContext);\n+        mSnoozeHelper.snooze(r2, snoozeContext);\n         assertEquals(2, mSnoozeHelper.getSnoozed().size());\n         assertEquals(2, mSnoozeHelper.getSnoozed(UserHandle.USER_SYSTEM, \"pkg\").size());\n+        // Verify that summary notification was added to the persisted list\n+        assertThat(mSnoozeHelper.getSnoozeContextForUnpostedNotification(UserHandle.USER_SYSTEM,\n+            \"pkg\", r.getKey())).isEqualTo(snoozeContext);\n \n         mSnoozeHelper.repostGroupSummary(\"pkg\", UserHandle.USER_SYSTEM, r.getGroupKey());\n \n@@ -621,6 +718,9 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n \n         assertEquals(1, mSnoozeHelper.getSnoozed().size());\n         assertEquals(1, mSnoozeHelper.getSnoozed(UserHandle.USER_SYSTEM, \"pkg\").size());\n+        // Verify that summary notification was removed from the persisted list\n+        assertThat(mSnoozeHelper.getSnoozeContextForUnpostedNotification(UserHandle.USER_SYSTEM,\n+                \"pkg\", r.getKey())).isNull();\n     }\n \n     @Test\n",
        "downstream_patch_tokens": {
          "openai": 2749,
          "general": {
            "word_based": 964,
            "char_based": 2874
          },
          "gemini": 3335
        },
        "file_conflicts": [
          {
            "file_name": "services/core/java/com/android/server/notification/SnoozeHelper.java",
            "total_hunks": 2,
            "failed_hunks": [
              1,
              2
            ],
            "inline_merge_conflicts": [
              {
                "hunk_number": 1,
                "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n\n=======\n            if ((mSnoozedNotifications.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n                    || (mPersistedSnoozedNotifications.size()\n                    + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n                    > CONCURRENT_SNOOZE_LIMIT) {\n                return false;\n            }\n        }\n>>>>>>> UPSTREAM PATCH (commit da6a9ea6deece5b2505d5facdf5d44cfc08057f3)",
                "merge_conflict_tokens": {
                  "openai": 121,
                  "general": {
                    "word_based": 20,
                    "char_based": 114
                  },
                  "gemini": 133
                }
              }
            ],
            "inline_merge_token_summary": {
              "gemini": 5852,
              "openai": 5445,
              "general_word": 900,
              "general_char": 5130
            },
            "rej_file_content": "```diff\n--- services/core/java/com/android/server/notification/SnoozeHelper.java\n+++ services/core/java/com/android/server/notification/SnoozeHelper.java\n@@ -118,7 +118,10 @@ public final class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mSnoozedNotifications.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mSnoozedNotifications.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                    || (mPersistedSnoozedNotifications.size()\n+                    + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n+                    > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n@@ -343,6 +346,9 @@ public final class SnoozeHelper {\n \n             if (groupSummaryKey != null) {\n                 NotificationRecord record = mSnoozedNotifications.remove(groupSummaryKey);\n+                String trimmedKey = getTrimmedString(groupSummaryKey);\n+                mPersistedSnoozedNotificationsWithContext.remove(trimmedKey);\n+                mPersistedSnoozedNotifications.remove(trimmedKey);\n \n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n```",
            "rej_file_tokens": {
              "openai": 290,
              "general": {
                "word_based": 84,
                "char_based": 314
              },
              "gemini": 329
            },
            "patch_apply_output": "patching file services/core/java/com/android/server/notification/SnoozeHelper.java\nHunk #1 FAILED at 118.\nHunk #2 FAILED at 343.\n2 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/notification/SnoozeHelper.java.rej",
            "inline_merge_output": "patching file services/core/java/com/android/server/notification/SnoozeHelper.java\nHunk #1 NOT MERGED at 121-130.\nHunk #2 already applied at 359-361.",
            "upstream_file_content": "```java\n/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.android.server.notification;\n\nimport android.annotation.NonNull;\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.UserHandle;\nimport android.service.notification.StatusBarNotification;\nimport android.util.ArrayMap;\nimport android.util.IntArray;\nimport android.util.Log;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.server.pm.PackageManagerService;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * NotificationManagerService helper for handling snoozed notifications.\n */\npublic final class SnoozeHelper {\n    public static final int XML_SNOOZED_NOTIFICATION_VERSION = 1;\n\n    static final int CONCURRENT_SNOOZE_LIMIT = 500;\n\n    // A safe size for strings to be put in persistent storage, to avoid breaking the XML write.\n    static final int MAX_STRING_LENGTH = 1000;\n\n    protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n\n    private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT = \"context\";\n    private static final String XML_SNOOZED_NOTIFICATION_KEY = \"key\";\n    //the time the snoozed notification should be reposted\n    private static final String XML_SNOOZED_NOTIFICATION_TIME = \"time\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT_ID = \"id\";\n    private static final String XML_SNOOZED_NOTIFICATION_VERSION_LABEL = \"version\";\n\n\n    private static final String TAG = \"SnoozeHelper\";\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n    private static final String INDENT = \"    \";\n\n    private static final String REPOST_ACTION = SnoozeHelper.class.getSimpleName() + \".EVALUATE\";\n    private static final int REQUEST_CODE_REPOST = 1;\n    private static final String REPOST_SCHEME = \"repost\";\n    static final String EXTRA_KEY = \"key\";\n    private static final String EXTRA_USER_ID = \"userId\";\n\n    private final Context mContext;\n    private AlarmManager mAm;\n    private final ManagedServices.UserProfiles mUserProfiles;\n\n    // notification key : record.\n    private ArrayMap<String, NotificationRecord> mSnoozedNotifications = new ArrayMap<>();\n    // notification key : time-milliseconds .\n    // This member stores persisted snoozed notification trigger times. it persists through reboots\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, Long> mPersistedSnoozedNotifications = new ArrayMap<>();\n    // notification key : creation ID.\n    // This member stores persisted snoozed notification trigger context for the assistant\n    // it persists through reboots.\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, String>\n            mPersistedSnoozedNotificationsWithContext = new ArrayMap<>();\n\n    private Callback mCallback;\n\n    private final Object mLock = new Object();\n\n    public SnoozeHelper(Context context, Callback callback,\n            ManagedServices.UserProfiles userProfiles) {\n        mContext = context;\n        IntentFilter filter = new IntentFilter(REPOST_ACTION);\n        filter.addDataScheme(REPOST_SCHEME);\n        mContext.registerReceiver(mBroadcastReceiver, filter,\n                Context.RECEIVER_EXPORTED_UNAUDITED);\n        mAm = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mCallback = callback;\n        mUserProfiles = userProfiles;\n    }\n\n    protected boolean canSnooze(int numberToSnooze) {\n        synchronized (mLock) {\n            if ((mSnoozedNotifications.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n                    || (mPersistedSnoozedNotifications.size()\n                    + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n                    > CONCURRENT_SNOOZE_LIMIT) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @NonNull\n    protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n        Long time = null;\n        synchronized (mLock) {\n            time = mPersistedSnoozedNotifications.get(getTrimmedString(key));\n        }\n        if (time == null) {\n            time = 0L;\n        }\n        return time;\n    }\n\n    protected String getSnoozeContextForUnpostedNotification(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            return mPersistedSnoozedNotificationsWithContext.get(getTrimmedString(key));\n        }\n    }\n\n    protected boolean isSnoozed(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            return mSnoozedNotifications.containsKey(key);\n        }\n    }\n\n    protected Collection<NotificationRecord> getSnoozed(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayList snoozed = new ArrayList();\n            for (NotificationRecord r : mSnoozedNotifications.values()) {\n                if (r.getUserId() == userId && r.getSbn().getPackageName().equals(pkg)) {\n                    snoozed.add(r);\n                }\n            }\n            return snoozed;\n        }\n    }\n\n    @NonNull\n    ArrayList<NotificationRecord> getNotifications(String pkg,\n            String groupKey, Integer userId) {\n        ArrayList<NotificationRecord> records =  new ArrayList<>();\n        synchronized (mLock) {\n            for (int i = 0; i < mSnoozedNotifications.size(); i++) {\n                NotificationRecord r = mSnoozedNotifications.valueAt(i);\n                if (r.getSbn().getPackageName().equals(pkg) && r.getUserId() == userId\n                        && Objects.equals(r.getSbn().getGroup(), groupKey)) {\n                    records.add(r);\n                }\n            }\n        }\n        return records;\n    }\n\n    protected NotificationRecord getNotification(String key) {\n        synchronized (mLock) {\n            return mSnoozedNotifications.get(key);\n        }\n    }\n\n    protected @NonNull List<NotificationRecord> getSnoozed() {\n        synchronized (mLock) {\n            // caller filters records based on the current user profiles and listener access,\n            // so just return everything\n            List<NotificationRecord> snoozed = new ArrayList<>();\n            snoozed.addAll(mSnoozedNotifications.values());\n            return snoozed;\n        }\n    }\n\n    /**\n     * Snoozes a notification and schedules an alarm to repost at that time.\n     */\n    protected void snooze(NotificationRecord record, long duration) {\n        String key = record.getKey();\n\n        snooze(record);\n        scheduleRepost(key, duration);\n        Long activateAt = System.currentTimeMillis() + duration;\n        synchronized (mLock) {\n            mPersistedSnoozedNotifications.put(getTrimmedString(key), activateAt);\n        }\n    }\n\n    /**\n     * Records a snoozed notification.\n     */\n    protected void snooze(NotificationRecord record, String contextId) {\n        if (contextId != null) {\n            synchronized (mLock) {\n                mPersistedSnoozedNotificationsWithContext.put(\n                        getTrimmedString(record.getKey()),\n                        getTrimmedString(contextId)\n                );\n            }\n        }\n        snooze(record);\n    }\n\n    private void snooze(NotificationRecord record) {\n        if (DEBUG) {\n            Slog.d(TAG, \"Snoozing \" + record.getKey());\n        }\n        synchronized (mLock) {\n            mSnoozedNotifications.put(record.getKey(), record);\n        }\n    }\n\n    private String getTrimmedString(String key) {\n        if (key != null && key.length() > MAX_STRING_LENGTH) {\n            return key.substring(0, MAX_STRING_LENGTH);\n        }\n        return key;\n    }\n\n    protected boolean cancel(int userId, String pkg, String tag, int id) {\n        synchronized (mLock) {\n            final Set<Map.Entry<String, NotificationRecord>> records =\n                    mSnoozedNotifications.entrySet();\n            for (Map.Entry<String, NotificationRecord> record : records) {\n                final StatusBarNotification sbn = record.getValue().getSbn();\n                if (sbn.getPackageName().equals(pkg) && sbn.getUserId() == userId\n                        && Objects.equals(sbn.getTag(), tag) && sbn.getId() == id) {\n                    record.getValue().isCanceled = true;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    protected void cancel(int userId, boolean includeCurrentProfiles) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.size() == 0) {\n                return;\n            }\n            IntArray userIds = new IntArray();\n            userIds.add(userId);\n            if (includeCurrentProfiles) {\n                userIds = mUserProfiles.getCurrentProfileIds();\n            }\n            for (NotificationRecord r : mSnoozedNotifications.values()) {\n                if (userIds.binarySearch(r.getUserId()) >= 0) {\n                    r.isCanceled = true;\n                }\n            }\n        }\n    }\n\n    protected boolean cancel(int userId, String pkg) {\n        synchronized (mLock) {\n            int n = mSnoozedNotifications.size();\n            for (int i = 0; i < n; i++) {\n                final NotificationRecord r = mSnoozedNotifications.valueAt(i);\n                if (r.getSbn().getPackageName().equals(pkg) && r.getUserId() == userId) {\n                    r.isCanceled = true;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Updates the notification record so the most up to date information is shown on re-post.\n     */\n    protected void update(int userId, NotificationRecord record) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.containsKey(record.getKey())) {\n                mSnoozedNotifications.put(record.getKey(), record);\n            }\n        }\n    }\n\n    protected void repost(String key, boolean muteOnReturn) {\n        synchronized (mLock) {\n            final NotificationRecord r = mSnoozedNotifications.get(key);\n            if (r != null) {\n                repost(key, r.getUserId(), muteOnReturn);\n            }\n        }\n    }\n\n    protected void repost(String key, int userId, boolean muteOnReturn) {\n        final String trimmedKey = getTrimmedString(key);\n\n        NotificationRecord record;\n        synchronized (mLock) {\n            mPersistedSnoozedNotifications.remove(trimmedKey);\n            mPersistedSnoozedNotificationsWithContext.remove(trimmedKey);\n            record = mSnoozedNotifications.remove(key);\n        }\n\n        if (record != null && !record.isCanceled) {\n            final PendingIntent pi = createPendingIntent(record.getKey());\n            mAm.cancel(pi);\n            MetricsLogger.action(record.getLogMaker()\n                    .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                    .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n            mCallback.repost(record.getUserId(), record, muteOnReturn);\n        }\n    }\n\n    protected void repostGroupSummary(String pkg, int userId, String groupKey) {\n        synchronized (mLock) {\n            String groupSummaryKey = null;\n            int n = mSnoozedNotifications.size();\n            for (int i = 0; i < n; i++) {\n                final NotificationRecord potentialGroupSummary = mSnoozedNotifications.valueAt(i);\n                if (potentialGroupSummary.getSbn().getPackageName().equals(pkg)\n                        && potentialGroupSummary.getUserId() == userId\n                        && potentialGroupSummary.getSbn().isGroup()\n                        && potentialGroupSummary.getNotification().isGroupSummary()\n                        && groupKey.equals(potentialGroupSummary.getGroupKey())) {\n                    groupSummaryKey = potentialGroupSummary.getKey();\n                    break;\n                }\n            }\n\n            if (groupSummaryKey != null) {\n                NotificationRecord record = mSnoozedNotifications.remove(groupSummaryKey);\n                String trimmedKey = getTrimmedString(groupSummaryKey);\n                mPersistedSnoozedNotificationsWithContext.remove(trimmedKey);\n                mPersistedSnoozedNotifications.remove(trimmedKey);\n\n                if (record != null && !record.isCanceled) {\n                    Runnable runnable = () -> {\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n                        mCallback.repost(record.getUserId(), record, false);\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    protected void clearData(int userId, String pkg) {\n        synchronized (mLock) {\n            int n = mSnoozedNotifications.size();\n            for (int i = n - 1; i >= 0; i--) {\n                final NotificationRecord record = mSnoozedNotifications.valueAt(i);\n                if (record.getUserId() == userId && record.getSbn().getPackageName().equals(pkg)) {\n                    mSnoozedNotifications.removeAt(i);\n                    String trimmedKey = getTrimmedString(record.getKey());\n                    mPersistedSnoozedNotificationsWithContext.remove(trimmedKey);\n                    mPersistedSnoozedNotifications.remove(trimmedKey);\n                    Runnable runnable = () -> {\n                        final PendingIntent pi = createPendingIntent(record.getKey());\n                        mAm.cancel(pi);\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_DISMISS));\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    protected void clearData(int userId) {\n        synchronized (mLock) {\n            int n = mSnoozedNotifications.size();\n            for (int i = n - 1; i >= 0; i--) {\n                final NotificationRecord record = mSnoozedNotifications.valueAt(i);\n                if (record.getUserId() == userId) {\n                    mSnoozedNotifications.removeAt(i);\n                    String trimmedKey = getTrimmedString(record.getKey());\n                    mPersistedSnoozedNotificationsWithContext.remove(trimmedKey);\n                    mPersistedSnoozedNotifications.remove(trimmedKey);\n\n                    Runnable runnable = () -> {\n                        final PendingIntent pi = createPendingIntent(record.getKey());\n                        mAm.cancel(pi);\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_DISMISS));\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    private PendingIntent createPendingIntent(String key) {\n        return PendingIntent.getBroadcast(mContext,\n                REQUEST_CODE_REPOST,\n                new Intent(REPOST_ACTION)\n                        .setPackage(PackageManagerService.PLATFORM_PACKAGE_NAME)\n                        .setData(new Uri.Builder().scheme(REPOST_SCHEME).appendPath(key).build())\n                        .addFlags(Intent.FLAG_RECEIVER_FOREGROUND)\n                        .putExtra(EXTRA_KEY, key),\n                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n    }\n\n    public void scheduleRepostsForPersistedNotifications(long currentTime) {\n        synchronized (mLock) {\n            for (int i = 0; i < mPersistedSnoozedNotifications.size(); i++) {\n                String key = mPersistedSnoozedNotifications.keyAt(i);\n                Long time = mPersistedSnoozedNotifications.valueAt(i);\n                if (time != null && time > currentTime) {\n                    scheduleRepostAtTime(key, time);\n                }\n            }\n        }\n    }\n\n    private void scheduleRepost(String key, long duration) {\n        scheduleRepostAtTime(key, System.currentTimeMillis() + duration);\n    }\n\n    private void scheduleRepostAtTime(String key, long time) {\n        Runnable runnable = () -> {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final PendingIntent pi = createPendingIntent(key);\n                mAm.cancel(pi);\n                if (DEBUG) Slog.d(TAG, \"Scheduling evaluate for \" + new Date(time));\n                mAm.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pi);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        };\n        runnable.run();\n    }\n\n    public void dump(PrintWriter pw, NotificationManagerService.DumpFilter filter) {\n        synchronized (mLock) {\n            pw.println(\"\\n  Snoozed notifications:\");\n            for (String key : mSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + key);\n            }\n            pw.println(\"\\n Pending snoozed notifications\");\n            for (String key : mPersistedSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + key + \" until: \" + mPersistedSnoozedNotifications.get(key));\n            }\n        }\n    }\n\n    protected void writeXml(TypedXmlSerializer out) throws IOException {\n        synchronized (mLock) {\n            final long currentTime = System.currentTimeMillis();\n            out.startTag(null, XML_TAG_NAME);\n            writeXml(out, mPersistedSnoozedNotifications, XML_SNOOZED_NOTIFICATION,\n                    value -> {\n                        if (value < currentTime) {\n                            return;\n                        }\n                        out.attributeLong(null, XML_SNOOZED_NOTIFICATION_TIME,\n                                value);\n                    });\n            writeXml(out, mPersistedSnoozedNotificationsWithContext,\n                    XML_SNOOZED_NOTIFICATION_CONTEXT,\n                    value -> {\n                        out.attribute(null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID,\n                                value);\n                    });\n            out.endTag(null, XML_TAG_NAME);\n        }\n    }\n\n    private interface Inserter<T> {\n        void insert(T t) throws IOException;\n    }\n\n    private <T> void writeXml(TypedXmlSerializer out, ArrayMap<String, T> targets, String tag,\n            Inserter<T> attributeInserter) throws IOException {\n        for (int j = 0; j < targets.size(); j++) {\n            String key = targets.keyAt(j);\n            // T is a String (snoozed until context) or Long (snoozed until time)\n            T value = targets.valueAt(j);\n\n            out.startTag(null, tag);\n\n            attributeInserter.insert(value);\n\n            out.attributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL,\n                    XML_SNOOZED_NOTIFICATION_VERSION);\n            out.attribute(null, XML_SNOOZED_NOTIFICATION_KEY, key);\n\n            out.endTag(null, tag);\n        }\n    }\n\n    protected void readXml(TypedXmlPullParser parser, long currentTime)\n            throws XmlPullParserException, IOException {\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {\n            String tag = parser.getName();\n            if (type == XmlPullParser.END_TAG\n                    && XML_TAG_NAME.equals(tag)) {\n                break;\n            }\n            if (type == XmlPullParser.START_TAG\n                    && (XML_SNOOZED_NOTIFICATION.equals(tag)\n                        || tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT))\n                    && parser.getAttributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL, -1)\n                        == XML_SNOOZED_NOTIFICATION_VERSION) {\n                try {\n                    final String key = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_KEY);\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION)) {\n                        final Long time = parser.getAttributeLong(\n                                null, XML_SNOOZED_NOTIFICATION_TIME, 0);\n                        if (time > currentTime) { //only read new stuff\n                            synchronized (mLock) {\n                                mPersistedSnoozedNotifications.put(key, time);\n                            }\n                        }\n                    }\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT)) {\n                        final String creationId = parser.getAttributeValue(\n                                null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID);\n                        synchronized (mLock) {\n                            mPersistedSnoozedNotificationsWithContext.put(key, creationId);\n                        }\n                    }\n                } catch (Exception e) {\n                    Slog.e(TAG,  \"Exception in reading snooze data from policy xml\", e);\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void setAlarmManager(AlarmManager am) {\n        mAm = am;\n    }\n\n    protected interface Callback {\n        void repost(int userId, NotificationRecord r, boolean muteOnReturn);\n    }\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (DEBUG) {\n                Slog.d(TAG, \"Reposting notification\");\n            }\n            if (REPOST_ACTION.equals(intent.getAction())) {\n                repost(intent.getStringExtra(EXTRA_KEY), intent.getIntExtra(EXTRA_USER_ID,\n                        UserHandle.USER_SYSTEM), false);\n            }\n        }\n    };\n}\n```",
            "upstream_file_tokens": {
              "openai": 4582,
              "general": {
                "word_based": 1807,
                "char_based": 5787
              },
              "gemini": 5452
            },
            "downstream_file_content": "```java\n/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.android.server.notification;\n\nimport android.annotation.NonNull;\nimport android.annotation.UserIdInt;\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.service.notification.StatusBarNotification;\nimport android.util.ArrayMap;\nimport android.util.IntArray;\nimport android.util.Log;\nimport android.util.Slog;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto;\nimport com.android.internal.util.XmlUtils;\nimport com.android.server.pm.PackageManagerService;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * NotificationManagerService helper for handling snoozed notifications.\n */\npublic class SnoozeHelper {\n    public static final int XML_SNOOZED_NOTIFICATION_VERSION = 1;\n\n    static final int CONCURRENT_SNOOZE_LIMIT = 500;\n\n    // A safe size for strings to be put in persistent storage, to avoid breaking the XML write.\n    static final int MAX_STRING_LENGTH = 1000;\n\n    protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n\n    private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT = \"context\";\n    private static final String XML_SNOOZED_NOTIFICATION_PKG = \"pkg\";\n    private static final String XML_SNOOZED_NOTIFICATION_USER_ID = \"user-id\";\n    private static final String XML_SNOOZED_NOTIFICATION_KEY = \"key\";\n    //the time the snoozed notification should be reposted\n    private static final String XML_SNOOZED_NOTIFICATION_TIME = \"time\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT_ID = \"id\";\n    private static final String XML_SNOOZED_NOTIFICATION_VERSION_LABEL = \"version\";\n\n\n    private static final String TAG = \"SnoozeHelper\";\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n    private static final String INDENT = \"    \";\n\n    private static final String REPOST_ACTION = SnoozeHelper.class.getSimpleName() + \".EVALUATE\";\n    private static final int REQUEST_CODE_REPOST = 1;\n    private static final String REPOST_SCHEME = \"repost\";\n    static final String EXTRA_KEY = \"key\";\n    private static final String EXTRA_USER_ID = \"userId\";\n\n    private final Context mContext;\n    private AlarmManager mAm;\n    private final ManagedServices.UserProfiles mUserProfiles;\n\n    // User id | package name : notification key : record.\n    private ArrayMap<String, ArrayMap<String, NotificationRecord>>\n            mSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : time-milliseconds .\n    // This member stores persisted snoozed notification trigger times. it persists through reboots\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, Long>>\n            mPersistedSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : creation ID .\n    // This member stores persisted snoozed notification trigger context for the assistant\n    // it persists through reboots.\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, String>>\n            mPersistedSnoozedNotificationsWithContext = new ArrayMap<>();\n    // notification key : package.\n    private ArrayMap<String, String> mPackages = new ArrayMap<>();\n    // key : userId\n    private ArrayMap<String, Integer> mUsers = new ArrayMap<>();\n    private Callback mCallback;\n\n    private final Object mLock = new Object();\n\n    public SnoozeHelper(Context context, Callback callback,\n            ManagedServices.UserProfiles userProfiles) {\n        mContext = context;\n        IntentFilter filter = new IntentFilter(REPOST_ACTION);\n        filter.addDataScheme(REPOST_SCHEME);\n        mContext.registerReceiver(mBroadcastReceiver, filter);\n        mAm = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mCallback = callback;\n        mUserProfiles = userProfiles;\n    }\n\n    private String getPkgKey(@UserIdInt int userId, String pkg) {\n        return userId + \"|\" + pkg;\n    }\n\n    void cleanupPersistedContext(String key){\n        synchronized (mLock) {\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            removeRecordLocked(pkg, key, userId, mPersistedSnoozedNotificationsWithContext);\n        }\n    }\n\n    protected boolean canSnooze(int numberToSnooze) {\n        synchronized (mLock) {\n            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @NonNull\n    protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n        Long time = null;\n        synchronized (mLock) {\n           ArrayMap<String, Long> snoozed =\n                   mPersistedSnoozedNotifications.get(getPkgKey(userId, pkg));\n           if (snoozed != null) {\n               time = snoozed.get(getTrimmedString(key));\n           }\n        }\n        if (time == null) {\n            time = 0L;\n        }\n        return time;\n    }\n\n    protected String getSnoozeContextForUnpostedNotification(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            ArrayMap<String, String> snoozed =\n                    mPersistedSnoozedNotificationsWithContext.get(getPkgKey(userId, pkg));\n            if (snoozed != null) {\n                return snoozed.get(getTrimmedString(key));\n            }\n        }\n        return null;\n    }\n\n    protected boolean isSnoozed(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            return mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))\n                    && mSnoozedNotifications.get(getPkgKey(userId, pkg)).containsKey(key);\n        }\n    }\n\n    protected Collection<NotificationRecord> getSnoozed(int userId, String pkg) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))) {\n                return mSnoozedNotifications.get(getPkgKey(userId, pkg)).values();\n            }\n        }\n        return Collections.EMPTY_LIST;\n    }\n\n    @NonNull\n    ArrayList<NotificationRecord> getNotifications(String pkg,\n            String groupKey, Integer userId) {\n        ArrayList<NotificationRecord> records =  new ArrayList<>();\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> allRecords =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (allRecords != null) {\n                for (int i = 0; i < allRecords.size(); i++) {\n                    NotificationRecord r = allRecords.valueAt(i);\n                    String currentGroupKey = r.getSbn().getGroup();\n                    if (Objects.equals(currentGroupKey, groupKey)) {\n                        records.add(r);\n                    }\n                }\n            }\n        }\n        return records;\n    }\n\n    protected NotificationRecord getNotification(String key) {\n        synchronized (mLock) {\n            if (!mUsers.containsKey(key) || !mPackages.containsKey(key)) {\n                Slog.w(TAG, \"Snoozed data sets no longer agree for \" + key);\n                return null;\n            }\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            ArrayMap<String, NotificationRecord> snoozed =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (snoozed == null) {\n                return null;\n            }\n            return snoozed.get(key);\n        }\n    }\n\n    protected @NonNull List<NotificationRecord> getSnoozed() {\n        synchronized (mLock) {\n            // caller filters records based on the current user profiles and listener access, so just\n            // return everything\n            List<NotificationRecord> snoozed = new ArrayList<>();\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                snoozed.addAll(snoozedRecords.values());\n            }\n            return snoozed;\n        }\n    }\n\n    /**\n     * Snoozes a notification and schedules an alarm to repost at that time.\n     */\n    protected void snooze(NotificationRecord record, long duration) {\n        String pkg = record.getSbn().getPackageName();\n        String key = record.getKey();\n        int userId = record.getUser().getIdentifier();\n\n        snooze(record);\n        scheduleRepost(pkg, key, userId, duration);\n        Long activateAt = System.currentTimeMillis() + duration;\n        synchronized (mLock) {\n            storeRecordLocked(pkg, getTrimmedString(key), userId, mPersistedSnoozedNotifications,\n                    activateAt);\n        }\n    }\n\n    /**\n     * Records a snoozed notification.\n     */\n    protected void snooze(NotificationRecord record, String contextId) {\n        int userId = record.getUser().getIdentifier();\n        if (contextId != null) {\n            synchronized (mLock) {\n                storeRecordLocked(record.getSbn().getPackageName(),\n                        getTrimmedString(record.getKey()),\n                        userId, mPersistedSnoozedNotificationsWithContext,\n                        getTrimmedString(contextId));\n            }\n        }\n        snooze(record);\n    }\n\n    private void snooze(NotificationRecord record) {\n        int userId = record.getUser().getIdentifier();\n        if (DEBUG) {\n            Slog.d(TAG, \"Snoozing \" + record.getKey());\n        }\n        synchronized (mLock) {\n            storeRecordLocked(record.getSbn().getPackageName(), record.getKey(),\n                    userId, mSnoozedNotifications, record);\n        }\n    }\n\n    private String getTrimmedString(String key) {\n        if (key != null && key.length() > MAX_STRING_LENGTH) {\n            return key.substring(0, MAX_STRING_LENGTH);\n        }\n        return key;\n    }\n\n    private <T> void storeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets, T object) {\n\n        mPackages.put(key, pkg);\n        mUsers.put(key, userId);\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            keyToValue = new ArrayMap<>();\n        }\n        keyToValue.put(key, object);\n        targets.put(getPkgKey(userId, pkg), keyToValue);\n    }\n\n    private <T> T removeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets) {\n        T object = null;\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            return null;\n        }\n        object = keyToValue.remove(key);\n        if (keyToValue.size() == 0) {\n            targets.remove(getPkgKey(userId, pkg));\n        }\n        return object;\n    }\n\n    protected boolean cancel(int userId, String pkg, String tag, int id) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsForPkg =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsForPkg != null) {\n                final Set<Map.Entry<String, NotificationRecord>> records = recordsForPkg.entrySet();\n                for (Map.Entry<String, NotificationRecord> record : records) {\n                    final StatusBarNotification sbn = record.getValue().getSbn();\n                    if (Objects.equals(sbn.getTag(), tag) && sbn.getId() == id) {\n                        record.getValue().isCanceled = true;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    protected void cancel(int userId, boolean includeCurrentProfiles) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.size() == 0) {\n                return;\n            }\n            IntArray userIds = new IntArray();\n            userIds.add(userId);\n            if (includeCurrentProfiles) {\n                userIds = mUserProfiles.getCurrentProfileIds();\n            }\n            for (ArrayMap<String, NotificationRecord> snoozedRecords : mSnoozedNotifications.values()) {\n                for (NotificationRecord r : snoozedRecords.values()) {\n                    if (userIds.binarySearch(r.getUserId()) >= 0) {\n                        r.isCanceled = true;\n                    }\n                }\n            }\n        }\n    }\n\n    protected boolean cancel(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return false;\n            }\n            int N = records.size();\n            for (int i = 0; i < N; i++) {\n                records.valueAt(i).isCanceled = true;\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Updates the notification record so the most up to date information is shown on re-post.\n     */\n    protected void update(int userId, NotificationRecord record) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, record.getSbn().getPackageName()));\n            if (records == null) {\n                return;\n            }\n            records.put(record.getKey(), record);\n        }\n    }\n\n    protected void repost(String key, boolean muteOnReturn) {\n        synchronized (mLock) {\n            Integer userId = mUsers.get(key);\n            if (userId != null) {\n                repost(key, userId, muteOnReturn);\n            }\n        }\n    }\n\n    protected void repost(String key, int userId, boolean muteOnReturn) {\n        final String trimmedKey = getTrimmedString(key);\n\n        NotificationRecord record;\n        synchronized (mLock) {\n            final String pkg = mPackages.remove(key);\n            mUsers.remove(key);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            record = records.remove(key);\n\n        }\n\n        if (record != null && !record.isCanceled) {\n            final PendingIntent pi = createPendingIntent(\n                    record.getSbn().getPackageName(), record.getKey(), userId);\n            mAm.cancel(pi);\n            MetricsLogger.action(record.getLogMaker()\n                    .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                    .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n            mCallback.repost(userId, record, muteOnReturn);\n        }\n    }\n\n    protected void repostGroupSummary(String pkg, int userId, String groupKey) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsByKey\n                    = mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsByKey == null) {\n                return;\n            }\n\n            String groupSummaryKey = null;\n            int N = recordsByKey.size();\n            for (int i = 0; i < N; i++) {\n                final NotificationRecord potentialGroupSummary = recordsByKey.valueAt(i);\n                if (potentialGroupSummary.getSbn().isGroup()\n                        && potentialGroupSummary.getNotification().isGroupSummary()\n                        && groupKey.equals(potentialGroupSummary.getGroupKey())) {\n                    groupSummaryKey = potentialGroupSummary.getKey();\n                    break;\n                }\n            }\n\n            if (groupSummaryKey != null) {\n                NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                mPackages.remove(groupSummaryKey);\n                mUsers.remove(groupSummaryKey);\n\n                if (record != null && !record.isCanceled) {\n                    Runnable runnable = () -> {\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n                        mCallback.repost(userId, record, false);\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    protected void clearData(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            for (int i = records.size() - 1; i >= 0; i--) {\n                final NotificationRecord r = records.removeAt(i);\n                if (r != null) {\n                    mPackages.remove(r.getKey());\n                    mUsers.remove(r.getKey());\n                    Runnable runnable = () -> {\n                        final PendingIntent pi = createPendingIntent(pkg, r.getKey(), userId);\n                        mAm.cancel(pi);\n                        MetricsLogger.action(r.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_DISMISS));\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    private PendingIntent createPendingIntent(String pkg, String key, int userId) {\n        return PendingIntent.getBroadcast(mContext,\n                REQUEST_CODE_REPOST,\n                new Intent(REPOST_ACTION)\n                        .setPackage(PackageManagerService.PLATFORM_PACKAGE_NAME)\n                        .setData(new Uri.Builder().scheme(REPOST_SCHEME).appendPath(key).build())\n                        .addFlags(Intent.FLAG_RECEIVER_FOREGROUND)\n                        .putExtra(EXTRA_KEY, key)\n                        .putExtra(EXTRA_USER_ID, userId),\n                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n    }\n\n    public void scheduleRepostsForPersistedNotifications(long currentTime) {\n        synchronized (mLock) {\n            for (ArrayMap<String, Long> snoozed : mPersistedSnoozedNotifications.values()) {\n                for (int i = 0; i < snoozed.size(); i++) {\n                    String key = snoozed.keyAt(i);\n                    Long time = snoozed.valueAt(i);\n                    String pkg = mPackages.get(key);\n                    Integer userId = mUsers.get(key);\n                    if (time == null || pkg == null || userId == null) {\n                        Slog.w(TAG, \"data out of sync: \" + time + \"|\" + pkg + \"|\" + userId);\n                        continue;\n                    }\n                    if (time != null && time > currentTime) {\n                        scheduleRepostAtTime(pkg, key, userId, time);\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleRepost(String pkg, String key, int userId, long duration) {\n        scheduleRepostAtTime(pkg, key, userId, System.currentTimeMillis() + duration);\n    }\n\n    private void scheduleRepostAtTime(String pkg, String key, int userId, long time) {\n        Runnable runnable = () -> {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final PendingIntent pi = createPendingIntent(pkg, key, userId);\n                mAm.cancel(pi);\n                if (DEBUG) Slog.d(TAG, \"Scheduling evaluate for \" + new Date(time));\n                mAm.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pi);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        };\n        runnable.run();\n    }\n\n    public void dump(PrintWriter pw, NotificationManagerService.DumpFilter filter) {\n        synchronized (mLock) {\n            pw.println(\"\\n  Snoozed notifications:\");\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.println(key);\n                }\n            }\n            pw.println(\"\\n Pending snoozed notifications\");\n            for (String userPkgKey : mPersistedSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, Long> snoozedRecords =\n                        mPersistedSnoozedNotifications.get(userPkgKey);\n                if (snoozedRecords == null) {\n                    continue;\n                }\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(key);\n                    pw.print(INDENT);\n                    pw.println(snoozedRecords.get(key));\n                }\n            }\n        }\n    }\n\n    protected void writeXml(TypedXmlSerializer out) throws IOException {\n        synchronized (mLock) {\n            final long currentTime = System.currentTimeMillis();\n            out.startTag(null, XML_TAG_NAME);\n            writeXml(out, mPersistedSnoozedNotifications, XML_SNOOZED_NOTIFICATION,\n                    value -> {\n                        if (value < currentTime) {\n                            return;\n                        }\n                        out.attributeLong(null, XML_SNOOZED_NOTIFICATION_TIME,\n                                value);\n                    });\n            writeXml(out, mPersistedSnoozedNotificationsWithContext,\n                    XML_SNOOZED_NOTIFICATION_CONTEXT,\n                    value -> {\n                        out.attribute(null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID,\n                                value);\n                    });\n            out.endTag(null, XML_TAG_NAME);\n        }\n    }\n\n    private interface Inserter<T> {\n        void insert(T t) throws IOException;\n    }\n\n    private <T> void writeXml(TypedXmlSerializer out,\n            ArrayMap<String, ArrayMap<String, T>> targets, String tag,\n            Inserter<T> attributeInserter)\n            throws IOException {\n        final int M = targets.size();\n        for (int i = 0; i < M; i++) {\n            // T is a String (snoozed until context) or Long (snoozed until time)\n            ArrayMap<String, T> keyToValue = targets.valueAt(i);\n            for (int j = 0; j < keyToValue.size(); j++) {\n                String key = keyToValue.keyAt(j);\n                T value = keyToValue.valueAt(j);\n                String pkg = mPackages.get(key);\n                Integer userId = mUsers.get(key);\n\n                if (pkg == null || userId == null) {\n                    Slog.w(TAG, \"pkg \" + pkg + \" or user \" + userId + \" missing for \" + key);\n                    continue;\n                }\n\n                out.startTag(null, tag);\n\n                attributeInserter.insert(value);\n\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL,\n                        XML_SNOOZED_NOTIFICATION_VERSION);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_KEY, key);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_PKG, pkg);\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_USER_ID, userId);\n\n                out.endTag(null, tag);\n            }\n        }\n    }\n\n    protected void readXml(TypedXmlPullParser parser, long currentTime)\n            throws XmlPullParserException, IOException {\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {\n            String tag = parser.getName();\n            if (type == XmlPullParser.END_TAG\n                    && XML_TAG_NAME.equals(tag)) {\n                break;\n            }\n            if (type == XmlPullParser.START_TAG\n                    && (XML_SNOOZED_NOTIFICATION.equals(tag)\n                        || tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT))\n                    && parser.getAttributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL, -1)\n                        == XML_SNOOZED_NOTIFICATION_VERSION) {\n                try {\n                    final String key = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_KEY);\n                    final String pkg = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_PKG);\n                    final int userId = parser.getAttributeInt(\n                            null, XML_SNOOZED_NOTIFICATION_USER_ID, UserHandle.USER_ALL);\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION)) {\n                        final Long time = parser.getAttributeLong(\n                                null, XML_SNOOZED_NOTIFICATION_TIME, 0);\n                        if (time > currentTime) { //only read new stuff\n                            synchronized (mLock) {\n                                storeRecordLocked(\n                                        pkg, key, userId, mPersistedSnoozedNotifications, time);\n                            }\n                        }\n                    }\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT)) {\n                        final String creationId = parser.getAttributeValue(\n                                null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID);\n                        synchronized (mLock) {\n                            storeRecordLocked(\n                                    pkg, key, userId, mPersistedSnoozedNotificationsWithContext,\n                                    creationId);\n                        }\n                    }\n                } catch (Exception e) {\n                    Slog.e(TAG,  \"Exception in reading snooze data from policy xml\", e);\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void setAlarmManager(AlarmManager am) {\n        mAm = am;\n    }\n\n    protected interface Callback {\n        void repost(int userId, NotificationRecord r, boolean muteOnReturn);\n    }\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (DEBUG) {\n                Slog.d(TAG, \"Reposting notification\");\n            }\n            if (REPOST_ACTION.equals(intent.getAction())) {\n                repost(intent.getStringExtra(EXTRA_KEY), intent.getIntExtra(EXTRA_USER_ID,\n                        UserHandle.USER_SYSTEM), false);\n            }\n        }\n    };\n}\n```",
            "downstream_file_tokens": {
              "openai": 5729,
              "general": {
                "word_based": 2301,
                "char_based": 7141
              },
              "gemini": 6865
            },
            "downstream_file_content_ground_truth": "/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.android.server.notification;\n\nimport android.annotation.NonNull;\nimport android.annotation.UserIdInt;\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.service.notification.StatusBarNotification;\nimport android.util.ArrayMap;\nimport android.util.IntArray;\nimport android.util.Log;\nimport android.util.Slog;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto;\nimport com.android.internal.util.XmlUtils;\nimport com.android.server.pm.PackageManagerService;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * NotificationManagerService helper for handling snoozed notifications.\n */\npublic class SnoozeHelper {\n    public static final int XML_SNOOZED_NOTIFICATION_VERSION = 1;\n\n    static final int CONCURRENT_SNOOZE_LIMIT = 500;\n\n    // A safe size for strings to be put in persistent storage, to avoid breaking the XML write.\n    static final int MAX_STRING_LENGTH = 1000;\n\n    protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n\n    private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT = \"context\";\n    private static final String XML_SNOOZED_NOTIFICATION_PKG = \"pkg\";\n    private static final String XML_SNOOZED_NOTIFICATION_USER_ID = \"user-id\";\n    private static final String XML_SNOOZED_NOTIFICATION_KEY = \"key\";\n    //the time the snoozed notification should be reposted\n    private static final String XML_SNOOZED_NOTIFICATION_TIME = \"time\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT_ID = \"id\";\n    private static final String XML_SNOOZED_NOTIFICATION_VERSION_LABEL = \"version\";\n\n\n    private static final String TAG = \"SnoozeHelper\";\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n    private static final String INDENT = \"    \";\n\n    private static final String REPOST_ACTION = SnoozeHelper.class.getSimpleName() + \".EVALUATE\";\n    private static final int REQUEST_CODE_REPOST = 1;\n    private static final String REPOST_SCHEME = \"repost\";\n    static final String EXTRA_KEY = \"key\";\n    private static final String EXTRA_USER_ID = \"userId\";\n\n    private final Context mContext;\n    private AlarmManager mAm;\n    private final ManagedServices.UserProfiles mUserProfiles;\n\n    // User id | package name : notification key : record.\n    private ArrayMap<String, ArrayMap<String, NotificationRecord>>\n            mSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : time-milliseconds .\n    // This member stores persisted snoozed notification trigger times. it persists through reboots\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, Long>>\n            mPersistedSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : creation ID .\n    // This member stores persisted snoozed notification trigger context for the assistant\n    // it persists through reboots.\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, String>>\n            mPersistedSnoozedNotificationsWithContext = new ArrayMap<>();\n    // notification key : package.\n    private ArrayMap<String, String> mPackages = new ArrayMap<>();\n    // key : userId\n    private ArrayMap<String, Integer> mUsers = new ArrayMap<>();\n    private Callback mCallback;\n\n    private final Object mLock = new Object();\n\n    public SnoozeHelper(Context context, Callback callback,\n            ManagedServices.UserProfiles userProfiles) {\n        mContext = context;\n        IntentFilter filter = new IntentFilter(REPOST_ACTION);\n        filter.addDataScheme(REPOST_SCHEME);\n        mContext.registerReceiver(mBroadcastReceiver, filter);\n        mAm = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mCallback = callback;\n        mUserProfiles = userProfiles;\n    }\n\n    private String getPkgKey(@UserIdInt int userId, String pkg) {\n        return userId + \"|\" + pkg;\n    }\n\n    void cleanupPersistedContext(String key){\n        synchronized (mLock) {\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            removeRecordLocked(pkg, key, userId, mPersistedSnoozedNotificationsWithContext);\n        }\n    }\n\n    protected boolean canSnooze(int numberToSnooze) {\n        synchronized (mLock) {\n            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n                || (countPersistedNotificationsLocked() + numberToSnooze)\n                > CONCURRENT_SNOOZE_LIMIT) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int countPersistedNotificationsLocked() {\n        int numNotifications = 0;\n        for (ArrayMap<String, String> persistedWithContext :\n                mPersistedSnoozedNotificationsWithContext.values()) {\n            numNotifications += persistedWithContext.size();\n        }\n        for (ArrayMap<String, Long> persistedWithDuration :\n                mPersistedSnoozedNotifications.values()) {\n            numNotifications += persistedWithDuration.size();\n        }\n        return numNotifications;\n    }\n\n\n    @NonNull\n    protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n        Long time = null;\n        synchronized (mLock) {\n           ArrayMap<String, Long> snoozed =\n                   mPersistedSnoozedNotifications.get(getPkgKey(userId, pkg));\n           if (snoozed != null) {\n               time = snoozed.get(getTrimmedString(key));\n           }\n        }\n        if (time == null) {\n            time = 0L;\n        }\n        return time;\n    }\n\n    protected String getSnoozeContextForUnpostedNotification(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            ArrayMap<String, String> snoozed =\n                    mPersistedSnoozedNotificationsWithContext.get(getPkgKey(userId, pkg));\n            if (snoozed != null) {\n                return snoozed.get(getTrimmedString(key));\n            }\n        }\n        return null;\n    }\n\n    protected boolean isSnoozed(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            return mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))\n                    && mSnoozedNotifications.get(getPkgKey(userId, pkg)).containsKey(key);\n        }\n    }\n\n    protected Collection<NotificationRecord> getSnoozed(int userId, String pkg) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))) {\n                return mSnoozedNotifications.get(getPkgKey(userId, pkg)).values();\n            }\n        }\n        return Collections.EMPTY_LIST;\n    }\n\n    @NonNull\n    ArrayList<NotificationRecord> getNotifications(String pkg,\n            String groupKey, Integer userId) {\n        ArrayList<NotificationRecord> records =  new ArrayList<>();\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> allRecords =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (allRecords != null) {\n                for (int i = 0; i < allRecords.size(); i++) {\n                    NotificationRecord r = allRecords.valueAt(i);\n                    String currentGroupKey = r.getSbn().getGroup();\n                    if (Objects.equals(currentGroupKey, groupKey)) {\n                        records.add(r);\n                    }\n                }\n            }\n        }\n        return records;\n    }\n\n    protected NotificationRecord getNotification(String key) {\n        synchronized (mLock) {\n            if (!mUsers.containsKey(key) || !mPackages.containsKey(key)) {\n                Slog.w(TAG, \"Snoozed data sets no longer agree for \" + key);\n                return null;\n            }\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            ArrayMap<String, NotificationRecord> snoozed =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (snoozed == null) {\n                return null;\n            }\n            return snoozed.get(key);\n        }\n    }\n\n    protected @NonNull List<NotificationRecord> getSnoozed() {\n        synchronized (mLock) {\n            // caller filters records based on the current user profiles and listener access, so just\n            // return everything\n            List<NotificationRecord> snoozed = new ArrayList<>();\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                snoozed.addAll(snoozedRecords.values());\n            }\n            return snoozed;\n        }\n    }\n\n    /**\n     * Snoozes a notification and schedules an alarm to repost at that time.\n     */\n    protected void snooze(NotificationRecord record, long duration) {\n        String pkg = record.getSbn().getPackageName();\n        String key = record.getKey();\n        int userId = record.getUser().getIdentifier();\n\n        snooze(record);\n        scheduleRepost(pkg, key, userId, duration);\n        Long activateAt = System.currentTimeMillis() + duration;\n        synchronized (mLock) {\n            storeRecordLocked(pkg, getTrimmedString(key), userId, mPersistedSnoozedNotifications,\n                    activateAt);\n        }\n    }\n\n    /**\n     * Records a snoozed notification.\n     */\n    protected void snooze(NotificationRecord record, String contextId) {\n        int userId = record.getUser().getIdentifier();\n        if (contextId != null) {\n            synchronized (mLock) {\n                storeRecordLocked(record.getSbn().getPackageName(),\n                        getTrimmedString(record.getKey()),\n                        userId, mPersistedSnoozedNotificationsWithContext,\n                        getTrimmedString(contextId));\n            }\n        }\n        snooze(record);\n    }\n\n    private void snooze(NotificationRecord record) {\n        int userId = record.getUser().getIdentifier();\n        if (DEBUG) {\n            Slog.d(TAG, \"Snoozing \" + record.getKey());\n        }\n        synchronized (mLock) {\n            storeRecordLocked(record.getSbn().getPackageName(), record.getKey(),\n                    userId, mSnoozedNotifications, record);\n        }\n    }\n\n    private String getTrimmedString(String key) {\n        if (key != null && key.length() > MAX_STRING_LENGTH) {\n            return key.substring(0, MAX_STRING_LENGTH);\n        }\n        return key;\n    }\n\n    private <T> void storeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets, T object) {\n\n        mPackages.put(key, pkg);\n        mUsers.put(key, userId);\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            keyToValue = new ArrayMap<>();\n        }\n        keyToValue.put(key, object);\n        targets.put(getPkgKey(userId, pkg), keyToValue);\n    }\n\n    private <T> T removeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets) {\n        T object = null;\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            return null;\n        }\n        object = keyToValue.remove(key);\n        if (keyToValue.size() == 0) {\n            targets.remove(getPkgKey(userId, pkg));\n        }\n        return object;\n    }\n\n    protected boolean cancel(int userId, String pkg, String tag, int id) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsForPkg =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsForPkg != null) {\n                final Set<Map.Entry<String, NotificationRecord>> records = recordsForPkg.entrySet();\n                for (Map.Entry<String, NotificationRecord> record : records) {\n                    final StatusBarNotification sbn = record.getValue().getSbn();\n                    if (Objects.equals(sbn.getTag(), tag) && sbn.getId() == id) {\n                        record.getValue().isCanceled = true;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    protected void cancel(int userId, boolean includeCurrentProfiles) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.size() == 0) {\n                return;\n            }\n            IntArray userIds = new IntArray();\n            userIds.add(userId);\n            if (includeCurrentProfiles) {\n                userIds = mUserProfiles.getCurrentProfileIds();\n            }\n            for (ArrayMap<String, NotificationRecord> snoozedRecords : mSnoozedNotifications.values()) {\n                for (NotificationRecord r : snoozedRecords.values()) {\n                    if (userIds.binarySearch(r.getUserId()) >= 0) {\n                        r.isCanceled = true;\n                    }\n                }\n            }\n        }\n    }\n\n    protected boolean cancel(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return false;\n            }\n            int N = records.size();\n            for (int i = 0; i < N; i++) {\n                records.valueAt(i).isCanceled = true;\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Updates the notification record so the most up to date information is shown on re-post.\n     */\n    protected void update(int userId, NotificationRecord record) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, record.getSbn().getPackageName()));\n            if (records == null) {\n                return;\n            }\n            records.put(record.getKey(), record);\n        }\n    }\n\n    protected void repost(String key, boolean muteOnReturn) {\n        synchronized (mLock) {\n            Integer userId = mUsers.get(key);\n            if (userId != null) {\n                repost(key, userId, muteOnReturn);\n            }\n        }\n    }\n\n    protected void repost(String key, int userId, boolean muteOnReturn) {\n        final String trimmedKey = getTrimmedString(key);\n\n        NotificationRecord record;\n        synchronized (mLock) {\n            final String pkg = mPackages.remove(key);\n            mUsers.remove(key);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            record = records.remove(key);\n\n        }\n\n        if (record != null && !record.isCanceled) {\n            final PendingIntent pi = createPendingIntent(\n                    record.getSbn().getPackageName(), record.getKey(), userId);\n            mAm.cancel(pi);\n            MetricsLogger.action(record.getLogMaker()\n                    .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                    .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n            mCallback.repost(userId, record, muteOnReturn);\n        }\n    }\n\n    protected void repostGroupSummary(String pkg, int userId, String groupKey) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsByKey\n                    = mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsByKey == null) {\n                return;\n            }\n\n            String groupSummaryKey = null;\n            int N = recordsByKey.size();\n            for (int i = 0; i < N; i++) {\n                final NotificationRecord potentialGroupSummary = recordsByKey.valueAt(i);\n                if (potentialGroupSummary.getSbn().isGroup()\n                        && potentialGroupSummary.getNotification().isGroupSummary()\n                        && groupKey.equals(potentialGroupSummary.getGroupKey())) {\n                    groupSummaryKey = potentialGroupSummary.getKey();\n                    break;\n                }\n            }\n\n            if (groupSummaryKey != null) {\n                NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                mPackages.remove(groupSummaryKey);\n                mUsers.remove(groupSummaryKey);\n\n                final String trimmedKey = getTrimmedString(groupSummaryKey);\n                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n                removeRecordLocked(pkg, trimmedKey, userId,\n                      mPersistedSnoozedNotificationsWithContext);\n\n                if (record != null && !record.isCanceled) {\n                    Runnable runnable = () -> {\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n                        mCallback.repost(userId, record, false);\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    protected void clearData(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            for (int i = records.size() - 1; i >= 0; i--) {\n                final NotificationRecord r = records.removeAt(i);\n                if (r != null) {\n                    mPackages.remove(r.getKey());\n                    mUsers.remove(r.getKey());\n                    Runnable runnable = () -> {\n                        final PendingIntent pi = createPendingIntent(pkg, r.getKey(), userId);\n                        mAm.cancel(pi);\n                        MetricsLogger.action(r.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_DISMISS));\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    private PendingIntent createPendingIntent(String pkg, String key, int userId) {\n        return PendingIntent.getBroadcast(mContext,\n                REQUEST_CODE_REPOST,\n                new Intent(REPOST_ACTION)\n                        .setPackage(PackageManagerService.PLATFORM_PACKAGE_NAME)\n                        .setData(new Uri.Builder().scheme(REPOST_SCHEME).appendPath(key).build())\n                        .addFlags(Intent.FLAG_RECEIVER_FOREGROUND)\n                        .putExtra(EXTRA_KEY, key)\n                        .putExtra(EXTRA_USER_ID, userId),\n                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n    }\n\n    public void scheduleRepostsForPersistedNotifications(long currentTime) {\n        synchronized (mLock) {\n            for (ArrayMap<String, Long> snoozed : mPersistedSnoozedNotifications.values()) {\n                for (int i = 0; i < snoozed.size(); i++) {\n                    String key = snoozed.keyAt(i);\n                    Long time = snoozed.valueAt(i);\n                    String pkg = mPackages.get(key);\n                    Integer userId = mUsers.get(key);\n                    if (time == null || pkg == null || userId == null) {\n                        Slog.w(TAG, \"data out of sync: \" + time + \"|\" + pkg + \"|\" + userId);\n                        continue;\n                    }\n                    if (time != null && time > currentTime) {\n                        scheduleRepostAtTime(pkg, key, userId, time);\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleRepost(String pkg, String key, int userId, long duration) {\n        scheduleRepostAtTime(pkg, key, userId, System.currentTimeMillis() + duration);\n    }\n\n    private void scheduleRepostAtTime(String pkg, String key, int userId, long time) {\n        Runnable runnable = () -> {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final PendingIntent pi = createPendingIntent(pkg, key, userId);\n                mAm.cancel(pi);\n                if (DEBUG) Slog.d(TAG, \"Scheduling evaluate for \" + new Date(time));\n                mAm.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pi);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        };\n        runnable.run();\n    }\n\n    public void dump(PrintWriter pw, NotificationManagerService.DumpFilter filter) {\n        synchronized (mLock) {\n            pw.println(\"\\n  Snoozed notifications:\");\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.println(key);\n                }\n            }\n            pw.println(\"\\n Pending snoozed notifications\");\n            for (String userPkgKey : mPersistedSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, Long> snoozedRecords =\n                        mPersistedSnoozedNotifications.get(userPkgKey);\n                if (snoozedRecords == null) {\n                    continue;\n                }\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(key);\n                    pw.print(INDENT);\n                    pw.println(snoozedRecords.get(key));\n                }\n            }\n        }\n    }\n\n    protected void writeXml(TypedXmlSerializer out) throws IOException {\n        synchronized (mLock) {\n            final long currentTime = System.currentTimeMillis();\n            out.startTag(null, XML_TAG_NAME);\n            writeXml(out, mPersistedSnoozedNotifications, XML_SNOOZED_NOTIFICATION,\n                    value -> {\n                        if (value < currentTime) {\n                            return;\n                        }\n                        out.attributeLong(null, XML_SNOOZED_NOTIFICATION_TIME,\n                                value);\n                    });\n            writeXml(out, mPersistedSnoozedNotificationsWithContext,\n                    XML_SNOOZED_NOTIFICATION_CONTEXT,\n                    value -> {\n                        out.attribute(null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID,\n                                value);\n                    });\n            out.endTag(null, XML_TAG_NAME);\n        }\n    }\n\n    private interface Inserter<T> {\n        void insert(T t) throws IOException;\n    }\n\n    private <T> void writeXml(TypedXmlSerializer out,\n            ArrayMap<String, ArrayMap<String, T>> targets, String tag,\n            Inserter<T> attributeInserter)\n            throws IOException {\n        final int M = targets.size();\n        for (int i = 0; i < M; i++) {\n            // T is a String (snoozed until context) or Long (snoozed until time)\n            ArrayMap<String, T> keyToValue = targets.valueAt(i);\n            for (int j = 0; j < keyToValue.size(); j++) {\n                String key = keyToValue.keyAt(j);\n                T value = keyToValue.valueAt(j);\n                String pkg = mPackages.get(key);\n                Integer userId = mUsers.get(key);\n\n                if (pkg == null || userId == null) {\n                    Slog.w(TAG, \"pkg \" + pkg + \" or user \" + userId + \" missing for \" + key);\n                    continue;\n                }\n\n                out.startTag(null, tag);\n\n                attributeInserter.insert(value);\n\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL,\n                        XML_SNOOZED_NOTIFICATION_VERSION);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_KEY, key);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_PKG, pkg);\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_USER_ID, userId);\n\n                out.endTag(null, tag);\n            }\n        }\n    }\n\n    protected void readXml(TypedXmlPullParser parser, long currentTime)\n            throws XmlPullParserException, IOException {\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {\n            String tag = parser.getName();\n            if (type == XmlPullParser.END_TAG\n                    && XML_TAG_NAME.equals(tag)) {\n                break;\n            }\n            if (type == XmlPullParser.START_TAG\n                    && (XML_SNOOZED_NOTIFICATION.equals(tag)\n                        || tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT))\n                    && parser.getAttributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL, -1)\n                        == XML_SNOOZED_NOTIFICATION_VERSION) {\n                try {\n                    final String key = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_KEY);\n                    final String pkg = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_PKG);\n                    final int userId = parser.getAttributeInt(\n                            null, XML_SNOOZED_NOTIFICATION_USER_ID, UserHandle.USER_ALL);\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION)) {\n                        final Long time = parser.getAttributeLong(\n                                null, XML_SNOOZED_NOTIFICATION_TIME, 0);\n                        if (time > currentTime) { //only read new stuff\n                            synchronized (mLock) {\n                                storeRecordLocked(\n                                        pkg, key, userId, mPersistedSnoozedNotifications, time);\n                            }\n                        }\n                    }\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT)) {\n                        final String creationId = parser.getAttributeValue(\n                                null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID);\n                        synchronized (mLock) {\n                            storeRecordLocked(\n                                    pkg, key, userId, mPersistedSnoozedNotificationsWithContext,\n                                    creationId);\n                        }\n                    }\n                } catch (Exception e) {\n                    Slog.e(TAG,  \"Exception in reading snooze data from policy xml\", e);\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void setAlarmManager(AlarmManager am) {\n        mAm = am;\n    }\n\n    protected interface Callback {\n        void repost(int userId, NotificationRecord r, boolean muteOnReturn);\n    }\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (DEBUG) {\n                Slog.d(TAG, \"Reposting notification\");\n            }\n            if (REPOST_ACTION.equals(intent.getAction())) {\n                repost(intent.getStringExtra(EXTRA_KEY), intent.getIntExtra(EXTRA_USER_ID,\n                        UserHandle.USER_SYSTEM), false);\n            }\n        }\n    };\n}",
            "downstream_file_ground_truth_tokens": {
              "openai": 5905,
              "general": {
                "word_based": 2347,
                "char_based": 7375
              },
              "gemini": 7061
            },
            "downstream_file_content_patched_upstream_only": "```java\n/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.android.server.notification;\n\nimport android.annotation.NonNull;\nimport android.annotation.UserIdInt;\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.service.notification.StatusBarNotification;\nimport android.util.ArrayMap;\nimport android.util.IntArray;\nimport android.util.Log;\nimport android.util.Slog;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto;\nimport com.android.internal.util.XmlUtils;\nimport com.android.server.pm.PackageManagerService;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * NotificationManagerService helper for handling snoozed notifications.\n */\npublic class SnoozeHelper {\n    public static final int XML_SNOOZED_NOTIFICATION_VERSION = 1;\n\n    static final int CONCURRENT_SNOOZE_LIMIT = 500;\n\n    // A safe size for strings to be put in persistent storage, to avoid breaking the XML write.\n    static final int MAX_STRING_LENGTH = 1000;\n\n    protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n\n    private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT = \"context\";\n    private static final String XML_SNOOZED_NOTIFICATION_PKG = \"pkg\";\n    private static final String XML_SNOOZED_NOTIFICATION_USER_ID = \"user-id\";\n    private static final String XML_SNOOZED_NOTIFICATION_KEY = \"key\";\n    //the time the snoozed notification should be reposted\n    private static final String XML_SNOOZED_NOTIFICATION_TIME = \"time\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT_ID = \"id\";\n    private static final String XML_SNOOZED_NOTIFICATION_VERSION_LABEL = \"version\";\n\n\n    private static final String TAG = \"SnoozeHelper\";\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n    private static final String INDENT = \"    \";\n\n    private static final String REPOST_ACTION = SnoozeHelper.class.getSimpleName() + \".EVALUATE\";\n    private static final int REQUEST_CODE_REPOST = 1;\n    private static final String REPOST_SCHEME = \"repost\";\n    static final String EXTRA_KEY = \"key\";\n    private static final String EXTRA_USER_ID = \"userId\";\n\n    private final Context mContext;\n    private AlarmManager mAm;\n    private final ManagedServices.UserProfiles mUserProfiles;\n\n    // User id | package name : notification key : record.\n    private ArrayMap<String, ArrayMap<String, NotificationRecord>>\n            mSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : time-milliseconds .\n    // This member stores persisted snoozed notification trigger times. it persists through reboots\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, Long>>\n            mPersistedSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : creation ID .\n    // This member stores persisted snoozed notification trigger context for the assistant\n    // it persists through reboots.\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, String>>\n            mPersistedSnoozedNotificationsWithContext = new ArrayMap<>();\n    // notification key : package.\n    private ArrayMap<String, String> mPackages = new ArrayMap<>();\n    // key : userId\n    private ArrayMap<String, Integer> mUsers = new ArrayMap<>();\n    private Callback mCallback;\n\n    private final Object mLock = new Object();\n\n    public SnoozeHelper(Context context, Callback callback,\n            ManagedServices.UserProfiles userProfiles) {\n        mContext = context;\n        IntentFilter filter = new IntentFilter(REPOST_ACTION);\n        filter.addDataScheme(REPOST_SCHEME);\n        mContext.registerReceiver(mBroadcastReceiver, filter);\n        mAm = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mCallback = callback;\n        mUserProfiles = userProfiles;\n    }\n\n    private String getPkgKey(@UserIdInt int userId, String pkg) {\n        return userId + \"|\" + pkg;\n    }\n\n    void cleanupPersistedContext(String key){\n        synchronized (mLock) {\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            removeRecordLocked(pkg, key, userId, mPersistedSnoozedNotificationsWithContext);\n        }\n    }\n\n    protected boolean canSnooze(int numberToSnooze) {\n        synchronized (mLock) {\n            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @NonNull\n    protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n        Long time = null;\n        synchronized (mLock) {\n           ArrayMap<String, Long> snoozed =\n                   mPersistedSnoozedNotifications.get(getPkgKey(userId, pkg));\n           if (snoozed != null) {\n               time = snoozed.get(getTrimmedString(key));\n           }\n        }\n        if (time == null) {\n            time = 0L;\n        }\n        return time;\n    }\n\n    protected String getSnoozeContextForUnpostedNotification(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            ArrayMap<String, String> snoozed =\n                    mPersistedSnoozedNotificationsWithContext.get(getPkgKey(userId, pkg));\n            if (snoozed != null) {\n                return snoozed.get(getTrimmedString(key));\n            }\n        }\n        return null;\n    }\n\n    protected boolean isSnoozed(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            return mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))\n                    && mSnoozedNotifications.get(getPkgKey(userId, pkg)).containsKey(key);\n        }\n    }\n\n    protected Collection<NotificationRecord> getSnoozed(int userId, String pkg) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))) {\n                return mSnoozedNotifications.get(getPkgKey(userId, pkg)).values();\n            }\n        }\n        return Collections.EMPTY_LIST;\n    }\n\n    @NonNull\n    ArrayList<NotificationRecord> getNotifications(String pkg,\n            String groupKey, Integer userId) {\n        ArrayList<NotificationRecord> records =  new ArrayList<>();\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> allRecords =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (allRecords != null) {\n                for (int i = 0; i < allRecords.size(); i++) {\n                    NotificationRecord r = allRecords.valueAt(i);\n                    String currentGroupKey = r.getSbn().getGroup();\n                    if (Objects.equals(currentGroupKey, groupKey)) {\n                        records.add(r);\n                    }\n                }\n            }\n        }\n        return records;\n    }\n\n    protected NotificationRecord getNotification(String key) {\n        synchronized (mLock) {\n            if (!mUsers.containsKey(key) || !mPackages.containsKey(key)) {\n                Slog.w(TAG, \"Snoozed data sets no longer agree for \" + key);\n                return null;\n            }\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            ArrayMap<String, NotificationRecord> snoozed =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (snoozed == null) {\n                return null;\n            }\n            return snoozed.get(key);\n        }\n    }\n\n    protected @NonNull List<NotificationRecord> getSnoozed() {\n        synchronized (mLock) {\n            // caller filters records based on the current user profiles and listener access, so just\n            // return everything\n            List<NotificationRecord> snoozed = new ArrayList<>();\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                snoozed.addAll(snoozedRecords.values());\n            }\n            return snoozed;\n        }\n    }\n\n    /**\n     * Snoozes a notification and schedules an alarm to repost at that time.\n     */\n    protected void snooze(NotificationRecord record, long duration) {\n        String pkg = record.getSbn().getPackageName();\n        String key = record.getKey();\n        int userId = record.getUser().getIdentifier();\n\n        snooze(record);\n        scheduleRepost(pkg, key, userId, duration);\n        Long activateAt = System.currentTimeMillis() + duration;\n        synchronized (mLock) {\n            storeRecordLocked(pkg, getTrimmedString(key), userId, mPersistedSnoozedNotifications,\n                    activateAt);\n        }\n    }\n\n    /**\n     * Records a snoozed notification.\n     */\n    protected void snooze(NotificationRecord record, String contextId) {\n        int userId = record.getUser().getIdentifier();\n        if (contextId != null) {\n            synchronized (mLock) {\n                storeRecordLocked(record.getSbn().getPackageName(),\n                        getTrimmedString(record.getKey()),\n                        userId, mPersistedSnoozedNotificationsWithContext,\n                        getTrimmedString(contextId));\n            }\n        }\n        snooze(record);\n    }\n\n    private void snooze(NotificationRecord record) {\n        int userId = record.getUser().getIdentifier();\n        if (DEBUG) {\n            Slog.d(TAG, \"Snoozing \" + record.getKey());\n        }\n        synchronized (mLock) {\n            storeRecordLocked(record.getSbn().getPackageName(), record.getKey(),\n                    userId, mSnoozedNotifications, record);\n        }\n    }\n\n    private String getTrimmedString(String key) {\n        if (key != null && key.length() > MAX_STRING_LENGTH) {\n            return key.substring(0, MAX_STRING_LENGTH);\n        }\n        return key;\n    }\n\n    private <T> void storeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets, T object) {\n\n        mPackages.put(key, pkg);\n        mUsers.put(key, userId);\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            keyToValue = new ArrayMap<>();\n        }\n        keyToValue.put(key, object);\n        targets.put(getPkgKey(userId, pkg), keyToValue);\n    }\n\n    private <T> T removeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets) {\n        T object = null;\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            return null;\n        }\n        object = keyToValue.remove(key);\n        if (keyToValue.size() == 0) {\n            targets.remove(getPkgKey(userId, pkg));\n        }\n        return object;\n    }\n\n    protected boolean cancel(int userId, String pkg, String tag, int id) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsForPkg =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsForPkg != null) {\n                final Set<Map.Entry<String, NotificationRecord>> records = recordsForPkg.entrySet();\n                for (Map.Entry<String, NotificationRecord> record : records) {\n                    final StatusBarNotification sbn = record.getValue().getSbn();\n                    if (Objects.equals(sbn.getTag(), tag) && sbn.getId() == id) {\n                        record.getValue().isCanceled = true;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    protected void cancel(int userId, boolean includeCurrentProfiles) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.size() == 0) {\n                return;\n            }\n            IntArray userIds = new IntArray();\n            userIds.add(userId);\n            if (includeCurrentProfiles) {\n                userIds = mUserProfiles.getCurrentProfileIds();\n            }\n            for (ArrayMap<String, NotificationRecord> snoozedRecords : mSnoozedNotifications.values()) {\n                for (NotificationRecord r : snoozedRecords.values()) {\n                    if (userIds.binarySearch(r.getUserId()) >= 0) {\n                        r.isCanceled = true;\n                    }\n                }\n            }\n        }\n    }\n\n    protected boolean cancel(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return false;\n            }\n            int N = records.size();\n            for (int i = 0; i < N; i++) {\n                records.valueAt(i).isCanceled = true;\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Updates the notification record so the most up to date information is shown on re-post.\n     */\n    protected void update(int userId, NotificationRecord record) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, record.getSbn().getPackageName()));\n            if (records == null) {\n                return;\n            }\n            records.put(record.getKey(), record);\n        }\n    }\n\n    protected void repost(String key, boolean muteOnReturn) {\n        synchronized (mLock) {\n            Integer userId = mUsers.get(key);\n            if (userId != null) {\n                repost(key, userId, muteOnReturn);\n            }\n        }\n    }\n\n    protected void repost(String key, int userId, boolean muteOnReturn) {\n        final String trimmedKey = getTrimmedString(key);\n\n        NotificationRecord record;\n        synchronized (mLock) {\n            final String pkg = mPackages.remove(key);\n            mUsers.remove(key);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            record = records.remove(key);\n\n        }\n\n        if (record != null && !record.isCanceled) {\n            final PendingIntent pi = createPendingIntent(\n                    record.getSbn().getPackageName(), record.getKey(), userId);\n            mAm.cancel(pi);\n            MetricsLogger.action(record.getLogMaker()\n                    .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                    .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n            mCallback.repost(userId, record, muteOnReturn);\n        }\n    }\n\n    protected void repostGroupSummary(String pkg, int userId, String groupKey) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsByKey\n                    = mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsByKey == null) {\n                return;\n            }\n\n            String groupSummaryKey = null;\n            int N = recordsByKey.size();\n            for (int i = 0; i < N; i++) {\n                final NotificationRecord potentialGroupSummary = recordsByKey.valueAt(i);\n                if (potentialGroupSummary.getSbn().isGroup()\n                        && potentialGroupSummary.getNotification().isGroupSummary()\n                        && groupKey.equals(potentialGroupSummary.getGroupKey())) {\n                    groupSummaryKey = potentialGroupSummary.getKey();\n                    break;\n                }\n            }\n\n            if (groupSummaryKey != null) {\n                NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                mPackages.remove(groupSummaryKey);\n                mUsers.remove(groupSummaryKey);\n\n                if (record != null && !record.isCanceled) {\n                    Runnable runnable = () -> {\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n                        mCallback.repost(userId, record, false);\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    protected void clearData(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            for (int i = records.size() - 1; i >= 0; i--) {\n                final NotificationRecord r = records.removeAt(i);\n                if (r != null) {\n                    mPackages.remove(r.getKey());\n                    mUsers.remove(r.getKey());\n                    Runnable runnable = () -> {\n                        final PendingIntent pi = createPendingIntent(pkg, r.getKey(), userId);\n                        mAm.cancel(pi);\n                        MetricsLogger.action(r.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_DISMISS));\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    private PendingIntent createPendingIntent(String pkg, String key, int userId) {\n        return PendingIntent.getBroadcast(mContext,\n                REQUEST_CODE_REPOST,\n                new Intent(REPOST_ACTION)\n                        .setPackage(PackageManagerService.PLATFORM_PACKAGE_NAME)\n                        .setData(new Uri.Builder().scheme(REPOST_SCHEME).appendPath(key).build())\n                        .addFlags(Intent.FLAG_RECEIVER_FOREGROUND)\n                        .putExtra(EXTRA_KEY, key)\n                        .putExtra(EXTRA_USER_ID, userId),\n                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n    }\n\n    public void scheduleRepostsForPersistedNotifications(long currentTime) {\n        synchronized (mLock) {\n            for (ArrayMap<String, Long> snoozed : mPersistedSnoozedNotifications.values()) {\n                for (int i = 0; i < snoozed.size(); i++) {\n                    String key = snoozed.keyAt(i);\n                    Long time = snoozed.valueAt(i);\n                    String pkg = mPackages.get(key);\n                    Integer userId = mUsers.get(key);\n                    if (time == null || pkg == null || userId == null) {\n                        Slog.w(TAG, \"data out of sync: \" + time + \"|\" + pkg + \"|\" + userId);\n                        continue;\n                    }\n                    if (time != null && time > currentTime) {\n                        scheduleRepostAtTime(pkg, key, userId, time);\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleRepost(String pkg, String key, int userId, long duration) {\n        scheduleRepostAtTime(pkg, key, userId, System.currentTimeMillis() + duration);\n    }\n\n    private void scheduleRepostAtTime(String pkg, String key, int userId, long time) {\n        Runnable runnable = () -> {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final PendingIntent pi = createPendingIntent(pkg, key, userId);\n                mAm.cancel(pi);\n                if (DEBUG) Slog.d(TAG, \"Scheduling evaluate for \" + new Date(time));\n                mAm.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pi);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        };\n        runnable.run();\n    }\n\n    public void dump(PrintWriter pw, NotificationManagerService.DumpFilter filter) {\n        synchronized (mLock) {\n            pw.println(\"\\n  Snoozed notifications:\");\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.println(key);\n                }\n            }\n            pw.println(\"\\n Pending snoozed notifications\");\n            for (String userPkgKey : mPersistedSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, Long> snoozedRecords =\n                        mPersistedSnoozedNotifications.get(userPkgKey);\n                if (snoozedRecords == null) {\n                    continue;\n                }\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(key);\n                    pw.print(INDENT);\n                    pw.println(snoozedRecords.get(key));\n                }\n            }\n        }\n    }\n\n    protected void writeXml(TypedXmlSerializer out) throws IOException {\n        synchronized (mLock) {\n            final long currentTime = System.currentTimeMillis();\n            out.startTag(null, XML_TAG_NAME);\n            writeXml(out, mPersistedSnoozedNotifications, XML_SNOOZED_NOTIFICATION,\n                    value -> {\n                        if (value < currentTime) {\n                            return;\n                        }\n                        out.attributeLong(null, XML_SNOOZED_NOTIFICATION_TIME,\n                                value);\n                    });\n            writeXml(out, mPersistedSnoozedNotificationsWithContext,\n                    XML_SNOOZED_NOTIFICATION_CONTEXT,\n                    value -> {\n                        out.attribute(null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID,\n                                value);\n                    });\n            out.endTag(null, XML_TAG_NAME);\n        }\n    }\n\n    private interface Inserter<T> {\n        void insert(T t) throws IOException;\n    }\n\n    private <T> void writeXml(TypedXmlSerializer out,\n            ArrayMap<String, ArrayMap<String, T>> targets, String tag,\n            Inserter<T> attributeInserter)\n            throws IOException {\n        final int M = targets.size();\n        for (int i = 0; i < M; i++) {\n            // T is a String (snoozed until context) or Long (snoozed until time)\n            ArrayMap<String, T> keyToValue = targets.valueAt(i);\n            for (int j = 0; j < keyToValue.size(); j++) {\n                String key = keyToValue.keyAt(j);\n                T value = keyToValue.valueAt(j);\n                String pkg = mPackages.get(key);\n                Integer userId = mUsers.get(key);\n\n                if (pkg == null || userId == null) {\n                    Slog.w(TAG, \"pkg \" + pkg + \" or user \" + userId + \" missing for \" + key);\n                    continue;\n                }\n\n                out.startTag(null, tag);\n\n                attributeInserter.insert(value);\n\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL,\n                        XML_SNOOZED_NOTIFICATION_VERSION);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_KEY, key);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_PKG, pkg);\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_USER_ID, userId);\n\n                out.endTag(null, tag);\n            }\n        }\n    }\n\n    protected void readXml(TypedXmlPullParser parser, long currentTime)\n            throws XmlPullParserException, IOException {\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {\n            String tag = parser.getName();\n            if (type == XmlPullParser.END_TAG\n                    && XML_TAG_NAME.equals(tag)) {\n                break;\n            }\n            if (type == XmlPullParser.START_TAG\n                    && (XML_SNOOZED_NOTIFICATION.equals(tag)\n                        || tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT))\n                    && parser.getAttributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL, -1)\n                        == XML_SNOOZED_NOTIFICATION_VERSION) {\n                try {\n                    final String key = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_KEY);\n                    final String pkg = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_PKG);\n                    final int userId = parser.getAttributeInt(\n                            null, XML_SNOOZED_NOTIFICATION_USER_ID, UserHandle.USER_ALL);\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION)) {\n                        final Long time = parser.getAttributeLong(\n                                null, XML_SNOOZED_NOTIFICATION_TIME, 0);\n                        if (time > currentTime) { //only read new stuff\n                            synchronized (mLock) {\n                                storeRecordLocked(\n                                        pkg, key, userId, mPersistedSnoozedNotifications, time);\n                            }\n                        }\n                    }\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT)) {\n                        final String creationId = parser.getAttributeValue(\n                                null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID);\n                        synchronized (mLock) {\n                            storeRecordLocked(\n                                    pkg, key, userId, mPersistedSnoozedNotificationsWithContext,\n                                    creationId);\n                        }\n                    }\n                } catch (Exception e) {\n                    Slog.e(TAG,  \"Exception in reading snooze data from policy xml\", e);\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void setAlarmManager(AlarmManager am) {\n        mAm = am;\n    }\n\n    protected interface Callback {\n        void repost(int userId, NotificationRecord r, boolean muteOnReturn);\n    }\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (DEBUG) {\n                Slog.d(TAG, \"Reposting notification\");\n            }\n            if (REPOST_ACTION.equals(intent.getAction())) {\n                repost(intent.getStringExtra(EXTRA_KEY), intent.getIntExtra(EXTRA_USER_ID,\n                        UserHandle.USER_SYSTEM), false);\n            }\n        }\n    };\n}\n```",
            "diff_patched_upstream_only": "--- original_downstream_file\n+++ patched_upstream_only\n@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2016 The Android Open Source Project\n  *\n@@ -704,5 +703,4 @@\n             }\n         }\n     };\n-}\n-```+}",
            "downstream_llm_diff_output": null,
            "runtime_seconds": 362.06,
            "llm_output_valid": false,
            "attempts_made": 3,
            "validation_results": [
              {
                "attempt": 1,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk diff line expected: @@ -381,11 +384,14 @@\n",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 140.25
              },
              {
                "attempt": 2,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk diff line expected: @@ -378,8 +381,11 @@\n",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 106.42
              },
              {
                "attempt": 3,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk diff line expected: @@ -377,9 +377,12 @@\n",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 115.38
              }
            ],
            "error": "All validation attempts failed",
            "last_format_error": "Invalid patch format: Hunk diff line expected: @@ -377,9 +377,12 @@\n",
            "last_apply_error": "Skipped due to format error"
          }
        ]
      },
      {
        "downstream_version": "12",
        "gemini_token_usage": 21789,
        "branch_used": "android12-release",
        "downstream_patch": "ade22bfdf6698cb97b4edc303e8952d6cc1a2f73",
        "repo_path": "android_repos/base",
        "result": "failure",
        "downstream_patch_content": "commit ade22bfdf6698cb97b4edc303e8952d6cc1a2f73\nAuthor: Valentin Iftime <valiiftime@google.com>\nDate:   Wed Nov 8 11:01:32 2023 +0100\n\n    Enforce persisted snoozed notifications limits\n    \n     Prevent DoS attack that causes boot-looping by serializing a huge amount of snoozed notifications:\n      - Check snooze limits for persisted notifications\n      - Remove persisted group summary notification when in-memory counterpart is removed\n      - Prevent unpriviledged API calls that allow 3P apps to snooze notifications with context/criterion\n    \n    Test: atest SnoozeHelperTest\n    Test: atest NotificationManagerServiceTest\n    Bug: 307948424\n    Bug: 308414141\n    \n    Change-Id: I3571fa9207b778def652130d3ca840183a9a8414\n    (cherry picked from commit 965ff2d3c5487f72a77f6153ed8542cb2621d93c)\n    Merged-In: I3571fa9207b778def652130d3ca840183a9a8414\n\ndiff --git a/services/core/java/com/android/server/notification/SnoozeHelper.java b/services/core/java/com/android/server/notification/SnoozeHelper.java\nindex f3b92eaf6473..966560359b39 100644\n--- a/services/core/java/com/android/server/notification/SnoozeHelper.java\n+++ b/services/core/java/com/android/server/notification/SnoozeHelper.java\n@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()\ndiff --git a/services/tests/uiservicestests/src/com/android/server/notification/SnoozeHelperTest.java b/services/tests/uiservicestests/src/com/android/server/notification/SnoozeHelperTest.java\nindex 883613f6a2b6..c1da6693bc1c 100644\n--- a/services/tests/uiservicestests/src/com/android/server/notification/SnoozeHelperTest.java\n+++ b/services/tests/uiservicestests/src/com/android/server/notification/SnoozeHelperTest.java\n@@ -18,6 +18,8 @@ package com.android.server.notification;\n import static com.android.server.notification.SnoozeHelper.CONCURRENT_SNOOZE_LIMIT;\n import static com.android.server.notification.SnoozeHelper.EXTRA_KEY;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static junit.framework.Assert.assertEquals;\n import static junit.framework.Assert.assertFalse;\n import static junit.framework.Assert.assertNull;\n@@ -76,6 +78,16 @@ import java.util.Collections;\n public class SnoozeHelperTest extends UiServiceTestCase {\n     private static final String TEST_CHANNEL_ID = \"test_channel_id\";\n \n+    private static final String XML_TAG_NAME = \"snoozed-notifications\";\n+    private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n+    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT = \"context\";\n+    private static final String XML_SNOOZED_NOTIFICATION_KEY = \"key\";\n+    private static final String XML_SNOOZED_NOTIFICATION_TIME = \"time\";\n+    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT_ID = \"id\";\n+    private static final String XML_SNOOZED_NOTIFICATION_VERSION_LABEL = \"version\";\n+    private static final String XML_SNOOZED_NOTIFICATION_PKG = \"pkg\";\n+    private static final String XML_SNOOZED_NOTIFICATION_USER_ID = \"user-id\";\n+\n     @Mock SnoozeHelper.Callback mCallback;\n     @Mock AlarmManager mAm;\n     @Mock ManagedServices.UserProfiles mUserProfiles;\n@@ -329,6 +341,56 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n         assertFalse(mSnoozeHelper.canSnooze(1));\n     }\n \n+    @Test\n+    public void testSnoozeLimit_maximumPersisted() throws XmlPullParserException, IOException {\n+        final long snoozeTimeout = 1234;\n+        final String snoozeContext = \"ctx\";\n+        // Serialize & deserialize notifications so that only persisted lists are used\n+        TypedXmlSerializer serializer = Xml.newFastSerializer();\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        serializer.setOutput(new BufferedOutputStream(baos), \"utf-8\");\n+        serializer.startDocument(null, true);\n+        serializer.startTag(null, XML_TAG_NAME);\n+        // Serialize maximum number of timed + context snoozed notifications, half of each\n+        for (int i = 0; i < CONCURRENT_SNOOZE_LIMIT; i++) {\n+            final boolean timedNotification = i % 2 == 0;\n+            if (timedNotification) {\n+                serializer.startTag(null, XML_SNOOZED_NOTIFICATION);\n+            } else {\n+                serializer.startTag(null, XML_SNOOZED_NOTIFICATION_CONTEXT);\n+            }\n+            serializer.attribute(null, XML_SNOOZED_NOTIFICATION_PKG, \"pkg\");\n+            serializer.attributeInt(null, XML_SNOOZED_NOTIFICATION_USER_ID,\n+                UserHandle.USER_SYSTEM);\n+            serializer.attributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL, 1);\n+            serializer.attribute(null, XML_SNOOZED_NOTIFICATION_KEY, \"key\" + i);\n+            if (timedNotification) {\n+                serializer.attributeLong(null, XML_SNOOZED_NOTIFICATION_TIME, snoozeTimeout);\n+                serializer.endTag(null, XML_SNOOZED_NOTIFICATION);\n+            } else {\n+                serializer.attribute(null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID, snoozeContext);\n+                serializer.endTag(null, XML_SNOOZED_NOTIFICATION_CONTEXT);\n+            }\n+        }\n+        serializer.endTag(null, XML_TAG_NAME);\n+        serializer.endDocument();\n+        serializer.flush();\n+\n+        TypedXmlPullParser parser = Xml.newFastPullParser();\n+        parser.setInput(new BufferedInputStream(\n+                new ByteArrayInputStream(baos.toByteArray())), \"utf-8\");\n+        mSnoozeHelper.readXml(parser, 1);\n+        // Verify that we can't snooze any more notifications\n+        //  and that the limit is caused by persisted notifications\n+        assertThat(mSnoozeHelper.canSnooze(1)).isFalse();\n+        assertThat(mSnoozeHelper.isSnoozed(UserHandle.USER_SYSTEM, \"pkg\", \"key0\")).isFalse();\n+        assertThat(mSnoozeHelper.getSnoozeTimeForUnpostedNotification(UserHandle.USER_SYSTEM,\n+                \"pkg\", \"key0\")).isEqualTo(snoozeTimeout);\n+        assertThat(\n+            mSnoozeHelper.getSnoozeContextForUnpostedNotification(UserHandle.USER_SYSTEM, \"pkg\",\n+                \"key1\")).isEqualTo(snoozeContext);\n+    }\n+\n     @Test\n     public void testCancelByApp() throws Exception {\n         NotificationRecord r = getNotificationRecord(\"pkg\", 1, \"one\", UserHandle.SYSTEM);\n@@ -602,6 +664,7 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n \n     @Test\n     public void repostGroupSummary_repostsSummary() throws Exception {\n+        final int snoozeDuration = 1000;\n         IntArray profileIds = new IntArray();\n         profileIds.add(UserHandle.USER_SYSTEM);\n         when(mUserProfiles.getCurrentProfileIds()).thenReturn(profileIds);\n@@ -609,10 +672,44 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n                 \"pkg\", 1, \"one\", UserHandle.SYSTEM, \"group1\", true);\n         NotificationRecord r2 = getNotificationRecord(\n                 \"pkg\", 2, \"two\", UserHandle.SYSTEM, \"group1\", false);\n-        mSnoozeHelper.snooze(r, 1000);\n-        mSnoozeHelper.snooze(r2, 1000);\n+        final long snoozeTime = System.currentTimeMillis() + snoozeDuration;\n+        mSnoozeHelper.snooze(r, snoozeDuration);\n+        mSnoozeHelper.snooze(r2, snoozeDuration);\n+        assertEquals(2, mSnoozeHelper.getSnoozed().size());\n+        assertEquals(2, mSnoozeHelper.getSnoozed(UserHandle.USER_SYSTEM, \"pkg\").size());\n+        // Verify that summary notification was added to the persisted list\n+        assertThat(mSnoozeHelper.getSnoozeTimeForUnpostedNotification(UserHandle.USER_SYSTEM, \"pkg\",\n+                r.getKey())).isAtLeast(snoozeTime);\n+\n+        mSnoozeHelper.repostGroupSummary(\"pkg\", UserHandle.USER_SYSTEM, r.getGroupKey());\n+\n+        verify(mCallback, times(1)).repost(UserHandle.USER_SYSTEM, r, false);\n+        verify(mCallback, never()).repost(UserHandle.USER_SYSTEM, r2, false);\n+\n+        assertEquals(1, mSnoozeHelper.getSnoozed().size());\n+        assertEquals(1, mSnoozeHelper.getSnoozed(UserHandle.USER_SYSTEM, \"pkg\").size());\n+        // Verify that summary notification was removed from the persisted list\n+        assertThat(mSnoozeHelper.getSnoozeTimeForUnpostedNotification(UserHandle.USER_SYSTEM, \"pkg\",\n+                r.getKey())).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void snoozeWithContext_repostGroupSummary_removesPersisted() throws Exception {\n+        final String snoozeContext = \"zzzzz\";\n+        IntArray profileIds = new IntArray();\n+        profileIds.add(UserHandle.USER_SYSTEM);\n+        when(mUserProfiles.getCurrentProfileIds()).thenReturn(profileIds);\n+        NotificationRecord r = getNotificationRecord(\n+                \"pkg\", 1, \"one\", UserHandle.SYSTEM, \"group1\", true);\n+        NotificationRecord r2 = getNotificationRecord(\n+                \"pkg\", 2, \"two\", UserHandle.SYSTEM, \"group1\", false);\n+        mSnoozeHelper.snooze(r, snoozeContext);\n+        mSnoozeHelper.snooze(r2, snoozeContext);\n         assertEquals(2, mSnoozeHelper.getSnoozed().size());\n         assertEquals(2, mSnoozeHelper.getSnoozed(UserHandle.USER_SYSTEM, \"pkg\").size());\n+        // Verify that summary notification was added to the persisted list\n+        assertThat(mSnoozeHelper.getSnoozeContextForUnpostedNotification(UserHandle.USER_SYSTEM,\n+            \"pkg\", r.getKey())).isEqualTo(snoozeContext);\n \n         mSnoozeHelper.repostGroupSummary(\"pkg\", UserHandle.USER_SYSTEM, r.getGroupKey());\n \n@@ -621,6 +718,9 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n \n         assertEquals(1, mSnoozeHelper.getSnoozed().size());\n         assertEquals(1, mSnoozeHelper.getSnoozed(UserHandle.USER_SYSTEM, \"pkg\").size());\n+        // Verify that summary notification was removed from the persisted list\n+        assertThat(mSnoozeHelper.getSnoozeContextForUnpostedNotification(UserHandle.USER_SYSTEM,\n+                \"pkg\", r.getKey())).isNull();\n     }\n \n     @Test\n",
        "downstream_patch_tokens": {
          "openai": 2749,
          "general": {
            "word_based": 964,
            "char_based": 2874
          },
          "gemini": 3335
        },
        "file_conflicts": [
          {
            "file_name": "services/core/java/com/android/server/notification/SnoozeHelper.java",
            "total_hunks": 2,
            "failed_hunks": [
              1,
              2
            ],
            "inline_merge_conflicts": [
              {
                "hunk_number": 1,
                "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n\n=======\n            if ((mSnoozedNotifications.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n                    || (mPersistedSnoozedNotifications.size()\n                    + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n                    > CONCURRENT_SNOOZE_LIMIT) {\n                return false;\n            }\n        }\n>>>>>>> UPSTREAM PATCH (commit da6a9ea6deece5b2505d5facdf5d44cfc08057f3)",
                "merge_conflict_tokens": {
                  "openai": 120,
                  "general": {
                    "word_based": 20,
                    "char_based": 114
                  },
                  "gemini": 132
                }
              }
            ],
            "inline_merge_token_summary": {
              "gemini": 5808,
              "openai": 5400,
              "general_word": 900,
              "general_char": 5130
            },
            "rej_file_content": "```diff\n--- services/core/java/com/android/server/notification/SnoozeHelper.java\n+++ services/core/java/com/android/server/notification/SnoozeHelper.java\n@@ -118,7 +118,10 @@ public final class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mSnoozedNotifications.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mSnoozedNotifications.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                    || (mPersistedSnoozedNotifications.size()\n+                    + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n+                    > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n@@ -343,6 +346,9 @@ public final class SnoozeHelper {\n \n             if (groupSummaryKey != null) {\n                 NotificationRecord record = mSnoozedNotifications.remove(groupSummaryKey);\n+                String trimmedKey = getTrimmedString(groupSummaryKey);\n+                mPersistedSnoozedNotificationsWithContext.remove(trimmedKey);\n+                mPersistedSnoozedNotifications.remove(trimmedKey);\n \n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n```",
            "rej_file_tokens": {
              "openai": 290,
              "general": {
                "word_based": 84,
                "char_based": 314
              },
              "gemini": 329
            },
            "patch_apply_output": "patching file services/core/java/com/android/server/notification/SnoozeHelper.java\nHunk #1 FAILED at 118.\nHunk #2 FAILED at 343.\n2 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/notification/SnoozeHelper.java.rej",
            "inline_merge_output": "patching file services/core/java/com/android/server/notification/SnoozeHelper.java\nHunk #1 NOT MERGED at 121-130.\nHunk #2 already applied at 359-361.",
            "upstream_file_content": "```java\n/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.android.server.notification;\n\nimport android.annotation.NonNull;\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.UserHandle;\nimport android.service.notification.StatusBarNotification;\nimport android.util.ArrayMap;\nimport android.util.IntArray;\nimport android.util.Log;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.server.pm.PackageManagerService;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * NotificationManagerService helper for handling snoozed notifications.\n */\npublic final class SnoozeHelper {\n    public static final int XML_SNOOZED_NOTIFICATION_VERSION = 1;\n\n    static final int CONCURRENT_SNOOZE_LIMIT = 500;\n\n    // A safe size for strings to be put in persistent storage, to avoid breaking the XML write.\n    static final int MAX_STRING_LENGTH = 1000;\n\n    protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n\n    private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT = \"context\";\n    private static final String XML_SNOOZED_NOTIFICATION_KEY = \"key\";\n    //the time the snoozed notification should be reposted\n    private static final String XML_SNOOZED_NOTIFICATION_TIME = \"time\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT_ID = \"id\";\n    private static final String XML_SNOOZED_NOTIFICATION_VERSION_LABEL = \"version\";\n\n\n    private static final String TAG = \"SnoozeHelper\";\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n    private static final String INDENT = \"    \";\n\n    private static final String REPOST_ACTION = SnoozeHelper.class.getSimpleName() + \".EVALUATE\";\n    private static final int REQUEST_CODE_REPOST = 1;\n    private static final String REPOST_SCHEME = \"repost\";\n    static final String EXTRA_KEY = \"key\";\n    private static final String EXTRA_USER_ID = \"userId\";\n\n    private final Context mContext;\n    private AlarmManager mAm;\n    private final ManagedServices.UserProfiles mUserProfiles;\n\n    // notification key : record.\n    private ArrayMap<String, NotificationRecord> mSnoozedNotifications = new ArrayMap<>();\n    // notification key : time-milliseconds .\n    // This member stores persisted snoozed notification trigger times. it persists through reboots\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, Long> mPersistedSnoozedNotifications = new ArrayMap<>();\n    // notification key : creation ID.\n    // This member stores persisted snoozed notification trigger context for the assistant\n    // it persists through reboots.\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, String>\n            mPersistedSnoozedNotificationsWithContext = new ArrayMap<>();\n\n    private Callback mCallback;\n\n    private final Object mLock = new Object();\n\n    public SnoozeHelper(Context context, Callback callback,\n            ManagedServices.UserProfiles userProfiles) {\n        mContext = context;\n        IntentFilter filter = new IntentFilter(REPOST_ACTION);\n        filter.addDataScheme(REPOST_SCHEME);\n        mContext.registerReceiver(mBroadcastReceiver, filter,\n                Context.RECEIVER_EXPORTED_UNAUDITED);\n        mAm = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mCallback = callback;\n        mUserProfiles = userProfiles;\n    }\n\n    protected boolean canSnooze(int numberToSnooze) {\n        synchronized (mLock) {\n            if ((mSnoozedNotifications.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n                    || (mPersistedSnoozedNotifications.size()\n                    + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n                    > CONCURRENT_SNOOZE_LIMIT) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @NonNull\n    protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n        Long time = null;\n        synchronized (mLock) {\n            time = mPersistedSnoozedNotifications.get(getTrimmedString(key));\n        }\n        if (time == null) {\n            time = 0L;\n        }\n        return time;\n    }\n\n    protected String getSnoozeContextForUnpostedNotification(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            return mPersistedSnoozedNotificationsWithContext.get(getTrimmedString(key));\n        }\n    }\n\n    protected boolean isSnoozed(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            return mSnoozedNotifications.containsKey(key);\n        }\n    }\n\n    protected Collection<NotificationRecord> getSnoozed(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayList snoozed = new ArrayList();\n            for (NotificationRecord r : mSnoozedNotifications.values()) {\n                if (r.getUserId() == userId && r.getSbn().getPackageName().equals(pkg)) {\n                    snoozed.add(r);\n                }\n            }\n            return snoozed;\n        }\n    }\n\n    @NonNull\n    ArrayList<NotificationRecord> getNotifications(String pkg,\n            String groupKey, Integer userId) {\n        ArrayList<NotificationRecord> records =  new ArrayList<>();\n        synchronized (mLock) {\n            for (int i = 0; i < mSnoozedNotifications.size(); i++) {\n                NotificationRecord r = mSnoozedNotifications.valueAt(i);\n                if (r.getSbn().getPackageName().equals(pkg) && r.getUserId() == userId\n                        && Objects.equals(r.getSbn().getGroup(), groupKey)) {\n                    records.add(r);\n                }\n            }\n        }\n        return records;\n    }\n\n    protected NotificationRecord getNotification(String key) {\n        synchronized (mLock) {\n            return mSnoozedNotifications.get(key);\n        }\n    }\n\n    protected @NonNull List<NotificationRecord> getSnoozed() {\n        synchronized (mLock) {\n            // caller filters records based on the current user profiles and listener access,\n            // so just return everything\n            List<NotificationRecord> snoozed = new ArrayList<>();\n            snoozed.addAll(mSnoozedNotifications.values());\n            return snoozed;\n        }\n    }\n\n    /**\n     * Snoozes a notification and schedules an alarm to repost at that time.\n     */\n    protected void snooze(NotificationRecord record, long duration) {\n        String key = record.getKey();\n\n        snooze(record);\n        scheduleRepost(key, duration);\n        Long activateAt = System.currentTimeMillis() + duration;\n        synchronized (mLock) {\n            mPersistedSnoozedNotifications.put(getTrimmedString(key), activateAt);\n        }\n    }\n\n    /**\n     * Records a snoozed notification.\n     */\n    protected void snooze(NotificationRecord record, String contextId) {\n        if (contextId != null) {\n            synchronized (mLock) {\n                mPersistedSnoozedNotificationsWithContext.put(\n                        getTrimmedString(record.getKey()),\n                        getTrimmedString(contextId)\n                );\n            }\n        }\n        snooze(record);\n    }\n\n    private void snooze(NotificationRecord record) {\n        if (DEBUG) {\n            Slog.d(TAG, \"Snoozing \" + record.getKey());\n        }\n        synchronized (mLock) {\n            mSnoozedNotifications.put(record.getKey(), record);\n        }\n    }\n\n    private String getTrimmedString(String key) {\n        if (key != null && key.length() > MAX_STRING_LENGTH) {\n            return key.substring(0, MAX_STRING_LENGTH);\n        }\n        return key;\n    }\n\n    protected boolean cancel(int userId, String pkg, String tag, int id) {\n        synchronized (mLock) {\n            final Set<Map.Entry<String, NotificationRecord>> records =\n                    mSnoozedNotifications.entrySet();\n            for (Map.Entry<String, NotificationRecord> record : records) {\n                final StatusBarNotification sbn = record.getValue().getSbn();\n                if (sbn.getPackageName().equals(pkg) && sbn.getUserId() == userId\n                        && Objects.equals(sbn.getTag(), tag) && sbn.getId() == id) {\n                    record.getValue().isCanceled = true;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    protected void cancel(int userId, boolean includeCurrentProfiles) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.size() == 0) {\n                return;\n            }\n            IntArray userIds = new IntArray();\n            userIds.add(userId);\n            if (includeCurrentProfiles) {\n                userIds = mUserProfiles.getCurrentProfileIds();\n            }\n            for (NotificationRecord r : mSnoozedNotifications.values()) {\n                if (userIds.binarySearch(r.getUserId()) >= 0) {\n                    r.isCanceled = true;\n                }\n            }\n        }\n    }\n\n    protected boolean cancel(int userId, String pkg) {\n        synchronized (mLock) {\n            int n = mSnoozedNotifications.size();\n            for (int i = 0; i < n; i++) {\n                final NotificationRecord r = mSnoozedNotifications.valueAt(i);\n                if (r.getSbn().getPackageName().equals(pkg) && r.getUserId() == userId) {\n                    r.isCanceled = true;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Updates the notification record so the most up to date information is shown on re-post.\n     */\n    protected void update(int userId, NotificationRecord record) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.containsKey(record.getKey())) {\n                mSnoozedNotifications.put(record.getKey(), record);\n            }\n        }\n    }\n\n    protected void repost(String key, boolean muteOnReturn) {\n        synchronized (mLock) {\n            final NotificationRecord r = mSnoozedNotifications.get(key);\n            if (r != null) {\n                repost(key, r.getUserId(), muteOnReturn);\n            }\n        }\n    }\n\n    protected void repost(String key, int userId, boolean muteOnReturn) {\n        final String trimmedKey = getTrimmedString(key);\n\n        NotificationRecord record;\n        synchronized (mLock) {\n            mPersistedSnoozedNotifications.remove(trimmedKey);\n            mPersistedSnoozedNotificationsWithContext.remove(trimmedKey);\n            record = mSnoozedNotifications.remove(key);\n        }\n\n        if (record != null && !record.isCanceled) {\n            final PendingIntent pi = createPendingIntent(record.getKey());\n            mAm.cancel(pi);\n            MetricsLogger.action(record.getLogMaker()\n                    .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                    .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n            mCallback.repost(record.getUserId(), record, muteOnReturn);\n        }\n    }\n\n    protected void repostGroupSummary(String pkg, int userId, String groupKey) {\n        synchronized (mLock) {\n            String groupSummaryKey = null;\n            int n = mSnoozedNotifications.size();\n            for (int i = 0; i < n; i++) {\n                final NotificationRecord potentialGroupSummary = mSnoozedNotifications.valueAt(i);\n                if (potentialGroupSummary.getSbn().getPackageName().equals(pkg)\n                        && potentialGroupSummary.getUserId() == userId\n                        && potentialGroupSummary.getSbn().isGroup()\n                        && potentialGroupSummary.getNotification().isGroupSummary()\n                        && groupKey.equals(potentialGroupSummary.getGroupKey())) {\n                    groupSummaryKey = potentialGroupSummary.getKey();\n                    break;\n                }\n            }\n\n            if (groupSummaryKey != null) {\n                NotificationRecord record = mSnoozedNotifications.remove(groupSummaryKey);\n                String trimmedKey = getTrimmedString(groupSummaryKey);\n                mPersistedSnoozedNotificationsWithContext.remove(trimmedKey);\n                mPersistedSnoozedNotifications.remove(trimmedKey);\n\n                if (record != null && !record.isCanceled) {\n                    Runnable runnable = () -> {\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n                        mCallback.repost(record.getUserId(), record, false);\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    protected void clearData(int userId, String pkg) {\n        synchronized (mLock) {\n            int n = mSnoozedNotifications.size();\n            for (int i = n - 1; i >= 0; i--) {\n                final NotificationRecord record = mSnoozedNotifications.valueAt(i);\n                if (record.getUserId() == userId && record.getSbn().getPackageName().equals(pkg)) {\n                    mSnoozedNotifications.removeAt(i);\n                    String trimmedKey = getTrimmedString(record.getKey());\n                    mPersistedSnoozedNotificationsWithContext.remove(trimmedKey);\n                    mPersistedSnoozedNotifications.remove(trimmedKey);\n                    Runnable runnable = () -> {\n                        final PendingIntent pi = createPendingIntent(record.getKey());\n                        mAm.cancel(pi);\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_DISMISS));\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    protected void clearData(int userId) {\n        synchronized (mLock) {\n            int n = mSnoozedNotifications.size();\n            for (int i = n - 1; i >= 0; i--) {\n                final NotificationRecord record = mSnoozedNotifications.valueAt(i);\n                if (record.getUserId() == userId) {\n                    mSnoozedNotifications.removeAt(i);\n                    String trimmedKey = getTrimmedString(record.getKey());\n                    mPersistedSnoozedNotificationsWithContext.remove(trimmedKey);\n                    mPersistedSnoozedNotifications.remove(trimmedKey);\n\n                    Runnable runnable = () -> {\n                        final PendingIntent pi = createPendingIntent(record.getKey());\n                        mAm.cancel(pi);\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_DISMISS));\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    private PendingIntent createPendingIntent(String key) {\n        return PendingIntent.getBroadcast(mContext,\n                REQUEST_CODE_REPOST,\n                new Intent(REPOST_ACTION)\n                        .setPackage(PackageManagerService.PLATFORM_PACKAGE_NAME)\n                        .setData(new Uri.Builder().scheme(REPOST_SCHEME).appendPath(key).build())\n                        .addFlags(Intent.FLAG_RECEIVER_FOREGROUND)\n                        .putExtra(EXTRA_KEY, key),\n                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n    }\n\n    public void scheduleRepostsForPersistedNotifications(long currentTime) {\n        synchronized (mLock) {\n            for (int i = 0; i < mPersistedSnoozedNotifications.size(); i++) {\n                String key = mPersistedSnoozedNotifications.keyAt(i);\n                Long time = mPersistedSnoozedNotifications.valueAt(i);\n                if (time != null && time > currentTime) {\n                    scheduleRepostAtTime(key, time);\n                }\n            }\n        }\n    }\n\n    private void scheduleRepost(String key, long duration) {\n        scheduleRepostAtTime(key, System.currentTimeMillis() + duration);\n    }\n\n    private void scheduleRepostAtTime(String key, long time) {\n        Runnable runnable = () -> {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final PendingIntent pi = createPendingIntent(key);\n                mAm.cancel(pi);\n                if (DEBUG) Slog.d(TAG, \"Scheduling evaluate for \" + new Date(time));\n                mAm.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pi);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        };\n        runnable.run();\n    }\n\n    public void dump(PrintWriter pw, NotificationManagerService.DumpFilter filter) {\n        synchronized (mLock) {\n            pw.println(\"\\n  Snoozed notifications:\");\n            for (String key : mSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + key);\n            }\n            pw.println(\"\\n Pending snoozed notifications\");\n            for (String key : mPersistedSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + key + \" until: \" + mPersistedSnoozedNotifications.get(key));\n            }\n        }\n    }\n\n    protected void writeXml(TypedXmlSerializer out) throws IOException {\n        synchronized (mLock) {\n            final long currentTime = System.currentTimeMillis();\n            out.startTag(null, XML_TAG_NAME);\n            writeXml(out, mPersistedSnoozedNotifications, XML_SNOOZED_NOTIFICATION,\n                    value -> {\n                        if (value < currentTime) {\n                            return;\n                        }\n                        out.attributeLong(null, XML_SNOOZED_NOTIFICATION_TIME,\n                                value);\n                    });\n            writeXml(out, mPersistedSnoozedNotificationsWithContext,\n                    XML_SNOOZED_NOTIFICATION_CONTEXT,\n                    value -> {\n                        out.attribute(null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID,\n                                value);\n                    });\n            out.endTag(null, XML_TAG_NAME);\n        }\n    }\n\n    private interface Inserter<T> {\n        void insert(T t) throws IOException;\n    }\n\n    private <T> void writeXml(TypedXmlSerializer out, ArrayMap<String, T> targets, String tag,\n            Inserter<T> attributeInserter) throws IOException {\n        for (int j = 0; j < targets.size(); j++) {\n            String key = targets.keyAt(j);\n            // T is a String (snoozed until context) or Long (snoozed until time)\n            T value = targets.valueAt(j);\n\n            out.startTag(null, tag);\n\n            attributeInserter.insert(value);\n\n            out.attributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL,\n                    XML_SNOOZED_NOTIFICATION_VERSION);\n            out.attribute(null, XML_SNOOZED_NOTIFICATION_KEY, key);\n\n            out.endTag(null, tag);\n        }\n    }\n\n    protected void readXml(TypedXmlPullParser parser, long currentTime)\n            throws XmlPullParserException, IOException {\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {\n            String tag = parser.getName();\n            if (type == XmlPullParser.END_TAG\n                    && XML_TAG_NAME.equals(tag)) {\n                break;\n            }\n            if (type == XmlPullParser.START_TAG\n                    && (XML_SNOOZED_NOTIFICATION.equals(tag)\n                        || tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT))\n                    && parser.getAttributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL, -1)\n                        == XML_SNOOZED_NOTIFICATION_VERSION) {\n                try {\n                    final String key = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_KEY);\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION)) {\n                        final Long time = parser.getAttributeLong(\n                                null, XML_SNOOZED_NOTIFICATION_TIME, 0);\n                        if (time > currentTime) { //only read new stuff\n                            synchronized (mLock) {\n                                mPersistedSnoozedNotifications.put(key, time);\n                            }\n                        }\n                    }\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT)) {\n                        final String creationId = parser.getAttributeValue(\n                                null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID);\n                        synchronized (mLock) {\n                            mPersistedSnoozedNotificationsWithContext.put(key, creationId);\n                        }\n                    }\n                } catch (Exception e) {\n                    Slog.e(TAG,  \"Exception in reading snooze data from policy xml\", e);\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void setAlarmManager(AlarmManager am) {\n        mAm = am;\n    }\n\n    protected interface Callback {\n        void repost(int userId, NotificationRecord r, boolean muteOnReturn);\n    }\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (DEBUG) {\n                Slog.d(TAG, \"Reposting notification\");\n            }\n            if (REPOST_ACTION.equals(intent.getAction())) {\n                repost(intent.getStringExtra(EXTRA_KEY), intent.getIntExtra(EXTRA_USER_ID,\n                        UserHandle.USER_SYSTEM), false);\n            }\n        }\n    };\n}\n```",
            "upstream_file_tokens": {
              "openai": 4582,
              "general": {
                "word_based": 1807,
                "char_based": 5787
              },
              "gemini": 5452
            },
            "downstream_file_content": "```java\n/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.android.server.notification;\n\nimport android.annotation.NonNull;\nimport android.annotation.UserIdInt;\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.service.notification.StatusBarNotification;\nimport android.util.ArrayMap;\nimport android.util.IntArray;\nimport android.util.Log;\nimport android.util.Slog;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto;\nimport com.android.internal.util.XmlUtils;\nimport com.android.server.pm.PackageManagerService;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * NotificationManagerService helper for handling snoozed notifications.\n */\npublic class SnoozeHelper {\n    public static final int XML_SNOOZED_NOTIFICATION_VERSION = 1;\n\n    static final int CONCURRENT_SNOOZE_LIMIT = 500;\n\n    // A safe size for strings to be put in persistent storage, to avoid breaking the XML write.\n    static final int MAX_STRING_LENGTH = 1000;\n\n    protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n\n    private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT = \"context\";\n    private static final String XML_SNOOZED_NOTIFICATION_PKG = \"pkg\";\n    private static final String XML_SNOOZED_NOTIFICATION_USER_ID = \"user-id\";\n    private static final String XML_SNOOZED_NOTIFICATION_KEY = \"key\";\n    //the time the snoozed notification should be reposted\n    private static final String XML_SNOOZED_NOTIFICATION_TIME = \"time\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT_ID = \"id\";\n    private static final String XML_SNOOZED_NOTIFICATION_VERSION_LABEL = \"version\";\n\n\n    private static final String TAG = \"SnoozeHelper\";\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n    private static final String INDENT = \"    \";\n\n    private static final String REPOST_ACTION = SnoozeHelper.class.getSimpleName() + \".EVALUATE\";\n    private static final int REQUEST_CODE_REPOST = 1;\n    private static final String REPOST_SCHEME = \"repost\";\n    static final String EXTRA_KEY = \"key\";\n    private static final String EXTRA_USER_ID = \"userId\";\n\n    private final Context mContext;\n    private AlarmManager mAm;\n    private final ManagedServices.UserProfiles mUserProfiles;\n\n    // User id | package name : notification key : record.\n    private ArrayMap<String, ArrayMap<String, NotificationRecord>>\n            mSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : time-milliseconds .\n    // This member stores persisted snoozed notification trigger times. it persists through reboots\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, Long>>\n            mPersistedSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : creation ID .\n    // This member stores persisted snoozed notification trigger context for the assistant\n    // it persists through reboots.\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, String>>\n            mPersistedSnoozedNotificationsWithContext = new ArrayMap<>();\n    // notification key : package.\n    private ArrayMap<String, String> mPackages = new ArrayMap<>();\n    // key : userId\n    private ArrayMap<String, Integer> mUsers = new ArrayMap<>();\n    private Callback mCallback;\n\n    private final Object mLock = new Object();\n\n    public SnoozeHelper(Context context, Callback callback,\n            ManagedServices.UserProfiles userProfiles) {\n        mContext = context;\n        IntentFilter filter = new IntentFilter(REPOST_ACTION);\n        filter.addDataScheme(REPOST_SCHEME);\n        mContext.registerReceiver(mBroadcastReceiver, filter);\n        mAm = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mCallback = callback;\n        mUserProfiles = userProfiles;\n    }\n\n    private String getPkgKey(@UserIdInt int userId, String pkg) {\n        return userId + \"|\" + pkg;\n    }\n\n    void cleanupPersistedContext(String key){\n        synchronized (mLock) {\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            removeRecordLocked(pkg, key, userId, mPersistedSnoozedNotificationsWithContext);\n        }\n    }\n\n    protected boolean canSnooze(int numberToSnooze) {\n        synchronized (mLock) {\n            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @NonNull\n    protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n        Long time = null;\n        synchronized (mLock) {\n           ArrayMap<String, Long> snoozed =\n                   mPersistedSnoozedNotifications.get(getPkgKey(userId, pkg));\n           if (snoozed != null) {\n               time = snoozed.get(getTrimmedString(key));\n           }\n        }\n        if (time == null) {\n            time = 0L;\n        }\n        return time;\n    }\n\n    protected String getSnoozeContextForUnpostedNotification(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            ArrayMap<String, String> snoozed =\n                    mPersistedSnoozedNotificationsWithContext.get(getPkgKey(userId, pkg));\n            if (snoozed != null) {\n                return snoozed.get(getTrimmedString(key));\n            }\n        }\n        return null;\n    }\n\n    protected boolean isSnoozed(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            return mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))\n                    && mSnoozedNotifications.get(getPkgKey(userId, pkg)).containsKey(key);\n        }\n    }\n\n    protected Collection<NotificationRecord> getSnoozed(int userId, String pkg) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))) {\n                return mSnoozedNotifications.get(getPkgKey(userId, pkg)).values();\n            }\n        }\n        return Collections.EMPTY_LIST;\n    }\n\n    @NonNull\n    ArrayList<NotificationRecord> getNotifications(String pkg,\n            String groupKey, Integer userId) {\n        ArrayList<NotificationRecord> records =  new ArrayList<>();\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> allRecords =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (allRecords != null) {\n                for (int i = 0; i < allRecords.size(); i++) {\n                    NotificationRecord r = allRecords.valueAt(i);\n                    String currentGroupKey = r.getSbn().getGroup();\n                    if (Objects.equals(currentGroupKey, groupKey)) {\n                        records.add(r);\n                    }\n                }\n            }\n        }\n        return records;\n    }\n\n    protected NotificationRecord getNotification(String key) {\n        synchronized (mLock) {\n            if (!mUsers.containsKey(key) || !mPackages.containsKey(key)) {\n                Slog.w(TAG, \"Snoozed data sets no longer agree for \" + key);\n                return null;\n            }\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            ArrayMap<String, NotificationRecord> snoozed =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (snoozed == null) {\n                return null;\n            }\n            return snoozed.get(key);\n        }\n    }\n\n    protected @NonNull List<NotificationRecord> getSnoozed() {\n        synchronized (mLock) {\n            // caller filters records based on the current user profiles and listener access, so just\n            // return everything\n            List<NotificationRecord> snoozed = new ArrayList<>();\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                snoozed.addAll(snoozedRecords.values());\n            }\n            return snoozed;\n        }\n    }\n\n    /**\n     * Snoozes a notification and schedules an alarm to repost at that time.\n     */\n    protected void snooze(NotificationRecord record, long duration) {\n        String pkg = record.getSbn().getPackageName();\n        String key = record.getKey();\n        int userId = record.getUser().getIdentifier();\n\n        snooze(record);\n        scheduleRepost(pkg, key, userId, duration);\n        Long activateAt = System.currentTimeMillis() + duration;\n        synchronized (mLock) {\n            storeRecordLocked(pkg, getTrimmedString(key), userId, mPersistedSnoozedNotifications,\n                    activateAt);\n        }\n    }\n\n    /**\n     * Records a snoozed notification.\n     */\n    protected void snooze(NotificationRecord record, String contextId) {\n        int userId = record.getUser().getIdentifier();\n        if (contextId != null) {\n            synchronized (mLock) {\n                storeRecordLocked(record.getSbn().getPackageName(),\n                        getTrimmedString(record.getKey()),\n                        userId, mPersistedSnoozedNotificationsWithContext,\n                        getTrimmedString(contextId));\n            }\n        }\n        snooze(record);\n    }\n\n    private void snooze(NotificationRecord record) {\n        int userId = record.getUser().getIdentifier();\n        if (DEBUG) {\n            Slog.d(TAG, \"Snoozing \" + record.getKey());\n        }\n        synchronized (mLock) {\n            storeRecordLocked(record.getSbn().getPackageName(), record.getKey(),\n                    userId, mSnoozedNotifications, record);\n        }\n    }\n\n    private String getTrimmedString(String key) {\n        if (key != null && key.length() > MAX_STRING_LENGTH) {\n            return key.substring(0, MAX_STRING_LENGTH);\n        }\n        return key;\n    }\n\n    private <T> void storeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets, T object) {\n\n        mPackages.put(key, pkg);\n        mUsers.put(key, userId);\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            keyToValue = new ArrayMap<>();\n        }\n        keyToValue.put(key, object);\n        targets.put(getPkgKey(userId, pkg), keyToValue);\n    }\n\n    private <T> T removeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets) {\n        T object = null;\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            return null;\n        }\n        object = keyToValue.remove(key);\n        if (keyToValue.size() == 0) {\n            targets.remove(getPkgKey(userId, pkg));\n        }\n        return object;\n    }\n\n    protected boolean cancel(int userId, String pkg, String tag, int id) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsForPkg =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsForPkg != null) {\n                final Set<Map.Entry<String, NotificationRecord>> records = recordsForPkg.entrySet();\n                for (Map.Entry<String, NotificationRecord> record : records) {\n                    final StatusBarNotification sbn = record.getValue().getSbn();\n                    if (Objects.equals(sbn.getTag(), tag) && sbn.getId() == id) {\n                        record.getValue().isCanceled = true;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    protected void cancel(int userId, boolean includeCurrentProfiles) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.size() == 0) {\n                return;\n            }\n            IntArray userIds = new IntArray();\n            userIds.add(userId);\n            if (includeCurrentProfiles) {\n                userIds = mUserProfiles.getCurrentProfileIds();\n            }\n            for (ArrayMap<String, NotificationRecord> snoozedRecords : mSnoozedNotifications.values()) {\n                for (NotificationRecord r : snoozedRecords.values()) {\n                    if (userIds.binarySearch(r.getUserId()) >= 0) {\n                        r.isCanceled = true;\n                    }\n                }\n            }\n        }\n    }\n\n    protected boolean cancel(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return false;\n            }\n            int N = records.size();\n            for (int i = 0; i < N; i++) {\n                records.valueAt(i).isCanceled = true;\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Updates the notification record so the most up to date information is shown on re-post.\n     */\n    protected void update(int userId, NotificationRecord record) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, record.getSbn().getPackageName()));\n            if (records == null) {\n                return;\n            }\n            records.put(record.getKey(), record);\n        }\n    }\n\n    protected void repost(String key, boolean muteOnReturn) {\n        synchronized (mLock) {\n            Integer userId = mUsers.get(key);\n            if (userId != null) {\n                repost(key, userId, muteOnReturn);\n            }\n        }\n    }\n\n    protected void repost(String key, int userId, boolean muteOnReturn) {\n        final String trimmedKey = getTrimmedString(key);\n\n        NotificationRecord record;\n        synchronized (mLock) {\n            final String pkg = mPackages.remove(key);\n            mUsers.remove(key);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            record = records.remove(key);\n\n        }\n\n        if (record != null && !record.isCanceled) {\n            final PendingIntent pi = createPendingIntent(\n                    record.getSbn().getPackageName(), record.getKey(), userId);\n            mAm.cancel(pi);\n            MetricsLogger.action(record.getLogMaker()\n                    .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                    .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n            mCallback.repost(userId, record, muteOnReturn);\n        }\n    }\n\n    protected void repostGroupSummary(String pkg, int userId, String groupKey) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsByKey\n                    = mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsByKey == null) {\n                return;\n            }\n\n            String groupSummaryKey = null;\n            int N = recordsByKey.size();\n            for (int i = 0; i < N; i++) {\n                final NotificationRecord potentialGroupSummary = recordsByKey.valueAt(i);\n                if (potentialGroupSummary.getSbn().isGroup()\n                        && potentialGroupSummary.getNotification().isGroupSummary()\n                        && groupKey.equals(potentialGroupSummary.getGroupKey())) {\n                    groupSummaryKey = potentialGroupSummary.getKey();\n                    break;\n                }\n            }\n\n            if (groupSummaryKey != null) {\n                NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                mPackages.remove(groupSummaryKey);\n                mUsers.remove(groupSummaryKey);\n\n                if (record != null && !record.isCanceled) {\n                    Runnable runnable = () -> {\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n                        mCallback.repost(userId, record, false);\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    protected void clearData(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            for (int i = records.size() - 1; i >= 0; i--) {\n                final NotificationRecord r = records.removeAt(i);\n                if (r != null) {\n                    mPackages.remove(r.getKey());\n                    mUsers.remove(r.getKey());\n                    Runnable runnable = () -> {\n                        final PendingIntent pi = createPendingIntent(pkg, r.getKey(), userId);\n                        mAm.cancel(pi);\n                        MetricsLogger.action(r.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_DISMISS));\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    private PendingIntent createPendingIntent(String pkg, String key, int userId) {\n        return PendingIntent.getBroadcast(mContext,\n                REQUEST_CODE_REPOST,\n                new Intent(REPOST_ACTION)\n                        .setPackage(PackageManagerService.PLATFORM_PACKAGE_NAME)\n                        .setData(new Uri.Builder().scheme(REPOST_SCHEME).appendPath(key).build())\n                        .addFlags(Intent.FLAG_RECEIVER_FOREGROUND)\n                        .putExtra(EXTRA_KEY, key)\n                        .putExtra(EXTRA_USER_ID, userId),\n                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n    }\n\n    public void scheduleRepostsForPersistedNotifications(long currentTime) {\n        synchronized (mLock) {\n            for (ArrayMap<String, Long> snoozed : mPersistedSnoozedNotifications.values()) {\n                for (int i = 0; i < snoozed.size(); i++) {\n                    String key = snoozed.keyAt(i);\n                    Long time = snoozed.valueAt(i);\n                    String pkg = mPackages.get(key);\n                    Integer userId = mUsers.get(key);\n                    if (time == null || pkg == null || userId == null) {\n                        Slog.w(TAG, \"data out of sync: \" + time + \"|\" + pkg + \"|\" + userId);\n                        continue;\n                    }\n                    if (time != null && time > currentTime) {\n                        scheduleRepostAtTime(pkg, key, userId, time);\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleRepost(String pkg, String key, int userId, long duration) {\n        scheduleRepostAtTime(pkg, key, userId, System.currentTimeMillis() + duration);\n    }\n\n    private void scheduleRepostAtTime(String pkg, String key, int userId, long time) {\n        Runnable runnable = () -> {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final PendingIntent pi = createPendingIntent(pkg, key, userId);\n                mAm.cancel(pi);\n                if (DEBUG) Slog.d(TAG, \"Scheduling evaluate for \" + new Date(time));\n                mAm.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pi);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        };\n        runnable.run();\n    }\n\n    public void dump(PrintWriter pw, NotificationManagerService.DumpFilter filter) {\n        synchronized (mLock) {\n            pw.println(\"\\n  Snoozed notifications:\");\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.println(key);\n                }\n            }\n            pw.println(\"\\n Pending snoozed notifications\");\n            for (String userPkgKey : mPersistedSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, Long> snoozedRecords =\n                        mPersistedSnoozedNotifications.get(userPkgKey);\n                if (snoozedRecords == null) {\n                    continue;\n                }\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(key);\n                    pw.print(INDENT);\n                    pw.println(snoozedRecords.get(key));\n                }\n            }\n        }\n    }\n\n    protected void writeXml(TypedXmlSerializer out) throws IOException {\n        synchronized (mLock) {\n            final long currentTime = System.currentTimeMillis();\n            out.startTag(null, XML_TAG_NAME);\n            writeXml(out, mPersistedSnoozedNotifications, XML_SNOOZED_NOTIFICATION,\n                    value -> {\n                        if (value < currentTime) {\n                            return;\n                        }\n                        out.attributeLong(null, XML_SNOOZED_NOTIFICATION_TIME,\n                                value);\n                    });\n            writeXml(out, mPersistedSnoozedNotificationsWithContext,\n                    XML_SNOOZED_NOTIFICATION_CONTEXT,\n                    value -> {\n                        out.attribute(null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID,\n                                value);\n                    });\n            out.endTag(null, XML_TAG_NAME);\n        }\n    }\n\n    private interface Inserter<T> {\n        void insert(T t) throws IOException;\n    }\n\n    private <T> void writeXml(TypedXmlSerializer out,\n            ArrayMap<String, ArrayMap<String, T>> targets, String tag,\n            Inserter<T> attributeInserter)\n            throws IOException {\n        final int M = targets.size();\n        for (int i = 0; i < M; i++) {\n            // T is a String (snoozed until context) or Long (snoozed until time)\n            ArrayMap<String, T> keyToValue = targets.valueAt(i);\n            for (int j = 0; j < keyToValue.size(); j++) {\n                String key = keyToValue.keyAt(j);\n                T value = keyToValue.valueAt(j);\n                String pkg = mPackages.get(key);\n                Integer userId = mUsers.get(key);\n\n                if (pkg == null || userId == null) {\n                    Slog.w(TAG, \"pkg \" + pkg + \" or user \" + userId + \" missing for \" + key);\n                    continue;\n                }\n\n                out.startTag(null, tag);\n\n                attributeInserter.insert(value);\n\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL,\n                        XML_SNOOZED_NOTIFICATION_VERSION);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_KEY, key);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_PKG, pkg);\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_USER_ID, userId);\n\n                out.endTag(null, tag);\n            }\n        }\n    }\n\n    protected void readXml(TypedXmlPullParser parser, long currentTime)\n            throws XmlPullParserException, IOException {\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {\n            String tag = parser.getName();\n            if (type == XmlPullParser.END_TAG\n                    && XML_TAG_NAME.equals(tag)) {\n                break;\n            }\n            if (type == XmlPullParser.START_TAG\n                    && (XML_SNOOZED_NOTIFICATION.equals(tag)\n                        || tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT))\n                    && parser.getAttributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL, -1)\n                        == XML_SNOOZED_NOTIFICATION_VERSION) {\n                try {\n                    final String key = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_KEY);\n                    final String pkg = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_PKG);\n                    final int userId = parser.getAttributeInt(\n                            null, XML_SNOOZED_NOTIFICATION_USER_ID, UserHandle.USER_ALL);\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION)) {\n                        final Long time = parser.getAttributeLong(\n                                null, XML_SNOOZED_NOTIFICATION_TIME, 0);\n                        if (time > currentTime) { //only read new stuff\n                            synchronized (mLock) {\n                                storeRecordLocked(\n                                        pkg, key, userId, mPersistedSnoozedNotifications, time);\n                            }\n                        }\n                    }\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT)) {\n                        final String creationId = parser.getAttributeValue(\n                                null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID);\n                        synchronized (mLock) {\n                            storeRecordLocked(\n                                    pkg, key, userId, mPersistedSnoozedNotificationsWithContext,\n                                    creationId);\n                        }\n                    }\n                } catch (Exception e) {\n                    Slog.e(TAG,  \"Exception in reading snooze data from policy xml\", e);\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void setAlarmManager(AlarmManager am) {\n        mAm = am;\n    }\n\n    protected interface Callback {\n        void repost(int userId, NotificationRecord r, boolean muteOnReturn);\n    }\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (DEBUG) {\n                Slog.d(TAG, \"Reposting notification\");\n            }\n            if (REPOST_ACTION.equals(intent.getAction())) {\n                repost(intent.getStringExtra(EXTRA_KEY), intent.getIntExtra(EXTRA_USER_ID,\n                        UserHandle.USER_SYSTEM), false);\n            }\n        }\n    };\n}\n```",
            "downstream_file_tokens": {
              "openai": 5729,
              "general": {
                "word_based": 2301,
                "char_based": 7141
              },
              "gemini": 6865
            },
            "downstream_file_content_ground_truth": "/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.android.server.notification;\n\nimport android.annotation.NonNull;\nimport android.annotation.UserIdInt;\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.service.notification.StatusBarNotification;\nimport android.util.ArrayMap;\nimport android.util.IntArray;\nimport android.util.Log;\nimport android.util.Slog;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto;\nimport com.android.internal.util.XmlUtils;\nimport com.android.server.pm.PackageManagerService;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * NotificationManagerService helper for handling snoozed notifications.\n */\npublic class SnoozeHelper {\n    public static final int XML_SNOOZED_NOTIFICATION_VERSION = 1;\n\n    static final int CONCURRENT_SNOOZE_LIMIT = 500;\n\n    // A safe size for strings to be put in persistent storage, to avoid breaking the XML write.\n    static final int MAX_STRING_LENGTH = 1000;\n\n    protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n\n    private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT = \"context\";\n    private static final String XML_SNOOZED_NOTIFICATION_PKG = \"pkg\";\n    private static final String XML_SNOOZED_NOTIFICATION_USER_ID = \"user-id\";\n    private static final String XML_SNOOZED_NOTIFICATION_KEY = \"key\";\n    //the time the snoozed notification should be reposted\n    private static final String XML_SNOOZED_NOTIFICATION_TIME = \"time\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT_ID = \"id\";\n    private static final String XML_SNOOZED_NOTIFICATION_VERSION_LABEL = \"version\";\n\n\n    private static final String TAG = \"SnoozeHelper\";\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n    private static final String INDENT = \"    \";\n\n    private static final String REPOST_ACTION = SnoozeHelper.class.getSimpleName() + \".EVALUATE\";\n    private static final int REQUEST_CODE_REPOST = 1;\n    private static final String REPOST_SCHEME = \"repost\";\n    static final String EXTRA_KEY = \"key\";\n    private static final String EXTRA_USER_ID = \"userId\";\n\n    private final Context mContext;\n    private AlarmManager mAm;\n    private final ManagedServices.UserProfiles mUserProfiles;\n\n    // User id | package name : notification key : record.\n    private ArrayMap<String, ArrayMap<String, NotificationRecord>>\n            mSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : time-milliseconds .\n    // This member stores persisted snoozed notification trigger times. it persists through reboots\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, Long>>\n            mPersistedSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : creation ID .\n    // This member stores persisted snoozed notification trigger context for the assistant\n    // it persists through reboots.\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, String>>\n            mPersistedSnoozedNotificationsWithContext = new ArrayMap<>();\n    // notification key : package.\n    private ArrayMap<String, String> mPackages = new ArrayMap<>();\n    // key : userId\n    private ArrayMap<String, Integer> mUsers = new ArrayMap<>();\n    private Callback mCallback;\n\n    private final Object mLock = new Object();\n\n    public SnoozeHelper(Context context, Callback callback,\n            ManagedServices.UserProfiles userProfiles) {\n        mContext = context;\n        IntentFilter filter = new IntentFilter(REPOST_ACTION);\n        filter.addDataScheme(REPOST_SCHEME);\n        mContext.registerReceiver(mBroadcastReceiver, filter);\n        mAm = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mCallback = callback;\n        mUserProfiles = userProfiles;\n    }\n\n    private String getPkgKey(@UserIdInt int userId, String pkg) {\n        return userId + \"|\" + pkg;\n    }\n\n    void cleanupPersistedContext(String key){\n        synchronized (mLock) {\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            removeRecordLocked(pkg, key, userId, mPersistedSnoozedNotificationsWithContext);\n        }\n    }\n\n    protected boolean canSnooze(int numberToSnooze) {\n        synchronized (mLock) {\n            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n                || (countPersistedNotificationsLocked() + numberToSnooze)\n                > CONCURRENT_SNOOZE_LIMIT) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int countPersistedNotificationsLocked() {\n        int numNotifications = 0;\n        for (ArrayMap<String, String> persistedWithContext :\n                mPersistedSnoozedNotificationsWithContext.values()) {\n            numNotifications += persistedWithContext.size();\n        }\n        for (ArrayMap<String, Long> persistedWithDuration :\n                mPersistedSnoozedNotifications.values()) {\n            numNotifications += persistedWithDuration.size();\n        }\n        return numNotifications;\n    }\n\n\n    @NonNull\n    protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n        Long time = null;\n        synchronized (mLock) {\n           ArrayMap<String, Long> snoozed =\n                   mPersistedSnoozedNotifications.get(getPkgKey(userId, pkg));\n           if (snoozed != null) {\n               time = snoozed.get(getTrimmedString(key));\n           }\n        }\n        if (time == null) {\n            time = 0L;\n        }\n        return time;\n    }\n\n    protected String getSnoozeContextForUnpostedNotification(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            ArrayMap<String, String> snoozed =\n                    mPersistedSnoozedNotificationsWithContext.get(getPkgKey(userId, pkg));\n            if (snoozed != null) {\n                return snoozed.get(getTrimmedString(key));\n            }\n        }\n        return null;\n    }\n\n    protected boolean isSnoozed(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            return mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))\n                    && mSnoozedNotifications.get(getPkgKey(userId, pkg)).containsKey(key);\n        }\n    }\n\n    protected Collection<NotificationRecord> getSnoozed(int userId, String pkg) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))) {\n                return mSnoozedNotifications.get(getPkgKey(userId, pkg)).values();\n            }\n        }\n        return Collections.EMPTY_LIST;\n    }\n\n    @NonNull\n    ArrayList<NotificationRecord> getNotifications(String pkg,\n            String groupKey, Integer userId) {\n        ArrayList<NotificationRecord> records =  new ArrayList<>();\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> allRecords =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (allRecords != null) {\n                for (int i = 0; i < allRecords.size(); i++) {\n                    NotificationRecord r = allRecords.valueAt(i);\n                    String currentGroupKey = r.getSbn().getGroup();\n                    if (Objects.equals(currentGroupKey, groupKey)) {\n                        records.add(r);\n                    }\n                }\n            }\n        }\n        return records;\n    }\n\n    protected NotificationRecord getNotification(String key) {\n        synchronized (mLock) {\n            if (!mUsers.containsKey(key) || !mPackages.containsKey(key)) {\n                Slog.w(TAG, \"Snoozed data sets no longer agree for \" + key);\n                return null;\n            }\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            ArrayMap<String, NotificationRecord> snoozed =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (snoozed == null) {\n                return null;\n            }\n            return snoozed.get(key);\n        }\n    }\n\n    protected @NonNull List<NotificationRecord> getSnoozed() {\n        synchronized (mLock) {\n            // caller filters records based on the current user profiles and listener access, so just\n            // return everything\n            List<NotificationRecord> snoozed = new ArrayList<>();\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                snoozed.addAll(snoozedRecords.values());\n            }\n            return snoozed;\n        }\n    }\n\n    /**\n     * Snoozes a notification and schedules an alarm to repost at that time.\n     */\n    protected void snooze(NotificationRecord record, long duration) {\n        String pkg = record.getSbn().getPackageName();\n        String key = record.getKey();\n        int userId = record.getUser().getIdentifier();\n\n        snooze(record);\n        scheduleRepost(pkg, key, userId, duration);\n        Long activateAt = System.currentTimeMillis() + duration;\n        synchronized (mLock) {\n            storeRecordLocked(pkg, getTrimmedString(key), userId, mPersistedSnoozedNotifications,\n                    activateAt);\n        }\n    }\n\n    /**\n     * Records a snoozed notification.\n     */\n    protected void snooze(NotificationRecord record, String contextId) {\n        int userId = record.getUser().getIdentifier();\n        if (contextId != null) {\n            synchronized (mLock) {\n                storeRecordLocked(record.getSbn().getPackageName(),\n                        getTrimmedString(record.getKey()),\n                        userId, mPersistedSnoozedNotificationsWithContext,\n                        getTrimmedString(contextId));\n            }\n        }\n        snooze(record);\n    }\n\n    private void snooze(NotificationRecord record) {\n        int userId = record.getUser().getIdentifier();\n        if (DEBUG) {\n            Slog.d(TAG, \"Snoozing \" + record.getKey());\n        }\n        synchronized (mLock) {\n            storeRecordLocked(record.getSbn().getPackageName(), record.getKey(),\n                    userId, mSnoozedNotifications, record);\n        }\n    }\n\n    private String getTrimmedString(String key) {\n        if (key != null && key.length() > MAX_STRING_LENGTH) {\n            return key.substring(0, MAX_STRING_LENGTH);\n        }\n        return key;\n    }\n\n    private <T> void storeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets, T object) {\n\n        mPackages.put(key, pkg);\n        mUsers.put(key, userId);\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            keyToValue = new ArrayMap<>();\n        }\n        keyToValue.put(key, object);\n        targets.put(getPkgKey(userId, pkg), keyToValue);\n    }\n\n    private <T> T removeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets) {\n        T object = null;\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            return null;\n        }\n        object = keyToValue.remove(key);\n        if (keyToValue.size() == 0) {\n            targets.remove(getPkgKey(userId, pkg));\n        }\n        return object;\n    }\n\n    protected boolean cancel(int userId, String pkg, String tag, int id) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsForPkg =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsForPkg != null) {\n                final Set<Map.Entry<String, NotificationRecord>> records = recordsForPkg.entrySet();\n                for (Map.Entry<String, NotificationRecord> record : records) {\n                    final StatusBarNotification sbn = record.getValue().getSbn();\n                    if (Objects.equals(sbn.getTag(), tag) && sbn.getId() == id) {\n                        record.getValue().isCanceled = true;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    protected void cancel(int userId, boolean includeCurrentProfiles) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.size() == 0) {\n                return;\n            }\n            IntArray userIds = new IntArray();\n            userIds.add(userId);\n            if (includeCurrentProfiles) {\n                userIds = mUserProfiles.getCurrentProfileIds();\n            }\n            for (ArrayMap<String, NotificationRecord> snoozedRecords : mSnoozedNotifications.values()) {\n                for (NotificationRecord r : snoozedRecords.values()) {\n                    if (userIds.binarySearch(r.getUserId()) >= 0) {\n                        r.isCanceled = true;\n                    }\n                }\n            }\n        }\n    }\n\n    protected boolean cancel(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return false;\n            }\n            int N = records.size();\n            for (int i = 0; i < N; i++) {\n                records.valueAt(i).isCanceled = true;\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Updates the notification record so the most up to date information is shown on re-post.\n     */\n    protected void update(int userId, NotificationRecord record) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, record.getSbn().getPackageName()));\n            if (records == null) {\n                return;\n            }\n            records.put(record.getKey(), record);\n        }\n    }\n\n    protected void repost(String key, boolean muteOnReturn) {\n        synchronized (mLock) {\n            Integer userId = mUsers.get(key);\n            if (userId != null) {\n                repost(key, userId, muteOnReturn);\n            }\n        }\n    }\n\n    protected void repost(String key, int userId, boolean muteOnReturn) {\n        final String trimmedKey = getTrimmedString(key);\n\n        NotificationRecord record;\n        synchronized (mLock) {\n            final String pkg = mPackages.remove(key);\n            mUsers.remove(key);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            record = records.remove(key);\n\n        }\n\n        if (record != null && !record.isCanceled) {\n            final PendingIntent pi = createPendingIntent(\n                    record.getSbn().getPackageName(), record.getKey(), userId);\n            mAm.cancel(pi);\n            MetricsLogger.action(record.getLogMaker()\n                    .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                    .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n            mCallback.repost(userId, record, muteOnReturn);\n        }\n    }\n\n    protected void repostGroupSummary(String pkg, int userId, String groupKey) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsByKey\n                    = mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsByKey == null) {\n                return;\n            }\n\n            String groupSummaryKey = null;\n            int N = recordsByKey.size();\n            for (int i = 0; i < N; i++) {\n                final NotificationRecord potentialGroupSummary = recordsByKey.valueAt(i);\n                if (potentialGroupSummary.getSbn().isGroup()\n                        && potentialGroupSummary.getNotification().isGroupSummary()\n                        && groupKey.equals(potentialGroupSummary.getGroupKey())) {\n                    groupSummaryKey = potentialGroupSummary.getKey();\n                    break;\n                }\n            }\n\n            if (groupSummaryKey != null) {\n                NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                mPackages.remove(groupSummaryKey);\n                mUsers.remove(groupSummaryKey);\n\n                final String trimmedKey = getTrimmedString(groupSummaryKey);\n                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n                removeRecordLocked(pkg, trimmedKey, userId,\n                      mPersistedSnoozedNotificationsWithContext);\n\n                if (record != null && !record.isCanceled) {\n                    Runnable runnable = () -> {\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n                        mCallback.repost(userId, record, false);\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    protected void clearData(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            for (int i = records.size() - 1; i >= 0; i--) {\n                final NotificationRecord r = records.removeAt(i);\n                if (r != null) {\n                    mPackages.remove(r.getKey());\n                    mUsers.remove(r.getKey());\n                    Runnable runnable = () -> {\n                        final PendingIntent pi = createPendingIntent(pkg, r.getKey(), userId);\n                        mAm.cancel(pi);\n                        MetricsLogger.action(r.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_DISMISS));\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    private PendingIntent createPendingIntent(String pkg, String key, int userId) {\n        return PendingIntent.getBroadcast(mContext,\n                REQUEST_CODE_REPOST,\n                new Intent(REPOST_ACTION)\n                        .setPackage(PackageManagerService.PLATFORM_PACKAGE_NAME)\n                        .setData(new Uri.Builder().scheme(REPOST_SCHEME).appendPath(key).build())\n                        .addFlags(Intent.FLAG_RECEIVER_FOREGROUND)\n                        .putExtra(EXTRA_KEY, key)\n                        .putExtra(EXTRA_USER_ID, userId),\n                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n    }\n\n    public void scheduleRepostsForPersistedNotifications(long currentTime) {\n        synchronized (mLock) {\n            for (ArrayMap<String, Long> snoozed : mPersistedSnoozedNotifications.values()) {\n                for (int i = 0; i < snoozed.size(); i++) {\n                    String key = snoozed.keyAt(i);\n                    Long time = snoozed.valueAt(i);\n                    String pkg = mPackages.get(key);\n                    Integer userId = mUsers.get(key);\n                    if (time == null || pkg == null || userId == null) {\n                        Slog.w(TAG, \"data out of sync: \" + time + \"|\" + pkg + \"|\" + userId);\n                        continue;\n                    }\n                    if (time != null && time > currentTime) {\n                        scheduleRepostAtTime(pkg, key, userId, time);\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleRepost(String pkg, String key, int userId, long duration) {\n        scheduleRepostAtTime(pkg, key, userId, System.currentTimeMillis() + duration);\n    }\n\n    private void scheduleRepostAtTime(String pkg, String key, int userId, long time) {\n        Runnable runnable = () -> {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final PendingIntent pi = createPendingIntent(pkg, key, userId);\n                mAm.cancel(pi);\n                if (DEBUG) Slog.d(TAG, \"Scheduling evaluate for \" + new Date(time));\n                mAm.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pi);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        };\n        runnable.run();\n    }\n\n    public void dump(PrintWriter pw, NotificationManagerService.DumpFilter filter) {\n        synchronized (mLock) {\n            pw.println(\"\\n  Snoozed notifications:\");\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.println(key);\n                }\n            }\n            pw.println(\"\\n Pending snoozed notifications\");\n            for (String userPkgKey : mPersistedSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, Long> snoozedRecords =\n                        mPersistedSnoozedNotifications.get(userPkgKey);\n                if (snoozedRecords == null) {\n                    continue;\n                }\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(key);\n                    pw.print(INDENT);\n                    pw.println(snoozedRecords.get(key));\n                }\n            }\n        }\n    }\n\n    protected void writeXml(TypedXmlSerializer out) throws IOException {\n        synchronized (mLock) {\n            final long currentTime = System.currentTimeMillis();\n            out.startTag(null, XML_TAG_NAME);\n            writeXml(out, mPersistedSnoozedNotifications, XML_SNOOZED_NOTIFICATION,\n                    value -> {\n                        if (value < currentTime) {\n                            return;\n                        }\n                        out.attributeLong(null, XML_SNOOZED_NOTIFICATION_TIME,\n                                value);\n                    });\n            writeXml(out, mPersistedSnoozedNotificationsWithContext,\n                    XML_SNOOZED_NOTIFICATION_CONTEXT,\n                    value -> {\n                        out.attribute(null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID,\n                                value);\n                    });\n            out.endTag(null, XML_TAG_NAME);\n        }\n    }\n\n    private interface Inserter<T> {\n        void insert(T t) throws IOException;\n    }\n\n    private <T> void writeXml(TypedXmlSerializer out,\n            ArrayMap<String, ArrayMap<String, T>> targets, String tag,\n            Inserter<T> attributeInserter)\n            throws IOException {\n        final int M = targets.size();\n        for (int i = 0; i < M; i++) {\n            // T is a String (snoozed until context) or Long (snoozed until time)\n            ArrayMap<String, T> keyToValue = targets.valueAt(i);\n            for (int j = 0; j < keyToValue.size(); j++) {\n                String key = keyToValue.keyAt(j);\n                T value = keyToValue.valueAt(j);\n                String pkg = mPackages.get(key);\n                Integer userId = mUsers.get(key);\n\n                if (pkg == null || userId == null) {\n                    Slog.w(TAG, \"pkg \" + pkg + \" or user \" + userId + \" missing for \" + key);\n                    continue;\n                }\n\n                out.startTag(null, tag);\n\n                attributeInserter.insert(value);\n\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL,\n                        XML_SNOOZED_NOTIFICATION_VERSION);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_KEY, key);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_PKG, pkg);\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_USER_ID, userId);\n\n                out.endTag(null, tag);\n            }\n        }\n    }\n\n    protected void readXml(TypedXmlPullParser parser, long currentTime)\n            throws XmlPullParserException, IOException {\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {\n            String tag = parser.getName();\n            if (type == XmlPullParser.END_TAG\n                    && XML_TAG_NAME.equals(tag)) {\n                break;\n            }\n            if (type == XmlPullParser.START_TAG\n                    && (XML_SNOOZED_NOTIFICATION.equals(tag)\n                        || tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT))\n                    && parser.getAttributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL, -1)\n                        == XML_SNOOZED_NOTIFICATION_VERSION) {\n                try {\n                    final String key = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_KEY);\n                    final String pkg = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_PKG);\n                    final int userId = parser.getAttributeInt(\n                            null, XML_SNOOZED_NOTIFICATION_USER_ID, UserHandle.USER_ALL);\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION)) {\n                        final Long time = parser.getAttributeLong(\n                                null, XML_SNOOZED_NOTIFICATION_TIME, 0);\n                        if (time > currentTime) { //only read new stuff\n                            synchronized (mLock) {\n                                storeRecordLocked(\n                                        pkg, key, userId, mPersistedSnoozedNotifications, time);\n                            }\n                        }\n                    }\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT)) {\n                        final String creationId = parser.getAttributeValue(\n                                null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID);\n                        synchronized (mLock) {\n                            storeRecordLocked(\n                                    pkg, key, userId, mPersistedSnoozedNotificationsWithContext,\n                                    creationId);\n                        }\n                    }\n                } catch (Exception e) {\n                    Slog.e(TAG,  \"Exception in reading snooze data from policy xml\", e);\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void setAlarmManager(AlarmManager am) {\n        mAm = am;\n    }\n\n    protected interface Callback {\n        void repost(int userId, NotificationRecord r, boolean muteOnReturn);\n    }\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (DEBUG) {\n                Slog.d(TAG, \"Reposting notification\");\n            }\n            if (REPOST_ACTION.equals(intent.getAction())) {\n                repost(intent.getStringExtra(EXTRA_KEY), intent.getIntExtra(EXTRA_USER_ID,\n                        UserHandle.USER_SYSTEM), false);\n            }\n        }\n    };\n}",
            "downstream_file_ground_truth_tokens": {
              "openai": 5905,
              "general": {
                "word_based": 2347,
                "char_based": 7375
              },
              "gemini": 7061
            },
            "downstream_file_content_patched_upstream_only": "```java\n/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.android.server.notification;\n\nimport android.annotation.NonNull;\nimport android.annotation.UserIdInt;\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.service.notification.StatusBarNotification;\nimport android.util.ArrayMap;\nimport android.util.IntArray;\nimport android.util.Log;\nimport android.util.Slog;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto;\nimport com.android.internal.util.XmlUtils;\nimport com.android.server.pm.PackageManagerService;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * NotificationManagerService helper for handling snoozed notifications.\n */\npublic class SnoozeHelper {\n    public static final int XML_SNOOZED_NOTIFICATION_VERSION = 1;\n\n    static final int CONCURRENT_SNOOZE_LIMIT = 500;\n\n    // A safe size for strings to be put in persistent storage, to avoid breaking the XML write.\n    static final int MAX_STRING_LENGTH = 1000;\n\n    protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n\n    private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT = \"context\";\n    private static final String XML_SNOOZED_NOTIFICATION_PKG = \"pkg\";\n    private static final String XML_SNOOZED_NOTIFICATION_USER_ID = \"user-id\";\n    private static final String XML_SNOOZED_NOTIFICATION_KEY = \"key\";\n    //the time the snoozed notification should be reposted\n    private static final String XML_SNOOZED_NOTIFICATION_TIME = \"time\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT_ID = \"id\";\n    private static final String XML_SNOOZED_NOTIFICATION_VERSION_LABEL = \"version\";\n\n\n    private static final String TAG = \"SnoozeHelper\";\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n    private static final String INDENT = \"    \";\n\n    private static final String REPOST_ACTION = SnoozeHelper.class.getSimpleName() + \".EVALUATE\";\n    private static final int REQUEST_CODE_REPOST = 1;\n    private static final String REPOST_SCHEME = \"repost\";\n    static final String EXTRA_KEY = \"key\";\n    private static final String EXTRA_USER_ID = \"userId\";\n\n    private final Context mContext;\n    private AlarmManager mAm;\n    private final ManagedServices.UserProfiles mUserProfiles;\n\n    // User id | package name : notification key : record.\n    private ArrayMap<String, ArrayMap<String, NotificationRecord>>\n            mSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : time-milliseconds .\n    // This member stores persisted snoozed notification trigger times. it persists through reboots\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, Long>>\n            mPersistedSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : creation ID .\n    // This member stores persisted snoozed notification trigger context for the assistant\n    // it persists through reboots.\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, String>>\n            mPersistedSnoozedNotificationsWithContext = new ArrayMap<>();\n    // notification key : package.\n    private ArrayMap<String, String> mPackages = new ArrayMap<>();\n    // key : userId\n    private ArrayMap<String, Integer> mUsers = new ArrayMap<>();\n    private Callback mCallback;\n\n    private final Object mLock = new Object();\n\n    public SnoozeHelper(Context context, Callback callback,\n            ManagedServices.UserProfiles userProfiles) {\n        mContext = context;\n        IntentFilter filter = new IntentFilter(REPOST_ACTION);\n        filter.addDataScheme(REPOST_SCHEME);\n        mContext.registerReceiver(mBroadcastReceiver, filter);\n        mAm = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mCallback = callback;\n        mUserProfiles = userProfiles;\n    }\n\n    private String getPkgKey(@UserIdInt int userId, String pkg) {\n        return userId + \"|\" + pkg;\n    }\n\n    void cleanupPersistedContext(String key){\n        synchronized (mLock) {\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            removeRecordLocked(pkg, key, userId, mPersistedSnoozedNotificationsWithContext);\n        }\n    }\n\n    protected boolean canSnooze(int numberToSnooze) {\n        synchronized (mLock) {\n            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @NonNull\n    protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n        Long time = null;\n        synchronized (mLock) {\n           ArrayMap<String, Long> snoozed =\n                   mPersistedSnoozedNotifications.get(getPkgKey(userId, pkg));\n           if (snoozed != null) {\n               time = snoozed.get(getTrimmedString(key));\n           }\n        }\n        if (time == null) {\n            time = 0L;\n        }\n        return time;\n    }\n\n    protected String getSnoozeContextForUnpostedNotification(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            ArrayMap<String, String> snoozed =\n                    mPersistedSnoozedNotificationsWithContext.get(getPkgKey(userId, pkg));\n            if (snoozed != null) {\n                return snoozed.get(getTrimmedString(key));\n            }\n        }\n        return null;\n    }\n\n    protected boolean isSnoozed(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            return mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))\n                    && mSnoozedNotifications.get(getPkgKey(userId, pkg)).containsKey(key);\n        }\n    }\n\n    protected Collection<NotificationRecord> getSnoozed(int userId, String pkg) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))) {\n                return mSnoozedNotifications.get(getPkgKey(userId, pkg)).values();\n            }\n        }\n        return Collections.EMPTY_LIST;\n    }\n\n    @NonNull\n    ArrayList<NotificationRecord> getNotifications(String pkg,\n            String groupKey, Integer userId) {\n        ArrayList<NotificationRecord> records =  new ArrayList<>();\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> allRecords =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (allRecords != null) {\n                for (int i = 0; i < allRecords.size(); i++) {\n                    NotificationRecord r = allRecords.valueAt(i);\n                    String currentGroupKey = r.getSbn().getGroup();\n                    if (Objects.equals(currentGroupKey, groupKey)) {\n                        records.add(r);\n                    }\n                }\n            }\n        }\n        return records;\n    }\n\n    protected NotificationRecord getNotification(String key) {\n        synchronized (mLock) {\n            if (!mUsers.containsKey(key) || !mPackages.containsKey(key)) {\n                Slog.w(TAG, \"Snoozed data sets no longer agree for \" + key);\n                return null;\n            }\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            ArrayMap<String, NotificationRecord> snoozed =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (snoozed == null) {\n                return null;\n            }\n            return snoozed.get(key);\n        }\n    }\n\n    protected @NonNull List<NotificationRecord> getSnoozed() {\n        synchronized (mLock) {\n            // caller filters records based on the current user profiles and listener access, so just\n            // return everything\n            List<NotificationRecord> snoozed = new ArrayList<>();\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                snoozed.addAll(snoozedRecords.values());\n            }\n            return snoozed;\n        }\n    }\n\n    /**\n     * Snoozes a notification and schedules an alarm to repost at that time.\n     */\n    protected void snooze(NotificationRecord record, long duration) {\n        String pkg = record.getSbn().getPackageName();\n        String key = record.getKey();\n        int userId = record.getUser().getIdentifier();\n\n        snooze(record);\n        scheduleRepost(pkg, key, userId, duration);\n        Long activateAt = System.currentTimeMillis() + duration;\n        synchronized (mLock) {\n            storeRecordLocked(pkg, getTrimmedString(key), userId, mPersistedSnoozedNotifications,\n                    activateAt);\n        }\n    }\n\n    /**\n     * Records a snoozed notification.\n     */\n    protected void snooze(NotificationRecord record, String contextId) {\n        int userId = record.getUser().getIdentifier();\n        if (contextId != null) {\n            synchronized (mLock) {\n                storeRecordLocked(record.getSbn().getPackageName(),\n                        getTrimmedString(record.getKey()),\n                        userId, mPersistedSnoozedNotificationsWithContext,\n                        getTrimmedString(contextId));\n            }\n        }\n        snooze(record);\n    }\n\n    private void snooze(NotificationRecord record) {\n        int userId = record.getUser().getIdentifier();\n        if (DEBUG) {\n            Slog.d(TAG, \"Snoozing \" + record.getKey());\n        }\n        synchronized (mLock) {\n            storeRecordLocked(record.getSbn().getPackageName(), record.getKey(),\n                    userId, mSnoozedNotifications, record);\n        }\n    }\n\n    private String getTrimmedString(String key) {\n        if (key != null && key.length() > MAX_STRING_LENGTH) {\n            return key.substring(0, MAX_STRING_LENGTH);\n        }\n        return key;\n    }\n\n    private <T> void storeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets, T object) {\n\n        mPackages.put(key, pkg);\n        mUsers.put(key, userId);\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            keyToValue = new ArrayMap<>();\n        }\n        keyToValue.put(key, object);\n        targets.put(getPkgKey(userId, pkg), keyToValue);\n    }\n\n    private <T> T removeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets) {\n        T object = null;\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            return null;\n        }\n        object = keyToValue.remove(key);\n        if (keyToValue.size() == 0) {\n            targets.remove(getPkgKey(userId, pkg));\n        }\n        return object;\n    }\n\n    protected boolean cancel(int userId, String pkg, String tag, int id) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsForPkg =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsForPkg != null) {\n                final Set<Map.Entry<String, NotificationRecord>> records = recordsForPkg.entrySet();\n                for (Map.Entry<String, NotificationRecord> record : records) {\n                    final StatusBarNotification sbn = record.getValue().getSbn();\n                    if (Objects.equals(sbn.getTag(), tag) && sbn.getId() == id) {\n                        record.getValue().isCanceled = true;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    protected void cancel(int userId, boolean includeCurrentProfiles) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.size() == 0) {\n                return;\n            }\n            IntArray userIds = new IntArray();\n            userIds.add(userId);\n            if (includeCurrentProfiles) {\n                userIds = mUserProfiles.getCurrentProfileIds();\n            }\n            for (ArrayMap<String, NotificationRecord> snoozedRecords : mSnoozedNotifications.values()) {\n                for (NotificationRecord r : snoozedRecords.values()) {\n                    if (userIds.binarySearch(r.getUserId()) >= 0) {\n                        r.isCanceled = true;\n                    }\n                }\n            }\n        }\n    }\n\n    protected boolean cancel(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return false;\n            }\n            int N = records.size();\n            for (int i = 0; i < N; i++) {\n                records.valueAt(i).isCanceled = true;\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Updates the notification record so the most up to date information is shown on re-post.\n     */\n    protected void update(int userId, NotificationRecord record) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, record.getSbn().getPackageName()));\n            if (records == null) {\n                return;\n            }\n            records.put(record.getKey(), record);\n        }\n    }\n\n    protected void repost(String key, boolean muteOnReturn) {\n        synchronized (mLock) {\n            Integer userId = mUsers.get(key);\n            if (userId != null) {\n                repost(key, userId, muteOnReturn);\n            }\n        }\n    }\n\n    protected void repost(String key, int userId, boolean muteOnReturn) {\n        final String trimmedKey = getTrimmedString(key);\n\n        NotificationRecord record;\n        synchronized (mLock) {\n            final String pkg = mPackages.remove(key);\n            mUsers.remove(key);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            record = records.remove(key);\n\n        }\n\n        if (record != null && !record.isCanceled) {\n            final PendingIntent pi = createPendingIntent(\n                    record.getSbn().getPackageName(), record.getKey(), userId);\n            mAm.cancel(pi);\n            MetricsLogger.action(record.getLogMaker()\n                    .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                    .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n            mCallback.repost(userId, record, muteOnReturn);\n        }\n    }\n\n    protected void repostGroupSummary(String pkg, int userId, String groupKey) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsByKey\n                    = mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsByKey == null) {\n                return;\n            }\n\n            String groupSummaryKey = null;\n            int N = recordsByKey.size();\n            for (int i = 0; i < N; i++) {\n                final NotificationRecord potentialGroupSummary = recordsByKey.valueAt(i);\n                if (potentialGroupSummary.getSbn().isGroup()\n                        && potentialGroupSummary.getNotification().isGroupSummary()\n                        && groupKey.equals(potentialGroupSummary.getGroupKey())) {\n                    groupSummaryKey = potentialGroupSummary.getKey();\n                    break;\n                }\n            }\n\n            if (groupSummaryKey != null) {\n                NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                mPackages.remove(groupSummaryKey);\n                mUsers.remove(groupSummaryKey);\n\n                if (record != null && !record.isCanceled) {\n                    Runnable runnable = () -> {\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n                        mCallback.repost(userId, record, false);\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    protected void clearData(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            for (int i = records.size() - 1; i >= 0; i--) {\n                final NotificationRecord r = records.removeAt(i);\n                if (r != null) {\n                    mPackages.remove(r.getKey());\n                    mUsers.remove(r.getKey());\n                    Runnable runnable = () -> {\n                        final PendingIntent pi = createPendingIntent(pkg, r.getKey(), userId);\n                        mAm.cancel(pi);\n                        MetricsLogger.action(r.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_DISMISS));\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    private PendingIntent createPendingIntent(String pkg, String key, int userId) {\n        return PendingIntent.getBroadcast(mContext,\n                REQUEST_CODE_REPOST,\n                new Intent(REPOST_ACTION)\n                        .setPackage(PackageManagerService.PLATFORM_PACKAGE_NAME)\n                        .setData(new Uri.Builder().scheme(REPOST_SCHEME).appendPath(key).build())\n                        .addFlags(Intent.FLAG_RECEIVER_FOREGROUND)\n                        .putExtra(EXTRA_KEY, key)\n                        .putExtra(EXTRA_USER_ID, userId),\n                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n    }\n\n    public void scheduleRepostsForPersistedNotifications(long currentTime) {\n        synchronized (mLock) {\n            for (ArrayMap<String, Long> snoozed : mPersistedSnoozedNotifications.values()) {\n                for (int i = 0; i < snoozed.size(); i++) {\n                    String key = snoozed.keyAt(i);\n                    Long time = snoozed.valueAt(i);\n                    String pkg = mPackages.get(key);\n                    Integer userId = mUsers.get(key);\n                    if (time == null || pkg == null || userId == null) {\n                        Slog.w(TAG, \"data out of sync: \" + time + \"|\" + pkg + \"|\" + userId);\n                        continue;\n                    }\n                    if (time != null && time > currentTime) {\n                        scheduleRepostAtTime(pkg, key, userId, time);\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleRepost(String pkg, String key, int userId, long duration) {\n        scheduleRepostAtTime(pkg, key, userId, System.currentTimeMillis() + duration);\n    }\n\n    private void scheduleRepostAtTime(String pkg, String key, int userId, long time) {\n        Runnable runnable = () -> {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final PendingIntent pi = createPendingIntent(pkg, key, userId);\n                mAm.cancel(pi);\n                if (DEBUG) Slog.d(TAG, \"Scheduling evaluate for \" + new Date(time));\n                mAm.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pi);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        };\n        runnable.run();\n    }\n\n    public void dump(PrintWriter pw, NotificationManagerService.DumpFilter filter) {\n        synchronized (mLock) {\n            pw.println(\"\\n  Snoozed notifications:\");\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.println(key);\n                }\n            }\n            pw.println(\"\\n Pending snoozed notifications\");\n            for (String userPkgKey : mPersistedSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, Long> snoozedRecords =\n                        mPersistedSnoozedNotifications.get(userPkgKey);\n                if (snoozedRecords == null) {\n                    continue;\n                }\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(key);\n                    pw.print(INDENT);\n                    pw.println(snoozedRecords.get(key));\n                }\n            }\n        }\n    }\n\n    protected void writeXml(TypedXmlSerializer out) throws IOException {\n        synchronized (mLock) {\n            final long currentTime = System.currentTimeMillis();\n            out.startTag(null, XML_TAG_NAME);\n            writeXml(out, mPersistedSnoozedNotifications, XML_SNOOZED_NOTIFICATION,\n                    value -> {\n                        if (value < currentTime) {\n                            return;\n                        }\n                        out.attributeLong(null, XML_SNOOZED_NOTIFICATION_TIME,\n                                value);\n                    });\n            writeXml(out, mPersistedSnoozedNotificationsWithContext,\n                    XML_SNOOZED_NOTIFICATION_CONTEXT,\n                    value -> {\n                        out.attribute(null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID,\n                                value);\n                    });\n            out.endTag(null, XML_TAG_NAME);\n        }\n    }\n\n    private interface Inserter<T> {\n        void insert(T t) throws IOException;\n    }\n\n    private <T> void writeXml(TypedXmlSerializer out,\n            ArrayMap<String, ArrayMap<String, T>> targets, String tag,\n            Inserter<T> attributeInserter)\n            throws IOException {\n        final int M = targets.size();\n        for (int i = 0; i < M; i++) {\n            // T is a String (snoozed until context) or Long (snoozed until time)\n            ArrayMap<String, T> keyToValue = targets.valueAt(i);\n            for (int j = 0; j < keyToValue.size(); j++) {\n                String key = keyToValue.keyAt(j);\n                T value = keyToValue.valueAt(j);\n                String pkg = mPackages.get(key);\n                Integer userId = mUsers.get(key);\n\n                if (pkg == null || userId == null) {\n                    Slog.w(TAG, \"pkg \" + pkg + \" or user \" + userId + \" missing for \" + key);\n                    continue;\n                }\n\n                out.startTag(null, tag);\n\n                attributeInserter.insert(value);\n\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL,\n                        XML_SNOOZED_NOTIFICATION_VERSION);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_KEY, key);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_PKG, pkg);\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_USER_ID, userId);\n\n                out.endTag(null, tag);\n            }\n        }\n    }\n\n    protected void readXml(TypedXmlPullParser parser, long currentTime)\n            throws XmlPullParserException, IOException {\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {\n            String tag = parser.getName();\n            if (type == XmlPullParser.END_TAG\n                    && XML_TAG_NAME.equals(tag)) {\n                break;\n            }\n            if (type == XmlPullParser.START_TAG\n                    && (XML_SNOOZED_NOTIFICATION.equals(tag)\n                        || tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT))\n                    && parser.getAttributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL, -1)\n                        == XML_SNOOZED_NOTIFICATION_VERSION) {\n                try {\n                    final String key = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_KEY);\n                    final String pkg = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_PKG);\n                    final int userId = parser.getAttributeInt(\n                            null, XML_SNOOZED_NOTIFICATION_USER_ID, UserHandle.USER_ALL);\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION)) {\n                        final Long time = parser.getAttributeLong(\n                                null, XML_SNOOZED_NOTIFICATION_TIME, 0);\n                        if (time > currentTime) { //only read new stuff\n                            synchronized (mLock) {\n                                storeRecordLocked(\n                                        pkg, key, userId, mPersistedSnoozedNotifications, time);\n                            }\n                        }\n                    }\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT)) {\n                        final String creationId = parser.getAttributeValue(\n                                null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID);\n                        synchronized (mLock) {\n                            storeRecordLocked(\n                                    pkg, key, userId, mPersistedSnoozedNotificationsWithContext,\n                                    creationId);\n                        }\n                    }\n                } catch (Exception e) {\n                    Slog.e(TAG,  \"Exception in reading snooze data from policy xml\", e);\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void setAlarmManager(AlarmManager am) {\n        mAm = am;\n    }\n\n    protected interface Callback {\n        void repost(int userId, NotificationRecord r, boolean muteOnReturn);\n    }\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (DEBUG) {\n                Slog.d(TAG, \"Reposting notification\");\n            }\n            if (REPOST_ACTION.equals(intent.getAction())) {\n                repost(intent.getStringExtra(EXTRA_KEY), intent.getIntExtra(EXTRA_USER_ID,\n                        UserHandle.USER_SYSTEM), false);\n            }\n        }\n    };\n}\n```",
            "diff_patched_upstream_only": "--- original_downstream_file\n+++ patched_upstream_only\n@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2016 The Android Open Source Project\n  *\n@@ -704,5 +703,4 @@\n             }\n         }\n     };\n-}\n-```+}",
            "downstream_llm_diff_output": null,
            "runtime_seconds": 362.43,
            "llm_output_valid": false,
            "attempts_made": 3,
            "validation_results": [
              {
                "attempt": 1,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk diff line expected: @@ -381,9 +384,12 @@\n",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 137.41
              },
              {
                "attempt": 2,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk is longer than expected",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 104.38
              },
              {
                "attempt": 3,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk is longer than expected",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 120.63
              }
            ],
            "error": "All validation attempts failed",
            "last_format_error": "Invalid patch format: Hunk is longer than expected",
            "last_apply_error": "Skipped due to format error"
          }
        ]
      },
      {
        "downstream_version": "13",
        "gemini_token_usage": 21789,
        "branch_used": "android13-release",
        "downstream_patch": "ade22bfdf6698cb97b4edc303e8952d6cc1a2f73",
        "repo_path": "android_repos/base",
        "result": "failure",
        "downstream_patch_content": "commit ade22bfdf6698cb97b4edc303e8952d6cc1a2f73\nAuthor: Valentin Iftime <valiiftime@google.com>\nDate:   Wed Nov 8 11:01:32 2023 +0100\n\n    Enforce persisted snoozed notifications limits\n    \n     Prevent DoS attack that causes boot-looping by serializing a huge amount of snoozed notifications:\n      - Check snooze limits for persisted notifications\n      - Remove persisted group summary notification when in-memory counterpart is removed\n      - Prevent unpriviledged API calls that allow 3P apps to snooze notifications with context/criterion\n    \n    Test: atest SnoozeHelperTest\n    Test: atest NotificationManagerServiceTest\n    Bug: 307948424\n    Bug: 308414141\n    \n    Change-Id: I3571fa9207b778def652130d3ca840183a9a8414\n    (cherry picked from commit 965ff2d3c5487f72a77f6153ed8542cb2621d93c)\n    Merged-In: I3571fa9207b778def652130d3ca840183a9a8414\n\ndiff --git a/services/core/java/com/android/server/notification/SnoozeHelper.java b/services/core/java/com/android/server/notification/SnoozeHelper.java\nindex f3b92eaf6473..966560359b39 100644\n--- a/services/core/java/com/android/server/notification/SnoozeHelper.java\n+++ b/services/core/java/com/android/server/notification/SnoozeHelper.java\n@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()\ndiff --git a/services/tests/uiservicestests/src/com/android/server/notification/SnoozeHelperTest.java b/services/tests/uiservicestests/src/com/android/server/notification/SnoozeHelperTest.java\nindex 883613f6a2b6..c1da6693bc1c 100644\n--- a/services/tests/uiservicestests/src/com/android/server/notification/SnoozeHelperTest.java\n+++ b/services/tests/uiservicestests/src/com/android/server/notification/SnoozeHelperTest.java\n@@ -18,6 +18,8 @@ package com.android.server.notification;\n import static com.android.server.notification.SnoozeHelper.CONCURRENT_SNOOZE_LIMIT;\n import static com.android.server.notification.SnoozeHelper.EXTRA_KEY;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static junit.framework.Assert.assertEquals;\n import static junit.framework.Assert.assertFalse;\n import static junit.framework.Assert.assertNull;\n@@ -76,6 +78,16 @@ import java.util.Collections;\n public class SnoozeHelperTest extends UiServiceTestCase {\n     private static final String TEST_CHANNEL_ID = \"test_channel_id\";\n \n+    private static final String XML_TAG_NAME = \"snoozed-notifications\";\n+    private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n+    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT = \"context\";\n+    private static final String XML_SNOOZED_NOTIFICATION_KEY = \"key\";\n+    private static final String XML_SNOOZED_NOTIFICATION_TIME = \"time\";\n+    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT_ID = \"id\";\n+    private static final String XML_SNOOZED_NOTIFICATION_VERSION_LABEL = \"version\";\n+    private static final String XML_SNOOZED_NOTIFICATION_PKG = \"pkg\";\n+    private static final String XML_SNOOZED_NOTIFICATION_USER_ID = \"user-id\";\n+\n     @Mock SnoozeHelper.Callback mCallback;\n     @Mock AlarmManager mAm;\n     @Mock ManagedServices.UserProfiles mUserProfiles;\n@@ -329,6 +341,56 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n         assertFalse(mSnoozeHelper.canSnooze(1));\n     }\n \n+    @Test\n+    public void testSnoozeLimit_maximumPersisted() throws XmlPullParserException, IOException {\n+        final long snoozeTimeout = 1234;\n+        final String snoozeContext = \"ctx\";\n+        // Serialize & deserialize notifications so that only persisted lists are used\n+        TypedXmlSerializer serializer = Xml.newFastSerializer();\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        serializer.setOutput(new BufferedOutputStream(baos), \"utf-8\");\n+        serializer.startDocument(null, true);\n+        serializer.startTag(null, XML_TAG_NAME);\n+        // Serialize maximum number of timed + context snoozed notifications, half of each\n+        for (int i = 0; i < CONCURRENT_SNOOZE_LIMIT; i++) {\n+            final boolean timedNotification = i % 2 == 0;\n+            if (timedNotification) {\n+                serializer.startTag(null, XML_SNOOZED_NOTIFICATION);\n+            } else {\n+                serializer.startTag(null, XML_SNOOZED_NOTIFICATION_CONTEXT);\n+            }\n+            serializer.attribute(null, XML_SNOOZED_NOTIFICATION_PKG, \"pkg\");\n+            serializer.attributeInt(null, XML_SNOOZED_NOTIFICATION_USER_ID,\n+                UserHandle.USER_SYSTEM);\n+            serializer.attributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL, 1);\n+            serializer.attribute(null, XML_SNOOZED_NOTIFICATION_KEY, \"key\" + i);\n+            if (timedNotification) {\n+                serializer.attributeLong(null, XML_SNOOZED_NOTIFICATION_TIME, snoozeTimeout);\n+                serializer.endTag(null, XML_SNOOZED_NOTIFICATION);\n+            } else {\n+                serializer.attribute(null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID, snoozeContext);\n+                serializer.endTag(null, XML_SNOOZED_NOTIFICATION_CONTEXT);\n+            }\n+        }\n+        serializer.endTag(null, XML_TAG_NAME);\n+        serializer.endDocument();\n+        serializer.flush();\n+\n+        TypedXmlPullParser parser = Xml.newFastPullParser();\n+        parser.setInput(new BufferedInputStream(\n+                new ByteArrayInputStream(baos.toByteArray())), \"utf-8\");\n+        mSnoozeHelper.readXml(parser, 1);\n+        // Verify that we can't snooze any more notifications\n+        //  and that the limit is caused by persisted notifications\n+        assertThat(mSnoozeHelper.canSnooze(1)).isFalse();\n+        assertThat(mSnoozeHelper.isSnoozed(UserHandle.USER_SYSTEM, \"pkg\", \"key0\")).isFalse();\n+        assertThat(mSnoozeHelper.getSnoozeTimeForUnpostedNotification(UserHandle.USER_SYSTEM,\n+                \"pkg\", \"key0\")).isEqualTo(snoozeTimeout);\n+        assertThat(\n+            mSnoozeHelper.getSnoozeContextForUnpostedNotification(UserHandle.USER_SYSTEM, \"pkg\",\n+                \"key1\")).isEqualTo(snoozeContext);\n+    }\n+\n     @Test\n     public void testCancelByApp() throws Exception {\n         NotificationRecord r = getNotificationRecord(\"pkg\", 1, \"one\", UserHandle.SYSTEM);\n@@ -602,6 +664,7 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n \n     @Test\n     public void repostGroupSummary_repostsSummary() throws Exception {\n+        final int snoozeDuration = 1000;\n         IntArray profileIds = new IntArray();\n         profileIds.add(UserHandle.USER_SYSTEM);\n         when(mUserProfiles.getCurrentProfileIds()).thenReturn(profileIds);\n@@ -609,10 +672,44 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n                 \"pkg\", 1, \"one\", UserHandle.SYSTEM, \"group1\", true);\n         NotificationRecord r2 = getNotificationRecord(\n                 \"pkg\", 2, \"two\", UserHandle.SYSTEM, \"group1\", false);\n-        mSnoozeHelper.snooze(r, 1000);\n-        mSnoozeHelper.snooze(r2, 1000);\n+        final long snoozeTime = System.currentTimeMillis() + snoozeDuration;\n+        mSnoozeHelper.snooze(r, snoozeDuration);\n+        mSnoozeHelper.snooze(r2, snoozeDuration);\n+        assertEquals(2, mSnoozeHelper.getSnoozed().size());\n+        assertEquals(2, mSnoozeHelper.getSnoozed(UserHandle.USER_SYSTEM, \"pkg\").size());\n+        // Verify that summary notification was added to the persisted list\n+        assertThat(mSnoozeHelper.getSnoozeTimeForUnpostedNotification(UserHandle.USER_SYSTEM, \"pkg\",\n+                r.getKey())).isAtLeast(snoozeTime);\n+\n+        mSnoozeHelper.repostGroupSummary(\"pkg\", UserHandle.USER_SYSTEM, r.getGroupKey());\n+\n+        verify(mCallback, times(1)).repost(UserHandle.USER_SYSTEM, r, false);\n+        verify(mCallback, never()).repost(UserHandle.USER_SYSTEM, r2, false);\n+\n+        assertEquals(1, mSnoozeHelper.getSnoozed().size());\n+        assertEquals(1, mSnoozeHelper.getSnoozed(UserHandle.USER_SYSTEM, \"pkg\").size());\n+        // Verify that summary notification was removed from the persisted list\n+        assertThat(mSnoozeHelper.getSnoozeTimeForUnpostedNotification(UserHandle.USER_SYSTEM, \"pkg\",\n+                r.getKey())).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void snoozeWithContext_repostGroupSummary_removesPersisted() throws Exception {\n+        final String snoozeContext = \"zzzzz\";\n+        IntArray profileIds = new IntArray();\n+        profileIds.add(UserHandle.USER_SYSTEM);\n+        when(mUserProfiles.getCurrentProfileIds()).thenReturn(profileIds);\n+        NotificationRecord r = getNotificationRecord(\n+                \"pkg\", 1, \"one\", UserHandle.SYSTEM, \"group1\", true);\n+        NotificationRecord r2 = getNotificationRecord(\n+                \"pkg\", 2, \"two\", UserHandle.SYSTEM, \"group1\", false);\n+        mSnoozeHelper.snooze(r, snoozeContext);\n+        mSnoozeHelper.snooze(r2, snoozeContext);\n         assertEquals(2, mSnoozeHelper.getSnoozed().size());\n         assertEquals(2, mSnoozeHelper.getSnoozed(UserHandle.USER_SYSTEM, \"pkg\").size());\n+        // Verify that summary notification was added to the persisted list\n+        assertThat(mSnoozeHelper.getSnoozeContextForUnpostedNotification(UserHandle.USER_SYSTEM,\n+            \"pkg\", r.getKey())).isEqualTo(snoozeContext);\n \n         mSnoozeHelper.repostGroupSummary(\"pkg\", UserHandle.USER_SYSTEM, r.getGroupKey());\n \n@@ -621,6 +718,9 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n \n         assertEquals(1, mSnoozeHelper.getSnoozed().size());\n         assertEquals(1, mSnoozeHelper.getSnoozed(UserHandle.USER_SYSTEM, \"pkg\").size());\n+        // Verify that summary notification was removed from the persisted list\n+        assertThat(mSnoozeHelper.getSnoozeContextForUnpostedNotification(UserHandle.USER_SYSTEM,\n+                \"pkg\", r.getKey())).isNull();\n     }\n \n     @Test\n",
        "downstream_patch_tokens": {
          "openai": 2749,
          "general": {
            "word_based": 964,
            "char_based": 2874
          },
          "gemini": 3335
        },
        "file_conflicts": [
          {
            "file_name": "services/core/java/com/android/server/notification/SnoozeHelper.java",
            "total_hunks": 2,
            "failed_hunks": [
              1,
              2
            ],
            "inline_merge_conflicts": [
              {
                "hunk_number": 1,
                "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n            if ((mSnoozedNotifications.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n                    || (mPersistedSnoozedNotifications.size()\n                    + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n                    > CONCURRENT_SNOOZE_LIMIT) {\n                return false;\n            }\n        }\n>>>>>>> UPSTREAM PATCH (commit da6a9ea6deece5b2505d5facdf5d44cfc08057f3)",
                "merge_conflict_tokens": {
                  "openai": 120,
                  "general": {
                    "word_based": 20,
                    "char_based": 114
                  },
                  "gemini": 132
                }
              }
            ],
            "inline_merge_token_summary": {
              "gemini": 5808,
              "openai": 5400,
              "general_word": 900,
              "general_char": 5130
            },
            "rej_file_content": "```diff\n--- services/core/java/com/android/server/notification/SnoozeHelper.java\n+++ services/core/java/com/android/server/notification/SnoozeHelper.java\n@@ -118,7 +118,10 @@ public final class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mSnoozedNotifications.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mSnoozedNotifications.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                    || (mPersistedSnoozedNotifications.size()\n+                    + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n+                    > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n@@ -343,6 +346,9 @@ public final class SnoozeHelper {\n \n             if (groupSummaryKey != null) {\n                 NotificationRecord record = mSnoozedNotifications.remove(groupSummaryKey);\n+                String trimmedKey = getTrimmedString(groupSummaryKey);\n+                mPersistedSnoozedNotificationsWithContext.remove(trimmedKey);\n+                mPersistedSnoozedNotifications.remove(trimmedKey);\n \n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n```",
            "rej_file_tokens": {
              "openai": 290,
              "general": {
                "word_based": 84,
                "char_based": 314
              },
              "gemini": 329
            },
            "patch_apply_output": "patching file services/core/java/com/android/server/notification/SnoozeHelper.java\nHunk #1 FAILED at 118.\nHunk #2 FAILED at 343.\n2 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/notification/SnoozeHelper.java.rej",
            "inline_merge_output": "patching file services/core/java/com/android/server/notification/SnoozeHelper.java\nHunk #1 NOT MERGED at 121-130.\nHunk #2 already applied at 359-361.",
            "upstream_file_content": "```java\n/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.android.server.notification;\n\nimport android.annotation.NonNull;\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.UserHandle;\nimport android.service.notification.StatusBarNotification;\nimport android.util.ArrayMap;\nimport android.util.IntArray;\nimport android.util.Log;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.server.pm.PackageManagerService;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * NotificationManagerService helper for handling snoozed notifications.\n */\npublic final class SnoozeHelper {\n    public static final int XML_SNOOZED_NOTIFICATION_VERSION = 1;\n\n    static final int CONCURRENT_SNOOZE_LIMIT = 500;\n\n    // A safe size for strings to be put in persistent storage, to avoid breaking the XML write.\n    static final int MAX_STRING_LENGTH = 1000;\n\n    protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n\n    private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT = \"context\";\n    private static final String XML_SNOOZED_NOTIFICATION_KEY = \"key\";\n    //the time the snoozed notification should be reposted\n    private static final String XML_SNOOZED_NOTIFICATION_TIME = \"time\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT_ID = \"id\";\n    private static final String XML_SNOOZED_NOTIFICATION_VERSION_LABEL = \"version\";\n\n\n    private static final String TAG = \"SnoozeHelper\";\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n    private static final String INDENT = \"    \";\n\n    private static final String REPOST_ACTION = SnoozeHelper.class.getSimpleName() + \".EVALUATE\";\n    private static final int REQUEST_CODE_REPOST = 1;\n    private static final String REPOST_SCHEME = \"repost\";\n    static final String EXTRA_KEY = \"key\";\n    private static final String EXTRA_USER_ID = \"userId\";\n\n    private final Context mContext;\n    private AlarmManager mAm;\n    private final ManagedServices.UserProfiles mUserProfiles;\n\n    // notification key : record.\n    private ArrayMap<String, NotificationRecord> mSnoozedNotifications = new ArrayMap<>();\n    // notification key : time-milliseconds .\n    // This member stores persisted snoozed notification trigger times. it persists through reboots\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, Long> mPersistedSnoozedNotifications = new ArrayMap<>();\n    // notification key : creation ID.\n    // This member stores persisted snoozed notification trigger context for the assistant\n    // it persists through reboots.\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, String>\n            mPersistedSnoozedNotificationsWithContext = new ArrayMap<>();\n\n    private Callback mCallback;\n\n    private final Object mLock = new Object();\n\n    public SnoozeHelper(Context context, Callback callback,\n            ManagedServices.UserProfiles userProfiles) {\n        mContext = context;\n        IntentFilter filter = new IntentFilter(REPOST_ACTION);\n        filter.addDataScheme(REPOST_SCHEME);\n        mContext.registerReceiver(mBroadcastReceiver, filter,\n                Context.RECEIVER_EXPORTED_UNAUDITED);\n        mAm = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mCallback = callback;\n        mUserProfiles = userProfiles;\n    }\n\n    protected boolean canSnooze(int numberToSnooze) {\n        synchronized (mLock) {\n            if ((mSnoozedNotifications.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n                    || (mPersistedSnoozedNotifications.size()\n                    + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n                    > CONCURRENT_SNOOZE_LIMIT) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @NonNull\n    protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n        Long time = null;\n        synchronized (mLock) {\n            time = mPersistedSnoozedNotifications.get(getTrimmedString(key));\n        }\n        if (time == null) {\n            time = 0L;\n        }\n        return time;\n    }\n\n    protected String getSnoozeContextForUnpostedNotification(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            return mPersistedSnoozedNotificationsWithContext.get(getTrimmedString(key));\n        }\n    }\n\n    protected boolean isSnoozed(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            return mSnoozedNotifications.containsKey(key);\n        }\n    }\n\n    protected Collection<NotificationRecord> getSnoozed(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayList snoozed = new ArrayList();\n            for (NotificationRecord r : mSnoozedNotifications.values()) {\n                if (r.getUserId() == userId && r.getSbn().getPackageName().equals(pkg)) {\n                    snoozed.add(r);\n                }\n            }\n            return snoozed;\n        }\n    }\n\n    @NonNull\n    ArrayList<NotificationRecord> getNotifications(String pkg,\n            String groupKey, Integer userId) {\n        ArrayList<NotificationRecord> records =  new ArrayList<>();\n        synchronized (mLock) {\n            for (int i = 0; i < mSnoozedNotifications.size(); i++) {\n                NotificationRecord r = mSnoozedNotifications.valueAt(i);\n                if (r.getSbn().getPackageName().equals(pkg) && r.getUserId() == userId\n                        && Objects.equals(r.getSbn().getGroup(), groupKey)) {\n                    records.add(r);\n                }\n            }\n        }\n        return records;\n    }\n\n    protected NotificationRecord getNotification(String key) {\n        synchronized (mLock) {\n            return mSnoozedNotifications.get(key);\n        }\n    }\n\n    protected @NonNull List<NotificationRecord> getSnoozed() {\n        synchronized (mLock) {\n            // caller filters records based on the current user profiles and listener access,\n            // so just return everything\n            List<NotificationRecord> snoozed = new ArrayList<>();\n            snoozed.addAll(mSnoozedNotifications.values());\n            return snoozed;\n        }\n    }\n\n    /**\n     * Snoozes a notification and schedules an alarm to repost at that time.\n     */\n    protected void snooze(NotificationRecord record, long duration) {\n        String key = record.getKey();\n\n        snooze(record);\n        scheduleRepost(key, duration);\n        Long activateAt = System.currentTimeMillis() + duration;\n        synchronized (mLock) {\n            mPersistedSnoozedNotifications.put(getTrimmedString(key), activateAt);\n        }\n    }\n\n    /**\n     * Records a snoozed notification.\n     */\n    protected void snooze(NotificationRecord record, String contextId) {\n        if (contextId != null) {\n            synchronized (mLock) {\n                mPersistedSnoozedNotificationsWithContext.put(\n                        getTrimmedString(record.getKey()),\n                        getTrimmedString(contextId)\n                );\n            }\n        }\n        snooze(record);\n    }\n\n    private void snooze(NotificationRecord record) {\n        if (DEBUG) {\n            Slog.d(TAG, \"Snoozing \" + record.getKey());\n        }\n        synchronized (mLock) {\n            mSnoozedNotifications.put(record.getKey(), record);\n        }\n    }\n\n    private String getTrimmedString(String key) {\n        if (key != null && key.length() > MAX_STRING_LENGTH) {\n            return key.substring(0, MAX_STRING_LENGTH);\n        }\n        return key;\n    }\n\n    protected boolean cancel(int userId, String pkg, String tag, int id) {\n        synchronized (mLock) {\n            final Set<Map.Entry<String, NotificationRecord>> records =\n                    mSnoozedNotifications.entrySet();\n            for (Map.Entry<String, NotificationRecord> record : records) {\n                final StatusBarNotification sbn = record.getValue().getSbn();\n                if (sbn.getPackageName().equals(pkg) && sbn.getUserId() == userId\n                        && Objects.equals(sbn.getTag(), tag) && sbn.getId() == id) {\n                    record.getValue().isCanceled = true;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    protected void cancel(int userId, boolean includeCurrentProfiles) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.size() == 0) {\n                return;\n            }\n            IntArray userIds = new IntArray();\n            userIds.add(userId);\n            if (includeCurrentProfiles) {\n                userIds = mUserProfiles.getCurrentProfileIds();\n            }\n            for (NotificationRecord r : mSnoozedNotifications.values()) {\n                if (userIds.binarySearch(r.getUserId()) >= 0) {\n                    r.isCanceled = true;\n                }\n            }\n        }\n    }\n\n    protected boolean cancel(int userId, String pkg) {\n        synchronized (mLock) {\n            int n = mSnoozedNotifications.size();\n            for (int i = 0; i < n; i++) {\n                final NotificationRecord r = mSnoozedNotifications.valueAt(i);\n                if (r.getSbn().getPackageName().equals(pkg) && r.getUserId() == userId) {\n                    r.isCanceled = true;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Updates the notification record so the most up to date information is shown on re-post.\n     */\n    protected void update(int userId, NotificationRecord record) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.containsKey(record.getKey())) {\n                mSnoozedNotifications.put(record.getKey(), record);\n            }\n        }\n    }\n\n    protected void repost(String key, boolean muteOnReturn) {\n        synchronized (mLock) {\n            final NotificationRecord r = mSnoozedNotifications.get(key);\n            if (r != null) {\n                repost(key, r.getUserId(), muteOnReturn);\n            }\n        }\n    }\n\n    protected void repost(String key, int userId, boolean muteOnReturn) {\n        final String trimmedKey = getTrimmedString(key);\n\n        NotificationRecord record;\n        synchronized (mLock) {\n            mPersistedSnoozedNotifications.remove(trimmedKey);\n            mPersistedSnoozedNotificationsWithContext.remove(trimmedKey);\n            record = mSnoozedNotifications.remove(key);\n        }\n\n        if (record != null && !record.isCanceled) {\n            final PendingIntent pi = createPendingIntent(record.getKey());\n            mAm.cancel(pi);\n            MetricsLogger.action(record.getLogMaker()\n                    .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                    .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n            mCallback.repost(record.getUserId(), record, muteOnReturn);\n        }\n    }\n\n    protected void repostGroupSummary(String pkg, int userId, String groupKey) {\n        synchronized (mLock) {\n            String groupSummaryKey = null;\n            int n = mSnoozedNotifications.size();\n            for (int i = 0; i < n; i++) {\n                final NotificationRecord potentialGroupSummary = mSnoozedNotifications.valueAt(i);\n                if (potentialGroupSummary.getSbn().getPackageName().equals(pkg)\n                        && potentialGroupSummary.getUserId() == userId\n                        && potentialGroupSummary.getSbn().isGroup()\n                        && potentialGroupSummary.getNotification().isGroupSummary()\n                        && groupKey.equals(potentialGroupSummary.getGroupKey())) {\n                    groupSummaryKey = potentialGroupSummary.getKey();\n                    break;\n                }\n            }\n\n            if (groupSummaryKey != null) {\n                NotificationRecord record = mSnoozedNotifications.remove(groupSummaryKey);\n                String trimmedKey = getTrimmedString(groupSummaryKey);\n                mPersistedSnoozedNotificationsWithContext.remove(trimmedKey);\n                mPersistedSnoozedNotifications.remove(trimmedKey);\n\n                if (record != null && !record.isCanceled) {\n                    Runnable runnable = () -> {\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n                        mCallback.repost(record.getUserId(), record, false);\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    protected void clearData(int userId, String pkg) {\n        synchronized (mLock) {\n            int n = mSnoozedNotifications.size();\n            for (int i = n - 1; i >= 0; i--) {\n                final NotificationRecord record = mSnoozedNotifications.valueAt(i);\n                if (record.getUserId() == userId && record.getSbn().getPackageName().equals(pkg)) {\n                    mSnoozedNotifications.removeAt(i);\n                    String trimmedKey = getTrimmedString(record.getKey());\n                    mPersistedSnoozedNotificationsWithContext.remove(trimmedKey);\n                    mPersistedSnoozedNotifications.remove(trimmedKey);\n                    Runnable runnable = () -> {\n                        final PendingIntent pi = createPendingIntent(record.getKey());\n                        mAm.cancel(pi);\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_DISMISS));\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    protected void clearData(int userId) {\n        synchronized (mLock) {\n            int n = mSnoozedNotifications.size();\n            for (int i = n - 1; i >= 0; i--) {\n                final NotificationRecord record = mSnoozedNotifications.valueAt(i);\n                if (record.getUserId() == userId) {\n                    mSnoozedNotifications.removeAt(i);\n                    String trimmedKey = getTrimmedString(record.getKey());\n                    mPersistedSnoozedNotificationsWithContext.remove(trimmedKey);\n                    mPersistedSnoozedNotifications.remove(trimmedKey);\n\n                    Runnable runnable = () -> {\n                        final PendingIntent pi = createPendingIntent(record.getKey());\n                        mAm.cancel(pi);\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_DISMISS));\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    private PendingIntent createPendingIntent(String key) {\n        return PendingIntent.getBroadcast(mContext,\n                REQUEST_CODE_REPOST,\n                new Intent(REPOST_ACTION)\n                        .setPackage(PackageManagerService.PLATFORM_PACKAGE_NAME)\n                        .setData(new Uri.Builder().scheme(REPOST_SCHEME).appendPath(key).build())\n                        .addFlags(Intent.FLAG_RECEIVER_FOREGROUND)\n                        .putExtra(EXTRA_KEY, key),\n                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n    }\n\n    public void scheduleRepostsForPersistedNotifications(long currentTime) {\n        synchronized (mLock) {\n            for (int i = 0; i < mPersistedSnoozedNotifications.size(); i++) {\n                String key = mPersistedSnoozedNotifications.keyAt(i);\n                Long time = mPersistedSnoozedNotifications.valueAt(i);\n                if (time != null && time > currentTime) {\n                    scheduleRepostAtTime(key, time);\n                }\n            }\n        }\n    }\n\n    private void scheduleRepost(String key, long duration) {\n        scheduleRepostAtTime(key, System.currentTimeMillis() + duration);\n    }\n\n    private void scheduleRepostAtTime(String key, long time) {\n        Runnable runnable = () -> {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final PendingIntent pi = createPendingIntent(key);\n                mAm.cancel(pi);\n                if (DEBUG) Slog.d(TAG, \"Scheduling evaluate for \" + new Date(time));\n                mAm.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pi);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        };\n        runnable.run();\n    }\n\n    public void dump(PrintWriter pw, NotificationManagerService.DumpFilter filter) {\n        synchronized (mLock) {\n            pw.println(\"\\n  Snoozed notifications:\");\n            for (String key : mSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + key);\n            }\n            pw.println(\"\\n Pending snoozed notifications\");\n            for (String key : mPersistedSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + key + \" until: \" + mPersistedSnoozedNotifications.get(key));\n            }\n        }\n    }\n\n    protected void writeXml(TypedXmlSerializer out) throws IOException {\n        synchronized (mLock) {\n            final long currentTime = System.currentTimeMillis();\n            out.startTag(null, XML_TAG_NAME);\n            writeXml(out, mPersistedSnoozedNotifications, XML_SNOOZED_NOTIFICATION,\n                    value -> {\n                        if (value < currentTime) {\n                            return;\n                        }\n                        out.attributeLong(null, XML_SNOOZED_NOTIFICATION_TIME,\n                                value);\n                    });\n            writeXml(out, mPersistedSnoozedNotificationsWithContext,\n                    XML_SNOOZED_NOTIFICATION_CONTEXT,\n                    value -> {\n                        out.attribute(null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID,\n                                value);\n                    });\n            out.endTag(null, XML_TAG_NAME);\n        }\n    }\n\n    private interface Inserter<T> {\n        void insert(T t) throws IOException;\n    }\n\n    private <T> void writeXml(TypedXmlSerializer out, ArrayMap<String, T> targets, String tag,\n            Inserter<T> attributeInserter) throws IOException {\n        for (int j = 0; j < targets.size(); j++) {\n            String key = targets.keyAt(j);\n            // T is a String (snoozed until context) or Long (snoozed until time)\n            T value = targets.valueAt(j);\n\n            out.startTag(null, tag);\n\n            attributeInserter.insert(value);\n\n            out.attributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL,\n                    XML_SNOOZED_NOTIFICATION_VERSION);\n            out.attribute(null, XML_SNOOZED_NOTIFICATION_KEY, key);\n\n            out.endTag(null, tag);\n        }\n    }\n\n    protected void readXml(TypedXmlPullParser parser, long currentTime)\n            throws XmlPullParserException, IOException {\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {\n            String tag = parser.getName();\n            if (type == XmlPullParser.END_TAG\n                    && XML_TAG_NAME.equals(tag)) {\n                break;\n            }\n            if (type == XmlPullParser.START_TAG\n                    && (XML_SNOOZED_NOTIFICATION.equals(tag)\n                        || tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT))\n                    && parser.getAttributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL, -1)\n                        == XML_SNOOZED_NOTIFICATION_VERSION) {\n                try {\n                    final String key = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_KEY);\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION)) {\n                        final Long time = parser.getAttributeLong(\n                                null, XML_SNOOZED_NOTIFICATION_TIME, 0);\n                        if (time > currentTime) { //only read new stuff\n                            synchronized (mLock) {\n                                mPersistedSnoozedNotifications.put(key, time);\n                            }\n                        }\n                    }\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT)) {\n                        final String creationId = parser.getAttributeValue(\n                                null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID);\n                        synchronized (mLock) {\n                            mPersistedSnoozedNotificationsWithContext.put(key, creationId);\n                        }\n                    }\n                } catch (Exception e) {\n                    Slog.e(TAG,  \"Exception in reading snooze data from policy xml\", e);\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void setAlarmManager(AlarmManager am) {\n        mAm = am;\n    }\n\n    protected interface Callback {\n        void repost(int userId, NotificationRecord r, boolean muteOnReturn);\n    }\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (DEBUG) {\n                Slog.d(TAG, \"Reposting notification\");\n            }\n            if (REPOST_ACTION.equals(intent.getAction())) {\n                repost(intent.getStringExtra(EXTRA_KEY), intent.getIntExtra(EXTRA_USER_ID,\n                        UserHandle.USER_SYSTEM), false);\n            }\n        }\n    };\n}\n```",
            "upstream_file_tokens": {
              "openai": 4582,
              "general": {
                "word_based": 1807,
                "char_based": 5787
              },
              "gemini": 5452
            },
            "downstream_file_content": "```java\n/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.android.server.notification;\n\nimport android.annotation.NonNull;\nimport android.annotation.UserIdInt;\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.service.notification.StatusBarNotification;\nimport android.util.ArrayMap;\nimport android.util.IntArray;\nimport android.util.Log;\nimport android.util.Slog;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto;\nimport com.android.internal.util.XmlUtils;\nimport com.android.server.pm.PackageManagerService;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * NotificationManagerService helper for handling snoozed notifications.\n */\npublic class SnoozeHelper {\n    public static final int XML_SNOOZED_NOTIFICATION_VERSION = 1;\n\n    static final int CONCURRENT_SNOOZE_LIMIT = 500;\n\n    // A safe size for strings to be put in persistent storage, to avoid breaking the XML write.\n    static final int MAX_STRING_LENGTH = 1000;\n\n    protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n\n    private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT = \"context\";\n    private static final String XML_SNOOZED_NOTIFICATION_PKG = \"pkg\";\n    private static final String XML_SNOOZED_NOTIFICATION_USER_ID = \"user-id\";\n    private static final String XML_SNOOZED_NOTIFICATION_KEY = \"key\";\n    //the time the snoozed notification should be reposted\n    private static final String XML_SNOOZED_NOTIFICATION_TIME = \"time\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT_ID = \"id\";\n    private static final String XML_SNOOZED_NOTIFICATION_VERSION_LABEL = \"version\";\n\n\n    private static final String TAG = \"SnoozeHelper\";\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n    private static final String INDENT = \"    \";\n\n    private static final String REPOST_ACTION = SnoozeHelper.class.getSimpleName() + \".EVALUATE\";\n    private static final int REQUEST_CODE_REPOST = 1;\n    private static final String REPOST_SCHEME = \"repost\";\n    static final String EXTRA_KEY = \"key\";\n    private static final String EXTRA_USER_ID = \"userId\";\n\n    private final Context mContext;\n    private AlarmManager mAm;\n    private final ManagedServices.UserProfiles mUserProfiles;\n\n    // User id | package name : notification key : record.\n    private ArrayMap<String, ArrayMap<String, NotificationRecord>>\n            mSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : time-milliseconds .\n    // This member stores persisted snoozed notification trigger times. it persists through reboots\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, Long>>\n            mPersistedSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : creation ID .\n    // This member stores persisted snoozed notification trigger context for the assistant\n    // it persists through reboots.\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, String>>\n            mPersistedSnoozedNotificationsWithContext = new ArrayMap<>();\n    // notification key : package.\n    private ArrayMap<String, String> mPackages = new ArrayMap<>();\n    // key : userId\n    private ArrayMap<String, Integer> mUsers = new ArrayMap<>();\n    private Callback mCallback;\n\n    private final Object mLock = new Object();\n\n    public SnoozeHelper(Context context, Callback callback,\n            ManagedServices.UserProfiles userProfiles) {\n        mContext = context;\n        IntentFilter filter = new IntentFilter(REPOST_ACTION);\n        filter.addDataScheme(REPOST_SCHEME);\n        mContext.registerReceiver(mBroadcastReceiver, filter);\n        mAm = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mCallback = callback;\n        mUserProfiles = userProfiles;\n    }\n\n    private String getPkgKey(@UserIdInt int userId, String pkg) {\n        return userId + \"|\" + pkg;\n    }\n\n    void cleanupPersistedContext(String key){\n        synchronized (mLock) {\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            removeRecordLocked(pkg, key, userId, mPersistedSnoozedNotificationsWithContext);\n        }\n    }\n\n    protected boolean canSnooze(int numberToSnooze) {\n        synchronized (mLock) {\n            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @NonNull\n    protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n        Long time = null;\n        synchronized (mLock) {\n           ArrayMap<String, Long> snoozed =\n                   mPersistedSnoozedNotifications.get(getPkgKey(userId, pkg));\n           if (snoozed != null) {\n               time = snoozed.get(getTrimmedString(key));\n           }\n        }\n        if (time == null) {\n            time = 0L;\n        }\n        return time;\n    }\n\n    protected String getSnoozeContextForUnpostedNotification(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            ArrayMap<String, String> snoozed =\n                    mPersistedSnoozedNotificationsWithContext.get(getPkgKey(userId, pkg));\n            if (snoozed != null) {\n                return snoozed.get(getTrimmedString(key));\n            }\n        }\n        return null;\n    }\n\n    protected boolean isSnoozed(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            return mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))\n                    && mSnoozedNotifications.get(getPkgKey(userId, pkg)).containsKey(key);\n        }\n    }\n\n    protected Collection<NotificationRecord> getSnoozed(int userId, String pkg) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))) {\n                return mSnoozedNotifications.get(getPkgKey(userId, pkg)).values();\n            }\n        }\n        return Collections.EMPTY_LIST;\n    }\n\n    @NonNull\n    ArrayList<NotificationRecord> getNotifications(String pkg,\n            String groupKey, Integer userId) {\n        ArrayList<NotificationRecord> records =  new ArrayList<>();\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> allRecords =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (allRecords != null) {\n                for (int i = 0; i < allRecords.size(); i++) {\n                    NotificationRecord r = allRecords.valueAt(i);\n                    String currentGroupKey = r.getSbn().getGroup();\n                    if (Objects.equals(currentGroupKey, groupKey)) {\n                        records.add(r);\n                    }\n                }\n            }\n        }\n        return records;\n    }\n\n    protected NotificationRecord getNotification(String key) {\n        synchronized (mLock) {\n            if (!mUsers.containsKey(key) || !mPackages.containsKey(key)) {\n                Slog.w(TAG, \"Snoozed data sets no longer agree for \" + key);\n                return null;\n            }\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            ArrayMap<String, NotificationRecord> snoozed =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (snoozed == null) {\n                return null;\n            }\n            return snoozed.get(key);\n        }\n    }\n\n    protected @NonNull List<NotificationRecord> getSnoozed() {\n        synchronized (mLock) {\n            // caller filters records based on the current user profiles and listener access, so just\n            // return everything\n            List<NotificationRecord> snoozed = new ArrayList<>();\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                snoozed.addAll(snoozedRecords.values());\n            }\n            return snoozed;\n        }\n    }\n\n    /**\n     * Snoozes a notification and schedules an alarm to repost at that time.\n     */\n    protected void snooze(NotificationRecord record, long duration) {\n        String pkg = record.getSbn().getPackageName();\n        String key = record.getKey();\n        int userId = record.getUser().getIdentifier();\n\n        snooze(record);\n        scheduleRepost(pkg, key, userId, duration);\n        Long activateAt = System.currentTimeMillis() + duration;\n        synchronized (mLock) {\n            storeRecordLocked(pkg, getTrimmedString(key), userId, mPersistedSnoozedNotifications,\n                    activateAt);\n        }\n    }\n\n    /**\n     * Records a snoozed notification.\n     */\n    protected void snooze(NotificationRecord record, String contextId) {\n        int userId = record.getUser().getIdentifier();\n        if (contextId != null) {\n            synchronized (mLock) {\n                storeRecordLocked(record.getSbn().getPackageName(),\n                        getTrimmedString(record.getKey()),\n                        userId, mPersistedSnoozedNotificationsWithContext,\n                        getTrimmedString(contextId));\n            }\n        }\n        snooze(record);\n    }\n\n    private void snooze(NotificationRecord record) {\n        int userId = record.getUser().getIdentifier();\n        if (DEBUG) {\n            Slog.d(TAG, \"Snoozing \" + record.getKey());\n        }\n        synchronized (mLock) {\n            storeRecordLocked(record.getSbn().getPackageName(), record.getKey(),\n                    userId, mSnoozedNotifications, record);\n        }\n    }\n\n    private String getTrimmedString(String key) {\n        if (key != null && key.length() > MAX_STRING_LENGTH) {\n            return key.substring(0, MAX_STRING_LENGTH);\n        }\n        return key;\n    }\n\n    private <T> void storeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets, T object) {\n\n        mPackages.put(key, pkg);\n        mUsers.put(key, userId);\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            keyToValue = new ArrayMap<>();\n        }\n        keyToValue.put(key, object);\n        targets.put(getPkgKey(userId, pkg), keyToValue);\n    }\n\n    private <T> T removeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets) {\n        T object = null;\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            return null;\n        }\n        object = keyToValue.remove(key);\n        if (keyToValue.size() == 0) {\n            targets.remove(getPkgKey(userId, pkg));\n        }\n        return object;\n    }\n\n    protected boolean cancel(int userId, String pkg, String tag, int id) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsForPkg =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsForPkg != null) {\n                final Set<Map.Entry<String, NotificationRecord>> records = recordsForPkg.entrySet();\n                for (Map.Entry<String, NotificationRecord> record : records) {\n                    final StatusBarNotification sbn = record.getValue().getSbn();\n                    if (Objects.equals(sbn.getTag(), tag) && sbn.getId() == id) {\n                        record.getValue().isCanceled = true;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    protected void cancel(int userId, boolean includeCurrentProfiles) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.size() == 0) {\n                return;\n            }\n            IntArray userIds = new IntArray();\n            userIds.add(userId);\n            if (includeCurrentProfiles) {\n                userIds = mUserProfiles.getCurrentProfileIds();\n            }\n            for (ArrayMap<String, NotificationRecord> snoozedRecords : mSnoozedNotifications.values()) {\n                for (NotificationRecord r : snoozedRecords.values()) {\n                    if (userIds.binarySearch(r.getUserId()) >= 0) {\n                        r.isCanceled = true;\n                    }\n                }\n            }\n        }\n    }\n\n    protected boolean cancel(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return false;\n            }\n            int N = records.size();\n            for (int i = 0; i < N; i++) {\n                records.valueAt(i).isCanceled = true;\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Updates the notification record so the most up to date information is shown on re-post.\n     */\n    protected void update(int userId, NotificationRecord record) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, record.getSbn().getPackageName()));\n            if (records == null) {\n                return;\n            }\n            records.put(record.getKey(), record);\n        }\n    }\n\n    protected void repost(String key, boolean muteOnReturn) {\n        synchronized (mLock) {\n            Integer userId = mUsers.get(key);\n            if (userId != null) {\n                repost(key, userId, muteOnReturn);\n            }\n        }\n    }\n\n    protected void repost(String key, int userId, boolean muteOnReturn) {\n        final String trimmedKey = getTrimmedString(key);\n\n        NotificationRecord record;\n        synchronized (mLock) {\n            final String pkg = mPackages.remove(key);\n            mUsers.remove(key);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            record = records.remove(key);\n\n        }\n\n        if (record != null && !record.isCanceled) {\n            final PendingIntent pi = createPendingIntent(\n                    record.getSbn().getPackageName(), record.getKey(), userId);\n            mAm.cancel(pi);\n            MetricsLogger.action(record.getLogMaker()\n                    .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                    .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n            mCallback.repost(userId, record, muteOnReturn);\n        }\n    }\n\n    protected void repostGroupSummary(String pkg, int userId, String groupKey) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsByKey\n                    = mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsByKey == null) {\n                return;\n            }\n\n            String groupSummaryKey = null;\n            int N = recordsByKey.size();\n            for (int i = 0; i < N; i++) {\n                final NotificationRecord potentialGroupSummary = recordsByKey.valueAt(i);\n                if (potentialGroupSummary.getSbn().isGroup()\n                        && potentialGroupSummary.getNotification().isGroupSummary()\n                        && groupKey.equals(potentialGroupSummary.getGroupKey())) {\n                    groupSummaryKey = potentialGroupSummary.getKey();\n                    break;\n                }\n            }\n\n            if (groupSummaryKey != null) {\n                NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                mPackages.remove(groupSummaryKey);\n                mUsers.remove(groupSummaryKey);\n\n                if (record != null && !record.isCanceled) {\n                    Runnable runnable = () -> {\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n                        mCallback.repost(userId, record, false);\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    protected void clearData(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            for (int i = records.size() - 1; i >= 0; i--) {\n                final NotificationRecord r = records.removeAt(i);\n                if (r != null) {\n                    mPackages.remove(r.getKey());\n                    mUsers.remove(r.getKey());\n                    Runnable runnable = () -> {\n                        final PendingIntent pi = createPendingIntent(pkg, r.getKey(), userId);\n                        mAm.cancel(pi);\n                        MetricsLogger.action(r.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_DISMISS));\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    private PendingIntent createPendingIntent(String pkg, String key, int userId) {\n        return PendingIntent.getBroadcast(mContext,\n                REQUEST_CODE_REPOST,\n                new Intent(REPOST_ACTION)\n                        .setPackage(PackageManagerService.PLATFORM_PACKAGE_NAME)\n                        .setData(new Uri.Builder().scheme(REPOST_SCHEME).appendPath(key).build())\n                        .addFlags(Intent.FLAG_RECEIVER_FOREGROUND)\n                        .putExtra(EXTRA_KEY, key)\n                        .putExtra(EXTRA_USER_ID, userId),\n                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n    }\n\n    public void scheduleRepostsForPersistedNotifications(long currentTime) {\n        synchronized (mLock) {\n            for (ArrayMap<String, Long> snoozed : mPersistedSnoozedNotifications.values()) {\n                for (int i = 0; i < snoozed.size(); i++) {\n                    String key = snoozed.keyAt(i);\n                    Long time = snoozed.valueAt(i);\n                    String pkg = mPackages.get(key);\n                    Integer userId = mUsers.get(key);\n                    if (time == null || pkg == null || userId == null) {\n                        Slog.w(TAG, \"data out of sync: \" + time + \"|\" + pkg + \"|\" + userId);\n                        continue;\n                    }\n                    if (time != null && time > currentTime) {\n                        scheduleRepostAtTime(pkg, key, userId, time);\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleRepost(String pkg, String key, int userId, long duration) {\n        scheduleRepostAtTime(pkg, key, userId, System.currentTimeMillis() + duration);\n    }\n\n    private void scheduleRepostAtTime(String pkg, String key, int userId, long time) {\n        Runnable runnable = () -> {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final PendingIntent pi = createPendingIntent(pkg, key, userId);\n                mAm.cancel(pi);\n                if (DEBUG) Slog.d(TAG, \"Scheduling evaluate for \" + new Date(time));\n                mAm.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pi);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        };\n        runnable.run();\n    }\n\n    public void dump(PrintWriter pw, NotificationManagerService.DumpFilter filter) {\n        synchronized (mLock) {\n            pw.println(\"\\n  Snoozed notifications:\");\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.println(key);\n                }\n            }\n            pw.println(\"\\n Pending snoozed notifications\");\n            for (String userPkgKey : mPersistedSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, Long> snoozedRecords =\n                        mPersistedSnoozedNotifications.get(userPkgKey);\n                if (snoozedRecords == null) {\n                    continue;\n                }\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(key);\n                    pw.print(INDENT);\n                    pw.println(snoozedRecords.get(key));\n                }\n            }\n        }\n    }\n\n    protected void writeXml(TypedXmlSerializer out) throws IOException {\n        synchronized (mLock) {\n            final long currentTime = System.currentTimeMillis();\n            out.startTag(null, XML_TAG_NAME);\n            writeXml(out, mPersistedSnoozedNotifications, XML_SNOOZED_NOTIFICATION,\n                    value -> {\n                        if (value < currentTime) {\n                            return;\n                        }\n                        out.attributeLong(null, XML_SNOOZED_NOTIFICATION_TIME,\n                                value);\n                    });\n            writeXml(out, mPersistedSnoozedNotificationsWithContext,\n                    XML_SNOOZED_NOTIFICATION_CONTEXT,\n                    value -> {\n                        out.attribute(null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID,\n                                value);\n                    });\n            out.endTag(null, XML_TAG_NAME);\n        }\n    }\n\n    private interface Inserter<T> {\n        void insert(T t) throws IOException;\n    }\n\n    private <T> void writeXml(TypedXmlSerializer out,\n            ArrayMap<String, ArrayMap<String, T>> targets, String tag,\n            Inserter<T> attributeInserter)\n            throws IOException {\n        final int M = targets.size();\n        for (int i = 0; i < M; i++) {\n            // T is a String (snoozed until context) or Long (snoozed until time)\n            ArrayMap<String, T> keyToValue = targets.valueAt(i);\n            for (int j = 0; j < keyToValue.size(); j++) {\n                String key = keyToValue.keyAt(j);\n                T value = keyToValue.valueAt(j);\n                String pkg = mPackages.get(key);\n                Integer userId = mUsers.get(key);\n\n                if (pkg == null || userId == null) {\n                    Slog.w(TAG, \"pkg \" + pkg + \" or user \" + userId + \" missing for \" + key);\n                    continue;\n                }\n\n                out.startTag(null, tag);\n\n                attributeInserter.insert(value);\n\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL,\n                        XML_SNOOZED_NOTIFICATION_VERSION);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_KEY, key);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_PKG, pkg);\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_USER_ID, userId);\n\n                out.endTag(null, tag);\n            }\n        }\n    }\n\n    protected void readXml(TypedXmlPullParser parser, long currentTime)\n            throws XmlPullParserException, IOException {\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {\n            String tag = parser.getName();\n            if (type == XmlPullParser.END_TAG\n                    && XML_TAG_NAME.equals(tag)) {\n                break;\n            }\n            if (type == XmlPullParser.START_TAG\n                    && (XML_SNOOZED_NOTIFICATION.equals(tag)\n                        || tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT))\n                    && parser.getAttributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL, -1)\n                        == XML_SNOOZED_NOTIFICATION_VERSION) {\n                try {\n                    final String key = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_KEY);\n                    final String pkg = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_PKG);\n                    final int userId = parser.getAttributeInt(\n                            null, XML_SNOOZED_NOTIFICATION_USER_ID, UserHandle.USER_ALL);\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION)) {\n                        final Long time = parser.getAttributeLong(\n                                null, XML_SNOOZED_NOTIFICATION_TIME, 0);\n                        if (time > currentTime) { //only read new stuff\n                            synchronized (mLock) {\n                                storeRecordLocked(\n                                        pkg, key, userId, mPersistedSnoozedNotifications, time);\n                            }\n                        }\n                    }\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT)) {\n                        final String creationId = parser.getAttributeValue(\n                                null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID);\n                        synchronized (mLock) {\n                            storeRecordLocked(\n                                    pkg, key, userId, mPersistedSnoozedNotificationsWithContext,\n                                    creationId);\n                        }\n                    }\n                } catch (Exception e) {\n                    Slog.e(TAG,  \"Exception in reading snooze data from policy xml\", e);\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void setAlarmManager(AlarmManager am) {\n        mAm = am;\n    }\n\n    protected interface Callback {\n        void repost(int userId, NotificationRecord r, boolean muteOnReturn);\n    }\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (DEBUG) {\n                Slog.d(TAG, \"Reposting notification\");\n            }\n            if (REPOST_ACTION.equals(intent.getAction())) {\n                repost(intent.getStringExtra(EXTRA_KEY), intent.getIntExtra(EXTRA_USER_ID,\n                        UserHandle.USER_SYSTEM), false);\n            }\n        }\n    };\n}\n```",
            "downstream_file_tokens": {
              "openai": 5729,
              "general": {
                "word_based": 2301,
                "char_based": 7141
              },
              "gemini": 6865
            },
            "downstream_file_content_ground_truth": "/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.android.server.notification;\n\nimport android.annotation.NonNull;\nimport android.annotation.UserIdInt;\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.service.notification.StatusBarNotification;\nimport android.util.ArrayMap;\nimport android.util.IntArray;\nimport android.util.Log;\nimport android.util.Slog;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto;\nimport com.android.internal.util.XmlUtils;\nimport com.android.server.pm.PackageManagerService;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * NotificationManagerService helper for handling snoozed notifications.\n */\npublic class SnoozeHelper {\n    public static final int XML_SNOOZED_NOTIFICATION_VERSION = 1;\n\n    static final int CONCURRENT_SNOOZE_LIMIT = 500;\n\n    // A safe size for strings to be put in persistent storage, to avoid breaking the XML write.\n    static final int MAX_STRING_LENGTH = 1000;\n\n    protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n\n    private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT = \"context\";\n    private static final String XML_SNOOZED_NOTIFICATION_PKG = \"pkg\";\n    private static final String XML_SNOOZED_NOTIFICATION_USER_ID = \"user-id\";\n    private static final String XML_SNOOZED_NOTIFICATION_KEY = \"key\";\n    //the time the snoozed notification should be reposted\n    private static final String XML_SNOOZED_NOTIFICATION_TIME = \"time\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT_ID = \"id\";\n    private static final String XML_SNOOZED_NOTIFICATION_VERSION_LABEL = \"version\";\n\n\n    private static final String TAG = \"SnoozeHelper\";\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n    private static final String INDENT = \"    \";\n\n    private static final String REPOST_ACTION = SnoozeHelper.class.getSimpleName() + \".EVALUATE\";\n    private static final int REQUEST_CODE_REPOST = 1;\n    private static final String REPOST_SCHEME = \"repost\";\n    static final String EXTRA_KEY = \"key\";\n    private static final String EXTRA_USER_ID = \"userId\";\n\n    private final Context mContext;\n    private AlarmManager mAm;\n    private final ManagedServices.UserProfiles mUserProfiles;\n\n    // User id | package name : notification key : record.\n    private ArrayMap<String, ArrayMap<String, NotificationRecord>>\n            mSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : time-milliseconds .\n    // This member stores persisted snoozed notification trigger times. it persists through reboots\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, Long>>\n            mPersistedSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : creation ID .\n    // This member stores persisted snoozed notification trigger context for the assistant\n    // it persists through reboots.\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, String>>\n            mPersistedSnoozedNotificationsWithContext = new ArrayMap<>();\n    // notification key : package.\n    private ArrayMap<String, String> mPackages = new ArrayMap<>();\n    // key : userId\n    private ArrayMap<String, Integer> mUsers = new ArrayMap<>();\n    private Callback mCallback;\n\n    private final Object mLock = new Object();\n\n    public SnoozeHelper(Context context, Callback callback,\n            ManagedServices.UserProfiles userProfiles) {\n        mContext = context;\n        IntentFilter filter = new IntentFilter(REPOST_ACTION);\n        filter.addDataScheme(REPOST_SCHEME);\n        mContext.registerReceiver(mBroadcastReceiver, filter);\n        mAm = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mCallback = callback;\n        mUserProfiles = userProfiles;\n    }\n\n    private String getPkgKey(@UserIdInt int userId, String pkg) {\n        return userId + \"|\" + pkg;\n    }\n\n    void cleanupPersistedContext(String key){\n        synchronized (mLock) {\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            removeRecordLocked(pkg, key, userId, mPersistedSnoozedNotificationsWithContext);\n        }\n    }\n\n    protected boolean canSnooze(int numberToSnooze) {\n        synchronized (mLock) {\n            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n                || (countPersistedNotificationsLocked() + numberToSnooze)\n                > CONCURRENT_SNOOZE_LIMIT) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int countPersistedNotificationsLocked() {\n        int numNotifications = 0;\n        for (ArrayMap<String, String> persistedWithContext :\n                mPersistedSnoozedNotificationsWithContext.values()) {\n            numNotifications += persistedWithContext.size();\n        }\n        for (ArrayMap<String, Long> persistedWithDuration :\n                mPersistedSnoozedNotifications.values()) {\n            numNotifications += persistedWithDuration.size();\n        }\n        return numNotifications;\n    }\n\n\n    @NonNull\n    protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n        Long time = null;\n        synchronized (mLock) {\n           ArrayMap<String, Long> snoozed =\n                   mPersistedSnoozedNotifications.get(getPkgKey(userId, pkg));\n           if (snoozed != null) {\n               time = snoozed.get(getTrimmedString(key));\n           }\n        }\n        if (time == null) {\n            time = 0L;\n        }\n        return time;\n    }\n\n    protected String getSnoozeContextForUnpostedNotification(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            ArrayMap<String, String> snoozed =\n                    mPersistedSnoozedNotificationsWithContext.get(getPkgKey(userId, pkg));\n            if (snoozed != null) {\n                return snoozed.get(getTrimmedString(key));\n            }\n        }\n        return null;\n    }\n\n    protected boolean isSnoozed(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            return mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))\n                    && mSnoozedNotifications.get(getPkgKey(userId, pkg)).containsKey(key);\n        }\n    }\n\n    protected Collection<NotificationRecord> getSnoozed(int userId, String pkg) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))) {\n                return mSnoozedNotifications.get(getPkgKey(userId, pkg)).values();\n            }\n        }\n        return Collections.EMPTY_LIST;\n    }\n\n    @NonNull\n    ArrayList<NotificationRecord> getNotifications(String pkg,\n            String groupKey, Integer userId) {\n        ArrayList<NotificationRecord> records =  new ArrayList<>();\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> allRecords =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (allRecords != null) {\n                for (int i = 0; i < allRecords.size(); i++) {\n                    NotificationRecord r = allRecords.valueAt(i);\n                    String currentGroupKey = r.getSbn().getGroup();\n                    if (Objects.equals(currentGroupKey, groupKey)) {\n                        records.add(r);\n                    }\n                }\n            }\n        }\n        return records;\n    }\n\n    protected NotificationRecord getNotification(String key) {\n        synchronized (mLock) {\n            if (!mUsers.containsKey(key) || !mPackages.containsKey(key)) {\n                Slog.w(TAG, \"Snoozed data sets no longer agree for \" + key);\n                return null;\n            }\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            ArrayMap<String, NotificationRecord> snoozed =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (snoozed == null) {\n                return null;\n            }\n            return snoozed.get(key);\n        }\n    }\n\n    protected @NonNull List<NotificationRecord> getSnoozed() {\n        synchronized (mLock) {\n            // caller filters records based on the current user profiles and listener access, so just\n            // return everything\n            List<NotificationRecord> snoozed = new ArrayList<>();\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                snoozed.addAll(snoozedRecords.values());\n            }\n            return snoozed;\n        }\n    }\n\n    /**\n     * Snoozes a notification and schedules an alarm to repost at that time.\n     */\n    protected void snooze(NotificationRecord record, long duration) {\n        String pkg = record.getSbn().getPackageName();\n        String key = record.getKey();\n        int userId = record.getUser().getIdentifier();\n\n        snooze(record);\n        scheduleRepost(pkg, key, userId, duration);\n        Long activateAt = System.currentTimeMillis() + duration;\n        synchronized (mLock) {\n            storeRecordLocked(pkg, getTrimmedString(key), userId, mPersistedSnoozedNotifications,\n                    activateAt);\n        }\n    }\n\n    /**\n     * Records a snoozed notification.\n     */\n    protected void snooze(NotificationRecord record, String contextId) {\n        int userId = record.getUser().getIdentifier();\n        if (contextId != null) {\n            synchronized (mLock) {\n                storeRecordLocked(record.getSbn().getPackageName(),\n                        getTrimmedString(record.getKey()),\n                        userId, mPersistedSnoozedNotificationsWithContext,\n                        getTrimmedString(contextId));\n            }\n        }\n        snooze(record);\n    }\n\n    private void snooze(NotificationRecord record) {\n        int userId = record.getUser().getIdentifier();\n        if (DEBUG) {\n            Slog.d(TAG, \"Snoozing \" + record.getKey());\n        }\n        synchronized (mLock) {\n            storeRecordLocked(record.getSbn().getPackageName(), record.getKey(),\n                    userId, mSnoozedNotifications, record);\n        }\n    }\n\n    private String getTrimmedString(String key) {\n        if (key != null && key.length() > MAX_STRING_LENGTH) {\n            return key.substring(0, MAX_STRING_LENGTH);\n        }\n        return key;\n    }\n\n    private <T> void storeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets, T object) {\n\n        mPackages.put(key, pkg);\n        mUsers.put(key, userId);\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            keyToValue = new ArrayMap<>();\n        }\n        keyToValue.put(key, object);\n        targets.put(getPkgKey(userId, pkg), keyToValue);\n    }\n\n    private <T> T removeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets) {\n        T object = null;\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            return null;\n        }\n        object = keyToValue.remove(key);\n        if (keyToValue.size() == 0) {\n            targets.remove(getPkgKey(userId, pkg));\n        }\n        return object;\n    }\n\n    protected boolean cancel(int userId, String pkg, String tag, int id) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsForPkg =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsForPkg != null) {\n                final Set<Map.Entry<String, NotificationRecord>> records = recordsForPkg.entrySet();\n                for (Map.Entry<String, NotificationRecord> record : records) {\n                    final StatusBarNotification sbn = record.getValue().getSbn();\n                    if (Objects.equals(sbn.getTag(), tag) && sbn.getId() == id) {\n                        record.getValue().isCanceled = true;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    protected void cancel(int userId, boolean includeCurrentProfiles) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.size() == 0) {\n                return;\n            }\n            IntArray userIds = new IntArray();\n            userIds.add(userId);\n            if (includeCurrentProfiles) {\n                userIds = mUserProfiles.getCurrentProfileIds();\n            }\n            for (ArrayMap<String, NotificationRecord> snoozedRecords : mSnoozedNotifications.values()) {\n                for (NotificationRecord r : snoozedRecords.values()) {\n                    if (userIds.binarySearch(r.getUserId()) >= 0) {\n                        r.isCanceled = true;\n                    }\n                }\n            }\n        }\n    }\n\n    protected boolean cancel(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return false;\n            }\n            int N = records.size();\n            for (int i = 0; i < N; i++) {\n                records.valueAt(i).isCanceled = true;\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Updates the notification record so the most up to date information is shown on re-post.\n     */\n    protected void update(int userId, NotificationRecord record) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, record.getSbn().getPackageName()));\n            if (records == null) {\n                return;\n            }\n            records.put(record.getKey(), record);\n        }\n    }\n\n    protected void repost(String key, boolean muteOnReturn) {\n        synchronized (mLock) {\n            Integer userId = mUsers.get(key);\n            if (userId != null) {\n                repost(key, userId, muteOnReturn);\n            }\n        }\n    }\n\n    protected void repost(String key, int userId, boolean muteOnReturn) {\n        final String trimmedKey = getTrimmedString(key);\n\n        NotificationRecord record;\n        synchronized (mLock) {\n            final String pkg = mPackages.remove(key);\n            mUsers.remove(key);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            record = records.remove(key);\n\n        }\n\n        if (record != null && !record.isCanceled) {\n            final PendingIntent pi = createPendingIntent(\n                    record.getSbn().getPackageName(), record.getKey(), userId);\n            mAm.cancel(pi);\n            MetricsLogger.action(record.getLogMaker()\n                    .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                    .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n            mCallback.repost(userId, record, muteOnReturn);\n        }\n    }\n\n    protected void repostGroupSummary(String pkg, int userId, String groupKey) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsByKey\n                    = mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsByKey == null) {\n                return;\n            }\n\n            String groupSummaryKey = null;\n            int N = recordsByKey.size();\n            for (int i = 0; i < N; i++) {\n                final NotificationRecord potentialGroupSummary = recordsByKey.valueAt(i);\n                if (potentialGroupSummary.getSbn().isGroup()\n                        && potentialGroupSummary.getNotification().isGroupSummary()\n                        && groupKey.equals(potentialGroupSummary.getGroupKey())) {\n                    groupSummaryKey = potentialGroupSummary.getKey();\n                    break;\n                }\n            }\n\n            if (groupSummaryKey != null) {\n                NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                mPackages.remove(groupSummaryKey);\n                mUsers.remove(groupSummaryKey);\n\n                final String trimmedKey = getTrimmedString(groupSummaryKey);\n                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n                removeRecordLocked(pkg, trimmedKey, userId,\n                      mPersistedSnoozedNotificationsWithContext);\n\n                if (record != null && !record.isCanceled) {\n                    Runnable runnable = () -> {\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n                        mCallback.repost(userId, record, false);\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    protected void clearData(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            for (int i = records.size() - 1; i >= 0; i--) {\n                final NotificationRecord r = records.removeAt(i);\n                if (r != null) {\n                    mPackages.remove(r.getKey());\n                    mUsers.remove(r.getKey());\n                    Runnable runnable = () -> {\n                        final PendingIntent pi = createPendingIntent(pkg, r.getKey(), userId);\n                        mAm.cancel(pi);\n                        MetricsLogger.action(r.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_DISMISS));\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    private PendingIntent createPendingIntent(String pkg, String key, int userId) {\n        return PendingIntent.getBroadcast(mContext,\n                REQUEST_CODE_REPOST,\n                new Intent(REPOST_ACTION)\n                        .setPackage(PackageManagerService.PLATFORM_PACKAGE_NAME)\n                        .setData(new Uri.Builder().scheme(REPOST_SCHEME).appendPath(key).build())\n                        .addFlags(Intent.FLAG_RECEIVER_FOREGROUND)\n                        .putExtra(EXTRA_KEY, key)\n                        .putExtra(EXTRA_USER_ID, userId),\n                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n    }\n\n    public void scheduleRepostsForPersistedNotifications(long currentTime) {\n        synchronized (mLock) {\n            for (ArrayMap<String, Long> snoozed : mPersistedSnoozedNotifications.values()) {\n                for (int i = 0; i < snoozed.size(); i++) {\n                    String key = snoozed.keyAt(i);\n                    Long time = snoozed.valueAt(i);\n                    String pkg = mPackages.get(key);\n                    Integer userId = mUsers.get(key);\n                    if (time == null || pkg == null || userId == null) {\n                        Slog.w(TAG, \"data out of sync: \" + time + \"|\" + pkg + \"|\" + userId);\n                        continue;\n                    }\n                    if (time != null && time > currentTime) {\n                        scheduleRepostAtTime(pkg, key, userId, time);\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleRepost(String pkg, String key, int userId, long duration) {\n        scheduleRepostAtTime(pkg, key, userId, System.currentTimeMillis() + duration);\n    }\n\n    private void scheduleRepostAtTime(String pkg, String key, int userId, long time) {\n        Runnable runnable = () -> {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final PendingIntent pi = createPendingIntent(pkg, key, userId);\n                mAm.cancel(pi);\n                if (DEBUG) Slog.d(TAG, \"Scheduling evaluate for \" + new Date(time));\n                mAm.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pi);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        };\n        runnable.run();\n    }\n\n    public void dump(PrintWriter pw, NotificationManagerService.DumpFilter filter) {\n        synchronized (mLock) {\n            pw.println(\"\\n  Snoozed notifications:\");\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.println(key);\n                }\n            }\n            pw.println(\"\\n Pending snoozed notifications\");\n            for (String userPkgKey : mPersistedSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, Long> snoozedRecords =\n                        mPersistedSnoozedNotifications.get(userPkgKey);\n                if (snoozedRecords == null) {\n                    continue;\n                }\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(key);\n                    pw.print(INDENT);\n                    pw.println(snoozedRecords.get(key));\n                }\n            }\n        }\n    }\n\n    protected void writeXml(TypedXmlSerializer out) throws IOException {\n        synchronized (mLock) {\n            final long currentTime = System.currentTimeMillis();\n            out.startTag(null, XML_TAG_NAME);\n            writeXml(out, mPersistedSnoozedNotifications, XML_SNOOZED_NOTIFICATION,\n                    value -> {\n                        if (value < currentTime) {\n                            return;\n                        }\n                        out.attributeLong(null, XML_SNOOZED_NOTIFICATION_TIME,\n                                value);\n                    });\n            writeXml(out, mPersistedSnoozedNotificationsWithContext,\n                    XML_SNOOZED_NOTIFICATION_CONTEXT,\n                    value -> {\n                        out.attribute(null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID,\n                                value);\n                    });\n            out.endTag(null, XML_TAG_NAME);\n        }\n    }\n\n    private interface Inserter<T> {\n        void insert(T t) throws IOException;\n    }\n\n    private <T> void writeXml(TypedXmlSerializer out,\n            ArrayMap<String, ArrayMap<String, T>> targets, String tag,\n            Inserter<T> attributeInserter)\n            throws IOException {\n        final int M = targets.size();\n        for (int i = 0; i < M; i++) {\n            // T is a String (snoozed until context) or Long (snoozed until time)\n            ArrayMap<String, T> keyToValue = targets.valueAt(i);\n            for (int j = 0; j < keyToValue.size(); j++) {\n                String key = keyToValue.keyAt(j);\n                T value = keyToValue.valueAt(j);\n                String pkg = mPackages.get(key);\n                Integer userId = mUsers.get(key);\n\n                if (pkg == null || userId == null) {\n                    Slog.w(TAG, \"pkg \" + pkg + \" or user \" + userId + \" missing for \" + key);\n                    continue;\n                }\n\n                out.startTag(null, tag);\n\n                attributeInserter.insert(value);\n\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL,\n                        XML_SNOOZED_NOTIFICATION_VERSION);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_KEY, key);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_PKG, pkg);\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_USER_ID, userId);\n\n                out.endTag(null, tag);\n            }\n        }\n    }\n\n    protected void readXml(TypedXmlPullParser parser, long currentTime)\n            throws XmlPullParserException, IOException {\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {\n            String tag = parser.getName();\n            if (type == XmlPullParser.END_TAG\n                    && XML_TAG_NAME.equals(tag)) {\n                break;\n            }\n            if (type == XmlPullParser.START_TAG\n                    && (XML_SNOOZED_NOTIFICATION.equals(tag)\n                        || tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT))\n                    && parser.getAttributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL, -1)\n                        == XML_SNOOZED_NOTIFICATION_VERSION) {\n                try {\n                    final String key = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_KEY);\n                    final String pkg = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_PKG);\n                    final int userId = parser.getAttributeInt(\n                            null, XML_SNOOZED_NOTIFICATION_USER_ID, UserHandle.USER_ALL);\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION)) {\n                        final Long time = parser.getAttributeLong(\n                                null, XML_SNOOZED_NOTIFICATION_TIME, 0);\n                        if (time > currentTime) { //only read new stuff\n                            synchronized (mLock) {\n                                storeRecordLocked(\n                                        pkg, key, userId, mPersistedSnoozedNotifications, time);\n                            }\n                        }\n                    }\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT)) {\n                        final String creationId = parser.getAttributeValue(\n                                null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID);\n                        synchronized (mLock) {\n                            storeRecordLocked(\n                                    pkg, key, userId, mPersistedSnoozedNotificationsWithContext,\n                                    creationId);\n                        }\n                    }\n                } catch (Exception e) {\n                    Slog.e(TAG,  \"Exception in reading snooze data from policy xml\", e);\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void setAlarmManager(AlarmManager am) {\n        mAm = am;\n    }\n\n    protected interface Callback {\n        void repost(int userId, NotificationRecord r, boolean muteOnReturn);\n    }\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (DEBUG) {\n                Slog.d(TAG, \"Reposting notification\");\n            }\n            if (REPOST_ACTION.equals(intent.getAction())) {\n                repost(intent.getStringExtra(EXTRA_KEY), intent.getIntExtra(EXTRA_USER_ID,\n                        UserHandle.USER_SYSTEM), false);\n            }\n        }\n    };\n}",
            "downstream_file_ground_truth_tokens": {
              "openai": 5905,
              "general": {
                "word_based": 2347,
                "char_based": 7375
              },
              "gemini": 7061
            },
            "downstream_file_content_patched_upstream_only": "```java\n/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.android.server.notification;\n\nimport android.annotation.NonNull;\nimport android.annotation.UserIdInt;\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.service.notification.StatusBarNotification;\nimport android.util.ArrayMap;\nimport android.util.IntArray;\nimport android.util.Log;\nimport android.util.Slog;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto;\nimport com.android.internal.util.XmlUtils;\nimport com.android.server.pm.PackageManagerService;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * NotificationManagerService helper for handling snoozed notifications.\n */\npublic class SnoozeHelper {\n    public static final int XML_SNOOZED_NOTIFICATION_VERSION = 1;\n\n    static final int CONCURRENT_SNOOZE_LIMIT = 500;\n\n    // A safe size for strings to be put in persistent storage, to avoid breaking the XML write.\n    static final int MAX_STRING_LENGTH = 1000;\n\n    protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n\n    private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT = \"context\";\n    private static final String XML_SNOOZED_NOTIFICATION_PKG = \"pkg\";\n    private static final String XML_SNOOZED_NOTIFICATION_USER_ID = \"user-id\";\n    private static final String XML_SNOOZED_NOTIFICATION_KEY = \"key\";\n    //the time the snoozed notification should be reposted\n    private static final String XML_SNOOZED_NOTIFICATION_TIME = \"time\";\n    private static final String XML_SNOOZED_NOTIFICATION_CONTEXT_ID = \"id\";\n    private static final String XML_SNOOZED_NOTIFICATION_VERSION_LABEL = \"version\";\n\n\n    private static final String TAG = \"SnoozeHelper\";\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n    private static final String INDENT = \"    \";\n\n    private static final String REPOST_ACTION = SnoozeHelper.class.getSimpleName() + \".EVALUATE\";\n    private static final int REQUEST_CODE_REPOST = 1;\n    private static final String REPOST_SCHEME = \"repost\";\n    static final String EXTRA_KEY = \"key\";\n    private static final String EXTRA_USER_ID = \"userId\";\n\n    private final Context mContext;\n    private AlarmManager mAm;\n    private final ManagedServices.UserProfiles mUserProfiles;\n\n    // User id | package name : notification key : record.\n    private ArrayMap<String, ArrayMap<String, NotificationRecord>>\n            mSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : time-milliseconds .\n    // This member stores persisted snoozed notification trigger times. it persists through reboots\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, Long>>\n            mPersistedSnoozedNotifications = new ArrayMap<>();\n    // User id | package name : notification key : creation ID .\n    // This member stores persisted snoozed notification trigger context for the assistant\n    // it persists through reboots.\n    // It should have the notifications that haven't expired or re-posted yet\n    private final ArrayMap<String, ArrayMap<String, String>>\n            mPersistedSnoozedNotificationsWithContext = new ArrayMap<>();\n    // notification key : package.\n    private ArrayMap<String, String> mPackages = new ArrayMap<>();\n    // key : userId\n    private ArrayMap<String, Integer> mUsers = new ArrayMap<>();\n    private Callback mCallback;\n\n    private final Object mLock = new Object();\n\n    public SnoozeHelper(Context context, Callback callback,\n            ManagedServices.UserProfiles userProfiles) {\n        mContext = context;\n        IntentFilter filter = new IntentFilter(REPOST_ACTION);\n        filter.addDataScheme(REPOST_SCHEME);\n        mContext.registerReceiver(mBroadcastReceiver, filter);\n        mAm = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mCallback = callback;\n        mUserProfiles = userProfiles;\n    }\n\n    private String getPkgKey(@UserIdInt int userId, String pkg) {\n        return userId + \"|\" + pkg;\n    }\n\n    void cleanupPersistedContext(String key){\n        synchronized (mLock) {\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            removeRecordLocked(pkg, key, userId, mPersistedSnoozedNotificationsWithContext);\n        }\n    }\n\n    protected boolean canSnooze(int numberToSnooze) {\n        synchronized (mLock) {\n            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @NonNull\n    protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n        Long time = null;\n        synchronized (mLock) {\n           ArrayMap<String, Long> snoozed =\n                   mPersistedSnoozedNotifications.get(getPkgKey(userId, pkg));\n           if (snoozed != null) {\n               time = snoozed.get(getTrimmedString(key));\n           }\n        }\n        if (time == null) {\n            time = 0L;\n        }\n        return time;\n    }\n\n    protected String getSnoozeContextForUnpostedNotification(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            ArrayMap<String, String> snoozed =\n                    mPersistedSnoozedNotificationsWithContext.get(getPkgKey(userId, pkg));\n            if (snoozed != null) {\n                return snoozed.get(getTrimmedString(key));\n            }\n        }\n        return null;\n    }\n\n    protected boolean isSnoozed(int userId, String pkg, String key) {\n        synchronized (mLock) {\n            return mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))\n                    && mSnoozedNotifications.get(getPkgKey(userId, pkg)).containsKey(key);\n        }\n    }\n\n    protected Collection<NotificationRecord> getSnoozed(int userId, String pkg) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.containsKey(getPkgKey(userId, pkg))) {\n                return mSnoozedNotifications.get(getPkgKey(userId, pkg)).values();\n            }\n        }\n        return Collections.EMPTY_LIST;\n    }\n\n    @NonNull\n    ArrayList<NotificationRecord> getNotifications(String pkg,\n            String groupKey, Integer userId) {\n        ArrayList<NotificationRecord> records =  new ArrayList<>();\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> allRecords =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (allRecords != null) {\n                for (int i = 0; i < allRecords.size(); i++) {\n                    NotificationRecord r = allRecords.valueAt(i);\n                    String currentGroupKey = r.getSbn().getGroup();\n                    if (Objects.equals(currentGroupKey, groupKey)) {\n                        records.add(r);\n                    }\n                }\n            }\n        }\n        return records;\n    }\n\n    protected NotificationRecord getNotification(String key) {\n        synchronized (mLock) {\n            if (!mUsers.containsKey(key) || !mPackages.containsKey(key)) {\n                Slog.w(TAG, \"Snoozed data sets no longer agree for \" + key);\n                return null;\n            }\n            int userId = mUsers.get(key);\n            String pkg = mPackages.get(key);\n            ArrayMap<String, NotificationRecord> snoozed =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (snoozed == null) {\n                return null;\n            }\n            return snoozed.get(key);\n        }\n    }\n\n    protected @NonNull List<NotificationRecord> getSnoozed() {\n        synchronized (mLock) {\n            // caller filters records based on the current user profiles and listener access, so just\n            // return everything\n            List<NotificationRecord> snoozed = new ArrayList<>();\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                snoozed.addAll(snoozedRecords.values());\n            }\n            return snoozed;\n        }\n    }\n\n    /**\n     * Snoozes a notification and schedules an alarm to repost at that time.\n     */\n    protected void snooze(NotificationRecord record, long duration) {\n        String pkg = record.getSbn().getPackageName();\n        String key = record.getKey();\n        int userId = record.getUser().getIdentifier();\n\n        snooze(record);\n        scheduleRepost(pkg, key, userId, duration);\n        Long activateAt = System.currentTimeMillis() + duration;\n        synchronized (mLock) {\n            storeRecordLocked(pkg, getTrimmedString(key), userId, mPersistedSnoozedNotifications,\n                    activateAt);\n        }\n    }\n\n    /**\n     * Records a snoozed notification.\n     */\n    protected void snooze(NotificationRecord record, String contextId) {\n        int userId = record.getUser().getIdentifier();\n        if (contextId != null) {\n            synchronized (mLock) {\n                storeRecordLocked(record.getSbn().getPackageName(),\n                        getTrimmedString(record.getKey()),\n                        userId, mPersistedSnoozedNotificationsWithContext,\n                        getTrimmedString(contextId));\n            }\n        }\n        snooze(record);\n    }\n\n    private void snooze(NotificationRecord record) {\n        int userId = record.getUser().getIdentifier();\n        if (DEBUG) {\n            Slog.d(TAG, \"Snoozing \" + record.getKey());\n        }\n        synchronized (mLock) {\n            storeRecordLocked(record.getSbn().getPackageName(), record.getKey(),\n                    userId, mSnoozedNotifications, record);\n        }\n    }\n\n    private String getTrimmedString(String key) {\n        if (key != null && key.length() > MAX_STRING_LENGTH) {\n            return key.substring(0, MAX_STRING_LENGTH);\n        }\n        return key;\n    }\n\n    private <T> void storeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets, T object) {\n\n        mPackages.put(key, pkg);\n        mUsers.put(key, userId);\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            keyToValue = new ArrayMap<>();\n        }\n        keyToValue.put(key, object);\n        targets.put(getPkgKey(userId, pkg), keyToValue);\n    }\n\n    private <T> T removeRecordLocked(String pkg, String key, Integer userId,\n            ArrayMap<String, ArrayMap<String, T>> targets) {\n        T object = null;\n        ArrayMap<String, T> keyToValue = targets.get(getPkgKey(userId, pkg));\n        if (keyToValue == null) {\n            return null;\n        }\n        object = keyToValue.remove(key);\n        if (keyToValue.size() == 0) {\n            targets.remove(getPkgKey(userId, pkg));\n        }\n        return object;\n    }\n\n    protected boolean cancel(int userId, String pkg, String tag, int id) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsForPkg =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsForPkg != null) {\n                final Set<Map.Entry<String, NotificationRecord>> records = recordsForPkg.entrySet();\n                for (Map.Entry<String, NotificationRecord> record : records) {\n                    final StatusBarNotification sbn = record.getValue().getSbn();\n                    if (Objects.equals(sbn.getTag(), tag) && sbn.getId() == id) {\n                        record.getValue().isCanceled = true;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    protected void cancel(int userId, boolean includeCurrentProfiles) {\n        synchronized (mLock) {\n            if (mSnoozedNotifications.size() == 0) {\n                return;\n            }\n            IntArray userIds = new IntArray();\n            userIds.add(userId);\n            if (includeCurrentProfiles) {\n                userIds = mUserProfiles.getCurrentProfileIds();\n            }\n            for (ArrayMap<String, NotificationRecord> snoozedRecords : mSnoozedNotifications.values()) {\n                for (NotificationRecord r : snoozedRecords.values()) {\n                    if (userIds.binarySearch(r.getUserId()) >= 0) {\n                        r.isCanceled = true;\n                    }\n                }\n            }\n        }\n    }\n\n    protected boolean cancel(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return false;\n            }\n            int N = records.size();\n            for (int i = 0; i < N; i++) {\n                records.valueAt(i).isCanceled = true;\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Updates the notification record so the most up to date information is shown on re-post.\n     */\n    protected void update(int userId, NotificationRecord record) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, record.getSbn().getPackageName()));\n            if (records == null) {\n                return;\n            }\n            records.put(record.getKey(), record);\n        }\n    }\n\n    protected void repost(String key, boolean muteOnReturn) {\n        synchronized (mLock) {\n            Integer userId = mUsers.get(key);\n            if (userId != null) {\n                repost(key, userId, muteOnReturn);\n            }\n        }\n    }\n\n    protected void repost(String key, int userId, boolean muteOnReturn) {\n        final String trimmedKey = getTrimmedString(key);\n\n        NotificationRecord record;\n        synchronized (mLock) {\n            final String pkg = mPackages.remove(key);\n            mUsers.remove(key);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            record = records.remove(key);\n\n        }\n\n        if (record != null && !record.isCanceled) {\n            final PendingIntent pi = createPendingIntent(\n                    record.getSbn().getPackageName(), record.getKey(), userId);\n            mAm.cancel(pi);\n            MetricsLogger.action(record.getLogMaker()\n                    .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                    .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n            mCallback.repost(userId, record, muteOnReturn);\n        }\n    }\n\n    protected void repostGroupSummary(String pkg, int userId, String groupKey) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> recordsByKey\n                    = mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (recordsByKey == null) {\n                return;\n            }\n\n            String groupSummaryKey = null;\n            int N = recordsByKey.size();\n            for (int i = 0; i < N; i++) {\n                final NotificationRecord potentialGroupSummary = recordsByKey.valueAt(i);\n                if (potentialGroupSummary.getSbn().isGroup()\n                        && potentialGroupSummary.getNotification().isGroupSummary()\n                        && groupKey.equals(potentialGroupSummary.getGroupKey())) {\n                    groupSummaryKey = potentialGroupSummary.getKey();\n                    break;\n                }\n            }\n\n            if (groupSummaryKey != null) {\n                NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                mPackages.remove(groupSummaryKey);\n                mUsers.remove(groupSummaryKey);\n\n                if (record != null && !record.isCanceled) {\n                    Runnable runnable = () -> {\n                        MetricsLogger.action(record.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_OPEN));\n                        mCallback.repost(userId, record, false);\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    protected void clearData(int userId, String pkg) {\n        synchronized (mLock) {\n            ArrayMap<String, NotificationRecord> records =\n                    mSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (records == null) {\n                return;\n            }\n            for (int i = records.size() - 1; i >= 0; i--) {\n                final NotificationRecord r = records.removeAt(i);\n                if (r != null) {\n                    mPackages.remove(r.getKey());\n                    mUsers.remove(r.getKey());\n                    Runnable runnable = () -> {\n                        final PendingIntent pi = createPendingIntent(pkg, r.getKey(), userId);\n                        mAm.cancel(pi);\n                        MetricsLogger.action(r.getLogMaker()\n                                .setCategory(MetricsProto.MetricsEvent.NOTIFICATION_SNOOZED)\n                                .setType(MetricsProto.MetricsEvent.TYPE_DISMISS));\n                    };\n                    runnable.run();\n                }\n            }\n        }\n    }\n\n    private PendingIntent createPendingIntent(String pkg, String key, int userId) {\n        return PendingIntent.getBroadcast(mContext,\n                REQUEST_CODE_REPOST,\n                new Intent(REPOST_ACTION)\n                        .setPackage(PackageManagerService.PLATFORM_PACKAGE_NAME)\n                        .setData(new Uri.Builder().scheme(REPOST_SCHEME).appendPath(key).build())\n                        .addFlags(Intent.FLAG_RECEIVER_FOREGROUND)\n                        .putExtra(EXTRA_KEY, key)\n                        .putExtra(EXTRA_USER_ID, userId),\n                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n    }\n\n    public void scheduleRepostsForPersistedNotifications(long currentTime) {\n        synchronized (mLock) {\n            for (ArrayMap<String, Long> snoozed : mPersistedSnoozedNotifications.values()) {\n                for (int i = 0; i < snoozed.size(); i++) {\n                    String key = snoozed.keyAt(i);\n                    Long time = snoozed.valueAt(i);\n                    String pkg = mPackages.get(key);\n                    Integer userId = mUsers.get(key);\n                    if (time == null || pkg == null || userId == null) {\n                        Slog.w(TAG, \"data out of sync: \" + time + \"|\" + pkg + \"|\" + userId);\n                        continue;\n                    }\n                    if (time != null && time > currentTime) {\n                        scheduleRepostAtTime(pkg, key, userId, time);\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleRepost(String pkg, String key, int userId, long duration) {\n        scheduleRepostAtTime(pkg, key, userId, System.currentTimeMillis() + duration);\n    }\n\n    private void scheduleRepostAtTime(String pkg, String key, int userId, long time) {\n        Runnable runnable = () -> {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final PendingIntent pi = createPendingIntent(pkg, key, userId);\n                mAm.cancel(pi);\n                if (DEBUG) Slog.d(TAG, \"Scheduling evaluate for \" + new Date(time));\n                mAm.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pi);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        };\n        runnable.run();\n    }\n\n    public void dump(PrintWriter pw, NotificationManagerService.DumpFilter filter) {\n        synchronized (mLock) {\n            pw.println(\"\\n  Snoozed notifications:\");\n            for (String userPkgKey : mSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, NotificationRecord> snoozedRecords =\n                        mSnoozedNotifications.get(userPkgKey);\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.println(key);\n                }\n            }\n            pw.println(\"\\n Pending snoozed notifications\");\n            for (String userPkgKey : mPersistedSnoozedNotifications.keySet()) {\n                pw.print(INDENT);\n                pw.println(\"key: \" + userPkgKey);\n                ArrayMap<String, Long> snoozedRecords =\n                        mPersistedSnoozedNotifications.get(userPkgKey);\n                if (snoozedRecords == null) {\n                    continue;\n                }\n                Set<String> snoozedKeys = snoozedRecords.keySet();\n                for (String key : snoozedKeys) {\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(INDENT);\n                    pw.print(key);\n                    pw.print(INDENT);\n                    pw.println(snoozedRecords.get(key));\n                }\n            }\n        }\n    }\n\n    protected void writeXml(TypedXmlSerializer out) throws IOException {\n        synchronized (mLock) {\n            final long currentTime = System.currentTimeMillis();\n            out.startTag(null, XML_TAG_NAME);\n            writeXml(out, mPersistedSnoozedNotifications, XML_SNOOZED_NOTIFICATION,\n                    value -> {\n                        if (value < currentTime) {\n                            return;\n                        }\n                        out.attributeLong(null, XML_SNOOZED_NOTIFICATION_TIME,\n                                value);\n                    });\n            writeXml(out, mPersistedSnoozedNotificationsWithContext,\n                    XML_SNOOZED_NOTIFICATION_CONTEXT,\n                    value -> {\n                        out.attribute(null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID,\n                                value);\n                    });\n            out.endTag(null, XML_TAG_NAME);\n        }\n    }\n\n    private interface Inserter<T> {\n        void insert(T t) throws IOException;\n    }\n\n    private <T> void writeXml(TypedXmlSerializer out,\n            ArrayMap<String, ArrayMap<String, T>> targets, String tag,\n            Inserter<T> attributeInserter)\n            throws IOException {\n        final int M = targets.size();\n        for (int i = 0; i < M; i++) {\n            // T is a String (snoozed until context) or Long (snoozed until time)\n            ArrayMap<String, T> keyToValue = targets.valueAt(i);\n            for (int j = 0; j < keyToValue.size(); j++) {\n                String key = keyToValue.keyAt(j);\n                T value = keyToValue.valueAt(j);\n                String pkg = mPackages.get(key);\n                Integer userId = mUsers.get(key);\n\n                if (pkg == null || userId == null) {\n                    Slog.w(TAG, \"pkg \" + pkg + \" or user \" + userId + \" missing for \" + key);\n                    continue;\n                }\n\n                out.startTag(null, tag);\n\n                attributeInserter.insert(value);\n\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL,\n                        XML_SNOOZED_NOTIFICATION_VERSION);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_KEY, key);\n                out.attribute(null, XML_SNOOZED_NOTIFICATION_PKG, pkg);\n                out.attributeInt(null, XML_SNOOZED_NOTIFICATION_USER_ID, userId);\n\n                out.endTag(null, tag);\n            }\n        }\n    }\n\n    protected void readXml(TypedXmlPullParser parser, long currentTime)\n            throws XmlPullParserException, IOException {\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {\n            String tag = parser.getName();\n            if (type == XmlPullParser.END_TAG\n                    && XML_TAG_NAME.equals(tag)) {\n                break;\n            }\n            if (type == XmlPullParser.START_TAG\n                    && (XML_SNOOZED_NOTIFICATION.equals(tag)\n                        || tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT))\n                    && parser.getAttributeInt(null, XML_SNOOZED_NOTIFICATION_VERSION_LABEL, -1)\n                        == XML_SNOOZED_NOTIFICATION_VERSION) {\n                try {\n                    final String key = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_KEY);\n                    final String pkg = parser.getAttributeValue(null, XML_SNOOZED_NOTIFICATION_PKG);\n                    final int userId = parser.getAttributeInt(\n                            null, XML_SNOOZED_NOTIFICATION_USER_ID, UserHandle.USER_ALL);\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION)) {\n                        final Long time = parser.getAttributeLong(\n                                null, XML_SNOOZED_NOTIFICATION_TIME, 0);\n                        if (time > currentTime) { //only read new stuff\n                            synchronized (mLock) {\n                                storeRecordLocked(\n                                        pkg, key, userId, mPersistedSnoozedNotifications, time);\n                            }\n                        }\n                    }\n                    if (tag.equals(XML_SNOOZED_NOTIFICATION_CONTEXT)) {\n                        final String creationId = parser.getAttributeValue(\n                                null, XML_SNOOZED_NOTIFICATION_CONTEXT_ID);\n                        synchronized (mLock) {\n                            storeRecordLocked(\n                                    pkg, key, userId, mPersistedSnoozedNotificationsWithContext,\n                                    creationId);\n                        }\n                    }\n                } catch (Exception e) {\n                    Slog.e(TAG,  \"Exception in reading snooze data from policy xml\", e);\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void setAlarmManager(AlarmManager am) {\n        mAm = am;\n    }\n\n    protected interface Callback {\n        void repost(int userId, NotificationRecord r, boolean muteOnReturn);\n    }\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (DEBUG) {\n                Slog.d(TAG, \"Reposting notification\");\n            }\n            if (REPOST_ACTION.equals(intent.getAction())) {\n                repost(intent.getStringExtra(EXTRA_KEY), intent.getIntExtra(EXTRA_USER_ID,\n                        UserHandle.USER_SYSTEM), false);\n            }\n        }\n    };\n}\n```",
            "diff_patched_upstream_only": "--- original_downstream_file\n+++ patched_upstream_only\n@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2016 The Android Open Source Project\n  *\n@@ -704,5 +703,4 @@\n             }\n         }\n     };\n-}\n-```+}",
            "downstream_llm_diff_output": "```diff\n--- a/services/core/java/com/android/server/notification/SnoozeHelper.java\n+++ b/services/core/java/com/android/server/notification/SnoozeHelper.java\n@@ -122,7 +122,10 @@\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mSnoozedNotifications.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                    || (mPersistedSnoozedNotifications.size()\n+                    + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n+                    > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n@@ -380,6 +383,9 @@\n \n             if (groupSummaryKey != null) {\n                 NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n+                String trimmedKey = getTrimmedString(groupSummaryKey);\n+                mPersistedSnoozedNotificationsWithContext.remove(trimmedKey);\n+                mPersistedSnoozedNotifications.remove(trimmedKey);\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n```",
            "llm_output_valid": true,
            "runtime_seconds": 315.28,
            "attempts_made": 2,
            "validation_results": [
              {
                "attempt": 1,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk diff line expected: @@ -382,4 +385,8 @@\n",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 133.75
              },
              {
                "attempt": 2,
                "format_valid": true,
                "format_error": "Valid patch format",
                "apply_valid": true,
                "apply_error": "Patch applies cleanly in repo",
                "valid": true,
                "runtime_seconds": 170.87
              }
            ],
            "token_counts": {
              "openai": 270,
              "general": {
                "word_based": 78,
                "char_based": 293
              },
              "gemini": 26007
            }
          }
        ]
      }
    ]
  }
]