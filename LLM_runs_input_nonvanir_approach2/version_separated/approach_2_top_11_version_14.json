[
  {
    "id": "ASB-A-333364513",
    "total_gemini_token_usage": 22961,
    "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-333364513",
    "severity": "High",
    "upstream_patch_content": "From 901880a1d2e632179eb4ac708fc4bc18d9d50791 Mon Sep 17 00:00:00 2001\nFrom: Jason Chiu <chiujason@google.com>\nDate: Wed, 31 Jan 2024 16:29:01 +0800\nSubject: [PATCH] Replace getCallingActivity() with getLaunchedFromPackage()\n\ngetLaunchedFromPackage() reports who launched this Activity or built\nPendingIntent used to launch it, whereas getCallingActivity() reports\nwho will get result of Activity.\n\nBug: 316891059\nTest: robotest, manual\nChange-Id: If97018c2741caef622f0596bbfeaa42ef1788b78\n---\n .../settings/search/SearchFeatureProvider.java |  2 +-\n .../search/SearchFeatureProviderImpl.java      | 18 ++++++++----------\n .../search/SearchResultTrampoline.java         | 13 ++++++-------\n .../search/SearchFeatureProviderImplTest.java  | 15 ++++++++-------\n 4 files changed, 23 insertions(+), 25 deletions(-)\n\ndiff --git a/src/com/android/settings/search/SearchFeatureProvider.java b/src/com/android/settings/search/SearchFeatureProvider.java\nindex 0741ce4b02c..b1d04d4398c 100644\n--- a/src/com/android/settings/search/SearchFeatureProvider.java\n+++ b/src/com/android/settings/search/SearchFeatureProvider.java\n@@ -56,7 +56,7 @@ public interface SearchFeatureProvider {\n      * @throws IllegalArgumentException when caller is null\n      * @throws SecurityException        when caller is not allowed to launch search result page\n      */\n-    void verifyLaunchSearchResultPageCaller(Context context, @NonNull ComponentName caller)\n+    void verifyLaunchSearchResultPageCaller(@NonNull Context context, @NonNull String callerPackage)\n             throws SecurityException, IllegalArgumentException;\n \n     /**\ndiff --git a/src/com/android/settings/search/SearchFeatureProviderImpl.java b/src/com/android/settings/search/SearchFeatureProviderImpl.java\nindex 6f909709058..3a62ddfb67e 100644\n--- a/src/com/android/settings/search/SearchFeatureProviderImpl.java\n+++ b/src/com/android/settings/search/SearchFeatureProviderImpl.java\n@@ -17,13 +17,14 @@\n \n package com.android.settings.search;\n \n-import android.content.ComponentName;\n import android.content.Context;\n import android.content.Intent;\n import android.net.Uri;\n import android.provider.Settings;\n import android.text.TextUtils;\n \n+import androidx.annotation.NonNull;\n+\n import com.android.settingslib.search.SearchIndexableResources;\n import com.android.settingslib.search.SearchIndexableResourcesMobile;\n \n@@ -32,21 +33,18 @@ import com.android.settingslib.search.SearchIndexableResourcesMobile;\n  */\n public class SearchFeatureProviderImpl implements SearchFeatureProvider {\n \n-    private static final String TAG = \"SearchFeatureProvider\";\n-\n     private SearchIndexableResources mSearchIndexableResources;\n \n     @Override\n-    public void verifyLaunchSearchResultPageCaller(Context context, ComponentName caller) {\n-        if (caller == null) {\n+    public void verifyLaunchSearchResultPageCaller(@NonNull Context context,\n+            @NonNull String callerPackage) {\n+        if (TextUtils.isEmpty(callerPackage)) {\n             throw new IllegalArgumentException(\"ExternalSettingsTrampoline intents \"\n                     + \"must be called with startActivityForResult\");\n         }\n-        final String packageName = caller.getPackageName();\n-        final boolean isSettingsPackage = TextUtils.equals(packageName, context.getPackageName())\n-                || TextUtils.equals(getSettingsIntelligencePkgName(context), packageName);\n-        final boolean isAllowlistedPackage =\n-                isSignatureAllowlisted(context, caller.getPackageName());\n+        final boolean isSettingsPackage = TextUtils.equals(callerPackage, context.getPackageName())\n+                || TextUtils.equals(getSettingsIntelligencePkgName(context), callerPackage);\n+        final boolean isAllowlistedPackage = isSignatureAllowlisted(context, callerPackage);\n         if (isSettingsPackage || isAllowlistedPackage) {\n             return;\n         }\ndiff --git a/src/com/android/settings/search/SearchResultTrampoline.java b/src/com/android/settings/search/SearchResultTrampoline.java\nindex 5d897af3b35..04d9db56eb7 100644\n--- a/src/com/android/settings/search/SearchResultTrampoline.java\n+++ b/src/com/android/settings/search/SearchResultTrampoline.java\n@@ -21,7 +21,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n import static com.android.settings.activityembedding.EmbeddedDeepLinkUtils.getTrampolineIntent;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.net.Uri;\n import android.os.Bundle;\n@@ -53,11 +52,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -106,7 +105,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -139,9 +138,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\ndiff --git a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\nindex f3496001d09..8a7419bb1ba 100644\n--- a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n+++ b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n@@ -20,7 +20,6 @@ package com.android.settings.search;\n import static com.google.common.truth.Truth.assertThat;\n \n import android.app.settings.SettingsEnums;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n import android.content.pm.ResolveInfo;\n@@ -131,20 +130,22 @@ public class SearchFeatureProviderImplTest {\n \n     @Test(expected = SecurityException.class)\n     public void verifyLaunchSearchResultPageCaller_badCaller_shouldCrash() {\n-        final ComponentName cn = new ComponentName(\"pkg\", \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = \"pkg\";\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsCaller_shouldNotCrash() {\n-        final ComponentName cn = new ComponentName(mActivity.getPackageName(), \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = mActivity.getPackageName();\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsIntelligenceCaller_shouldNotCrash() {\n         final String packageName = mProvider.getSettingsIntelligencePkgName(mActivity);\n-        final ComponentName cn = new ComponentName(packageName, \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n }\n-- \n2.39.5 (Apple Git-154)\n\n",
    "upstream_commits": [
      "901880a1d2e632179eb4ac708fc4bc18d9d50791"
    ],
    "upstream_patch_tokens": {
      "openai": 1803,
      "general": {
        "word_based": 751,
        "char_based": 2153
      },
      "gemini": 2289
    },
    "failures": [
      {
        "downstream_version": "14",
        "gemini_token_usage": 5474,
        "branch_used": "android14-release",
        "downstream_patch": "ddc11bc03ab48e885f652b89df5f92ff283bcd4a",
        "repo_path": "android_repos/Settings",
        "result": "failure",
        "downstream_patch_content": "commit ddc11bc03ab48e885f652b89df5f92ff283bcd4a\nAuthor: Jason Chiu <chiujason@google.com>\nDate:   Wed Jan 31 16:29:01 2024 +0800\n\n    Replace getCallingActivity() with getLaunchedFromPackage()\n    \n    getLaunchedFromPackage() reports who launched this Activity or built\n    PendingIntent used to launch it, whereas getCallingActivity() reports\n    who will get result of Activity.\n    \n    Bug: 316891059\n    Test: robotest, manual\n    Change-Id: If97018c2741caef622f0596bbfeaa42ef1788b78\n    Merged-In: If97018c2741caef622f0596bbfeaa42ef1788b78\n    (cherry picked from commit 901880a1d2e632179eb4ac708fc4bc18d9d50791)\n\ndiff --git a/src/com/android/settings/search/SearchFeatureProvider.java b/src/com/android/settings/search/SearchFeatureProvider.java\nindex cd096ec6e16..c2257b47c9e 100644\n--- a/src/com/android/settings/search/SearchFeatureProvider.java\n+++ b/src/com/android/settings/search/SearchFeatureProvider.java\n@@ -56,7 +56,7 @@ public interface SearchFeatureProvider {\n      * @throws IllegalArgumentException when caller is null\n      * @throws SecurityException        when caller is not allowed to launch search result page\n      */\n-    void verifyLaunchSearchResultPageCaller(Context context, @NonNull ComponentName caller)\n+    void verifyLaunchSearchResultPageCaller(@NonNull Context context, @NonNull String callerPackage)\n             throws SecurityException, IllegalArgumentException;\n \n     /**\ndiff --git a/src/com/android/settings/search/SearchFeatureProviderImpl.java b/src/com/android/settings/search/SearchFeatureProviderImpl.java\nindex 6f909709058..3a62ddfb67e 100644\n--- a/src/com/android/settings/search/SearchFeatureProviderImpl.java\n+++ b/src/com/android/settings/search/SearchFeatureProviderImpl.java\n@@ -17,13 +17,14 @@\n \n package com.android.settings.search;\n \n-import android.content.ComponentName;\n import android.content.Context;\n import android.content.Intent;\n import android.net.Uri;\n import android.provider.Settings;\n import android.text.TextUtils;\n \n+import androidx.annotation.NonNull;\n+\n import com.android.settingslib.search.SearchIndexableResources;\n import com.android.settingslib.search.SearchIndexableResourcesMobile;\n \n@@ -32,21 +33,18 @@ import com.android.settingslib.search.SearchIndexableResourcesMobile;\n  */\n public class SearchFeatureProviderImpl implements SearchFeatureProvider {\n \n-    private static final String TAG = \"SearchFeatureProvider\";\n-\n     private SearchIndexableResources mSearchIndexableResources;\n \n     @Override\n-    public void verifyLaunchSearchResultPageCaller(Context context, ComponentName caller) {\n-        if (caller == null) {\n+    public void verifyLaunchSearchResultPageCaller(@NonNull Context context,\n+            @NonNull String callerPackage) {\n+        if (TextUtils.isEmpty(callerPackage)) {\n             throw new IllegalArgumentException(\"ExternalSettingsTrampoline intents \"\n                     + \"must be called with startActivityForResult\");\n         }\n-        final String packageName = caller.getPackageName();\n-        final boolean isSettingsPackage = TextUtils.equals(packageName, context.getPackageName())\n-                || TextUtils.equals(getSettingsIntelligencePkgName(context), packageName);\n-        final boolean isAllowlistedPackage =\n-                isSignatureAllowlisted(context, caller.getPackageName());\n+        final boolean isSettingsPackage = TextUtils.equals(callerPackage, context.getPackageName())\n+                || TextUtils.equals(getSettingsIntelligencePkgName(context), callerPackage);\n+        final boolean isAllowlistedPackage = isSignatureAllowlisted(context, callerPackage);\n         if (isSettingsPackage || isAllowlistedPackage) {\n             return;\n         }\ndiff --git a/src/com/android/settings/search/SearchResultTrampoline.java b/src/com/android/settings/search/SearchResultTrampoline.java\nindex 6ba0338bfc9..504e2985742 100644\n--- a/src/com/android/settings/search/SearchResultTrampoline.java\n+++ b/src/com/android/settings/search/SearchResultTrampoline.java\n@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.net.Uri;\n import android.os.Bundle;\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -105,7 +104,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\ndiff --git a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\nindex 0aa49eb6d68..7a1b2606a92 100644\n--- a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n+++ b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n@@ -20,7 +20,6 @@ package com.android.settings.search;\n import static com.google.common.truth.Truth.assertThat;\n \n import android.app.settings.SettingsEnums;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n import android.content.pm.ResolveInfo;\n@@ -136,20 +135,22 @@ public class SearchFeatureProviderImplTest {\n \n     @Test(expected = SecurityException.class)\n     public void verifyLaunchSearchResultPageCaller_badCaller_shouldCrash() {\n-        final ComponentName cn = new ComponentName(\"pkg\", \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = \"pkg\";\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsCaller_shouldNotCrash() {\n-        final ComponentName cn = new ComponentName(mActivity.getPackageName(), \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = mActivity.getPackageName();\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsIntelligenceCaller_shouldNotCrash() {\n         final String packageName = mProvider.getSettingsIntelligencePkgName(mActivity);\n-        final ComponentName cn = new ComponentName(packageName, \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n }\n",
        "downstream_patch_tokens": {
          "openai": 1752,
          "general": {
            "word_based": 722,
            "char_based": 2098
          },
          "gemini": 2245
        },
        "file_conflicts": [
          {
            "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
            "total_hunks": 4,
            "failed_hunks": [
              2,
              4
            ],
            "inline_merge_conflicts": [],
            "inline_merge_token_summary": {
              "gemini": 0,
              "openai": 0,
              "general_word": 0,
              "general_char": 0
            },
            "rej_file_content": "```diff\n--- src/com/android/settings/search/SearchResultTrampoline.java\n+++ src/com/android/settings/search/SearchResultTrampoline.java\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\n```",
            "rej_file_tokens": {
              "openai": 277,
              "general": {
                "word_based": 115,
                "char_based": 378
              },
              "gemini": 335
            },
            "patch_apply_output": "patching file src/com/android/settings/search/SearchFeatureProvider.java\npatching file src/com/android/settings/search/SearchFeatureProviderImpl.java\npatching file src/com/android/settings/search/SearchResultTrampoline.java\nHunk #1 succeeded at 20 with fuzz 1 (offset -1 lines).\nHunk #2 FAILED at 52.\nHunk #3 succeeded at 104 with fuzz 2 (offset -1 lines).\nHunk #4 FAILED at 138.\n2 out of 4 hunks FAILED -- saving rejects to file src/com/android/settings/search/SearchResultTrampoline.java.rej",
            "inline_merge_output": "patching file src/com/android/settings/search/SearchResultTrampoline.java\nHunk #1 already applied at 24.\nHunk #2 already applied at 55,59.\nHunk #3 already applied at 108.\nHunk #4 already applied at 141-143.",
            "upstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\nimport static com.android.settings.activityembedding.EmbeddedDeepLinkUtils.getTrampolineIntent;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.FeatureFlagUtils;\nimport android.util.Log;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsApplication;\nimport com.android.settings.SubSettings;\nimport com.android.settings.activityembedding.ActivityEmbeddingRulesController;\nimport com.android.settings.activityembedding.ActivityEmbeddingUtils;\nimport com.android.settings.core.FeatureFlags;\nimport com.android.settings.homepage.DeepLinkHomepageActivityInternal;\nimport com.android.settings.homepage.SettingsHomepageActivity;\nimport com.android.settings.overlay.FeatureFactory;\n\nimport java.net.URISyntaxException;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    private static final String TAG = \"SearchResultTrampoline\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final String callerPackage = getLaunchedFromPackage();\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFeatureFactory()\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n        // Didn't crash, proceed and launch the result as a subsetting.\n        Intent intent = getIntent();\n        final String highlightMenuKey = intent.getStringExtra(\n                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);\n\n        final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);\n        if (!TextUtils.isEmpty(fragment)) {\n            // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n            // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from\n            // external caller and args may not persisted.\n            final String settingKey = intent.getStringExtra(\n                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n            final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n            final Bundle args = new Bundle();\n            args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n            args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n            intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n            // Reroute request to SubSetting.\n            intent.setClass(this /* context */, SubSettings.class);\n        } else {\n            // Direct link case\n            final String intentUriString = intent.getStringExtra(\n                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);\n            if (TextUtils.isEmpty(intentUriString)) {\n                Log.e(TAG, \"No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link\");\n                finish();\n                return;\n            }\n\n            final Uri data = intent.getParcelableExtra(\n                    SettingsHomepageActivity.EXTRA_SETTINGS_LARGE_SCREEN_DEEP_LINK_INTENT_DATA,\n                    Uri.class);\n            try {\n                intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);\n                intent.setData(data);\n            } catch (URISyntaxException e) {\n                Log.e(TAG, \"Failed to parse deep link intent: \" + e);\n                finish();\n                return;\n            }\n        }\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n\n        if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n            startActivity(intent);\n        } else if (isSettingsIntelligence(callerPackage)) {\n            if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                startActivity(getTrampolineIntent(intent, highlightMenuKey)\n                        .setClass(this, DeepLinkHomepageActivityInternal.class)\n                        .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                                | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS));\n            } else {\n                // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected\n                // back navigation behavior.\n                ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n                        false /* clearTop */);\n\n                intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);\n                startActivity(intent);\n\n                // Pass menu key to homepage\n                final SettingsHomepageActivity homeActivity =\n                        ((SettingsApplication) getApplicationContext()).getHomeActivity();\n                if (homeActivity != null) {\n                    homeActivity.getMainFragment().setHighlightMenuKey(highlightMenuKey,\n                            /* scrollNeeded= */ true);\n                }\n            }\n        } else {\n            // Two-pane case\n            startActivity(getTrampolineIntent(intent, highlightMenuKey)\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));\n        }\n\n        // Done.\n        finish();\n    }\n\n    private boolean isSettingsIntelligence(String callerPackage) {\n        return TextUtils.equals(\n                callerPackage,\n                FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                        .getSettingsIntelligencePkgName(this));\n    }\n}\n```",
            "upstream_file_tokens": {
              "openai": 1137,
              "general": {
                "word_based": 526,
                "char_based": 1616
              },
              "gemini": 1451
            },
            "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.FeatureFlagUtils;\nimport android.util.Log;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsApplication;\nimport com.android.settings.SubSettings;\nimport com.android.settings.activityembedding.ActivityEmbeddingRulesController;\nimport com.android.settings.activityembedding.ActivityEmbeddingUtils;\nimport com.android.settings.core.FeatureFlags;\nimport com.android.settings.homepage.DeepLinkHomepageActivityInternal;\nimport com.android.settings.homepage.SettingsHomepageActivity;\nimport com.android.settings.overlay.FeatureFactory;\n\nimport java.net.URISyntaxException;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    private static final String TAG = \"SearchResultTrampoline\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final ComponentName callingActivity = getCallingActivity();\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFactory(this)\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n        // Didn't crash, proceed and launch the result as a subsetting.\n        Intent intent = getIntent();\n        final String highlightMenuKey = intent.getStringExtra(\n                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);\n\n        final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);\n        if (!TextUtils.isEmpty(fragment)) {\n            // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n            // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from\n            // external caller and args may not persisted.\n            final String settingKey = intent.getStringExtra(\n                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n            final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n            final Bundle args = new Bundle();\n            args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n            args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n            intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n            // Reroute request to SubSetting.\n            intent.setClass(this /* context */, SubSettings.class);\n        } else {\n            // Direct link case\n            final String intentUriString = intent.getStringExtra(\n                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);\n            if (TextUtils.isEmpty(intentUriString)) {\n                Log.e(TAG, \"No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link\");\n                finish();\n                return;\n            }\n\n            final Uri data = intent.getParcelableExtra(\n                    SettingsHomepageActivity.EXTRA_SETTINGS_LARGE_SCREEN_DEEP_LINK_INTENT_DATA,\n                    Uri.class);\n            try {\n                intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);\n                intent.setData(data);\n            } catch (URISyntaxException e) {\n                Log.e(TAG, \"Failed to parse deep link intent: \" + e);\n                finish();\n                return;\n            }\n        }\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n\n        if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n            startActivity(intent);\n        } else if (isSettingsIntelligence(callerPackage)) {\n            if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                        .setClass(this, DeepLinkHomepageActivityInternal.class)\n                        .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                                | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS));\n            } else {\n                // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected\n                // back navigation behavior.\n                ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n                        false /* clearTop */);\n\n                intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);\n                startActivity(intent);\n\n                // Pass menu key to homepage\n                final SettingsHomepageActivity homeActivity =\n                        ((SettingsApplication) getApplicationContext()).getHomeActivity();\n                if (homeActivity != null) {\n                    homeActivity.getMainFragment().setHighlightMenuKey(highlightMenuKey,\n                            /* scrollNeeded= */ true);\n                }\n            }\n        } else {\n            // Two-pane case\n            startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));\n        }\n\n        // Done.\n        finish();\n    }\n\n    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n        return callingActivity != null && TextUtils.equals(\n                callingActivity.getPackageName(),\n                FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                        .getSettingsIntelligencePkgName(this));\n    }\n}\n```",
            "downstream_file_tokens": {
              "openai": 1131,
              "general": {
                "word_based": 525,
                "char_based": 1614
              },
              "gemini": 1443
            },
            "downstream_file_content_ground_truth": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.FeatureFlagUtils;\nimport android.util.Log;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsApplication;\nimport com.android.settings.SubSettings;\nimport com.android.settings.activityembedding.ActivityEmbeddingRulesController;\nimport com.android.settings.activityembedding.ActivityEmbeddingUtils;\nimport com.android.settings.core.FeatureFlags;\nimport com.android.settings.homepage.DeepLinkHomepageActivityInternal;\nimport com.android.settings.homepage.SettingsHomepageActivity;\nimport com.android.settings.overlay.FeatureFactory;\n\nimport java.net.URISyntaxException;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    private static final String TAG = \"SearchResultTrampoline\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final String callerPackage = getLaunchedFromPackage();\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFactory(this)\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n        // Didn't crash, proceed and launch the result as a subsetting.\n        Intent intent = getIntent();\n        final String highlightMenuKey = intent.getStringExtra(\n                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);\n\n        final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);\n        if (!TextUtils.isEmpty(fragment)) {\n            // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n            // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from\n            // external caller and args may not persisted.\n            final String settingKey = intent.getStringExtra(\n                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n            final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n            final Bundle args = new Bundle();\n            args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n            args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n            intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n            // Reroute request to SubSetting.\n            intent.setClass(this /* context */, SubSettings.class);\n        } else {\n            // Direct link case\n            final String intentUriString = intent.getStringExtra(\n                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);\n            if (TextUtils.isEmpty(intentUriString)) {\n                Log.e(TAG, \"No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link\");\n                finish();\n                return;\n            }\n\n            final Uri data = intent.getParcelableExtra(\n                    SettingsHomepageActivity.EXTRA_SETTINGS_LARGE_SCREEN_DEEP_LINK_INTENT_DATA,\n                    Uri.class);\n            try {\n                intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);\n                intent.setData(data);\n            } catch (URISyntaxException e) {\n                Log.e(TAG, \"Failed to parse deep link intent: \" + e);\n                finish();\n                return;\n            }\n        }\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n\n        if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n            startActivity(intent);\n        } else if (isSettingsIntelligence(callerPackage)) {\n            if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                        .setClass(this, DeepLinkHomepageActivityInternal.class)\n                        .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                                | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS));\n            } else {\n                // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected\n                // back navigation behavior.\n                ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n                        false /* clearTop */);\n\n                intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);\n                startActivity(intent);\n\n                // Pass menu key to homepage\n                final SettingsHomepageActivity homeActivity =\n                        ((SettingsApplication) getApplicationContext()).getHomeActivity();\n                if (homeActivity != null) {\n                    homeActivity.getMainFragment().setHighlightMenuKey(highlightMenuKey,\n                            /* scrollNeeded= */ true);\n                }\n            }\n        } else {\n            // Two-pane case\n            startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));\n        }\n\n        // Done.\n        finish();\n    }\n\n    private boolean isSettingsIntelligence(String callerPackage) {\n        return TextUtils.equals(\n                callerPackage,\n                FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                        .getSettingsIntelligencePkgName(this));\n    }\n}",
            "downstream_file_ground_truth_tokens": {
              "openai": 1124,
              "general": {
                "word_based": 522,
                "char_based": 1599
              },
              "gemini": 1436
            },
            "downstream_file_content_patched_upstream_only": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.FeatureFlagUtils;\nimport android.util.Log;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsApplication;\nimport com.android.settings.SubSettings;\nimport com.android.settings.activityembedding.ActivityEmbeddingRulesController;\nimport com.android.settings.activityembedding.ActivityEmbeddingUtils;\nimport com.android.settings.core.FeatureFlags;\nimport com.android.settings.homepage.DeepLinkHomepageActivityInternal;\nimport com.android.settings.homepage.SettingsHomepageActivity;\nimport com.android.settings.overlay.FeatureFactory;\n\nimport java.net.URISyntaxException;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    private static final String TAG = \"SearchResultTrampoline\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final ComponentName callingActivity = getCallingActivity();\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFactory(this)\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n        // Didn't crash, proceed and launch the result as a subsetting.\n        Intent intent = getIntent();\n        final String highlightMenuKey = intent.getStringExtra(\n                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);\n\n        final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);\n        if (!TextUtils.isEmpty(fragment)) {\n            // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n            // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from\n            // external caller and args may not persisted.\n            final String settingKey = intent.getStringExtra(\n                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n            final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n            final Bundle args = new Bundle();\n            args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n            args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n            intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n            // Reroute request to SubSetting.\n            intent.setClass(this /* context */, SubSettings.class);\n        } else {\n            // Direct link case\n            final String intentUriString = intent.getStringExtra(\n                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);\n            if (TextUtils.isEmpty(intentUriString)) {\n                Log.e(TAG, \"No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link\");\n                finish();\n                return;\n            }\n\n            final Uri data = intent.getParcelableExtra(\n                    SettingsHomepageActivity.EXTRA_SETTINGS_LARGE_SCREEN_DEEP_LINK_INTENT_DATA,\n                    Uri.class);\n            try {\n                intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);\n                intent.setData(data);\n            } catch (URISyntaxException e) {\n                Log.e(TAG, \"Failed to parse deep link intent: \" + e);\n                finish();\n                return;\n            }\n        }\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n\n        if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n            startActivity(intent);\n        } else if (isSettingsIntelligence(callerPackage)) {\n            if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                        .setClass(this, DeepLinkHomepageActivityInternal.class)\n                        .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                                | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS));\n            } else {\n                // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected\n                // back navigation behavior.\n                ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n                        false /* clearTop */);\n\n                intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);\n                startActivity(intent);\n\n                // Pass menu key to homepage\n                final SettingsHomepageActivity homeActivity =\n                        ((SettingsApplication) getApplicationContext()).getHomeActivity();\n                if (homeActivity != null) {\n                    homeActivity.getMainFragment().setHighlightMenuKey(highlightMenuKey,\n                            /* scrollNeeded= */ true);\n                }\n            }\n        } else {\n            // Two-pane case\n            startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));\n        }\n\n        // Done.\n        finish();\n    }\n\n    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n        return callingActivity != null && TextUtils.equals(\n                callingActivity.getPackageName(),\n                FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                        .getSettingsIntelligencePkgName(this));\n    }\n}\n```",
            "diff_patched_upstream_only": "--- original_downstream_file\n+++ patched_upstream_only\n@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2017 The Android Open Source Project\n  *\n@@ -144,5 +143,4 @@\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\n-}\n-```+}",
            "downstream_llm_diff_output": "```diff\n--- a/src/com/android/settings/search/SearchResultTrampoline.java\n+++ b/src/com/android/settings/search/SearchResultTrampoline.java\n@@ -40,11 +40,11 @@\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -110,9 +110,9 @@\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\n```",
            "llm_output_valid": true,
            "runtime_seconds": 175.02,
            "attempts_made": 2,
            "validation_results": [
              {
                "attempt": 1,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk diff line expected: @@ -110,13 +110,12 @@\n",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 89.33
              },
              {
                "attempt": 2,
                "format_valid": true,
                "format_error": "Valid patch format",
                "apply_valid": true,
                "apply_error": "Patch applies cleanly in repo",
                "valid": true,
                "runtime_seconds": 81.57
              }
            ],
            "token_counts": {
              "openai": 267,
              "general": {
                "word_based": 110,
                "char_based": 353
              },
              "gemini": 11924
            }
          }
        ]
      },
      {
        "downstream_version": "12L",
        "gemini_token_usage": 5383,
        "branch_used": "android12L-release",
        "downstream_patch": "8bdbb580da847d82f16fb57883a01a5e65ffa696",
        "repo_path": "android_repos/Settings",
        "result": "failure",
        "downstream_patch_content": "commit 8bdbb580da847d82f16fb57883a01a5e65ffa696\nAuthor: Jason Chiu <chiujason@google.com>\nDate:   Wed Jan 31 16:29:01 2024 +0800\n\n    Replace getCallingActivity() with getLaunchedFromPackage()\n    \n    getLaunchedFromPackage() reports who launched this Activity or built\n    PendingIntent used to launch it, whereas getCallingActivity() reports\n    who will get result of Activity.\n    \n    Bug: 316891059\n    Test: robotest, manual\n    Change-Id: If97018c2741caef622f0596bbfeaa42ef1788b78\n    Merged-In: If97018c2741caef622f0596bbfeaa42ef1788b78\n    (cherry picked from commit ddc11bc03ab48e885f652b89df5f92ff283bcd4a)\n\ndiff --git a/src/com/android/settings/search/SearchFeatureProvider.java b/src/com/android/settings/search/SearchFeatureProvider.java\nindex 1785361d3b2..c4141e91f72 100644\n--- a/src/com/android/settings/search/SearchFeatureProvider.java\n+++ b/src/com/android/settings/search/SearchFeatureProvider.java\n@@ -56,7 +56,7 @@ public interface SearchFeatureProvider {\n      * @throws IllegalArgumentException when caller is null\n      * @throws SecurityException        when caller is not allowed to launch search result page\n      */\n-    void verifyLaunchSearchResultPageCaller(Context context, @NonNull ComponentName caller)\n+    void verifyLaunchSearchResultPageCaller(@NonNull Context context, @NonNull String callerPackage)\n             throws SecurityException, IllegalArgumentException;\n \n     /**\ndiff --git a/src/com/android/settings/search/SearchFeatureProviderImpl.java b/src/com/android/settings/search/SearchFeatureProviderImpl.java\nindex 6f909709058..3a62ddfb67e 100644\n--- a/src/com/android/settings/search/SearchFeatureProviderImpl.java\n+++ b/src/com/android/settings/search/SearchFeatureProviderImpl.java\n@@ -17,13 +17,14 @@\n \n package com.android.settings.search;\n \n-import android.content.ComponentName;\n import android.content.Context;\n import android.content.Intent;\n import android.net.Uri;\n import android.provider.Settings;\n import android.text.TextUtils;\n \n+import androidx.annotation.NonNull;\n+\n import com.android.settingslib.search.SearchIndexableResources;\n import com.android.settingslib.search.SearchIndexableResourcesMobile;\n \n@@ -32,21 +33,18 @@ import com.android.settingslib.search.SearchIndexableResourcesMobile;\n  */\n public class SearchFeatureProviderImpl implements SearchFeatureProvider {\n \n-    private static final String TAG = \"SearchFeatureProvider\";\n-\n     private SearchIndexableResources mSearchIndexableResources;\n \n     @Override\n-    public void verifyLaunchSearchResultPageCaller(Context context, ComponentName caller) {\n-        if (caller == null) {\n+    public void verifyLaunchSearchResultPageCaller(@NonNull Context context,\n+            @NonNull String callerPackage) {\n+        if (TextUtils.isEmpty(callerPackage)) {\n             throw new IllegalArgumentException(\"ExternalSettingsTrampoline intents \"\n                     + \"must be called with startActivityForResult\");\n         }\n-        final String packageName = caller.getPackageName();\n-        final boolean isSettingsPackage = TextUtils.equals(packageName, context.getPackageName())\n-                || TextUtils.equals(getSettingsIntelligencePkgName(context), packageName);\n-        final boolean isAllowlistedPackage =\n-                isSignatureAllowlisted(context, caller.getPackageName());\n+        final boolean isSettingsPackage = TextUtils.equals(callerPackage, context.getPackageName())\n+                || TextUtils.equals(getSettingsIntelligencePkgName(context), callerPackage);\n+        final boolean isAllowlistedPackage = isSignatureAllowlisted(context, callerPackage);\n         if (isSettingsPackage || isAllowlistedPackage) {\n             return;\n         }\ndiff --git a/src/com/android/settings/search/SearchResultTrampoline.java b/src/com/android/settings/search/SearchResultTrampoline.java\nindex 8b041b67f87..6580c682fa1 100644\n--- a/src/com/android/settings/search/SearchResultTrampoline.java\n+++ b/src/com/android/settings/search/SearchResultTrampoline.java\n@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.os.Bundle;\n import android.provider.Settings;\n@@ -48,11 +47,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -96,7 +95,7 @@ public class SearchResultTrampoline extends Activity {\n \n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n             // navigation behavior.\n             ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n@@ -122,9 +121,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\ndiff --git a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\nindex 5de57b6c95e..dec99028e82 100644\n--- a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n+++ b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n@@ -20,7 +20,6 @@ package com.android.settings.search;\n import static com.google.common.truth.Truth.assertThat;\n \n import android.app.settings.SettingsEnums;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n import android.content.pm.ResolveInfo;\n@@ -127,20 +126,22 @@ public class SearchFeatureProviderImplTest {\n \n     @Test(expected = SecurityException.class)\n     public void verifyLaunchSearchResultPageCaller_badCaller_shouldCrash() {\n-        final ComponentName cn = new ComponentName(\"pkg\", \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = \"pkg\";\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsCaller_shouldNotCrash() {\n-        final ComponentName cn = new ComponentName(mActivity.getPackageName(), \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = mActivity.getPackageName();\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsIntelligenceCaller_shouldNotCrash() {\n         final String packageName = mProvider.getSettingsIntelligencePkgName(mActivity);\n-        final ComponentName cn = new ComponentName(packageName, \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n }\n",
        "downstream_patch_tokens": {
          "openai": 1732,
          "general": {
            "word_based": 720,
            "char_based": 2070
          },
          "gemini": 2215
        },
        "file_conflicts": [
          {
            "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
            "total_hunks": 4,
            "failed_hunks": [
              2,
              3,
              4
            ],
            "inline_merge_conflicts": [],
            "inline_merge_token_summary": {
              "gemini": 0,
              "openai": 0,
              "general_word": 0,
              "general_char": 0
            },
            "rej_file_content": "```diff\n--- src/com/android/settings/search/SearchResultTrampoline.java\n+++ src/com/android/settings/search/SearchResultTrampoline.java\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -105,7 +104,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\n```",
            "rej_file_tokens": {
              "openai": 399,
              "general": {
                "word_based": 155,
                "char_based": 536
              },
              "gemini": 480
            },
            "patch_apply_output": "patching file src/com/android/settings/search/SearchFeatureProvider.java\npatching file src/com/android/settings/search/SearchFeatureProviderImpl.java\npatching file src/com/android/settings/search/SearchResultTrampoline.java\nHunk #1 succeeded at 20 with fuzz 2 (offset -1 lines).\nHunk #2 FAILED at 52.\nHunk #3 FAILED at 105.\nHunk #4 FAILED at 138.\n3 out of 4 hunks FAILED -- saving rejects to file src/com/android/settings/search/SearchResultTrampoline.java.rej",
            "inline_merge_output": "patching file src/com/android/settings/search/SearchResultTrampoline.java\nHunk #1 already applied at 24.\nHunk #2 already applied at 55,59.\nHunk #3 already applied at 108.\nHunk #4 already applied at 141-143.",
            "upstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\nimport static com.android.settings.activityembedding.EmbeddedDeepLinkUtils.getTrampolineIntent;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.FeatureFlagUtils;\nimport android.util.Log;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsApplication;\nimport com.android.settings.SubSettings;\nimport com.android.settings.activityembedding.ActivityEmbeddingRulesController;\nimport com.android.settings.activityembedding.ActivityEmbeddingUtils;\nimport com.android.settings.core.FeatureFlags;\nimport com.android.settings.homepage.DeepLinkHomepageActivityInternal;\nimport com.android.settings.homepage.SettingsHomepageActivity;\nimport com.android.settings.overlay.FeatureFactory;\n\nimport java.net.URISyntaxException;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    private static final String TAG = \"SearchResultTrampoline\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final String callerPackage = getLaunchedFromPackage();\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFeatureFactory()\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n        // Didn't crash, proceed and launch the result as a subsetting.\n        Intent intent = getIntent();\n        final String highlightMenuKey = intent.getStringExtra(\n                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);\n\n        final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);\n        if (!TextUtils.isEmpty(fragment)) {\n            // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n            // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from\n            // external caller and args may not persisted.\n            final String settingKey = intent.getStringExtra(\n                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n            final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n            final Bundle args = new Bundle();\n            args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n            args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n            intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n            // Reroute request to SubSetting.\n            intent.setClass(this /* context */, SubSettings.class);\n        } else {\n            // Direct link case\n            final String intentUriString = intent.getStringExtra(\n                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);\n            if (TextUtils.isEmpty(intentUriString)) {\n                Log.e(TAG, \"No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link\");\n                finish();\n                return;\n            }\n\n            final Uri data = intent.getParcelableExtra(\n                    SettingsHomepageActivity.EXTRA_SETTINGS_LARGE_SCREEN_DEEP_LINK_INTENT_DATA,\n                    Uri.class);\n            try {\n                intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);\n                intent.setData(data);\n            } catch (URISyntaxException e) {\n                Log.e(TAG, \"Failed to parse deep link intent: \" + e);\n                finish();\n                return;\n            }\n        }\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n\n        if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n            startActivity(intent);\n        } else if (isSettingsIntelligence(callerPackage)) {\n            if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                startActivity(getTrampolineIntent(intent, highlightMenuKey)\n                        .setClass(this, DeepLinkHomepageActivityInternal.class)\n                        .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                                | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS));\n            } else {\n                // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected\n                // back navigation behavior.\n                ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n                        false /* clearTop */);\n\n                intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);\n                startActivity(intent);\n\n                // Pass menu key to homepage\n                final SettingsHomepageActivity homeActivity =\n                        ((SettingsApplication) getApplicationContext()).getHomeActivity();\n                if (homeActivity != null) {\n                    homeActivity.getMainFragment().setHighlightMenuKey(highlightMenuKey,\n                            /* scrollNeeded= */ true);\n                }\n            }\n        } else {\n            // Two-pane case\n            startActivity(getTrampolineIntent(intent, highlightMenuKey)\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));\n        }\n\n        // Done.\n        finish();\n    }\n\n    private boolean isSettingsIntelligence(String callerPackage) {\n        return TextUtils.equals(\n                callerPackage,\n                FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                        .getSettingsIntelligencePkgName(this));\n    }\n}\n```",
            "upstream_file_tokens": {
              "openai": 1137,
              "general": {
                "word_based": 526,
                "char_based": 1616
              },
              "gemini": 1451
            },
            "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsApplication;\nimport com.android.settings.SubSettings;\nimport com.android.settings.activityembedding.ActivityEmbeddingRulesController;\nimport com.android.settings.activityembedding.ActivityEmbeddingUtils;\nimport com.android.settings.homepage.SettingsHomepageActivity;\nimport com.android.settings.overlay.FeatureFactory;\n\nimport java.net.URISyntaxException;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    private static final String TAG = \"SearchResultTrampoline\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final ComponentName callingActivity = getCallingActivity();\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFactory(this)\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n        // Didn't crash, proceed and launch the result as a subsetting.\n        Intent intent = getIntent();\n        final String highlightMenuKey = intent.getStringExtra(\n                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);\n\n        final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);\n        if (!TextUtils.isEmpty(fragment)) {\n            // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n            // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from\n            // external caller and args may not persisted.\n            final String settingKey = intent.getStringExtra(\n                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n            final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n            final Bundle args = new Bundle();\n            args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n            args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n            intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n            // Reroute request to SubSetting.\n            intent.setClass(this /* context */, SubSettings.class);\n        } else {\n            // Direct link case\n            final String intentUriString = intent.getStringExtra(\n                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);\n            if (TextUtils.isEmpty(intentUriString)) {\n                Log.e(TAG, \"No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link\");\n                finish();\n                return;\n            }\n\n            try {\n                intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);\n            } catch (URISyntaxException e) {\n                Log.e(TAG, \"Failed to parse deep link intent: \" + e);\n                finish();\n                return;\n            }\n        }\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n\n        if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n            startActivity(intent);\n        } else if (isSettingsIntelligence(callingActivity)) {\n            // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n            // navigation behavior.\n            ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n                    false /* clearTop */);\n\n            intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);\n            startActivity(intent);\n\n            // Pass menu key to homepage\n            final SettingsHomepageActivity homeActivity =\n                    ((SettingsApplication) getApplicationContext()).getHomeActivity();\n            if (homeActivity != null) {\n                homeActivity.getMainFragment().setHighlightMenuKey(highlightMenuKey,\n                        /* scrollNeeded= */ true);\n            }\n        } else {\n            // Two-pane case\n            startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));\n        }\n\n        // Done.\n        finish();\n    }\n\n    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n        return callingActivity != null && TextUtils.equals(\n                callingActivity.getPackageName(),\n                FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                        .getSettingsIntelligencePkgName(this));\n    }\n}\n```",
            "downstream_file_tokens": {
              "openai": 980,
              "general": {
                "word_based": 469,
                "char_based": 1373
              },
              "gemini": 1237
            },
            "downstream_file_content_ground_truth": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsApplication;\nimport com.android.settings.SubSettings;\nimport com.android.settings.activityembedding.ActivityEmbeddingRulesController;\nimport com.android.settings.activityembedding.ActivityEmbeddingUtils;\nimport com.android.settings.homepage.SettingsHomepageActivity;\nimport com.android.settings.overlay.FeatureFactory;\n\nimport java.net.URISyntaxException;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    private static final String TAG = \"SearchResultTrampoline\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final String callerPackage = getLaunchedFromPackage();\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFactory(this)\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n        // Didn't crash, proceed and launch the result as a subsetting.\n        Intent intent = getIntent();\n        final String highlightMenuKey = intent.getStringExtra(\n                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);\n\n        final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);\n        if (!TextUtils.isEmpty(fragment)) {\n            // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n            // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from\n            // external caller and args may not persisted.\n            final String settingKey = intent.getStringExtra(\n                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n            final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n            final Bundle args = new Bundle();\n            args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n            args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n            intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n            // Reroute request to SubSetting.\n            intent.setClass(this /* context */, SubSettings.class);\n        } else {\n            // Direct link case\n            final String intentUriString = intent.getStringExtra(\n                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);\n            if (TextUtils.isEmpty(intentUriString)) {\n                Log.e(TAG, \"No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link\");\n                finish();\n                return;\n            }\n\n            try {\n                intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);\n            } catch (URISyntaxException e) {\n                Log.e(TAG, \"Failed to parse deep link intent: \" + e);\n                finish();\n                return;\n            }\n        }\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n\n        if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n            startActivity(intent);\n        } else if (isSettingsIntelligence(callerPackage)) {\n            // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n            // navigation behavior.\n            ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n                    false /* clearTop */);\n\n            intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);\n            startActivity(intent);\n\n            // Pass menu key to homepage\n            final SettingsHomepageActivity homeActivity =\n                    ((SettingsApplication) getApplicationContext()).getHomeActivity();\n            if (homeActivity != null) {\n                homeActivity.getMainFragment().setHighlightMenuKey(highlightMenuKey,\n                        /* scrollNeeded= */ true);\n            }\n        } else {\n            // Two-pane case\n            startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));\n        }\n\n        // Done.\n        finish();\n    }\n\n    private boolean isSettingsIntelligence(String callerPackage) {\n        return TextUtils.equals(\n                callerPackage,\n                FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                        .getSettingsIntelligencePkgName(this));\n    }\n}",
            "downstream_file_ground_truth_tokens": {
              "openai": 973,
              "general": {
                "word_based": 466,
                "char_based": 1357
              },
              "gemini": 1230
            },
            "downstream_file_content_patched_upstream_only": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsApplication;\nimport com.android.settings.SubSettings;\nimport com.android.settings.activityembedding.ActivityEmbeddingRulesController;\nimport com.android.settings.activityembedding.ActivityEmbeddingUtils;\nimport com.android.settings.homepage.SettingsHomepageActivity;\nimport com.android.settings.overlay.FeatureFactory;\n\nimport java.net.URISyntaxException;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    private static final String TAG = \"SearchResultTrampoline\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final ComponentName callingActivity = getCallingActivity();\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFactory(this)\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n        // Didn't crash, proceed and launch the result as a subsetting.\n        Intent intent = getIntent();\n        final String highlightMenuKey = intent.getStringExtra(\n                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);\n\n        final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);\n        if (!TextUtils.isEmpty(fragment)) {\n            // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n            // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from\n            // external caller and args may not persisted.\n            final String settingKey = intent.getStringExtra(\n                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n            final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n            final Bundle args = new Bundle();\n            args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n            args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n            intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n            // Reroute request to SubSetting.\n            intent.setClass(this /* context */, SubSettings.class);\n        } else {\n            // Direct link case\n            final String intentUriString = intent.getStringExtra(\n                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);\n            if (TextUtils.isEmpty(intentUriString)) {\n                Log.e(TAG, \"No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link\");\n                finish();\n                return;\n            }\n\n            try {\n                intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);\n            } catch (URISyntaxException e) {\n                Log.e(TAG, \"Failed to parse deep link intent: \" + e);\n                finish();\n                return;\n            }\n        }\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n\n        if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n            startActivity(intent);\n        } else if (isSettingsIntelligence(callingActivity)) {\n            // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n            // navigation behavior.\n            ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n                    false /* clearTop */);\n\n            intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);\n            startActivity(intent);\n\n            // Pass menu key to homepage\n            final SettingsHomepageActivity homeActivity =\n                    ((SettingsApplication) getApplicationContext()).getHomeActivity();\n            if (homeActivity != null) {\n                homeActivity.getMainFragment().setHighlightMenuKey(highlightMenuKey,\n                        /* scrollNeeded= */ true);\n            }\n        } else {\n            // Two-pane case\n            startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));\n        }\n\n        // Done.\n        finish();\n    }\n\n    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n        return callingActivity != null && TextUtils.equals(\n                callingActivity.getPackageName(),\n                FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                        .getSettingsIntelligencePkgName(this));\n    }\n}\n```",
            "diff_patched_upstream_only": "--- original_downstream_file\n+++ patched_upstream_only\n@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2017 The Android Open Source Project\n  *\n@@ -128,5 +127,4 @@\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\n-}\n-```+}",
            "downstream_llm_diff_output": null,
            "runtime_seconds": 423.74,
            "llm_output_valid": false,
            "attempts_made": 3,
            "validation_results": [
              {
                "attempt": 1,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk is longer than expected",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 137.23
              },
              {
                "attempt": 2,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk is longer than expected",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 157.06
              },
              {
                "attempt": 3,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk diff line expected: @@ -77,9 +77,12 @@\n",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 129.45
              }
            ],
            "error": "All validation attempts failed",
            "last_format_error": "Invalid patch format: Hunk diff line expected: @@ -77,9 +77,12 @@\n",
            "last_apply_error": "Skipped due to format error"
          }
        ]
      },
      {
        "downstream_version": "13",
        "gemini_token_usage": 5383,
        "branch_used": "android13-release",
        "downstream_patch": "8bdbb580da847d82f16fb57883a01a5e65ffa696",
        "repo_path": "android_repos/Settings",
        "result": "failure",
        "downstream_patch_content": "commit 8bdbb580da847d82f16fb57883a01a5e65ffa696\nAuthor: Jason Chiu <chiujason@google.com>\nDate:   Wed Jan 31 16:29:01 2024 +0800\n\n    Replace getCallingActivity() with getLaunchedFromPackage()\n    \n    getLaunchedFromPackage() reports who launched this Activity or built\n    PendingIntent used to launch it, whereas getCallingActivity() reports\n    who will get result of Activity.\n    \n    Bug: 316891059\n    Test: robotest, manual\n    Change-Id: If97018c2741caef622f0596bbfeaa42ef1788b78\n    Merged-In: If97018c2741caef622f0596bbfeaa42ef1788b78\n    (cherry picked from commit ddc11bc03ab48e885f652b89df5f92ff283bcd4a)\n\ndiff --git a/src/com/android/settings/search/SearchFeatureProvider.java b/src/com/android/settings/search/SearchFeatureProvider.java\nindex 1785361d3b2..c4141e91f72 100644\n--- a/src/com/android/settings/search/SearchFeatureProvider.java\n+++ b/src/com/android/settings/search/SearchFeatureProvider.java\n@@ -56,7 +56,7 @@ public interface SearchFeatureProvider {\n      * @throws IllegalArgumentException when caller is null\n      * @throws SecurityException        when caller is not allowed to launch search result page\n      */\n-    void verifyLaunchSearchResultPageCaller(Context context, @NonNull ComponentName caller)\n+    void verifyLaunchSearchResultPageCaller(@NonNull Context context, @NonNull String callerPackage)\n             throws SecurityException, IllegalArgumentException;\n \n     /**\ndiff --git a/src/com/android/settings/search/SearchFeatureProviderImpl.java b/src/com/android/settings/search/SearchFeatureProviderImpl.java\nindex 6f909709058..3a62ddfb67e 100644\n--- a/src/com/android/settings/search/SearchFeatureProviderImpl.java\n+++ b/src/com/android/settings/search/SearchFeatureProviderImpl.java\n@@ -17,13 +17,14 @@\n \n package com.android.settings.search;\n \n-import android.content.ComponentName;\n import android.content.Context;\n import android.content.Intent;\n import android.net.Uri;\n import android.provider.Settings;\n import android.text.TextUtils;\n \n+import androidx.annotation.NonNull;\n+\n import com.android.settingslib.search.SearchIndexableResources;\n import com.android.settingslib.search.SearchIndexableResourcesMobile;\n \n@@ -32,21 +33,18 @@ import com.android.settingslib.search.SearchIndexableResourcesMobile;\n  */\n public class SearchFeatureProviderImpl implements SearchFeatureProvider {\n \n-    private static final String TAG = \"SearchFeatureProvider\";\n-\n     private SearchIndexableResources mSearchIndexableResources;\n \n     @Override\n-    public void verifyLaunchSearchResultPageCaller(Context context, ComponentName caller) {\n-        if (caller == null) {\n+    public void verifyLaunchSearchResultPageCaller(@NonNull Context context,\n+            @NonNull String callerPackage) {\n+        if (TextUtils.isEmpty(callerPackage)) {\n             throw new IllegalArgumentException(\"ExternalSettingsTrampoline intents \"\n                     + \"must be called with startActivityForResult\");\n         }\n-        final String packageName = caller.getPackageName();\n-        final boolean isSettingsPackage = TextUtils.equals(packageName, context.getPackageName())\n-                || TextUtils.equals(getSettingsIntelligencePkgName(context), packageName);\n-        final boolean isAllowlistedPackage =\n-                isSignatureAllowlisted(context, caller.getPackageName());\n+        final boolean isSettingsPackage = TextUtils.equals(callerPackage, context.getPackageName())\n+                || TextUtils.equals(getSettingsIntelligencePkgName(context), callerPackage);\n+        final boolean isAllowlistedPackage = isSignatureAllowlisted(context, callerPackage);\n         if (isSettingsPackage || isAllowlistedPackage) {\n             return;\n         }\ndiff --git a/src/com/android/settings/search/SearchResultTrampoline.java b/src/com/android/settings/search/SearchResultTrampoline.java\nindex 8b041b67f87..6580c682fa1 100644\n--- a/src/com/android/settings/search/SearchResultTrampoline.java\n+++ b/src/com/android/settings/search/SearchResultTrampoline.java\n@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.os.Bundle;\n import android.provider.Settings;\n@@ -48,11 +47,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -96,7 +95,7 @@ public class SearchResultTrampoline extends Activity {\n \n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n             // navigation behavior.\n             ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n@@ -122,9 +121,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\ndiff --git a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\nindex 5de57b6c95e..dec99028e82 100644\n--- a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n+++ b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n@@ -20,7 +20,6 @@ package com.android.settings.search;\n import static com.google.common.truth.Truth.assertThat;\n \n import android.app.settings.SettingsEnums;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n import android.content.pm.ResolveInfo;\n@@ -127,20 +126,22 @@ public class SearchFeatureProviderImplTest {\n \n     @Test(expected = SecurityException.class)\n     public void verifyLaunchSearchResultPageCaller_badCaller_shouldCrash() {\n-        final ComponentName cn = new ComponentName(\"pkg\", \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = \"pkg\";\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsCaller_shouldNotCrash() {\n-        final ComponentName cn = new ComponentName(mActivity.getPackageName(), \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = mActivity.getPackageName();\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsIntelligenceCaller_shouldNotCrash() {\n         final String packageName = mProvider.getSettingsIntelligencePkgName(mActivity);\n-        final ComponentName cn = new ComponentName(packageName, \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n }\n",
        "downstream_patch_tokens": {
          "openai": 1732,
          "general": {
            "word_based": 720,
            "char_based": 2070
          },
          "gemini": 2215
        },
        "file_conflicts": [
          {
            "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
            "total_hunks": 4,
            "failed_hunks": [
              2,
              3,
              4
            ],
            "inline_merge_conflicts": [],
            "inline_merge_token_summary": {
              "gemini": 0,
              "openai": 0,
              "general_word": 0,
              "general_char": 0
            },
            "rej_file_content": "```diff\n--- src/com/android/settings/search/SearchResultTrampoline.java\n+++ src/com/android/settings/search/SearchResultTrampoline.java\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -105,7 +104,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\n```",
            "rej_file_tokens": {
              "openai": 399,
              "general": {
                "word_based": 155,
                "char_based": 536
              },
              "gemini": 480
            },
            "patch_apply_output": "patching file src/com/android/settings/search/SearchFeatureProvider.java\npatching file src/com/android/settings/search/SearchFeatureProviderImpl.java\npatching file src/com/android/settings/search/SearchResultTrampoline.java\nHunk #1 succeeded at 20 with fuzz 2 (offset -1 lines).\nHunk #2 FAILED at 52.\nHunk #3 FAILED at 105.\nHunk #4 FAILED at 138.\n3 out of 4 hunks FAILED -- saving rejects to file src/com/android/settings/search/SearchResultTrampoline.java.rej",
            "inline_merge_output": "patching file src/com/android/settings/search/SearchResultTrampoline.java\nHunk #1 already applied at 24.\nHunk #2 already applied at 55,59.\nHunk #3 already applied at 108.\nHunk #4 already applied at 141-143.",
            "upstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\nimport static com.android.settings.activityembedding.EmbeddedDeepLinkUtils.getTrampolineIntent;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.FeatureFlagUtils;\nimport android.util.Log;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsApplication;\nimport com.android.settings.SubSettings;\nimport com.android.settings.activityembedding.ActivityEmbeddingRulesController;\nimport com.android.settings.activityembedding.ActivityEmbeddingUtils;\nimport com.android.settings.core.FeatureFlags;\nimport com.android.settings.homepage.DeepLinkHomepageActivityInternal;\nimport com.android.settings.homepage.SettingsHomepageActivity;\nimport com.android.settings.overlay.FeatureFactory;\n\nimport java.net.URISyntaxException;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    private static final String TAG = \"SearchResultTrampoline\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final String callerPackage = getLaunchedFromPackage();\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFeatureFactory()\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n        // Didn't crash, proceed and launch the result as a subsetting.\n        Intent intent = getIntent();\n        final String highlightMenuKey = intent.getStringExtra(\n                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);\n\n        final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);\n        if (!TextUtils.isEmpty(fragment)) {\n            // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n            // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from\n            // external caller and args may not persisted.\n            final String settingKey = intent.getStringExtra(\n                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n            final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n            final Bundle args = new Bundle();\n            args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n            args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n            intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n            // Reroute request to SubSetting.\n            intent.setClass(this /* context */, SubSettings.class);\n        } else {\n            // Direct link case\n            final String intentUriString = intent.getStringExtra(\n                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);\n            if (TextUtils.isEmpty(intentUriString)) {\n                Log.e(TAG, \"No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link\");\n                finish();\n                return;\n            }\n\n            final Uri data = intent.getParcelableExtra(\n                    SettingsHomepageActivity.EXTRA_SETTINGS_LARGE_SCREEN_DEEP_LINK_INTENT_DATA,\n                    Uri.class);\n            try {\n                intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);\n                intent.setData(data);\n            } catch (URISyntaxException e) {\n                Log.e(TAG, \"Failed to parse deep link intent: \" + e);\n                finish();\n                return;\n            }\n        }\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n\n        if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n            startActivity(intent);\n        } else if (isSettingsIntelligence(callerPackage)) {\n            if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                startActivity(getTrampolineIntent(intent, highlightMenuKey)\n                        .setClass(this, DeepLinkHomepageActivityInternal.class)\n                        .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                                | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS));\n            } else {\n                // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected\n                // back navigation behavior.\n                ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n                        false /* clearTop */);\n\n                intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);\n                startActivity(intent);\n\n                // Pass menu key to homepage\n                final SettingsHomepageActivity homeActivity =\n                        ((SettingsApplication) getApplicationContext()).getHomeActivity();\n                if (homeActivity != null) {\n                    homeActivity.getMainFragment().setHighlightMenuKey(highlightMenuKey,\n                            /* scrollNeeded= */ true);\n                }\n            }\n        } else {\n            // Two-pane case\n            startActivity(getTrampolineIntent(intent, highlightMenuKey)\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));\n        }\n\n        // Done.\n        finish();\n    }\n\n    private boolean isSettingsIntelligence(String callerPackage) {\n        return TextUtils.equals(\n                callerPackage,\n                FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                        .getSettingsIntelligencePkgName(this));\n    }\n}\n```",
            "upstream_file_tokens": {
              "openai": 1137,
              "general": {
                "word_based": 526,
                "char_based": 1616
              },
              "gemini": 1451
            },
            "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsApplication;\nimport com.android.settings.SubSettings;\nimport com.android.settings.activityembedding.ActivityEmbeddingRulesController;\nimport com.android.settings.activityembedding.ActivityEmbeddingUtils;\nimport com.android.settings.homepage.SettingsHomepageActivity;\nimport com.android.settings.overlay.FeatureFactory;\n\nimport java.net.URISyntaxException;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    private static final String TAG = \"SearchResultTrampoline\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final ComponentName callingActivity = getCallingActivity();\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFactory(this)\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n        // Didn't crash, proceed and launch the result as a subsetting.\n        Intent intent = getIntent();\n        final String highlightMenuKey = intent.getStringExtra(\n                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);\n\n        final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);\n        if (!TextUtils.isEmpty(fragment)) {\n            // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n            // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from\n            // external caller and args may not persisted.\n            final String settingKey = intent.getStringExtra(\n                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n            final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n            final Bundle args = new Bundle();\n            args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n            args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n            intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n            // Reroute request to SubSetting.\n            intent.setClass(this /* context */, SubSettings.class);\n        } else {\n            // Direct link case\n            final String intentUriString = intent.getStringExtra(\n                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);\n            if (TextUtils.isEmpty(intentUriString)) {\n                Log.e(TAG, \"No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link\");\n                finish();\n                return;\n            }\n\n            try {\n                intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);\n            } catch (URISyntaxException e) {\n                Log.e(TAG, \"Failed to parse deep link intent: \" + e);\n                finish();\n                return;\n            }\n        }\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n\n        if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n            startActivity(intent);\n        } else if (isSettingsIntelligence(callingActivity)) {\n            // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n            // navigation behavior.\n            ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n                    false /* clearTop */);\n\n            intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);\n            startActivity(intent);\n\n            // Pass menu key to homepage\n            final SettingsHomepageActivity homeActivity =\n                    ((SettingsApplication) getApplicationContext()).getHomeActivity();\n            if (homeActivity != null) {\n                homeActivity.getMainFragment().setHighlightMenuKey(highlightMenuKey,\n                        /* scrollNeeded= */ true);\n            }\n        } else {\n            // Two-pane case\n            startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));\n        }\n\n        // Done.\n        finish();\n    }\n\n    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n        return callingActivity != null && TextUtils.equals(\n                callingActivity.getPackageName(),\n                FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                        .getSettingsIntelligencePkgName(this));\n    }\n}\n```",
            "downstream_file_tokens": {
              "openai": 980,
              "general": {
                "word_based": 469,
                "char_based": 1373
              },
              "gemini": 1237
            },
            "downstream_file_content_ground_truth": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsApplication;\nimport com.android.settings.SubSettings;\nimport com.android.settings.activityembedding.ActivityEmbeddingRulesController;\nimport com.android.settings.activityembedding.ActivityEmbeddingUtils;\nimport com.android.settings.homepage.SettingsHomepageActivity;\nimport com.android.settings.overlay.FeatureFactory;\n\nimport java.net.URISyntaxException;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    private static final String TAG = \"SearchResultTrampoline\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final String callerPackage = getLaunchedFromPackage();\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFactory(this)\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n        // Didn't crash, proceed and launch the result as a subsetting.\n        Intent intent = getIntent();\n        final String highlightMenuKey = intent.getStringExtra(\n                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);\n\n        final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);\n        if (!TextUtils.isEmpty(fragment)) {\n            // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n            // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from\n            // external caller and args may not persisted.\n            final String settingKey = intent.getStringExtra(\n                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n            final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n            final Bundle args = new Bundle();\n            args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n            args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n            intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n            // Reroute request to SubSetting.\n            intent.setClass(this /* context */, SubSettings.class);\n        } else {\n            // Direct link case\n            final String intentUriString = intent.getStringExtra(\n                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);\n            if (TextUtils.isEmpty(intentUriString)) {\n                Log.e(TAG, \"No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link\");\n                finish();\n                return;\n            }\n\n            try {\n                intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);\n            } catch (URISyntaxException e) {\n                Log.e(TAG, \"Failed to parse deep link intent: \" + e);\n                finish();\n                return;\n            }\n        }\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n\n        if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n            startActivity(intent);\n        } else if (isSettingsIntelligence(callerPackage)) {\n            // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n            // navigation behavior.\n            ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n                    false /* clearTop */);\n\n            intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);\n            startActivity(intent);\n\n            // Pass menu key to homepage\n            final SettingsHomepageActivity homeActivity =\n                    ((SettingsApplication) getApplicationContext()).getHomeActivity();\n            if (homeActivity != null) {\n                homeActivity.getMainFragment().setHighlightMenuKey(highlightMenuKey,\n                        /* scrollNeeded= */ true);\n            }\n        } else {\n            // Two-pane case\n            startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));\n        }\n\n        // Done.\n        finish();\n    }\n\n    private boolean isSettingsIntelligence(String callerPackage) {\n        return TextUtils.equals(\n                callerPackage,\n                FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                        .getSettingsIntelligencePkgName(this));\n    }\n}",
            "downstream_file_ground_truth_tokens": {
              "openai": 973,
              "general": {
                "word_based": 466,
                "char_based": 1357
              },
              "gemini": 1230
            },
            "downstream_file_content_patched_upstream_only": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsApplication;\nimport com.android.settings.SubSettings;\nimport com.android.settings.activityembedding.ActivityEmbeddingRulesController;\nimport com.android.settings.activityembedding.ActivityEmbeddingUtils;\nimport com.android.settings.homepage.SettingsHomepageActivity;\nimport com.android.settings.overlay.FeatureFactory;\n\nimport java.net.URISyntaxException;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    private static final String TAG = \"SearchResultTrampoline\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final ComponentName callingActivity = getCallingActivity();\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFactory(this)\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n        // Didn't crash, proceed and launch the result as a subsetting.\n        Intent intent = getIntent();\n        final String highlightMenuKey = intent.getStringExtra(\n                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);\n\n        final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);\n        if (!TextUtils.isEmpty(fragment)) {\n            // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n            // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from\n            // external caller and args may not persisted.\n            final String settingKey = intent.getStringExtra(\n                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n            final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n            final Bundle args = new Bundle();\n            args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n            args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n            intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n            // Reroute request to SubSetting.\n            intent.setClass(this /* context */, SubSettings.class);\n        } else {\n            // Direct link case\n            final String intentUriString = intent.getStringExtra(\n                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);\n            if (TextUtils.isEmpty(intentUriString)) {\n                Log.e(TAG, \"No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link\");\n                finish();\n                return;\n            }\n\n            try {\n                intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);\n            } catch (URISyntaxException e) {\n                Log.e(TAG, \"Failed to parse deep link intent: \" + e);\n                finish();\n                return;\n            }\n        }\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n\n        if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n            startActivity(intent);\n        } else if (isSettingsIntelligence(callingActivity)) {\n            // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n            // navigation behavior.\n            ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n                    false /* clearTop */);\n\n            intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);\n            startActivity(intent);\n\n            // Pass menu key to homepage\n            final SettingsHomepageActivity homeActivity =\n                    ((SettingsApplication) getApplicationContext()).getHomeActivity();\n            if (homeActivity != null) {\n                homeActivity.getMainFragment().setHighlightMenuKey(highlightMenuKey,\n                        /* scrollNeeded= */ true);\n            }\n        } else {\n            // Two-pane case\n            startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));\n        }\n\n        // Done.\n        finish();\n    }\n\n    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n        return callingActivity != null && TextUtils.equals(\n                callingActivity.getPackageName(),\n                FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                        .getSettingsIntelligencePkgName(this));\n    }\n}\n```",
            "diff_patched_upstream_only": "--- original_downstream_file\n+++ patched_upstream_only\n@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2017 The Android Open Source Project\n  *\n@@ -128,5 +127,4 @@\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\n-}\n-```+}",
            "downstream_llm_diff_output": null,
            "runtime_seconds": 410.34,
            "llm_output_valid": false,
            "attempts_made": 3,
            "validation_results": [
              {
                "attempt": 1,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk diff line expected: @@ -100,14 +100,14 @@\n",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 98.92
              },
              {
                "attempt": 2,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk diff line expected: @@ -79,7 +79,7 @@\n",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 142.27
              },
              {
                "attempt": 3,
                "format_valid": false,
                "format_error": "Invalid patch format: Unexpected hunk found: @@ -103,13 +107,11 @@\n",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 169.15
              }
            ],
            "error": "All validation attempts failed",
            "last_format_error": "Invalid patch format: Unexpected hunk found: @@ -103,13 +107,11 @@\n",
            "last_apply_error": "Skipped due to format error"
          }
        ]
      },
      {
        "downstream_version": "12",
        "gemini_token_usage": 4432,
        "branch_used": "android12-release",
        "downstream_patch": "b86569b274003e517bfd089cc7d6ba62d1c5f820",
        "repo_path": "android_repos/Settings",
        "result": "failure",
        "downstream_patch_content": "commit b86569b274003e517bfd089cc7d6ba62d1c5f820\nAuthor: Jason Chiu <chiujason@google.com>\nDate:   Wed Jan 31 16:29:01 2024 +0800\n\n    [RESTRICT AUTOMERGE] Replace getCallingActivity() with getLaunchedFromPackage()\n    \n    getLaunchedFromPackage() reports who launched this Activity or built\n    PendingIntent used to launch it, whereas getCallingActivity() reports\n    who will get result of Activity.\n    \n    Bug: 316891059\n    Bug: 333364513\n    Test: robotest, manual\n    Change-Id: If97018c2741caef622f0596bbfeaa42ef1788b78\n    (cherry picked from commit ddc11bc03ab48e885f652b89df5f92ff283bcd4a)\n\ndiff --git a/src/com/android/settings/search/SearchFeatureProvider.java b/src/com/android/settings/search/SearchFeatureProvider.java\nindex 4c39b9c0c11..5c548788275 100644\n--- a/src/com/android/settings/search/SearchFeatureProvider.java\n+++ b/src/com/android/settings/search/SearchFeatureProvider.java\n@@ -51,7 +51,7 @@ public interface SearchFeatureProvider {\n      * @throws IllegalArgumentException when caller is null\n      * @throws SecurityException        when caller is not allowed to launch search result page\n      */\n-    void verifyLaunchSearchResultPageCaller(Context context, @NonNull ComponentName caller)\n+    void verifyLaunchSearchResultPageCaller(@NonNull Context context, @NonNull String callerPackage)\n             throws SecurityException, IllegalArgumentException;\n \n     /**\ndiff --git a/src/com/android/settings/search/SearchFeatureProviderImpl.java b/src/com/android/settings/search/SearchFeatureProviderImpl.java\nindex 508d37d7e6a..5035ef8f9fe 100644\n--- a/src/com/android/settings/search/SearchFeatureProviderImpl.java\n+++ b/src/com/android/settings/search/SearchFeatureProviderImpl.java\n@@ -17,13 +17,14 @@\n \n package com.android.settings.search;\n \n-import android.content.ComponentName;\n import android.content.Context;\n import android.content.Intent;\n import android.net.Uri;\n import android.provider.Settings;\n import android.text.TextUtils;\n \n+import androidx.annotation.NonNull;\n+\n import com.android.settingslib.search.SearchIndexableResources;\n import com.android.settingslib.search.SearchIndexableResourcesMobile;\n \n@@ -32,21 +33,18 @@ import com.android.settingslib.search.SearchIndexableResourcesMobile;\n  */\n public class SearchFeatureProviderImpl implements SearchFeatureProvider {\n \n-    private static final String TAG = \"SearchFeatureProvider\";\n-\n     private SearchIndexableResources mSearchIndexableResources;\n \n     @Override\n-    public void verifyLaunchSearchResultPageCaller(Context context, ComponentName caller) {\n-        if (caller == null) {\n+    public void verifyLaunchSearchResultPageCaller(@NonNull Context context,\n+            @NonNull String callerPackage) {\n+        if (TextUtils.isEmpty(callerPackage)) {\n             throw new IllegalArgumentException(\"ExternalSettingsTrampoline intents \"\n                     + \"must be called with startActivityForResult\");\n         }\n-        final String packageName = caller.getPackageName();\n-        final boolean isSettingsPackage = TextUtils.equals(packageName, context.getPackageName())\n-                || TextUtils.equals(getSettingsIntelligencePkgName(context), packageName);\n-        final boolean isAllowlistedPackage =\n-                isSignatureAllowlisted(context, caller.getPackageName());\n+        final boolean isSettingsPackage = TextUtils.equals(callerPackage, context.getPackageName())\n+                || TextUtils.equals(getSettingsIntelligencePkgName(context), callerPackage);\n+        final boolean isAllowlistedPackage = isSignatureAllowlisted(context, callerPackage);\n         if (isSettingsPackage || isAllowlistedPackage) {\n             return;\n         }\ndiff --git a/src/com/android/settings/search/SearchResultTrampoline.java b/src/com/android/settings/search/SearchResultTrampoline.java\nindex e9304739460..28030e81d87 100644\n--- a/src/com/android/settings/search/SearchResultTrampoline.java\n+++ b/src/com/android/settings/search/SearchResultTrampoline.java\n@@ -39,7 +39,7 @@ public class SearchResultTrampoline extends Activity {\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, getCallingActivity());\n+                .verifyLaunchSearchResultPageCaller(this, getLaunchedFromPackage());\n         // Didn't crash, proceed and launch the result as a subsetting.\n         final Intent intent = getIntent();\n \ndiff --git a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\nindex 444a8137889..ebd935d3406 100644\n--- a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n+++ b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n@@ -21,7 +21,6 @@ import static com.google.common.truth.Truth.assertThat;\n \n import android.app.Activity;\n import android.app.settings.SettingsEnums;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n import android.content.pm.ResolveInfo;\n@@ -126,20 +125,22 @@ public class SearchFeatureProviderImplTest {\n \n     @Test(expected = SecurityException.class)\n     public void verifyLaunchSearchResultPageCaller_badCaller_shouldCrash() {\n-        final ComponentName cn = new ComponentName(\"pkg\", \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = \"pkg\";\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsCaller_shouldNotCrash() {\n-        final ComponentName cn = new ComponentName(mActivity.getPackageName(), \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = mActivity.getPackageName();\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsIntelligenceCaller_shouldNotCrash() {\n         final String packageName = mProvider.getSettingsIntelligencePkgName(mActivity);\n-        final ComponentName cn = new ComponentName(packageName, \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n }\n",
        "downstream_patch_tokens": {
          "openai": 1401,
          "general": {
            "word_based": 586,
            "char_based": 1633
          },
          "gemini": 1801
        },
        "file_conflicts": [
          {
            "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
            "total_hunks": 0,
            "failed_hunks": [],
            "inline_merge_conflicts": [],
            "inline_merge_token_summary": {
              "gemini": 0,
              "openai": 0,
              "general_word": 0,
              "general_char": 0
            },
            "rej_file_content": "```diff\n--- src/com/android/settings/search/SearchResultTrampoline.java\n+++ src/com/android/settings/search/SearchResultTrampoline.java\n@@ -21,7 +21,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n import static com.android.settings.activityembedding.EmbeddedDeepLinkUtils.getTrampolineIntent;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.net.Uri;\n import android.os.Bundle;\n@@ -53,11 +52,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -106,7 +105,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -139,9 +138,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\n```",
            "rej_file_tokens": {
              "openai": 465,
              "general": {
                "word_based": 194,
                "char_based": 623
              },
              "gemini": 578
            },
            "patch_apply_output": "patching file src/com/android/settings/search/SearchFeatureProvider.java\nHunk #1 succeeded at 51 (offset -5 lines).\npatching file src/com/android/settings/search/SearchFeatureProviderImpl.java\npatching file src/com/android/settings/search/SearchResultTrampoline.java\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n4 out of 4 hunks ignored -- saving rejects to file src/com/android/settings/search/SearchResultTrampoline.java.rej",
            "inline_merge_output": "patching file src/com/android/settings/search/SearchResultTrampoline.java\nHunk #1 already applied at 24.\nHunk #2 already applied at 55,59.\nHunk #3 already applied at 108.\nHunk #4 already applied at 141-143.",
            "upstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\nimport static com.android.settings.activityembedding.EmbeddedDeepLinkUtils.getTrampolineIntent;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.FeatureFlagUtils;\nimport android.util.Log;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsApplication;\nimport com.android.settings.SubSettings;\nimport com.android.settings.activityembedding.ActivityEmbeddingRulesController;\nimport com.android.settings.activityembedding.ActivityEmbeddingUtils;\nimport com.android.settings.core.FeatureFlags;\nimport com.android.settings.homepage.DeepLinkHomepageActivityInternal;\nimport com.android.settings.homepage.SettingsHomepageActivity;\nimport com.android.settings.overlay.FeatureFactory;\n\nimport java.net.URISyntaxException;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    private static final String TAG = \"SearchResultTrampoline\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final String callerPackage = getLaunchedFromPackage();\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFeatureFactory()\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n        // Didn't crash, proceed and launch the result as a subsetting.\n        Intent intent = getIntent();\n        final String highlightMenuKey = intent.getStringExtra(\n                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);\n\n        final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);\n        if (!TextUtils.isEmpty(fragment)) {\n            // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n            // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from\n            // external caller and args may not persisted.\n            final String settingKey = intent.getStringExtra(\n                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n            final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n            final Bundle args = new Bundle();\n            args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n            args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n            intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n            // Reroute request to SubSetting.\n            intent.setClass(this /* context */, SubSettings.class);\n        } else {\n            // Direct link case\n            final String intentUriString = intent.getStringExtra(\n                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);\n            if (TextUtils.isEmpty(intentUriString)) {\n                Log.e(TAG, \"No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link\");\n                finish();\n                return;\n            }\n\n            final Uri data = intent.getParcelableExtra(\n                    SettingsHomepageActivity.EXTRA_SETTINGS_LARGE_SCREEN_DEEP_LINK_INTENT_DATA,\n                    Uri.class);\n            try {\n                intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);\n                intent.setData(data);\n            } catch (URISyntaxException e) {\n                Log.e(TAG, \"Failed to parse deep link intent: \" + e);\n                finish();\n                return;\n            }\n        }\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n\n        if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n            startActivity(intent);\n        } else if (isSettingsIntelligence(callerPackage)) {\n            if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                startActivity(getTrampolineIntent(intent, highlightMenuKey)\n                        .setClass(this, DeepLinkHomepageActivityInternal.class)\n                        .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                                | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS));\n            } else {\n                // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected\n                // back navigation behavior.\n                ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n                        false /* clearTop */);\n\n                intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);\n                startActivity(intent);\n\n                // Pass menu key to homepage\n                final SettingsHomepageActivity homeActivity =\n                        ((SettingsApplication) getApplicationContext()).getHomeActivity();\n                if (homeActivity != null) {\n                    homeActivity.getMainFragment().setHighlightMenuKey(highlightMenuKey,\n                            /* scrollNeeded= */ true);\n                }\n            }\n        } else {\n            // Two-pane case\n            startActivity(getTrampolineIntent(intent, highlightMenuKey)\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));\n        }\n\n        // Done.\n        finish();\n    }\n\n    private boolean isSettingsIntelligence(String callerPackage) {\n        return TextUtils.equals(\n                callerPackage,\n                FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                        .getSettingsIntelligencePkgName(this));\n    }\n}\n```",
            "upstream_file_tokens": {
              "openai": 1137,
              "general": {
                "word_based": 526,
                "char_based": 1616
              },
              "gemini": 1451
            },
            "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SubSettings;\nimport com.android.settings.overlay.FeatureFactory;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFactory(this)\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, getCallingActivity());\n        // Didn't crash, proceed and launch the result as a subsetting.\n        final Intent intent = getIntent();\n\n        // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n        // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from external\n        // caller and args may not persisted.\n        final String settingKey = intent.getStringExtra(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n        final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n        final Bundle args = new Bundle();\n        args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n        args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n        intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n        // Reroute request to SubSetting.\n        intent.setClass(this /* context */, SubSettings.class)\n                .addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n        startActivity(intent);\n\n        // Done.\n        finish();\n    }\n\n}\n```",
            "downstream_file_tokens": {
              "openai": 472,
              "general": {
                "word_based": 271,
                "char_based": 628
              },
              "gemini": 602
            },
            "downstream_file_content_ground_truth": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SubSettings;\nimport com.android.settings.overlay.FeatureFactory;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFactory(this)\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, getLaunchedFromPackage());\n        // Didn't crash, proceed and launch the result as a subsetting.\n        final Intent intent = getIntent();\n\n        // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n        // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from external\n        // caller and args may not persisted.\n        final String settingKey = intent.getStringExtra(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n        final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n        final Bundle args = new Bundle();\n        args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n        args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n        intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n        // Reroute request to SubSetting.\n        intent.setClass(this /* context */, SubSettings.class)\n                .addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n        startActivity(intent);\n\n        // Done.\n        finish();\n    }\n\n}",
            "downstream_file_ground_truth_tokens": {
              "openai": 474,
              "general": {
                "word_based": 271,
                "char_based": 629
              },
              "gemini": 603
            },
            "downstream_file_content_patched_upstream_only": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SubSettings;\nimport com.android.settings.overlay.FeatureFactory;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFactory(this)\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, getCallingActivity());\n        // Didn't crash, proceed and launch the result as a subsetting.\n        final Intent intent = getIntent();\n\n        // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n        // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from external\n        // caller and args may not persisted.\n        final String settingKey = intent.getStringExtra(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n        final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n        final Bundle args = new Bundle();\n        args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n        args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n        intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n        // Reroute request to SubSetting.\n        intent.setClass(this /* context */, SubSettings.class)\n                .addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n        startActivity(intent);\n\n        // Done.\n        finish();\n    }\n\n}\n```",
            "diff_patched_upstream_only": "--- original_downstream_file\n+++ patched_upstream_only\n@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2017 The Android Open Source Project\n  *\n@@ -63,5 +62,4 @@\n         finish();\n     }\n \n-}\n-```+}",
            "downstream_llm_diff_output": null,
            "runtime_seconds": 551.75,
            "llm_output_valid": false,
            "attempts_made": 3,
            "validation_results": [
              {
                "attempt": 1,
                "format_valid": true,
                "format_error": "Valid patch format",
                "apply_valid": false,
                "apply_error": "Patch failed in repo: checking file src/com/android/settings/search/SearchResultTrampoline.java\nHunk #1 FAILED at 17.\n1 out of 1 hunk FAILED\npatch unexpectedly ends in middle of line",
                "valid": false,
                "runtime_seconds": 200.05
              },
              {
                "attempt": 2,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk is longer than expected",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 166.1
              },
              {
                "attempt": 3,
                "format_valid": false,
                "format_error": "Invalid patch format: Unexpected hunk found: @@ -32,28 +35,47 @@\n",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 185.17
              }
            ],
            "error": "All validation attempts failed",
            "last_format_error": "Invalid patch format: Unexpected hunk found: @@ -32,28 +35,47 @@\n",
            "last_apply_error": "Skipped due to format error"
          }
        ]
      }
    ]
  },
  {
    "id": "ASB-A-353712853",
    "total_gemini_token_usage": 199220,
    "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-353712853",
    "severity": "High",
    "upstream_patch_content": "From 7c6ec68537ba8abf798afd9ab7c3e5889841171f Mon Sep 17 00:00:00 2001\nFrom: Ashish Kumar Gupta <kumarashishg@google.com>\nDate: Wed, 31 Jul 2024 16:02:29 +0000\nSubject: [PATCH] Set no data transfer on function switch timeout for accessory\n mode\n\nIn case of function switch times out, we will check whether\nthe last function set was accessory. If this is the case, it is\nrecommended to set the function to NONE(No data transfer) rather than\nsetting it to the default USB function.\n\nBug: 353712853\nTest: Build the code, flash the device and test it.\nTest: atest CtsUsbManagerTestCases\nTest: run CtsVerifier tool\nTest: atest CtsUsbTests\nChange-Id: I698e9df0333cbb51dd9bd5917a94d81273a2784a\n---\n .../com/android/server/usb/UsbDeviceManager.java    | 13 +++++++++----\n 1 file changed, 9 insertions(+), 4 deletions(-)\n\ndiff --git a/services/usb/java/com/android/server/usb/UsbDeviceManager.java b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\nindex 14044135eca7..6c1e1a428fb8 100644\n--- a/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -80,9 +80,9 @@ import android.os.storage.StorageVolume;\n import android.provider.Settings;\n import android.service.usb.UsbDeviceManagerProto;\n import android.service.usb.UsbHandlerProto;\n+import android.text.TextUtils;\n import android.util.Pair;\n import android.util.Slog;\n-import android.text.TextUtils;\n \n import com.android.internal.R;\n import com.android.internal.annotations.GuardedBy;\n@@ -880,7 +880,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit(int operationId) {\n+        protected void notifyAccessoryModeExit(int operationId) {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -2313,8 +2313,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      */\n                     operationId = sUsbOperationCount.incrementAndGet();\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit(operationId);\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:\n-- \n2.39.5 (Apple Git-154)\n\n",
    "upstream_commits": [
      "7c6ec68537ba8abf798afd9ab7c3e5889841171f"
    ],
    "upstream_patch_tokens": {
      "openai": 704,
      "general": {
        "word_based": 316,
        "char_based": 735
      },
      "gemini": 855
    },
    "failures": [
      {
        "downstream_version": "14",
        "gemini_token_usage": 50755,
        "branch_used": "android14-release",
        "downstream_patch": "37be5d18e529877fcd3c62063aec205a96660449",
        "repo_path": "android_repos/base",
        "result": "failure",
        "downstream_patch_content": "commit 37be5d18e529877fcd3c62063aec205a96660449\nAuthor: Ashish Kumar Gupta <kumarashishg@google.com>\nDate:   Wed Jul 31 16:02:29 2024 +0000\n\n    Set no data transfer on function switch timeout for accessory mode\n    \n    In case of function switch times out, we will check whether\n    the last function set was accessory. If this is the case, it is\n    recommended to set the function to NONE(No data transfer) rather than\n    setting it to the default USB function.\n    \n    Bug: 353712853\n    Test: Build the code, flash the device and test it.\n    Test: atest CtsUsbManagerTestCases\n    Test: run CtsVerifier tool\n    Test: atest CtsUsbTests\n    Change-Id: I698e9df0333cbb51dd9bd5917a94d81273a2784a\n    Merged-In: I698e9df0333cbb51dd9bd5917a94d81273a2784a\n    (cherry picked from commit 7c6ec68537ba8abf798afd9ab7c3e5889841171f)\n\ndiff --git a/services/usb/java/com/android/server/usb/UsbDeviceManager.java b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\nindex 77b263824b78..3d012f6eacc0 100644\n--- a/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -819,7 +819,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit(int operationId) {\n+        protected void notifyAccessoryModeExit(int operationId) {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -2145,8 +2145,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      */\n                     operationId = sUsbOperationCount.incrementAndGet();\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit(operationId);\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:\n",
        "downstream_patch_tokens": {
          "openai": 621,
          "general": {
            "word_based": 245,
            "char_based": 634
          },
          "gemini": 758
        },
        "file_conflicts": [
          {
            "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
            "total_hunks": 3,
            "failed_hunks": [
              1
            ],
            "inline_merge_conflicts": [],
            "inline_merge_token_summary": {
              "gemini": 0,
              "openai": 0,
              "general_word": 0,
              "general_char": 0
            },
            "rej_file_content": "```diff\n--- services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -80,9 +80,9 @@ import android.os.storage.StorageVolume;\n import android.provider.Settings;\n import android.service.usb.UsbDeviceManagerProto;\n import android.service.usb.UsbHandlerProto;\n+import android.text.TextUtils;\n import android.util.Pair;\n import android.util.Slog;\n-import android.text.TextUtils;\n \n import com.android.internal.R;\n import com.android.internal.annotations.GuardedBy;\n```",
            "rej_file_tokens": {
              "openai": 118,
              "general": {
                "word_based": 68,
                "char_based": 132
              },
              "gemini": 159
            },
            "patch_apply_output": "patching file services/usb/java/com/android/server/usb/UsbDeviceManager.java\nHunk #1 FAILED at 80.\nHunk #2 succeeded at 819 (offset -61 lines).\nHunk #3 succeeded at 2145 (offset -168 lines).\n1 out of 3 hunks FAILED -- saving rejects to file services/usb/java/com/android/server/usb/UsbDeviceManager.java.rej",
            "inline_merge_output": "patching file services/usb/java/com/android/server/usb/UsbDeviceManager.java\nHunk #1 already applied at 83,86.\nHunk #2 already applied at 883.\nHunk #3 merged at 2291-2297.",
            "upstream_file_content": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport com.android.internal.annotations.Keep;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.text.TextUtils;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.usb.flags.Flags;\nimport com.android.server.usb.hal.gadget.UsbGadgetHal;\nimport com.android.server.usb.hal.gadget.UsbGadgetHalInstance;\nimport com.android.server.utils.EventLogger;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    /**\n     *  UDC controller for the ConfigFS USB Gadgets.\n     */\n    private static final String USB_CONTROLLER_NAME_PROPERTY = \"sys.usb.controller\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String UDC_SUBSYS_MATCH =\n            \"SUBSYSTEM=udc\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final int DUMPSYS_LOG_BUFFER = 200;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    private static EventLogger sEventLogger;\n\n    private static UsbGadgetHal mUsbGadgetHal;\n\n    private final boolean mEnableUdcSysfsUsbStateUpdate;\n    private String mUdcName = \"\";\n\n    /**\n     * Counter for tracking UsbOperation operations.\n     */\n    private static final AtomicInteger sUsbOperationCount = new AtomicInteger();\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n            if (sEventLogger != null) {\n                sEventLogger.enqueue(new EventLogger.StringEvent(\"USB UEVENT: \"\n                        + event.toString()));\n            } else {\n                if (DEBUG) Slog.d(TAG, \"sEventLogger == null\");\n            }\n\n            String accessory = event.get(\"ACCESSORY\");\n\n            if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                mHandler.setAccessoryUEventTime(SystemClock.elapsedRealtime());\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n\n            if (mEnableUdcSysfsUsbStateUpdate) {\n                if (!mUdcName.isEmpty()\n                        && \"udc\".equals(event.get(\"SUBSYSTEM\"))\n                        && event.get(\"DEVPATH\").contains(mUdcName)) {\n                    String action = event.get(\"ACTION\");\n                    if (\"add\".equals(action)) {\n                        nativeStartGadgetMonitor(mUdcName);\n                    } else if (\"remove\".equals(action)) {\n                        nativeStopGadgetMonitor();\n                    }\n                }\n            } else {\n                String state = event.get(\"USB_STATE\");\n                if (state != null) {\n                    mHandler.updateState(state);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n        boolean halNotPresent = false;\n\n        mUsbGadgetHal = UsbGadgetHalInstance.getInstance(this, null);\n        Slog.d(TAG, \"getInstance done\");\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (mUsbGadgetHal == null) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        mHandler.handlerInitDone(operationId);\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT, android.hardware.usb.ParcelableUsbPort.class);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS, android.hardware.usb.UsbPortStatus.class);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n\n        mEnableUdcSysfsUsbStateUpdate =\n                android.hardware.usb.flags.Flags.enableUdcSysfsUsbStateUpdate()\n                && context.getResources().getBoolean(R.bool.config_enableUdcSysfsUsbStateUpdate);\n\n        if (mEnableUdcSysfsUsbStateUpdate) {\n            mUEventObserver.startObserving(UDC_SUBSYS_MATCH);\n            new Thread(\"GetUsbControllerSysprop\") {\n                public void run() {\n                    String udcName;\n                    // blocking wait until usb controller sysprop is available\n                    udcName = nativeWaitAndGetProperty(USB_CONTROLLER_NAME_PROPERTY);\n                    nativeStartGadgetMonitor(udcName);\n                    mUdcName = udcName;\n                    Slog.v(TAG, \"USB controller name \" + udcName);\n                }\n            }.start();\n        } else {\n            mUEventObserver.startObserving(USB_STATE_MATCH);\n        }\n\n        sEventLogger = new EventLogger(DUMPSYS_LOG_BUFFER, \"UsbDeviceManager activity\");\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions, operationId);\n        }\n    }\n\n    //TODO It is not clear that this method serves any purpose (at least on Pixel devices)\n    // consider removing\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.i(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    public static void logAndPrint(int priority, IndentingPrintWriter pw, String msg) {\n        Slog.println(priority, TAG, msg);\n        if (pw != null) {\n            pw.println(msg);\n        }\n    }\n\n    public static void logAndPrintException(IndentingPrintWriter pw, String msg, Exception e) {\n        Slog.e(TAG, msg, e);\n        if (pw != null) {\n            pw.println(msg + e);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mUsbAccessoryConnected;\n        private boolean mInHostModeWithNoAccessoryConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n        private boolean mConnectedToDataDisabledPort;\n        private int mPowerBrickConnectionStatus;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        /**\n         * Do not debounce for the first disconnect after resetUsbGadget.\n         */\n        protected boolean mResetUsbGadgetDisableDebounce;\n        protected boolean mConnected;\n        protected boolean mConfigured;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n        protected boolean mPendingBootAccessoryHandshakeBroadcast;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        protected static final String MTP_PACKAGE_NAME = \"com.android.mtp\";\n        protected static final String MTP_SERVICE_CLASS_NAME = \"com.android.mtp.MtpService\";\n\n        private boolean mIsMtpServiceBound = false;\n\n        /**\n         * {@link ServiceConnection} for {@link MtpService}.\n         */\n        private ServiceConnection mMtpServiceConnection = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName className, IBinder service) {}\n\n            @Override\n            public void onServiceDisconnected(ComponentName arg0) {}\n        };\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public boolean sendMessage(int what) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            return sendMessageDelayed(m,0);\n        }\n\n        public void sendMessage(int what, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, long arg, boolean arg1, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            if (DEBUG) {\n                Slog.i(TAG, \"mResetUsbGadgetDisableDebounce:\" + mResetUsbGadgetDisableDebounce\n                       + \" connected:\" + connected + \"configured:\" + configured);\n            }\n            if (mResetUsbGadgetDisableDebounce) {\n                // Do not debounce disconnect after resetUsbGadget.\n                sendMessage(msg);\n                if (connected == 1) mResetUsbGadgetDisableDebounce = false;\n            } else {\n                if (configured == 0) {\n                    removeMessages(MSG_UPDATE_STATE);\n                    if (DEBUG) Slog.i(TAG, \"removeMessages MSG_UPDATE_STATE\");\n                }\n                if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n                // debounce disconnects to avoid problems bringing up USB tethering.\n                sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n            }\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable, int operationId) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true, operationId);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            int operationId = sUsbOperationCount.incrementAndGet();\n\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit(operationId);\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        protected void notifyAccessoryModeExit(int operationId) {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                        | Intent.FLAG_RECEIVER_FOREGROUND)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            SystemClock.elapsedRealtime());\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n            sEventLogger.enqueue(new EventLogger.StringEvent(\"USB intent: \" + intent));\n        }\n\n        private void getMidiCardDevice() throws FileNotFoundException {\n            String controllerName =  getSystemProperty(USB_CONTROLLER_NAME_PROPERTY, \"\");\n            if (TextUtils.isEmpty(controllerName)) {\n                throw new FileNotFoundException(\"controller name not found\");\n            }\n\n            File soundDir = new File(\"/sys/class/udc/\" + controllerName + \"/gadget/sound\");\n            if (!soundDir.exists()) {\n                throw new FileNotFoundException(\"sound device not found\");\n            }\n\n            // There should be exactly one sound card\n            File[] cardDirs = FileUtils.listFilesOrEmpty(soundDir,\n                                                         (dir, file) -> file.startsWith(\"card\"));\n            if (cardDirs.length != 1) {\n                throw new FileNotFoundException(\"sound card not match\");\n            }\n\n            // There should be exactly one midi device\n            File[] midis = FileUtils.listFilesOrEmpty(cardDirs[0],\n                                                      (dir, file) -> file.startsWith(\"midi\"));\n            if (midis.length != 1) {\n                throw new FileNotFoundException(\"MIDI device not match\");\n            }\n\n            Pattern pattern = Pattern.compile(\"midiC(\\\\d+)D(\\\\d+)\");\n            Matcher matcher = pattern.matcher(midis[0].getName());\n            if (matcher.matches()) {\n                mMidiCard = Integer.parseInt(matcher.group(1));\n                mMidiDevice = Integer.parseInt(matcher.group(2));\n                Slog.i(TAG, \"Found MIDI card \" + mMidiCard + \" device \" + mMidiDevice);\n            } else {\n                throw new FileNotFoundException(\"MIDI name not match\");\n            }\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n            updateMtpFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    if (android.hardware.usb.flags.Flags.enableUsbSysfsMidiIdentification()) {\n                        try {\n                            getMidiCardDevice();\n                        } catch (FileNotFoundException e) {\n                            Slog.e(TAG, \"could not identify MIDI device\", e);\n                            enabled = false;\n                        }\n                    } else {\n                        Scanner scanner = null;\n                        try {\n                            scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                            mMidiCard = scanner.nextInt();\n                            mMidiDevice = scanner.nextInt();\n                        } catch (FileNotFoundException e) {\n                            Slog.e(TAG, \"could not open MIDI file\", e);\n                            enabled = false;\n                        } finally {\n                            if (scanner != null) {\n                                scanner.close();\n                            }\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        /**\n         * Bind to MtpService when MTP or PTP is enabled. This is done to prevent activity manager\n         * from freezing the corresponding process.\n         */\n        private void updateMtpFunction() {\n            if (!Flags.enableBindToMtpService()) {\n                return;\n            }\n\n            boolean mtpEnabled = ((mCurrentFunctions & UsbManager.FUNCTION_MTP) != 0);\n            boolean ptpEnabled = ((mCurrentFunctions & UsbManager.FUNCTION_PTP) != 0);\n\n            if (DEBUG) {\n                Slog.d(TAG, \"updateMtpFunction \"\n                        + \", mtpEnabled: \" + mtpEnabled\n                        + \", ptpEnabled: \" + ptpEnabled\n                        + \", mIsMtpServiceBound: \" + mIsMtpServiceBound\n                );\n            }\n\n            if (mConfigured && (mtpEnabled || ptpEnabled)) {\n                bindToMtpService();\n            } else if (mIsMtpServiceBound) {\n                unbindMtpService();\n            }\n        }\n\n        private void bindToMtpService() {\n            Intent intent = new Intent();\n            intent.setComponent(new ComponentName(MTP_PACKAGE_NAME, MTP_SERVICE_CLASS_NAME));\n\n            if (DEBUG) Slog.d(TAG, \"Binding to MtpService\");\n\n            try {\n                mIsMtpServiceBound = mContext.bindServiceAsUser(\n                    intent,\n                    mMtpServiceConnection,\n                    Context.BIND_AUTO_CREATE,\n                    UserHandle.CURRENT\n                );\n            } catch (SecurityException exception) {\n                Slog.e(TAG, \"Unable to bind to MtpService due to SecurityException\", exception);\n            }\n\n            // Unbinding from the service if binding was not successful to release the connection.\n            // https://developer.android.com/reference/android/content/Context#bindService(android.content.Intent,%20android.content.ServiceConnection,%20int)\n            if (!mIsMtpServiceBound) {\n                unbindMtpService();\n                Slog.e(TAG, \"Binding to MtpService failed\");\n            }\n\n            if (DEBUG && mIsMtpServiceBound) Slog.d(TAG, \"Successfully bound to MtpService\");\n        }\n\n        private void unbindMtpService() {\n            if (DEBUG) Slog.d(TAG, \"Unbinding from MtpService\");\n\n            mContext.unbindService(mMtpServiceConnection);\n            mIsMtpServiceBound = false;\n        }\n\n        private void setScreenUnlockedFunctions(int operationId) {\n            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"handleMessage MSG_UPDATE_STATE \" + \"mConnected:\" + mConnected\n                               + \" mConfigured:\" + mConfigured);\n                    }\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions(operationId);\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n\n                        boolean usbDataDisabled =\n                                status.getUsbDataStatus() != UsbPortStatus.DATA_STATUS_ENABLED;\n                        mConnectedToDataDisabledPort = status.isConnected() && usbDataDisabled;\n                        mPowerBrickConnectionStatus = status.getPowerBrickConnectionStatus();\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                        mConnectedToDataDisabledPort = false;\n                        mPowerBrickConnectionStatus = UsbPortStatus.POWER_BRICK_STATUS_UNKNOWN;\n                    }\n\n                    if (mHostConnected) {\n                        if (!mUsbAccessoryConnected) {\n                            mInHostModeWithNoAccessoryConnected = true;\n                        } else {\n                            mInHostModeWithNoAccessoryConnected = false;\n                        }\n                    } else {\n                        // if not in host mode, reset value to false\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    mUsbAccessoryConnected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + mUsbAccessoryConnected);\n                    }\n\n                    if (!devices.hasNext()) {\n                        mInHostModeWithNoAccessoryConnected = true;\n                    } else {\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1, msg.arg2);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    operationId = (int) msg.arg1;\n                    setEnabledFunctions(functions, false, operationId);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions(operationId);\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions(operationId);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true, operationId);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mBootCompleted = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_USER_SWITCHED: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected\n                                    + \" ,operationId: \" + operationId);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit(operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    if (mBootCompleted) {\n                        broadcastUsbAccessoryHandshake();\n                    } else {\n                        if (DEBUG) Slog.v(TAG, \"Pending broadcasting intent as \"\n                                + \"not boot completed yet.\");\n                        mPendingBootAccessoryHandshakeBroadcast = true;\n                    }\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        public abstract void handlerInitDone(int operationId);\n\n        protected void finishBoot(int operationId) {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions(operationId);\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                } else if (mPendingBootAccessoryHandshakeBroadcast) {\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                mPendingBootAccessoryHandshakeBroadcast = false;\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if ((mHideUsbNotification || mInHostModeWithNoAccessoryConnected)\n                    && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_UVC) {\n                    titleRes = com.android.internal.R.string.usb_uvc_notification_title;\n                    id = SystemMessage.NOTE_USB_UVC;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && (mUsbCharging || mUsbAccessoryConnected)) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            } else if (mSinkPower && mConnectedToDataDisabledPort\n                    && mPowerBrickConnectionStatus != UsbPortStatus.POWER_BRICK_STATUS_CONNECTED) {\n                // Show charging notification when USB Data is disabled on the port, and not\n                // connected to a wall charger.\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions,\n                boolean forceRestart, int operationId);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n\n        public abstract void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions);\n\n        public abstract void getUsbSpeedCb(int speed);\n\n        public abstract void resetCb(int status);\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions,\n                boolean forceRestart, int operationId) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions +\n                        \" ,forceRestart=\" + forceRestart +\n                        \" ,usbDataUnlocked=\" + usbDataUnlocked +\n                        \" ,operationId=\" + operationId);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void getUsbSpeedCb(int speed){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void resetCb(int status){\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            int operationId = sUsbOperationCount.incrementAndGet();\n            try {\n\n                synchronized (mGadgetProxyLock) {\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    updateUsbGadgetHalVersion();\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mUsbGadgetHal = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\"\n                                + \" ,operationId:\" + operationId);\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.i(TAG, \"processing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n                    operationId = msg.arg2;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.i(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.i(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot(operationId);\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 != 1) {\n                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                            notifyAccessoryModeExit(operationId);\n                        } else {\n                            // Set this since default function may be selected from Developer\n                            // options\n                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                        }\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mUsbGadgetHal = UsbGadgetHalInstance.getInstance(mUsbDeviceManager,\n                                    null);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false, operationId);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        if (mUsbGadgetHal == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mUsbGadgetHal is null\");\n                            break;\n                        }\n\n                        try {\n                            // MSG_ACCESSORY_MODE_ENTER_TIMEOUT has to be removed to allow exiting\n                            // AOAP mode during resetUsbGadget.\n                            removeMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n                            if (mConfigured) {\n                                mResetUsbGadgetDisableDebounce = true;\n                            }\n                            mUsbGadgetHal.reset(operationId);\n                        } catch (Exception e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                            mResetUsbGadgetDisableDebounce = false;\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mGadgetHal is null, operationId:\" + operationId);\n                        break;\n                    }\n\n                    try {\n                        mUsbGadgetHal.getUsbSpeed(operationId);\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"get UsbSpeed failed\", e);\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mUsbGadgetHal is null\");\n                        break;\n                    }\n                    else {\n                        try {\n                            mCurrentGadgetHalVersion = mUsbGadgetHal.getGadgetHalVersion();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"update Usb gadget version failed\", e);\n                        }\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n\n            if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                  || (mFunctions != functions)) {\n                return;\n            }\n\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            Slog.i(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n            if (status == Status.SUCCESS) {\n                mCurrentFunctionsApplied = true;\n            } else if (!mChargingFunctions) {\n                Slog.e(TAG, \"Setting default fuctions\");\n                sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n            }\n        }\n\n        @Override\n        public void getUsbSpeedCb(int speed) {\n            mUsbSpeed = speed;\n        }\n\n        @Override\n        public void resetCb(int status) {\n            if (status != Status.SUCCESS)\n                Slog.e(TAG, \"resetCb fail\");\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions, int operationId) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mUsbGadgetHal == null) {\n                    Slog.e(TAG, \"setUsbConfig mUsbGadgetHal is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    mUsbGadgetHal.setCurrentUsbFunctions(mCurrentRequest,\n                            config, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS, operationId);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (Exception e) {//RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart, int operationId) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctionsi \" +\n                        \"functions=\" + functions +\n                        \", forceRestart=\" + forceRestart +\n                        \", operationId=\" + operationId);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions, operationId);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n            mUsbGadgetHal.getCurrentUsbFunctions(operationId);\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int pid, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, pid, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n        mHandler.setCurrentUsbFunctionsCb(functions, status,\n                    mRequest, mFunctions, mChargingFunctions);\n    }\n\n    public void getCurrentUsbFunctionsCb(long functions, int status) {\n        mHandler.sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                    status == Status.FUNCTIONS_APPLIED);\n    }\n\n    public void getUsbSpeedCb(int speed) {\n        mHandler.getUsbSpeedCb(speed);\n    }\n\n    public void resetCb(int status) {\n        mHandler.resetCb(status);\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions, int operationId) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        } else if (functions == UsbManager.FUNCTION_UVC) {\n            // MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_UVC);\n            // TODO: Add MetricsEvent for UVC?\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions, operationId);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        int operationId = sUsbOperationCount.incrementAndGet();\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n            sEventLogger.dump(new DualOutputStreamDumpSink(dump, UsbHandlerProto.UEVENT));\n        }\n\n        dump.end(token);\n    }\n\n    /**\n     * Update usb state (Called by native code).\n     */\n    @Keep\n    private void updateGadgetState(String state) {\n        Slog.d(TAG, \"Usb state update \" + state);\n\n        mHandler.updateState(state);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native String nativeWaitAndGetProperty(String propName);\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native boolean nativeStartGadgetMonitor(String udcName);\n\n    private native void nativeStopGadgetMonitor();\n}\n```",
            "upstream_file_tokens": {
              "openai": 21808,
              "general": {
                "word_based": 8151,
                "char_based": 29003
              },
              "gemini": 25756
            },
            "downstream_file_content": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.usb.hal.gadget.UsbGadgetHal;\nimport com.android.server.usb.hal.gadget.UsbGadgetHalInstance;\nimport com.android.server.utils.EventLogger;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String AUDIO_SOURCE_PCM_PATH =\n            \"/sys/class/android_usb/android0/f_audio_source/pcm\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    private static final int AUDIO_MODE_SOURCE = 1;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final int DUMPSYS_LOG_BUFFER = 200;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    private static EventLogger sEventLogger;\n\n    private static UsbGadgetHal mUsbGadgetHal;\n\n    /**\n     * Counter for tracking UsbOperation operations.\n     */\n    private static final AtomicInteger sUsbOperationCount = new AtomicInteger();\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n            if (sEventLogger != null) {\n                sEventLogger.enqueue(new EventLogger.StringEvent(\"USB UEVENT: \"\n                        + event.toString()));\n            } else {\n                if (DEBUG) Slog.d(TAG, \"sEventLogger == null\");\n            }\n\n            String state = event.get(\"USB_STATE\");\n            String accessory = event.get(\"ACCESSORY\");\n\n            if (state != null) {\n                mHandler.updateState(state);\n            } else if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                mHandler.setAccessoryUEventTime(SystemClock.elapsedRealtime());\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n        boolean halNotPresent = false;\n\n        mUsbGadgetHal = UsbGadgetHalInstance.getInstance(this, null);\n        Slog.d(TAG, \"getInstance done\");\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (mUsbGadgetHal == null) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        mHandler.handlerInitDone(operationId);\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT, android.hardware.usb.ParcelableUsbPort.class);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS, android.hardware.usb.UsbPortStatus.class);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(USB_STATE_MATCH);\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n\n        sEventLogger = new EventLogger(DUMPSYS_LOG_BUFFER, \"UsbDeviceManager activity\");\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        boolean enableAudio = (nativeGetAudioMode() == AUDIO_MODE_SOURCE);\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n        if (enableAudio) {\n            functions |= UsbManager.FUNCTION_AUDIO_SOURCE;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions, operationId);\n        }\n    }\n\n    //TODO It is not clear that this method serves any purpose (at least on Pixel devices)\n    // consider removing\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.i(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    public static void logAndPrint(int priority, IndentingPrintWriter pw, String msg) {\n        Slog.println(priority, TAG, msg);\n        if (pw != null) {\n            pw.println(msg);\n        }\n    }\n\n    public static void logAndPrintException(IndentingPrintWriter pw, String msg, Exception e) {\n        Slog.e(TAG, msg, e);\n        if (pw != null) {\n            pw.println(msg + e);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mUsbAccessoryConnected;\n        private boolean mInHostModeWithNoAccessoryConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n        private boolean mConnectedToDataDisabledPort;\n        private int mPowerBrickConnectionStatus;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        /**\n         * Do not debounce for the first disconnect after resetUsbGadget.\n         */\n        protected boolean mResetUsbGadgetDisableDebounce;\n        protected boolean mConnected;\n        protected boolean mConfigured;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n        protected boolean mPendingBootAccessoryHandshakeBroadcast;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public boolean sendMessage(int what) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            return sendMessageDelayed(m,0);\n        }\n\n        public void sendMessage(int what, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, long arg, boolean arg1, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            if (DEBUG) {\n                Slog.i(TAG, \"mResetUsbGadgetDisableDebounce:\" + mResetUsbGadgetDisableDebounce\n                       + \" connected:\" + connected + \"configured:\" + configured);\n            }\n            if (mResetUsbGadgetDisableDebounce) {\n                // Do not debounce disconnect after resetUsbGadget.\n                sendMessage(msg);\n                if (connected == 1) mResetUsbGadgetDisableDebounce = false;\n            } else {\n                if (configured == 0) {\n                    removeMessages(MSG_UPDATE_STATE);\n                    if (DEBUG) Slog.i(TAG, \"removeMessages MSG_UPDATE_STATE\");\n                }\n                if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n                // debounce disconnects to avoid problems bringing up USB tethering.\n                sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n            }\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable, int operationId) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true, operationId);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            int operationId = sUsbOperationCount.incrementAndGet();\n\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit(operationId);\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        protected void notifyAccessoryModeExit(int operationId) {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                        | Intent.FLAG_RECEIVER_FOREGROUND)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            SystemClock.elapsedRealtime());\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n            sEventLogger.enqueue(new EventLogger.StringEvent(\"USB intent: \" + intent));\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    Scanner scanner = null;\n                    try {\n                        scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                        mMidiCard = scanner.nextInt();\n                        mMidiDevice = scanner.nextInt();\n                    } catch (FileNotFoundException e) {\n                        Slog.e(TAG, \"could not open MIDI file\", e);\n                        enabled = false;\n                    } finally {\n                        if (scanner != null) {\n                            scanner.close();\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        private void setScreenUnlockedFunctions(int operationId) {\n            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"handleMessage MSG_UPDATE_STATE \" + \"mConnected:\" + mConnected\n                               + \" mConfigured:\" + mConfigured);\n                    }\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions(operationId);\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n\n                        boolean usbDataDisabled =\n                                status.getUsbDataStatus() != UsbPortStatus.DATA_STATUS_ENABLED;\n                        mConnectedToDataDisabledPort = status.isConnected() && usbDataDisabled;\n                        mPowerBrickConnectionStatus = status.getPowerBrickConnectionStatus();\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                        mConnectedToDataDisabledPort = false;\n                        mPowerBrickConnectionStatus = UsbPortStatus.POWER_BRICK_STATUS_UNKNOWN;\n                    }\n\n                    if (mHostConnected) {\n                        if (!mUsbAccessoryConnected) {\n                            mInHostModeWithNoAccessoryConnected = true;\n                        } else {\n                            mInHostModeWithNoAccessoryConnected = false;\n                        }\n                    } else {\n                        // if not in host mode, reset value to false\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    mUsbAccessoryConnected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + mUsbAccessoryConnected);\n                    }\n\n                    if (!devices.hasNext()) {\n                        mInHostModeWithNoAccessoryConnected = true;\n                    } else {\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1, msg.arg2);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    operationId = (int) msg.arg1;\n                    setEnabledFunctions(functions, false, operationId);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions(operationId);\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions(operationId);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true, operationId);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mBootCompleted = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_USER_SWITCHED: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected\n                                    + \" ,operationId: \" + operationId);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit(operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    if (mBootCompleted) {\n                        broadcastUsbAccessoryHandshake();\n                    } else {\n                        if (DEBUG) Slog.v(TAG, \"Pending broadcasting intent as \"\n                                + \"not boot completed yet.\");\n                        mPendingBootAccessoryHandshakeBroadcast = true;\n                    }\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        public abstract void handlerInitDone(int operationId);\n\n        protected void finishBoot(int operationId) {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions(operationId);\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                } else if (mPendingBootAccessoryHandshakeBroadcast) {\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                mPendingBootAccessoryHandshakeBroadcast = false;\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if ((mHideUsbNotification || mInHostModeWithNoAccessoryConnected)\n                    && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_UVC) {\n                    titleRes = com.android.internal.R.string.usb_uvc_notification_title;\n                    id = SystemMessage.NOTE_USB_UVC;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && (mUsbCharging || mUsbAccessoryConnected)) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            } else if (mSinkPower && mConnectedToDataDisabledPort\n                    && mPowerBrickConnectionStatus != UsbPortStatus.POWER_BRICK_STATUS_CONNECTED) {\n                // Show charging notification when USB Data is disabled on the port, and not\n                // connected to a wall charger.\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions,\n                boolean forceRestart, int operationId);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n\n        public abstract void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions);\n\n        public abstract void getUsbSpeedCb(int speed);\n\n        public abstract void resetCb(int status);\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions,\n                boolean forceRestart, int operationId) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions +\n                        \" ,forceRestart=\" + forceRestart +\n                        \" ,usbDataUnlocked=\" + usbDataUnlocked +\n                        \" ,operationId=\" + operationId);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void getUsbSpeedCb(int speed){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void resetCb(int status){\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            int operationId = sUsbOperationCount.incrementAndGet();\n            try {\n\n                synchronized (mGadgetProxyLock) {\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    updateUsbGadgetHalVersion();\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mUsbGadgetHal = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\"\n                                + \" ,operationId:\" + operationId);\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.i(TAG, \"processing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n                    operationId = msg.arg2;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.i(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.i(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot(operationId);\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 != 1) {\n                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                            notifyAccessoryModeExit(operationId);\n                        } else {\n                            // Set this since default function may be selected from Developer\n                            // options\n                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                        }\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mUsbGadgetHal = UsbGadgetHalInstance.getInstance(mUsbDeviceManager,\n                                    null);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false, operationId);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        if (mUsbGadgetHal == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mUsbGadgetHal is null\");\n                            break;\n                        }\n\n                        try {\n                            // MSG_ACCESSORY_MODE_ENTER_TIMEOUT has to be removed to allow exiting\n                            // AOAP mode during resetUsbGadget.\n                            removeMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n                            if (mConfigured) {\n                                mResetUsbGadgetDisableDebounce = true;\n                            }\n                            mUsbGadgetHal.reset(operationId);\n                        } catch (Exception e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                            mResetUsbGadgetDisableDebounce = false;\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mGadgetHal is null, operationId:\" + operationId);\n                        break;\n                    }\n\n                    try {\n                        mUsbGadgetHal.getUsbSpeed(operationId);\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"get UsbSpeed failed\", e);\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mUsbGadgetHal is null\");\n                        break;\n                    }\n                    else {\n                        try {\n                            mCurrentGadgetHalVersion = mUsbGadgetHal.getGadgetHalVersion();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"update Usb gadget version failed\", e);\n                        }\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n\n            if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                  || (mFunctions != functions)) {\n                return;\n            }\n\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            Slog.i(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n            if (status == Status.SUCCESS) {\n                mCurrentFunctionsApplied = true;\n            } else if (!mChargingFunctions) {\n                Slog.e(TAG, \"Setting default fuctions\");\n                sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n            }\n        }\n\n        @Override\n        public void getUsbSpeedCb(int speed) {\n            mUsbSpeed = speed;\n        }\n\n        @Override\n        public void resetCb(int status) {\n            if (status != Status.SUCCESS)\n                Slog.e(TAG, \"resetCb fail\");\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions, int operationId) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mUsbGadgetHal == null) {\n                    Slog.e(TAG, \"setUsbConfig mUsbGadgetHal is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    mUsbGadgetHal.setCurrentUsbFunctions(mCurrentRequest,\n                            config, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS, operationId);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (Exception e) {//RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart, int operationId) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctionsi \" +\n                        \"functions=\" + functions +\n                        \", forceRestart=\" + forceRestart +\n                        \", operationId=\" + operationId);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions, operationId);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n            mUsbGadgetHal.getCurrentUsbFunctions(operationId);\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int pid, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, pid, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n        mHandler.setCurrentUsbFunctionsCb(functions, status,\n                    mRequest, mFunctions, mChargingFunctions);\n    }\n\n    public void getCurrentUsbFunctionsCb(long functions, int status) {\n        mHandler.sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                    status == Status.FUNCTIONS_APPLIED);\n    }\n\n    public void getUsbSpeedCb(int speed) {\n        mHandler.getUsbSpeedCb(speed);\n    }\n\n    public void resetCb(int status) {\n        mHandler.resetCb(status);\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions, int operationId) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        } else if (functions == UsbManager.FUNCTION_UVC) {\n            // MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_UVC);\n            // TODO: Add MetricsEvent for UVC?\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions, operationId);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        int operationId = sUsbOperationCount.incrementAndGet();\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n            sEventLogger.dump(new DualOutputStreamDumpSink(dump, UsbHandlerProto.UEVENT));\n        }\n\n        dump.end(token);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native int nativeGetAudioMode();\n}\n```",
            "downstream_file_tokens": {
              "openai": 20371,
              "general": {
                "word_based": 7605,
                "char_based": 27177
              },
              "gemini": 24082
            },
            "downstream_file_content_ground_truth": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.usb.hal.gadget.UsbGadgetHal;\nimport com.android.server.usb.hal.gadget.UsbGadgetHalInstance;\nimport com.android.server.utils.EventLogger;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String AUDIO_SOURCE_PCM_PATH =\n            \"/sys/class/android_usb/android0/f_audio_source/pcm\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    private static final int AUDIO_MODE_SOURCE = 1;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final int DUMPSYS_LOG_BUFFER = 200;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    private static EventLogger sEventLogger;\n\n    private static UsbGadgetHal mUsbGadgetHal;\n\n    /**\n     * Counter for tracking UsbOperation operations.\n     */\n    private static final AtomicInteger sUsbOperationCount = new AtomicInteger();\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n            if (sEventLogger != null) {\n                sEventLogger.enqueue(new EventLogger.StringEvent(\"USB UEVENT: \"\n                        + event.toString()));\n            } else {\n                if (DEBUG) Slog.d(TAG, \"sEventLogger == null\");\n            }\n\n            String state = event.get(\"USB_STATE\");\n            String accessory = event.get(\"ACCESSORY\");\n\n            if (state != null) {\n                mHandler.updateState(state);\n            } else if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                mHandler.setAccessoryUEventTime(SystemClock.elapsedRealtime());\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n        boolean halNotPresent = false;\n\n        mUsbGadgetHal = UsbGadgetHalInstance.getInstance(this, null);\n        Slog.d(TAG, \"getInstance done\");\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (mUsbGadgetHal == null) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        mHandler.handlerInitDone(operationId);\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT, android.hardware.usb.ParcelableUsbPort.class);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS, android.hardware.usb.UsbPortStatus.class);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(USB_STATE_MATCH);\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n\n        sEventLogger = new EventLogger(DUMPSYS_LOG_BUFFER, \"UsbDeviceManager activity\");\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        boolean enableAudio = (nativeGetAudioMode() == AUDIO_MODE_SOURCE);\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n        if (enableAudio) {\n            functions |= UsbManager.FUNCTION_AUDIO_SOURCE;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions, operationId);\n        }\n    }\n\n    //TODO It is not clear that this method serves any purpose (at least on Pixel devices)\n    // consider removing\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.i(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    public static void logAndPrint(int priority, IndentingPrintWriter pw, String msg) {\n        Slog.println(priority, TAG, msg);\n        if (pw != null) {\n            pw.println(msg);\n        }\n    }\n\n    public static void logAndPrintException(IndentingPrintWriter pw, String msg, Exception e) {\n        Slog.e(TAG, msg, e);\n        if (pw != null) {\n            pw.println(msg + e);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mUsbAccessoryConnected;\n        private boolean mInHostModeWithNoAccessoryConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n        private boolean mConnectedToDataDisabledPort;\n        private int mPowerBrickConnectionStatus;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        /**\n         * Do not debounce for the first disconnect after resetUsbGadget.\n         */\n        protected boolean mResetUsbGadgetDisableDebounce;\n        protected boolean mConnected;\n        protected boolean mConfigured;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n        protected boolean mPendingBootAccessoryHandshakeBroadcast;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public boolean sendMessage(int what) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            return sendMessageDelayed(m,0);\n        }\n\n        public void sendMessage(int what, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, long arg, boolean arg1, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            if (DEBUG) {\n                Slog.i(TAG, \"mResetUsbGadgetDisableDebounce:\" + mResetUsbGadgetDisableDebounce\n                       + \" connected:\" + connected + \"configured:\" + configured);\n            }\n            if (mResetUsbGadgetDisableDebounce) {\n                // Do not debounce disconnect after resetUsbGadget.\n                sendMessage(msg);\n                if (connected == 1) mResetUsbGadgetDisableDebounce = false;\n            } else {\n                if (configured == 0) {\n                    removeMessages(MSG_UPDATE_STATE);\n                    if (DEBUG) Slog.i(TAG, \"removeMessages MSG_UPDATE_STATE\");\n                }\n                if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n                // debounce disconnects to avoid problems bringing up USB tethering.\n                sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n            }\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable, int operationId) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true, operationId);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            int operationId = sUsbOperationCount.incrementAndGet();\n\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit(operationId);\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        protected void notifyAccessoryModeExit(int operationId) {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                        | Intent.FLAG_RECEIVER_FOREGROUND)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            SystemClock.elapsedRealtime());\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n            sEventLogger.enqueue(new EventLogger.StringEvent(\"USB intent: \" + intent));\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    Scanner scanner = null;\n                    try {\n                        scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                        mMidiCard = scanner.nextInt();\n                        mMidiDevice = scanner.nextInt();\n                    } catch (FileNotFoundException e) {\n                        Slog.e(TAG, \"could not open MIDI file\", e);\n                        enabled = false;\n                    } finally {\n                        if (scanner != null) {\n                            scanner.close();\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        private void setScreenUnlockedFunctions(int operationId) {\n            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"handleMessage MSG_UPDATE_STATE \" + \"mConnected:\" + mConnected\n                               + \" mConfigured:\" + mConfigured);\n                    }\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions(operationId);\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n\n                        boolean usbDataDisabled =\n                                status.getUsbDataStatus() != UsbPortStatus.DATA_STATUS_ENABLED;\n                        mConnectedToDataDisabledPort = status.isConnected() && usbDataDisabled;\n                        mPowerBrickConnectionStatus = status.getPowerBrickConnectionStatus();\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                        mConnectedToDataDisabledPort = false;\n                        mPowerBrickConnectionStatus = UsbPortStatus.POWER_BRICK_STATUS_UNKNOWN;\n                    }\n\n                    if (mHostConnected) {\n                        if (!mUsbAccessoryConnected) {\n                            mInHostModeWithNoAccessoryConnected = true;\n                        } else {\n                            mInHostModeWithNoAccessoryConnected = false;\n                        }\n                    } else {\n                        // if not in host mode, reset value to false\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    mUsbAccessoryConnected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + mUsbAccessoryConnected);\n                    }\n\n                    if (!devices.hasNext()) {\n                        mInHostModeWithNoAccessoryConnected = true;\n                    } else {\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1, msg.arg2);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    operationId = (int) msg.arg1;\n                    setEnabledFunctions(functions, false, operationId);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions(operationId);\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions(operationId);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true, operationId);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mBootCompleted = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_USER_SWITCHED: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected\n                                    + \" ,operationId: \" + operationId);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit(operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    if (mBootCompleted) {\n                        broadcastUsbAccessoryHandshake();\n                    } else {\n                        if (DEBUG) Slog.v(TAG, \"Pending broadcasting intent as \"\n                                + \"not boot completed yet.\");\n                        mPendingBootAccessoryHandshakeBroadcast = true;\n                    }\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        public abstract void handlerInitDone(int operationId);\n\n        protected void finishBoot(int operationId) {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions(operationId);\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                } else if (mPendingBootAccessoryHandshakeBroadcast) {\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                mPendingBootAccessoryHandshakeBroadcast = false;\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if ((mHideUsbNotification || mInHostModeWithNoAccessoryConnected)\n                    && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_UVC) {\n                    titleRes = com.android.internal.R.string.usb_uvc_notification_title;\n                    id = SystemMessage.NOTE_USB_UVC;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && (mUsbCharging || mUsbAccessoryConnected)) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            } else if (mSinkPower && mConnectedToDataDisabledPort\n                    && mPowerBrickConnectionStatus != UsbPortStatus.POWER_BRICK_STATUS_CONNECTED) {\n                // Show charging notification when USB Data is disabled on the port, and not\n                // connected to a wall charger.\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions,\n                boolean forceRestart, int operationId);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n\n        public abstract void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions);\n\n        public abstract void getUsbSpeedCb(int speed);\n\n        public abstract void resetCb(int status);\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions,\n                boolean forceRestart, int operationId) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions +\n                        \" ,forceRestart=\" + forceRestart +\n                        \" ,usbDataUnlocked=\" + usbDataUnlocked +\n                        \" ,operationId=\" + operationId);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void getUsbSpeedCb(int speed){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void resetCb(int status){\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            int operationId = sUsbOperationCount.incrementAndGet();\n            try {\n\n                synchronized (mGadgetProxyLock) {\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    updateUsbGadgetHalVersion();\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mUsbGadgetHal = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\"\n                                + \" ,operationId:\" + operationId);\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.i(TAG, \"processing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n                    operationId = msg.arg2;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.i(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.i(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot(operationId);\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 != 1) {\n                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                            notifyAccessoryModeExit(operationId);\n                        } else {\n                            // Set this since default function may be selected from Developer\n                            // options\n                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                        }\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mUsbGadgetHal = UsbGadgetHalInstance.getInstance(mUsbDeviceManager,\n                                    null);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false, operationId);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        if (mUsbGadgetHal == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mUsbGadgetHal is null\");\n                            break;\n                        }\n\n                        try {\n                            // MSG_ACCESSORY_MODE_ENTER_TIMEOUT has to be removed to allow exiting\n                            // AOAP mode during resetUsbGadget.\n                            removeMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n                            if (mConfigured) {\n                                mResetUsbGadgetDisableDebounce = true;\n                            }\n                            mUsbGadgetHal.reset(operationId);\n                        } catch (Exception e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                            mResetUsbGadgetDisableDebounce = false;\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mGadgetHal is null, operationId:\" + operationId);\n                        break;\n                    }\n\n                    try {\n                        mUsbGadgetHal.getUsbSpeed(operationId);\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"get UsbSpeed failed\", e);\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mUsbGadgetHal is null\");\n                        break;\n                    }\n                    else {\n                        try {\n                            mCurrentGadgetHalVersion = mUsbGadgetHal.getGadgetHalVersion();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"update Usb gadget version failed\", e);\n                        }\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n\n            if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                  || (mFunctions != functions)) {\n                return;\n            }\n\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            Slog.i(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n            if (status == Status.SUCCESS) {\n                mCurrentFunctionsApplied = true;\n            } else if (!mChargingFunctions) {\n                Slog.e(TAG, \"Setting default fuctions\");\n                sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n            }\n        }\n\n        @Override\n        public void getUsbSpeedCb(int speed) {\n            mUsbSpeed = speed;\n        }\n\n        @Override\n        public void resetCb(int status) {\n            if (status != Status.SUCCESS)\n                Slog.e(TAG, \"resetCb fail\");\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions, int operationId) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mUsbGadgetHal == null) {\n                    Slog.e(TAG, \"setUsbConfig mUsbGadgetHal is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    mUsbGadgetHal.setCurrentUsbFunctions(mCurrentRequest,\n                            config, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS, operationId);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (Exception e) {//RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart, int operationId) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctionsi \" +\n                        \"functions=\" + functions +\n                        \", forceRestart=\" + forceRestart +\n                        \", operationId=\" + operationId);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions, operationId);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n            mUsbGadgetHal.getCurrentUsbFunctions(operationId);\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int pid, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, pid, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n        mHandler.setCurrentUsbFunctionsCb(functions, status,\n                    mRequest, mFunctions, mChargingFunctions);\n    }\n\n    public void getCurrentUsbFunctionsCb(long functions, int status) {\n        mHandler.sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                    status == Status.FUNCTIONS_APPLIED);\n    }\n\n    public void getUsbSpeedCb(int speed) {\n        mHandler.getUsbSpeedCb(speed);\n    }\n\n    public void resetCb(int status) {\n        mHandler.resetCb(status);\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions, int operationId) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        } else if (functions == UsbManager.FUNCTION_UVC) {\n            // MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_UVC);\n            // TODO: Add MetricsEvent for UVC?\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions, operationId);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        int operationId = sUsbOperationCount.incrementAndGet();\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n            sEventLogger.dump(new DualOutputStreamDumpSink(dump, UsbHandlerProto.UEVENT));\n        }\n\n        dump.end(token);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native int nativeGetAudioMode();\n}",
            "downstream_file_ground_truth_tokens": {
              "openai": 20371,
              "general": {
                "word_based": 7605,
                "char_based": 27177
              },
              "gemini": 24082
            },
            "downstream_file_content_patched_upstream_only": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.usb.hal.gadget.UsbGadgetHal;\nimport com.android.server.usb.hal.gadget.UsbGadgetHalInstance;\nimport com.android.server.utils.EventLogger;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String AUDIO_SOURCE_PCM_PATH =\n            \"/sys/class/android_usb/android0/f_audio_source/pcm\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    private static final int AUDIO_MODE_SOURCE = 1;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final int DUMPSYS_LOG_BUFFER = 200;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    private static EventLogger sEventLogger;\n\n    private static UsbGadgetHal mUsbGadgetHal;\n\n    /**\n     * Counter for tracking UsbOperation operations.\n     */\n    private static final AtomicInteger sUsbOperationCount = new AtomicInteger();\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n            if (sEventLogger != null) {\n                sEventLogger.enqueue(new EventLogger.StringEvent(\"USB UEVENT: \"\n                        + event.toString()));\n            } else {\n                if (DEBUG) Slog.d(TAG, \"sEventLogger == null\");\n            }\n\n            String state = event.get(\"USB_STATE\");\n            String accessory = event.get(\"ACCESSORY\");\n\n            if (state != null) {\n                mHandler.updateState(state);\n            } else if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                mHandler.setAccessoryUEventTime(SystemClock.elapsedRealtime());\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n        boolean halNotPresent = false;\n\n        mUsbGadgetHal = UsbGadgetHalInstance.getInstance(this, null);\n        Slog.d(TAG, \"getInstance done\");\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (mUsbGadgetHal == null) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        mHandler.handlerInitDone(operationId);\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT, android.hardware.usb.ParcelableUsbPort.class);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS, android.hardware.usb.UsbPortStatus.class);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(USB_STATE_MATCH);\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n\n        sEventLogger = new EventLogger(DUMPSYS_LOG_BUFFER, \"UsbDeviceManager activity\");\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        boolean enableAudio = (nativeGetAudioMode() == AUDIO_MODE_SOURCE);\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n        if (enableAudio) {\n            functions |= UsbManager.FUNCTION_AUDIO_SOURCE;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions, operationId);\n        }\n    }\n\n    //TODO It is not clear that this method serves any purpose (at least on Pixel devices)\n    // consider removing\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.i(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    public static void logAndPrint(int priority, IndentingPrintWriter pw, String msg) {\n        Slog.println(priority, TAG, msg);\n        if (pw != null) {\n            pw.println(msg);\n        }\n    }\n\n    public static void logAndPrintException(IndentingPrintWriter pw, String msg, Exception e) {\n        Slog.e(TAG, msg, e);\n        if (pw != null) {\n            pw.println(msg + e);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mUsbAccessoryConnected;\n        private boolean mInHostModeWithNoAccessoryConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n        private boolean mConnectedToDataDisabledPort;\n        private int mPowerBrickConnectionStatus;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        /**\n         * Do not debounce for the first disconnect after resetUsbGadget.\n         */\n        protected boolean mResetUsbGadgetDisableDebounce;\n        protected boolean mConnected;\n        protected boolean mConfigured;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n        protected boolean mPendingBootAccessoryHandshakeBroadcast;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public boolean sendMessage(int what) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            return sendMessageDelayed(m,0);\n        }\n\n        public void sendMessage(int what, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, long arg, boolean arg1, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            if (DEBUG) {\n                Slog.i(TAG, \"mResetUsbGadgetDisableDebounce:\" + mResetUsbGadgetDisableDebounce\n                       + \" connected:\" + connected + \"configured:\" + configured);\n            }\n            if (mResetUsbGadgetDisableDebounce) {\n                // Do not debounce disconnect after resetUsbGadget.\n                sendMessage(msg);\n                if (connected == 1) mResetUsbGadgetDisableDebounce = false;\n            } else {\n                if (configured == 0) {\n                    removeMessages(MSG_UPDATE_STATE);\n                    if (DEBUG) Slog.i(TAG, \"removeMessages MSG_UPDATE_STATE\");\n                }\n                if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n                // debounce disconnects to avoid problems bringing up USB tethering.\n                sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n            }\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable, int operationId) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true, operationId);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            int operationId = sUsbOperationCount.incrementAndGet();\n\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit(operationId);\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        protected void notifyAccessoryModeExit(int operationId) {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                        | Intent.FLAG_RECEIVER_FOREGROUND)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            SystemClock.elapsedRealtime());\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n            sEventLogger.enqueue(new EventLogger.StringEvent(\"USB intent: \" + intent));\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    Scanner scanner = null;\n                    try {\n                        scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                        mMidiCard = scanner.nextInt();\n                        mMidiDevice = scanner.nextInt();\n                    } catch (FileNotFoundException e) {\n                        Slog.e(TAG, \"could not open MIDI file\", e);\n                        enabled = false;\n                    } finally {\n                        if (scanner != null) {\n                            scanner.close();\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        private void setScreenUnlockedFunctions(int operationId) {\n            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"handleMessage MSG_UPDATE_STATE \" + \"mConnected:\" + mConnected\n                               + \" mConfigured:\" + mConfigured);\n                    }\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions(operationId);\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n\n                        boolean usbDataDisabled =\n                                status.getUsbDataStatus() != UsbPortStatus.DATA_STATUS_ENABLED;\n                        mConnectedToDataDisabledPort = status.isConnected() && usbDataDisabled;\n                        mPowerBrickConnectionStatus = status.getPowerBrickConnectionStatus();\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                        mConnectedToDataDisabledPort = false;\n                        mPowerBrickConnectionStatus = UsbPortStatus.POWER_BRICK_STATUS_UNKNOWN;\n                    }\n\n                    if (mHostConnected) {\n                        if (!mUsbAccessoryConnected) {\n                            mInHostModeWithNoAccessoryConnected = true;\n                        } else {\n                            mInHostModeWithNoAccessoryConnected = false;\n                        }\n                    } else {\n                        // if not in host mode, reset value to false\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    mUsbAccessoryConnected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + mUsbAccessoryConnected);\n                    }\n\n                    if (!devices.hasNext()) {\n                        mInHostModeWithNoAccessoryConnected = true;\n                    } else {\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1, msg.arg2);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    operationId = (int) msg.arg1;\n                    setEnabledFunctions(functions, false, operationId);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions(operationId);\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions(operationId);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true, operationId);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mBootCompleted = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_USER_SWITCHED: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected\n                                    + \" ,operationId: \" + operationId);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit(operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    if (mBootCompleted) {\n                        broadcastUsbAccessoryHandshake();\n                    } else {\n                        if (DEBUG) Slog.v(TAG, \"Pending broadcasting intent as \"\n                                + \"not boot completed yet.\");\n                        mPendingBootAccessoryHandshakeBroadcast = true;\n                    }\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        public abstract void handlerInitDone(int operationId);\n\n        protected void finishBoot(int operationId) {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions(operationId);\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                } else if (mPendingBootAccessoryHandshakeBroadcast) {\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                mPendingBootAccessoryHandshakeBroadcast = false;\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if ((mHideUsbNotification || mInHostModeWithNoAccessoryConnected)\n                    && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_UVC) {\n                    titleRes = com.android.internal.R.string.usb_uvc_notification_title;\n                    id = SystemMessage.NOTE_USB_UVC;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && (mUsbCharging || mUsbAccessoryConnected)) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            } else if (mSinkPower && mConnectedToDataDisabledPort\n                    && mPowerBrickConnectionStatus != UsbPortStatus.POWER_BRICK_STATUS_CONNECTED) {\n                // Show charging notification when USB Data is disabled on the port, and not\n                // connected to a wall charger.\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions,\n                boolean forceRestart, int operationId);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n\n        public abstract void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions);\n\n        public abstract void getUsbSpeedCb(int speed);\n\n        public abstract void resetCb(int status);\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions,\n                boolean forceRestart, int operationId) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions +\n                        \" ,forceRestart=\" + forceRestart +\n                        \" ,usbDataUnlocked=\" + usbDataUnlocked +\n                        \" ,operationId=\" + operationId);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void getUsbSpeedCb(int speed){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void resetCb(int status){\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            int operationId = sUsbOperationCount.incrementAndGet();\n            try {\n\n                synchronized (mGadgetProxyLock) {\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    updateUsbGadgetHalVersion();\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mUsbGadgetHal = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\"\n                                + \" ,operationId:\" + operationId);\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.i(TAG, \"processing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n                    operationId = msg.arg2;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.i(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.i(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot(operationId);\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 != 1) {\n                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                            notifyAccessoryModeExit(operationId);\n                        } else {\n                            // Set this since default function may be selected from Developer\n                            // options\n                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                        }\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mUsbGadgetHal = UsbGadgetHalInstance.getInstance(mUsbDeviceManager,\n                                    null);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false, operationId);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        if (mUsbGadgetHal == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mUsbGadgetHal is null\");\n                            break;\n                        }\n\n                        try {\n                            // MSG_ACCESSORY_MODE_ENTER_TIMEOUT has to be removed to allow exiting\n                            // AOAP mode during resetUsbGadget.\n                            removeMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n                            if (mConfigured) {\n                                mResetUsbGadgetDisableDebounce = true;\n                            }\n                            mUsbGadgetHal.reset(operationId);\n                        } catch (Exception e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                            mResetUsbGadgetDisableDebounce = false;\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mGadgetHal is null, operationId:\" + operationId);\n                        break;\n                    }\n\n                    try {\n                        mUsbGadgetHal.getUsbSpeed(operationId);\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"get UsbSpeed failed\", e);\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mUsbGadgetHal is null\");\n                        break;\n                    }\n                    else {\n                        try {\n                            mCurrentGadgetHalVersion = mUsbGadgetHal.getGadgetHalVersion();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"update Usb gadget version failed\", e);\n                        }\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n\n            if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                  || (mFunctions != functions)) {\n                return;\n            }\n\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            Slog.i(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n            if (status == Status.SUCCESS) {\n                mCurrentFunctionsApplied = true;\n            } else if (!mChargingFunctions) {\n                Slog.e(TAG, \"Setting default fuctions\");\n                sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n            }\n        }\n\n        @Override\n        public void getUsbSpeedCb(int speed) {\n            mUsbSpeed = speed;\n        }\n\n        @Override\n        public void resetCb(int status) {\n            if (status != Status.SUCCESS)\n                Slog.e(TAG, \"resetCb fail\");\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions, int operationId) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mUsbGadgetHal == null) {\n                    Slog.e(TAG, \"setUsbConfig mUsbGadgetHal is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    mUsbGadgetHal.setCurrentUsbFunctions(mCurrentRequest,\n                            config, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS, operationId);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (Exception e) {//RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart, int operationId) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctionsi \" +\n                        \"functions=\" + functions +\n                        \", forceRestart=\" + forceRestart +\n                        \", operationId=\" + operationId);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions, operationId);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n            mUsbGadgetHal.getCurrentUsbFunctions(operationId);\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int pid, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, pid, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n        mHandler.setCurrentUsbFunctionsCb(functions, status,\n                    mRequest, mFunctions, mChargingFunctions);\n    }\n\n    public void getCurrentUsbFunctionsCb(long functions, int status) {\n        mHandler.sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                    status == Status.FUNCTIONS_APPLIED);\n    }\n\n    public void getUsbSpeedCb(int speed) {\n        mHandler.getUsbSpeedCb(speed);\n    }\n\n    public void resetCb(int status) {\n        mHandler.resetCb(status);\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions, int operationId) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        } else if (functions == UsbManager.FUNCTION_UVC) {\n            // MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_UVC);\n            // TODO: Add MetricsEvent for UVC?\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions, operationId);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        int operationId = sUsbOperationCount.incrementAndGet();\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n            sEventLogger.dump(new DualOutputStreamDumpSink(dump, UsbHandlerProto.UEVENT));\n        }\n\n        dump.end(token);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native int nativeGetAudioMode();\n}\n```",
            "diff_patched_upstream_only": "--- original_downstream_file\n+++ patched_upstream_only\n@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2011 The Android Open Source Project\n  *\n@@ -2498,5 +2497,4 @@\n     private native boolean nativeIsStartRequested();\n \n     private native int nativeGetAudioMode();\n-}\n-```+}",
            "downstream_llm_diff_output": "```diff\n--- a/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -75,9 +75,11 @@\n import android.provider.Settings;\n import android.service.usb.UsbDeviceManagerProto;\n import android.service.usb.UsbHandlerProto;\n+import android.text.TextUtils;\n import android.util.Pair;\n import android.util.Slog;\n \n+import com.android.internal.R;\n import com.android.internal.annotations.GuardedBy;\n import com.android.internal.logging.MetricsLogger;\n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n```",
            "llm_output_valid": true,
            "runtime_seconds": 63.86,
            "attempts_made": 1,
            "validation_results": [
              {
                "attempt": 1,
                "format_valid": true,
                "format_error": "Valid patch format",
                "apply_valid": true,
                "apply_error": "Patch applies cleanly in repo",
                "valid": true,
                "runtime_seconds": 60.85
              }
            ],
            "token_counts": {
              "openai": 135,
              "general": {
                "word_based": 76,
                "char_based": 148
              },
              "gemini": 32403
            }
          }
        ]
      },
      {
        "downstream_version": "13",
        "gemini_token_usage": 49406,
        "branch_used": "android13-release",
        "downstream_patch": "aec6c731bfdbe7f0fe537948563a7aeee5cf05e2",
        "repo_path": "android_repos/base",
        "result": "failure",
        "downstream_patch_content": "commit aec6c731bfdbe7f0fe537948563a7aeee5cf05e2\nAuthor: Ashish Kumar Gupta <kumarashishg@google.com>\nDate:   Wed Jul 31 16:02:29 2024 +0000\n\n    Set no data transfer on function switch timeout for accessory mode\n    \n    In case of function switch times out, we will check whether\n    the last function set was accessory. If this is the case, it is\n    recommended to set the function to NONE(No data transfer) rather than\n    setting it to the default USB function.\n    \n    Bug: 353712853\n    Test: Build the code, flash the device and test it.\n    Test: atest CtsUsbManagerTestCases\n    Test: run CtsVerifier tool\n    Test: atest CtsUsbTests\n    Change-Id: I698e9df0333cbb51dd9bd5917a94d81273a2784a\n    Merged-In: I698e9df0333cbb51dd9bd5917a94d81273a2784a\n    (cherry picked from commit 7c6ec68537ba8abf798afd9ab7c3e5889841171f)\n\ndiff --git a/services/usb/java/com/android/server/usb/UsbDeviceManager.java b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\nindex 6ea416b54811..06561b2617ee 100644\n--- a/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -735,7 +735,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit() {\n+        protected void notifyAccessoryModeExit() {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -1981,8 +1981,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      * Dont force to default when the configuration is already set to default.\n                      */\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit();\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:\n",
        "downstream_patch_tokens": {
          "openai": 610,
          "general": {
            "word_based": 247,
            "char_based": 623
          },
          "gemini": 738
        },
        "file_conflicts": [
          {
            "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
            "total_hunks": 3,
            "failed_hunks": [
              1,
              2,
              3
            ],
            "inline_merge_conflicts": [],
            "inline_merge_token_summary": {
              "gemini": 0,
              "openai": 0,
              "general_word": 0,
              "general_char": 0
            },
            "rej_file_content": "```diff\n--- services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -80,9 +80,9 @@ import android.os.storage.StorageVolume;\n import android.provider.Settings;\n import android.service.usb.UsbDeviceManagerProto;\n import android.service.usb.UsbHandlerProto;\n+import android.text.TextUtils;\n import android.util.Pair;\n import android.util.Slog;\n-import android.text.TextUtils;\n \n import com.android.internal.R;\n import com.android.internal.annotations.GuardedBy;\n@@ -880,7 +880,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit(int operationId) {\n+        protected void notifyAccessoryModeExit(int operationId) {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -2313,8 +2313,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      */\n                     operationId = sUsbOperationCount.incrementAndGet();\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit(operationId);\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:\n```",
            "rej_file_tokens": {
              "openai": 370,
              "general": {
                "word_based": 162,
                "char_based": 478
              },
              "gemini": 446
            },
            "patch_apply_output": "patching file services/usb/java/com/android/server/usb/UsbDeviceManager.java\nHunk #1 FAILED at 80.\nHunk #2 FAILED at 880.\nHunk #3 FAILED at 2313.\n3 out of 3 hunks FAILED -- saving rejects to file services/usb/java/com/android/server/usb/UsbDeviceManager.java.rej",
            "inline_merge_output": "patching file services/usb/java/com/android/server/usb/UsbDeviceManager.java\nHunk #1 already applied at 83,86.\nHunk #2 already applied at 883.\nHunk #3 merged at 2291-2297.",
            "upstream_file_content": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport com.android.internal.annotations.Keep;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.text.TextUtils;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.usb.flags.Flags;\nimport com.android.server.usb.hal.gadget.UsbGadgetHal;\nimport com.android.server.usb.hal.gadget.UsbGadgetHalInstance;\nimport com.android.server.utils.EventLogger;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    /**\n     *  UDC controller for the ConfigFS USB Gadgets.\n     */\n    private static final String USB_CONTROLLER_NAME_PROPERTY = \"sys.usb.controller\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String UDC_SUBSYS_MATCH =\n            \"SUBSYSTEM=udc\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final int DUMPSYS_LOG_BUFFER = 200;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    private static EventLogger sEventLogger;\n\n    private static UsbGadgetHal mUsbGadgetHal;\n\n    private final boolean mEnableUdcSysfsUsbStateUpdate;\n    private String mUdcName = \"\";\n\n    /**\n     * Counter for tracking UsbOperation operations.\n     */\n    private static final AtomicInteger sUsbOperationCount = new AtomicInteger();\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n            if (sEventLogger != null) {\n                sEventLogger.enqueue(new EventLogger.StringEvent(\"USB UEVENT: \"\n                        + event.toString()));\n            } else {\n                if (DEBUG) Slog.d(TAG, \"sEventLogger == null\");\n            }\n\n            String accessory = event.get(\"ACCESSORY\");\n\n            if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                mHandler.setAccessoryUEventTime(SystemClock.elapsedRealtime());\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n\n            if (mEnableUdcSysfsUsbStateUpdate) {\n                if (!mUdcName.isEmpty()\n                        && \"udc\".equals(event.get(\"SUBSYSTEM\"))\n                        && event.get(\"DEVPATH\").contains(mUdcName)) {\n                    String action = event.get(\"ACTION\");\n                    if (\"add\".equals(action)) {\n                        nativeStartGadgetMonitor(mUdcName);\n                    } else if (\"remove\".equals(action)) {\n                        nativeStopGadgetMonitor();\n                    }\n                }\n            } else {\n                String state = event.get(\"USB_STATE\");\n                if (state != null) {\n                    mHandler.updateState(state);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n        boolean halNotPresent = false;\n\n        mUsbGadgetHal = UsbGadgetHalInstance.getInstance(this, null);\n        Slog.d(TAG, \"getInstance done\");\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (mUsbGadgetHal == null) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        mHandler.handlerInitDone(operationId);\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT, android.hardware.usb.ParcelableUsbPort.class);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS, android.hardware.usb.UsbPortStatus.class);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n\n        mEnableUdcSysfsUsbStateUpdate =\n                android.hardware.usb.flags.Flags.enableUdcSysfsUsbStateUpdate()\n                && context.getResources().getBoolean(R.bool.config_enableUdcSysfsUsbStateUpdate);\n\n        if (mEnableUdcSysfsUsbStateUpdate) {\n            mUEventObserver.startObserving(UDC_SUBSYS_MATCH);\n            new Thread(\"GetUsbControllerSysprop\") {\n                public void run() {\n                    String udcName;\n                    // blocking wait until usb controller sysprop is available\n                    udcName = nativeWaitAndGetProperty(USB_CONTROLLER_NAME_PROPERTY);\n                    nativeStartGadgetMonitor(udcName);\n                    mUdcName = udcName;\n                    Slog.v(TAG, \"USB controller name \" + udcName);\n                }\n            }.start();\n        } else {\n            mUEventObserver.startObserving(USB_STATE_MATCH);\n        }\n\n        sEventLogger = new EventLogger(DUMPSYS_LOG_BUFFER, \"UsbDeviceManager activity\");\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions, operationId);\n        }\n    }\n\n    //TODO It is not clear that this method serves any purpose (at least on Pixel devices)\n    // consider removing\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.i(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    public static void logAndPrint(int priority, IndentingPrintWriter pw, String msg) {\n        Slog.println(priority, TAG, msg);\n        if (pw != null) {\n            pw.println(msg);\n        }\n    }\n\n    public static void logAndPrintException(IndentingPrintWriter pw, String msg, Exception e) {\n        Slog.e(TAG, msg, e);\n        if (pw != null) {\n            pw.println(msg + e);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mUsbAccessoryConnected;\n        private boolean mInHostModeWithNoAccessoryConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n        private boolean mConnectedToDataDisabledPort;\n        private int mPowerBrickConnectionStatus;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        /**\n         * Do not debounce for the first disconnect after resetUsbGadget.\n         */\n        protected boolean mResetUsbGadgetDisableDebounce;\n        protected boolean mConnected;\n        protected boolean mConfigured;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n        protected boolean mPendingBootAccessoryHandshakeBroadcast;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        protected static final String MTP_PACKAGE_NAME = \"com.android.mtp\";\n        protected static final String MTP_SERVICE_CLASS_NAME = \"com.android.mtp.MtpService\";\n\n        private boolean mIsMtpServiceBound = false;\n\n        /**\n         * {@link ServiceConnection} for {@link MtpService}.\n         */\n        private ServiceConnection mMtpServiceConnection = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName className, IBinder service) {}\n\n            @Override\n            public void onServiceDisconnected(ComponentName arg0) {}\n        };\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public boolean sendMessage(int what) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            return sendMessageDelayed(m,0);\n        }\n\n        public void sendMessage(int what, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, long arg, boolean arg1, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            if (DEBUG) {\n                Slog.i(TAG, \"mResetUsbGadgetDisableDebounce:\" + mResetUsbGadgetDisableDebounce\n                       + \" connected:\" + connected + \"configured:\" + configured);\n            }\n            if (mResetUsbGadgetDisableDebounce) {\n                // Do not debounce disconnect after resetUsbGadget.\n                sendMessage(msg);\n                if (connected == 1) mResetUsbGadgetDisableDebounce = false;\n            } else {\n                if (configured == 0) {\n                    removeMessages(MSG_UPDATE_STATE);\n                    if (DEBUG) Slog.i(TAG, \"removeMessages MSG_UPDATE_STATE\");\n                }\n                if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n                // debounce disconnects to avoid problems bringing up USB tethering.\n                sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n            }\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable, int operationId) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true, operationId);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            int operationId = sUsbOperationCount.incrementAndGet();\n\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit(operationId);\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        protected void notifyAccessoryModeExit(int operationId) {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                        | Intent.FLAG_RECEIVER_FOREGROUND)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            SystemClock.elapsedRealtime());\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n            sEventLogger.enqueue(new EventLogger.StringEvent(\"USB intent: \" + intent));\n        }\n\n        private void getMidiCardDevice() throws FileNotFoundException {\n            String controllerName =  getSystemProperty(USB_CONTROLLER_NAME_PROPERTY, \"\");\n            if (TextUtils.isEmpty(controllerName)) {\n                throw new FileNotFoundException(\"controller name not found\");\n            }\n\n            File soundDir = new File(\"/sys/class/udc/\" + controllerName + \"/gadget/sound\");\n            if (!soundDir.exists()) {\n                throw new FileNotFoundException(\"sound device not found\");\n            }\n\n            // There should be exactly one sound card\n            File[] cardDirs = FileUtils.listFilesOrEmpty(soundDir,\n                                                         (dir, file) -> file.startsWith(\"card\"));\n            if (cardDirs.length != 1) {\n                throw new FileNotFoundException(\"sound card not match\");\n            }\n\n            // There should be exactly one midi device\n            File[] midis = FileUtils.listFilesOrEmpty(cardDirs[0],\n                                                      (dir, file) -> file.startsWith(\"midi\"));\n            if (midis.length != 1) {\n                throw new FileNotFoundException(\"MIDI device not match\");\n            }\n\n            Pattern pattern = Pattern.compile(\"midiC(\\\\d+)D(\\\\d+)\");\n            Matcher matcher = pattern.matcher(midis[0].getName());\n            if (matcher.matches()) {\n                mMidiCard = Integer.parseInt(matcher.group(1));\n                mMidiDevice = Integer.parseInt(matcher.group(2));\n                Slog.i(TAG, \"Found MIDI card \" + mMidiCard + \" device \" + mMidiDevice);\n            } else {\n                throw new FileNotFoundException(\"MIDI name not match\");\n            }\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n            updateMtpFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    if (android.hardware.usb.flags.Flags.enableUsbSysfsMidiIdentification()) {\n                        try {\n                            getMidiCardDevice();\n                        } catch (FileNotFoundException e) {\n                            Slog.e(TAG, \"could not identify MIDI device\", e);\n                            enabled = false;\n                        }\n                    } else {\n                        Scanner scanner = null;\n                        try {\n                            scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                            mMidiCard = scanner.nextInt();\n                            mMidiDevice = scanner.nextInt();\n                        } catch (FileNotFoundException e) {\n                            Slog.e(TAG, \"could not open MIDI file\", e);\n                            enabled = false;\n                        } finally {\n                            if (scanner != null) {\n                                scanner.close();\n                            }\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        /**\n         * Bind to MtpService when MTP or PTP is enabled. This is done to prevent activity manager\n         * from freezing the corresponding process.\n         */\n        private void updateMtpFunction() {\n            if (!Flags.enableBindToMtpService()) {\n                return;\n            }\n\n            boolean mtpEnabled = ((mCurrentFunctions & UsbManager.FUNCTION_MTP) != 0);\n            boolean ptpEnabled = ((mCurrentFunctions & UsbManager.FUNCTION_PTP) != 0);\n\n            if (DEBUG) {\n                Slog.d(TAG, \"updateMtpFunction \"\n                        + \", mtpEnabled: \" + mtpEnabled\n                        + \", ptpEnabled: \" + ptpEnabled\n                        + \", mIsMtpServiceBound: \" + mIsMtpServiceBound\n                );\n            }\n\n            if (mConfigured && (mtpEnabled || ptpEnabled)) {\n                bindToMtpService();\n            } else if (mIsMtpServiceBound) {\n                unbindMtpService();\n            }\n        }\n\n        private void bindToMtpService() {\n            Intent intent = new Intent();\n            intent.setComponent(new ComponentName(MTP_PACKAGE_NAME, MTP_SERVICE_CLASS_NAME));\n\n            if (DEBUG) Slog.d(TAG, \"Binding to MtpService\");\n\n            try {\n                mIsMtpServiceBound = mContext.bindServiceAsUser(\n                    intent,\n                    mMtpServiceConnection,\n                    Context.BIND_AUTO_CREATE,\n                    UserHandle.CURRENT\n                );\n            } catch (SecurityException exception) {\n                Slog.e(TAG, \"Unable to bind to MtpService due to SecurityException\", exception);\n            }\n\n            // Unbinding from the service if binding was not successful to release the connection.\n            // https://developer.android.com/reference/android/content/Context#bindService(android.content.Intent,%20android.content.ServiceConnection,%20int)\n            if (!mIsMtpServiceBound) {\n                unbindMtpService();\n                Slog.e(TAG, \"Binding to MtpService failed\");\n            }\n\n            if (DEBUG && mIsMtpServiceBound) Slog.d(TAG, \"Successfully bound to MtpService\");\n        }\n\n        private void unbindMtpService() {\n            if (DEBUG) Slog.d(TAG, \"Unbinding from MtpService\");\n\n            mContext.unbindService(mMtpServiceConnection);\n            mIsMtpServiceBound = false;\n        }\n\n        private void setScreenUnlockedFunctions(int operationId) {\n            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"handleMessage MSG_UPDATE_STATE \" + \"mConnected:\" + mConnected\n                               + \" mConfigured:\" + mConfigured);\n                    }\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions(operationId);\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n\n                        boolean usbDataDisabled =\n                                status.getUsbDataStatus() != UsbPortStatus.DATA_STATUS_ENABLED;\n                        mConnectedToDataDisabledPort = status.isConnected() && usbDataDisabled;\n                        mPowerBrickConnectionStatus = status.getPowerBrickConnectionStatus();\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                        mConnectedToDataDisabledPort = false;\n                        mPowerBrickConnectionStatus = UsbPortStatus.POWER_BRICK_STATUS_UNKNOWN;\n                    }\n\n                    if (mHostConnected) {\n                        if (!mUsbAccessoryConnected) {\n                            mInHostModeWithNoAccessoryConnected = true;\n                        } else {\n                            mInHostModeWithNoAccessoryConnected = false;\n                        }\n                    } else {\n                        // if not in host mode, reset value to false\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    mUsbAccessoryConnected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + mUsbAccessoryConnected);\n                    }\n\n                    if (!devices.hasNext()) {\n                        mInHostModeWithNoAccessoryConnected = true;\n                    } else {\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1, msg.arg2);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    operationId = (int) msg.arg1;\n                    setEnabledFunctions(functions, false, operationId);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions(operationId);\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions(operationId);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true, operationId);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mBootCompleted = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_USER_SWITCHED: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected\n                                    + \" ,operationId: \" + operationId);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit(operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    if (mBootCompleted) {\n                        broadcastUsbAccessoryHandshake();\n                    } else {\n                        if (DEBUG) Slog.v(TAG, \"Pending broadcasting intent as \"\n                                + \"not boot completed yet.\");\n                        mPendingBootAccessoryHandshakeBroadcast = true;\n                    }\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        public abstract void handlerInitDone(int operationId);\n\n        protected void finishBoot(int operationId) {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions(operationId);\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                } else if (mPendingBootAccessoryHandshakeBroadcast) {\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                mPendingBootAccessoryHandshakeBroadcast = false;\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if ((mHideUsbNotification || mInHostModeWithNoAccessoryConnected)\n                    && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_UVC) {\n                    titleRes = com.android.internal.R.string.usb_uvc_notification_title;\n                    id = SystemMessage.NOTE_USB_UVC;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && (mUsbCharging || mUsbAccessoryConnected)) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            } else if (mSinkPower && mConnectedToDataDisabledPort\n                    && mPowerBrickConnectionStatus != UsbPortStatus.POWER_BRICK_STATUS_CONNECTED) {\n                // Show charging notification when USB Data is disabled on the port, and not\n                // connected to a wall charger.\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions,\n                boolean forceRestart, int operationId);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n\n        public abstract void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions);\n\n        public abstract void getUsbSpeedCb(int speed);\n\n        public abstract void resetCb(int status);\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions,\n                boolean forceRestart, int operationId) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions +\n                        \" ,forceRestart=\" + forceRestart +\n                        \" ,usbDataUnlocked=\" + usbDataUnlocked +\n                        \" ,operationId=\" + operationId);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void getUsbSpeedCb(int speed){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void resetCb(int status){\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            int operationId = sUsbOperationCount.incrementAndGet();\n            try {\n\n                synchronized (mGadgetProxyLock) {\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    updateUsbGadgetHalVersion();\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mUsbGadgetHal = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\"\n                                + \" ,operationId:\" + operationId);\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.i(TAG, \"processing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n                    operationId = msg.arg2;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.i(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.i(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot(operationId);\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 != 1) {\n                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                            notifyAccessoryModeExit(operationId);\n                        } else {\n                            // Set this since default function may be selected from Developer\n                            // options\n                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                        }\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mUsbGadgetHal = UsbGadgetHalInstance.getInstance(mUsbDeviceManager,\n                                    null);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false, operationId);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        if (mUsbGadgetHal == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mUsbGadgetHal is null\");\n                            break;\n                        }\n\n                        try {\n                            // MSG_ACCESSORY_MODE_ENTER_TIMEOUT has to be removed to allow exiting\n                            // AOAP mode during resetUsbGadget.\n                            removeMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n                            if (mConfigured) {\n                                mResetUsbGadgetDisableDebounce = true;\n                            }\n                            mUsbGadgetHal.reset(operationId);\n                        } catch (Exception e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                            mResetUsbGadgetDisableDebounce = false;\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mGadgetHal is null, operationId:\" + operationId);\n                        break;\n                    }\n\n                    try {\n                        mUsbGadgetHal.getUsbSpeed(operationId);\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"get UsbSpeed failed\", e);\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mUsbGadgetHal is null\");\n                        break;\n                    }\n                    else {\n                        try {\n                            mCurrentGadgetHalVersion = mUsbGadgetHal.getGadgetHalVersion();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"update Usb gadget version failed\", e);\n                        }\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n\n            if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                  || (mFunctions != functions)) {\n                return;\n            }\n\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            Slog.i(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n            if (status == Status.SUCCESS) {\n                mCurrentFunctionsApplied = true;\n            } else if (!mChargingFunctions) {\n                Slog.e(TAG, \"Setting default fuctions\");\n                sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n            }\n        }\n\n        @Override\n        public void getUsbSpeedCb(int speed) {\n            mUsbSpeed = speed;\n        }\n\n        @Override\n        public void resetCb(int status) {\n            if (status != Status.SUCCESS)\n                Slog.e(TAG, \"resetCb fail\");\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions, int operationId) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mUsbGadgetHal == null) {\n                    Slog.e(TAG, \"setUsbConfig mUsbGadgetHal is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    mUsbGadgetHal.setCurrentUsbFunctions(mCurrentRequest,\n                            config, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS, operationId);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (Exception e) {//RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart, int operationId) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctionsi \" +\n                        \"functions=\" + functions +\n                        \", forceRestart=\" + forceRestart +\n                        \", operationId=\" + operationId);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions, operationId);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n            mUsbGadgetHal.getCurrentUsbFunctions(operationId);\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int pid, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, pid, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n        mHandler.setCurrentUsbFunctionsCb(functions, status,\n                    mRequest, mFunctions, mChargingFunctions);\n    }\n\n    public void getCurrentUsbFunctionsCb(long functions, int status) {\n        mHandler.sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                    status == Status.FUNCTIONS_APPLIED);\n    }\n\n    public void getUsbSpeedCb(int speed) {\n        mHandler.getUsbSpeedCb(speed);\n    }\n\n    public void resetCb(int status) {\n        mHandler.resetCb(status);\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions, int operationId) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        } else if (functions == UsbManager.FUNCTION_UVC) {\n            // MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_UVC);\n            // TODO: Add MetricsEvent for UVC?\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions, operationId);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        int operationId = sUsbOperationCount.incrementAndGet();\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n            sEventLogger.dump(new DualOutputStreamDumpSink(dump, UsbHandlerProto.UEVENT));\n        }\n\n        dump.end(token);\n    }\n\n    /**\n     * Update usb state (Called by native code).\n     */\n    @Keep\n    private void updateGadgetState(String state) {\n        Slog.d(TAG, \"Usb state update \" + state);\n\n        mHandler.updateState(state);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native String nativeWaitAndGetProperty(String propName);\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native boolean nativeStartGadgetMonitor(String udcName);\n\n    private native void nativeStopGadgetMonitor();\n}\n```",
            "upstream_file_tokens": {
              "openai": 21808,
              "general": {
                "word_based": 8151,
                "char_based": 29003
              },
              "gemini": 25756
            },
            "downstream_file_content": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.IUsbGadget;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.IUsbGadgetCallback;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceManager;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String AUDIO_SOURCE_PCM_PATH =\n            \"/sys/class/android_usb/android0/f_audio_source/pcm\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    private static final int AUDIO_MODE_SOURCE = 1;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final int DUMPSYS_LOG_BUFFER = 200;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    private static UsbDeviceLogger sEventLogger;\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n            if (sEventLogger != null) {\n                sEventLogger.log(new UsbDeviceLogger.StringEvent(\"USB UEVENT: \"\n                        + event.toString()));\n            } else {\n                if (DEBUG) Slog.d(TAG, \"sEventLogger == null\");\n            }\n\n            String state = event.get(\"USB_STATE\");\n            String accessory = event.get(\"ACCESSORY\");\n\n            if (state != null) {\n                mHandler.updateState(state);\n            } else if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                mHandler.setAccessoryUEventTime(SystemClock.elapsedRealtime());\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        boolean halNotPresent = false;\n        try {\n            IUsbGadget.getService(true);\n        } catch (RemoteException e) {\n            Slog.e(TAG, \"USB GADGET HAL present but exception thrown\", e);\n        } catch (NoSuchElementException e) {\n            halNotPresent = true;\n            Slog.i(TAG, \"USB GADGET HAL not present in the device\", e);\n        }\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (halNotPresent) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(USB_STATE_MATCH);\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n\n        sEventLogger = new UsbDeviceLogger(DUMPSYS_LOG_BUFFER, \"UsbDeviceManager activity\");\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        boolean enableAudio = (nativeGetAudioMode() == AUDIO_MODE_SOURCE);\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n        if (enableAudio) {\n            functions |= UsbManager.FUNCTION_AUDIO_SOURCE;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions);\n        }\n    }\n\n    //TODO It is not clear that this method serves any purpose (at least on Pixel devices)\n    // consider removing\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.i(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mUsbAccessoryConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mConfigured;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        protected boolean mConnected;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n        protected boolean mPendingBootAccessoryHandshakeBroadcast;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            if (configured == 0) removeMessages(MSG_UPDATE_STATE);\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            // debounce disconnects to avoid problems bringing up USB tethering\n            sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit();\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        private void notifyAccessoryModeExit() {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                        | Intent.FLAG_RECEIVER_FOREGROUND)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            SystemClock.elapsedRealtime());\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n            sEventLogger.log(new UsbDeviceLogger.StringEvent(\"USB intent: \" + intent));\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    Scanner scanner = null;\n                    try {\n                        scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                        mMidiCard = scanner.nextInt();\n                        mMidiDevice = scanner.nextInt();\n                    } catch (FileNotFoundException e) {\n                        Slog.e(TAG, \"could not open MIDI file\", e);\n                        enabled = false;\n                    } finally {\n                        if (scanner != null) {\n                            scanner.close();\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        private void setScreenUnlockedFunctions() {\n            setEnabledFunctions(mScreenUnlockedFunctions, false);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions();\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    mUsbAccessoryConnected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + mUsbAccessoryConnected);\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    setEnabledFunctions(functions, false);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions();\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions();\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot();\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    mBootCompleted = true;\n                    finishBoot();\n                    break;\n                case MSG_USER_SWITCHED: {\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit();\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    if (mBootCompleted) {\n                        broadcastUsbAccessoryHandshake();\n                    } else {\n                        if (DEBUG) Slog.v(TAG, \"Pending broadcasting intent as \"\n                                + \"not boot completed yet.\");\n                        mPendingBootAccessoryHandshakeBroadcast = true;\n                    }\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        protected void finishBoot() {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions();\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                } else if (mPendingBootAccessoryHandshakeBroadcast) {\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                mPendingBootAccessoryHandshakeBroadcast = false;\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if (mHideUsbNotification && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && (mUsbCharging || mUsbAccessoryConnected)) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions, boolean forceRestart);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions + \", \"\n                        + \"forceRestart=\" + forceRestart + \", usbDataUnlocked=\" + usbDataUnlocked);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + functions);\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        /**\n         * Proxy object for the usb gadget hal daemon.\n         */\n        @GuardedBy(\"mGadgetProxyLock\")\n        private IUsbGadget mGadgetProxy;\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                ServiceNotification serviceNotification = new ServiceNotification();\n\n                boolean ret = IServiceManager.getService()\n                        .registerForNotifications(GADGET_HAL_FQ_NAME, \"\", serviceNotification);\n                if (!ret) {\n                    Slog.e(TAG, \"Failed to register usb gadget service start notification\");\n                    return;\n                }\n\n                synchronized (mGadgetProxyLock) {\n                    mGadgetProxy = IUsbGadget.getService(true);\n                    mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                            USB_GADGET_HAL_DEATH_COOKIE);\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    mGadgetProxy.getCurrentUsbFunctions(new UsbGadgetCallback());\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n                updateUsbGadgetHalVersion();\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (RemoteException e) {\n                Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mGadgetProxy = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\");\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.i(TAG, \"processing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.i(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.i(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot();\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mGadgetProxy = IUsbGadget.getService();\n                            mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                                    USB_GADGET_HAL_DEATH_COOKIE);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            gadgetProxy.reset();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_2.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxy != null) {\n                                gadgetProxy.getUsbSpeed(new UsbGadgetCallback());\n                            }\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"get UsbSpeed failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                android.hardware.usb.gadget.V1_2.IUsbGadget.castFrom(mGadgetProxy);\n                        if (gadgetProxy == null) {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxyV1By1 =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxyV1By1 == null) {\n                                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                                break;\n                            }\n                            mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_1;\n                            break;\n                        }\n                        mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_2;\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        private class UsbGadgetCallback extends IUsbGadgetCallback.Stub {\n            int mRequest;\n            long mFunctions;\n            boolean mChargingFunctions;\n\n            UsbGadgetCallback() {\n            }\n\n            UsbGadgetCallback(int request, long functions,\n                    boolean chargingFunctions) {\n                mRequest = request;\n                mFunctions = functions;\n                mChargingFunctions = chargingFunctions;\n            }\n\n            @Override\n            public void setCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                /**\n                 * Callback called for a previous setCurrenUsbFunction\n                 */\n                if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                        || (mFunctions != functions)) {\n                    return;\n                }\n\n                removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n                Slog.e(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n                if (status == Status.SUCCESS) {\n                    mCurrentFunctionsApplied = true;\n                } else if (!mChargingFunctions) {\n                    Slog.e(TAG, \"Setting default fuctions\");\n                    sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n                }\n            }\n\n            @Override\n            public void getCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                        status == Status.FUNCTIONS_APPLIED);\n            }\n\n            @Override\n            public void getUsbSpeedCb(int speed) {\n                mUsbSpeed = speed;\n            }\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mGadgetProxy == null) {\n                    Slog.e(TAG, \"setUsbConfig mGadgetProxy is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    UsbGadgetCallback usbGadgetCallback = new UsbGadgetCallback(mCurrentRequest,\n                            config, chargingFunctions);\n                    mGadgetProxy.setCurrentUsbFunctions(config, usbGadgetCallback,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + functions + \", \"\n                        + \"forceRestart=\" + forceRestart);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int pid, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, pid, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n            sEventLogger.dump(dump, UsbHandlerProto.UEVENT);\n        }\n\n        dump.end(token);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native int nativeGetAudioMode();\n}\n```",
            "downstream_file_tokens": {
              "openai": 18967,
              "general": {
                "word_based": 7077,
                "char_based": 25402
              },
              "gemini": 22466
            },
            "downstream_file_content_ground_truth": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.IUsbGadget;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.IUsbGadgetCallback;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceManager;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String AUDIO_SOURCE_PCM_PATH =\n            \"/sys/class/android_usb/android0/f_audio_source/pcm\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    private static final int AUDIO_MODE_SOURCE = 1;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final int DUMPSYS_LOG_BUFFER = 200;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    private static UsbDeviceLogger sEventLogger;\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n            if (sEventLogger != null) {\n                sEventLogger.log(new UsbDeviceLogger.StringEvent(\"USB UEVENT: \"\n                        + event.toString()));\n            } else {\n                if (DEBUG) Slog.d(TAG, \"sEventLogger == null\");\n            }\n\n            String state = event.get(\"USB_STATE\");\n            String accessory = event.get(\"ACCESSORY\");\n\n            if (state != null) {\n                mHandler.updateState(state);\n            } else if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                mHandler.setAccessoryUEventTime(SystemClock.elapsedRealtime());\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        boolean halNotPresent = false;\n        try {\n            IUsbGadget.getService(true);\n        } catch (RemoteException e) {\n            Slog.e(TAG, \"USB GADGET HAL present but exception thrown\", e);\n        } catch (NoSuchElementException e) {\n            halNotPresent = true;\n            Slog.i(TAG, \"USB GADGET HAL not present in the device\", e);\n        }\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (halNotPresent) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(USB_STATE_MATCH);\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n\n        sEventLogger = new UsbDeviceLogger(DUMPSYS_LOG_BUFFER, \"UsbDeviceManager activity\");\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        boolean enableAudio = (nativeGetAudioMode() == AUDIO_MODE_SOURCE);\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n        if (enableAudio) {\n            functions |= UsbManager.FUNCTION_AUDIO_SOURCE;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions);\n        }\n    }\n\n    //TODO It is not clear that this method serves any purpose (at least on Pixel devices)\n    // consider removing\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.i(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mUsbAccessoryConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mConfigured;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        protected boolean mConnected;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n        protected boolean mPendingBootAccessoryHandshakeBroadcast;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            if (configured == 0) removeMessages(MSG_UPDATE_STATE);\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            // debounce disconnects to avoid problems bringing up USB tethering\n            sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit();\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        protected void notifyAccessoryModeExit() {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                        | Intent.FLAG_RECEIVER_FOREGROUND)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            SystemClock.elapsedRealtime());\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n            sEventLogger.log(new UsbDeviceLogger.StringEvent(\"USB intent: \" + intent));\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    Scanner scanner = null;\n                    try {\n                        scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                        mMidiCard = scanner.nextInt();\n                        mMidiDevice = scanner.nextInt();\n                    } catch (FileNotFoundException e) {\n                        Slog.e(TAG, \"could not open MIDI file\", e);\n                        enabled = false;\n                    } finally {\n                        if (scanner != null) {\n                            scanner.close();\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        private void setScreenUnlockedFunctions() {\n            setEnabledFunctions(mScreenUnlockedFunctions, false);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions();\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    mUsbAccessoryConnected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + mUsbAccessoryConnected);\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    setEnabledFunctions(functions, false);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions();\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions();\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot();\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    mBootCompleted = true;\n                    finishBoot();\n                    break;\n                case MSG_USER_SWITCHED: {\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit();\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    if (mBootCompleted) {\n                        broadcastUsbAccessoryHandshake();\n                    } else {\n                        if (DEBUG) Slog.v(TAG, \"Pending broadcasting intent as \"\n                                + \"not boot completed yet.\");\n                        mPendingBootAccessoryHandshakeBroadcast = true;\n                    }\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        protected void finishBoot() {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions();\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                } else if (mPendingBootAccessoryHandshakeBroadcast) {\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                mPendingBootAccessoryHandshakeBroadcast = false;\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if (mHideUsbNotification && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && (mUsbCharging || mUsbAccessoryConnected)) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions, boolean forceRestart);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions + \", \"\n                        + \"forceRestart=\" + forceRestart + \", usbDataUnlocked=\" + usbDataUnlocked);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + functions);\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        /**\n         * Proxy object for the usb gadget hal daemon.\n         */\n        @GuardedBy(\"mGadgetProxyLock\")\n        private IUsbGadget mGadgetProxy;\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                ServiceNotification serviceNotification = new ServiceNotification();\n\n                boolean ret = IServiceManager.getService()\n                        .registerForNotifications(GADGET_HAL_FQ_NAME, \"\", serviceNotification);\n                if (!ret) {\n                    Slog.e(TAG, \"Failed to register usb gadget service start notification\");\n                    return;\n                }\n\n                synchronized (mGadgetProxyLock) {\n                    mGadgetProxy = IUsbGadget.getService(true);\n                    mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                            USB_GADGET_HAL_DEATH_COOKIE);\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    mGadgetProxy.getCurrentUsbFunctions(new UsbGadgetCallback());\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n                updateUsbGadgetHalVersion();\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (RemoteException e) {\n                Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mGadgetProxy = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\");\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.i(TAG, \"processing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.i(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.i(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot();\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    if (msg.arg1 != 1) {\n                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                            notifyAccessoryModeExit();\n                        } else {\n                            // Set this since default function may be selected from Developer\n                            // options\n                            setEnabledFunctions(mScreenUnlockedFunctions, false);\n                        }\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mGadgetProxy = IUsbGadget.getService();\n                            mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                                    USB_GADGET_HAL_DEATH_COOKIE);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            gadgetProxy.reset();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_2.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxy != null) {\n                                gadgetProxy.getUsbSpeed(new UsbGadgetCallback());\n                            }\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"get UsbSpeed failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                android.hardware.usb.gadget.V1_2.IUsbGadget.castFrom(mGadgetProxy);\n                        if (gadgetProxy == null) {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxyV1By1 =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxyV1By1 == null) {\n                                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                                break;\n                            }\n                            mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_1;\n                            break;\n                        }\n                        mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_2;\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        private class UsbGadgetCallback extends IUsbGadgetCallback.Stub {\n            int mRequest;\n            long mFunctions;\n            boolean mChargingFunctions;\n\n            UsbGadgetCallback() {\n            }\n\n            UsbGadgetCallback(int request, long functions,\n                    boolean chargingFunctions) {\n                mRequest = request;\n                mFunctions = functions;\n                mChargingFunctions = chargingFunctions;\n            }\n\n            @Override\n            public void setCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                /**\n                 * Callback called for a previous setCurrenUsbFunction\n                 */\n                if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                        || (mFunctions != functions)) {\n                    return;\n                }\n\n                removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n                Slog.e(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n                if (status == Status.SUCCESS) {\n                    mCurrentFunctionsApplied = true;\n                } else if (!mChargingFunctions) {\n                    Slog.e(TAG, \"Setting default fuctions\");\n                    sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n                }\n            }\n\n            @Override\n            public void getCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                        status == Status.FUNCTIONS_APPLIED);\n            }\n\n            @Override\n            public void getUsbSpeedCb(int speed) {\n                mUsbSpeed = speed;\n            }\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mGadgetProxy == null) {\n                    Slog.e(TAG, \"setUsbConfig mGadgetProxy is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    UsbGadgetCallback usbGadgetCallback = new UsbGadgetCallback(mCurrentRequest,\n                            config, chargingFunctions);\n                    mGadgetProxy.setCurrentUsbFunctions(config, usbGadgetCallback,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + functions + \", \"\n                        + \"forceRestart=\" + forceRestart);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int pid, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, pid, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n            sEventLogger.dump(dump, UsbHandlerProto.UEVENT);\n        }\n\n        dump.end(token);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native int nativeGetAudioMode();\n}",
            "downstream_file_ground_truth_tokens": {
              "openai": 18998,
              "general": {
                "word_based": 7083,
                "char_based": 25461
              },
              "gemini": 22501
            },
            "downstream_file_content_patched_upstream_only": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.IUsbGadget;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.IUsbGadgetCallback;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceManager;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String AUDIO_SOURCE_PCM_PATH =\n            \"/sys/class/android_usb/android0/f_audio_source/pcm\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    private static final int AUDIO_MODE_SOURCE = 1;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final int DUMPSYS_LOG_BUFFER = 200;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    private static UsbDeviceLogger sEventLogger;\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n            if (sEventLogger != null) {\n                sEventLogger.log(new UsbDeviceLogger.StringEvent(\"USB UEVENT: \"\n                        + event.toString()));\n            } else {\n                if (DEBUG) Slog.d(TAG, \"sEventLogger == null\");\n            }\n\n            String state = event.get(\"USB_STATE\");\n            String accessory = event.get(\"ACCESSORY\");\n\n            if (state != null) {\n                mHandler.updateState(state);\n            } else if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                mHandler.setAccessoryUEventTime(SystemClock.elapsedRealtime());\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        boolean halNotPresent = false;\n        try {\n            IUsbGadget.getService(true);\n        } catch (RemoteException e) {\n            Slog.e(TAG, \"USB GADGET HAL present but exception thrown\", e);\n        } catch (NoSuchElementException e) {\n            halNotPresent = true;\n            Slog.i(TAG, \"USB GADGET HAL not present in the device\", e);\n        }\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (halNotPresent) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(USB_STATE_MATCH);\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n\n        sEventLogger = new UsbDeviceLogger(DUMPSYS_LOG_BUFFER, \"UsbDeviceManager activity\");\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        boolean enableAudio = (nativeGetAudioMode() == AUDIO_MODE_SOURCE);\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n        if (enableAudio) {\n            functions |= UsbManager.FUNCTION_AUDIO_SOURCE;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions);\n        }\n    }\n\n    //TODO It is not clear that this method serves any purpose (at least on Pixel devices)\n    // consider removing\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.i(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mUsbAccessoryConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mConfigured;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        protected boolean mConnected;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n        protected boolean mPendingBootAccessoryHandshakeBroadcast;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            if (configured == 0) removeMessages(MSG_UPDATE_STATE);\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            // debounce disconnects to avoid problems bringing up USB tethering\n            sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit();\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        private void notifyAccessoryModeExit() {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                        | Intent.FLAG_RECEIVER_FOREGROUND)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            SystemClock.elapsedRealtime());\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n            sEventLogger.log(new UsbDeviceLogger.StringEvent(\"USB intent: \" + intent));\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    Scanner scanner = null;\n                    try {\n                        scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                        mMidiCard = scanner.nextInt();\n                        mMidiDevice = scanner.nextInt();\n                    } catch (FileNotFoundException e) {\n                        Slog.e(TAG, \"could not open MIDI file\", e);\n                        enabled = false;\n                    } finally {\n                        if (scanner != null) {\n                            scanner.close();\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        private void setScreenUnlockedFunctions() {\n            setEnabledFunctions(mScreenUnlockedFunctions, false);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions();\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    mUsbAccessoryConnected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + mUsbAccessoryConnected);\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    setEnabledFunctions(functions, false);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions();\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions();\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot();\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    mBootCompleted = true;\n                    finishBoot();\n                    break;\n                case MSG_USER_SWITCHED: {\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit();\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    if (mBootCompleted) {\n                        broadcastUsbAccessoryHandshake();\n                    } else {\n                        if (DEBUG) Slog.v(TAG, \"Pending broadcasting intent as \"\n                                + \"not boot completed yet.\");\n                        mPendingBootAccessoryHandshakeBroadcast = true;\n                    }\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        protected void finishBoot() {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions();\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                } else if (mPendingBootAccessoryHandshakeBroadcast) {\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                mPendingBootAccessoryHandshakeBroadcast = false;\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if (mHideUsbNotification && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && (mUsbCharging || mUsbAccessoryConnected)) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions, boolean forceRestart);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions + \", \"\n                        + \"forceRestart=\" + forceRestart + \", usbDataUnlocked=\" + usbDataUnlocked);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + functions);\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        /**\n         * Proxy object for the usb gadget hal daemon.\n         */\n        @GuardedBy(\"mGadgetProxyLock\")\n        private IUsbGadget mGadgetProxy;\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                ServiceNotification serviceNotification = new ServiceNotification();\n\n                boolean ret = IServiceManager.getService()\n                        .registerForNotifications(GADGET_HAL_FQ_NAME, \"\", serviceNotification);\n                if (!ret) {\n                    Slog.e(TAG, \"Failed to register usb gadget service start notification\");\n                    return;\n                }\n\n                synchronized (mGadgetProxyLock) {\n                    mGadgetProxy = IUsbGadget.getService(true);\n                    mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                            USB_GADGET_HAL_DEATH_COOKIE);\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    mGadgetProxy.getCurrentUsbFunctions(new UsbGadgetCallback());\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n                updateUsbGadgetHalVersion();\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (RemoteException e) {\n                Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mGadgetProxy = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\");\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.i(TAG, \"processing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.i(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.i(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot();\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mGadgetProxy = IUsbGadget.getService();\n                            mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                                    USB_GADGET_HAL_DEATH_COOKIE);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            gadgetProxy.reset();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_2.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxy != null) {\n                                gadgetProxy.getUsbSpeed(new UsbGadgetCallback());\n                            }\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"get UsbSpeed failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                android.hardware.usb.gadget.V1_2.IUsbGadget.castFrom(mGadgetProxy);\n                        if (gadgetProxy == null) {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxyV1By1 =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxyV1By1 == null) {\n                                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                                break;\n                            }\n                            mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_1;\n                            break;\n                        }\n                        mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_2;\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        private class UsbGadgetCallback extends IUsbGadgetCallback.Stub {\n            int mRequest;\n            long mFunctions;\n            boolean mChargingFunctions;\n\n            UsbGadgetCallback() {\n            }\n\n            UsbGadgetCallback(int request, long functions,\n                    boolean chargingFunctions) {\n                mRequest = request;\n                mFunctions = functions;\n                mChargingFunctions = chargingFunctions;\n            }\n\n            @Override\n            public void setCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                /**\n                 * Callback called for a previous setCurrenUsbFunction\n                 */\n                if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                        || (mFunctions != functions)) {\n                    return;\n                }\n\n                removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n                Slog.e(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n                if (status == Status.SUCCESS) {\n                    mCurrentFunctionsApplied = true;\n                } else if (!mChargingFunctions) {\n                    Slog.e(TAG, \"Setting default fuctions\");\n                    sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n                }\n            }\n\n            @Override\n            public void getCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                        status == Status.FUNCTIONS_APPLIED);\n            }\n\n            @Override\n            public void getUsbSpeedCb(int speed) {\n                mUsbSpeed = speed;\n            }\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mGadgetProxy == null) {\n                    Slog.e(TAG, \"setUsbConfig mGadgetProxy is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    UsbGadgetCallback usbGadgetCallback = new UsbGadgetCallback(mCurrentRequest,\n                            config, chargingFunctions);\n                    mGadgetProxy.setCurrentUsbFunctions(config, usbGadgetCallback,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + functions + \", \"\n                        + \"forceRestart=\" + forceRestart);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int pid, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, pid, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n            sEventLogger.dump(dump, UsbHandlerProto.UEVENT);\n        }\n\n        dump.end(token);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native int nativeGetAudioMode();\n}\n```",
            "diff_patched_upstream_only": "--- original_downstream_file\n+++ patched_upstream_only\n@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2011 The Android Open Source Project\n  *\n@@ -2332,5 +2331,4 @@\n     private native boolean nativeIsStartRequested();\n \n     private native int nativeGetAudioMode();\n-}\n-```+}",
            "downstream_llm_diff_output": null,
            "runtime_seconds": 429.54,
            "llm_output_valid": false,
            "attempts_made": 3,
            "validation_results": [
              {
                "attempt": 1,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk diff line expected: @@ -877,7 +877,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 161.59
              },
              {
                "attempt": 2,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk is longer than expected",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 127.64
              },
              {
                "attempt": 3,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk diff line expected: @@ -682,7 +682,7 @@\n",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 140.3
              }
            ],
            "error": "All validation attempts failed",
            "last_format_error": "Invalid patch format: Hunk diff line expected: @@ -682,7 +682,7 @@\n",
            "last_apply_error": "Skipped due to format error"
          }
        ]
      },
      {
        "downstream_version": "12L",
        "gemini_token_usage": 49103,
        "branch_used": "android12L-release",
        "downstream_patch": "643bea502a92329e72585050fb7fa5535456094f",
        "repo_path": "android_repos/base",
        "result": "failure",
        "downstream_patch_content": "commit 643bea502a92329e72585050fb7fa5535456094f\nAuthor: Ashish Kumar Gupta <kumarashishg@google.com>\nDate:   Wed Jul 31 16:02:29 2024 +0000\n\n    Set no data transfer on function switch timeout for accessory mode\n    \n    In case of function switch times out, we will check whether\n    the last function set was accessory. If this is the case, it is\n    recommended to set the function to NONE(No data transfer) rather than\n    setting it to the default USB function.\n    \n    Bug: 353712853\n    Test: Build the code, flash the device and test it.\n    Test: atest CtsUsbManagerTestCases\n    Test: run CtsVerifier tool\n    Test: atest CtsUsbTests\n    Change-Id: I698e9df0333cbb51dd9bd5917a94d81273a2784a\n    Merged-In: I698e9df0333cbb51dd9bd5917a94d81273a2784a\n    (cherry picked from commit 7c6ec68537ba8abf798afd9ab7c3e5889841171f)\n\ndiff --git a/services/usb/java/com/android/server/usb/UsbDeviceManager.java b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\nindex 9f31647e038e..c71b1c13e4c8 100644\n--- a/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -719,7 +719,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit() {\n+        protected void notifyAccessoryModeExit() {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -1957,8 +1957,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      * Dont force to default when the configuration is already set to default.\n                      */\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit();\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:\n",
        "downstream_patch_tokens": {
          "openai": 612,
          "general": {
            "word_based": 247,
            "char_based": 623
          },
          "gemini": 745
        },
        "file_conflicts": [
          {
            "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
            "total_hunks": 3,
            "failed_hunks": [
              1,
              2,
              3
            ],
            "inline_merge_conflicts": [],
            "inline_merge_token_summary": {
              "gemini": 0,
              "openai": 0,
              "general_word": 0,
              "general_char": 0
            },
            "rej_file_content": "```diff\n--- services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -80,9 +80,9 @@ import android.os.storage.StorageVolume;\n import android.provider.Settings;\n import android.service.usb.UsbDeviceManagerProto;\n import android.service.usb.UsbHandlerProto;\n+import android.text.TextUtils;\n import android.util.Pair;\n import android.util.Slog;\n-import android.text.TextUtils;\n \n import com.android.internal.R;\n import com.android.internal.annotations.GuardedBy;\n@@ -880,7 +880,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit(int operationId) {\n+        protected void notifyAccessoryModeExit(int operationId) {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -2313,8 +2313,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      */\n                     operationId = sUsbOperationCount.incrementAndGet();\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit(operationId);\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:\n```",
            "rej_file_tokens": {
              "openai": 370,
              "general": {
                "word_based": 162,
                "char_based": 478
              },
              "gemini": 446
            },
            "patch_apply_output": "patching file services/usb/java/com/android/server/usb/UsbDeviceManager.java\nHunk #1 FAILED at 80.\nHunk #2 FAILED at 880.\nHunk #3 FAILED at 2313.\n3 out of 3 hunks FAILED -- saving rejects to file services/usb/java/com/android/server/usb/UsbDeviceManager.java.rej",
            "inline_merge_output": "patching file services/usb/java/com/android/server/usb/UsbDeviceManager.java\nHunk #1 already applied at 83,86.\nHunk #2 already applied at 883.\nHunk #3 merged at 2291-2297.",
            "upstream_file_content": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport com.android.internal.annotations.Keep;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.text.TextUtils;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.usb.flags.Flags;\nimport com.android.server.usb.hal.gadget.UsbGadgetHal;\nimport com.android.server.usb.hal.gadget.UsbGadgetHalInstance;\nimport com.android.server.utils.EventLogger;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    /**\n     *  UDC controller for the ConfigFS USB Gadgets.\n     */\n    private static final String USB_CONTROLLER_NAME_PROPERTY = \"sys.usb.controller\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String UDC_SUBSYS_MATCH =\n            \"SUBSYSTEM=udc\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final int DUMPSYS_LOG_BUFFER = 200;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    private static EventLogger sEventLogger;\n\n    private static UsbGadgetHal mUsbGadgetHal;\n\n    private final boolean mEnableUdcSysfsUsbStateUpdate;\n    private String mUdcName = \"\";\n\n    /**\n     * Counter for tracking UsbOperation operations.\n     */\n    private static final AtomicInteger sUsbOperationCount = new AtomicInteger();\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n            if (sEventLogger != null) {\n                sEventLogger.enqueue(new EventLogger.StringEvent(\"USB UEVENT: \"\n                        + event.toString()));\n            } else {\n                if (DEBUG) Slog.d(TAG, \"sEventLogger == null\");\n            }\n\n            String accessory = event.get(\"ACCESSORY\");\n\n            if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                mHandler.setAccessoryUEventTime(SystemClock.elapsedRealtime());\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n\n            if (mEnableUdcSysfsUsbStateUpdate) {\n                if (!mUdcName.isEmpty()\n                        && \"udc\".equals(event.get(\"SUBSYSTEM\"))\n                        && event.get(\"DEVPATH\").contains(mUdcName)) {\n                    String action = event.get(\"ACTION\");\n                    if (\"add\".equals(action)) {\n                        nativeStartGadgetMonitor(mUdcName);\n                    } else if (\"remove\".equals(action)) {\n                        nativeStopGadgetMonitor();\n                    }\n                }\n            } else {\n                String state = event.get(\"USB_STATE\");\n                if (state != null) {\n                    mHandler.updateState(state);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n        boolean halNotPresent = false;\n\n        mUsbGadgetHal = UsbGadgetHalInstance.getInstance(this, null);\n        Slog.d(TAG, \"getInstance done\");\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (mUsbGadgetHal == null) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        mHandler.handlerInitDone(operationId);\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT, android.hardware.usb.ParcelableUsbPort.class);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS, android.hardware.usb.UsbPortStatus.class);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n\n        mEnableUdcSysfsUsbStateUpdate =\n                android.hardware.usb.flags.Flags.enableUdcSysfsUsbStateUpdate()\n                && context.getResources().getBoolean(R.bool.config_enableUdcSysfsUsbStateUpdate);\n\n        if (mEnableUdcSysfsUsbStateUpdate) {\n            mUEventObserver.startObserving(UDC_SUBSYS_MATCH);\n            new Thread(\"GetUsbControllerSysprop\") {\n                public void run() {\n                    String udcName;\n                    // blocking wait until usb controller sysprop is available\n                    udcName = nativeWaitAndGetProperty(USB_CONTROLLER_NAME_PROPERTY);\n                    nativeStartGadgetMonitor(udcName);\n                    mUdcName = udcName;\n                    Slog.v(TAG, \"USB controller name \" + udcName);\n                }\n            }.start();\n        } else {\n            mUEventObserver.startObserving(USB_STATE_MATCH);\n        }\n\n        sEventLogger = new EventLogger(DUMPSYS_LOG_BUFFER, \"UsbDeviceManager activity\");\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions, operationId);\n        }\n    }\n\n    //TODO It is not clear that this method serves any purpose (at least on Pixel devices)\n    // consider removing\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.i(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    public static void logAndPrint(int priority, IndentingPrintWriter pw, String msg) {\n        Slog.println(priority, TAG, msg);\n        if (pw != null) {\n            pw.println(msg);\n        }\n    }\n\n    public static void logAndPrintException(IndentingPrintWriter pw, String msg, Exception e) {\n        Slog.e(TAG, msg, e);\n        if (pw != null) {\n            pw.println(msg + e);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mUsbAccessoryConnected;\n        private boolean mInHostModeWithNoAccessoryConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n        private boolean mConnectedToDataDisabledPort;\n        private int mPowerBrickConnectionStatus;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        /**\n         * Do not debounce for the first disconnect after resetUsbGadget.\n         */\n        protected boolean mResetUsbGadgetDisableDebounce;\n        protected boolean mConnected;\n        protected boolean mConfigured;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n        protected boolean mPendingBootAccessoryHandshakeBroadcast;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        protected static final String MTP_PACKAGE_NAME = \"com.android.mtp\";\n        protected static final String MTP_SERVICE_CLASS_NAME = \"com.android.mtp.MtpService\";\n\n        private boolean mIsMtpServiceBound = false;\n\n        /**\n         * {@link ServiceConnection} for {@link MtpService}.\n         */\n        private ServiceConnection mMtpServiceConnection = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName className, IBinder service) {}\n\n            @Override\n            public void onServiceDisconnected(ComponentName arg0) {}\n        };\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public boolean sendMessage(int what) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            return sendMessageDelayed(m,0);\n        }\n\n        public void sendMessage(int what, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, long arg, boolean arg1, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            if (DEBUG) {\n                Slog.i(TAG, \"mResetUsbGadgetDisableDebounce:\" + mResetUsbGadgetDisableDebounce\n                       + \" connected:\" + connected + \"configured:\" + configured);\n            }\n            if (mResetUsbGadgetDisableDebounce) {\n                // Do not debounce disconnect after resetUsbGadget.\n                sendMessage(msg);\n                if (connected == 1) mResetUsbGadgetDisableDebounce = false;\n            } else {\n                if (configured == 0) {\n                    removeMessages(MSG_UPDATE_STATE);\n                    if (DEBUG) Slog.i(TAG, \"removeMessages MSG_UPDATE_STATE\");\n                }\n                if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n                // debounce disconnects to avoid problems bringing up USB tethering.\n                sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n            }\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable, int operationId) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true, operationId);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            int operationId = sUsbOperationCount.incrementAndGet();\n\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit(operationId);\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        protected void notifyAccessoryModeExit(int operationId) {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                        | Intent.FLAG_RECEIVER_FOREGROUND)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            SystemClock.elapsedRealtime());\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n            sEventLogger.enqueue(new EventLogger.StringEvent(\"USB intent: \" + intent));\n        }\n\n        private void getMidiCardDevice() throws FileNotFoundException {\n            String controllerName =  getSystemProperty(USB_CONTROLLER_NAME_PROPERTY, \"\");\n            if (TextUtils.isEmpty(controllerName)) {\n                throw new FileNotFoundException(\"controller name not found\");\n            }\n\n            File soundDir = new File(\"/sys/class/udc/\" + controllerName + \"/gadget/sound\");\n            if (!soundDir.exists()) {\n                throw new FileNotFoundException(\"sound device not found\");\n            }\n\n            // There should be exactly one sound card\n            File[] cardDirs = FileUtils.listFilesOrEmpty(soundDir,\n                                                         (dir, file) -> file.startsWith(\"card\"));\n            if (cardDirs.length != 1) {\n                throw new FileNotFoundException(\"sound card not match\");\n            }\n\n            // There should be exactly one midi device\n            File[] midis = FileUtils.listFilesOrEmpty(cardDirs[0],\n                                                      (dir, file) -> file.startsWith(\"midi\"));\n            if (midis.length != 1) {\n                throw new FileNotFoundException(\"MIDI device not match\");\n            }\n\n            Pattern pattern = Pattern.compile(\"midiC(\\\\d+)D(\\\\d+)\");\n            Matcher matcher = pattern.matcher(midis[0].getName());\n            if (matcher.matches()) {\n                mMidiCard = Integer.parseInt(matcher.group(1));\n                mMidiDevice = Integer.parseInt(matcher.group(2));\n                Slog.i(TAG, \"Found MIDI card \" + mMidiCard + \" device \" + mMidiDevice);\n            } else {\n                throw new FileNotFoundException(\"MIDI name not match\");\n            }\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n            updateMtpFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    if (android.hardware.usb.flags.Flags.enableUsbSysfsMidiIdentification()) {\n                        try {\n                            getMidiCardDevice();\n                        } catch (FileNotFoundException e) {\n                            Slog.e(TAG, \"could not identify MIDI device\", e);\n                            enabled = false;\n                        }\n                    } else {\n                        Scanner scanner = null;\n                        try {\n                            scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                            mMidiCard = scanner.nextInt();\n                            mMidiDevice = scanner.nextInt();\n                        } catch (FileNotFoundException e) {\n                            Slog.e(TAG, \"could not open MIDI file\", e);\n                            enabled = false;\n                        } finally {\n                            if (scanner != null) {\n                                scanner.close();\n                            }\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        /**\n         * Bind to MtpService when MTP or PTP is enabled. This is done to prevent activity manager\n         * from freezing the corresponding process.\n         */\n        private void updateMtpFunction() {\n            if (!Flags.enableBindToMtpService()) {\n                return;\n            }\n\n            boolean mtpEnabled = ((mCurrentFunctions & UsbManager.FUNCTION_MTP) != 0);\n            boolean ptpEnabled = ((mCurrentFunctions & UsbManager.FUNCTION_PTP) != 0);\n\n            if (DEBUG) {\n                Slog.d(TAG, \"updateMtpFunction \"\n                        + \", mtpEnabled: \" + mtpEnabled\n                        + \", ptpEnabled: \" + ptpEnabled\n                        + \", mIsMtpServiceBound: \" + mIsMtpServiceBound\n                );\n            }\n\n            if (mConfigured && (mtpEnabled || ptpEnabled)) {\n                bindToMtpService();\n            } else if (mIsMtpServiceBound) {\n                unbindMtpService();\n            }\n        }\n\n        private void bindToMtpService() {\n            Intent intent = new Intent();\n            intent.setComponent(new ComponentName(MTP_PACKAGE_NAME, MTP_SERVICE_CLASS_NAME));\n\n            if (DEBUG) Slog.d(TAG, \"Binding to MtpService\");\n\n            try {\n                mIsMtpServiceBound = mContext.bindServiceAsUser(\n                    intent,\n                    mMtpServiceConnection,\n                    Context.BIND_AUTO_CREATE,\n                    UserHandle.CURRENT\n                );\n            } catch (SecurityException exception) {\n                Slog.e(TAG, \"Unable to bind to MtpService due to SecurityException\", exception);\n            }\n\n            // Unbinding from the service if binding was not successful to release the connection.\n            // https://developer.android.com/reference/android/content/Context#bindService(android.content.Intent,%20android.content.ServiceConnection,%20int)\n            if (!mIsMtpServiceBound) {\n                unbindMtpService();\n                Slog.e(TAG, \"Binding to MtpService failed\");\n            }\n\n            if (DEBUG && mIsMtpServiceBound) Slog.d(TAG, \"Successfully bound to MtpService\");\n        }\n\n        private void unbindMtpService() {\n            if (DEBUG) Slog.d(TAG, \"Unbinding from MtpService\");\n\n            mContext.unbindService(mMtpServiceConnection);\n            mIsMtpServiceBound = false;\n        }\n\n        private void setScreenUnlockedFunctions(int operationId) {\n            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"handleMessage MSG_UPDATE_STATE \" + \"mConnected:\" + mConnected\n                               + \" mConfigured:\" + mConfigured);\n                    }\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions(operationId);\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n\n                        boolean usbDataDisabled =\n                                status.getUsbDataStatus() != UsbPortStatus.DATA_STATUS_ENABLED;\n                        mConnectedToDataDisabledPort = status.isConnected() && usbDataDisabled;\n                        mPowerBrickConnectionStatus = status.getPowerBrickConnectionStatus();\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                        mConnectedToDataDisabledPort = false;\n                        mPowerBrickConnectionStatus = UsbPortStatus.POWER_BRICK_STATUS_UNKNOWN;\n                    }\n\n                    if (mHostConnected) {\n                        if (!mUsbAccessoryConnected) {\n                            mInHostModeWithNoAccessoryConnected = true;\n                        } else {\n                            mInHostModeWithNoAccessoryConnected = false;\n                        }\n                    } else {\n                        // if not in host mode, reset value to false\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    mUsbAccessoryConnected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + mUsbAccessoryConnected);\n                    }\n\n                    if (!devices.hasNext()) {\n                        mInHostModeWithNoAccessoryConnected = true;\n                    } else {\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1, msg.arg2);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    operationId = (int) msg.arg1;\n                    setEnabledFunctions(functions, false, operationId);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions(operationId);\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions(operationId);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true, operationId);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mBootCompleted = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_USER_SWITCHED: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected\n                                    + \" ,operationId: \" + operationId);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit(operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    if (mBootCompleted) {\n                        broadcastUsbAccessoryHandshake();\n                    } else {\n                        if (DEBUG) Slog.v(TAG, \"Pending broadcasting intent as \"\n                                + \"not boot completed yet.\");\n                        mPendingBootAccessoryHandshakeBroadcast = true;\n                    }\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        public abstract void handlerInitDone(int operationId);\n\n        protected void finishBoot(int operationId) {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions(operationId);\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                } else if (mPendingBootAccessoryHandshakeBroadcast) {\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                mPendingBootAccessoryHandshakeBroadcast = false;\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if ((mHideUsbNotification || mInHostModeWithNoAccessoryConnected)\n                    && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_UVC) {\n                    titleRes = com.android.internal.R.string.usb_uvc_notification_title;\n                    id = SystemMessage.NOTE_USB_UVC;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && (mUsbCharging || mUsbAccessoryConnected)) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            } else if (mSinkPower && mConnectedToDataDisabledPort\n                    && mPowerBrickConnectionStatus != UsbPortStatus.POWER_BRICK_STATUS_CONNECTED) {\n                // Show charging notification when USB Data is disabled on the port, and not\n                // connected to a wall charger.\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions,\n                boolean forceRestart, int operationId);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n\n        public abstract void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions);\n\n        public abstract void getUsbSpeedCb(int speed);\n\n        public abstract void resetCb(int status);\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions,\n                boolean forceRestart, int operationId) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions +\n                        \" ,forceRestart=\" + forceRestart +\n                        \" ,usbDataUnlocked=\" + usbDataUnlocked +\n                        \" ,operationId=\" + operationId);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void getUsbSpeedCb(int speed){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void resetCb(int status){\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            int operationId = sUsbOperationCount.incrementAndGet();\n            try {\n\n                synchronized (mGadgetProxyLock) {\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    updateUsbGadgetHalVersion();\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mUsbGadgetHal = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\"\n                                + \" ,operationId:\" + operationId);\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.i(TAG, \"processing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n                    operationId = msg.arg2;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.i(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.i(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot(operationId);\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 != 1) {\n                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                            notifyAccessoryModeExit(operationId);\n                        } else {\n                            // Set this since default function may be selected from Developer\n                            // options\n                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                        }\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mUsbGadgetHal = UsbGadgetHalInstance.getInstance(mUsbDeviceManager,\n                                    null);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false, operationId);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        if (mUsbGadgetHal == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mUsbGadgetHal is null\");\n                            break;\n                        }\n\n                        try {\n                            // MSG_ACCESSORY_MODE_ENTER_TIMEOUT has to be removed to allow exiting\n                            // AOAP mode during resetUsbGadget.\n                            removeMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n                            if (mConfigured) {\n                                mResetUsbGadgetDisableDebounce = true;\n                            }\n                            mUsbGadgetHal.reset(operationId);\n                        } catch (Exception e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                            mResetUsbGadgetDisableDebounce = false;\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mGadgetHal is null, operationId:\" + operationId);\n                        break;\n                    }\n\n                    try {\n                        mUsbGadgetHal.getUsbSpeed(operationId);\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"get UsbSpeed failed\", e);\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mUsbGadgetHal is null\");\n                        break;\n                    }\n                    else {\n                        try {\n                            mCurrentGadgetHalVersion = mUsbGadgetHal.getGadgetHalVersion();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"update Usb gadget version failed\", e);\n                        }\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n\n            if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                  || (mFunctions != functions)) {\n                return;\n            }\n\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            Slog.i(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n            if (status == Status.SUCCESS) {\n                mCurrentFunctionsApplied = true;\n            } else if (!mChargingFunctions) {\n                Slog.e(TAG, \"Setting default fuctions\");\n                sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n            }\n        }\n\n        @Override\n        public void getUsbSpeedCb(int speed) {\n            mUsbSpeed = speed;\n        }\n\n        @Override\n        public void resetCb(int status) {\n            if (status != Status.SUCCESS)\n                Slog.e(TAG, \"resetCb fail\");\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions, int operationId) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mUsbGadgetHal == null) {\n                    Slog.e(TAG, \"setUsbConfig mUsbGadgetHal is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    mUsbGadgetHal.setCurrentUsbFunctions(mCurrentRequest,\n                            config, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS, operationId);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (Exception e) {//RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart, int operationId) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctionsi \" +\n                        \"functions=\" + functions +\n                        \", forceRestart=\" + forceRestart +\n                        \", operationId=\" + operationId);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions, operationId);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n            mUsbGadgetHal.getCurrentUsbFunctions(operationId);\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int pid, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, pid, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n        mHandler.setCurrentUsbFunctionsCb(functions, status,\n                    mRequest, mFunctions, mChargingFunctions);\n    }\n\n    public void getCurrentUsbFunctionsCb(long functions, int status) {\n        mHandler.sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                    status == Status.FUNCTIONS_APPLIED);\n    }\n\n    public void getUsbSpeedCb(int speed) {\n        mHandler.getUsbSpeedCb(speed);\n    }\n\n    public void resetCb(int status) {\n        mHandler.resetCb(status);\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions, int operationId) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        } else if (functions == UsbManager.FUNCTION_UVC) {\n            // MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_UVC);\n            // TODO: Add MetricsEvent for UVC?\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions, operationId);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        int operationId = sUsbOperationCount.incrementAndGet();\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n            sEventLogger.dump(new DualOutputStreamDumpSink(dump, UsbHandlerProto.UEVENT));\n        }\n\n        dump.end(token);\n    }\n\n    /**\n     * Update usb state (Called by native code).\n     */\n    @Keep\n    private void updateGadgetState(String state) {\n        Slog.d(TAG, \"Usb state update \" + state);\n\n        mHandler.updateState(state);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native String nativeWaitAndGetProperty(String propName);\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native boolean nativeStartGadgetMonitor(String udcName);\n\n    private native void nativeStopGadgetMonitor();\n}\n```",
            "upstream_file_tokens": {
              "openai": 21808,
              "general": {
                "word_based": 8151,
                "char_based": 29003
              },
              "gemini": 25756
            },
            "downstream_file_content": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.IUsbGadget;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.IUsbGadgetCallback;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceManager;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String AUDIO_SOURCE_PCM_PATH =\n            \"/sys/class/android_usb/android0/f_audio_source/pcm\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    private static final int AUDIO_MODE_SOURCE = 1;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n\n            String state = event.get(\"USB_STATE\");\n            String accessory = event.get(\"ACCESSORY\");\n            if (state != null) {\n                mHandler.updateState(state);\n            } else if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                long elapsedRealtime = SystemClock.elapsedRealtime();\n                mHandler.setAccessoryUEventTime(elapsedRealtime);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        boolean halNotPresent = false;\n        try {\n            IUsbGadget.getService(true);\n        } catch (RemoteException e) {\n            Slog.e(TAG, \"USB GADGET HAL present but exception thrown\", e);\n        } catch (NoSuchElementException e) {\n            halNotPresent = true;\n            Slog.i(TAG, \"USB GADGET HAL not present in the device\", e);\n        }\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (halNotPresent) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(USB_STATE_MATCH);\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        boolean enableAudio = (nativeGetAudioMode() == AUDIO_MODE_SOURCE);\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n        if (enableAudio) {\n            functions |= UsbManager.FUNCTION_AUDIO_SOURCE;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions);\n        }\n    }\n\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.e(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mConfigured;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        protected boolean mConnected;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            removeMessages(MSG_UPDATE_STATE);\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            // debounce disconnects to avoid problems bringing up USB tethering\n            sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit();\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        private void notifyAccessoryModeExit() {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            long elapsedRealtime = SystemClock.elapsedRealtime();\n            long accessoryHandShakeEnd = elapsedRealtime;\n\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            accessoryHandShakeEnd);\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n            accessoryHandShakeEnd = 0L;\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    Scanner scanner = null;\n                    try {\n                        scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                        mMidiCard = scanner.nextInt();\n                        mMidiDevice = scanner.nextInt();\n                    } catch (FileNotFoundException e) {\n                        Slog.e(TAG, \"could not open MIDI file\", e);\n                        enabled = false;\n                    } finally {\n                        if (scanner != null) {\n                            scanner.close();\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        private void setScreenUnlockedFunctions() {\n            setEnabledFunctions(mScreenUnlockedFunctions, false);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions();\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    boolean connected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + connected);\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    setEnabledFunctions(functions, false);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions();\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions();\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot();\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    mBootCompleted = true;\n                    finishBoot();\n                    break;\n                case MSG_USER_SWITCHED: {\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit();\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    broadcastUsbAccessoryHandshake();\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        protected void finishBoot() {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions();\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if (mHideUsbNotification && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && mUsbCharging) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions, boolean forceRestart);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions + \", \"\n                        + \"forceRestart=\" + forceRestart + \", usbDataUnlocked=\" + usbDataUnlocked);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + functions);\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        /**\n         * Proxy object for the usb gadget hal daemon.\n         */\n        @GuardedBy(\"mGadgetProxyLock\")\n        private IUsbGadget mGadgetProxy;\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                ServiceNotification serviceNotification = new ServiceNotification();\n\n                boolean ret = IServiceManager.getService()\n                        .registerForNotifications(GADGET_HAL_FQ_NAME, \"\", serviceNotification);\n                if (!ret) {\n                    Slog.e(TAG, \"Failed to register usb gadget service start notification\");\n                    return;\n                }\n\n                synchronized (mGadgetProxyLock) {\n                    mGadgetProxy = IUsbGadget.getService(true);\n                    mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                            USB_GADGET_HAL_DEATH_COOKIE);\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    mGadgetProxy.getCurrentUsbFunctions(new UsbGadgetCallback());\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n                updateUsbGadgetHalVersion();\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (RemoteException e) {\n                Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mGadgetProxy = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\");\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.e(TAG, \"prcessing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.e(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.e(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot();\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mGadgetProxy = IUsbGadget.getService();\n                            mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                                    USB_GADGET_HAL_DEATH_COOKIE);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            gadgetProxy.reset();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_2.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxy != null) {\n                                gadgetProxy.getUsbSpeed(new UsbGadgetCallback());\n                            }\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"get UsbSpeed failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                android.hardware.usb.gadget.V1_2.IUsbGadget.castFrom(mGadgetProxy);\n                        if (gadgetProxy == null) {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxyV1By1 =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxyV1By1 == null) {\n                                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                                break;\n                            }\n                            mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_1;\n                            break;\n                        }\n                        mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_2;\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        private class UsbGadgetCallback extends IUsbGadgetCallback.Stub {\n            int mRequest;\n            long mFunctions;\n            boolean mChargingFunctions;\n\n            UsbGadgetCallback() {\n            }\n\n            UsbGadgetCallback(int request, long functions,\n                    boolean chargingFunctions) {\n                mRequest = request;\n                mFunctions = functions;\n                mChargingFunctions = chargingFunctions;\n            }\n\n            @Override\n            public void setCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                /**\n                 * Callback called for a previous setCurrenUsbFunction\n                 */\n                if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                        || (mFunctions != functions)) {\n                    return;\n                }\n\n                removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n                Slog.e(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n                if (status == Status.SUCCESS) {\n                    mCurrentFunctionsApplied = true;\n                } else if (!mChargingFunctions) {\n                    Slog.e(TAG, \"Setting default fuctions\");\n                    sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n                }\n            }\n\n            @Override\n            public void getCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                        status == Status.FUNCTIONS_APPLIED);\n            }\n\n            @Override\n            public void getUsbSpeedCb(int speed) {\n                mUsbSpeed = speed;\n            }\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mGadgetProxy == null) {\n                    Slog.e(TAG, \"setUsbConfig mGadgetProxy is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    UsbGadgetCallback usbGadgetCallback = new UsbGadgetCallback(mCurrentRequest,\n                            config, chargingFunctions);\n                    mGadgetProxy.setCurrentUsbFunctions(config, usbGadgetCallback,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + functions + \", \"\n                        + \"forceRestart=\" + forceRestart);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n        }\n\n        dump.end(token);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native int nativeGetAudioMode();\n}\n```",
            "downstream_file_tokens": {
              "openai": 18700,
              "general": {
                "word_based": 6980,
                "char_based": 25065
              },
              "gemini": 22156
            },
            "downstream_file_content_ground_truth": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.IUsbGadget;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.IUsbGadgetCallback;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceManager;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String AUDIO_SOURCE_PCM_PATH =\n            \"/sys/class/android_usb/android0/f_audio_source/pcm\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    private static final int AUDIO_MODE_SOURCE = 1;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n\n            String state = event.get(\"USB_STATE\");\n            String accessory = event.get(\"ACCESSORY\");\n            if (state != null) {\n                mHandler.updateState(state);\n            } else if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                long elapsedRealtime = SystemClock.elapsedRealtime();\n                mHandler.setAccessoryUEventTime(elapsedRealtime);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        boolean halNotPresent = false;\n        try {\n            IUsbGadget.getService(true);\n        } catch (RemoteException e) {\n            Slog.e(TAG, \"USB GADGET HAL present but exception thrown\", e);\n        } catch (NoSuchElementException e) {\n            halNotPresent = true;\n            Slog.i(TAG, \"USB GADGET HAL not present in the device\", e);\n        }\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (halNotPresent) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(USB_STATE_MATCH);\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        boolean enableAudio = (nativeGetAudioMode() == AUDIO_MODE_SOURCE);\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n        if (enableAudio) {\n            functions |= UsbManager.FUNCTION_AUDIO_SOURCE;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions);\n        }\n    }\n\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.e(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mConfigured;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        protected boolean mConnected;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            removeMessages(MSG_UPDATE_STATE);\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            // debounce disconnects to avoid problems bringing up USB tethering\n            sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit();\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        protected void notifyAccessoryModeExit() {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            long elapsedRealtime = SystemClock.elapsedRealtime();\n            long accessoryHandShakeEnd = elapsedRealtime;\n\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            accessoryHandShakeEnd);\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n            accessoryHandShakeEnd = 0L;\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    Scanner scanner = null;\n                    try {\n                        scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                        mMidiCard = scanner.nextInt();\n                        mMidiDevice = scanner.nextInt();\n                    } catch (FileNotFoundException e) {\n                        Slog.e(TAG, \"could not open MIDI file\", e);\n                        enabled = false;\n                    } finally {\n                        if (scanner != null) {\n                            scanner.close();\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        private void setScreenUnlockedFunctions() {\n            setEnabledFunctions(mScreenUnlockedFunctions, false);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions();\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    boolean connected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + connected);\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    setEnabledFunctions(functions, false);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions();\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions();\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot();\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    mBootCompleted = true;\n                    finishBoot();\n                    break;\n                case MSG_USER_SWITCHED: {\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit();\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    broadcastUsbAccessoryHandshake();\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        protected void finishBoot() {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions();\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if (mHideUsbNotification && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && mUsbCharging) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions, boolean forceRestart);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions + \", \"\n                        + \"forceRestart=\" + forceRestart + \", usbDataUnlocked=\" + usbDataUnlocked);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + functions);\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        /**\n         * Proxy object for the usb gadget hal daemon.\n         */\n        @GuardedBy(\"mGadgetProxyLock\")\n        private IUsbGadget mGadgetProxy;\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                ServiceNotification serviceNotification = new ServiceNotification();\n\n                boolean ret = IServiceManager.getService()\n                        .registerForNotifications(GADGET_HAL_FQ_NAME, \"\", serviceNotification);\n                if (!ret) {\n                    Slog.e(TAG, \"Failed to register usb gadget service start notification\");\n                    return;\n                }\n\n                synchronized (mGadgetProxyLock) {\n                    mGadgetProxy = IUsbGadget.getService(true);\n                    mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                            USB_GADGET_HAL_DEATH_COOKIE);\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    mGadgetProxy.getCurrentUsbFunctions(new UsbGadgetCallback());\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n                updateUsbGadgetHalVersion();\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (RemoteException e) {\n                Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mGadgetProxy = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\");\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.e(TAG, \"prcessing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.e(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.e(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot();\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    if (msg.arg1 != 1) {\n                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                            notifyAccessoryModeExit();\n                        } else {\n                            // Set this since default function may be selected from Developer\n                            // options\n                            setEnabledFunctions(mScreenUnlockedFunctions, false);\n                        }\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mGadgetProxy = IUsbGadget.getService();\n                            mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                                    USB_GADGET_HAL_DEATH_COOKIE);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            gadgetProxy.reset();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_2.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxy != null) {\n                                gadgetProxy.getUsbSpeed(new UsbGadgetCallback());\n                            }\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"get UsbSpeed failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                android.hardware.usb.gadget.V1_2.IUsbGadget.castFrom(mGadgetProxy);\n                        if (gadgetProxy == null) {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxyV1By1 =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxyV1By1 == null) {\n                                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                                break;\n                            }\n                            mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_1;\n                            break;\n                        }\n                        mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_2;\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        private class UsbGadgetCallback extends IUsbGadgetCallback.Stub {\n            int mRequest;\n            long mFunctions;\n            boolean mChargingFunctions;\n\n            UsbGadgetCallback() {\n            }\n\n            UsbGadgetCallback(int request, long functions,\n                    boolean chargingFunctions) {\n                mRequest = request;\n                mFunctions = functions;\n                mChargingFunctions = chargingFunctions;\n            }\n\n            @Override\n            public void setCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                /**\n                 * Callback called for a previous setCurrenUsbFunction\n                 */\n                if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                        || (mFunctions != functions)) {\n                    return;\n                }\n\n                removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n                Slog.e(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n                if (status == Status.SUCCESS) {\n                    mCurrentFunctionsApplied = true;\n                } else if (!mChargingFunctions) {\n                    Slog.e(TAG, \"Setting default fuctions\");\n                    sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n                }\n            }\n\n            @Override\n            public void getCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                        status == Status.FUNCTIONS_APPLIED);\n            }\n\n            @Override\n            public void getUsbSpeedCb(int speed) {\n                mUsbSpeed = speed;\n            }\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mGadgetProxy == null) {\n                    Slog.e(TAG, \"setUsbConfig mGadgetProxy is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    UsbGadgetCallback usbGadgetCallback = new UsbGadgetCallback(mCurrentRequest,\n                            config, chargingFunctions);\n                    mGadgetProxy.setCurrentUsbFunctions(config, usbGadgetCallback,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + functions + \", \"\n                        + \"forceRestart=\" + forceRestart);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n        }\n\n        dump.end(token);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native int nativeGetAudioMode();\n}",
            "downstream_file_ground_truth_tokens": {
              "openai": 18731,
              "general": {
                "word_based": 6986,
                "char_based": 25125
              },
              "gemini": 22191
            },
            "downstream_file_content_patched_upstream_only": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.IUsbGadget;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.IUsbGadgetCallback;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceManager;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String AUDIO_SOURCE_PCM_PATH =\n            \"/sys/class/android_usb/android0/f_audio_source/pcm\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    private static final int AUDIO_MODE_SOURCE = 1;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n\n            String state = event.get(\"USB_STATE\");\n            String accessory = event.get(\"ACCESSORY\");\n            if (state != null) {\n                mHandler.updateState(state);\n            } else if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                long elapsedRealtime = SystemClock.elapsedRealtime();\n                mHandler.setAccessoryUEventTime(elapsedRealtime);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        boolean halNotPresent = false;\n        try {\n            IUsbGadget.getService(true);\n        } catch (RemoteException e) {\n            Slog.e(TAG, \"USB GADGET HAL present but exception thrown\", e);\n        } catch (NoSuchElementException e) {\n            halNotPresent = true;\n            Slog.i(TAG, \"USB GADGET HAL not present in the device\", e);\n        }\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (halNotPresent) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(USB_STATE_MATCH);\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        boolean enableAudio = (nativeGetAudioMode() == AUDIO_MODE_SOURCE);\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n        if (enableAudio) {\n            functions |= UsbManager.FUNCTION_AUDIO_SOURCE;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions);\n        }\n    }\n\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.e(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mConfigured;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        protected boolean mConnected;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            removeMessages(MSG_UPDATE_STATE);\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            // debounce disconnects to avoid problems bringing up USB tethering\n            sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit();\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        private void notifyAccessoryModeExit() {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            long elapsedRealtime = SystemClock.elapsedRealtime();\n            long accessoryHandShakeEnd = elapsedRealtime;\n\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            accessoryHandShakeEnd);\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n            accessoryHandShakeEnd = 0L;\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    Scanner scanner = null;\n                    try {\n                        scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                        mMidiCard = scanner.nextInt();\n                        mMidiDevice = scanner.nextInt();\n                    } catch (FileNotFoundException e) {\n                        Slog.e(TAG, \"could not open MIDI file\", e);\n                        enabled = false;\n                    } finally {\n                        if (scanner != null) {\n                            scanner.close();\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        private void setScreenUnlockedFunctions() {\n            setEnabledFunctions(mScreenUnlockedFunctions, false);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions();\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    boolean connected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + connected);\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    setEnabledFunctions(functions, false);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions();\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions();\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot();\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    mBootCompleted = true;\n                    finishBoot();\n                    break;\n                case MSG_USER_SWITCHED: {\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit();\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    broadcastUsbAccessoryHandshake();\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        protected void finishBoot() {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions();\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if (mHideUsbNotification && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && mUsbCharging) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions, boolean forceRestart);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions + \", \"\n                        + \"forceRestart=\" + forceRestart + \", usbDataUnlocked=\" + usbDataUnlocked);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + functions);\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        /**\n         * Proxy object for the usb gadget hal daemon.\n         */\n        @GuardedBy(\"mGadgetProxyLock\")\n        private IUsbGadget mGadgetProxy;\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                ServiceNotification serviceNotification = new ServiceNotification();\n\n                boolean ret = IServiceManager.getService()\n                        .registerForNotifications(GADGET_HAL_FQ_NAME, \"\", serviceNotification);\n                if (!ret) {\n                    Slog.e(TAG, \"Failed to register usb gadget service start notification\");\n                    return;\n                }\n\n                synchronized (mGadgetProxyLock) {\n                    mGadgetProxy = IUsbGadget.getService(true);\n                    mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                            USB_GADGET_HAL_DEATH_COOKIE);\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    mGadgetProxy.getCurrentUsbFunctions(new UsbGadgetCallback());\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n                updateUsbGadgetHalVersion();\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (RemoteException e) {\n                Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mGadgetProxy = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\");\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.e(TAG, \"prcessing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.e(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.e(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot();\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mGadgetProxy = IUsbGadget.getService();\n                            mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                                    USB_GADGET_HAL_DEATH_COOKIE);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            gadgetProxy.reset();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_2.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxy != null) {\n                                gadgetProxy.getUsbSpeed(new UsbGadgetCallback());\n                            }\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"get UsbSpeed failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                android.hardware.usb.gadget.V1_2.IUsbGadget.castFrom(mGadgetProxy);\n                        if (gadgetProxy == null) {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxyV1By1 =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxyV1By1 == null) {\n                                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                                break;\n                            }\n                            mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_1;\n                            break;\n                        }\n                        mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_2;\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        private class UsbGadgetCallback extends IUsbGadgetCallback.Stub {\n            int mRequest;\n            long mFunctions;\n            boolean mChargingFunctions;\n\n            UsbGadgetCallback() {\n            }\n\n            UsbGadgetCallback(int request, long functions,\n                    boolean chargingFunctions) {\n                mRequest = request;\n                mFunctions = functions;\n                mChargingFunctions = chargingFunctions;\n            }\n\n            @Override\n            public void setCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                /**\n                 * Callback called for a previous setCurrenUsbFunction\n                 */\n                if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                        || (mFunctions != functions)) {\n                    return;\n                }\n\n                removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n                Slog.e(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n                if (status == Status.SUCCESS) {\n                    mCurrentFunctionsApplied = true;\n                } else if (!mChargingFunctions) {\n                    Slog.e(TAG, \"Setting default fuctions\");\n                    sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n                }\n            }\n\n            @Override\n            public void getCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                        status == Status.FUNCTIONS_APPLIED);\n            }\n\n            @Override\n            public void getUsbSpeedCb(int speed) {\n                mUsbSpeed = speed;\n            }\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mGadgetProxy == null) {\n                    Slog.e(TAG, \"setUsbConfig mGadgetProxy is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    UsbGadgetCallback usbGadgetCallback = new UsbGadgetCallback(mCurrentRequest,\n                            config, chargingFunctions);\n                    mGadgetProxy.setCurrentUsbFunctions(config, usbGadgetCallback,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + functions + \", \"\n                        + \"forceRestart=\" + forceRestart);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n        }\n\n        dump.end(token);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native int nativeGetAudioMode();\n}\n```",
            "diff_patched_upstream_only": "--- original_downstream_file\n+++ patched_upstream_only\n@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2011 The Android Open Source Project\n  *\n@@ -2307,5 +2306,4 @@\n     private native boolean nativeIsStartRequested();\n \n     private native int nativeGetAudioMode();\n-}\n-```+}",
            "downstream_llm_diff_output": null,
            "runtime_seconds": 464.87,
            "llm_output_valid": false,
            "attempts_made": 3,
            "validation_results": [
              {
                "attempt": 1,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk diff line expected: @@ -764,7 +769,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 136.85
              },
              {
                "attempt": 2,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk diff line expected: @@ -616,7 +617,7 @@\n",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 171.95
              },
              {
                "attempt": 3,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk diff line expected: @@ -636,7 +641,8 @@\n",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 156.07
              }
            ],
            "error": "All validation attempts failed",
            "last_format_error": "Invalid patch format: Hunk diff line expected: @@ -636,7 +641,8 @@\n",
            "last_apply_error": "Skipped due to format error"
          }
        ]
      },
      {
        "downstream_version": "12",
        "gemini_token_usage": 49101,
        "branch_used": "android12-release",
        "downstream_patch": "ef6f37e5292ae3491de1857751dc01a319bb61d1",
        "repo_path": "android_repos/base",
        "result": "failure",
        "downstream_patch_content": "commit ef6f37e5292ae3491de1857751dc01a319bb61d1\nAuthor: Ashish Kumar Gupta <kumarashishg@google.com>\nDate:   Wed Jul 31 16:02:29 2024 +0000\n\n    Set no data transfer on function switch timeout for accessory mode\n    \n    In case of function switch times out, we will check whether\n    the last function set was accessory. If this is the case, it is\n    recommended to set the function to NONE(No data transfer) rather than\n    setting it to the default USB function.\n    \n    Bug: 353712853\n    Test: Build the code, flash the device and test it.\n    Test: atest CtsUsbManagerTestCases\n    Test: run CtsVerifier tool\n    Test: atest CtsUsbTests\n    Change-Id: I698e9df0333cbb51dd9bd5917a94d81273a2784a\n    Merged-In: I698e9df0333cbb51dd9bd5917a94d81273a2784a\n    (cherry picked from commit 7c6ec68537ba8abf798afd9ab7c3e5889841171f)\n\ndiff --git a/services/usb/java/com/android/server/usb/UsbDeviceManager.java b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\nindex 9f31647e038e..c71b1c13e4c8 100644\n--- a/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -719,7 +719,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit() {\n+        protected void notifyAccessoryModeExit() {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -1957,8 +1957,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      * Dont force to default when the configuration is already set to default.\n                      */\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit();\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:\n",
        "downstream_patch_tokens": {
          "openai": 614,
          "general": {
            "word_based": 247,
            "char_based": 623
          },
          "gemini": 743
        },
        "file_conflicts": [
          {
            "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
            "total_hunks": 3,
            "failed_hunks": [
              1,
              2,
              3
            ],
            "inline_merge_conflicts": [],
            "inline_merge_token_summary": {
              "gemini": 0,
              "openai": 0,
              "general_word": 0,
              "general_char": 0
            },
            "rej_file_content": "```diff\n--- services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -80,9 +80,9 @@ import android.os.storage.StorageVolume;\n import android.provider.Settings;\n import android.service.usb.UsbDeviceManagerProto;\n import android.service.usb.UsbHandlerProto;\n+import android.text.TextUtils;\n import android.util.Pair;\n import android.util.Slog;\n-import android.text.TextUtils;\n \n import com.android.internal.R;\n import com.android.internal.annotations.GuardedBy;\n@@ -880,7 +880,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit(int operationId) {\n+        protected void notifyAccessoryModeExit(int operationId) {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -2313,8 +2313,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      */\n                     operationId = sUsbOperationCount.incrementAndGet();\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit(operationId);\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:\n```",
            "rej_file_tokens": {
              "openai": 370,
              "general": {
                "word_based": 162,
                "char_based": 478
              },
              "gemini": 446
            },
            "patch_apply_output": "patching file services/usb/java/com/android/server/usb/UsbDeviceManager.java\nHunk #1 FAILED at 80.\nHunk #2 FAILED at 880.\nHunk #3 FAILED at 2313.\n3 out of 3 hunks FAILED -- saving rejects to file services/usb/java/com/android/server/usb/UsbDeviceManager.java.rej",
            "inline_merge_output": "patching file services/usb/java/com/android/server/usb/UsbDeviceManager.java\nHunk #1 already applied at 83,86.\nHunk #2 already applied at 883.\nHunk #3 merged at 2291-2297.",
            "upstream_file_content": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport com.android.internal.annotations.Keep;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.text.TextUtils;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.usb.flags.Flags;\nimport com.android.server.usb.hal.gadget.UsbGadgetHal;\nimport com.android.server.usb.hal.gadget.UsbGadgetHalInstance;\nimport com.android.server.utils.EventLogger;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    /**\n     *  UDC controller for the ConfigFS USB Gadgets.\n     */\n    private static final String USB_CONTROLLER_NAME_PROPERTY = \"sys.usb.controller\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String UDC_SUBSYS_MATCH =\n            \"SUBSYSTEM=udc\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final int DUMPSYS_LOG_BUFFER = 200;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    private static EventLogger sEventLogger;\n\n    private static UsbGadgetHal mUsbGadgetHal;\n\n    private final boolean mEnableUdcSysfsUsbStateUpdate;\n    private String mUdcName = \"\";\n\n    /**\n     * Counter for tracking UsbOperation operations.\n     */\n    private static final AtomicInteger sUsbOperationCount = new AtomicInteger();\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n            if (sEventLogger != null) {\n                sEventLogger.enqueue(new EventLogger.StringEvent(\"USB UEVENT: \"\n                        + event.toString()));\n            } else {\n                if (DEBUG) Slog.d(TAG, \"sEventLogger == null\");\n            }\n\n            String accessory = event.get(\"ACCESSORY\");\n\n            if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                mHandler.setAccessoryUEventTime(SystemClock.elapsedRealtime());\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n\n            if (mEnableUdcSysfsUsbStateUpdate) {\n                if (!mUdcName.isEmpty()\n                        && \"udc\".equals(event.get(\"SUBSYSTEM\"))\n                        && event.get(\"DEVPATH\").contains(mUdcName)) {\n                    String action = event.get(\"ACTION\");\n                    if (\"add\".equals(action)) {\n                        nativeStartGadgetMonitor(mUdcName);\n                    } else if (\"remove\".equals(action)) {\n                        nativeStopGadgetMonitor();\n                    }\n                }\n            } else {\n                String state = event.get(\"USB_STATE\");\n                if (state != null) {\n                    mHandler.updateState(state);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n        boolean halNotPresent = false;\n\n        mUsbGadgetHal = UsbGadgetHalInstance.getInstance(this, null);\n        Slog.d(TAG, \"getInstance done\");\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (mUsbGadgetHal == null) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        mHandler.handlerInitDone(operationId);\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT, android.hardware.usb.ParcelableUsbPort.class);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS, android.hardware.usb.UsbPortStatus.class);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n\n        mEnableUdcSysfsUsbStateUpdate =\n                android.hardware.usb.flags.Flags.enableUdcSysfsUsbStateUpdate()\n                && context.getResources().getBoolean(R.bool.config_enableUdcSysfsUsbStateUpdate);\n\n        if (mEnableUdcSysfsUsbStateUpdate) {\n            mUEventObserver.startObserving(UDC_SUBSYS_MATCH);\n            new Thread(\"GetUsbControllerSysprop\") {\n                public void run() {\n                    String udcName;\n                    // blocking wait until usb controller sysprop is available\n                    udcName = nativeWaitAndGetProperty(USB_CONTROLLER_NAME_PROPERTY);\n                    nativeStartGadgetMonitor(udcName);\n                    mUdcName = udcName;\n                    Slog.v(TAG, \"USB controller name \" + udcName);\n                }\n            }.start();\n        } else {\n            mUEventObserver.startObserving(USB_STATE_MATCH);\n        }\n\n        sEventLogger = new EventLogger(DUMPSYS_LOG_BUFFER, \"UsbDeviceManager activity\");\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions, operationId);\n        }\n    }\n\n    //TODO It is not clear that this method serves any purpose (at least on Pixel devices)\n    // consider removing\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.i(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    public static void logAndPrint(int priority, IndentingPrintWriter pw, String msg) {\n        Slog.println(priority, TAG, msg);\n        if (pw != null) {\n            pw.println(msg);\n        }\n    }\n\n    public static void logAndPrintException(IndentingPrintWriter pw, String msg, Exception e) {\n        Slog.e(TAG, msg, e);\n        if (pw != null) {\n            pw.println(msg + e);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mUsbAccessoryConnected;\n        private boolean mInHostModeWithNoAccessoryConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n        private boolean mConnectedToDataDisabledPort;\n        private int mPowerBrickConnectionStatus;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        /**\n         * Do not debounce for the first disconnect after resetUsbGadget.\n         */\n        protected boolean mResetUsbGadgetDisableDebounce;\n        protected boolean mConnected;\n        protected boolean mConfigured;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n        protected boolean mPendingBootAccessoryHandshakeBroadcast;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        protected static final String MTP_PACKAGE_NAME = \"com.android.mtp\";\n        protected static final String MTP_SERVICE_CLASS_NAME = \"com.android.mtp.MtpService\";\n\n        private boolean mIsMtpServiceBound = false;\n\n        /**\n         * {@link ServiceConnection} for {@link MtpService}.\n         */\n        private ServiceConnection mMtpServiceConnection = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName className, IBinder service) {}\n\n            @Override\n            public void onServiceDisconnected(ComponentName arg0) {}\n        };\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public boolean sendMessage(int what) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            return sendMessageDelayed(m,0);\n        }\n\n        public void sendMessage(int what, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, long arg, boolean arg1, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            if (DEBUG) {\n                Slog.i(TAG, \"mResetUsbGadgetDisableDebounce:\" + mResetUsbGadgetDisableDebounce\n                       + \" connected:\" + connected + \"configured:\" + configured);\n            }\n            if (mResetUsbGadgetDisableDebounce) {\n                // Do not debounce disconnect after resetUsbGadget.\n                sendMessage(msg);\n                if (connected == 1) mResetUsbGadgetDisableDebounce = false;\n            } else {\n                if (configured == 0) {\n                    removeMessages(MSG_UPDATE_STATE);\n                    if (DEBUG) Slog.i(TAG, \"removeMessages MSG_UPDATE_STATE\");\n                }\n                if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n                // debounce disconnects to avoid problems bringing up USB tethering.\n                sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n            }\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable, int operationId) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true, operationId);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            int operationId = sUsbOperationCount.incrementAndGet();\n\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit(operationId);\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        protected void notifyAccessoryModeExit(int operationId) {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                        | Intent.FLAG_RECEIVER_FOREGROUND)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            SystemClock.elapsedRealtime());\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n            sEventLogger.enqueue(new EventLogger.StringEvent(\"USB intent: \" + intent));\n        }\n\n        private void getMidiCardDevice() throws FileNotFoundException {\n            String controllerName =  getSystemProperty(USB_CONTROLLER_NAME_PROPERTY, \"\");\n            if (TextUtils.isEmpty(controllerName)) {\n                throw new FileNotFoundException(\"controller name not found\");\n            }\n\n            File soundDir = new File(\"/sys/class/udc/\" + controllerName + \"/gadget/sound\");\n            if (!soundDir.exists()) {\n                throw new FileNotFoundException(\"sound device not found\");\n            }\n\n            // There should be exactly one sound card\n            File[] cardDirs = FileUtils.listFilesOrEmpty(soundDir,\n                                                         (dir, file) -> file.startsWith(\"card\"));\n            if (cardDirs.length != 1) {\n                throw new FileNotFoundException(\"sound card not match\");\n            }\n\n            // There should be exactly one midi device\n            File[] midis = FileUtils.listFilesOrEmpty(cardDirs[0],\n                                                      (dir, file) -> file.startsWith(\"midi\"));\n            if (midis.length != 1) {\n                throw new FileNotFoundException(\"MIDI device not match\");\n            }\n\n            Pattern pattern = Pattern.compile(\"midiC(\\\\d+)D(\\\\d+)\");\n            Matcher matcher = pattern.matcher(midis[0].getName());\n            if (matcher.matches()) {\n                mMidiCard = Integer.parseInt(matcher.group(1));\n                mMidiDevice = Integer.parseInt(matcher.group(2));\n                Slog.i(TAG, \"Found MIDI card \" + mMidiCard + \" device \" + mMidiDevice);\n            } else {\n                throw new FileNotFoundException(\"MIDI name not match\");\n            }\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n            updateMtpFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    if (android.hardware.usb.flags.Flags.enableUsbSysfsMidiIdentification()) {\n                        try {\n                            getMidiCardDevice();\n                        } catch (FileNotFoundException e) {\n                            Slog.e(TAG, \"could not identify MIDI device\", e);\n                            enabled = false;\n                        }\n                    } else {\n                        Scanner scanner = null;\n                        try {\n                            scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                            mMidiCard = scanner.nextInt();\n                            mMidiDevice = scanner.nextInt();\n                        } catch (FileNotFoundException e) {\n                            Slog.e(TAG, \"could not open MIDI file\", e);\n                            enabled = false;\n                        } finally {\n                            if (scanner != null) {\n                                scanner.close();\n                            }\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        /**\n         * Bind to MtpService when MTP or PTP is enabled. This is done to prevent activity manager\n         * from freezing the corresponding process.\n         */\n        private void updateMtpFunction() {\n            if (!Flags.enableBindToMtpService()) {\n                return;\n            }\n\n            boolean mtpEnabled = ((mCurrentFunctions & UsbManager.FUNCTION_MTP) != 0);\n            boolean ptpEnabled = ((mCurrentFunctions & UsbManager.FUNCTION_PTP) != 0);\n\n            if (DEBUG) {\n                Slog.d(TAG, \"updateMtpFunction \"\n                        + \", mtpEnabled: \" + mtpEnabled\n                        + \", ptpEnabled: \" + ptpEnabled\n                        + \", mIsMtpServiceBound: \" + mIsMtpServiceBound\n                );\n            }\n\n            if (mConfigured && (mtpEnabled || ptpEnabled)) {\n                bindToMtpService();\n            } else if (mIsMtpServiceBound) {\n                unbindMtpService();\n            }\n        }\n\n        private void bindToMtpService() {\n            Intent intent = new Intent();\n            intent.setComponent(new ComponentName(MTP_PACKAGE_NAME, MTP_SERVICE_CLASS_NAME));\n\n            if (DEBUG) Slog.d(TAG, \"Binding to MtpService\");\n\n            try {\n                mIsMtpServiceBound = mContext.bindServiceAsUser(\n                    intent,\n                    mMtpServiceConnection,\n                    Context.BIND_AUTO_CREATE,\n                    UserHandle.CURRENT\n                );\n            } catch (SecurityException exception) {\n                Slog.e(TAG, \"Unable to bind to MtpService due to SecurityException\", exception);\n            }\n\n            // Unbinding from the service if binding was not successful to release the connection.\n            // https://developer.android.com/reference/android/content/Context#bindService(android.content.Intent,%20android.content.ServiceConnection,%20int)\n            if (!mIsMtpServiceBound) {\n                unbindMtpService();\n                Slog.e(TAG, \"Binding to MtpService failed\");\n            }\n\n            if (DEBUG && mIsMtpServiceBound) Slog.d(TAG, \"Successfully bound to MtpService\");\n        }\n\n        private void unbindMtpService() {\n            if (DEBUG) Slog.d(TAG, \"Unbinding from MtpService\");\n\n            mContext.unbindService(mMtpServiceConnection);\n            mIsMtpServiceBound = false;\n        }\n\n        private void setScreenUnlockedFunctions(int operationId) {\n            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"handleMessage MSG_UPDATE_STATE \" + \"mConnected:\" + mConnected\n                               + \" mConfigured:\" + mConfigured);\n                    }\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions(operationId);\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n\n                        boolean usbDataDisabled =\n                                status.getUsbDataStatus() != UsbPortStatus.DATA_STATUS_ENABLED;\n                        mConnectedToDataDisabledPort = status.isConnected() && usbDataDisabled;\n                        mPowerBrickConnectionStatus = status.getPowerBrickConnectionStatus();\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                        mConnectedToDataDisabledPort = false;\n                        mPowerBrickConnectionStatus = UsbPortStatus.POWER_BRICK_STATUS_UNKNOWN;\n                    }\n\n                    if (mHostConnected) {\n                        if (!mUsbAccessoryConnected) {\n                            mInHostModeWithNoAccessoryConnected = true;\n                        } else {\n                            mInHostModeWithNoAccessoryConnected = false;\n                        }\n                    } else {\n                        // if not in host mode, reset value to false\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    mUsbAccessoryConnected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + mUsbAccessoryConnected);\n                    }\n\n                    if (!devices.hasNext()) {\n                        mInHostModeWithNoAccessoryConnected = true;\n                    } else {\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1, msg.arg2);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    operationId = (int) msg.arg1;\n                    setEnabledFunctions(functions, false, operationId);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions(operationId);\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions(operationId);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true, operationId);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mBootCompleted = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_USER_SWITCHED: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected\n                                    + \" ,operationId: \" + operationId);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit(operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    if (mBootCompleted) {\n                        broadcastUsbAccessoryHandshake();\n                    } else {\n                        if (DEBUG) Slog.v(TAG, \"Pending broadcasting intent as \"\n                                + \"not boot completed yet.\");\n                        mPendingBootAccessoryHandshakeBroadcast = true;\n                    }\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        public abstract void handlerInitDone(int operationId);\n\n        protected void finishBoot(int operationId) {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions(operationId);\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                } else if (mPendingBootAccessoryHandshakeBroadcast) {\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                mPendingBootAccessoryHandshakeBroadcast = false;\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if ((mHideUsbNotification || mInHostModeWithNoAccessoryConnected)\n                    && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_UVC) {\n                    titleRes = com.android.internal.R.string.usb_uvc_notification_title;\n                    id = SystemMessage.NOTE_USB_UVC;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && (mUsbCharging || mUsbAccessoryConnected)) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            } else if (mSinkPower && mConnectedToDataDisabledPort\n                    && mPowerBrickConnectionStatus != UsbPortStatus.POWER_BRICK_STATUS_CONNECTED) {\n                // Show charging notification when USB Data is disabled on the port, and not\n                // connected to a wall charger.\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions,\n                boolean forceRestart, int operationId);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n\n        public abstract void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions);\n\n        public abstract void getUsbSpeedCb(int speed);\n\n        public abstract void resetCb(int status);\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions,\n                boolean forceRestart, int operationId) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions +\n                        \" ,forceRestart=\" + forceRestart +\n                        \" ,usbDataUnlocked=\" + usbDataUnlocked +\n                        \" ,operationId=\" + operationId);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void getUsbSpeedCb(int speed){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void resetCb(int status){\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            int operationId = sUsbOperationCount.incrementAndGet();\n            try {\n\n                synchronized (mGadgetProxyLock) {\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    updateUsbGadgetHalVersion();\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mUsbGadgetHal = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\"\n                                + \" ,operationId:\" + operationId);\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.i(TAG, \"processing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n                    operationId = msg.arg2;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.i(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.i(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot(operationId);\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 != 1) {\n                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                            notifyAccessoryModeExit(operationId);\n                        } else {\n                            // Set this since default function may be selected from Developer\n                            // options\n                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                        }\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mUsbGadgetHal = UsbGadgetHalInstance.getInstance(mUsbDeviceManager,\n                                    null);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false, operationId);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        if (mUsbGadgetHal == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mUsbGadgetHal is null\");\n                            break;\n                        }\n\n                        try {\n                            // MSG_ACCESSORY_MODE_ENTER_TIMEOUT has to be removed to allow exiting\n                            // AOAP mode during resetUsbGadget.\n                            removeMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n                            if (mConfigured) {\n                                mResetUsbGadgetDisableDebounce = true;\n                            }\n                            mUsbGadgetHal.reset(operationId);\n                        } catch (Exception e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                            mResetUsbGadgetDisableDebounce = false;\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mGadgetHal is null, operationId:\" + operationId);\n                        break;\n                    }\n\n                    try {\n                        mUsbGadgetHal.getUsbSpeed(operationId);\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"get UsbSpeed failed\", e);\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mUsbGadgetHal is null\");\n                        break;\n                    }\n                    else {\n                        try {\n                            mCurrentGadgetHalVersion = mUsbGadgetHal.getGadgetHalVersion();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"update Usb gadget version failed\", e);\n                        }\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n\n            if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                  || (mFunctions != functions)) {\n                return;\n            }\n\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            Slog.i(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n            if (status == Status.SUCCESS) {\n                mCurrentFunctionsApplied = true;\n            } else if (!mChargingFunctions) {\n                Slog.e(TAG, \"Setting default fuctions\");\n                sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n            }\n        }\n\n        @Override\n        public void getUsbSpeedCb(int speed) {\n            mUsbSpeed = speed;\n        }\n\n        @Override\n        public void resetCb(int status) {\n            if (status != Status.SUCCESS)\n                Slog.e(TAG, \"resetCb fail\");\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions, int operationId) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mUsbGadgetHal == null) {\n                    Slog.e(TAG, \"setUsbConfig mUsbGadgetHal is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    mUsbGadgetHal.setCurrentUsbFunctions(mCurrentRequest,\n                            config, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS, operationId);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (Exception e) {//RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart, int operationId) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctionsi \" +\n                        \"functions=\" + functions +\n                        \", forceRestart=\" + forceRestart +\n                        \", operationId=\" + operationId);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions, operationId);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n            mUsbGadgetHal.getCurrentUsbFunctions(operationId);\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int pid, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, pid, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n        mHandler.setCurrentUsbFunctionsCb(functions, status,\n                    mRequest, mFunctions, mChargingFunctions);\n    }\n\n    public void getCurrentUsbFunctionsCb(long functions, int status) {\n        mHandler.sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                    status == Status.FUNCTIONS_APPLIED);\n    }\n\n    public void getUsbSpeedCb(int speed) {\n        mHandler.getUsbSpeedCb(speed);\n    }\n\n    public void resetCb(int status) {\n        mHandler.resetCb(status);\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions, int operationId) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        } else if (functions == UsbManager.FUNCTION_UVC) {\n            // MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_UVC);\n            // TODO: Add MetricsEvent for UVC?\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions, operationId);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        int operationId = sUsbOperationCount.incrementAndGet();\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n            sEventLogger.dump(new DualOutputStreamDumpSink(dump, UsbHandlerProto.UEVENT));\n        }\n\n        dump.end(token);\n    }\n\n    /**\n     * Update usb state (Called by native code).\n     */\n    @Keep\n    private void updateGadgetState(String state) {\n        Slog.d(TAG, \"Usb state update \" + state);\n\n        mHandler.updateState(state);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native String nativeWaitAndGetProperty(String propName);\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native boolean nativeStartGadgetMonitor(String udcName);\n\n    private native void nativeStopGadgetMonitor();\n}\n```",
            "upstream_file_tokens": {
              "openai": 21808,
              "general": {
                "word_based": 8151,
                "char_based": 29003
              },
              "gemini": 25756
            },
            "downstream_file_content": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.IUsbGadget;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.IUsbGadgetCallback;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceManager;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String AUDIO_SOURCE_PCM_PATH =\n            \"/sys/class/android_usb/android0/f_audio_source/pcm\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    private static final int AUDIO_MODE_SOURCE = 1;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n\n            String state = event.get(\"USB_STATE\");\n            String accessory = event.get(\"ACCESSORY\");\n            if (state != null) {\n                mHandler.updateState(state);\n            } else if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                long elapsedRealtime = SystemClock.elapsedRealtime();\n                mHandler.setAccessoryUEventTime(elapsedRealtime);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        boolean halNotPresent = false;\n        try {\n            IUsbGadget.getService(true);\n        } catch (RemoteException e) {\n            Slog.e(TAG, \"USB GADGET HAL present but exception thrown\", e);\n        } catch (NoSuchElementException e) {\n            halNotPresent = true;\n            Slog.i(TAG, \"USB GADGET HAL not present in the device\", e);\n        }\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (halNotPresent) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(USB_STATE_MATCH);\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        boolean enableAudio = (nativeGetAudioMode() == AUDIO_MODE_SOURCE);\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n        if (enableAudio) {\n            functions |= UsbManager.FUNCTION_AUDIO_SOURCE;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions);\n        }\n    }\n\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.e(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mConfigured;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        protected boolean mConnected;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            removeMessages(MSG_UPDATE_STATE);\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            // debounce disconnects to avoid problems bringing up USB tethering\n            sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit();\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        private void notifyAccessoryModeExit() {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            long elapsedRealtime = SystemClock.elapsedRealtime();\n            long accessoryHandShakeEnd = elapsedRealtime;\n\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            accessoryHandShakeEnd);\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n            accessoryHandShakeEnd = 0L;\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    Scanner scanner = null;\n                    try {\n                        scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                        mMidiCard = scanner.nextInt();\n                        mMidiDevice = scanner.nextInt();\n                    } catch (FileNotFoundException e) {\n                        Slog.e(TAG, \"could not open MIDI file\", e);\n                        enabled = false;\n                    } finally {\n                        if (scanner != null) {\n                            scanner.close();\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        private void setScreenUnlockedFunctions() {\n            setEnabledFunctions(mScreenUnlockedFunctions, false);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions();\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    boolean connected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + connected);\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    setEnabledFunctions(functions, false);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions();\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions();\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot();\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    mBootCompleted = true;\n                    finishBoot();\n                    break;\n                case MSG_USER_SWITCHED: {\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit();\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    broadcastUsbAccessoryHandshake();\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        protected void finishBoot() {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions();\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if (mHideUsbNotification && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && mUsbCharging) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions, boolean forceRestart);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions + \", \"\n                        + \"forceRestart=\" + forceRestart + \", usbDataUnlocked=\" + usbDataUnlocked);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + functions);\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        /**\n         * Proxy object for the usb gadget hal daemon.\n         */\n        @GuardedBy(\"mGadgetProxyLock\")\n        private IUsbGadget mGadgetProxy;\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                ServiceNotification serviceNotification = new ServiceNotification();\n\n                boolean ret = IServiceManager.getService()\n                        .registerForNotifications(GADGET_HAL_FQ_NAME, \"\", serviceNotification);\n                if (!ret) {\n                    Slog.e(TAG, \"Failed to register usb gadget service start notification\");\n                    return;\n                }\n\n                synchronized (mGadgetProxyLock) {\n                    mGadgetProxy = IUsbGadget.getService(true);\n                    mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                            USB_GADGET_HAL_DEATH_COOKIE);\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    mGadgetProxy.getCurrentUsbFunctions(new UsbGadgetCallback());\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n                updateUsbGadgetHalVersion();\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (RemoteException e) {\n                Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mGadgetProxy = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\");\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.e(TAG, \"prcessing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.e(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.e(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot();\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mGadgetProxy = IUsbGadget.getService();\n                            mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                                    USB_GADGET_HAL_DEATH_COOKIE);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            gadgetProxy.reset();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_2.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxy != null) {\n                                gadgetProxy.getUsbSpeed(new UsbGadgetCallback());\n                            }\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"get UsbSpeed failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                android.hardware.usb.gadget.V1_2.IUsbGadget.castFrom(mGadgetProxy);\n                        if (gadgetProxy == null) {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxyV1By1 =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxyV1By1 == null) {\n                                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                                break;\n                            }\n                            mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_1;\n                            break;\n                        }\n                        mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_2;\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        private class UsbGadgetCallback extends IUsbGadgetCallback.Stub {\n            int mRequest;\n            long mFunctions;\n            boolean mChargingFunctions;\n\n            UsbGadgetCallback() {\n            }\n\n            UsbGadgetCallback(int request, long functions,\n                    boolean chargingFunctions) {\n                mRequest = request;\n                mFunctions = functions;\n                mChargingFunctions = chargingFunctions;\n            }\n\n            @Override\n            public void setCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                /**\n                 * Callback called for a previous setCurrenUsbFunction\n                 */\n                if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                        || (mFunctions != functions)) {\n                    return;\n                }\n\n                removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n                Slog.e(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n                if (status == Status.SUCCESS) {\n                    mCurrentFunctionsApplied = true;\n                } else if (!mChargingFunctions) {\n                    Slog.e(TAG, \"Setting default fuctions\");\n                    sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n                }\n            }\n\n            @Override\n            public void getCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                        status == Status.FUNCTIONS_APPLIED);\n            }\n\n            @Override\n            public void getUsbSpeedCb(int speed) {\n                mUsbSpeed = speed;\n            }\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mGadgetProxy == null) {\n                    Slog.e(TAG, \"setUsbConfig mGadgetProxy is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    UsbGadgetCallback usbGadgetCallback = new UsbGadgetCallback(mCurrentRequest,\n                            config, chargingFunctions);\n                    mGadgetProxy.setCurrentUsbFunctions(config, usbGadgetCallback,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + functions + \", \"\n                        + \"forceRestart=\" + forceRestart);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n        }\n\n        dump.end(token);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native int nativeGetAudioMode();\n}\n```",
            "downstream_file_tokens": {
              "openai": 18700,
              "general": {
                "word_based": 6980,
                "char_based": 25065
              },
              "gemini": 22156
            },
            "downstream_file_content_ground_truth": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.IUsbGadget;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.IUsbGadgetCallback;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceManager;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String AUDIO_SOURCE_PCM_PATH =\n            \"/sys/class/android_usb/android0/f_audio_source/pcm\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    private static final int AUDIO_MODE_SOURCE = 1;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n\n            String state = event.get(\"USB_STATE\");\n            String accessory = event.get(\"ACCESSORY\");\n            if (state != null) {\n                mHandler.updateState(state);\n            } else if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                long elapsedRealtime = SystemClock.elapsedRealtime();\n                mHandler.setAccessoryUEventTime(elapsedRealtime);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        boolean halNotPresent = false;\n        try {\n            IUsbGadget.getService(true);\n        } catch (RemoteException e) {\n            Slog.e(TAG, \"USB GADGET HAL present but exception thrown\", e);\n        } catch (NoSuchElementException e) {\n            halNotPresent = true;\n            Slog.i(TAG, \"USB GADGET HAL not present in the device\", e);\n        }\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (halNotPresent) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(USB_STATE_MATCH);\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        boolean enableAudio = (nativeGetAudioMode() == AUDIO_MODE_SOURCE);\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n        if (enableAudio) {\n            functions |= UsbManager.FUNCTION_AUDIO_SOURCE;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions);\n        }\n    }\n\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.e(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mConfigured;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        protected boolean mConnected;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            removeMessages(MSG_UPDATE_STATE);\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            // debounce disconnects to avoid problems bringing up USB tethering\n            sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit();\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        protected void notifyAccessoryModeExit() {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            long elapsedRealtime = SystemClock.elapsedRealtime();\n            long accessoryHandShakeEnd = elapsedRealtime;\n\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            accessoryHandShakeEnd);\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n            accessoryHandShakeEnd = 0L;\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    Scanner scanner = null;\n                    try {\n                        scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                        mMidiCard = scanner.nextInt();\n                        mMidiDevice = scanner.nextInt();\n                    } catch (FileNotFoundException e) {\n                        Slog.e(TAG, \"could not open MIDI file\", e);\n                        enabled = false;\n                    } finally {\n                        if (scanner != null) {\n                            scanner.close();\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        private void setScreenUnlockedFunctions() {\n            setEnabledFunctions(mScreenUnlockedFunctions, false);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions();\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    boolean connected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + connected);\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    setEnabledFunctions(functions, false);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions();\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions();\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot();\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    mBootCompleted = true;\n                    finishBoot();\n                    break;\n                case MSG_USER_SWITCHED: {\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit();\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    broadcastUsbAccessoryHandshake();\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        protected void finishBoot() {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions();\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if (mHideUsbNotification && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && mUsbCharging) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions, boolean forceRestart);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions + \", \"\n                        + \"forceRestart=\" + forceRestart + \", usbDataUnlocked=\" + usbDataUnlocked);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + functions);\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        /**\n         * Proxy object for the usb gadget hal daemon.\n         */\n        @GuardedBy(\"mGadgetProxyLock\")\n        private IUsbGadget mGadgetProxy;\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                ServiceNotification serviceNotification = new ServiceNotification();\n\n                boolean ret = IServiceManager.getService()\n                        .registerForNotifications(GADGET_HAL_FQ_NAME, \"\", serviceNotification);\n                if (!ret) {\n                    Slog.e(TAG, \"Failed to register usb gadget service start notification\");\n                    return;\n                }\n\n                synchronized (mGadgetProxyLock) {\n                    mGadgetProxy = IUsbGadget.getService(true);\n                    mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                            USB_GADGET_HAL_DEATH_COOKIE);\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    mGadgetProxy.getCurrentUsbFunctions(new UsbGadgetCallback());\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n                updateUsbGadgetHalVersion();\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (RemoteException e) {\n                Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mGadgetProxy = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\");\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.e(TAG, \"prcessing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.e(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.e(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot();\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    if (msg.arg1 != 1) {\n                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                            notifyAccessoryModeExit();\n                        } else {\n                            // Set this since default function may be selected from Developer\n                            // options\n                            setEnabledFunctions(mScreenUnlockedFunctions, false);\n                        }\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mGadgetProxy = IUsbGadget.getService();\n                            mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                                    USB_GADGET_HAL_DEATH_COOKIE);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            gadgetProxy.reset();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_2.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxy != null) {\n                                gadgetProxy.getUsbSpeed(new UsbGadgetCallback());\n                            }\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"get UsbSpeed failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                android.hardware.usb.gadget.V1_2.IUsbGadget.castFrom(mGadgetProxy);\n                        if (gadgetProxy == null) {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxyV1By1 =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxyV1By1 == null) {\n                                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                                break;\n                            }\n                            mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_1;\n                            break;\n                        }\n                        mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_2;\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        private class UsbGadgetCallback extends IUsbGadgetCallback.Stub {\n            int mRequest;\n            long mFunctions;\n            boolean mChargingFunctions;\n\n            UsbGadgetCallback() {\n            }\n\n            UsbGadgetCallback(int request, long functions,\n                    boolean chargingFunctions) {\n                mRequest = request;\n                mFunctions = functions;\n                mChargingFunctions = chargingFunctions;\n            }\n\n            @Override\n            public void setCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                /**\n                 * Callback called for a previous setCurrenUsbFunction\n                 */\n                if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                        || (mFunctions != functions)) {\n                    return;\n                }\n\n                removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n                Slog.e(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n                if (status == Status.SUCCESS) {\n                    mCurrentFunctionsApplied = true;\n                } else if (!mChargingFunctions) {\n                    Slog.e(TAG, \"Setting default fuctions\");\n                    sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n                }\n            }\n\n            @Override\n            public void getCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                        status == Status.FUNCTIONS_APPLIED);\n            }\n\n            @Override\n            public void getUsbSpeedCb(int speed) {\n                mUsbSpeed = speed;\n            }\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mGadgetProxy == null) {\n                    Slog.e(TAG, \"setUsbConfig mGadgetProxy is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    UsbGadgetCallback usbGadgetCallback = new UsbGadgetCallback(mCurrentRequest,\n                            config, chargingFunctions);\n                    mGadgetProxy.setCurrentUsbFunctions(config, usbGadgetCallback,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + functions + \", \"\n                        + \"forceRestart=\" + forceRestart);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n        }\n\n        dump.end(token);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native int nativeGetAudioMode();\n}",
            "downstream_file_ground_truth_tokens": {
              "openai": 18731,
              "general": {
                "word_based": 6986,
                "char_based": 25125
              },
              "gemini": 22191
            },
            "downstream_file_content_patched_upstream_only": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.IUsbGadget;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.IUsbGadgetCallback;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceManager;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String AUDIO_SOURCE_PCM_PATH =\n            \"/sys/class/android_usb/android0/f_audio_source/pcm\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    private static final int AUDIO_MODE_SOURCE = 1;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n\n            String state = event.get(\"USB_STATE\");\n            String accessory = event.get(\"ACCESSORY\");\n            if (state != null) {\n                mHandler.updateState(state);\n            } else if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                long elapsedRealtime = SystemClock.elapsedRealtime();\n                mHandler.setAccessoryUEventTime(elapsedRealtime);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        boolean halNotPresent = false;\n        try {\n            IUsbGadget.getService(true);\n        } catch (RemoteException e) {\n            Slog.e(TAG, \"USB GADGET HAL present but exception thrown\", e);\n        } catch (NoSuchElementException e) {\n            halNotPresent = true;\n            Slog.i(TAG, \"USB GADGET HAL not present in the device\", e);\n        }\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (halNotPresent) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(USB_STATE_MATCH);\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        boolean enableAudio = (nativeGetAudioMode() == AUDIO_MODE_SOURCE);\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n        if (enableAudio) {\n            functions |= UsbManager.FUNCTION_AUDIO_SOURCE;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions);\n        }\n    }\n\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.e(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mConfigured;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        protected boolean mConnected;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            removeMessages(MSG_UPDATE_STATE);\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            // debounce disconnects to avoid problems bringing up USB tethering\n            sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit();\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        private void notifyAccessoryModeExit() {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            long elapsedRealtime = SystemClock.elapsedRealtime();\n            long accessoryHandShakeEnd = elapsedRealtime;\n\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            accessoryHandShakeEnd);\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n            accessoryHandShakeEnd = 0L;\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    Scanner scanner = null;\n                    try {\n                        scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                        mMidiCard = scanner.nextInt();\n                        mMidiDevice = scanner.nextInt();\n                    } catch (FileNotFoundException e) {\n                        Slog.e(TAG, \"could not open MIDI file\", e);\n                        enabled = false;\n                    } finally {\n                        if (scanner != null) {\n                            scanner.close();\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        private void setScreenUnlockedFunctions() {\n            setEnabledFunctions(mScreenUnlockedFunctions, false);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions();\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    boolean connected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + connected);\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    setEnabledFunctions(functions, false);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions();\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions();\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot();\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    mBootCompleted = true;\n                    finishBoot();\n                    break;\n                case MSG_USER_SWITCHED: {\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit();\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    broadcastUsbAccessoryHandshake();\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        protected void finishBoot() {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions();\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if (mHideUsbNotification && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && mUsbCharging) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions, boolean forceRestart);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions + \", \"\n                        + \"forceRestart=\" + forceRestart + \", usbDataUnlocked=\" + usbDataUnlocked);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + functions);\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        /**\n         * Proxy object for the usb gadget hal daemon.\n         */\n        @GuardedBy(\"mGadgetProxyLock\")\n        private IUsbGadget mGadgetProxy;\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                ServiceNotification serviceNotification = new ServiceNotification();\n\n                boolean ret = IServiceManager.getService()\n                        .registerForNotifications(GADGET_HAL_FQ_NAME, \"\", serviceNotification);\n                if (!ret) {\n                    Slog.e(TAG, \"Failed to register usb gadget service start notification\");\n                    return;\n                }\n\n                synchronized (mGadgetProxyLock) {\n                    mGadgetProxy = IUsbGadget.getService(true);\n                    mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                            USB_GADGET_HAL_DEATH_COOKIE);\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    mGadgetProxy.getCurrentUsbFunctions(new UsbGadgetCallback());\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n                updateUsbGadgetHalVersion();\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (RemoteException e) {\n                Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mGadgetProxy = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\");\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.e(TAG, \"prcessing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.e(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.e(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot();\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mGadgetProxy = IUsbGadget.getService();\n                            mGadgetProxy.linkToDeath(new UsbGadgetDeathRecipient(),\n                                    USB_GADGET_HAL_DEATH_COOKIE);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"Usb Gadget hal not responding\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            gadgetProxy.reset();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        try {\n                            android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                    android.hardware.usb.gadget.V1_2.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxy != null) {\n                                gadgetProxy.getUsbSpeed(new UsbGadgetCallback());\n                            }\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"get UsbSpeed failed\", e);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    synchronized (mGadgetProxyLock) {\n                        if (mGadgetProxy == null) {\n                            Slog.e(TAG, \"mGadgetProxy is null\");\n                            break;\n                        }\n\n                        android.hardware.usb.gadget.V1_2.IUsbGadget gadgetProxy =\n                                android.hardware.usb.gadget.V1_2.IUsbGadget.castFrom(mGadgetProxy);\n                        if (gadgetProxy == null) {\n                            android.hardware.usb.gadget.V1_1.IUsbGadget gadgetProxyV1By1 =\n                                    android.hardware.usb.gadget.V1_1.IUsbGadget\n                                            .castFrom(mGadgetProxy);\n                            if (gadgetProxyV1By1 == null) {\n                                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                                break;\n                            }\n                            mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_1;\n                            break;\n                        }\n                        mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_2;\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        private class UsbGadgetCallback extends IUsbGadgetCallback.Stub {\n            int mRequest;\n            long mFunctions;\n            boolean mChargingFunctions;\n\n            UsbGadgetCallback() {\n            }\n\n            UsbGadgetCallback(int request, long functions,\n                    boolean chargingFunctions) {\n                mRequest = request;\n                mFunctions = functions;\n                mChargingFunctions = chargingFunctions;\n            }\n\n            @Override\n            public void setCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                /**\n                 * Callback called for a previous setCurrenUsbFunction\n                 */\n                if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                        || (mFunctions != functions)) {\n                    return;\n                }\n\n                removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n                Slog.e(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n                if (status == Status.SUCCESS) {\n                    mCurrentFunctionsApplied = true;\n                } else if (!mChargingFunctions) {\n                    Slog.e(TAG, \"Setting default fuctions\");\n                    sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n                }\n            }\n\n            @Override\n            public void getCurrentUsbFunctionsCb(long functions,\n                    int status) {\n                sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                        status == Status.FUNCTIONS_APPLIED);\n            }\n\n            @Override\n            public void getUsbSpeedCb(int speed) {\n                mUsbSpeed = speed;\n            }\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mGadgetProxy == null) {\n                    Slog.e(TAG, \"setUsbConfig mGadgetProxy is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    UsbGadgetCallback usbGadgetCallback = new UsbGadgetCallback(mCurrentRequest,\n                            config, chargingFunctions);\n                    mGadgetProxy.setCurrentUsbFunctions(config, usbGadgetCallback,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + functions + \", \"\n                        + \"forceRestart=\" + forceRestart);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n        }\n\n        dump.end(token);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native int nativeGetAudioMode();\n}\n```",
            "diff_patched_upstream_only": "--- original_downstream_file\n+++ patched_upstream_only\n@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2011 The Android Open Source Project\n  *\n@@ -2307,5 +2306,4 @@\n     private native boolean nativeIsStartRequested();\n \n     private native int nativeGetAudioMode();\n-}\n-```+}",
            "downstream_llm_diff_output": null,
            "runtime_seconds": 450.92,
            "llm_output_valid": false,
            "attempts_made": 3,
            "validation_results": [
              {
                "attempt": 1,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk is longer than expected",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 171.73
              },
              {
                "attempt": 2,
                "error": "Exception during generation: 500 An internal error has occurred. Please retry or report in https://developers.generativeai.google/guide/troubleshooting",
                "valid": false,
                "format_valid": false,
                "format_error": "Skipped due to exception",
                "apply_valid": false,
                "apply_error": "Skipped due to exception"
              },
              {
                "attempt": 3,
                "format_valid": false,
                "format_error": "Invalid patch format: Hunk diff line expected: ```",
                "apply_valid": false,
                "apply_error": "Skipped due to format error",
                "valid": false,
                "runtime_seconds": 122.94
              }
            ],
            "error": "All validation attempts failed",
            "last_format_error": "Invalid patch format: Hunk diff line expected: ```",
            "last_apply_error": "Skipped due to format error"
          }
        ]
      }
    ]
  }
]