{
    "summary": {
        "total_vulnerabilities_tested": 70,
        "total_versions_tested": 217,
        "total_failed_patches": 80,
        "total_unique_downstream_versions_tested": 217,
        "total_unique_downstream_failed_patches": 80,
        "vulnerabilities_with_all_failures": 0,
        "vulnerabilities_with_partial_failures": 15,
        "vulnerabilities_with_all_successful_patches": 55,
        "vulnerabilities_skipped": 50,
        "severity_counts": {
            "Critical": 15,
            "High": 55,
            "Medium": 0,
            "Low": 0,
            "Unknown": 0
        }
    },
    "vulnerabilities_with_all_failures": [],
    "vulnerabilities_with_partial_failures": [
        {
            "id": "ASB-A-363248394",
            "aliases": [
                "A-363248394",
                "CVE-2024-49742"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-363248394",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "7ae59a42eb13f643d842525208619037c074371a"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 7ae59a42eb13f643d842525208619037c074371a Mon Sep 17 00:00:00 2001\nFrom: Guojing Yuan <guojing@google.com>\nDate: Tue, 1 Oct 2024 21:59:31 +0000\nSubject: [PATCH] [CDM][NLS] Check if the NLS service has an intent-filter\n\nBug: 363248394\nTest: CTS\nFlag: EXEMPT bugfix\nChange-Id: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n---\n ...otificationAccessConfirmationActivity.java | 50 +++++++++++--------\n ...icationAccessConfirmationActivityTest.java |  9 ++--\n 2 files changed, 33 insertions(+), 26 deletions(-)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex 3f300c0fce3..1adeb644155 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -30,13 +30,15 @@ import android.app.admin.DevicePolicyManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -49,6 +51,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -113,6 +117,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -147,19 +176,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -170,12 +186,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();\ndiff --git a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\nindex 9b510fb43e3..0a953615abf 100644\n--- a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n+++ b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n@@ -31,8 +31,6 @@ import android.widget.TextView;\n \n import androidx.annotation.Nullable;\n \n-import com.android.settings.R;\n-\n import com.google.common.base.Strings;\n \n import org.junit.Test;\n@@ -45,15 +43,14 @@ import org.robolectric.RuntimeEnvironment;\n public class NotificationAccessConfirmationActivityTest {\n \n     @Test\n-    public void start_showsDialog() {\n+    public void start_withMissingIntentFilter_finishes() {\n         ComponentName cn = new ComponentName(\"com.example\", \"com.example.SomeService\");\n         installPackage(cn.getPackageName(), \"X\");\n \n         NotificationAccessConfirmationActivity activity = startActivityWithIntent(cn);\n \n-        assertThat(activity.isFinishing()).isFalse();\n-        assertThat(getDialogText(activity)).isEqualTo(\n-                activity.getString(R.string.notification_listener_security_warning_summary, \"X\"));\n+        assertThat(getDialogText(activity)).isNull();\n+        assertThat(activity.isFinishing()).isTrue();\n     }\n \n     @Test\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 2,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "59cdc3e20ca4ac198b1c27e6a5372ececd155b16",
                            "result": "failure",
                            "downstream_patch_content": "commit 59cdc3e20ca4ac198b1c27e6a5372ececd155b16\nAuthor: Guojing Yuan <guojing@google.com>\nDate:   Tue Oct 1 21:59:31 2024 +0000\n\n    [CDM][NLS] Check if the NLS service has an intent-filter\n    \n    Bug: 363248394\n    Test: CTS\n    Flag: EXEMPT bugfix\n    Change-Id: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    Merged-In: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    (cherry picked from commit 7ae59a42eb13f643d842525208619037c074371a)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex a6b565ae6ba..f01e23a5e8f 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -29,12 +29,14 @@ import android.app.NotificationManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -44,6 +46,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -92,6 +96,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -126,19 +155,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -149,12 +165,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();\n",
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/notification/NotificationAccessConfirmationActivity.java",
                                    "total_hunks": 5,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n\n=======\nimport android.os.UserManager;\nimport android.service.notification.NotificationListenerService;\n>>>>>>> UPSTREAM PATCH (commit 7ae59a42eb13f643d842525208619037c074371a)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -30,13 +30,15 @@ import android.app.admin.DevicePolicyManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n```",
                                    "patch_apply_output": "patching file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nHunk #1 FAILED at 30.\nHunk #2 succeeded at 44 (offset -5 lines).\nHunk #3 succeeded at 94 (offset -21 lines).\nHunk #4 succeeded at 153 (offset -21 lines).\nHunk #5 succeeded at 163 (offset -21 lines).\n1 out of 5 hunks FAILED -- saving rejects to file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nHunk #1 merged at 32,36, NOT MERGED at 40-44."
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "59cdc3e20ca4ac198b1c27e6a5372ececd155b16",
                            "result": "failure",
                            "downstream_patch_content": "commit 59cdc3e20ca4ac198b1c27e6a5372ececd155b16\nAuthor: Guojing Yuan <guojing@google.com>\nDate:   Tue Oct 1 21:59:31 2024 +0000\n\n    [CDM][NLS] Check if the NLS service has an intent-filter\n    \n    Bug: 363248394\n    Test: CTS\n    Flag: EXEMPT bugfix\n    Change-Id: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    Merged-In: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    (cherry picked from commit 7ae59a42eb13f643d842525208619037c074371a)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex a6b565ae6ba..f01e23a5e8f 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -29,12 +29,14 @@ import android.app.NotificationManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -44,6 +46,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -92,6 +96,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -126,19 +155,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -149,12 +165,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();\n",
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/notification/NotificationAccessConfirmationActivity.java",
                                    "total_hunks": 5,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n\n=======\nimport android.os.UserManager;\nimport android.service.notification.NotificationListenerService;\n>>>>>>> UPSTREAM PATCH (commit 7ae59a42eb13f643d842525208619037c074371a)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -30,13 +30,15 @@ import android.app.admin.DevicePolicyManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n```",
                                    "patch_apply_output": "patching file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nHunk #1 FAILED at 30.\nHunk #2 succeeded at 44 (offset -5 lines).\nHunk #3 succeeded at 94 (offset -21 lines).\nHunk #4 succeeded at 153 (offset -21 lines).\nHunk #5 succeeded at 163 (offset -21 lines).\n1 out of 5 hunks FAILED -- saving rejects to file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nHunk #1 merged at 32,36, NOT MERGED at 40-44."
                                }
                            ]
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "2b3a057d23dc929e7d4b593550974368ea4f83ef"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "d440f2ef05c20f81e1b1cad447cca427a25d77ec",
                            "result": "success",
                            "downstream_patch_content": "commit d440f2ef05c20f81e1b1cad447cca427a25d77ec\nAuthor: Guojing Yuan <guojing@google.com>\nDate:   Tue Oct 1 21:59:31 2024 +0000\n\n    [CDM][NLS] Check if the NLS service has an intent-filter\n    \n    Bug: 363248394\n    Test: CTS\n    Flag: EXEMPT bugfix\n    Change-Id: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    Merged-In: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    (cherry picked from commit 7ae59a42eb13f643d842525208619037c074371a)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex 9ea8c58024f..74b8102ee2c 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -31,13 +31,15 @@ import android.app.admin.DevicePolicyManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -48,6 +50,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -112,6 +116,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -146,19 +175,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -169,12 +185,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();\n"
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "e4fe2f5b8134c007e29345ae11a64d37e8ef214a",
                            "result": "success",
                            "downstream_patch_content": "commit e4fe2f5b8134c007e29345ae11a64d37e8ef214a\nAuthor: Guojing Yuan <guojing@google.com>\nDate:   Tue Oct 1 21:59:31 2024 +0000\n\n    [CDM][NLS] Check if the NLS service has an intent-filter\n    \n    Bug: 363248394\n    Test: CTS\n    Flag: EXEMPT bugfix\n    Change-Id: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    Merged-In: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    (cherry picked from commit 7ae59a42eb13f643d842525208619037c074371a)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex 9ea8c58024f..74b8102ee2c 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -31,13 +31,15 @@ import android.app.admin.DevicePolicyManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -48,6 +50,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -112,6 +116,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -146,19 +175,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -169,12 +185,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();\ndiff --git a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\nindex 86631ffb2d4..788f853e19b 100644\n--- a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n+++ b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n@@ -30,8 +30,6 @@ import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageInfo;\n import android.widget.TextView;\n \n-import com.android.settings.R;\n-\n import com.google.common.base.Strings;\n \n import org.junit.Test;\n@@ -44,15 +42,14 @@ import org.robolectric.RuntimeEnvironment;\n public class NotificationAccessConfirmationActivityTest {\n \n     @Test\n-    public void start_showsDialog() {\n+    public void start_withMissingIntentFilter_finishes() {\n         ComponentName cn = new ComponentName(\"com.example\", \"com.example.SomeService\");\n         installPackage(cn.getPackageName(), \"X\");\n \n         NotificationAccessConfirmationActivity activity = startActivityWithIntent(cn);\n \n-        assertThat(activity.isFinishing()).isFalse();\n-        assertThat(getDialogText(activity)).isEqualTo(\n-                activity.getString(R.string.notification_listener_security_warning_summary, \"X\"));\n+        assertThat(getDialogText(activity)).isNull();\n+        assertThat(activity.isFinishing()).isTrue();\n     }\n \n     @Test\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-365738306",
            "aliases": [
                "A-365738306",
                "CVE-2024-49733"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-365738306",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "234c5e843ca427b1dd47e91e3969f3309dd787bf"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 234c5e843ca427b1dd47e91e3969f3309dd787bf Mon Sep 17 00:00:00 2001\nFrom: Julia Reynolds <juliacr@google.com>\nDate: Mon, 7 Oct 2024 11:10:31 -0400\nSubject: [PATCH] Always show all approved apps\n\nRegardless of what the current criteria is in order to be approved,\nshow everything that's currently approved, since the criteria might\nhave been more lax when it was approved\n\nTest: manual\nTest: ServiceListingTest\nFlag: EXEMPT bug fix\nBug: 365738306\nChange-Id: I6c19d3dbff6ecabc74729a7f021f293e26601944\n---\n .../applications/ServiceListing.java          | 32 ++++++---\n .../applications/ServiceListingTest.java      | 66 ++++++++++++++++++-\n 2 files changed, 88 insertions(+), 10 deletions(-)\n\ndiff --git a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\nindex c8bcabff1094..261c722e517c 100644\n--- a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n+++ b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n@@ -138,23 +138,37 @@ public class ServiceListing {\n         }\n \n         final PackageManager pmWrapper = mContext.getPackageManager();\n+        // Add requesting apps, with full validation\n         List<ResolveInfo> installedServices = pmWrapper.queryIntentServicesAsUser(\n                 new Intent(mIntentAction), flags, user);\n         for (ResolveInfo resolveInfo : installedServices) {\n             ServiceInfo info = resolveInfo.serviceInfo;\n \n-            if (!mPermission.equals(info.permission)) {\n-                Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n-                        + info.packageName + \"/\" + info.name\n-                        + \": it does not require the permission \"\n-                        + mPermission);\n-                continue;\n+            if (!mEnabledServices.contains(info.getComponentName())) {\n+                if (!mPermission.equals(info.permission)) {\n+                    Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n+                            + info.packageName + \"/\" + info.name\n+                            + \": it does not require the permission \"\n+                            + mPermission);\n+                    continue;\n+                }\n+                if (mValidator != null && !mValidator.test(info)) {\n+                    continue;\n+                }\n+                mServices.add(info);\n             }\n-            if (mValidator != null && !mValidator.test(info)) {\n-                continue;\n+        }\n+\n+        // Add all apps with access, in case prior approval was granted without full validation\n+        for (ComponentName cn : mEnabledServices) {\n+            List<ResolveInfo> enabledServices = pmWrapper.queryIntentServicesAsUser(\n+                    new Intent().setComponent(cn), flags, user);\n+            for (ResolveInfo resolveInfo : enabledServices) {\n+                ServiceInfo info = resolveInfo.serviceInfo;\n+                mServices.add(info);\n             }\n-            mServices.add(info);\n         }\n+\n         for (Callback callback : mCallbacks) {\n             callback.onServicesReloaded(mServices);\n         }\ndiff --git a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\nindex 7ff0988c494d..feef559dfe26 100644\n--- a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n+++ b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n@@ -21,6 +21,7 @@ import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.ArgumentMatchers.argThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.times;\n@@ -29,6 +30,7 @@ import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n import android.content.Context;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n@@ -42,6 +44,7 @@ import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n import org.robolectric.RobolectricTestRunner;\n import org.robolectric.RuntimeEnvironment;\n \n@@ -72,19 +75,26 @@ public class ServiceListingTest {\n                 .build();\n     }\n \n+    private ArgumentMatcher<Intent> filterEquals(Intent intent) {\n+        return (test) -> {\n+            return intent.filterEquals(test);\n+        };\n+    }\n+\n     @Test\n     public void testValidator() {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n         r2.serviceInfo = s2;\n-\n         when(mPm.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(\n                 ImmutableList.of(r1, r2));\n \n@@ -118,9 +128,11 @@ public class ServiceListingTest {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n@@ -193,4 +205,56 @@ public class ServiceListingTest {\n         assertThat(Settings.Secure.getString(RuntimeEnvironment.application.getContentResolver(),\n                 TEST_SETTING)).contains(testComponent2.flattenToString());\n     }\n+\n+    @Test\n+    public void testHasPermissionWithoutMeetingCurrentRegs() {\n+        ServiceInfo s1 = new ServiceInfo();\n+        s1.permission = \"testPermission\";\n+        s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n+        ServiceInfo s2 = new ServiceInfo();\n+        s2.permission = \"testPermission\";\n+        s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n+        ResolveInfo r1 = new ResolveInfo();\n+        r1.serviceInfo = s1;\n+        ResolveInfo r2 = new ResolveInfo();\n+        r2.serviceInfo = s2;\n+\n+        ComponentName approvedComponent = new ComponentName(s2.packageName, s2.name);\n+\n+        Settings.Secure.putString(\n+                mContext.getContentResolver(), TEST_SETTING, approvedComponent.flattenToString());\n+\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent(TEST_INTENT))), anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r1));\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent().setComponent(approvedComponent))),\n+                anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r2));\n+\n+        mServiceListing = new ServiceListing.Builder(mContext)\n+                .setTag(\"testTag\")\n+                .setSetting(TEST_SETTING)\n+                .setNoun(\"testNoun\")\n+                .setIntentAction(TEST_INTENT)\n+                .setValidator(info -> {\n+                    if (info.packageName.equals(\"pkg\")) {\n+                        return true;\n+                    }\n+                    return false;\n+                })\n+                .setPermission(\"testPermission\")\n+                .build();\n+        ServiceListing.Callback callback = mock(ServiceListing.Callback.class);\n+        mServiceListing.addCallback(callback);\n+        mServiceListing.reload();\n+\n+        verify(mPm, times(2)).queryIntentServicesAsUser(any(), anyInt(), anyInt());\n+        ArgumentCaptor<List<ServiceInfo>> captor = ArgumentCaptor.forClass(List.class);\n+        verify(callback, times(1)).onServicesReloaded(captor.capture());\n+\n+        assertThat(captor.getValue()).containsExactlyElementsIn(ImmutableList.of(s2, s1));\n+    }\n }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 1,
                    "failed_patches": 3,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "e81fa0c19c07a5b6509c3f844b69847a96c7a815",
                            "result": "failure",
                            "downstream_patch_content": "commit e81fa0c19c07a5b6509c3f844b69847a96c7a815\nAuthor: Julia Reynolds <juliacr@google.com>\nDate:   Mon Oct 7 11:10:31 2024 -0400\n\n    Always show all approved apps\n    \n    Regardless of what the current criteria is in order to be approved,\n    show everything that's currently approved, since the criteria might\n    have been more lax when it was approved\n    \n    Test: manual\n    Test: ServiceListingTest\n    Flag: EXEMPT bug fix\n    Bug: 365738306\n    Change-Id: I6c19d3dbff6ecabc74729a7f021f293e26601944\n    (cherry picked from commit 234c5e843ca427b1dd47e91e3969f3309dd787bf)\n\ndiff --git a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\nindex c8bcabff1094..261c722e517c 100644\n--- a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n+++ b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n@@ -138,23 +138,37 @@ public class ServiceListing {\n         }\n \n         final PackageManager pmWrapper = mContext.getPackageManager();\n+        // Add requesting apps, with full validation\n         List<ResolveInfo> installedServices = pmWrapper.queryIntentServicesAsUser(\n                 new Intent(mIntentAction), flags, user);\n         for (ResolveInfo resolveInfo : installedServices) {\n             ServiceInfo info = resolveInfo.serviceInfo;\n \n-            if (!mPermission.equals(info.permission)) {\n-                Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n-                        + info.packageName + \"/\" + info.name\n-                        + \": it does not require the permission \"\n-                        + mPermission);\n-                continue;\n+            if (!mEnabledServices.contains(info.getComponentName())) {\n+                if (!mPermission.equals(info.permission)) {\n+                    Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n+                            + info.packageName + \"/\" + info.name\n+                            + \": it does not require the permission \"\n+                            + mPermission);\n+                    continue;\n+                }\n+                if (mValidator != null && !mValidator.test(info)) {\n+                    continue;\n+                }\n+                mServices.add(info);\n             }\n-            if (mValidator != null && !mValidator.test(info)) {\n-                continue;\n+        }\n+\n+        // Add all apps with access, in case prior approval was granted without full validation\n+        for (ComponentName cn : mEnabledServices) {\n+            List<ResolveInfo> enabledServices = pmWrapper.queryIntentServicesAsUser(\n+                    new Intent().setComponent(cn), flags, user);\n+            for (ResolveInfo resolveInfo : enabledServices) {\n+                ServiceInfo info = resolveInfo.serviceInfo;\n+                mServices.add(info);\n             }\n-            mServices.add(info);\n         }\n+\n         for (Callback callback : mCallbacks) {\n             callback.onServicesReloaded(mServices);\n         }\ndiff --git a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\nindex 7ff0988c494d..feef559dfe26 100644\n--- a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n+++ b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n@@ -21,6 +21,7 @@ import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.ArgumentMatchers.argThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.times;\n@@ -29,6 +30,7 @@ import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n import android.content.Context;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n@@ -42,6 +44,7 @@ import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n import org.robolectric.RobolectricTestRunner;\n import org.robolectric.RuntimeEnvironment;\n \n@@ -72,19 +75,26 @@ public class ServiceListingTest {\n                 .build();\n     }\n \n+    private ArgumentMatcher<Intent> filterEquals(Intent intent) {\n+        return (test) -> {\n+            return intent.filterEquals(test);\n+        };\n+    }\n+\n     @Test\n     public void testValidator() {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n         r2.serviceInfo = s2;\n-\n         when(mPm.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(\n                 ImmutableList.of(r1, r2));\n \n@@ -118,9 +128,11 @@ public class ServiceListingTest {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n@@ -193,4 +205,56 @@ public class ServiceListingTest {\n         assertThat(Settings.Secure.getString(RuntimeEnvironment.application.getContentResolver(),\n                 TEST_SETTING)).contains(testComponent2.flattenToString());\n     }\n+\n+    @Test\n+    public void testHasPermissionWithoutMeetingCurrentRegs() {\n+        ServiceInfo s1 = new ServiceInfo();\n+        s1.permission = \"testPermission\";\n+        s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n+        ServiceInfo s2 = new ServiceInfo();\n+        s2.permission = \"testPermission\";\n+        s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n+        ResolveInfo r1 = new ResolveInfo();\n+        r1.serviceInfo = s1;\n+        ResolveInfo r2 = new ResolveInfo();\n+        r2.serviceInfo = s2;\n+\n+        ComponentName approvedComponent = new ComponentName(s2.packageName, s2.name);\n+\n+        Settings.Secure.putString(\n+                mContext.getContentResolver(), TEST_SETTING, approvedComponent.flattenToString());\n+\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent(TEST_INTENT))), anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r1));\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent().setComponent(approvedComponent))),\n+                anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r2));\n+\n+        mServiceListing = new ServiceListing.Builder(mContext)\n+                .setTag(\"testTag\")\n+                .setSetting(TEST_SETTING)\n+                .setNoun(\"testNoun\")\n+                .setIntentAction(TEST_INTENT)\n+                .setValidator(info -> {\n+                    if (info.packageName.equals(\"pkg\")) {\n+                        return true;\n+                    }\n+                    return false;\n+                })\n+                .setPermission(\"testPermission\")\n+                .build();\n+        ServiceListing.Callback callback = mock(ServiceListing.Callback.class);\n+        mServiceListing.addCallback(callback);\n+        mServiceListing.reload();\n+\n+        verify(mPm, times(2)).queryIntentServicesAsUser(any(), anyInt(), anyInt());\n+        ArgumentCaptor<List<ServiceInfo>> captor = ArgumentCaptor.forClass(List.class);\n+        verify(callback, times(1)).onServicesReloaded(captor.capture());\n+\n+        assertThat(captor.getValue()).containsExactlyElementsIn(ImmutableList.of(s2, s1));\n+    }\n }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n            if (!mPermission.equals(info.permission)) {\n                Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n                        + info.packageName + \"/\" + info.name\n                        + \": it does not require the permission \"\n                        + mPermission);\n                continue;\n=======\n            if (!mEnabledServices.contains(info.getComponentName())) {\n                if (!mPermission.equals(info.permission)) {\n                    Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n                            + info.packageName + \"/\" + info.name\n                            + \": it does not require the permission \"\n                            + mPermission);\n                    continue;\n                }\n                if (mValidator != null && !mValidator.test(info)) {\n                    continue;\n                }\n                mServices.add(info);\n            }\n        }\n\n        // Add all apps with access, in case prior approval was granted without full validation\n        for (ComponentName cn : mEnabledServices) {\n            List<ResolveInfo> enabledServices = pmWrapper.queryIntentServicesAsUser(\n                    new Intent().setComponent(cn), flags, user);\n            for (ResolveInfo resolveInfo : enabledServices) {\n                ServiceInfo info = resolveInfo.serviceInfo;\n                mServices.add(info);\n>>>>>>> UPSTREAM PATCH (commit 234c5e843ca427b1dd47e91e3969f3309dd787bf)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n+++ packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n@@ -138,23 +138,37 @@ public class ServiceListing {\n         }\n \n         final PackageManager pmWrapper = mContext.getPackageManager();\n+        // Add requesting apps, with full validation\n         List<ResolveInfo> installedServices = pmWrapper.queryIntentServicesAsUser(\n                 new Intent(mIntentAction), flags, user);\n         for (ResolveInfo resolveInfo : installedServices) {\n             ServiceInfo info = resolveInfo.serviceInfo;\n \n-            if (!mPermission.equals(info.permission)) {\n-                Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n-                        + info.packageName + \"/\" + info.name\n-                        + \": it does not require the permission \"\n-                        + mPermission);\n-                continue;\n+            if (!mEnabledServices.contains(info.getComponentName())) {\n+                if (!mPermission.equals(info.permission)) {\n+                    Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n+                            + info.packageName + \"/\" + info.name\n+                            + \": it does not require the permission \"\n+                            + mPermission);\n+                    continue;\n+                }\n+                if (mValidator != null && !mValidator.test(info)) {\n+                    continue;\n+                }\n+                mServices.add(info);\n             }\n-            if (mValidator != null && !mValidator.test(info)) {\n-                continue;\n+        }\n+\n+        // Add all apps with access, in case prior approval was granted without full validation\n+        for (ComponentName cn : mEnabledServices) {\n+            List<ResolveInfo> enabledServices = pmWrapper.queryIntentServicesAsUser(\n+                    new Intent().setComponent(cn), flags, user);\n+            for (ResolveInfo resolveInfo : enabledServices) {\n+                ServiceInfo info = resolveInfo.serviceInfo;\n+                mServices.add(info);\n             }\n-            mServices.add(info);\n         }\n+\n         for (Callback callback : mCallbacks) {\n             callback.onServicesReloaded(mServices);\n         }\n```",
                                    "patch_apply_output": "patching file packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\nHunk #1 FAILED at 138.\n1 out of 1 hunk FAILED -- saving rejects to file packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java.rej",
                                    "inline_merge_output": "patching file packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\nHunk #1 merged at 138, NOT MERGED at 145-175,177,179."
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "e81fa0c19c07a5b6509c3f844b69847a96c7a815",
                            "result": "failure",
                            "downstream_patch_content": "commit e81fa0c19c07a5b6509c3f844b69847a96c7a815\nAuthor: Julia Reynolds <juliacr@google.com>\nDate:   Mon Oct 7 11:10:31 2024 -0400\n\n    Always show all approved apps\n    \n    Regardless of what the current criteria is in order to be approved,\n    show everything that's currently approved, since the criteria might\n    have been more lax when it was approved\n    \n    Test: manual\n    Test: ServiceListingTest\n    Flag: EXEMPT bug fix\n    Bug: 365738306\n    Change-Id: I6c19d3dbff6ecabc74729a7f021f293e26601944\n    (cherry picked from commit 234c5e843ca427b1dd47e91e3969f3309dd787bf)\n\ndiff --git a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\nindex c8bcabff1094..261c722e517c 100644\n--- a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n+++ b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n@@ -138,23 +138,37 @@ public class ServiceListing {\n         }\n \n         final PackageManager pmWrapper = mContext.getPackageManager();\n+        // Add requesting apps, with full validation\n         List<ResolveInfo> installedServices = pmWrapper.queryIntentServicesAsUser(\n                 new Intent(mIntentAction), flags, user);\n         for (ResolveInfo resolveInfo : installedServices) {\n             ServiceInfo info = resolveInfo.serviceInfo;\n \n-            if (!mPermission.equals(info.permission)) {\n-                Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n-                        + info.packageName + \"/\" + info.name\n-                        + \": it does not require the permission \"\n-                        + mPermission);\n-                continue;\n+            if (!mEnabledServices.contains(info.getComponentName())) {\n+                if (!mPermission.equals(info.permission)) {\n+                    Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n+                            + info.packageName + \"/\" + info.name\n+                            + \": it does not require the permission \"\n+                            + mPermission);\n+                    continue;\n+                }\n+                if (mValidator != null && !mValidator.test(info)) {\n+                    continue;\n+                }\n+                mServices.add(info);\n             }\n-            if (mValidator != null && !mValidator.test(info)) {\n-                continue;\n+        }\n+\n+        // Add all apps with access, in case prior approval was granted without full validation\n+        for (ComponentName cn : mEnabledServices) {\n+            List<ResolveInfo> enabledServices = pmWrapper.queryIntentServicesAsUser(\n+                    new Intent().setComponent(cn), flags, user);\n+            for (ResolveInfo resolveInfo : enabledServices) {\n+                ServiceInfo info = resolveInfo.serviceInfo;\n+                mServices.add(info);\n             }\n-            mServices.add(info);\n         }\n+\n         for (Callback callback : mCallbacks) {\n             callback.onServicesReloaded(mServices);\n         }\ndiff --git a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\nindex 7ff0988c494d..feef559dfe26 100644\n--- a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n+++ b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n@@ -21,6 +21,7 @@ import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.ArgumentMatchers.argThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.times;\n@@ -29,6 +30,7 @@ import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n import android.content.Context;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n@@ -42,6 +44,7 @@ import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n import org.robolectric.RobolectricTestRunner;\n import org.robolectric.RuntimeEnvironment;\n \n@@ -72,19 +75,26 @@ public class ServiceListingTest {\n                 .build();\n     }\n \n+    private ArgumentMatcher<Intent> filterEquals(Intent intent) {\n+        return (test) -> {\n+            return intent.filterEquals(test);\n+        };\n+    }\n+\n     @Test\n     public void testValidator() {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n         r2.serviceInfo = s2;\n-\n         when(mPm.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(\n                 ImmutableList.of(r1, r2));\n \n@@ -118,9 +128,11 @@ public class ServiceListingTest {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n@@ -193,4 +205,56 @@ public class ServiceListingTest {\n         assertThat(Settings.Secure.getString(RuntimeEnvironment.application.getContentResolver(),\n                 TEST_SETTING)).contains(testComponent2.flattenToString());\n     }\n+\n+    @Test\n+    public void testHasPermissionWithoutMeetingCurrentRegs() {\n+        ServiceInfo s1 = new ServiceInfo();\n+        s1.permission = \"testPermission\";\n+        s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n+        ServiceInfo s2 = new ServiceInfo();\n+        s2.permission = \"testPermission\";\n+        s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n+        ResolveInfo r1 = new ResolveInfo();\n+        r1.serviceInfo = s1;\n+        ResolveInfo r2 = new ResolveInfo();\n+        r2.serviceInfo = s2;\n+\n+        ComponentName approvedComponent = new ComponentName(s2.packageName, s2.name);\n+\n+        Settings.Secure.putString(\n+                mContext.getContentResolver(), TEST_SETTING, approvedComponent.flattenToString());\n+\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent(TEST_INTENT))), anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r1));\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent().setComponent(approvedComponent))),\n+                anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r2));\n+\n+        mServiceListing = new ServiceListing.Builder(mContext)\n+                .setTag(\"testTag\")\n+                .setSetting(TEST_SETTING)\n+                .setNoun(\"testNoun\")\n+                .setIntentAction(TEST_INTENT)\n+                .setValidator(info -> {\n+                    if (info.packageName.equals(\"pkg\")) {\n+                        return true;\n+                    }\n+                    return false;\n+                })\n+                .setPermission(\"testPermission\")\n+                .build();\n+        ServiceListing.Callback callback = mock(ServiceListing.Callback.class);\n+        mServiceListing.addCallback(callback);\n+        mServiceListing.reload();\n+\n+        verify(mPm, times(2)).queryIntentServicesAsUser(any(), anyInt(), anyInt());\n+        ArgumentCaptor<List<ServiceInfo>> captor = ArgumentCaptor.forClass(List.class);\n+        verify(callback, times(1)).onServicesReloaded(captor.capture());\n+\n+        assertThat(captor.getValue()).containsExactlyElementsIn(ImmutableList.of(s2, s1));\n+    }\n }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n            if (!mPermission.equals(info.permission)) {\n                Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n                        + info.packageName + \"/\" + info.name\n                        + \": it does not require the permission \"\n                        + mPermission);\n                continue;\n=======\n            if (!mEnabledServices.contains(info.getComponentName())) {\n                if (!mPermission.equals(info.permission)) {\n                    Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n                            + info.packageName + \"/\" + info.name\n                            + \": it does not require the permission \"\n                            + mPermission);\n                    continue;\n                }\n                if (mValidator != null && !mValidator.test(info)) {\n                    continue;\n                }\n                mServices.add(info);\n            }\n        }\n\n        // Add all apps with access, in case prior approval was granted without full validation\n        for (ComponentName cn : mEnabledServices) {\n            List<ResolveInfo> enabledServices = pmWrapper.queryIntentServicesAsUser(\n                    new Intent().setComponent(cn), flags, user);\n            for (ResolveInfo resolveInfo : enabledServices) {\n                ServiceInfo info = resolveInfo.serviceInfo;\n                mServices.add(info);\n>>>>>>> UPSTREAM PATCH (commit 234c5e843ca427b1dd47e91e3969f3309dd787bf)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n+++ packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n@@ -138,23 +138,37 @@ public class ServiceListing {\n         }\n \n         final PackageManager pmWrapper = mContext.getPackageManager();\n+        // Add requesting apps, with full validation\n         List<ResolveInfo> installedServices = pmWrapper.queryIntentServicesAsUser(\n                 new Intent(mIntentAction), flags, user);\n         for (ResolveInfo resolveInfo : installedServices) {\n             ServiceInfo info = resolveInfo.serviceInfo;\n \n-            if (!mPermission.equals(info.permission)) {\n-                Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n-                        + info.packageName + \"/\" + info.name\n-                        + \": it does not require the permission \"\n-                        + mPermission);\n-                continue;\n+            if (!mEnabledServices.contains(info.getComponentName())) {\n+                if (!mPermission.equals(info.permission)) {\n+                    Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n+                            + info.packageName + \"/\" + info.name\n+                            + \": it does not require the permission \"\n+                            + mPermission);\n+                    continue;\n+                }\n+                if (mValidator != null && !mValidator.test(info)) {\n+                    continue;\n+                }\n+                mServices.add(info);\n             }\n-            if (mValidator != null && !mValidator.test(info)) {\n-                continue;\n+        }\n+\n+        // Add all apps with access, in case prior approval was granted without full validation\n+        for (ComponentName cn : mEnabledServices) {\n+            List<ResolveInfo> enabledServices = pmWrapper.queryIntentServicesAsUser(\n+                    new Intent().setComponent(cn), flags, user);\n+            for (ResolveInfo resolveInfo : enabledServices) {\n+                ServiceInfo info = resolveInfo.serviceInfo;\n+                mServices.add(info);\n             }\n-            mServices.add(info);\n         }\n+\n         for (Callback callback : mCallbacks) {\n             callback.onServicesReloaded(mServices);\n         }\n```",
                                    "patch_apply_output": "patching file packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\nHunk #1 FAILED at 138.\n1 out of 1 hunk FAILED -- saving rejects to file packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java.rej",
                                    "inline_merge_output": "patching file packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\nHunk #1 merged at 138, NOT MERGED at 145-175,177,179."
                                }
                            ]
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "3c44dd35fd99b87e8754a2c67f29b221ef3f69a5"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "e81fa0c19c07a5b6509c3f844b69847a96c7a815",
                            "result": "failure",
                            "downstream_patch_content": "commit e81fa0c19c07a5b6509c3f844b69847a96c7a815\nAuthor: Julia Reynolds <juliacr@google.com>\nDate:   Mon Oct 7 11:10:31 2024 -0400\n\n    Always show all approved apps\n    \n    Regardless of what the current criteria is in order to be approved,\n    show everything that's currently approved, since the criteria might\n    have been more lax when it was approved\n    \n    Test: manual\n    Test: ServiceListingTest\n    Flag: EXEMPT bug fix\n    Bug: 365738306\n    Change-Id: I6c19d3dbff6ecabc74729a7f021f293e26601944\n    (cherry picked from commit 234c5e843ca427b1dd47e91e3969f3309dd787bf)\n\ndiff --git a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\nindex c8bcabff1094..261c722e517c 100644\n--- a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n+++ b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n@@ -138,23 +138,37 @@ public class ServiceListing {\n         }\n \n         final PackageManager pmWrapper = mContext.getPackageManager();\n+        // Add requesting apps, with full validation\n         List<ResolveInfo> installedServices = pmWrapper.queryIntentServicesAsUser(\n                 new Intent(mIntentAction), flags, user);\n         for (ResolveInfo resolveInfo : installedServices) {\n             ServiceInfo info = resolveInfo.serviceInfo;\n \n-            if (!mPermission.equals(info.permission)) {\n-                Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n-                        + info.packageName + \"/\" + info.name\n-                        + \": it does not require the permission \"\n-                        + mPermission);\n-                continue;\n+            if (!mEnabledServices.contains(info.getComponentName())) {\n+                if (!mPermission.equals(info.permission)) {\n+                    Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n+                            + info.packageName + \"/\" + info.name\n+                            + \": it does not require the permission \"\n+                            + mPermission);\n+                    continue;\n+                }\n+                if (mValidator != null && !mValidator.test(info)) {\n+                    continue;\n+                }\n+                mServices.add(info);\n             }\n-            if (mValidator != null && !mValidator.test(info)) {\n-                continue;\n+        }\n+\n+        // Add all apps with access, in case prior approval was granted without full validation\n+        for (ComponentName cn : mEnabledServices) {\n+            List<ResolveInfo> enabledServices = pmWrapper.queryIntentServicesAsUser(\n+                    new Intent().setComponent(cn), flags, user);\n+            for (ResolveInfo resolveInfo : enabledServices) {\n+                ServiceInfo info = resolveInfo.serviceInfo;\n+                mServices.add(info);\n             }\n-            mServices.add(info);\n         }\n+\n         for (Callback callback : mCallbacks) {\n             callback.onServicesReloaded(mServices);\n         }\ndiff --git a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\nindex 7ff0988c494d..feef559dfe26 100644\n--- a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n+++ b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n@@ -21,6 +21,7 @@ import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.ArgumentMatchers.argThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.times;\n@@ -29,6 +30,7 @@ import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n import android.content.Context;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n@@ -42,6 +44,7 @@ import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n import org.robolectric.RobolectricTestRunner;\n import org.robolectric.RuntimeEnvironment;\n \n@@ -72,19 +75,26 @@ public class ServiceListingTest {\n                 .build();\n     }\n \n+    private ArgumentMatcher<Intent> filterEquals(Intent intent) {\n+        return (test) -> {\n+            return intent.filterEquals(test);\n+        };\n+    }\n+\n     @Test\n     public void testValidator() {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n         r2.serviceInfo = s2;\n-\n         when(mPm.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(\n                 ImmutableList.of(r1, r2));\n \n@@ -118,9 +128,11 @@ public class ServiceListingTest {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n@@ -193,4 +205,56 @@ public class ServiceListingTest {\n         assertThat(Settings.Secure.getString(RuntimeEnvironment.application.getContentResolver(),\n                 TEST_SETTING)).contains(testComponent2.flattenToString());\n     }\n+\n+    @Test\n+    public void testHasPermissionWithoutMeetingCurrentRegs() {\n+        ServiceInfo s1 = new ServiceInfo();\n+        s1.permission = \"testPermission\";\n+        s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n+        ServiceInfo s2 = new ServiceInfo();\n+        s2.permission = \"testPermission\";\n+        s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n+        ResolveInfo r1 = new ResolveInfo();\n+        r1.serviceInfo = s1;\n+        ResolveInfo r2 = new ResolveInfo();\n+        r2.serviceInfo = s2;\n+\n+        ComponentName approvedComponent = new ComponentName(s2.packageName, s2.name);\n+\n+        Settings.Secure.putString(\n+                mContext.getContentResolver(), TEST_SETTING, approvedComponent.flattenToString());\n+\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent(TEST_INTENT))), anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r1));\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent().setComponent(approvedComponent))),\n+                anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r2));\n+\n+        mServiceListing = new ServiceListing.Builder(mContext)\n+                .setTag(\"testTag\")\n+                .setSetting(TEST_SETTING)\n+                .setNoun(\"testNoun\")\n+                .setIntentAction(TEST_INTENT)\n+                .setValidator(info -> {\n+                    if (info.packageName.equals(\"pkg\")) {\n+                        return true;\n+                    }\n+                    return false;\n+                })\n+                .setPermission(\"testPermission\")\n+                .build();\n+        ServiceListing.Callback callback = mock(ServiceListing.Callback.class);\n+        mServiceListing.addCallback(callback);\n+        mServiceListing.reload();\n+\n+        verify(mPm, times(2)).queryIntentServicesAsUser(any(), anyInt(), anyInt());\n+        ArgumentCaptor<List<ServiceInfo>> captor = ArgumentCaptor.forClass(List.class);\n+        verify(callback, times(1)).onServicesReloaded(captor.capture());\n+\n+        assertThat(captor.getValue()).containsExactlyElementsIn(ImmutableList.of(s2, s1));\n+    }\n }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n            if (!mPermission.equals(info.permission)) {\n                Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n                        + info.packageName + \"/\" + info.name\n                        + \": it does not require the permission \"\n                        + mPermission);\n                continue;\n=======\n            if (!mEnabledServices.contains(info.getComponentName())) {\n                if (!mPermission.equals(info.permission)) {\n                    Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n                            + info.packageName + \"/\" + info.name\n                            + \": it does not require the permission \"\n                            + mPermission);\n                    continue;\n                }\n                if (mValidator != null && !mValidator.test(info)) {\n                    continue;\n                }\n                mServices.add(info);\n            }\n        }\n\n        // Add all apps with access, in case prior approval was granted without full validation\n        for (ComponentName cn : mEnabledServices) {\n            List<ResolveInfo> enabledServices = pmWrapper.queryIntentServicesAsUser(\n                    new Intent().setComponent(cn), flags, user);\n            for (ResolveInfo resolveInfo : enabledServices) {\n                ServiceInfo info = resolveInfo.serviceInfo;\n                mServices.add(info);\n>>>>>>> UPSTREAM PATCH (commit 234c5e843ca427b1dd47e91e3969f3309dd787bf)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n+++ packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n@@ -138,23 +138,37 @@ public class ServiceListing {\n         }\n \n         final PackageManager pmWrapper = mContext.getPackageManager();\n+        // Add requesting apps, with full validation\n         List<ResolveInfo> installedServices = pmWrapper.queryIntentServicesAsUser(\n                 new Intent(mIntentAction), flags, user);\n         for (ResolveInfo resolveInfo : installedServices) {\n             ServiceInfo info = resolveInfo.serviceInfo;\n \n-            if (!mPermission.equals(info.permission)) {\n-                Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n-                        + info.packageName + \"/\" + info.name\n-                        + \": it does not require the permission \"\n-                        + mPermission);\n-                continue;\n+            if (!mEnabledServices.contains(info.getComponentName())) {\n+                if (!mPermission.equals(info.permission)) {\n+                    Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n+                            + info.packageName + \"/\" + info.name\n+                            + \": it does not require the permission \"\n+                            + mPermission);\n+                    continue;\n+                }\n+                if (mValidator != null && !mValidator.test(info)) {\n+                    continue;\n+                }\n+                mServices.add(info);\n             }\n-            if (mValidator != null && !mValidator.test(info)) {\n-                continue;\n+        }\n+\n+        // Add all apps with access, in case prior approval was granted without full validation\n+        for (ComponentName cn : mEnabledServices) {\n+            List<ResolveInfo> enabledServices = pmWrapper.queryIntentServicesAsUser(\n+                    new Intent().setComponent(cn), flags, user);\n+            for (ResolveInfo resolveInfo : enabledServices) {\n+                ServiceInfo info = resolveInfo.serviceInfo;\n+                mServices.add(info);\n             }\n-            mServices.add(info);\n         }\n+\n         for (Callback callback : mCallbacks) {\n             callback.onServicesReloaded(mServices);\n         }\n```",
                                    "patch_apply_output": "patching file packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\nHunk #1 FAILED at 138.\n1 out of 1 hunk FAILED -- saving rejects to file packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java.rej",
                                    "inline_merge_output": "patching file packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\nHunk #1 merged at 138, NOT MERGED at 145-175,177,179."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "e81fa0c19c07a5b6509c3f844b69847a96c7a815",
                            "result": "success",
                            "downstream_patch_content": "commit e81fa0c19c07a5b6509c3f844b69847a96c7a815\nAuthor: Julia Reynolds <juliacr@google.com>\nDate:   Mon Oct 7 11:10:31 2024 -0400\n\n    Always show all approved apps\n    \n    Regardless of what the current criteria is in order to be approved,\n    show everything that's currently approved, since the criteria might\n    have been more lax when it was approved\n    \n    Test: manual\n    Test: ServiceListingTest\n    Flag: EXEMPT bug fix\n    Bug: 365738306\n    Change-Id: I6c19d3dbff6ecabc74729a7f021f293e26601944\n    (cherry picked from commit 234c5e843ca427b1dd47e91e3969f3309dd787bf)\n\ndiff --git a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\nindex c8bcabff1094..261c722e517c 100644\n--- a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n+++ b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n@@ -138,23 +138,37 @@ public class ServiceListing {\n         }\n \n         final PackageManager pmWrapper = mContext.getPackageManager();\n+        // Add requesting apps, with full validation\n         List<ResolveInfo> installedServices = pmWrapper.queryIntentServicesAsUser(\n                 new Intent(mIntentAction), flags, user);\n         for (ResolveInfo resolveInfo : installedServices) {\n             ServiceInfo info = resolveInfo.serviceInfo;\n \n-            if (!mPermission.equals(info.permission)) {\n-                Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n-                        + info.packageName + \"/\" + info.name\n-                        + \": it does not require the permission \"\n-                        + mPermission);\n-                continue;\n+            if (!mEnabledServices.contains(info.getComponentName())) {\n+                if (!mPermission.equals(info.permission)) {\n+                    Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n+                            + info.packageName + \"/\" + info.name\n+                            + \": it does not require the permission \"\n+                            + mPermission);\n+                    continue;\n+                }\n+                if (mValidator != null && !mValidator.test(info)) {\n+                    continue;\n+                }\n+                mServices.add(info);\n             }\n-            if (mValidator != null && !mValidator.test(info)) {\n-                continue;\n+        }\n+\n+        // Add all apps with access, in case prior approval was granted without full validation\n+        for (ComponentName cn : mEnabledServices) {\n+            List<ResolveInfo> enabledServices = pmWrapper.queryIntentServicesAsUser(\n+                    new Intent().setComponent(cn), flags, user);\n+            for (ResolveInfo resolveInfo : enabledServices) {\n+                ServiceInfo info = resolveInfo.serviceInfo;\n+                mServices.add(info);\n             }\n-            mServices.add(info);\n         }\n+\n         for (Callback callback : mCallbacks) {\n             callback.onServicesReloaded(mServices);\n         }\ndiff --git a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\nindex 7ff0988c494d..feef559dfe26 100644\n--- a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n+++ b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n@@ -21,6 +21,7 @@ import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.ArgumentMatchers.argThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.times;\n@@ -29,6 +30,7 @@ import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n import android.content.Context;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n@@ -42,6 +44,7 @@ import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n import org.robolectric.RobolectricTestRunner;\n import org.robolectric.RuntimeEnvironment;\n \n@@ -72,19 +75,26 @@ public class ServiceListingTest {\n                 .build();\n     }\n \n+    private ArgumentMatcher<Intent> filterEquals(Intent intent) {\n+        return (test) -> {\n+            return intent.filterEquals(test);\n+        };\n+    }\n+\n     @Test\n     public void testValidator() {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n         r2.serviceInfo = s2;\n-\n         when(mPm.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(\n                 ImmutableList.of(r1, r2));\n \n@@ -118,9 +128,11 @@ public class ServiceListingTest {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n@@ -193,4 +205,56 @@ public class ServiceListingTest {\n         assertThat(Settings.Secure.getString(RuntimeEnvironment.application.getContentResolver(),\n                 TEST_SETTING)).contains(testComponent2.flattenToString());\n     }\n+\n+    @Test\n+    public void testHasPermissionWithoutMeetingCurrentRegs() {\n+        ServiceInfo s1 = new ServiceInfo();\n+        s1.permission = \"testPermission\";\n+        s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n+        ServiceInfo s2 = new ServiceInfo();\n+        s2.permission = \"testPermission\";\n+        s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n+        ResolveInfo r1 = new ResolveInfo();\n+        r1.serviceInfo = s1;\n+        ResolveInfo r2 = new ResolveInfo();\n+        r2.serviceInfo = s2;\n+\n+        ComponentName approvedComponent = new ComponentName(s2.packageName, s2.name);\n+\n+        Settings.Secure.putString(\n+                mContext.getContentResolver(), TEST_SETTING, approvedComponent.flattenToString());\n+\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent(TEST_INTENT))), anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r1));\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent().setComponent(approvedComponent))),\n+                anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r2));\n+\n+        mServiceListing = new ServiceListing.Builder(mContext)\n+                .setTag(\"testTag\")\n+                .setSetting(TEST_SETTING)\n+                .setNoun(\"testNoun\")\n+                .setIntentAction(TEST_INTENT)\n+                .setValidator(info -> {\n+                    if (info.packageName.equals(\"pkg\")) {\n+                        return true;\n+                    }\n+                    return false;\n+                })\n+                .setPermission(\"testPermission\")\n+                .build();\n+        ServiceListing.Callback callback = mock(ServiceListing.Callback.class);\n+        mServiceListing.addCallback(callback);\n+        mServiceListing.reload();\n+\n+        verify(mPm, times(2)).queryIntentServicesAsUser(any(), anyInt(), anyInt());\n+        ArgumentCaptor<List<ServiceInfo>> captor = ArgumentCaptor.forClass(List.class);\n+        verify(callback, times(1)).onServicesReloaded(captor.capture());\n+\n+        assertThat(captor.getValue()).containsExactlyElementsIn(ImmutableList.of(s2, s1));\n+    }\n }\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-277207798",
            "aliases": [
                "A-277207798",
                "CVE-2025-22416"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-277207798",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "bad47a2280c7107e1213f4adc5a3825a62698d00"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From bad47a2280c7107e1213f4adc5a3825a62698d00 Mon Sep 17 00:00:00 2001\nFrom: Andrey Yepin <ayepin@google.com>\nDate: Mon, 9 Dec 2024 21:34:17 -0800\nSubject: [PATCH] Verify that the caller has permissions for the icons it\n provided.\n\nBug: 277207798\nTest: manual testing: first reroduce the issue as described in the\n ticket then check that it is not reproduceable after the fix.\nChange-Id: I08992550507572a4878c501184360a58adef53ad\n---\n .../android/internal/app/ChooserActivity.java | 50 ++++++++++++++++++-\n 1 file changed, 49 insertions(+), 1 deletion(-)\n\ndiff --git a/core/java/com/android/internal/app/ChooserActivity.java b/core/java/com/android/internal/app/ChooserActivity.java\nindex f9d553ffc0c1..ebd015f1c429 100644\n--- a/core/java/com/android/internal/app/ChooserActivity.java\n+++ b/core/java/com/android/internal/app/ChooserActivity.java\n@@ -21,6 +21,7 @@ import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_PERSONAL;\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_WORK;\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CROSS_PROFILE_BLOCKED_TITLE;\n+import static android.content.ContentProvider.getUriWithoutUserId;\n import static android.content.ContentProvider.getUserIdFromUri;\n import static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_PERSONAL;\n import static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_WORK;\n@@ -40,7 +41,9 @@ import android.annotation.Nullable;\n import android.app.Activity;\n import android.app.ActivityManager;\n import android.app.ActivityOptions;\n+import android.app.IUriGrantsManager;\n import android.app.SharedElementCallback;\n+import android.app.UriGrantsManager;\n import android.app.prediction.AppPredictionContext;\n import android.app.prediction.AppPredictionManager;\n import android.app.prediction.AppPredictor;\n@@ -77,6 +80,7 @@ import android.graphics.Paint;\n import android.graphics.Path;\n import android.graphics.drawable.AnimatedVectorDrawable;\n import android.graphics.drawable.Drawable;\n+import android.graphics.drawable.Icon;\n import android.metrics.LogMaker;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -86,6 +90,7 @@ import android.os.Handler;\n import android.os.Message;\n import android.os.Parcelable;\n import android.os.PatternMatcher;\n+import android.os.RemoteException;\n import android.os.ResultReceiver;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -692,7 +697,11 @@ public class ChooserActivity extends ResolverActivity implements\n                     targets = null;\n                     break;\n                 }\n-                targets[i] = (ChooserTarget) pa[i];\n+                ChooserTarget chooserTarget = (ChooserTarget) pa[i];\n+                if (!hasValidIcon(chooserTarget)) {\n+                    chooserTarget = removeIcon(chooserTarget);\n+                }\n+                targets[i] = chooserTarget;\n             }\n             mCallerChooserTargets = targets;\n         }\n@@ -4313,4 +4322,43 @@ public class ChooserActivity extends ResolverActivity implements\n     private boolean shouldNearbyShareBeIncludedAsActionButton() {\n         return !shouldNearbyShareBeFirstInRankedRow();\n     }\n+\n+    private boolean hasValidIcon(ChooserTarget target) {\n+        Icon icon = target.getIcon();\n+        if (icon == null) {\n+            return true;\n+        }\n+        if (icon.getType() == Icon.TYPE_URI || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n+            Uri uri = icon.getUri();\n+            try {\n+                getUriGrantsManager().checkGrantUriPermission_ignoreNonSystem(\n+                        getLaunchedFromUid(),\n+                        getPackageName(),\n+                        getUriWithoutUserId(uri),\n+                        Intent.FLAG_GRANT_READ_URI_PERMISSION,\n+                        getUserIdFromUri(uri)\n+                );\n+            } catch (SecurityException | RemoteException e) {\n+                Log.e(TAG, \"Failed to get URI permission for: \" + uri, e);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private IUriGrantsManager getUriGrantsManager() {\n+        return UriGrantsManager.getService();\n+    }\n+\n+    private static ChooserTarget removeIcon(ChooserTarget target) {\n+        if (target == null) {\n+            return null;\n+        }\n+        return new ChooserTarget(\n+                target.getTitle(),\n+                null,\n+                target.getScore(),\n+                target.getComponentName(),\n+                target.getIntentExtras());\n+    }\n }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 1,
                    "failed_patches": 1,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "c108d3866a3e6b1d7780325d862f20450a36d573"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "e73bb60fed12daa78ddad8308b31b0c78f1c3c66",
                            "result": "failure",
                            "downstream_patch_content": "commit e73bb60fed12daa78ddad8308b31b0c78f1c3c66\nAuthor: Andrey Yepin <ayepin@google.com>\nDate:   Mon Dec 9 17:12:10 2024 -0800\n\n    Verify that the caller has permissions for the icons it provided.\n    \n    Bug: 277207798\n    Test: manual testing: first reroduce the issue as described in the\n     ticket then check that it is not reproduceable after the fix.\n    Merged-In: I08992550507572a4878c501184360a58adef53ad\n    Change-Id: Ic8cb75ed586e94c5895065f772bfb21013396dd0\n\ndiff --git a/core/java/com/android/internal/app/ChooserActivity.java b/core/java/com/android/internal/app/ChooserActivity.java\nindex 919c176b5841..4e4305aa73b1 100644\n--- a/core/java/com/android/internal/app/ChooserActivity.java\n+++ b/core/java/com/android/internal/app/ChooserActivity.java\n@@ -16,6 +16,7 @@\n \n package com.android.internal.app;\n \n+import static android.content.ContentProvider.getUriWithoutUserId;\n import static android.content.ContentProvider.getUserIdFromUri;\n \n import static com.android.internal.util.LatencyTracker.ACTION_LOAD_SHARE_SHEET;\n@@ -32,7 +33,9 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.Activity;\n import android.app.ActivityManager;\n+import android.app.IUriGrantsManager;\n import android.app.SharedElementCallback;\n+import android.app.UriGrantsManager;\n import android.app.prediction.AppPredictionContext;\n import android.app.prediction.AppPredictionManager;\n import android.app.prediction.AppPredictor;\n@@ -68,6 +71,7 @@ import android.graphics.Paint;\n import android.graphics.Path;\n import android.graphics.drawable.AnimatedVectorDrawable;\n import android.graphics.drawable.Drawable;\n+import android.graphics.drawable.Icon;\n import android.metrics.LogMaker;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -77,6 +81,7 @@ import android.os.Handler;\n import android.os.Message;\n import android.os.Parcelable;\n import android.os.PatternMatcher;\n+import android.os.RemoteException;\n import android.os.ResultReceiver;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -663,7 +668,11 @@ public class ChooserActivity extends ResolverActivity implements\n                     targets = null;\n                     break;\n                 }\n-                targets[i] = (ChooserTarget) pa[i];\n+                ChooserTarget chooserTarget = (ChooserTarget) pa[i];\n+                if (!hasValidIcon(chooserTarget)) {\n+                    chooserTarget = removeIcon(chooserTarget);\n+                }\n+                targets[i] = chooserTarget;\n             }\n             mCallerChooserTargets = targets;\n         }\n@@ -4038,4 +4047,43 @@ public class ChooserActivity extends ResolverActivity implements\n     private boolean shouldNearbyShareBeIncludedAsActionButton() {\n         return !shouldNearbyShareBeFirstInRankedRow();\n     }\n+\n+    private boolean hasValidIcon(ChooserTarget target) {\n+        Icon icon = target.getIcon();\n+        if (icon == null) {\n+            return true;\n+        }\n+        if (icon.getType() == Icon.TYPE_URI || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n+            Uri uri = icon.getUri();\n+            try {\n+                getUriGrantsManager().checkGrantUriPermission_ignoreNonSystem(\n+                        getLaunchedFromUid(),\n+                        getPackageName(),\n+                        getUriWithoutUserId(uri),\n+                        Intent.FLAG_GRANT_READ_URI_PERMISSION,\n+                        getUserIdFromUri(uri)\n+                );\n+            } catch (SecurityException | RemoteException e) {\n+                Log.e(TAG, \"Failed to get URI permission for: \" + uri, e);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private IUriGrantsManager getUriGrantsManager() {\n+        return UriGrantsManager.getService();\n+    }\n+\n+    private static ChooserTarget removeIcon(ChooserTarget target) {\n+        if (target == null) {\n+            return null;\n+        }\n+        return new ChooserTarget(\n+                target.getTitle(),\n+                null,\n+                target.getScore(),\n+                target.getComponentName(),\n+                target.getIntentExtras());\n+    }\n }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "core/java/com/android/internal/app/ChooserActivity.java",
                                    "total_hunks": 6,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\nimport static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_PERSONAL;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_WORK;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CROSS_PROFILE_BLOCKED_TITLE;\nimport static android.content.ContentProvider.getUriWithoutUserId;\nimport static android.content.ContentProvider.getUserIdFromUri;\nimport static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_PERSONAL;\nimport static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_WORK;\n>>>>>>> UPSTREAM PATCH (commit bad47a2280c7107e1213f4adc5a3825a62698d00)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\nimport android.app.ActivityOptions;\nimport android.app.IUriGrantsManager;\n>>>>>>> UPSTREAM PATCH (commit bad47a2280c7107e1213f4adc5a3825a62698d00)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- core/java/com/android/internal/app/ChooserActivity.java\n+++ core/java/com/android/internal/app/ChooserActivity.java\n@@ -21,6 +21,7 @@ import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_PERSONAL;\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_WORK;\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CROSS_PROFILE_BLOCKED_TITLE;\n+import static android.content.ContentProvider.getUriWithoutUserId;\n import static android.content.ContentProvider.getUserIdFromUri;\n import static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_PERSONAL;\n import static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_WORK;\n@@ -40,7 +41,9 @@ import android.annotation.Nullable;\n import android.app.Activity;\n import android.app.ActivityManager;\n import android.app.ActivityOptions;\n+import android.app.IUriGrantsManager;\n import android.app.SharedElementCallback;\n+import android.app.UriGrantsManager;\n import android.app.prediction.AppPredictionContext;\n import android.app.prediction.AppPredictionManager;\n import android.app.prediction.AppPredictor;\n```",
                                    "patch_apply_output": "patching file core/java/com/android/internal/app/ChooserActivity.java\nHunk #1 FAILED at 21.\nHunk #2 FAILED at 40.\nHunk #3 succeeded at 66 (offset -11 lines).\nHunk #4 succeeded at 76 (offset -11 lines).\nHunk #5 succeeded at 654 (offset -40 lines).\nHunk #6 succeeded at 4004 (offset -315 lines).\n2 out of 6 hunks FAILED -- saving rejects to file core/java/com/android/internal/app/ChooserActivity.java.rej",
                                    "inline_merge_output": "patching file core/java/com/android/internal/app/ChooserActivity.java\nHunk #1 NOT MERGED at 21-30.\nHunk #2 NOT MERGED at 43-47, merged at 49."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "bad47a2280c7107e1213f4adc5a3825a62698d00",
                            "result": "success",
                            "downstream_patch_content": "commit bad47a2280c7107e1213f4adc5a3825a62698d00\nAuthor: Andrey Yepin <ayepin@google.com>\nDate:   Mon Dec 9 21:34:17 2024 -0800\n\n    Verify that the caller has permissions for the icons it provided.\n    \n    Bug: 277207798\n    Test: manual testing: first reroduce the issue as described in the\n     ticket then check that it is not reproduceable after the fix.\n    Change-Id: I08992550507572a4878c501184360a58adef53ad\n\ndiff --git a/core/java/com/android/internal/app/ChooserActivity.java b/core/java/com/android/internal/app/ChooserActivity.java\nindex f9d553ffc0c1..ebd015f1c429 100644\n--- a/core/java/com/android/internal/app/ChooserActivity.java\n+++ b/core/java/com/android/internal/app/ChooserActivity.java\n@@ -21,6 +21,7 @@ import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_PERSONAL;\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_WORK;\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CROSS_PROFILE_BLOCKED_TITLE;\n+import static android.content.ContentProvider.getUriWithoutUserId;\n import static android.content.ContentProvider.getUserIdFromUri;\n import static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_PERSONAL;\n import static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_WORK;\n@@ -40,7 +41,9 @@ import android.annotation.Nullable;\n import android.app.Activity;\n import android.app.ActivityManager;\n import android.app.ActivityOptions;\n+import android.app.IUriGrantsManager;\n import android.app.SharedElementCallback;\n+import android.app.UriGrantsManager;\n import android.app.prediction.AppPredictionContext;\n import android.app.prediction.AppPredictionManager;\n import android.app.prediction.AppPredictor;\n@@ -77,6 +80,7 @@ import android.graphics.Paint;\n import android.graphics.Path;\n import android.graphics.drawable.AnimatedVectorDrawable;\n import android.graphics.drawable.Drawable;\n+import android.graphics.drawable.Icon;\n import android.metrics.LogMaker;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -86,6 +90,7 @@ import android.os.Handler;\n import android.os.Message;\n import android.os.Parcelable;\n import android.os.PatternMatcher;\n+import android.os.RemoteException;\n import android.os.ResultReceiver;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -692,7 +697,11 @@ public class ChooserActivity extends ResolverActivity implements\n                     targets = null;\n                     break;\n                 }\n-                targets[i] = (ChooserTarget) pa[i];\n+                ChooserTarget chooserTarget = (ChooserTarget) pa[i];\n+                if (!hasValidIcon(chooserTarget)) {\n+                    chooserTarget = removeIcon(chooserTarget);\n+                }\n+                targets[i] = chooserTarget;\n             }\n             mCallerChooserTargets = targets;\n         }\n@@ -4313,4 +4322,43 @@ public class ChooserActivity extends ResolverActivity implements\n     private boolean shouldNearbyShareBeIncludedAsActionButton() {\n         return !shouldNearbyShareBeFirstInRankedRow();\n     }\n+\n+    private boolean hasValidIcon(ChooserTarget target) {\n+        Icon icon = target.getIcon();\n+        if (icon == null) {\n+            return true;\n+        }\n+        if (icon.getType() == Icon.TYPE_URI || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n+            Uri uri = icon.getUri();\n+            try {\n+                getUriGrantsManager().checkGrantUriPermission_ignoreNonSystem(\n+                        getLaunchedFromUid(),\n+                        getPackageName(),\n+                        getUriWithoutUserId(uri),\n+                        Intent.FLAG_GRANT_READ_URI_PERMISSION,\n+                        getUserIdFromUri(uri)\n+                );\n+            } catch (SecurityException | RemoteException e) {\n+                Log.e(TAG, \"Failed to get URI permission for: \" + uri, e);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private IUriGrantsManager getUriGrantsManager() {\n+        return UriGrantsManager.getService();\n+    }\n+\n+    private static ChooserTarget removeIcon(ChooserTarget target) {\n+        if (target == null) {\n+            return null;\n+        }\n+        return new ChooserTarget(\n+                target.getTitle(),\n+                null,\n+                target.getScore(),\n+                target.getComponentName(),\n+                target.getIntentExtras());\n+    }\n }\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-283101289",
            "aliases": [
                "A-283101289",
                "CVE-2023-40134"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-283101289",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "bf7fbbccd920596e514d1559fb3feaca70e55e78"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From bf7fbbccd920596e514d1559fb3feaca70e55e78 Mon Sep 17 00:00:00 2001\nFrom: Tim Yu <yunicorn@google.com>\nDate: Tue, 20 Jun 2023 21:24:36 +0000\nSubject: [PATCH] [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n\nCheck permissions of URI inside of FillResponse's RemoteViews. If the\ncurrent user does not have the required permissions to view the URI, the\nRemoteView is dropped from displaying.\n\nThis fixes a security spill in which a user can view content of another\nuser through a malicious Autofill provider.\n\nBug: 283137865\nFixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\nb/281534749 b/283101289\nTest: Verified by POC app attached in bugs\nTest: atest CtsAutoFillServiceTestCases (added new tests)\nChange-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n---\n .../com/android/server/autofill/Helper.java   | 43 +++++++++++++++++++\n .../server/autofill/ui/DialogFillUi.java      | 12 ++++--\n .../android/server/autofill/ui/FillUi.java    | 11 +++--\n .../android/server/autofill/ui/SaveUi.java    |  3 +-\n 4 files changed, 60 insertions(+), 9 deletions(-)\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex 82af38200166..ad8f5e1481e1 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -20,6 +20,8 @@ import static com.android.server.autofill.Helper.sDebug;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -40,6 +42,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -50,6 +53,8 @@ import java.lang.ref.WeakReference;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -83,6 +88,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed & permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex dbeb624bd202..fa414e3b172b 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -53,6 +53,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -208,7 +209,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -243,9 +245,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -289,7 +292,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 129ce72e037d..cdfe7bb4f4a7 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -148,8 +148,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -227,6 +228,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -306,7 +310,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex f035d0764279..70382f1d5274 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -384,8 +384,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 1,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "73fa082a7202100da107ae14dd7742ecd86da053",
                            "result": "failure",
                            "downstream_patch_content": "commit 73fa082a7202100da107ae14dd7742ecd86da053\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "f7ca136c514dc975c3f46d95c53fd6b3752c577a",
                            "result": "failure",
                            "downstream_patch_content": "commit f7ca136c514dc975c3f46d95c53fd6b3752c577a\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "93810ba1c0a4d31f49adbf9454731e2b7defdfc0",
                            "result": "success",
                            "downstream_patch_content": "commit 93810ba1c0a4d31f49adbf9454731e2b7defdfc0\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n    Merged-In: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex c2c630e01bee..59184e9ed288 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -52,6 +52,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -197,7 +198,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -232,9 +234,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -278,7 +281,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 8fbdd81cc4cc..76fa258734cc 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -144,8 +144,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -223,6 +224,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -302,7 +306,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 677871f6c85f..533a7b69a650 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-370840874",
            "aliases": [
                "A-370840874",
                "CVE-2024-49738"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-370840874",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "c54dad65317f851ce9d016bd90ec6a7a04da09fc"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From c54dad65317f851ce9d016bd90ec6a7a04da09fc Mon Sep 17 00:00:00 2001\nFrom: Steven Moreland <smoreland@google.com>\nDate: Wed, 2 Oct 2024 00:37:59 +0000\nSubject: [PATCH] libbinder: Parcel: validate read data before write\n\nThis is slow, but it's required to prevent memory\ncorruption.\n\nIgnore-AOSP-First: security\nBug: 370840874\nTest: fuzzer\nChange-Id: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n---\n libs/binder/Parcel.cpp | 12 ++++++++++++\n 1 file changed, 12 insertions(+)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 3d36f2eed7..d346ad15d2 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -1211,6 +1211,10 @@ restart_write:\n         //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n         uint8_t* const data = mData+mDataPos;\n \n+        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n+            return nullptr; // drops status\n+        }\n+\n         // Need to pad at end?\n         if (padded != len) {\n #if BYTE_ORDER == BIG_ENDIAN\n@@ -1799,6 +1803,10 @@ status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n     const bool enoughObjects = kernelFields->mObjectsSize < kernelFields->mObjectsCapacity;\n     if (enoughData && enoughObjects) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n \n         // remember if it's a file descriptor\n@@ -2042,6 +2050,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         memcpy(mData + mDataPos, &val, sizeof(val));\n         return finishWrite(sizeof(val));\n     }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 2,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "2aec032c0826ad68cd94c100173b99167bfcb10d",
                            "result": "failure",
                            "downstream_patch_content": "commit 2aec032c0826ad68cd94c100173b99167bfcb10d\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Wed Oct 2 00:37:59 2024 +0000\n\n    libbinder: Parcel: validate read data before write\n    \n    This is slow, but it's required to prevent memory\n    corruption.\n    \n    Ignore-AOSP-First: security\n    Bug: 370840874\n    Test: fuzzer\n    Merged-In: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n    Change-Id: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n    (cherry picked from commit c54dad65317f851ce9d016bd90ec6a7a04da09fc)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 617708f3d4..0670307e48 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -796,6 +796,10 @@ restart_write:\n         //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n         uint8_t* const data = mData+mDataPos;\n \n+        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n+            return nullptr; // drops status\n+        }\n+\n         // Need to pad at end?\n         if (padded != len) {\n #if BYTE_ORDER == BIG_ENDIAN\n@@ -1313,6 +1317,10 @@ status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n     const bool enoughObjects = mObjectsSize < mObjectsCapacity;\n     if (enoughData && enoughObjects) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n \n         // remember if it's a file descriptor\n@@ -1505,6 +1513,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<T*>(mData+mDataPos) = val;\n         return finishWrite(sizeof(val));\n     }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "libs/binder/Parcel.cpp",
                                    "total_hunks": 3,
                                    "failed_hunks": [
                                        3
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n        *reinterpret_cast<T*>(mData+mDataPos) = val;\n=======\n        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n            return status;\n        }\n\n        memcpy(mData + mDataPos, &val, sizeof(val));\n>>>>>>> UPSTREAM PATCH (commit c54dad65317f851ce9d016bd90ec6a7a04da09fc)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- libs/binder/Parcel.cpp\n+++ libs/binder/Parcel.cpp\n@@ -2050,6 +2058,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         memcpy(mData + mDataPos, &val, sizeof(val));\n         return finishWrite(sizeof(val));\n     }\n```",
                                    "patch_apply_output": "patching file libs/binder/Parcel.cpp\nHunk #1 succeeded at 796 (offset -415 lines).\nHunk #2 succeeded at 1317 with fuzz 1 (offset -486 lines).\nHunk #3 FAILED at 2050.\n1 out of 3 hunks FAILED -- saving rejects to file libs/binder/Parcel.cpp.rej",
                                    "inline_merge_output": "patching file libs/binder/Parcel.cpp\nHunk #2 merged at 1320-1323.\nHunk #3 NOT MERGED at 1516-1524."
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "2aec032c0826ad68cd94c100173b99167bfcb10d",
                            "result": "failure",
                            "downstream_patch_content": "commit 2aec032c0826ad68cd94c100173b99167bfcb10d\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Wed Oct 2 00:37:59 2024 +0000\n\n    libbinder: Parcel: validate read data before write\n    \n    This is slow, but it's required to prevent memory\n    corruption.\n    \n    Ignore-AOSP-First: security\n    Bug: 370840874\n    Test: fuzzer\n    Merged-In: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n    Change-Id: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n    (cherry picked from commit c54dad65317f851ce9d016bd90ec6a7a04da09fc)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 617708f3d4..0670307e48 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -796,6 +796,10 @@ restart_write:\n         //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n         uint8_t* const data = mData+mDataPos;\n \n+        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n+            return nullptr; // drops status\n+        }\n+\n         // Need to pad at end?\n         if (padded != len) {\n #if BYTE_ORDER == BIG_ENDIAN\n@@ -1313,6 +1317,10 @@ status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n     const bool enoughObjects = mObjectsSize < mObjectsCapacity;\n     if (enoughData && enoughObjects) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n \n         // remember if it's a file descriptor\n@@ -1505,6 +1513,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<T*>(mData+mDataPos) = val;\n         return finishWrite(sizeof(val));\n     }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "libs/binder/Parcel.cpp",
                                    "total_hunks": 3,
                                    "failed_hunks": [
                                        3
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n        *reinterpret_cast<T*>(mData+mDataPos) = val;\n=======\n        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n            return status;\n        }\n\n        memcpy(mData + mDataPos, &val, sizeof(val));\n>>>>>>> UPSTREAM PATCH (commit c54dad65317f851ce9d016bd90ec6a7a04da09fc)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- libs/binder/Parcel.cpp\n+++ libs/binder/Parcel.cpp\n@@ -2050,6 +2058,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         memcpy(mData + mDataPos, &val, sizeof(val));\n         return finishWrite(sizeof(val));\n     }\n```",
                                    "patch_apply_output": "patching file libs/binder/Parcel.cpp\nHunk #1 succeeded at 796 (offset -415 lines).\nHunk #2 succeeded at 1317 with fuzz 1 (offset -486 lines).\nHunk #3 FAILED at 2050.\n1 out of 3 hunks FAILED -- saving rejects to file libs/binder/Parcel.cpp.rej",
                                    "inline_merge_output": "patching file libs/binder/Parcel.cpp\nHunk #2 merged at 1320-1323.\nHunk #3 NOT MERGED at 1516-1524."
                                }
                            ]
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "43feae49c343b948a38b15d5e12c78916bafee61"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "4e76d6907ec1e8f065f7af3e4032e4b8cee6b2c1",
                            "result": "success",
                            "downstream_patch_content": "commit 4e76d6907ec1e8f065f7af3e4032e4b8cee6b2c1\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Wed Oct 2 00:37:59 2024 +0000\n\n    libbinder: Parcel: validate read data before write\n    \n    This is slow, but it's required to prevent memory\n    corruption.\n    \n    Ignore-AOSP-First: security\n    Bug: 370840874\n    Test: fuzzer\n    Merged-In: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n    Change-Id: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n    (cherry picked from commit c54dad65317f851ce9d016bd90ec6a7a04da09fc)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 58b0b35323..2ddfdd727d 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -888,6 +888,10 @@ restart_write:\n         //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n         uint8_t* const data = mData+mDataPos;\n \n+        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n+            return nullptr; // drops status\n+        }\n+\n         // Need to pad at end?\n         if (padded != len) {\n #if BYTE_ORDER == BIG_ENDIAN\n@@ -1405,6 +1409,10 @@ status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n     const bool enoughObjects = mObjectsSize < mObjectsCapacity;\n     if (enoughData && enoughObjects) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n \n         // remember if it's a file descriptor\n@@ -1621,6 +1629,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         memcpy(mData + mDataPos, &val, sizeof(val));\n         return finishWrite(sizeof(val));\n     }\n"
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "4e76d6907ec1e8f065f7af3e4032e4b8cee6b2c1",
                            "result": "success",
                            "downstream_patch_content": "commit 4e76d6907ec1e8f065f7af3e4032e4b8cee6b2c1\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Wed Oct 2 00:37:59 2024 +0000\n\n    libbinder: Parcel: validate read data before write\n    \n    This is slow, but it's required to prevent memory\n    corruption.\n    \n    Ignore-AOSP-First: security\n    Bug: 370840874\n    Test: fuzzer\n    Merged-In: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n    Change-Id: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n    (cherry picked from commit c54dad65317f851ce9d016bd90ec6a7a04da09fc)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 58b0b35323..2ddfdd727d 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -888,6 +888,10 @@ restart_write:\n         //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n         uint8_t* const data = mData+mDataPos;\n \n+        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n+            return nullptr; // drops status\n+        }\n+\n         // Need to pad at end?\n         if (padded != len) {\n #if BYTE_ORDER == BIG_ENDIAN\n@@ -1405,6 +1409,10 @@ status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n     const bool enoughObjects = mObjectsSize < mObjectsCapacity;\n     if (enoughData && enoughObjects) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n \n         // remember if it's a file descriptor\n@@ -1621,6 +1629,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         memcpy(mData + mDataPos, &val, sizeof(val));\n         return finishWrite(sizeof(val));\n     }\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-323850943",
            "aliases": [
                "A-323850943",
                "CVE-2024-43096"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-323850943",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "cad927034a371b82a4a07a16ec442eb261f6153f"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From cad927034a371b82a4a07a16ec442eb261f6153f Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Thu, 16 May 2024 20:47:44 +0000\nSubject: [PATCH] Fix OOB write in build_read_multi_rsp of gatt_sr.cc\n\nbuild_read_multi_rsp is missing a bounds check, which can lead to an\nOOB write when the mtu parameter is set to zero.\n\nAdd that bounds check.\n\nBug: 323850943\nTest: atest GattSrTest\nTest: researcher POC\nTag: #security\nFlag: EXEMPT trivial validity checks\nIgnore-AOSP-First: Security\nChange-Id: I18e4325dbc9d6814220332288c85b114d0415c2f\n---\n system/stack/eatt/eatt.h     | 1 +\n system/stack/gatt/gatt_sr.cc | 7 +++++++\n 2 files changed, 8 insertions(+)\n\ndiff --git a/system/stack/eatt/eatt.h b/system/stack/eatt/eatt.h\nindex 62bf248206..0a1a591a54 100644\n--- a/system/stack/eatt/eatt.h\n+++ b/system/stack/eatt/eatt.h\n@@ -100,6 +100,7 @@ class EattChannel {\n \n   void EattChannelSetTxMTU(uint16_t tx_mtu) {\n     this->tx_mtu_ = std::min<uint16_t>(tx_mtu, EATT_MAX_TX_MTU);\n+    this->tx_mtu_ = std::max<uint16_t>(tx_mtu, EATT_MIN_MTU_MPS);\n   }\n };\n \ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 9c40fedb7d..1785372507 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -162,6 +162,13 @@ static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n   uint8_t* p;\n   bool is_overflow = false;\n \n+  // We need at least one extra byte for the opcode\n+  if (mtu == 0) {\n+    log::error(\"Invalid MTU\");\n+    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n+    return;\n+  }\n+\n   len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n   BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n   p_buf->offset = L2CAP_MIN_OFFSET;\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 1,
                    "failed_patches": 1,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12-release: Command '['git', 'checkout', 'android12-release']' returned non-zero exit status 1.",
                            "downstream_patch": "c177fdbd6189a114239e11e2713740b5a50624e1"
                        },
                        {
                            "downstream_version": "12L",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12L-release: Command '['git', 'checkout', 'android12L-release']' returned non-zero exit status 1.",
                            "downstream_patch": "c177fdbd6189a114239e11e2713740b5a50624e1"
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "2b68d81a761d1f92625a5cd29ddb458fcdb46f52"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "e5ab6c617683a00c4e2996f1bc15c4c6e7f70f48",
                            "result": "failure",
                            "downstream_patch_content": "commit e5ab6c617683a00c4e2996f1bc15c4c6e7f70f48\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Thu May 16 20:47:44 2024 +0000\n\n    Fix OOB write in build_read_multi_rsp of gatt_sr.cc\n    \n    build_read_multi_rsp is missing a bounds check, which can lead to an\n    OOB write when the mtu parameter is set to zero.\n    \n    Add that bounds check.\n    \n    Bug: 323850943\n    Test: atest GattSrTest\n    Test: researcher POC\n    Tag: #security\n    Flag: EXEMPT trivial validity checks\n    Ignore-AOSP-First: Security\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:cad927034a371b82a4a07a16ec442eb261f6153f)\n    Merged-In: I18e4325dbc9d6814220332288c85b114d0415c2f\n    Change-Id: I18e4325dbc9d6814220332288c85b114d0415c2f\n\ndiff --git a/system/stack/eatt/eatt.h b/system/stack/eatt/eatt.h\nindex 92b61c533e..69e3e32257 100644\n--- a/system/stack/eatt/eatt.h\n+++ b/system/stack/eatt/eatt.h\n@@ -98,6 +98,7 @@ class EattChannel {\n \n   void EattChannelSetTxMTU(uint16_t tx_mtu) {\n     this->tx_mtu_ = std::min<uint16_t>(tx_mtu, EATT_MAX_TX_MTU);\n+    this->tx_mtu_ = std::max<uint16_t>(this->tx_mtu_, EATT_MIN_MTU_MPS);\n   }\n };\n \ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 4c00743228..3ab333d167 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -148,6 +148,13 @@ static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n   uint8_t* p;\n   bool is_overflow = false;\n \n+  // We need at least one extra byte for the opcode\n+  if (mtu == 0) {\n+    LOG(ERROR) << \"Invalid MTU\";\n+    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n+    return;\n+  }\n+\n   len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n   BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n   p_buf->offset = L2CAP_MIN_OFFSET;\n",
                            "file_conflicts": [
                                {
                                    "file_name": "system/stack/eatt/eatt.h",
                                    "total_hunks": 0,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n    state_ = state;\n=======\n\n  void EattChannelSetTxMTU(uint16_t tx_mtu) {\n    this->tx_mtu_ = std::min<uint16_t>(tx_mtu, EATT_MAX_TX_MTU);\n    this->tx_mtu_ = std::max<uint16_t>(tx_mtu, EATT_MIN_MTU_MPS);\n>>>>>>> UPSTREAM PATCH (commit cad927034a371b82a4a07a16ec442eb261f6153f)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- system/stack/eatt/eatt.h\n+++ system/stack/eatt/eatt.h\n@@ -100,6 +100,7 @@ class EattChannel {\n \n   void EattChannelSetTxMTU(uint16_t tx_mtu) {\n     this->tx_mtu_ = std::min<uint16_t>(tx_mtu, EATT_MAX_TX_MTU);\n+    this->tx_mtu_ = std::max<uint16_t>(tx_mtu, EATT_MIN_MTU_MPS);\n   }\n };\n```",
                                    "patch_apply_output": "patching file system/stack/eatt/eatt.h\nHunk #1 FAILED at 100.\n1 out of 1 hunk FAILED -- saving rejects to file system/stack/eatt/eatt.h.rej\npatching file system/stack/gatt/gatt_sr.cc\nHunk #1 succeeded at 146 (offset -16 lines).",
                                    "inline_merge_output": "patching file system/stack/eatt/eatt.h\nHunk #1 NOT MERGED at 93-100."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "e5ab6c617683a00c4e2996f1bc15c4c6e7f70f48",
                            "result": "success",
                            "downstream_patch_content": "commit e5ab6c617683a00c4e2996f1bc15c4c6e7f70f48\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Thu May 16 20:47:44 2024 +0000\n\n    Fix OOB write in build_read_multi_rsp of gatt_sr.cc\n    \n    build_read_multi_rsp is missing a bounds check, which can lead to an\n    OOB write when the mtu parameter is set to zero.\n    \n    Add that bounds check.\n    \n    Bug: 323850943\n    Test: atest GattSrTest\n    Test: researcher POC\n    Tag: #security\n    Flag: EXEMPT trivial validity checks\n    Ignore-AOSP-First: Security\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:cad927034a371b82a4a07a16ec442eb261f6153f)\n    Merged-In: I18e4325dbc9d6814220332288c85b114d0415c2f\n    Change-Id: I18e4325dbc9d6814220332288c85b114d0415c2f\n\ndiff --git a/system/stack/eatt/eatt.h b/system/stack/eatt/eatt.h\nindex 92b61c533e..69e3e32257 100644\n--- a/system/stack/eatt/eatt.h\n+++ b/system/stack/eatt/eatt.h\n@@ -98,6 +98,7 @@ class EattChannel {\n \n   void EattChannelSetTxMTU(uint16_t tx_mtu) {\n     this->tx_mtu_ = std::min<uint16_t>(tx_mtu, EATT_MAX_TX_MTU);\n+    this->tx_mtu_ = std::max<uint16_t>(this->tx_mtu_, EATT_MIN_MTU_MPS);\n   }\n };\n \ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 4c00743228..3ab333d167 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -148,6 +148,13 @@ static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n   uint8_t* p;\n   bool is_overflow = false;\n \n+  // We need at least one extra byte for the opcode\n+  if (mtu == 0) {\n+    LOG(ERROR) << \"Invalid MTU\";\n+    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n+    return;\n+  }\n+\n   len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n   BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n   p_buf->offset = L2CAP_MIN_OFFSET;\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-281666022",
            "aliases": [
                "A-281666022",
                "CVE-2023-40136"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-281666022",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "bf7fbbccd920596e514d1559fb3feaca70e55e78"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From bf7fbbccd920596e514d1559fb3feaca70e55e78 Mon Sep 17 00:00:00 2001\nFrom: Tim Yu <yunicorn@google.com>\nDate: Tue, 20 Jun 2023 21:24:36 +0000\nSubject: [PATCH] [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n\nCheck permissions of URI inside of FillResponse's RemoteViews. If the\ncurrent user does not have the required permissions to view the URI, the\nRemoteView is dropped from displaying.\n\nThis fixes a security spill in which a user can view content of another\nuser through a malicious Autofill provider.\n\nBug: 283137865\nFixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\nb/281534749 b/283101289\nTest: Verified by POC app attached in bugs\nTest: atest CtsAutoFillServiceTestCases (added new tests)\nChange-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n---\n .../com/android/server/autofill/Helper.java   | 43 +++++++++++++++++++\n .../server/autofill/ui/DialogFillUi.java      | 12 ++++--\n .../android/server/autofill/ui/FillUi.java    | 11 +++--\n .../android/server/autofill/ui/SaveUi.java    |  3 +-\n 4 files changed, 60 insertions(+), 9 deletions(-)\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex 82af38200166..ad8f5e1481e1 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -20,6 +20,8 @@ import static com.android.server.autofill.Helper.sDebug;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -40,6 +42,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -50,6 +53,8 @@ import java.lang.ref.WeakReference;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -83,6 +88,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed & permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex dbeb624bd202..fa414e3b172b 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -53,6 +53,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -208,7 +209,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -243,9 +245,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -289,7 +292,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 129ce72e037d..cdfe7bb4f4a7 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -148,8 +148,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -227,6 +228,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -306,7 +310,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex f035d0764279..70382f1d5274 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -384,8 +384,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 1,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "73fa082a7202100da107ae14dd7742ecd86da053",
                            "result": "failure",
                            "downstream_patch_content": "commit 73fa082a7202100da107ae14dd7742ecd86da053\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "f7ca136c514dc975c3f46d95c53fd6b3752c577a",
                            "result": "failure",
                            "downstream_patch_content": "commit f7ca136c514dc975c3f46d95c53fd6b3752c577a\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "93810ba1c0a4d31f49adbf9454731e2b7defdfc0",
                            "result": "success",
                            "downstream_patch_content": "commit 93810ba1c0a4d31f49adbf9454731e2b7defdfc0\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n    Merged-In: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex c2c630e01bee..59184e9ed288 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -52,6 +52,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -197,7 +198,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -232,9 +234,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -278,7 +281,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 8fbdd81cc4cc..76fa258734cc 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -144,8 +144,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -223,6 +224,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -302,7 +306,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 677871f6c85f..533a7b69a650 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-283264674",
            "aliases": [
                "A-283264674",
                "CVE-2023-40133"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-283264674",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "bf7fbbccd920596e514d1559fb3feaca70e55e78"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From bf7fbbccd920596e514d1559fb3feaca70e55e78 Mon Sep 17 00:00:00 2001\nFrom: Tim Yu <yunicorn@google.com>\nDate: Tue, 20 Jun 2023 21:24:36 +0000\nSubject: [PATCH] [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n\nCheck permissions of URI inside of FillResponse's RemoteViews. If the\ncurrent user does not have the required permissions to view the URI, the\nRemoteView is dropped from displaying.\n\nThis fixes a security spill in which a user can view content of another\nuser through a malicious Autofill provider.\n\nBug: 283137865\nFixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\nb/281534749 b/283101289\nTest: Verified by POC app attached in bugs\nTest: atest CtsAutoFillServiceTestCases (added new tests)\nChange-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n---\n .../com/android/server/autofill/Helper.java   | 43 +++++++++++++++++++\n .../server/autofill/ui/DialogFillUi.java      | 12 ++++--\n .../android/server/autofill/ui/FillUi.java    | 11 +++--\n .../android/server/autofill/ui/SaveUi.java    |  3 +-\n 4 files changed, 60 insertions(+), 9 deletions(-)\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex 82af38200166..ad8f5e1481e1 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -20,6 +20,8 @@ import static com.android.server.autofill.Helper.sDebug;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -40,6 +42,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -50,6 +53,8 @@ import java.lang.ref.WeakReference;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -83,6 +88,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed & permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex dbeb624bd202..fa414e3b172b 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -53,6 +53,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -208,7 +209,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -243,9 +245,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -289,7 +292,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 129ce72e037d..cdfe7bb4f4a7 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -148,8 +148,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -227,6 +228,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -306,7 +310,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex f035d0764279..70382f1d5274 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -384,8 +384,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 1,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "73fa082a7202100da107ae14dd7742ecd86da053",
                            "result": "failure",
                            "downstream_patch_content": "commit 73fa082a7202100da107ae14dd7742ecd86da053\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "f7ca136c514dc975c3f46d95c53fd6b3752c577a",
                            "result": "failure",
                            "downstream_patch_content": "commit f7ca136c514dc975c3f46d95c53fd6b3752c577a\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "93810ba1c0a4d31f49adbf9454731e2b7defdfc0",
                            "result": "success",
                            "downstream_patch_content": "commit 93810ba1c0a4d31f49adbf9454731e2b7defdfc0\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n    Merged-In: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex c2c630e01bee..59184e9ed288 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -52,6 +52,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -197,7 +198,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -232,9 +234,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -278,7 +281,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 8fbdd81cc4cc..76fa258734cc 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -144,8 +144,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -223,6 +224,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -302,7 +306,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 677871f6c85f..533a7b69a650 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-281665050",
            "aliases": [
                "A-281665050",
                "CVE-2023-40137"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-281665050",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "bf7fbbccd920596e514d1559fb3feaca70e55e78"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From bf7fbbccd920596e514d1559fb3feaca70e55e78 Mon Sep 17 00:00:00 2001\nFrom: Tim Yu <yunicorn@google.com>\nDate: Tue, 20 Jun 2023 21:24:36 +0000\nSubject: [PATCH] [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n\nCheck permissions of URI inside of FillResponse's RemoteViews. If the\ncurrent user does not have the required permissions to view the URI, the\nRemoteView is dropped from displaying.\n\nThis fixes a security spill in which a user can view content of another\nuser through a malicious Autofill provider.\n\nBug: 283137865\nFixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\nb/281534749 b/283101289\nTest: Verified by POC app attached in bugs\nTest: atest CtsAutoFillServiceTestCases (added new tests)\nChange-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n---\n .../com/android/server/autofill/Helper.java   | 43 +++++++++++++++++++\n .../server/autofill/ui/DialogFillUi.java      | 12 ++++--\n .../android/server/autofill/ui/FillUi.java    | 11 +++--\n .../android/server/autofill/ui/SaveUi.java    |  3 +-\n 4 files changed, 60 insertions(+), 9 deletions(-)\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex 82af38200166..ad8f5e1481e1 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -20,6 +20,8 @@ import static com.android.server.autofill.Helper.sDebug;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -40,6 +42,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -50,6 +53,8 @@ import java.lang.ref.WeakReference;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -83,6 +88,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed & permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex dbeb624bd202..fa414e3b172b 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -53,6 +53,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -208,7 +209,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -243,9 +245,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -289,7 +292,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 129ce72e037d..cdfe7bb4f4a7 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -148,8 +148,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -227,6 +228,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -306,7 +310,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex f035d0764279..70382f1d5274 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -384,8 +384,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 1,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "73fa082a7202100da107ae14dd7742ecd86da053",
                            "result": "failure",
                            "downstream_patch_content": "commit 73fa082a7202100da107ae14dd7742ecd86da053\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "f7ca136c514dc975c3f46d95c53fd6b3752c577a",
                            "result": "failure",
                            "downstream_patch_content": "commit f7ca136c514dc975c3f46d95c53fd6b3752c577a\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "93810ba1c0a4d31f49adbf9454731e2b7defdfc0",
                            "result": "success",
                            "downstream_patch_content": "commit 93810ba1c0a4d31f49adbf9454731e2b7defdfc0\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n    Merged-In: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex c2c630e01bee..59184e9ed288 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -52,6 +52,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -197,7 +198,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -232,9 +234,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -278,7 +281,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 8fbdd81cc4cc..76fa258734cc 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -144,8 +144,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -223,6 +224,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -302,7 +306,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 677871f6c85f..533a7b69a650 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-281534749",
            "aliases": [
                "A-281534749",
                "CVE-2023-40138"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-281534749",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "bf7fbbccd920596e514d1559fb3feaca70e55e78"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From bf7fbbccd920596e514d1559fb3feaca70e55e78 Mon Sep 17 00:00:00 2001\nFrom: Tim Yu <yunicorn@google.com>\nDate: Tue, 20 Jun 2023 21:24:36 +0000\nSubject: [PATCH] [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n\nCheck permissions of URI inside of FillResponse's RemoteViews. If the\ncurrent user does not have the required permissions to view the URI, the\nRemoteView is dropped from displaying.\n\nThis fixes a security spill in which a user can view content of another\nuser through a malicious Autofill provider.\n\nBug: 283137865\nFixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\nb/281534749 b/283101289\nTest: Verified by POC app attached in bugs\nTest: atest CtsAutoFillServiceTestCases (added new tests)\nChange-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n---\n .../com/android/server/autofill/Helper.java   | 43 +++++++++++++++++++\n .../server/autofill/ui/DialogFillUi.java      | 12 ++++--\n .../android/server/autofill/ui/FillUi.java    | 11 +++--\n .../android/server/autofill/ui/SaveUi.java    |  3 +-\n 4 files changed, 60 insertions(+), 9 deletions(-)\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex 82af38200166..ad8f5e1481e1 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -20,6 +20,8 @@ import static com.android.server.autofill.Helper.sDebug;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -40,6 +42,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -50,6 +53,8 @@ import java.lang.ref.WeakReference;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -83,6 +88,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed & permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex dbeb624bd202..fa414e3b172b 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -53,6 +53,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -208,7 +209,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -243,9 +245,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -289,7 +292,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 129ce72e037d..cdfe7bb4f4a7 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -148,8 +148,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -227,6 +228,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -306,7 +310,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex f035d0764279..70382f1d5274 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -384,8 +384,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 1,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "73fa082a7202100da107ae14dd7742ecd86da053",
                            "result": "failure",
                            "downstream_patch_content": "commit 73fa082a7202100da107ae14dd7742ecd86da053\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "f7ca136c514dc975c3f46d95c53fd6b3752c577a",
                            "result": "failure",
                            "downstream_patch_content": "commit f7ca136c514dc975c3f46d95c53fd6b3752c577a\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "93810ba1c0a4d31f49adbf9454731e2b7defdfc0",
                            "result": "success",
                            "downstream_patch_content": "commit 93810ba1c0a4d31f49adbf9454731e2b7defdfc0\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n    Merged-In: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex c2c630e01bee..59184e9ed288 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -52,6 +52,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -197,7 +198,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -232,9 +234,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -278,7 +281,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 8fbdd81cc4cc..76fa258734cc 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -144,8 +144,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -223,6 +224,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -302,7 +306,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 677871f6c85f..533a7b69a650 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-366401629",
            "aliases": [
                "A-366401629",
                "CVE-2025-0091"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-366401629",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "841fb3846b25dee4ae5924fd798cd48709c69801"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 841fb3846b25dee4ae5924fd798cd48709c69801 Mon Sep 17 00:00:00 2001\nFrom: Jason Chiu <chiujason@google.com>\nDate: Thu, 7 Nov 2024 15:33:53 +0800\nSubject: [PATCH] Block the content scheme intent in\n AccountTypePreferenceLoader\n\nBug: 366401629\nFlag: EXEMPT security fix\nTest: atest AccountTypePreferenceLoaderTest, manual\nChange-Id: Ica87087341cc983df04190919e33dc369fa18619\n---\n .../accounts/AccountTypePreferenceLoader.java | 21 ++++++++++++-------\n .../AccountTypePreferenceLoaderTest.java      | 12 +++++++++++\n 2 files changed, 26 insertions(+), 7 deletions(-)\n\ndiff --git a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nindex 3b254e9b844..71c71346adb 100644\n--- a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -20,6 +20,7 @@ package com.android.settings.accounts;\n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n import android.content.ClipData;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n@@ -186,9 +187,9 @@ public class AccountTypePreferenceLoader {\n                                     prefIntent, mUserHandle);\n                             } else {\n                                 Log.e(TAG,\n-                                    \"Refusing to launch authenticator intent because\"\n-                                        + \"it exploits Settings permissions: \"\n-                                        + prefIntent);\n+                                        \"Refusing to launch authenticator intent because \"\n+                                                + \"it exploits Settings permissions: \"\n+                                                + prefIntent);\n                             }\n                             return true;\n                         }\n@@ -242,13 +243,19 @@ public class AccountTypePreferenceLoader {\n     }\n \n     /**\n-     * Determines if the supplied Intent is safe. A safe intent is one that is\n-     * will launch a exported=true activity or owned by the same uid as the\n+     * Determines if the supplied Intent is safe. A safe intent is one that\n+     * will launch an exported=true activity or owned by the same uid as the\n      * authenticator supplying the intent.\n      */\n-    private boolean isSafeIntent(PackageManager pm, Intent intent, String acccountType) {\n+    @VisibleForTesting\n+    boolean isSafeIntent(PackageManager pm, Intent intent, String accountType) {\n+        if (TextUtils.equals(intent.getScheme(), ContentResolver.SCHEME_CONTENT)) {\n+            Log.e(TAG, \"Intent with a content scheme is unsafe.\");\n+            return false;\n+        }\n+\n         AuthenticatorDescription authDesc =\n-            mAuthenticatorHelper.getAccountTypeDescription(acccountType);\n+                mAuthenticatorHelper.getAccountTypeDescription(accountType);\n         ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mUserHandle.getIdentifier());\n         if (resolveInfo == null) {\n             return false;\ndiff --git a/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java b/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\nindex efa5fea7416..0b9c6c357a4 100644\n--- a/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\n+++ b/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\n@@ -30,8 +30,11 @@ import static org.mockito.Mockito.when;\n import android.accounts.Account;\n import android.accounts.AccountManager;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ClipData;\n import android.content.Context;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n+import android.net.Uri;\n import android.os.UserHandle;\n \n import androidx.collection.ArraySet;\n@@ -250,4 +253,13 @@ public class AccountTypePreferenceLoaderTest {\n         mPrefLoader.filterBlockedFragments(parent, Set.of(\"nomatch\", \"other\"));\n         verify(pref).setOnPreferenceClickListener(any());\n     }\n+\n+    @Test\n+    public void isSafeIntent_hasContextScheme_returnFalse() {\n+        Intent intent = new Intent();\n+        intent.setClipData(ClipData.newRawUri(null,\n+                Uri.parse(\"content://com.android.settings.files/my_cache/NOTICE.html\")));\n+\n+        assertThat(mPrefLoader.isSafeIntent(mPackageManager, intent, mAccount.type)).isFalse();\n+    }\n }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 1,
                    "failed_patches": 3,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "d782f9c4bc72cdb0dbfb07a76e1582dafa9f49b3",
                            "result": "failure",
                            "downstream_patch_content": "commit d782f9c4bc72cdb0dbfb07a76e1582dafa9f49b3\nAuthor: Jason Chiu <chiujason@google.com>\nDate:   Thu Nov 7 15:33:53 2024 +0800\n\n    Block the content scheme intent in AccountTypePreferenceLoader\n    \n    Also prevent intent defined in AccountPreference from leaking access\n    \n    Bug: 366401629\n    Flag: EXEMPT security fix\n    Test: atest AccountTypePreferenceLoaderTest, manual\n    Change-Id: Ica87087341cc983df04190919e33dc369fa18619\n    Merged-In: Ica87087341cc983df04190919e33dc369fa18619\n    (cherry picked from commit 841fb3846b25dee4ae5924fd798cd48709c69801)\n\ndiff --git a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nindex 73583ea8592..7cfeb1cc193 100644\n--- a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -19,6 +19,8 @@ package com.android.settings.accounts;\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ClipData;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n@@ -177,13 +179,16 @@ public class AccountTypePreferenceLoader {\n                                  * exploiting the fact that settings has system privileges.\n                                  */\n                             if (isSafeIntent(pm, prefIntent, acccountType)) {\n+                                // Explicitly set an empty ClipData to ensure that we don't offer to\n+                                // promote any Uris contained inside for granting purposes\n+                                prefIntent.setClipData(ClipData.newPlainText(null, null));\n                                 mFragment.getActivity().startActivityAsUser(\n                                     prefIntent, mUserHandle);\n                             } else {\n                                 Log.e(TAG,\n-                                    \"Refusing to launch authenticator intent because\"\n-                                        + \"it exploits Settings permissions: \"\n-                                        + prefIntent);\n+                                        \"Refusing to launch authenticator intent because \"\n+                                                + \"it exploits Settings permissions: \"\n+                                                + prefIntent);\n                             }\n                             return true;\n                         }\n@@ -237,13 +242,19 @@ public class AccountTypePreferenceLoader {\n     }\n \n     /**\n-     * Determines if the supplied Intent is safe. A safe intent is one that is\n-     * will launch a exported=true activity or owned by the same uid as the\n+     * Determines if the supplied Intent is safe. A safe intent is one that\n+     * will launch an exported=true activity or owned by the same uid as the\n      * authenticator supplying the intent.\n      */\n-    private boolean isSafeIntent(PackageManager pm, Intent intent, String acccountType) {\n+    @VisibleForTesting\n+    boolean isSafeIntent(PackageManager pm, Intent intent, String accountType) {\n+        if (TextUtils.equals(intent.getScheme(), ContentResolver.SCHEME_CONTENT)) {\n+            Log.e(TAG, \"Intent with a content scheme is unsafe.\");\n+            return false;\n+        }\n+\n         AuthenticatorDescription authDesc =\n-            mAuthenticatorHelper.getAccountTypeDescription(acccountType);\n+                mAuthenticatorHelper.getAccountTypeDescription(accountType);\n         ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mUserHandle.getIdentifier());\n         if (resolveInfo == null) {\n             return false;\ndiff --git a/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java b/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\nindex 405f6b3dbb8..5e566004a1e 100644\n--- a/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\n+++ b/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\n@@ -16,6 +16,8 @@\n \n package com.android.settings.accounts;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.mockito.Answers.RETURNS_DEEP_STUBS;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.Mockito.mock;\n@@ -26,8 +28,11 @@ import static org.mockito.Mockito.when;\n import android.accounts.Account;\n import android.accounts.AccountManager;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ClipData;\n import android.content.Context;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n+import android.net.Uri;\n import android.os.UserHandle;\n \n import androidx.preference.Preference;\n@@ -129,4 +134,13 @@ public class AccountTypePreferenceLoaderTest {\n         verify(mPrefLoader).updatePreferenceIntents(prefGroup4, acctType, mAccount);\n         verify(mPrefLoader).updatePreferenceIntents(prefGroup41, acctType, mAccount);\n     }\n+\n+    @Test\n+    public void isSafeIntent_hasContextScheme_returnFalse() {\n+        Intent intent = new Intent();\n+        intent.setClipData(ClipData.newRawUri(null,\n+                Uri.parse(\"content://com.android.settings.files/my_cache/NOTICE.html\")));\n+\n+        assertThat(mPrefLoader.isSafeIntent(mPackageManager, intent, mAccount.type)).isFalse();\n+    }\n }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/accounts/AccountTypePreferenceLoader.java",
                                    "total_hunks": 3,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n\n=======\nimport android.content.ClipData;\nimport android.content.ContentResolver;\n>>>>>>> UPSTREAM PATCH (commit 841fb3846b25dee4ae5924fd798cd48709c69801)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -20,6 +20,7 @@ package com.android.settings.accounts;\n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n import android.content.ClipData;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n```",
                                    "patch_apply_output": "patching file src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nHunk #1 FAILED at 20.\nHunk #2 succeeded at 181 (offset -5 lines).\nHunk #3 succeeded at 237 (offset -5 lines).\n1 out of 3 hunks FAILED -- saving rejects to file src/com/android/settings/accounts/AccountTypePreferenceLoader.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nHunk #1 NOT MERGED at 22-26."
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "d782f9c4bc72cdb0dbfb07a76e1582dafa9f49b3",
                            "result": "failure",
                            "downstream_patch_content": "commit d782f9c4bc72cdb0dbfb07a76e1582dafa9f49b3\nAuthor: Jason Chiu <chiujason@google.com>\nDate:   Thu Nov 7 15:33:53 2024 +0800\n\n    Block the content scheme intent in AccountTypePreferenceLoader\n    \n    Also prevent intent defined in AccountPreference from leaking access\n    \n    Bug: 366401629\n    Flag: EXEMPT security fix\n    Test: atest AccountTypePreferenceLoaderTest, manual\n    Change-Id: Ica87087341cc983df04190919e33dc369fa18619\n    Merged-In: Ica87087341cc983df04190919e33dc369fa18619\n    (cherry picked from commit 841fb3846b25dee4ae5924fd798cd48709c69801)\n\ndiff --git a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nindex 73583ea8592..7cfeb1cc193 100644\n--- a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -19,6 +19,8 @@ package com.android.settings.accounts;\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ClipData;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n@@ -177,13 +179,16 @@ public class AccountTypePreferenceLoader {\n                                  * exploiting the fact that settings has system privileges.\n                                  */\n                             if (isSafeIntent(pm, prefIntent, acccountType)) {\n+                                // Explicitly set an empty ClipData to ensure that we don't offer to\n+                                // promote any Uris contained inside for granting purposes\n+                                prefIntent.setClipData(ClipData.newPlainText(null, null));\n                                 mFragment.getActivity().startActivityAsUser(\n                                     prefIntent, mUserHandle);\n                             } else {\n                                 Log.e(TAG,\n-                                    \"Refusing to launch authenticator intent because\"\n-                                        + \"it exploits Settings permissions: \"\n-                                        + prefIntent);\n+                                        \"Refusing to launch authenticator intent because \"\n+                                                + \"it exploits Settings permissions: \"\n+                                                + prefIntent);\n                             }\n                             return true;\n                         }\n@@ -237,13 +242,19 @@ public class AccountTypePreferenceLoader {\n     }\n \n     /**\n-     * Determines if the supplied Intent is safe. A safe intent is one that is\n-     * will launch a exported=true activity or owned by the same uid as the\n+     * Determines if the supplied Intent is safe. A safe intent is one that\n+     * will launch an exported=true activity or owned by the same uid as the\n      * authenticator supplying the intent.\n      */\n-    private boolean isSafeIntent(PackageManager pm, Intent intent, String acccountType) {\n+    @VisibleForTesting\n+    boolean isSafeIntent(PackageManager pm, Intent intent, String accountType) {\n+        if (TextUtils.equals(intent.getScheme(), ContentResolver.SCHEME_CONTENT)) {\n+            Log.e(TAG, \"Intent with a content scheme is unsafe.\");\n+            return false;\n+        }\n+\n         AuthenticatorDescription authDesc =\n-            mAuthenticatorHelper.getAccountTypeDescription(acccountType);\n+                mAuthenticatorHelper.getAccountTypeDescription(accountType);\n         ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mUserHandle.getIdentifier());\n         if (resolveInfo == null) {\n             return false;\ndiff --git a/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java b/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\nindex 405f6b3dbb8..5e566004a1e 100644\n--- a/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\n+++ b/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\n@@ -16,6 +16,8 @@\n \n package com.android.settings.accounts;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.mockito.Answers.RETURNS_DEEP_STUBS;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.Mockito.mock;\n@@ -26,8 +28,11 @@ import static org.mockito.Mockito.when;\n import android.accounts.Account;\n import android.accounts.AccountManager;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ClipData;\n import android.content.Context;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n+import android.net.Uri;\n import android.os.UserHandle;\n \n import androidx.preference.Preference;\n@@ -129,4 +134,13 @@ public class AccountTypePreferenceLoaderTest {\n         verify(mPrefLoader).updatePreferenceIntents(prefGroup4, acctType, mAccount);\n         verify(mPrefLoader).updatePreferenceIntents(prefGroup41, acctType, mAccount);\n     }\n+\n+    @Test\n+    public void isSafeIntent_hasContextScheme_returnFalse() {\n+        Intent intent = new Intent();\n+        intent.setClipData(ClipData.newRawUri(null,\n+                Uri.parse(\"content://com.android.settings.files/my_cache/NOTICE.html\")));\n+\n+        assertThat(mPrefLoader.isSafeIntent(mPackageManager, intent, mAccount.type)).isFalse();\n+    }\n }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/accounts/AccountTypePreferenceLoader.java",
                                    "total_hunks": 3,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n\n=======\nimport android.content.ClipData;\nimport android.content.ContentResolver;\n>>>>>>> UPSTREAM PATCH (commit 841fb3846b25dee4ae5924fd798cd48709c69801)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -20,6 +20,7 @@ package com.android.settings.accounts;\n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n import android.content.ClipData;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n```",
                                    "patch_apply_output": "patching file src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nHunk #1 FAILED at 20.\nHunk #2 succeeded at 181 (offset -5 lines).\nHunk #3 succeeded at 237 (offset -5 lines).\n1 out of 3 hunks FAILED -- saving rejects to file src/com/android/settings/accounts/AccountTypePreferenceLoader.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nHunk #1 NOT MERGED at 22-26."
                                }
                            ]
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "4929f6647b4d99d88423d0b3abac692112fde659"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "d782f9c4bc72cdb0dbfb07a76e1582dafa9f49b3",
                            "result": "failure",
                            "downstream_patch_content": "commit d782f9c4bc72cdb0dbfb07a76e1582dafa9f49b3\nAuthor: Jason Chiu <chiujason@google.com>\nDate:   Thu Nov 7 15:33:53 2024 +0800\n\n    Block the content scheme intent in AccountTypePreferenceLoader\n    \n    Also prevent intent defined in AccountPreference from leaking access\n    \n    Bug: 366401629\n    Flag: EXEMPT security fix\n    Test: atest AccountTypePreferenceLoaderTest, manual\n    Change-Id: Ica87087341cc983df04190919e33dc369fa18619\n    Merged-In: Ica87087341cc983df04190919e33dc369fa18619\n    (cherry picked from commit 841fb3846b25dee4ae5924fd798cd48709c69801)\n\ndiff --git a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nindex 73583ea8592..7cfeb1cc193 100644\n--- a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -19,6 +19,8 @@ package com.android.settings.accounts;\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ClipData;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n@@ -177,13 +179,16 @@ public class AccountTypePreferenceLoader {\n                                  * exploiting the fact that settings has system privileges.\n                                  */\n                             if (isSafeIntent(pm, prefIntent, acccountType)) {\n+                                // Explicitly set an empty ClipData to ensure that we don't offer to\n+                                // promote any Uris contained inside for granting purposes\n+                                prefIntent.setClipData(ClipData.newPlainText(null, null));\n                                 mFragment.getActivity().startActivityAsUser(\n                                     prefIntent, mUserHandle);\n                             } else {\n                                 Log.e(TAG,\n-                                    \"Refusing to launch authenticator intent because\"\n-                                        + \"it exploits Settings permissions: \"\n-                                        + prefIntent);\n+                                        \"Refusing to launch authenticator intent because \"\n+                                                + \"it exploits Settings permissions: \"\n+                                                + prefIntent);\n                             }\n                             return true;\n                         }\n@@ -237,13 +242,19 @@ public class AccountTypePreferenceLoader {\n     }\n \n     /**\n-     * Determines if the supplied Intent is safe. A safe intent is one that is\n-     * will launch a exported=true activity or owned by the same uid as the\n+     * Determines if the supplied Intent is safe. A safe intent is one that\n+     * will launch an exported=true activity or owned by the same uid as the\n      * authenticator supplying the intent.\n      */\n-    private boolean isSafeIntent(PackageManager pm, Intent intent, String acccountType) {\n+    @VisibleForTesting\n+    boolean isSafeIntent(PackageManager pm, Intent intent, String accountType) {\n+        if (TextUtils.equals(intent.getScheme(), ContentResolver.SCHEME_CONTENT)) {\n+            Log.e(TAG, \"Intent with a content scheme is unsafe.\");\n+            return false;\n+        }\n+\n         AuthenticatorDescription authDesc =\n-            mAuthenticatorHelper.getAccountTypeDescription(acccountType);\n+                mAuthenticatorHelper.getAccountTypeDescription(accountType);\n         ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mUserHandle.getIdentifier());\n         if (resolveInfo == null) {\n             return false;\ndiff --git a/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java b/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\nindex 405f6b3dbb8..5e566004a1e 100644\n--- a/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\n+++ b/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\n@@ -16,6 +16,8 @@\n \n package com.android.settings.accounts;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.mockito.Answers.RETURNS_DEEP_STUBS;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.Mockito.mock;\n@@ -26,8 +28,11 @@ import static org.mockito.Mockito.when;\n import android.accounts.Account;\n import android.accounts.AccountManager;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ClipData;\n import android.content.Context;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n+import android.net.Uri;\n import android.os.UserHandle;\n \n import androidx.preference.Preference;\n@@ -129,4 +134,13 @@ public class AccountTypePreferenceLoaderTest {\n         verify(mPrefLoader).updatePreferenceIntents(prefGroup4, acctType, mAccount);\n         verify(mPrefLoader).updatePreferenceIntents(prefGroup41, acctType, mAccount);\n     }\n+\n+    @Test\n+    public void isSafeIntent_hasContextScheme_returnFalse() {\n+        Intent intent = new Intent();\n+        intent.setClipData(ClipData.newRawUri(null,\n+                Uri.parse(\"content://com.android.settings.files/my_cache/NOTICE.html\")));\n+\n+        assertThat(mPrefLoader.isSafeIntent(mPackageManager, intent, mAccount.type)).isFalse();\n+    }\n }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/accounts/AccountTypePreferenceLoader.java",
                                    "total_hunks": 3,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\nimport android.content.ClipData;\nimport android.content.ContentResolver;\n>>>>>>> UPSTREAM PATCH (commit 841fb3846b25dee4ae5924fd798cd48709c69801)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -20,6 +20,7 @@ package com.android.settings.accounts;\n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n import android.content.ClipData;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n```",
                                    "patch_apply_output": "patching file src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nHunk #1 FAILED at 20.\nHunk #2 succeeded at 181 (offset -5 lines).\nHunk #3 succeeded at 237 (offset -5 lines).\n1 out of 3 hunks FAILED -- saving rejects to file src/com/android/settings/accounts/AccountTypePreferenceLoader.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nHunk #1 NOT MERGED at 22-26."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "8fa1dcb0345a2f5f751a465c208aa496f7be642a",
                            "result": "success",
                            "downstream_patch_content": "commit 8fa1dcb0345a2f5f751a465c208aa496f7be642a\nAuthor: Jason Chiu <chiujason@google.com>\nDate:   Thu Nov 7 15:33:53 2024 +0800\n\n    Block the content scheme intent in AccountTypePreferenceLoader\n    \n    Bug: 366401629\n    Flag: EXEMPT security fix\n    Test: atest AccountTypePreferenceLoaderTest, manual\n    Change-Id: Ica87087341cc983df04190919e33dc369fa18619\n    Merged-In: Ica87087341cc983df04190919e33dc369fa18619\n    (cherry picked from commit 841fb3846b25dee4ae5924fd798cd48709c69801)\n\ndiff --git a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nindex 16519af6730..7cfeb1cc193 100644\n--- a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -20,6 +20,7 @@ package com.android.settings.accounts;\n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n import android.content.ClipData;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n@@ -185,9 +186,9 @@ public class AccountTypePreferenceLoader {\n                                     prefIntent, mUserHandle);\n                             } else {\n                                 Log.e(TAG,\n-                                    \"Refusing to launch authenticator intent because\"\n-                                        + \"it exploits Settings permissions: \"\n-                                        + prefIntent);\n+                                        \"Refusing to launch authenticator intent because \"\n+                                                + \"it exploits Settings permissions: \"\n+                                                + prefIntent);\n                             }\n                             return true;\n                         }\n@@ -241,13 +242,19 @@ public class AccountTypePreferenceLoader {\n     }\n \n     /**\n-     * Determines if the supplied Intent is safe. A safe intent is one that is\n-     * will launch a exported=true activity or owned by the same uid as the\n+     * Determines if the supplied Intent is safe. A safe intent is one that\n+     * will launch an exported=true activity or owned by the same uid as the\n      * authenticator supplying the intent.\n      */\n-    private boolean isSafeIntent(PackageManager pm, Intent intent, String acccountType) {\n+    @VisibleForTesting\n+    boolean isSafeIntent(PackageManager pm, Intent intent, String accountType) {\n+        if (TextUtils.equals(intent.getScheme(), ContentResolver.SCHEME_CONTENT)) {\n+            Log.e(TAG, \"Intent with a content scheme is unsafe.\");\n+            return false;\n+        }\n+\n         AuthenticatorDescription authDesc =\n-            mAuthenticatorHelper.getAccountTypeDescription(acccountType);\n+                mAuthenticatorHelper.getAccountTypeDescription(accountType);\n         ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mUserHandle.getIdentifier());\n         if (resolveInfo == null) {\n             return false;\ndiff --git a/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java b/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\nindex 405f6b3dbb8..5e566004a1e 100644\n--- a/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\n+++ b/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\n@@ -16,6 +16,8 @@\n \n package com.android.settings.accounts;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.mockito.Answers.RETURNS_DEEP_STUBS;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.Mockito.mock;\n@@ -26,8 +28,11 @@ import static org.mockito.Mockito.when;\n import android.accounts.Account;\n import android.accounts.AccountManager;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ClipData;\n import android.content.Context;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n+import android.net.Uri;\n import android.os.UserHandle;\n \n import androidx.preference.Preference;\n@@ -129,4 +134,13 @@ public class AccountTypePreferenceLoaderTest {\n         verify(mPrefLoader).updatePreferenceIntents(prefGroup4, acctType, mAccount);\n         verify(mPrefLoader).updatePreferenceIntents(prefGroup41, acctType, mAccount);\n     }\n+\n+    @Test\n+    public void isSafeIntent_hasContextScheme_returnFalse() {\n+        Intent intent = new Intent();\n+        intent.setClipData(ClipData.newRawUri(null,\n+                Uri.parse(\"content://com.android.settings.files/my_cache/NOTICE.html\")));\n+\n+        assertThat(mPrefLoader.isSafeIntent(mPackageManager, intent, mAccount.type)).isFalse();\n+    }\n }\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-304497167",
            "aliases": [
                "A-304497167",
                "CVE-2025-26417"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-304497167",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "bf66a79ddcd8d93f502bf908621469893f513780"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From bf66a79ddcd8d93f502bf908621469893f513780 Mon Sep 17 00:00:00 2001\nFrom: Himanshu Arora <hmarora@google.com>\nDate: Wed, 18 Dec 2024 12:40:54 +0000\nSubject: [PATCH] Ensure ownership validation in downloadprovider insert method\n\nEarlier, apps could access any file in Downloads by invoking the insert method in Downloadprovider. Now, it includes a check to ensure no existing record is present in Mediaprovider. If a record exists, the method validates the ownerPackageName before proceeding with the insert operation\n\nBug: 304497167\nTest: manual\nFlag: EXEMPT, fix only\nChange-Id: I8b2d24974cdf3ae8a9e5680c22cf422bce396940\n---\n .../providers/downloads/DownloadProvider.java | 41 +++++++++++++++++++\n 1 file changed, 41 insertions(+)\n\ndiff --git a/src/com/android/providers/downloads/DownloadProvider.java b/src/com/android/providers/downloads/DownloadProvider.java\nindex a89edea9..c43e8c6d 100644\n--- a/src/com/android/providers/downloads/DownloadProvider.java\n+++ b/src/com/android/providers/downloads/DownloadProvider.java\n@@ -84,6 +84,7 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.util.Arrays;\n import java.util.Iterator;\n import java.util.Map;\n \n@@ -1118,8 +1119,48 @@ public final class DownloadProvider extends ContentProvider {\n         Helpers.checkDestinationFilePathRestrictions(file, getCallingPackage(), getContext(),\n                 mAppOpsManager, getCallingAttributionTag(), isLegacyMode,\n                 /* allowDownloadsDirOnly */ true);\n+        // check whether record already exists in MP or getCallingPackage owns this file\n+        checkWhetherCallingAppHasAccess(file.getPath(), Binder.getCallingUid());\n     }\n \n+    private void checkWhetherCallingAppHasAccess(String filePath, int uid) {\n+        try (ContentProviderClient client = getContext().getContentResolver()\n+                .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n+            if (client == null) {\n+                Log.w(Constants.TAG, \"Failed to acquire ContentProviderClient for MediaStore\");\n+                return;\n+            }\n+\n+            Uri filesUri = MediaStore.setIncludePending(\n+                    Helpers.getContentUriForPath(getContext(), filePath));\n+\n+            try (Cursor cursor = client.query(filesUri,\n+                    new String[]{MediaStore.Files.FileColumns._ID,\n+                            MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME},\n+                    MediaStore.Files.FileColumns.DATA + \"=?\", new String[]{filePath},\n+                    null)) {\n+                if (cursor != null && cursor.moveToFirst()) {\n+                    String fetchedOwnerPackageName = cursor.getString(\n+                            cursor.getColumnIndexOrThrow(\n+                                    MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME));\n+                    String[] packageNames = getContext().getPackageManager().getPackagesForUid(uid);\n+\n+                    if (fetchedOwnerPackageName != null && packageNames != null) {\n+                        boolean isCallerAuthorized = Arrays.asList(packageNames)\n+                                .contains(fetchedOwnerPackageName);\n+                        if (!isCallerAuthorized) {\n+                            throw new SecurityException(\"Caller does not have access to this path\");\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (RemoteException e) {\n+            Log.w(Constants.TAG, \"Failed to query MediaStore: \" + e.getMessage());\n+        }\n+    }\n+\n+\n+\n     /**\n      * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n      * constraints in the rest of the code. Apps without that may still access this provider through\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 3,
                    "failed_patches": 1,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "7139559a207f7cfbabe86c143292042c3bf77d7e",
                            "result": "failure",
                            "downstream_patch_content": "commit 7139559a207f7cfbabe86c143292042c3bf77d7e\nAuthor: Himanshu Arora <hmarora@google.com>\nDate:   Wed Dec 18 12:40:54 2024 +0000\n\n    Ensure ownership validation in downloadprovider insert method\n    \n    Earlier, apps could access any file in Downloads by invoking the insert method in Downloadprovider. Now, it includes a check to ensure no existing record is present in Mediaprovider. If a record exists, the method validates the ownerPackageName before proceeding with the insert operation\n    \n    Bug: 304497167\n    Test: manual\n    Flag: EXEMPT, fix only\n    Change-Id: I8b2d24974cdf3ae8a9e5680c22cf422bce396940\n    (cherry picked from commit bf66a79ddcd8d93f502bf908621469893f513780)\n    Merged-In: I8b2d24974cdf3ae8a9e5680c22cf422bce396940\n\ndiff --git a/src/com/android/providers/downloads/DownloadProvider.java b/src/com/android/providers/downloads/DownloadProvider.java\nindex 1afa0901..70650d70 100644\n--- a/src/com/android/providers/downloads/DownloadProvider.java\n+++ b/src/com/android/providers/downloads/DownloadProvider.java\n@@ -84,6 +84,7 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.util.Arrays;\n import java.util.Iterator;\n import java.util.Map;\n \n@@ -1103,8 +1104,48 @@ public final class DownloadProvider extends ContentProvider {\n         Helpers.checkDestinationFilePathRestrictions(file, getCallingPackage(), getContext(),\n                 mAppOpsManager, getCallingAttributionTag(), isLegacyMode,\n                 /* allowDownloadsDirOnly */ true);\n+        // check whether record already exists in MP or getCallingPackage owns this file\n+        checkWhetherCallingAppHasAccess(file.getPath(), Binder.getCallingUid());\n     }\n \n+    private void checkWhetherCallingAppHasAccess(String filePath, int uid) {\n+        try (ContentProviderClient client = getContext().getContentResolver()\n+                .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n+            if (client == null) {\n+                Log.w(Constants.TAG, \"Failed to acquire ContentProviderClient for MediaStore\");\n+                return;\n+            }\n+\n+            Uri filesUri = MediaStore.setIncludePending(\n+                    Helpers.getContentUriForPath(getContext(), filePath));\n+\n+            try (Cursor cursor = client.query(filesUri,\n+                    new String[]{MediaStore.Files.FileColumns._ID,\n+                            MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME},\n+                    MediaStore.Files.FileColumns.DATA + \"=?\", new String[]{filePath},\n+                    null)) {\n+                if (cursor != null && cursor.moveToFirst()) {\n+                    String fetchedOwnerPackageName = cursor.getString(\n+                            cursor.getColumnIndexOrThrow(\n+                                    MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME));\n+                    String[] packageNames = getContext().getPackageManager().getPackagesForUid(uid);\n+\n+                    if (fetchedOwnerPackageName != null && packageNames != null) {\n+                        boolean isCallerAuthorized = Arrays.asList(packageNames)\n+                                .contains(fetchedOwnerPackageName);\n+                        if (!isCallerAuthorized) {\n+                            throw new SecurityException(\"Caller does not have access to this path\");\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (RemoteException e) {\n+            Log.w(Constants.TAG, \"Failed to query MediaStore: \" + e.getMessage());\n+        }\n+    }\n+\n+\n+\n     /**\n      * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n      * constraints in the rest of the code. Apps without that may still access this provider through\n",
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/providers/downloads/DownloadProvider.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n                return ai.targetSdkVersion;\n            }\n        }\n        return Build.VERSION_CODES.CUR_DEVELOPMENT;\n=======\n        Helpers.checkDestinationFilePathRestrictions(file, getCallingPackage(), getContext(),\n                mAppOpsManager, getCallingAttributionTag(), isLegacyMode,\n                /* allowDownloadsDirOnly */ true);\n        // check whether record already exists in MP or getCallingPackage owns this file\n        checkWhetherCallingAppHasAccess(file.getPath(), Binder.getCallingUid());\n>>>>>>> UPSTREAM PATCH (commit bf66a79ddcd8d93f502bf908621469893f513780)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- src/com/android/providers/downloads/DownloadProvider.java\n+++ src/com/android/providers/downloads/DownloadProvider.java\n@@ -1119,8 +1120,48 @@ public final class DownloadProvider extends ContentProvider {\n         Helpers.checkDestinationFilePathRestrictions(file, getCallingPackage(), getContext(),\n                 mAppOpsManager, getCallingAttributionTag(), isLegacyMode,\n                 /* allowDownloadsDirOnly */ true);\n+        // check whether record already exists in MP or getCallingPackage owns this file\n+        checkWhetherCallingAppHasAccess(file.getPath(), Binder.getCallingUid());\n     }\n \n+    private void checkWhetherCallingAppHasAccess(String filePath, int uid) {\n+        try (ContentProviderClient client = getContext().getContentResolver()\n+                .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n+            if (client == null) {\n+                Log.w(Constants.TAG, \"Failed to acquire ContentProviderClient for MediaStore\");\n+                return;\n+            }\n+\n+            Uri filesUri = MediaStore.setIncludePending(\n+                    Helpers.getContentUriForPath(getContext(), filePath));\n+\n+            try (Cursor cursor = client.query(filesUri,\n+                    new String[]{MediaStore.Files.FileColumns._ID,\n+                            MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME},\n+                    MediaStore.Files.FileColumns.DATA + \"=?\", new String[]{filePath},\n+                    null)) {\n+                if (cursor != null && cursor.moveToFirst()) {\n+                    String fetchedOwnerPackageName = cursor.getString(\n+                            cursor.getColumnIndexOrThrow(\n+                                    MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME));\n+                    String[] packageNames = getContext().getPackageManager().getPackagesForUid(uid);\n+\n+                    if (fetchedOwnerPackageName != null && packageNames != null) {\n+                        boolean isCallerAuthorized = Arrays.asList(packageNames)\n+                                .contains(fetchedOwnerPackageName);\n+                        if (!isCallerAuthorized) {\n+                            throw new SecurityException(\"Caller does not have access to this path\");\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (RemoteException e) {\n+            Log.w(Constants.TAG, \"Failed to query MediaStore: \" + e.getMessage());\n+        }\n+    }\n+\n+\n+\n     /**\n      * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n      * constraints in the rest of the code. Apps without that may still access this provider through\n```",
                                    "patch_apply_output": "patching file src/com/android/providers/downloads/DownloadProvider.java\nHunk #2 FAILED at 1119.\n1 out of 2 hunks FAILED -- saving rejects to file src/com/android/providers/downloads/DownloadProvider.java.rej",
                                    "inline_merge_output": "patching file src/com/android/providers/downloads/DownloadProvider.java\nHunk #2 NOT MERGED at 1166-1177, merged at 1180-1217."
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "7139559a207f7cfbabe86c143292042c3bf77d7e",
                            "result": "success",
                            "downstream_patch_content": "commit 7139559a207f7cfbabe86c143292042c3bf77d7e\nAuthor: Himanshu Arora <hmarora@google.com>\nDate:   Wed Dec 18 12:40:54 2024 +0000\n\n    Ensure ownership validation in downloadprovider insert method\n    \n    Earlier, apps could access any file in Downloads by invoking the insert method in Downloadprovider. Now, it includes a check to ensure no existing record is present in Mediaprovider. If a record exists, the method validates the ownerPackageName before proceeding with the insert operation\n    \n    Bug: 304497167\n    Test: manual\n    Flag: EXEMPT, fix only\n    Change-Id: I8b2d24974cdf3ae8a9e5680c22cf422bce396940\n    (cherry picked from commit bf66a79ddcd8d93f502bf908621469893f513780)\n    Merged-In: I8b2d24974cdf3ae8a9e5680c22cf422bce396940\n\ndiff --git a/src/com/android/providers/downloads/DownloadProvider.java b/src/com/android/providers/downloads/DownloadProvider.java\nindex 1afa0901..70650d70 100644\n--- a/src/com/android/providers/downloads/DownloadProvider.java\n+++ b/src/com/android/providers/downloads/DownloadProvider.java\n@@ -84,6 +84,7 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.util.Arrays;\n import java.util.Iterator;\n import java.util.Map;\n \n@@ -1103,8 +1104,48 @@ public final class DownloadProvider extends ContentProvider {\n         Helpers.checkDestinationFilePathRestrictions(file, getCallingPackage(), getContext(),\n                 mAppOpsManager, getCallingAttributionTag(), isLegacyMode,\n                 /* allowDownloadsDirOnly */ true);\n+        // check whether record already exists in MP or getCallingPackage owns this file\n+        checkWhetherCallingAppHasAccess(file.getPath(), Binder.getCallingUid());\n     }\n \n+    private void checkWhetherCallingAppHasAccess(String filePath, int uid) {\n+        try (ContentProviderClient client = getContext().getContentResolver()\n+                .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n+            if (client == null) {\n+                Log.w(Constants.TAG, \"Failed to acquire ContentProviderClient for MediaStore\");\n+                return;\n+            }\n+\n+            Uri filesUri = MediaStore.setIncludePending(\n+                    Helpers.getContentUriForPath(getContext(), filePath));\n+\n+            try (Cursor cursor = client.query(filesUri,\n+                    new String[]{MediaStore.Files.FileColumns._ID,\n+                            MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME},\n+                    MediaStore.Files.FileColumns.DATA + \"=?\", new String[]{filePath},\n+                    null)) {\n+                if (cursor != null && cursor.moveToFirst()) {\n+                    String fetchedOwnerPackageName = cursor.getString(\n+                            cursor.getColumnIndexOrThrow(\n+                                    MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME));\n+                    String[] packageNames = getContext().getPackageManager().getPackagesForUid(uid);\n+\n+                    if (fetchedOwnerPackageName != null && packageNames != null) {\n+                        boolean isCallerAuthorized = Arrays.asList(packageNames)\n+                                .contains(fetchedOwnerPackageName);\n+                        if (!isCallerAuthorized) {\n+                            throw new SecurityException(\"Caller does not have access to this path\");\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (RemoteException e) {\n+            Log.w(Constants.TAG, \"Failed to query MediaStore: \" + e.getMessage());\n+        }\n+    }\n+\n+\n+\n     /**\n      * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n      * constraints in the rest of the code. Apps without that may still access this provider through\n"
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "a2e3e8c7bec2b51f9192ca44757f170c0bde34a5"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "7139559a207f7cfbabe86c143292042c3bf77d7e",
                            "result": "success",
                            "downstream_patch_content": "commit 7139559a207f7cfbabe86c143292042c3bf77d7e\nAuthor: Himanshu Arora <hmarora@google.com>\nDate:   Wed Dec 18 12:40:54 2024 +0000\n\n    Ensure ownership validation in downloadprovider insert method\n    \n    Earlier, apps could access any file in Downloads by invoking the insert method in Downloadprovider. Now, it includes a check to ensure no existing record is present in Mediaprovider. If a record exists, the method validates the ownerPackageName before proceeding with the insert operation\n    \n    Bug: 304497167\n    Test: manual\n    Flag: EXEMPT, fix only\n    Change-Id: I8b2d24974cdf3ae8a9e5680c22cf422bce396940\n    (cherry picked from commit bf66a79ddcd8d93f502bf908621469893f513780)\n    Merged-In: I8b2d24974cdf3ae8a9e5680c22cf422bce396940\n\ndiff --git a/src/com/android/providers/downloads/DownloadProvider.java b/src/com/android/providers/downloads/DownloadProvider.java\nindex 1afa0901..70650d70 100644\n--- a/src/com/android/providers/downloads/DownloadProvider.java\n+++ b/src/com/android/providers/downloads/DownloadProvider.java\n@@ -84,6 +84,7 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.util.Arrays;\n import java.util.Iterator;\n import java.util.Map;\n \n@@ -1103,8 +1104,48 @@ public final class DownloadProvider extends ContentProvider {\n         Helpers.checkDestinationFilePathRestrictions(file, getCallingPackage(), getContext(),\n                 mAppOpsManager, getCallingAttributionTag(), isLegacyMode,\n                 /* allowDownloadsDirOnly */ true);\n+        // check whether record already exists in MP or getCallingPackage owns this file\n+        checkWhetherCallingAppHasAccess(file.getPath(), Binder.getCallingUid());\n     }\n \n+    private void checkWhetherCallingAppHasAccess(String filePath, int uid) {\n+        try (ContentProviderClient client = getContext().getContentResolver()\n+                .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n+            if (client == null) {\n+                Log.w(Constants.TAG, \"Failed to acquire ContentProviderClient for MediaStore\");\n+                return;\n+            }\n+\n+            Uri filesUri = MediaStore.setIncludePending(\n+                    Helpers.getContentUriForPath(getContext(), filePath));\n+\n+            try (Cursor cursor = client.query(filesUri,\n+                    new String[]{MediaStore.Files.FileColumns._ID,\n+                            MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME},\n+                    MediaStore.Files.FileColumns.DATA + \"=?\", new String[]{filePath},\n+                    null)) {\n+                if (cursor != null && cursor.moveToFirst()) {\n+                    String fetchedOwnerPackageName = cursor.getString(\n+                            cursor.getColumnIndexOrThrow(\n+                                    MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME));\n+                    String[] packageNames = getContext().getPackageManager().getPackagesForUid(uid);\n+\n+                    if (fetchedOwnerPackageName != null && packageNames != null) {\n+                        boolean isCallerAuthorized = Arrays.asList(packageNames)\n+                                .contains(fetchedOwnerPackageName);\n+                        if (!isCallerAuthorized) {\n+                            throw new SecurityException(\"Caller does not have access to this path\");\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (RemoteException e) {\n+            Log.w(Constants.TAG, \"Failed to query MediaStore: \" + e.getMessage());\n+        }\n+    }\n+\n+\n+\n     /**\n      * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n      * constraints in the rest of the code. Apps without that may still access this provider through\n"
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "7139559a207f7cfbabe86c143292042c3bf77d7e",
                            "result": "success",
                            "downstream_patch_content": "commit 7139559a207f7cfbabe86c143292042c3bf77d7e\nAuthor: Himanshu Arora <hmarora@google.com>\nDate:   Wed Dec 18 12:40:54 2024 +0000\n\n    Ensure ownership validation in downloadprovider insert method\n    \n    Earlier, apps could access any file in Downloads by invoking the insert method in Downloadprovider. Now, it includes a check to ensure no existing record is present in Mediaprovider. If a record exists, the method validates the ownerPackageName before proceeding with the insert operation\n    \n    Bug: 304497167\n    Test: manual\n    Flag: EXEMPT, fix only\n    Change-Id: I8b2d24974cdf3ae8a9e5680c22cf422bce396940\n    (cherry picked from commit bf66a79ddcd8d93f502bf908621469893f513780)\n    Merged-In: I8b2d24974cdf3ae8a9e5680c22cf422bce396940\n\ndiff --git a/src/com/android/providers/downloads/DownloadProvider.java b/src/com/android/providers/downloads/DownloadProvider.java\nindex 1afa0901..70650d70 100644\n--- a/src/com/android/providers/downloads/DownloadProvider.java\n+++ b/src/com/android/providers/downloads/DownloadProvider.java\n@@ -84,6 +84,7 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.util.Arrays;\n import java.util.Iterator;\n import java.util.Map;\n \n@@ -1103,8 +1104,48 @@ public final class DownloadProvider extends ContentProvider {\n         Helpers.checkDestinationFilePathRestrictions(file, getCallingPackage(), getContext(),\n                 mAppOpsManager, getCallingAttributionTag(), isLegacyMode,\n                 /* allowDownloadsDirOnly */ true);\n+        // check whether record already exists in MP or getCallingPackage owns this file\n+        checkWhetherCallingAppHasAccess(file.getPath(), Binder.getCallingUid());\n     }\n \n+    private void checkWhetherCallingAppHasAccess(String filePath, int uid) {\n+        try (ContentProviderClient client = getContext().getContentResolver()\n+                .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n+            if (client == null) {\n+                Log.w(Constants.TAG, \"Failed to acquire ContentProviderClient for MediaStore\");\n+                return;\n+            }\n+\n+            Uri filesUri = MediaStore.setIncludePending(\n+                    Helpers.getContentUriForPath(getContext(), filePath));\n+\n+            try (Cursor cursor = client.query(filesUri,\n+                    new String[]{MediaStore.Files.FileColumns._ID,\n+                            MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME},\n+                    MediaStore.Files.FileColumns.DATA + \"=?\", new String[]{filePath},\n+                    null)) {\n+                if (cursor != null && cursor.moveToFirst()) {\n+                    String fetchedOwnerPackageName = cursor.getString(\n+                            cursor.getColumnIndexOrThrow(\n+                                    MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME));\n+                    String[] packageNames = getContext().getPackageManager().getPackagesForUid(uid);\n+\n+                    if (fetchedOwnerPackageName != null && packageNames != null) {\n+                        boolean isCallerAuthorized = Arrays.asList(packageNames)\n+                                .contains(fetchedOwnerPackageName);\n+                        if (!isCallerAuthorized) {\n+                            throw new SecurityException(\"Caller does not have access to this path\");\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (RemoteException e) {\n+            Log.w(Constants.TAG, \"Failed to query MediaStore: \" + e.getMessage());\n+        }\n+    }\n+\n+\n+\n     /**\n      * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n      * constraints in the rest of the code. Apps without that may still access this provider through\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-281848557",
            "aliases": [
                "A-281848557",
                "CVE-2023-40135"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-281848557",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "bf7fbbccd920596e514d1559fb3feaca70e55e78"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From bf7fbbccd920596e514d1559fb3feaca70e55e78 Mon Sep 17 00:00:00 2001\nFrom: Tim Yu <yunicorn@google.com>\nDate: Tue, 20 Jun 2023 21:24:36 +0000\nSubject: [PATCH] [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n\nCheck permissions of URI inside of FillResponse's RemoteViews. If the\ncurrent user does not have the required permissions to view the URI, the\nRemoteView is dropped from displaying.\n\nThis fixes a security spill in which a user can view content of another\nuser through a malicious Autofill provider.\n\nBug: 283137865\nFixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\nb/281534749 b/283101289\nTest: Verified by POC app attached in bugs\nTest: atest CtsAutoFillServiceTestCases (added new tests)\nChange-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n---\n .../com/android/server/autofill/Helper.java   | 43 +++++++++++++++++++\n .../server/autofill/ui/DialogFillUi.java      | 12 ++++--\n .../android/server/autofill/ui/FillUi.java    | 11 +++--\n .../android/server/autofill/ui/SaveUi.java    |  3 +-\n 4 files changed, 60 insertions(+), 9 deletions(-)\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex 82af38200166..ad8f5e1481e1 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -20,6 +20,8 @@ import static com.android.server.autofill.Helper.sDebug;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -40,6 +42,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -50,6 +53,8 @@ import java.lang.ref.WeakReference;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -83,6 +88,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed & permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex dbeb624bd202..fa414e3b172b 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -53,6 +53,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -208,7 +209,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -243,9 +245,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -289,7 +292,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 129ce72e037d..cdfe7bb4f4a7 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -148,8 +148,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -227,6 +228,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -306,7 +310,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex f035d0764279..70382f1d5274 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -384,8 +384,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 1,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "73fa082a7202100da107ae14dd7742ecd86da053",
                            "result": "failure",
                            "downstream_patch_content": "commit 73fa082a7202100da107ae14dd7742ecd86da053\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "f7ca136c514dc975c3f46d95c53fd6b3752c577a",
                            "result": "failure",
                            "downstream_patch_content": "commit f7ca136c514dc975c3f46d95c53fd6b3752c577a\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "93810ba1c0a4d31f49adbf9454731e2b7defdfc0",
                            "result": "success",
                            "downstream_patch_content": "commit 93810ba1c0a4d31f49adbf9454731e2b7defdfc0\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n    Merged-In: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex c2c630e01bee..59184e9ed288 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -52,6 +52,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -197,7 +198,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -232,9 +234,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -278,7 +281,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 8fbdd81cc4cc..76fa258734cc 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -144,8 +144,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -223,6 +224,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -302,7 +306,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 677871f6c85f..533a7b69a650 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-281533566",
            "aliases": [
                "A-281533566",
                "CVE-2023-40139"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-281533566",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "bf7fbbccd920596e514d1559fb3feaca70e55e78"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From bf7fbbccd920596e514d1559fb3feaca70e55e78 Mon Sep 17 00:00:00 2001\nFrom: Tim Yu <yunicorn@google.com>\nDate: Tue, 20 Jun 2023 21:24:36 +0000\nSubject: [PATCH] [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n\nCheck permissions of URI inside of FillResponse's RemoteViews. If the\ncurrent user does not have the required permissions to view the URI, the\nRemoteView is dropped from displaying.\n\nThis fixes a security spill in which a user can view content of another\nuser through a malicious Autofill provider.\n\nBug: 283137865\nFixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\nb/281534749 b/283101289\nTest: Verified by POC app attached in bugs\nTest: atest CtsAutoFillServiceTestCases (added new tests)\nChange-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n---\n .../com/android/server/autofill/Helper.java   | 43 +++++++++++++++++++\n .../server/autofill/ui/DialogFillUi.java      | 12 ++++--\n .../android/server/autofill/ui/FillUi.java    | 11 +++--\n .../android/server/autofill/ui/SaveUi.java    |  3 +-\n 4 files changed, 60 insertions(+), 9 deletions(-)\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex 82af38200166..ad8f5e1481e1 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -20,6 +20,8 @@ import static com.android.server.autofill.Helper.sDebug;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -40,6 +42,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -50,6 +53,8 @@ import java.lang.ref.WeakReference;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -83,6 +88,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed & permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex dbeb624bd202..fa414e3b172b 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -53,6 +53,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -208,7 +209,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -243,9 +245,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -289,7 +292,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 129ce72e037d..cdfe7bb4f4a7 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -148,8 +148,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -227,6 +228,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -306,7 +310,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex f035d0764279..70382f1d5274 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -384,8 +384,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 1,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "73fa082a7202100da107ae14dd7742ecd86da053",
                            "result": "failure",
                            "downstream_patch_content": "commit 73fa082a7202100da107ae14dd7742ecd86da053\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "f7ca136c514dc975c3f46d95c53fd6b3752c577a",
                            "result": "failure",
                            "downstream_patch_content": "commit f7ca136c514dc975c3f46d95c53fd6b3752c577a\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "93810ba1c0a4d31f49adbf9454731e2b7defdfc0",
                            "result": "success",
                            "downstream_patch_content": "commit 93810ba1c0a4d31f49adbf9454731e2b7defdfc0\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n    Merged-In: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex c2c630e01bee..59184e9ed288 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -52,6 +52,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -197,7 +198,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -232,9 +234,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -278,7 +281,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 8fbdd81cc4cc..76fa258734cc 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -144,8 +144,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -223,6 +224,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -302,7 +306,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 677871f6c85f..533a7b69a650 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-355411348",
            "aliases": [
                "A-355411348",
                "CVE-2024-49720"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-355411348",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "7e1f7097f4a6895358bf1472e6d26c5198d00c11"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 7e1f7097f4a6895358bf1472e6d26c5198d00c11 Mon Sep 17 00:00:00 2001\nFrom: mrulhania <mrulhania@google.com>\nDate: Thu, 24 Oct 2024 14:29:30 -0700\nSubject: [PATCH] Role re-evaluation should respect ask every time choice by\n user\n\nRole evalation respect USER_SET flag when the role is not\nsupposed to override user choices. Role granting logic\nis missing ONE_TIME check, ONE_TIME flag should be considered\na user choice.\n\nFix: 355411348\nTest: tbd\nFLAG: EXEMPT bug fix\nRelnote: security bug fix\nChange-Id: Ie65c2cd62ba3f24e8dd411abca49e397746bc1a9\n---\n .../java/com/android/role/controller/model/Permissions.java | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\ndiff --git a/PermissionController/role-controller/java/com/android/role/controller/model/Permissions.java b/PermissionController/role-controller/java/com/android/role/controller/model/Permissions.java\nindex ed21db7bb1..820ff3d4e4 100644\n--- a/PermissionController/role-controller/java/com/android/role/controller/model/Permissions.java\n+++ b/PermissionController/role-controller/java/com/android/role/controller/model/Permissions.java\n@@ -263,7 +263,8 @@ public class Permissions {\n         if (!wasPermissionOrAppOpGranted) {\n             // If we've granted a permission which wasn't granted, it's no longer user set or fixed.\n             newMask |= PackageManager.FLAG_PERMISSION_USER_FIXED\n-                    | PackageManager.FLAG_PERMISSION_USER_SET;\n+                    | PackageManager.FLAG_PERMISSION_USER_SET\n+                    | PackageManager.FLAG_PERMISSION_ONE_TIME;\n         }\n         // If a component gets a permission for being the default handler A and also default handler\n         // B, we grant the weaker grant form. This only applies to default permission grant.\n@@ -634,7 +635,8 @@ public class Permissions {\n         }\n         if (!overrideUserSetAndFixed) {\n             fixedFlags |= PackageManager.FLAG_PERMISSION_USER_FIXED\n-                    | PackageManager.FLAG_PERMISSION_USER_SET;\n+                    | PackageManager.FLAG_PERMISSION_USER_SET\n+                    | PackageManager.FLAG_PERMISSION_ONE_TIME;\n         }\n         return (flags & fixedFlags) != 0;\n     }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 1,
                    "failed_patches": 1,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "15b296865950d19076a065d8b293d28eae4a3af2"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "71e09e5ad12d02b3129c7a5ce16f6de734fdd0da",
                            "result": "failure",
                            "downstream_patch_content": "commit 71e09e5ad12d02b3129c7a5ce16f6de734fdd0da\nAuthor: Manjeet Rulhania <mrulhania@google.com>\nDate:   Wed Oct 30 20:18:46 2024 +0000\n\n    Role re-evaluation should respect ask every time choice by user\n    \n    Role evalation respect USER_SET flag when the role is not\n    supposed to override user choices. Role granting logic\n    is missing ONE_TIME check, ONE_TIME flag should be considered\n    a user choice.\n    \n    Bug: 355411348\n    Change-Id: I4146abff462ef4ed0e67efd04b4182bcf2c04d98\n    Test: RolePermissionOverrideTest\n    Relnote: security bug fix\n    Merged-In: Ie65c2cd62ba3f24e8dd411abca49e397746bc1a9\n\ndiff --git a/PermissionController/src/com/android/permissioncontroller/role/model/Permissions.java b/PermissionController/src/com/android/permissioncontroller/role/model/Permissions.java\nindex dee675bd06..ab56518f32 100644\n--- a/PermissionController/src/com/android/permissioncontroller/role/model/Permissions.java\n+++ b/PermissionController/src/com/android/permissioncontroller/role/model/Permissions.java\n@@ -253,7 +253,8 @@ public class Permissions {\n         if (!wasPermissionOrAppOpGranted) {\n             // If we've granted a permission which wasn't granted, it's no longer user set or fixed.\n             newMask |= PackageManager.FLAG_PERMISSION_USER_FIXED\n-                    | PackageManager.FLAG_PERMISSION_USER_SET;\n+                    | PackageManager.FLAG_PERMISSION_USER_SET\n+                    | PackageManager.FLAG_PERMISSION_ONE_TIME;\n         }\n         // If a component gets a permission for being the default handler A and also default handler\n         // B, we grant the weaker grant form. This only applies to default permission grant.\n@@ -607,7 +608,8 @@ public class Permissions {\n         }\n         if (!overrideUserSetAndFixed) {\n             fixedFlags |= PackageManager.FLAG_PERMISSION_USER_FIXED\n-                    | PackageManager.FLAG_PERMISSION_USER_SET;\n+                    | PackageManager.FLAG_PERMISSION_USER_SET\n+                    | PackageManager.FLAG_PERMISSION_ONE_TIME;\n         }\n         return (flags & fixedFlags) != 0;\n     }\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "04e3f30193b80d0fdb7f68cbe0161dc985aa7557",
                            "result": "success",
                            "downstream_patch_content": "commit 04e3f30193b80d0fdb7f68cbe0161dc985aa7557\nAuthor: mrulhania <mrulhania@google.com>\nDate:   Thu Oct 24 14:29:30 2024 -0700\n\n    Role re-evaluation should respect ask every time choice by user\n    \n    Role evalation respect USER_SET flag when the role is not\n    supposed to override user choices. Role granting logic\n    is missing ONE_TIME check, ONE_TIME flag should be considered\n    a user choice.\n    \n    Fix: 355411348\n    Test: RolePermissionOverrideTest\n    FLAG: EXEMPT bug fix\n    Relnote: security bug fix\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:7e1f7097f4a6895358bf1472e6d26c5198d00c11)\n    Merged-In: Ie65c2cd62ba3f24e8dd411abca49e397746bc1a9\n    Change-Id: Ie65c2cd62ba3f24e8dd411abca49e397746bc1a9\n\ndiff --git a/PermissionController/role-controller/java/com/android/role/controller/model/Permissions.java b/PermissionController/role-controller/java/com/android/role/controller/model/Permissions.java\nindex f55a84c07a..83e3b19326 100644\n--- a/PermissionController/role-controller/java/com/android/role/controller/model/Permissions.java\n+++ b/PermissionController/role-controller/java/com/android/role/controller/model/Permissions.java\n@@ -249,7 +249,8 @@ public class Permissions {\n         if (!wasPermissionOrAppOpGranted) {\n             // If we've granted a permission which wasn't granted, it's no longer user set or fixed.\n             newMask |= PackageManager.FLAG_PERMISSION_USER_FIXED\n-                    | PackageManager.FLAG_PERMISSION_USER_SET;\n+                    | PackageManager.FLAG_PERMISSION_USER_SET\n+                    | PackageManager.FLAG_PERMISSION_ONE_TIME;\n         }\n         // If a component gets a permission for being the default handler A and also default handler\n         // B, we grant the weaker grant form. This only applies to default permission grant.\n@@ -606,7 +607,8 @@ public class Permissions {\n         }\n         if (!overrideUserSetAndFixed) {\n             fixedFlags |= PackageManager.FLAG_PERMISSION_USER_FIXED\n-                    | PackageManager.FLAG_PERMISSION_USER_SET;\n+                    | PackageManager.FLAG_PERMISSION_USER_SET\n+                    | PackageManager.FLAG_PERMISSION_ONE_TIME;\n         }\n         return (flags & fixedFlags) != 0;\n     }\n"
                        }
                    ]
                }
            ]
        }
    ],
    "vulnerabilities_with_all_successful_patches": [
        {
            "id": "ASB-A-251514170",
            "aliases": [
                "A-251514170",
                "CVE-2024-34722"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-251514170",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "eaa367379e0f08d5ab3167ac49136343e0c87e52"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From eaa367379e0f08d5ab3167ac49136343e0c87e52 Mon Sep 17 00:00:00 2001\nFrom: Hui Peng <phui@google.com>\nDate: Wed, 24 Jan 2024 02:07:32 -0800\nSubject: [PATCH] Fix an authentication bypass bug in SMP\n\nWhen pairing with BLE legacy pairing initiated\nfrom remote, authentication can be bypassed.\nThis change fixes it.\n\nBug: 251514170\nBug: 321300737\nTest: m com.android.btservices\nTest: manual run against PoC\nIgnore-AOSP-First: security\nChange-Id: Id36c06beb13bcbc9b499ef59f6d4e43ac616da10\n---\n system/stack/smp/smp_act.cc | 14 ++++++++++++++\n system/stack/smp/smp_int.h  |  2 ++\n 2 files changed, 16 insertions(+)\n\ndiff --git a/system/stack/smp/smp_act.cc b/system/stack/smp/smp_act.cc\nindex 2222c036cd..93360e76f9 100644\n--- a/system/stack/smp/smp_act.cc\n+++ b/system/stack/smp/smp_act.cc\n@@ -318,6 +318,7 @@ void smp_send_pair_rsp(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n void smp_send_confirm(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n   LOG_VERBOSE(\"addr:%s\", ADDRESS_TO_LOGGABLE_CSTR(p_cb->pairing_bda));\n   smp_send_cmd(SMP_OPCODE_CONFIRM, p_cb);\n+  p_cb->flags |= SMP_PAIR_FLAGS_CMD_CONFIRM_SENT;\n }\n \n /*******************************************************************************\n@@ -683,6 +684,19 @@ void smp_proc_rand(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n     return;\n   }\n \n+  if (IS_FLAG_ENABLED(fix_le_pairing_passkey_entry_bypass)) {\n+    if (!((p_cb->loc_auth_req & SMP_SC_SUPPORT_BIT) &&\n+          (p_cb->peer_auth_req & SMP_SC_SUPPORT_BIT)) &&\n+        !(p_cb->flags & SMP_PAIR_FLAGS_CMD_CONFIRM_SENT)) {\n+      // in legacy pairing, the peer should send its rand after\n+      // we send our confirm\n+      tSMP_INT_DATA smp_int_data{};\n+      smp_int_data.status = SMP_INVALID_PARAMETERS;\n+      smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &smp_int_data);\n+      return;\n+    }\n+  }\n+\n   /* save the SRand for comparison */\n   STREAM_TO_ARRAY(p_cb->rrand.data(), p, OCTET16_LEN);\n }\ndiff --git a/system/stack/smp/smp_int.h b/system/stack/smp/smp_int.h\nindex bfb017ccd3..a7b98e92d3 100644\n--- a/system/stack/smp/smp_int.h\n+++ b/system/stack/smp/smp_int.h\n@@ -264,6 +264,8 @@ typedef union {\n #define SMP_PAIR_FLAG_HAVE_LOCAL_PUBL_KEY \\\n   (1 << 8) /* used on peripheral to resolve race condition */\n \n+#define SMP_PAIR_FLAGS_CMD_CONFIRM_SENT (1 << 9)\n+\n /* check if authentication requirement need MITM protection */\n #define SMP_NO_MITM_REQUIRED(x) (((x)&SMP_AUTH_YN_BIT) == 0)\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 4,
                    "successful_patches": 2,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12-release: Command '['git', 'checkout', 'android12-release']' returned non-zero exit status 1.",
                            "downstream_patch": "8a3dbadc71428a30b172a74343be08498c656747"
                        },
                        {
                            "downstream_version": "12L",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12L-release: Command '['git', 'checkout', 'android12L-release']' returned non-zero exit status 1.",
                            "downstream_patch": "8a3dbadc71428a30b172a74343be08498c656747"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "25a3fcd487c799d5d9029b8646159a0b10143d97",
                            "result": "success",
                            "downstream_patch_content": "commit 25a3fcd487c799d5d9029b8646159a0b10143d97\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Mon Apr 22 21:10:09 2024 +0000\n\n    Fix an authentication bypass bug in SMP\n    \n    When pairing with BLE legacy pairing initiated\n    from remote, authentication can be bypassed.\n    This change fixes it.\n    \n    Bug: 251514170\n    Test: m com.android.btservices\n    Test: manual run against PoC\n    Ignore-AOSP-First: security\n    Merged-In: Id36c06beb13bcbc9b499ef59f6d4e43ac616da10\n    Change-Id: I369a8fdd675eca731a7a488ed6a2be645058b795\n\ndiff --git a/system/stack/smp/smp_act.cc b/system/stack/smp/smp_act.cc\nindex 6d8f007c72..eb26e36270 100644\n--- a/system/stack/smp/smp_act.cc\n+++ b/system/stack/smp/smp_act.cc\n@@ -286,6 +286,7 @@ void smp_send_pair_rsp(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n void smp_send_confirm(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n   SMP_TRACE_DEBUG(\"%s\", __func__);\n   smp_send_cmd(SMP_OPCODE_CONFIRM, p_cb);\n+  p_cb->flags |= SMP_PAIR_FLAGS_CMD_CONFIRM_SENT;\n }\n \n /*******************************************************************************\n@@ -647,6 +648,17 @@ void smp_proc_init(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n     return;\n   }\n \n+  if (!((p_cb->loc_auth_req & SMP_SC_SUPPORT_BIT) &&\n+        (p_cb->peer_auth_req & SMP_SC_SUPPORT_BIT)) &&\n+      !(p_cb->flags & SMP_PAIR_FLAGS_CMD_CONFIRM_SENT)) {\n+    // in legacy pairing, the peer should send its rand after\n+    // we send our confirm\n+    tSMP_INT_DATA smp_int_data{};\n+    smp_int_data.status = SMP_INVALID_PARAMETERS;\n+    smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &smp_int_data);\n+    return;\n+  }\n+\n   /* save the SRand for comparison */\n   STREAM_TO_ARRAY(p_cb->rrand.data(), p, OCTET16_LEN);\n }\ndiff --git a/system/stack/smp/smp_int.h b/system/stack/smp/smp_int.h\nindex c4ddf3ec5e..cb88476ba2 100644\n--- a/system/stack/smp/smp_int.h\n+++ b/system/stack/smp/smp_int.h\n@@ -213,6 +213,7 @@ typedef union {\n   (1 << 7) /* used to resolve race condition */\n #define SMP_PAIR_FLAG_HAVE_LOCAL_PUBL_KEY \\\n   (1 << 8) /* used on peripheral to resolve race condition */\n+#define SMP_PAIR_FLAGS_CMD_CONFIRM_SENT (1 << 9)\n \n /* check if authentication requirement need MITM protection */\n #define SMP_NO_MITM_REQUIRED(x) (((x)&SMP_AUTH_YN_BIT) == 0)\n"
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "25a3fcd487c799d5d9029b8646159a0b10143d97",
                            "result": "success",
                            "downstream_patch_content": "commit 25a3fcd487c799d5d9029b8646159a0b10143d97\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Mon Apr 22 21:10:09 2024 +0000\n\n    Fix an authentication bypass bug in SMP\n    \n    When pairing with BLE legacy pairing initiated\n    from remote, authentication can be bypassed.\n    This change fixes it.\n    \n    Bug: 251514170\n    Test: m com.android.btservices\n    Test: manual run against PoC\n    Ignore-AOSP-First: security\n    Merged-In: Id36c06beb13bcbc9b499ef59f6d4e43ac616da10\n    Change-Id: I369a8fdd675eca731a7a488ed6a2be645058b795\n\ndiff --git a/system/stack/smp/smp_act.cc b/system/stack/smp/smp_act.cc\nindex 6d8f007c72..eb26e36270 100644\n--- a/system/stack/smp/smp_act.cc\n+++ b/system/stack/smp/smp_act.cc\n@@ -286,6 +286,7 @@ void smp_send_pair_rsp(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n void smp_send_confirm(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n   SMP_TRACE_DEBUG(\"%s\", __func__);\n   smp_send_cmd(SMP_OPCODE_CONFIRM, p_cb);\n+  p_cb->flags |= SMP_PAIR_FLAGS_CMD_CONFIRM_SENT;\n }\n \n /*******************************************************************************\n@@ -647,6 +648,17 @@ void smp_proc_init(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n     return;\n   }\n \n+  if (!((p_cb->loc_auth_req & SMP_SC_SUPPORT_BIT) &&\n+        (p_cb->peer_auth_req & SMP_SC_SUPPORT_BIT)) &&\n+      !(p_cb->flags & SMP_PAIR_FLAGS_CMD_CONFIRM_SENT)) {\n+    // in legacy pairing, the peer should send its rand after\n+    // we send our confirm\n+    tSMP_INT_DATA smp_int_data{};\n+    smp_int_data.status = SMP_INVALID_PARAMETERS;\n+    smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &smp_int_data);\n+    return;\n+  }\n+\n   /* save the SRand for comparison */\n   STREAM_TO_ARRAY(p_cb->rrand.data(), p, OCTET16_LEN);\n }\ndiff --git a/system/stack/smp/smp_int.h b/system/stack/smp/smp_int.h\nindex c4ddf3ec5e..cb88476ba2 100644\n--- a/system/stack/smp/smp_int.h\n+++ b/system/stack/smp/smp_int.h\n@@ -213,6 +213,7 @@ typedef union {\n   (1 << 7) /* used to resolve race condition */\n #define SMP_PAIR_FLAG_HAVE_LOCAL_PUBL_KEY \\\n   (1 << 8) /* used on peripheral to resolve race condition */\n+#define SMP_PAIR_FLAGS_CMD_CONFIRM_SENT (1 << 9)\n \n /* check if authentication requirement need MITM protection */\n #define SMP_NO_MITM_REQUIRED(x) (((x)&SMP_AUTH_YN_BIT) == 0)\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-370962373",
            "aliases": [
                "A-370962373",
                "CVE-2025-0099"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-370962373",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "692cddfb32abae6c77b00c4850fd36b7eaaf8c70"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 692cddfb32abae6c77b00c4850fd36b7eaaf8c70 Mon Sep 17 00:00:00 2001\nFrom: Raphael Kim <raphk@google.com>\nDate: Wed, 16 Oct 2024 14:42:21 -0700\nSubject: [PATCH] [CDM] Check for system calling UID when backing up and\n restoring data\n\nBug: 370962373\nTest: Manual test on POC\nFlag: EXEMPT bugfix\nChange-Id: I307940b7194dd17eacbbfb8be5c92ac21e688c65\n---\n .../server/companion/CompanionDeviceManagerService.java     | 6 ++++++\n 1 file changed, 6 insertions(+)\n\ndiff --git a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nindex 95281c81fc33..591107010431 100644\n--- a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -715,11 +715,17 @@ public class CompanionDeviceManagerService extends SystemService {\n \n         @Override\n         public byte[] getBackupPayload(int userId) {\n+            if (getCallingUid() != SYSTEM_UID) {\n+                throw new SecurityException(\"Caller must be system\");\n+            }\n             return mBackupRestoreProcessor.getBackupPayload(userId);\n         }\n \n         @Override\n         public void applyRestoredPayload(byte[] payload, int userId) {\n+            if (getCallingUid() != SYSTEM_UID) {\n+                throw new SecurityException(\"Caller must be system\");\n+            }\n             mBackupRestoreProcessor.applyRestoredPayload(payload, userId);\n         }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "191638ababfc5b03d63264b8932c5903f18543ba"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-375404242",
            "aliases": [
                "A-375404242",
                "CVE-2025-22412"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375404242",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "00555617ddbbc1a19089104c084d14f465c971ce"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 00555617ddbbc1a19089104c084d14f465c971ce Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Sat, 2 Nov 2024 02:29:10 +0000\nSubject: [PATCH] Fix more memory-unsafe logging\n\nIn various locations around the stack, log statements use structures that\nmay, in exceptional cases, have been freed by preceding calls.  This can\nlead to use after free and potentially to security vulnerabilities.\n\nUse local variables instead, or store the length before the call if no\nlocal variable is already convenient.\n\nBug: 375404242\nBug: 375398779\nBug: 375397720\nBug: 375397164\nBug: 375397370\nBug: 375396810\nBug: 375159652\nBug: 375160214\nBug: 375159480\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: Ia50e074de751661a0e617bfffa17871497b8d1ea\n---\n system/stack/avct/avct_lcb_act.cc    | 5 ++++-\n system/stack/bnep/bnep_main.cc       | 4 +++-\n system/stack/bnep/bnep_utils.cc      | 3 ++-\n system/stack/hid/hidd_conn.cc        | 4 ++--\n system/stack/rfcomm/rfc_ts_frames.cc | 3 ++-\n system/stack/rfcomm/rfc_utils.cc     | 3 ++-\n system/stack/sdp/sdp_discovery.cc    | 2 +-\n system/stack/sdp/sdp_server.cc       | 4 ++--\n 8 files changed, 18 insertions(+), 10 deletions(-)\n\ndiff --git a/system/stack/avct/avct_lcb_act.cc b/system/stack/avct/avct_lcb_act.cc\nindex 986bce7d34..32da9d865b 100644\n--- a/system/stack/avct/avct_lcb_act.cc\n+++ b/system/stack/avct/avct_lcb_act.cc\n@@ -727,10 +727,13 @@ void avct_lcb_msg_ind(tAVCT_LCB* p_lcb, tAVCT_LCB_EVT* p_data) {\n     p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n     AVCT_BUILD_HDR(p, label, AVCT_PKT_TYPE_SINGLE, AVCT_REJ);\n     UINT16_TO_BE_STREAM(p, pid);\n+\n+    uint16_t len = p_buf->len;\n+\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_lcb->ch_lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} lcid:0x{:04x} len:{}\", p_lcb->peer_addr,\n-                p_lcb->ch_lcid, p_buf->len);\n+                p_lcb->ch_lcid, len);\n     }\n   }\n }\ndiff --git a/system/stack/bnep/bnep_main.cc b/system/stack/bnep/bnep_main.cc\nindex e0e3c4540c..adf3c8666e 100644\n--- a/system/stack/bnep/bnep_main.cc\n+++ b/system/stack/bnep/bnep_main.cc\n@@ -295,10 +295,12 @@ static void bnep_congestion_ind(uint16_t l2cap_cid, bool is_congested) {\n         break;\n       }\n \n+      uint16_t len = p_buf->len;\n+\n       if (stack::l2cap::get_interface().L2CA_DataWrite(l2cap_cid, p_buf) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n         log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda, l2cap_cid,\n-                  p_buf->len);\n+                  len);\n       }\n     }\n   }\ndiff --git a/system/stack/bnep/bnep_utils.cc b/system/stack/bnep/bnep_utils.cc\nindex 252facf668..4092d9afee 100644\n--- a/system/stack/bnep/bnep_utils.cc\n+++ b/system/stack/bnep/bnep_utils.cc\n@@ -411,10 +411,11 @@ void bnepu_check_send_packet(tBNEP_CONN* p_bcb, BT_HDR* p_buf) {\n       fixed_queue_enqueue(p_bcb->xmit_q, p_buf);\n     }\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_bcb->l2cap_cid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda,\n-                p_bcb->l2cap_cid, p_buf->len);\n+                p_bcb->l2cap_cid, len);\n     }\n   }\n }\ndiff --git a/system/stack/hid/hidd_conn.cc b/system/stack/hid/hidd_conn.cc\nindex c64a7b9104..695e5d6c84 100644\n--- a/system/stack/hid/hidd_conn.cc\n+++ b/system/stack/hid/hidd_conn.cc\n@@ -88,10 +88,10 @@ static void hidd_check_config_done() {\n \n     // send outstanding data on intr\n     if (hd_cb.pending_data) {\n+      uint16_t len = hd_cb.pending_data->len;\n       if (stack::l2cap::get_interface().L2CA_DataWrite(p_hcon->intr_cid, hd_cb.pending_data) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n-        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid,\n-                  hd_cb.pending_data->len);\n+        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid, len);\n       }\n       hd_cb.pending_data = NULL;\n     }\ndiff --git a/system/stack/rfcomm/rfc_ts_frames.cc b/system/stack/rfcomm/rfc_ts_frames.cc\nindex ea57abf6dc..e93cfed9b8 100644\n--- a/system/stack/rfcomm/rfc_ts_frames.cc\n+++ b/system/stack/rfcomm/rfc_ts_frames.cc\n@@ -201,10 +201,11 @@ void rfc_send_buf_uih(tRFC_MCB* p_mcb, uint8_t dlci, BT_HDR* p_buf) {\n   if (dlci == RFCOMM_MX_DLCI) {\n     rfc_check_send_cmd(p_mcb, p_buf);\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p_buf->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/rfcomm/rfc_utils.cc b/system/stack/rfcomm/rfc_utils.cc\nindex 23420892cb..0c5074db76 100644\n--- a/system/stack/rfcomm/rfc_utils.cc\n+++ b/system/stack/rfcomm/rfc_utils.cc\n@@ -428,9 +428,10 @@ void rfc_check_send_cmd(tRFC_MCB* p_mcb, BT_HDR* p_buf) {\n     if (p == NULL) {\n       break;\n     }\n+    uint16_t len = p->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p) != tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/sdp/sdp_discovery.cc b/system/stack/sdp/sdp_discovery.cc\nindex 4fa484e14a..6aba1993af 100644\n--- a/system/stack/sdp/sdp_discovery.cc\n+++ b/system/stack/sdp/sdp_discovery.cc\n@@ -877,7 +877,7 @@ static void process_service_attr_rsp(tCONN_CB* p_ccb, uint8_t* p_reply, uint8_t*\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_msg) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-                p_ccb->connection_id, p_msg->len);\n+                p_ccb->connection_id, p - p_start);\n     }\n \n     /* Start inactivity timer */\ndiff --git a/system/stack/sdp/sdp_server.cc b/system/stack/sdp/sdp_server.cc\nindex abd70aedb1..0f379708e9 100644\n--- a/system/stack/sdp/sdp_server.cc\n+++ b/system/stack/sdp/sdp_server.cc\n@@ -300,7 +300,7 @@ static void process_service_search(tCONN_CB* p_ccb, uint16_t trans_num, uint16_t\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n@@ -564,7 +564,7 @@ static void process_service_attr_req(tCONN_CB* p_ccb, uint16_t trans_num, uint16\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "43cfd234de9ba9557118b0014513269cc1aeefda"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-372670004",
            "aliases": [
                "A-372670004",
                "CVE-2025-0100"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-372670004",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "829da8849df35c00c110ebebdd54c1692d96f840",
                        "3b422f0543874c8e1fc27af096e183a7dd4bb8dc"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 829da8849df35c00c110ebebdd54c1692d96f840 Mon Sep 17 00:00:00 2001\nFrom: Marvin Ramin <marvinramin@google.com>\nDate: Wed, 16 Oct 2024 12:26:02 +0200\nSubject: [PATCH] Use getLaunchedFromPackage instead of getCallingPackage\n\nEnsure that MediaProjectionPermissionActivity is doing proper\nattribution and validation of permissions before showing.\n\nBug: 373581993\nTest: presubmit\nFlag: com.android.systemui.media_projection_request_attribution_fix\nChange-Id: Ibcc14090ce38a0fac21a394d861d044b9669a8a0\n---\n packages/SystemUI/aconfig/systemui.aconfig             | 10 ++++++++++\n .../permission/MediaProjectionPermissionActivity.java  |  7 +++++--\n 2 files changed, 15 insertions(+), 2 deletions(-)\n\ndiff --git a/packages/SystemUI/aconfig/systemui.aconfig b/packages/SystemUI/aconfig/systemui.aconfig\nindex c79c0441cfbb..540115de8830 100644\n--- a/packages/SystemUI/aconfig/systemui.aconfig\n+++ b/packages/SystemUI/aconfig/systemui.aconfig\n@@ -1487,3 +1487,13 @@ flag {\n   description: \"Enables notes role qs tile which opens default notes role app in app bubbles\"\n   bug: \"357863750\"\n }\n+\n+flag {\n+   name: \"media_projection_request_attribution_fix\"\n+   namespace: \"systemui\"\n+   description: \"Ensure MediaProjection consent requests are properly attributed\"\n+   bug: \"373581993\"\n+   metadata {\n+       purpose: PURPOSE_BUGFIX\n+   }\n+}\ndiff --git a/packages/SystemUI/src/com/android/systemui/mediaprojection/permission/MediaProjectionPermissionActivity.java b/packages/SystemUI/src/com/android/systemui/mediaprojection/permission/MediaProjectionPermissionActivity.java\nindex c3729c0dcdfd..212da9ffb9c5 100644\n--- a/packages/SystemUI/src/com/android/systemui/mediaprojection/permission/MediaProjectionPermissionActivity.java\n+++ b/packages/SystemUI/src/com/android/systemui/mediaprojection/permission/MediaProjectionPermissionActivity.java\n@@ -122,8 +122,11 @@ public class MediaProjectionPermissionActivity extends Activity {\n         final Intent launchingIntent = getIntent();\n         mReviewGrantedConsentRequired = launchingIntent.getBooleanExtra(\n                 EXTRA_USER_REVIEW_GRANTED_CONSENT, false);\n-\n-        mPackageName = getCallingPackage();\n+        if (com.android.systemui.Flags.mediaProjectionRequestAttributionFix()) {\n+            mPackageName = getLaunchedFromPackage();\n+        } else {\n+            mPackageName = getCallingPackage();\n+        }\n \n         // This activity is launched directly by an app, or system server. System server provides\n         // the package name through the intent if so.\n-- \n2.39.5 (Apple Git-154)\n\nFrom 3b422f0543874c8e1fc27af096e183a7dd4bb8dc Mon Sep 17 00:00:00 2001\nFrom: Vadim Caen <caen@google.com>\nDate: Thu, 5 Dec 2024 17:20:02 +0100\nSubject: [PATCH] Remove the mediaProjectionRequestAttributionFix flag\n\n Ibcc14090ce38a0fac21a394d861d044b9669a8a0 was flag but is actually\na security fix, so we should not flag the change\n\nFlag: EXEMPT security fix\nBug: 372670004\nTest: N/A\nChange-Id: I1fe00d54ac8b8fcf802c0b0ac18ab2a802272325\n---\n .../MediaProjectionPermissionActivity.java    | 19 +++++++++----------\n 1 file changed, 9 insertions(+), 10 deletions(-)\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/mediaprojection/permission/MediaProjectionPermissionActivity.java b/packages/SystemUI/src/com/android/systemui/mediaprojection/permission/MediaProjectionPermissionActivity.java\nindex 2fda2013d6f5..d33ad8f80021 100644\n--- a/packages/SystemUI/src/com/android/systemui/mediaprojection/permission/MediaProjectionPermissionActivity.java\n+++ b/packages/SystemUI/src/com/android/systemui/mediaprojection/permission/MediaProjectionPermissionActivity.java\n@@ -122,21 +122,20 @@ public class MediaProjectionPermissionActivity extends Activity {\n         final Intent launchingIntent = getIntent();\n         mReviewGrantedConsentRequired = launchingIntent.getBooleanExtra(\n                 EXTRA_USER_REVIEW_GRANTED_CONSENT, false);\n-        if (com.android.systemui.Flags.mediaProjectionRequestAttributionFix()) {\n-            mPackageName = getLaunchedFromPackage();\n-        } else {\n-            mPackageName = getCallingPackage();\n-        }\n \n-        // This activity is launched directly by an app, or system server. System server provides\n-        // the package name through the intent if so.\n-        if (mPackageName == null || (\n-                com.android.systemui.Flags.mediaProjectionRequestAttributionFix()\n-                        && getCallingPackage() == null)) {\n+        // The original requester of this activity start\n+        mPackageName = getLaunchedFromPackage();\n+\n+        // This activity is launched directly by using startActivity(),\n+        // thus getCallingPackage() will be null.\n+        if (getCallingPackage() == null) {\n+            // System server provides the package name through the intent if so and is able to get\n+            // the result back. Other applications can't.\n             if (launchingIntent.hasExtra(EXTRA_PACKAGE_REUSING_GRANTED_CONSENT)) {\n                 mPackageName = launchingIntent.getStringExtra(\n                         EXTRA_PACKAGE_REUSING_GRANTED_CONSENT);\n             } else {\n+                // The activity was not launched for result, we abort here\n                 finishAsCancelled();\n                 return;\n             }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 0,
                    "failed_patches": 4,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "49e2bbad9d92315dc2a93df4bbc0beb9eb88c43b",
                            "result": "failure",
                            "downstream_patch_content": "commit 49e2bbad9d92315dc2a93df4bbc0beb9eb88c43b\nAuthor: Marvin Ramin <marvinramin@google.com>\nDate:   Wed Oct 16 12:26:02 2024 +0200\n\n    RESTRICT AUTOMERGE Use getLaunchedFromPackage instead of getCallingPackage\n    \n    Ensure that MediaProjectionPermissionActivity is doing proper\n    attribution and validation of permissions before showing.\n    \n    Bug: 372670004\n    Bug: 373581993\n    Test: presubmit\n    Change-Id: I48adb14fbc8d5f2f2e21ef8a30a713d33f03ab02\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java b/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java\nindex 66c51d278dab..b2884e37e674 100644\n--- a/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java\n+++ b/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java\n@@ -62,11 +62,11 @@ public class MediaProjectionPermissionActivity extends Activity\n     public void onCreate(Bundle icicle) {\n         super.onCreate(icicle);\n \n-        mPackageName = getCallingPackage();\n+        mPackageName = getLaunchedFromPackage();\n         IBinder b = ServiceManager.getService(MEDIA_PROJECTION_SERVICE);\n         mService = IMediaProjectionManager.Stub.asInterface(b);\n \n-        if (mPackageName == null) {\n+        if (getCallingPackage() == null) {\n             finish();\n             return;\n         }\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "4622b15f1db1b94b0dfe0a32d68d06c449af38ce",
                            "result": "failure",
                            "downstream_patch_content": "commit 4622b15f1db1b94b0dfe0a32d68d06c449af38ce\nAuthor: Marvin Ramin <marvinramin@google.com>\nDate:   Wed Oct 16 12:26:02 2024 +0200\n\n    RESTRICT AUTOMERGE Use getLaunchedFromPackage instead of getCallingPackage\n    \n    Ensure that MediaProjectionPermissionActivity is doing proper\n    attribution and validation of permissions before showing.\n    \n    Bug: 372670004\n    Bug: 373581993\n    Test: presubmit\n    Change-Id: I48adb14fbc8d5f2f2e21ef8a30a713d33f03ab02\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java b/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java\nindex e2716e992c48..493cada4bab8 100644\n--- a/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java\n+++ b/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java\n@@ -62,11 +62,11 @@ public class MediaProjectionPermissionActivity extends Activity\n     public void onCreate(Bundle icicle) {\n         super.onCreate(icicle);\n \n-        mPackageName = getCallingPackage();\n+        mPackageName = getLaunchedFromPackage();\n         IBinder b = ServiceManager.getService(MEDIA_PROJECTION_SERVICE);\n         mService = IMediaProjectionManager.Stub.asInterface(b);\n \n-        if (mPackageName == null) {\n+        if (getCallingPackage() == null) {\n             finish();\n             return;\n         }\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "a5eebf827a826c3379b97619b9ee6bfd891904f8"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "4ebc9c8d2b1c952c9d36c160e3dc6c4b094aadb5",
                            "result": "failure",
                            "downstream_patch_content": "commit 4ebc9c8d2b1c952c9d36c160e3dc6c4b094aadb5\nAuthor: Marvin Ramin <marvinramin@google.com>\nDate:   Wed Oct 16 12:26:02 2024 +0200\n\n    RESTRICT AUTOMERGE Use getLaunchedFromPackage instead of getCallingPackage\n    \n    Ensure that MediaProjectionPermissionActivity is doing proper\n    attribution and validation of permissions before showing.\n    \n    Bug: 372670004\n    Bug: 373581993\n    Test: presubmit\n    Change-Id: I48adb14fbc8d5f2f2e21ef8a30a713d33f03ab02\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java b/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java\nindex 38604091c409..b62dbf385ac2 100644\n--- a/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java\n+++ b/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java\n@@ -60,11 +60,11 @@ public class MediaProjectionPermissionActivity extends Activity\n     public void onCreate(Bundle icicle) {\n         super.onCreate(icicle);\n \n-        mPackageName = getCallingPackage();\n+        mPackageName = getLaunchedFromPackage();\n         IBinder b = ServiceManager.getService(MEDIA_PROJECTION_SERVICE);\n         mService = IMediaProjectionManager.Stub.asInterface(b);\n \n-        if (mPackageName == null) {\n+        if (getCallingPackage() == null) {\n             finish();\n             return;\n         }\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "85987ea1dfd92e4da11e26ee11db876e16a364d1",
                            "result": "failure",
                            "downstream_patch_content": "commit 85987ea1dfd92e4da11e26ee11db876e16a364d1\nAuthor: Marvin Ramin <marvinramin@google.com>\nDate:   Wed Oct 16 12:26:02 2024 +0200\n\n    RESTRICT AUTOMERGE Use getLaunchedFromPackage instead of getCallingPackage\n    \n    Ensure that MediaProjectionPermissionActivity is doing proper\n    attribution and validation of permissions before showing.\n    \n    Bug: 372670004\n    Bug: 373581993\n    Test: presubmit\n    Change-Id: I48adb14fbc8d5f2f2e21ef8a30a713d33f03ab02\n    Merged-In: I48adb14fbc8d5f2f2e21ef8a30a713d33f03ab02\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java b/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java\nindex f6a2f3704283..eb7698c42329 100644\n--- a/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java\n+++ b/packages/SystemUI/src/com/android/systemui/media/MediaProjectionPermissionActivity.java\n@@ -98,12 +98,11 @@ public class MediaProjectionPermissionActivity extends Activity\n         final Intent launchingIntent = getIntent();\n         mReviewGrantedConsentRequired = launchingIntent.getBooleanExtra(\n                 EXTRA_USER_REVIEW_GRANTED_CONSENT, false);\n-\n-        mPackageName = getCallingPackage();\n+        mPackageName = getLaunchedFromPackage();\n \n         // This activity is launched directly by an app, or system server. System server provides\n         // the package name through the intent if so.\n-        if (mPackageName == null) {\n+        if (getCallingPackage() == null)  {\n             if (launchingIntent.hasExtra(EXTRA_PACKAGE_REUSING_GRANTED_CONSENT)) {\n                 mPackageName = launchingIntent.getStringExtra(\n                         EXTRA_PACKAGE_REUSING_GRANTED_CONSENT);\n",
                            "file_conflicts": []
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-354682735",
            "aliases": [
                "A-354682735",
                "CVE-2024-49721"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-354682735",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "bc2fbfc0b73535ce9d0c9f73b5130cfffaf4daee"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From bc2fbfc0b73535ce9d0c9f73b5130cfffaf4daee Mon Sep 17 00:00:00 2001\nFrom: Adrian Roos <roosa@google.com>\nDate: Fri, 2 Jun 2023 13:57:57 +0000\nSubject: [PATCH] InputMethodSubtypeArray: prevent negative count injection\n\nFixes an issue where negative counts could be injected\nvia the Parcel constructor. The writeToParcel method\nin that case would write data that a subsequent read would\nnot consume.\n\nFixes: 277916797\nTest: atest InputMethodSubtypeArrayTest\nChange-Id: I7e881d82415051179c59bf5df97f8ba0a41e693e\n---\n .../inputmethod/InputMethodSubtypeArray.java  |  4 +++\n .../InputMethodSubtypeArrayTest.java          | 36 +++++++++++++++++++\n 2 files changed, 40 insertions(+)\n\ndiff --git a/core/java/android/view/inputmethod/InputMethodSubtypeArray.java b/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\nindex 50e95c80cfed..ee36dc72e346 100644\n--- a/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\n+++ b/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\n@@ -17,6 +17,7 @@\n package android.view.inputmethod;\n \n import android.compat.annotation.UnsupportedAppUsage;\n+import android.os.BadParcelableException;\n import android.os.Parcel;\n import android.util.Slog;\n \n@@ -69,6 +70,9 @@ public class InputMethodSubtypeArray {\n      */\n     public InputMethodSubtypeArray(final Parcel source) {\n         mCount = source.readInt();\n+        if (mCount < 0) {\n+            throw new BadParcelableException(\"mCount must be non-negative.\");\n+        }\n         if (mCount > 0) {\n             mDecompressedSize = source.readInt();\n             mCompressedData = source.createByteArray();\ndiff --git a/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java b/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\nindex e2fb46af5b64..e7b1110f898a 100644\n--- a/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\n+++ b/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\n@@ -16,9 +16,14 @@\n \n package android.view.inputmethod;\n \n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n+\n import static org.junit.Assert.assertEquals;\n \n+import android.os.BadParcelableException;\n import android.os.Parcel;\n+import android.platform.test.annotations.Presubmit;\n import android.view.inputmethod.InputMethodSubtype.InputMethodSubtypeBuilder;\n \n import androidx.test.filters.SmallTest;\n@@ -31,6 +36,7 @@ import java.util.ArrayList;\n \n @SmallTest\n @RunWith(AndroidJUnit4.class)\n+@Presubmit\n public class InputMethodSubtypeArrayTest {\n \n     @Test\n@@ -59,6 +65,36 @@ public class InputMethodSubtypeArrayTest {\n         assertEquals(clonedArray.get(2), clonedClonedArray.get(2));\n     }\n \n+    @Test\n+    public void testNegativeCount() throws Exception {\n+        InputMethodSubtypeArray negativeCountArray;\n+        try {\n+            // Construct a InputMethodSubtypeArray with: mCount = -1\n+            var p = Parcel.obtain();\n+            p.writeInt(-1);\n+            p.setDataPosition(0);\n+            negativeCountArray = new InputMethodSubtypeArray(p);\n+        } catch (BadParcelableException e) {\n+            // Expected with fix: Prevent negative mCount\n+            assertThat(e).hasMessageThat().contains(\"mCount\");\n+            return;\n+        }\n+        assertWithMessage(\"Test set-up failed\")\n+                .that(negativeCountArray.getCount()).isEqualTo(-1);\n+\n+        var p = Parcel.obtain();\n+        // Writes: int (mCount), int (mDecompressedSize), byte[] (mCompressedData)\n+        negativeCountArray.writeToParcel(p);\n+        p.setDataPosition(0);\n+        // Reads: int (mCount)\n+        // Leaves: int (mDecompressedSize), byte[] (mCompressedData)\n+        new InputMethodSubtypeArray(p);\n+\n+        assertWithMessage(\"Didn't read all data that was previously written\")\n+                .that(p.dataPosition())\n+                .isEqualTo(p.dataSize());\n+    }\n+\n     InputMethodSubtypeArray cloneViaParcel(final InputMethodSubtypeArray original) {\n         Parcel parcel = null;\n         try {\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 3,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "1e973616542153aaed999c4f1c292ce493f40049",
                            "result": "success",
                            "downstream_patch_content": "commit 1e973616542153aaed999c4f1c292ce493f40049\nAuthor: Adrian Roos <roosa@google.com>\nDate:   Fri Jun 2 13:57:57 2023 +0000\n\n    InputMethodSubtypeArray: prevent negative count injection\n    \n    Fixes an issue where negative counts could be injected\n    via the Parcel constructor. The writeToParcel method\n    in that case would write data that a subsequent read would\n    not consume.\n    \n    Fixes: 277916797\n    Fixes: 354682735\n    Test: atest InputMethodSubtypeArrayTest\n    Merged-In: I7e881d82415051179c59bf5df97f8ba0a41e693e\n    Change-Id: I7e881d82415051179c59bf5df97f8ba0a41e693e\n\ndiff --git a/core/java/android/view/inputmethod/InputMethodSubtypeArray.java b/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\nindex 50e95c80cfed..ee36dc72e346 100644\n--- a/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\n+++ b/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\n@@ -17,6 +17,7 @@\n package android.view.inputmethod;\n \n import android.compat.annotation.UnsupportedAppUsage;\n+import android.os.BadParcelableException;\n import android.os.Parcel;\n import android.util.Slog;\n \n@@ -69,6 +70,9 @@ public class InputMethodSubtypeArray {\n      */\n     public InputMethodSubtypeArray(final Parcel source) {\n         mCount = source.readInt();\n+        if (mCount < 0) {\n+            throw new BadParcelableException(\"mCount must be non-negative.\");\n+        }\n         if (mCount > 0) {\n             mDecompressedSize = source.readInt();\n             mCompressedData = source.createByteArray();\ndiff --git a/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java b/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\nindex e2fb46af5b64..5af8558ccde9 100644\n--- a/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\n+++ b/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\n@@ -16,9 +16,14 @@\n \n package android.view.inputmethod;\n \n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n+\n import static org.junit.Assert.assertEquals;\n \n+import android.os.BadParcelableException;\n import android.os.Parcel;\n+import android.platform.test.annotations.Presubmit;\n import android.view.inputmethod.InputMethodSubtype.InputMethodSubtypeBuilder;\n \n import androidx.test.filters.SmallTest;\n@@ -31,6 +36,7 @@ import java.util.ArrayList;\n \n @SmallTest\n @RunWith(AndroidJUnit4.class)\n+@Presubmit\n public class InputMethodSubtypeArrayTest {\n \n     @Test\n@@ -59,6 +65,36 @@ public class InputMethodSubtypeArrayTest {\n         assertEquals(clonedArray.get(2), clonedClonedArray.get(2));\n     }\n \n+    @Test\n+    public void testNegativeCount() throws Exception {\n+        InputMethodSubtypeArray negativeCountArray;\n+        try {\n+            // Construct a InputMethodSubtypeArray with: mCount = -1\n+            Parcel p = Parcel.obtain();\n+            p.writeInt(-1);\n+            p.setDataPosition(0);\n+            negativeCountArray = new InputMethodSubtypeArray(p);\n+        } catch (BadParcelableException e) {\n+            // Expected with fix: Prevent negative mCount\n+            assertThat(e).hasMessageThat().contains(\"mCount\");\n+            return;\n+        }\n+        assertWithMessage(\"Test set-up failed\")\n+                .that(negativeCountArray.getCount()).isEqualTo(-1);\n+\n+        Parcel p = Parcel.obtain();\n+        // Writes: int (mCount), int (mDecompressedSize), byte[] (mCompressedData)\n+        negativeCountArray.writeToParcel(p);\n+        p.setDataPosition(0);\n+        // Reads: int (mCount)\n+        // Leaves: int (mDecompressedSize), byte[] (mCompressedData)\n+        new InputMethodSubtypeArray(p);\n+\n+        assertWithMessage(\"Didn't read all data that was previously written\")\n+                .that(p.dataPosition())\n+                .isEqualTo(p.dataSize());\n+    }\n+\n     InputMethodSubtypeArray cloneViaParcel(final InputMethodSubtypeArray original) {\n         Parcel parcel = null;\n         try {\n"
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "b7acc399ad02f3c2faa6cdb61a86a3c642418208",
                            "result": "success",
                            "downstream_patch_content": "commit b7acc399ad02f3c2faa6cdb61a86a3c642418208\nAuthor: Adrian Roos <roosa@google.com>\nDate:   Fri Jun 2 13:57:57 2023 +0000\n\n    InputMethodSubtypeArray: prevent negative count injection\n    \n    Fixes an issue where negative counts could be injected\n    via the Parcel constructor. The writeToParcel method\n    in that case would write data that a subsequent read would\n    not consume.\n    \n    Fixes: 277916797\n    Fixes: 354682735\n    Test: atest InputMethodSubtypeArrayTest\n    Merged-In: I7e881d82415051179c59bf5df97f8ba0a41e693e\n    Change-Id: I7e881d82415051179c59bf5df97f8ba0a41e693e\n\ndiff --git a/core/java/android/view/inputmethod/InputMethodSubtypeArray.java b/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\nindex 50e95c80cfed..ee36dc72e346 100644\n--- a/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\n+++ b/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\n@@ -17,6 +17,7 @@\n package android.view.inputmethod;\n \n import android.compat.annotation.UnsupportedAppUsage;\n+import android.os.BadParcelableException;\n import android.os.Parcel;\n import android.util.Slog;\n \n@@ -69,6 +70,9 @@ public class InputMethodSubtypeArray {\n      */\n     public InputMethodSubtypeArray(final Parcel source) {\n         mCount = source.readInt();\n+        if (mCount < 0) {\n+            throw new BadParcelableException(\"mCount must be non-negative.\");\n+        }\n         if (mCount > 0) {\n             mDecompressedSize = source.readInt();\n             mCompressedData = source.createByteArray();\ndiff --git a/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java b/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\nindex e2fb46af5b64..5af8558ccde9 100644\n--- a/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\n+++ b/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\n@@ -16,9 +16,14 @@\n \n package android.view.inputmethod;\n \n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n+\n import static org.junit.Assert.assertEquals;\n \n+import android.os.BadParcelableException;\n import android.os.Parcel;\n+import android.platform.test.annotations.Presubmit;\n import android.view.inputmethod.InputMethodSubtype.InputMethodSubtypeBuilder;\n \n import androidx.test.filters.SmallTest;\n@@ -31,6 +36,7 @@ import java.util.ArrayList;\n \n @SmallTest\n @RunWith(AndroidJUnit4.class)\n+@Presubmit\n public class InputMethodSubtypeArrayTest {\n \n     @Test\n@@ -59,6 +65,36 @@ public class InputMethodSubtypeArrayTest {\n         assertEquals(clonedArray.get(2), clonedClonedArray.get(2));\n     }\n \n+    @Test\n+    public void testNegativeCount() throws Exception {\n+        InputMethodSubtypeArray negativeCountArray;\n+        try {\n+            // Construct a InputMethodSubtypeArray with: mCount = -1\n+            Parcel p = Parcel.obtain();\n+            p.writeInt(-1);\n+            p.setDataPosition(0);\n+            negativeCountArray = new InputMethodSubtypeArray(p);\n+        } catch (BadParcelableException e) {\n+            // Expected with fix: Prevent negative mCount\n+            assertThat(e).hasMessageThat().contains(\"mCount\");\n+            return;\n+        }\n+        assertWithMessage(\"Test set-up failed\")\n+                .that(negativeCountArray.getCount()).isEqualTo(-1);\n+\n+        Parcel p = Parcel.obtain();\n+        // Writes: int (mCount), int (mDecompressedSize), byte[] (mCompressedData)\n+        negativeCountArray.writeToParcel(p);\n+        p.setDataPosition(0);\n+        // Reads: int (mCount)\n+        // Leaves: int (mDecompressedSize), byte[] (mCompressedData)\n+        new InputMethodSubtypeArray(p);\n+\n+        assertWithMessage(\"Didn't read all data that was previously written\")\n+                .that(p.dataPosition())\n+                .isEqualTo(p.dataSize());\n+    }\n+\n     InputMethodSubtypeArray cloneViaParcel(final InputMethodSubtypeArray original) {\n         Parcel parcel = null;\n         try {\n"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "e863b7b8285f122fafbab5439ad3c337172bff6c",
                            "result": "success",
                            "downstream_patch_content": "commit e863b7b8285f122fafbab5439ad3c337172bff6c\nAuthor: Adrian Roos <roosa@google.com>\nDate:   Fri Jun 2 13:57:57 2023 +0000\n\n    InputMethodSubtypeArray: prevent negative count injection\n    \n    Fixes an issue where negative counts could be injected\n    via the Parcel constructor. The writeToParcel method\n    in that case would write data that a subsequent read would\n    not consume.\n    \n    Fixes: 277916797\n    Fixes: 354682735\n    Test: atest InputMethodSubtypeArrayTest\n    Merged-In: I7e881d82415051179c59bf5df97f8ba0a41e693e\n    Change-Id: I7e881d82415051179c59bf5df97f8ba0a41e693e\n\ndiff --git a/core/java/android/view/inputmethod/InputMethodSubtypeArray.java b/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\nindex 50e95c80cfed..ee36dc72e346 100644\n--- a/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\n+++ b/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\n@@ -17,6 +17,7 @@\n package android.view.inputmethod;\n \n import android.compat.annotation.UnsupportedAppUsage;\n+import android.os.BadParcelableException;\n import android.os.Parcel;\n import android.util.Slog;\n \n@@ -69,6 +70,9 @@ public class InputMethodSubtypeArray {\n      */\n     public InputMethodSubtypeArray(final Parcel source) {\n         mCount = source.readInt();\n+        if (mCount < 0) {\n+            throw new BadParcelableException(\"mCount must be non-negative.\");\n+        }\n         if (mCount > 0) {\n             mDecompressedSize = source.readInt();\n             mCompressedData = source.createByteArray();\ndiff --git a/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java b/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\nindex e2fb46af5b64..5af8558ccde9 100644\n--- a/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\n+++ b/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\n@@ -16,9 +16,14 @@\n \n package android.view.inputmethod;\n \n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n+\n import static org.junit.Assert.assertEquals;\n \n+import android.os.BadParcelableException;\n import android.os.Parcel;\n+import android.platform.test.annotations.Presubmit;\n import android.view.inputmethod.InputMethodSubtype.InputMethodSubtypeBuilder;\n \n import androidx.test.filters.SmallTest;\n@@ -31,6 +36,7 @@ import java.util.ArrayList;\n \n @SmallTest\n @RunWith(AndroidJUnit4.class)\n+@Presubmit\n public class InputMethodSubtypeArrayTest {\n \n     @Test\n@@ -59,6 +65,36 @@ public class InputMethodSubtypeArrayTest {\n         assertEquals(clonedArray.get(2), clonedClonedArray.get(2));\n     }\n \n+    @Test\n+    public void testNegativeCount() throws Exception {\n+        InputMethodSubtypeArray negativeCountArray;\n+        try {\n+            // Construct a InputMethodSubtypeArray with: mCount = -1\n+            Parcel p = Parcel.obtain();\n+            p.writeInt(-1);\n+            p.setDataPosition(0);\n+            negativeCountArray = new InputMethodSubtypeArray(p);\n+        } catch (BadParcelableException e) {\n+            // Expected with fix: Prevent negative mCount\n+            assertThat(e).hasMessageThat().contains(\"mCount\");\n+            return;\n+        }\n+        assertWithMessage(\"Test set-up failed\")\n+                .that(negativeCountArray.getCount()).isEqualTo(-1);\n+\n+        Parcel p = Parcel.obtain();\n+        // Writes: int (mCount), int (mDecompressedSize), byte[] (mCompressedData)\n+        negativeCountArray.writeToParcel(p);\n+        p.setDataPosition(0);\n+        // Reads: int (mCount)\n+        // Leaves: int (mDecompressedSize), byte[] (mCompressedData)\n+        new InputMethodSubtypeArray(p);\n+\n+        assertWithMessage(\"Didn't read all data that was previously written\")\n+                .that(p.dataPosition())\n+                .isEqualTo(p.dataSize());\n+    }\n+\n     InputMethodSubtypeArray cloneViaParcel(final InputMethodSubtypeArray original) {\n         Parcel parcel = null;\n         try {\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-352542820",
            "aliases": [
                "A-352542820",
                "CVE-2025-0094"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-352542820",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "69c7f5dac580361792bbb189178653b297d06c8a"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 69c7f5dac580361792bbb189178653b297d06c8a Mon Sep 17 00:00:00 2001\nFrom: Adam Bookatz <bookatz@google.com>\nDate: Mon, 18 Nov 2024 15:53:41 -0800\nSubject: [PATCH] Don't let profiles open the UserSettings overflow\n\nReally, profiles aren't expected to open Settings at all. But if they\ndo somehow, the overflow shouldn't appear.\n\nBug: 352542820\nFlag: EXEMPT bugfix\nTest: Try to access the overflow of the work profile by launching its Settings in\nadb shell am start --user 10 'com.android.settings/.Settings\\$UserSettingsActivity'\n\nChange-Id: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n---\n src/com/android/settings/users/UserSettings.java | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex 0881b29a3b3..589f512ac23 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -465,7 +465,7 @@ public class UserSettings extends SettingsPreferenceFragment\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n-                && !isCurrentUserGuest()) {\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 0,
                    "failed_patches": 4,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "44a35ac07bcc076871b8054331096aaff8ee10f0",
                            "result": "failure",
                            "downstream_patch_content": "commit 44a35ac07bcc076871b8054331096aaff8ee10f0\nAuthor: Adam Bookatz <bookatz@google.com>\nDate:   Mon Nov 18 15:53:41 2024 -0800\n\n    Don't let profiles open the UserSettings overflow [DO NOT MERGE]\n    \n    Really, profiles aren't expected to open Settings at all. But if they\n    do somehow, the overflow shouldn't appear.\n    \n    Bug: 352542820\n    Flag: EXEMPT bugfix\n    Test: Try to access the overflow of the work profile by launching its Settings in\n    adb shell am start --user 10 'com.android.settings/.Settings\\$UserSettingsActivity'\n    \n    Change-Id: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    Merged-In: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    (cherry picked from commit 69c7f5dac580361792bbb189178653b297d06c8a)\n\ndiff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex ee23fc379d8..56bdfba3069 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -358,8 +358,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n",
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/users/UserSettings.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n\n=======\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n>>>>>>> UPSTREAM PATCH (commit 69c7f5dac580361792bbb189178653b297d06c8a)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- src/com/android/settings/users/UserSettings.java\n+++ src/com/android/settings/users/UserSettings.java\n@@ -465,7 +465,7 @@ public class UserSettings extends SettingsPreferenceFragment\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n-                && !isCurrentUserGuest()) {\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```",
                                    "patch_apply_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 FAILED at 465.\n1 out of 1 hunk FAILED -- saving rejects to file src/com/android/settings/users/UserSettings.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 NOT MERGED at 363-369."
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "4901c86b765f5e72075fb5e26374c097920a56f5",
                            "result": "failure",
                            "downstream_patch_content": "commit 4901c86b765f5e72075fb5e26374c097920a56f5\nAuthor: Adam Bookatz <bookatz@google.com>\nDate:   Mon Nov 18 15:53:41 2024 -0800\n\n    Don't let profiles open the UserSettings overflow [DO NOT MERGE]\n    \n    Really, profiles aren't expected to open Settings at all. But if they\n    do somehow, the overflow shouldn't appear.\n    \n    Bug: 352542820\n    Flag: EXEMPT bugfix\n    Test: Try to access the overflow of the work profile by launching its Settings in\n    adb shell am start --user 10 'com.android.settings/.Settings\\$UserSettingsActivity'\n    \n    Change-Id: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    Merged-In: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    (cherry picked from commit 69c7f5dac580361792bbb189178653b297d06c8a)\n\ndiff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex ee23fc379d8..56bdfba3069 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -358,8 +358,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n",
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/users/UserSettings.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n\n=======\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n>>>>>>> UPSTREAM PATCH (commit 69c7f5dac580361792bbb189178653b297d06c8a)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- src/com/android/settings/users/UserSettings.java\n+++ src/com/android/settings/users/UserSettings.java\n@@ -465,7 +465,7 @@ public class UserSettings extends SettingsPreferenceFragment\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n-                && !isCurrentUserGuest()) {\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```",
                                    "patch_apply_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 FAILED at 465.\n1 out of 1 hunk FAILED -- saving rejects to file src/com/android/settings/users/UserSettings.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 NOT MERGED at 363-369."
                                }
                            ]
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "e0b732cbeecb51a26377052501d2b10a8f5ee862"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "31e69deb2809887b5ea7b8b7a7893d7db90acdd2",
                            "result": "failure",
                            "downstream_patch_content": "commit 31e69deb2809887b5ea7b8b7a7893d7db90acdd2\nAuthor: Adam Bookatz <bookatz@google.com>\nDate:   Mon Nov 18 15:53:41 2024 -0800\n\n    Don't let profiles open the UserSettings overflow [DO NOT MERGE]\n    \n    Really, profiles aren't expected to open Settings at all. But if they\n    do somehow, the overflow shouldn't appear.\n    \n    Bug: 352542820\n    Flag: EXEMPT bugfix\n    Test: Try to access the overflow of the work profile by launching its Settings in\n    adb shell am start --user 10 'com.android.settings/.Settings\\$UserSettingsActivity'\n    \n    Change-Id: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    Merged-In: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    (cherry picked from commit 69c7f5dac580361792bbb189178653b297d06c8a)\n\ndiff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex 5ee95ddc45a..a1806fe4770 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -380,8 +380,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n",
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/users/UserSettings.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n>>>>>>> UPSTREAM PATCH (commit 69c7f5dac580361792bbb189178653b297d06c8a)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- src/com/android/settings/users/UserSettings.java\n+++ src/com/android/settings/users/UserSettings.java\n@@ -465,7 +465,7 @@ public class UserSettings extends SettingsPreferenceFragment\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n-                && !isCurrentUserGuest()) {\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```",
                                    "patch_apply_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 FAILED at 465.\n1 out of 1 hunk FAILED -- saving rejects to file src/com/android/settings/users/UserSettings.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 NOT MERGED at 385-391."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "6e413c4cff2f306d18e9682b1e0be5ddc8427c5f",
                            "result": "failure",
                            "downstream_patch_content": "commit 6e413c4cff2f306d18e9682b1e0be5ddc8427c5f\nAuthor: Adam Bookatz <bookatz@google.com>\nDate:   Mon Nov 18 15:53:41 2024 -0800\n\n    Don't let profiles open the UserSettings overflow [DO NOT MERGE]\n    \n    Really, profiles aren't expected to open Settings at all. But if they\n    do somehow, the overflow shouldn't appear.\n    \n    Bug: 352542820\n    Flag: EXEMPT bugfix\n    Test: Try to access the overflow of the work profile by launching its Settings in\n    adb shell am start --user 10 'com.android.settings/.Settings\\$UserSettingsActivity'\n    \n    Change-Id: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    Merged-In: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    (cherry picked from commit 69c7f5dac580361792bbb189178653b297d06c8a)\n\ndiff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex 28e02ec16e2..b430068a7ef 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -464,7 +464,8 @@ public class UserSettings extends SettingsPreferenceFragment\n     @Override\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n-        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n+        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()\n+                && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n",
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/users/UserSettings.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n=======\n        if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n>>>>>>> UPSTREAM PATCH (commit 69c7f5dac580361792bbb189178653b297d06c8a)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- src/com/android/settings/users/UserSettings.java\n+++ src/com/android/settings/users/UserSettings.java\n@@ -465,7 +465,7 @@ public class UserSettings extends SettingsPreferenceFragment\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n-                && !isCurrentUserGuest()) {\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```",
                                    "patch_apply_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 FAILED at 465.\n1 out of 1 hunk FAILED -- saving rejects to file src/com/android/settings/users/UserSettings.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 NOT MERGED at 467-472."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-296915500",
            "aliases": [
                "A-296915500",
                "CVE-2024-49728"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-296915500",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "b5d66a17fa296117b44f23ae45ff7338cee6ae85"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From b5d66a17fa296117b44f23ae45ff7338cee6ae85 Mon Sep 17 00:00:00 2001\nFrom: Billy Huang <billyhuang@google.com>\nDate: Thu, 8 Aug 2024 14:57:07 -0700\nSubject: [PATCH] Reapply \"opp: validate that content uri belongs to current\n user\"\n\nCheck that the userInfo part of the content URI is\neither implicit or the same as the current userId.\n\nThis reverts commit db25b12501095bc3f371a7271e372834cde5cee5.\n\nBug: 296915500\nFlag: EXEMPT fix for vulnerability\nTest: atest GoogleBluetoothInstrumentationTests:BluetoothOppSendFileInfoTest\nIgnore-AOSP-First: fix for undisclosed vulnerability\nChange-Id: I76b25fcd446d5e0530308e21deafa68d0b768edc\n---\n .../opp/BluetoothOppSendFileInfo.java         |  22 +++-\n .../opp/BluetoothOppSendFileInfoTest.java     | 106 ++++++++++++++++++\n 2 files changed, 127 insertions(+), 1 deletion(-)\n\ndiff --git a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nindex 16056cde79..2d727f9fdf 100644\n--- a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.bluetooth.BluetoothProfile;\n import android.bluetooth.BluetoothProtoEnums;\n import android.content.ContentResolver;\n@@ -41,6 +43,7 @@ import android.database.Cursor;\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n+import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -53,12 +56,13 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be used for outbound\n  * share.\n  */\n-// Next tag value for ContentProfileErrorReportUtils.report(): 15\n+// Next tag value for ContentProfileErrorReportUtils.report(): 16\n public class BluetoothOppSendFileInfo {\n     private static final String TAG = \"BluetoothOppSendFileInfo\";\n \n@@ -124,6 +128,16 @@ public class BluetoothOppSendFileInfo {\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n+            if (isContentUriForOtherUser(uri)) {\n+                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n+                ContentProfileErrorReportUtils.report(\n+                        BluetoothProfile.OPP,\n+                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n+                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n+                        15);\n+                return SEND_FILE_INFO_ERROR;\n+            }\n+\n             contentType = contentResolver.getType(uri);\n             Cursor metadataCursor;\n             try {\n@@ -353,6 +367,12 @@ public class BluetoothOppSendFileInfo {\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n+    private static boolean isContentUriForOtherUser(Uri uri) {\n+        String uriUserId = uri.getUserInfo();\n+        return !TextUtils.isEmpty(uriUserId)\n+                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n+    }\n+\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];\ndiff --git a/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\nindex 273f6fd8d5..aad8a31170 100644\n--- a/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\n+++ b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\n@@ -16,6 +16,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import static com.google.common.truth.Truth.assertThat;\n \n import static org.mockito.ArgumentMatchers.any;\n@@ -119,6 +121,110 @@ public class BluetoothOppSendFileInfoTest {\n         assertThat(info).isEqualTo(BluetoothOppSendFileInfo.SEND_FILE_INFO_ERROR);\n     }\n \n+    @Test\n+    public void generateFileInfo_withContentUriForOtherUser_returnsSendFileInfoError()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority((myUserId() + 1) + \"@media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info).isEqualTo(BluetoothOppSendFileInfo.SEND_FILE_INFO_ERROR);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForImplicitUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(\"media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForSameUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(myUserId() + \"@media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    private static Uri buildContentUriWithEncodedAuthority(String authority) {\n+        return new Uri.Builder()\n+                .scheme(\"content\")\n+                .encodedAuthority(authority)\n+                .path(\"external/images/media/1\")\n+                .build();\n+    }\n+\n     @Test\n     public void generateFileInfo_withoutPermissionForAccessingUri_returnsSendFileInfoError() {\n         String type = \"text/plain\";\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "e17b3fcb3946abf2f307fc8393ecc347c3df67d9"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "5bcfd347823f1d3893d843db2286f2013923fad8",
                            "result": "failure",
                            "downstream_patch_content": "commit 5bcfd347823f1d3893d843db2286f2013923fad8\nAuthor: Billy Huang <billyhuang@google.com>\nDate:   Wed Oct 2 14:45:37 2024 -0700\n\n    RESTRICT AUTOMERGE backport \"opp: validate that content uri belongs to current user\"\n    \n    Bug: 296915500\n    Flag: EXEMPT trivial fix with complete testing coverage\n    Test: atest GoogleBluetoothInstrumentationTests:BluetoothOppSendFileInfoTest\n    Ignore-AOSP-First: fix for undisclosed vulnerability\n    Merged-In: I76b25fcd446d5e0530308e21deafa68d0b768edc\n    Change-Id: Ibff36089bfde4b5bb28d797aeae1423b668943a2\n\ndiff --git a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nindex 46e3ba144e..10087c9f16 100644\n--- a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.res.AssetFileDescriptor;\n@@ -39,6 +41,7 @@ import android.database.Cursor;\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n+import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -48,6 +51,7 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be\n@@ -116,6 +120,11 @@ public class BluetoothOppSendFileInfo {\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n+            if (isContentUriForOtherUser(uri)) {\n+                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n+                return SEND_FILE_INFO_ERROR;\n+            }\n+\n             contentType = contentResolver.getType(uri);\n             Cursor metadataCursor;\n             try {\n@@ -247,6 +256,12 @@ public class BluetoothOppSendFileInfo {\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n+    private static boolean isContentUriForOtherUser(Uri uri) {\n+        String uriUserId = uri.getUserInfo();\n+        return !TextUtils.isEmpty(uriUserId)\n+                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n+    }\n+\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];\ndiff --git a/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\nnew file mode 100644\nindex 0000000000..9fb93ac968\n--- /dev/null\n+++ b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\n@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2024 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.android.bluetooth.opp;\n+\n+import static android.os.UserHandle.myUserId;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+\n+import android.content.ContentResolver;\n+import android.content.Context;\n+import android.content.IContentProvider;\n+import android.content.pm.ApplicationInfo;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.MatrixCursor;\n+import android.net.Uri;\n+import android.os.Build;\n+import android.provider.OpenableColumns;\n+import android.test.mock.MockContentProvider;\n+import android.test.mock.MockContext;\n+\n+import androidx.test.runner.AndroidJUnit4;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.io.FileInputStream;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class BluetoothOppSendFileInfoTest {\n+    public static final String PROVIDER_NAME_MEDIA = \"media\";\n+    TestContext mContext;\n+    TestContentResolver mContentResolver;\n+    MockContentProvider mContentProvider;\n+    MatrixCursor mCursor;\n+\n+    private static Uri buildContentUriWithEncodedAuthority(String authority) {\n+        return new Uri.Builder().scheme(\"content\")\n+                .encodedAuthority(authority)\n+                .path(\"external/images/media/1\")\n+                .build();\n+    }\n+\n+    @Before\n+    public void setUp() {\n+        mContext = new TestContext();\n+        mContentResolver = mContext.getContentResolver();\n+        mContentProvider = mContext.getContentProvider();\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForOtherUser_returnsSendFileInfoError()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority((myUserId() + 1) + \"@\" + PROVIDER_NAME_MEDIA);\n+        doReturn(type).when(mContentProvider).getType(any());\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+        doReturn(fd).when(mContentProvider).openAssetFile(eq(uri), any(), any());\n+        mCursor =\n+                new MatrixCursor(new String[]{OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[]{fileName, fileLength});\n+        doReturn(mCursor).when(mContentProvider).query(eq(uri), any(), any(), any(), any());\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+        assertThat(info).isEqualTo(BluetoothOppSendFileInfo.SEND_FILE_INFO_ERROR);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForImplicitUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(PROVIDER_NAME_MEDIA);\n+        doReturn(type).when(mContentProvider).getType(any());\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+        doReturn(fd).when(mContentProvider).openAssetFile(eq(uri), any(), any());\n+        mCursor =\n+                new MatrixCursor(new String[]{OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[]{fileName, fileLength});\n+        doReturn(mCursor).when(mContentProvider).query(eq(uri), any(), any(), any(), any());\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForSameUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(myUserId() + \"@\" + PROVIDER_NAME_MEDIA);\n+        doReturn(type).when(mContentProvider).getType(any());\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+        doReturn(fd).when(mContentProvider).openAssetFile(eq(uri), any(), any());\n+        mCursor =\n+                new MatrixCursor(new String[]{OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[]{fileName, fileLength});\n+        doReturn(mCursor).when(mContentProvider).query(eq(uri), any(), any(), any(), any());\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    public static final class TestContext extends MockContext {\n+        private final TestContentResolver mContentResolver;\n+        private final MockContentProvider mContentProvider;\n+\n+        public TestContext() {\n+            mContentProvider = spy(new MockContentProvider(this));\n+            mContentResolver = new TestContentResolver(this, mContentProvider);\n+        }\n+\n+        @Override\n+        public TestContentResolver getContentResolver() {\n+            return mContentResolver;\n+        }\n+\n+        public MockContentProvider getContentProvider() {\n+            return mContentProvider;\n+        }\n+\n+        @Override\n+        public String getOpPackageName() {\n+            return \"test.package\";\n+        }\n+\n+        @Override\n+        public ApplicationInfo getApplicationInfo() {\n+            ApplicationInfo applicationInfo = new ApplicationInfo();\n+            applicationInfo.targetSdkVersion = Build.VERSION.SDK_INT;\n+            return applicationInfo;\n+        }\n+    }\n+\n+    public static final class TestContentResolver extends ContentResolver {\n+        private final MockContentProvider mContentProvider;\n+\n+        public TestContentResolver(Context context, MockContentProvider contentProvider) {\n+            super(context, contentProvider);\n+            mContentProvider = contentProvider;\n+        }\n+\n+        @Override\n+        protected IContentProvider acquireProvider(Context c, String name) {\n+            return mContentProvider.getIContentProvider();\n+        }\n+\n+        @Override\n+        public boolean releaseProvider(IContentProvider icp) {\n+            return true;\n+        }\n+\n+        @Override\n+        protected IContentProvider acquireUnstableProvider(Context c, String name) {\n+            return mContentProvider.getIContentProvider();\n+        }\n+\n+        @Override\n+        public boolean releaseUnstableProvider(IContentProvider icp) {\n+            return true;\n+        }\n+\n+        @Override\n+        public void unstableProviderDied(IContentProvider icp) {\n+        }\n+    }\n+}\n",
                            "file_conflicts": [
                                {
                                    "file_name": "android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java",
                                    "total_hunks": 5,
                                    "failed_hunks": [
                                        1,
                                        3
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\nimport static android.os.UserHandle.myUserId;\n\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\n>>>>>>> UPSTREAM PATCH (commit b5d66a17fa296117b44f23ae45ff7338cee6ae85)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n// Next tag value for ContentProfileErrorReportUtils.report(): 16\n>>>>>>> UPSTREAM PATCH (commit b5d66a17fa296117b44f23ae45ff7338cee6ae85)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.bluetooth.BluetoothProfile;\n import android.bluetooth.BluetoothProtoEnums;\n import android.content.ContentResolver;\n@@ -54,12 +57,13 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be used for outbound\n  * share.\n  */\n-// Next tag value for ContentProfileErrorReportUtils.report(): 15\n+// Next tag value for ContentProfileErrorReportUtils.report(): 16\n public class BluetoothOppSendFileInfo {\n     private static final String TAG = \"BluetoothOppSendFileInfo\";\n```",
                                    "patch_apply_output": "patching file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nHunk #1 FAILED at 32.\nHunk #2 succeeded at 39 (offset -2 lines).\nHunk #3 FAILED at 54.\nHunk #4 succeeded at 117 (offset -8 lines).\nHunk #5 succeeded at 258 (offset -106 lines).\n2 out of 5 hunks FAILED -- saving rejects to file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java.rej",
                                    "inline_merge_output": "patching file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nHunk #1 NOT MERGED at 35-41.\nHunk #3 merged at 59, NOT MERGED at 65-68."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "2c5add83a18d87ea4a46bc8ab7f675e32c8d6a56",
                            "result": "failure",
                            "downstream_patch_content": "commit 2c5add83a18d87ea4a46bc8ab7f675e32c8d6a56\nAuthor: Billy Huang <billyhuang@google.com>\nDate:   Wed Oct 2 14:27:47 2024 -0700\n\n    RESTRICT AUTOMERGE backport \"opp: validate that content uri belongs to current user\"\n    \n    Bug: 296915500\n    Flag: EXEMPT trivial fix with complete testing coverage\n    Test: atest GoogleBluetoothInstrumentationTests:BluetoothOppSendFileInfoTest\n    Ignore-AOSP-First: fix for undisclosed vulnerability\n    Merged-In: I76b25fcd446d5e0530308e21deafa68d0b768edc\n    Change-Id: I0b6423025c95c13eeea3cbf584212913b5fbf307\n\ndiff --git a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nindex 2adb8e5f44..7ce134341a 100644\n--- a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.res.AssetFileDescriptor;\n@@ -39,6 +41,7 @@ import android.database.Cursor;\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n+import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -49,6 +52,7 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be\n@@ -117,6 +121,11 @@ public class BluetoothOppSendFileInfo {\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n+            if (isContentUriForOtherUser(uri)) {\n+                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n+                return SEND_FILE_INFO_ERROR;\n+            }\n+\n             contentType = contentResolver.getType(uri);\n             Cursor metadataCursor;\n             try {\n@@ -253,6 +262,12 @@ public class BluetoothOppSendFileInfo {\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n+    private static boolean isContentUriForOtherUser(Uri uri) {\n+        String uriUserId = uri.getUserInfo();\n+        return !TextUtils.isEmpty(uriUserId)\n+                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n+    }\n+\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];\ndiff --git a/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\nindex 756836afaa..acb58272fb 100644\n--- a/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\n+++ b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\n@@ -17,6 +17,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import static com.google.common.truth.Truth.assertThat;\n \n import static org.mockito.ArgumentMatchers.any;\n@@ -31,7 +33,6 @@ import android.content.res.AssetFileDescriptor;\n import android.database.MatrixCursor;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n-import android.util.Log;\n \n import androidx.test.platform.app.InstrumentationRegistry;\n import androidx.test.runner.AndroidJUnit4;\n@@ -120,6 +121,110 @@ public class BluetoothOppSendFileInfoTest {\n         assertThat(info).isEqualTo(BluetoothOppSendFileInfo.SEND_FILE_INFO_ERROR);\n     }\n \n+    @Test\n+    public void generateFileInfo_withContentUriForOtherUser_returnsSendFileInfoError()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority((myUserId() + 1) + \"@media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info).isEqualTo(BluetoothOppSendFileInfo.SEND_FILE_INFO_ERROR);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForImplicitUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(\"media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForSameUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(myUserId() + \"@media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    private static Uri buildContentUriWithEncodedAuthority(String authority) {\n+        return new Uri.Builder()\n+                .scheme(\"content\")\n+                .encodedAuthority(authority)\n+                .path(\"external/images/media/1\")\n+                .build();\n+    }\n+\n     @Test\n     public void generateFileInfo_withoutPermissionForAccessingUri_returnsSendFileInfoError() {\n         String type = \"text/plain\";\n",
                            "file_conflicts": [
                                {
                                    "file_name": "android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java",
                                    "total_hunks": 5,
                                    "failed_hunks": [
                                        1,
                                        3
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\nimport static android.os.UserHandle.myUserId;\n\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\n>>>>>>> UPSTREAM PATCH (commit b5d66a17fa296117b44f23ae45ff7338cee6ae85)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n// Next tag value for ContentProfileErrorReportUtils.report(): 16\n>>>>>>> UPSTREAM PATCH (commit b5d66a17fa296117b44f23ae45ff7338cee6ae85)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.bluetooth.BluetoothProfile;\n import android.bluetooth.BluetoothProtoEnums;\n import android.content.ContentResolver;\n@@ -54,12 +57,13 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be used for outbound\n  * share.\n  */\n-// Next tag value for ContentProfileErrorReportUtils.report(): 15\n+// Next tag value for ContentProfileErrorReportUtils.report(): 16\n public class BluetoothOppSendFileInfo {\n     private static final String TAG = \"BluetoothOppSendFileInfo\";\n```",
                                    "patch_apply_output": "patching file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nHunk #1 FAILED at 32.\nHunk #2 succeeded at 39 (offset -2 lines).\nHunk #3 FAILED at 54.\nHunk #4 succeeded at 118 (offset -7 lines).\nHunk #5 succeeded at 264 (offset -100 lines).\n2 out of 5 hunks FAILED -- saving rejects to file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java.rej",
                                    "inline_merge_output": "patching file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nHunk #1 NOT MERGED at 35-41.\nHunk #3 merged at 60, NOT MERGED at 66-69."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-370958259",
            "aliases": [
                "A-370958259",
                "CVE-2025-0080"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-370958259",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "b1612955cb7fb2f69f1e04d437bb7fabd411ff7c"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From b1612955cb7fb2f69f1e04d437bb7fabd411ff7c Mon Sep 17 00:00:00 2001\nFrom: Sumedh Sen <sumedhsen@google.com>\nDate: Thu, 12 Dec 2024 14:29:31 -0800\nSubject: [PATCH] Prevent showing overlays when unarchiving\n\nWhen unarchiving an app:\n- Hide non-system overlays\n- Disable the restore button when another window is being shown on top\n  of Pia\n\nBug: 370958259\nTest: atest CtsPackageUninstallTestCases:ArchiveTest\nFlag: EXEMPT.Bug fix only\nChange-Id: If750c0a613136f3ad3040c544bd70ab428fe5ef2\n---\n .../packageinstaller/UnarchiveActivity.java   |  3 ++\n .../packageinstaller/UnarchiveFragment.java   | 31 ++++++++++++++++++-\n 2 files changed, 33 insertions(+), 1 deletion(-)\n\ndiff --git a/packages/PackageInstaller/src/com/android/packageinstaller/UnarchiveActivity.java b/packages/PackageInstaller/src/com/android/packageinstaller/UnarchiveActivity.java\nindex b20117d78230..c99d37bb6ce6 100644\n--- a/packages/PackageInstaller/src/com/android/packageinstaller/UnarchiveActivity.java\n+++ b/packages/PackageInstaller/src/com/android/packageinstaller/UnarchiveActivity.java\n@@ -19,6 +19,7 @@ package com.android.packageinstaller;\n import static android.Manifest.permission;\n import static android.content.pm.PackageManager.GET_PERMISSIONS;\n import static android.content.pm.PackageManager.MATCH_ARCHIVED_PACKAGES;\n+import static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n \n import android.app.Activity;\n import android.app.DialogFragment;\n@@ -53,6 +54,8 @@ public class UnarchiveActivity extends Activity {\n \n     @Override\n     public void onCreate(Bundle icicle) {\n+        getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n+\n         super.onCreate(null);\n \n         int callingUid = getLaunchedFromUid();\ndiff --git a/packages/PackageInstaller/src/com/android/packageinstaller/UnarchiveFragment.java b/packages/PackageInstaller/src/com/android/packageinstaller/UnarchiveFragment.java\nindex 42dd382b98bc..fbb0fa4d6a57 100644\n--- a/packages/PackageInstaller/src/com/android/packageinstaller/UnarchiveFragment.java\n+++ b/packages/PackageInstaller/src/com/android/packageinstaller/UnarchiveFragment.java\n@@ -21,10 +21,14 @@ import android.app.Dialog;\n import android.app.DialogFragment;\n import android.content.DialogInterface;\n import android.os.Bundle;\n+import android.widget.Button;\n \n public class UnarchiveFragment extends DialogFragment implements\n         DialogInterface.OnClickListener {\n \n+    private Dialog mDialog;\n+    private Button mRestoreButton;\n+\n     @Override\n     public Dialog onCreateDialog(Bundle savedInstanceState) {\n         String appTitle = getArguments().getString(UnarchiveActivity.APP_TITLE);\n@@ -40,7 +44,32 @@ public class UnarchiveFragment extends DialogFragment implements\n         dialogBuilder.setPositiveButton(R.string.restore, this);\n         dialogBuilder.setNegativeButton(android.R.string.cancel, this);\n \n-        return dialogBuilder.create();\n+        mDialog = dialogBuilder.create();\n+        return mDialog;\n+    }\n+\n+    @Override\n+    public void onStart() {\n+        super.onStart();\n+        if (mDialog != null) {\n+            mRestoreButton = ((AlertDialog) mDialog).getButton(DialogInterface.BUTTON_POSITIVE);\n+        }\n+    }\n+\n+    @Override\n+    public void onPause() {\n+        super.onPause();\n+        if (mRestoreButton != null) {\n+            mRestoreButton.setEnabled(false);\n+        }\n+    }\n+\n+    @Override\n+    public void onResume() {\n+        super.onResume();\n+        if (mRestoreButton != null) {\n+            mRestoreButton.setEnabled(true);\n+        }\n     }\n \n     @Override\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "799842233276351680f47420d8754f381dcbf86f"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-341688848",
            "aliases": [
                "A-341688848",
                "CVE-2024-49722"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-341688848",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "e480e1892cafaff977e2ede68e5988eb732d098e"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From e480e1892cafaff977e2ede68e5988eb732d098e Mon Sep 17 00:00:00 2001\nFrom: Anna Bauza <annabauza@google.com>\nDate: Tue, 3 Sep 2024 12:08:43 +0000\nSubject: [PATCH] Fix vulnerability by explicitly set the class name of avatar\n picker.\n\nChange-Id: I0203403d7724076c7d6266a7b5930fa26a3e54b7\nFlag: android.multiuser.fix_avatar_cross_user_leak\nTest: manual\nBug: 341688848\n---\n packages/SettingsLib/res/values/config.xml             | 10 ++++++++++\n .../settingslib/users/EditUserPhotoController.java     |  8 ++++++++\n 2 files changed, 18 insertions(+)\n\ndiff --git a/packages/SettingsLib/res/values/config.xml b/packages/SettingsLib/res/values/config.xml\nindex 68b81db1d9c0..3c3de044cc4e 100644\n--- a/packages/SettingsLib/res/values/config.xml\n+++ b/packages/SettingsLib/res/values/config.xml\n@@ -31,4 +31,14 @@\n     <!-- Control whether status bar should distinguish HSPA data icon form UMTS\n     data icon on devices -->\n     <bool name=\"config_hspa_data_distinguishable\">false</bool>\n+\n+    <!-- Edit User avatar explicit package name -->\n+    <string name=\"config_avatar_picker_package\" translatable=\"false\">\n+        com.android.avatarpicker\n+    </string>\n+\n+    <!-- Edit User avatar explicit activity class -->\n+    <string name=\"config_avatar_picker_class\" translatable=\"false\">\n+        com.android.avatarpicker.ui.AvatarPickerActivity\n+    </string>\n </resources>\n\\ No newline at end of file\ndiff --git a/packages/SettingsLib/src/com/android/settingslib/users/EditUserPhotoController.java b/packages/SettingsLib/src/com/android/settingslib/users/EditUserPhotoController.java\nindex cdc3f123eff7..f38e91ac0d8a 100644\n--- a/packages/SettingsLib/src/com/android/settingslib/users/EditUserPhotoController.java\n+++ b/packages/SettingsLib/src/com/android/settingslib/users/EditUserPhotoController.java\n@@ -32,6 +32,7 @@ import androidx.annotation.Nullable;\n \n import com.android.internal.util.UserIcons;\n import com.android.settingslib.drawable.CircleFramedDrawable;\n+import com.android.settingslib.R;\n import com.android.settingslib.utils.ThreadUtils;\n \n import com.google.common.util.concurrent.FutureCallback;\n@@ -132,6 +133,13 @@ public class EditUserPhotoController {\n         intent.addCategory(Intent.CATEGORY_DEFAULT);\n         if (Flags.avatarSync()) {\n             intent.putExtra(EXTRA_IS_USER_NEW, isUserNew);\n+            // Fix vulnerability b/341688848 by explicitly set the class name of avatar picker.\n+            if (Flags.fixAvatarCrossUserLeak()) {\n+                final String packageName =\n+                        mActivity.getString(R.string.config_avatar_picker_package);\n+                final String className = mActivity.getString(R.string.config_avatar_picker_class);\n+                intent.setClassName(packageName, className);\n+            }\n         } else {\n             // SettingsLib is used by multiple apps therefore we need to know out of all apps\n             // using settingsLib which one is the one we return value to.\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "4b731d5c8715190b88a44c443d5028b3014cd495"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-368579654",
            "aliases": [
                "A-368579654",
                "CVE-2025-22427"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-368579654",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "e0510a62eba04140e459cdd8232f35087aa3073b"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From e0510a62eba04140e459cdd8232f35087aa3073b Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Mat=C3=ADas=20Hern=C3=A1ndez?= <matiashe@google.com>\nDate: Fri, 3 Jan 2025 13:38:10 +0100\nSubject: [PATCH] Remove incorrect call to Window.addFlags with a system flag\n\nThe same flag is being (correctly) added in onCreate, so on top of being wrong this was also completely unnecessary.\n\nBug: 368579654\nTest: atest NotificationAccessConfirmationActivityTest\nFlag: EXEMPT bugfix\n\nChange-Id: I539fca77a1d136bdd0e4892993020884430b8a4e\n---\n .../NotificationAccessConfirmationActivity.java   | 15 ---------------\n ...otificationAccessConfirmationActivityTest.java | 15 +++++++++++++++\n 2 files changed, 15 insertions(+), 15 deletions(-)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex 1adeb644155..8448a8e752a 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -41,7 +41,6 @@ import android.os.UserManager;\n import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n-import android.view.WindowManager;\n import android.view.accessibility.AccessibilityEvent;\n import android.widget.Toast;\n \n@@ -161,20 +160,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         getWindow().setCloseOnTouchOutside(false); \n     }\n \n-    @Override\n-    public void onResume() {\n-        super.onResume();\n-        getWindow().addFlags(\n-                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n-    }\n-\n-    @Override\n-    public void onPause() {\n-        getWindow().clearFlags(\n-                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n-        super.onPause();\n-    }\n-\n     private void onAllow() {\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \ndiff --git a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\nindex 0a953615abf..8ae242f0869 100644\n--- a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n+++ b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n@@ -16,6 +16,8 @@\n \n package com.android.settings.notification;\n \n+import static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n+\n import static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\n \n import static com.google.common.truth.Truth.assertThat;\n@@ -42,6 +44,19 @@ import org.robolectric.RuntimeEnvironment;\n @RunWith(RobolectricTestRunner.class)\n public class NotificationAccessConfirmationActivityTest {\n \n+    @Test\n+    public void onCreate_setsWindowFlags() {\n+        ComponentName cn = new ComponentName(\"com.example\", \"com.example.SomeService\");\n+        installPackage(cn.getPackageName(), \"Example\");\n+\n+        NotificationAccessConfirmationActivity activity = startActivityWithIntent(cn);\n+\n+        assertThat(activity.getWindow().getAttributes().privateFlags\n+                & SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS).isNotEqualTo(0);\n+        assertThat(activity.getWindow().getAttributes().flags\n+                & SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS).isEqualTo(0);\n+    }\n+\n     @Test\n     public void start_withMissingIntentFilter_finishes() {\n         ComponentName cn = new ComponentName(\"com.example\", \"com.example.SomeService\");\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 2,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "4b2cf3f23788ec210863757217ead902ee1f3bb4"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "2a6672dd33d6430da0f240fd600f7379ac301588",
                            "result": "success",
                            "downstream_patch_content": "commit 2a6672dd33d6430da0f240fd600f7379ac301588\nAuthor: Mat\u00edas Hern\u00e1ndez <matiashe@google.com>\nDate:   Fri Jan 3 13:38:10 2025 +0100\n\n    Remove incorrect call to Window.addFlags with a system flag\n    \n    The same flag is being (correctly) added in onCreate, so on top of being wrong this was also completely unnecessary.\n    \n    Bug: 368579654\n    Test: manual\n    Flag: EXEMPT bugfix\n    \n    Change-Id: I539fca77a1d136bdd0e4892993020884430b8a4e\n    Merged-In: I539fca77a1d136bdd0e4892993020884430b8a4e\n    (cherry picked from commit e0510a62eba04140e459cdd8232f35087aa3073b)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex 74b8102ee2c..253ae88e4b3 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -42,7 +42,6 @@ import android.os.UserManager;\n import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n-import android.view.WindowManager;\n import android.view.accessibility.AccessibilityEvent;\n import android.widget.Toast;\n \n@@ -160,20 +159,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         getWindow().setCloseOnTouchOutside(false); \n     }\n \n-    @Override\n-    public void onResume() {\n-        super.onResume();\n-        getWindow().addFlags(\n-                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n-    }\n-\n-    @Override\n-    public void onPause() {\n-        getWindow().clearFlags(\n-                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n-        super.onPause();\n-    }\n-\n     private void onAllow() {\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n"
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "c97cd9e805f9c347db5152553fdd1c4004a558b3",
                            "result": "success",
                            "downstream_patch_content": "commit c97cd9e805f9c347db5152553fdd1c4004a558b3\nAuthor: Mat\u00edas Hern\u00e1ndez <matiashe@google.com>\nDate:   Fri Jan 3 13:38:10 2025 +0100\n\n    Remove incorrect call to Window.addFlags with a system flag\n    \n    The same flag is being (correctly) added in onCreate, so on top of being wrong this was also completely unnecessary.\n    \n    Bug: 368579654\n    Test: atest NotificationAccessConfirmationActivityTest\n    Flag: EXEMPT bugfix\n    \n    Change-Id: I539fca77a1d136bdd0e4892993020884430b8a4e\n    Merged-In: I539fca77a1d136bdd0e4892993020884430b8a4e\n    (cherry picked from commit e0510a62eba04140e459cdd8232f35087aa3073b)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex 74b8102ee2c..253ae88e4b3 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -42,7 +42,6 @@ import android.os.UserManager;\n import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n-import android.view.WindowManager;\n import android.view.accessibility.AccessibilityEvent;\n import android.widget.Toast;\n \n@@ -160,20 +159,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         getWindow().setCloseOnTouchOutside(false); \n     }\n \n-    @Override\n-    public void onResume() {\n-        super.onResume();\n-        getWindow().addFlags(\n-                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n-    }\n-\n-    @Override\n-    public void onPause() {\n-        getWindow().clearFlags(\n-                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n-        super.onPause();\n-    }\n-\n     private void onAllow() {\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \ndiff --git a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\nindex 788f853e19b..1f5640285c6 100644\n--- a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n+++ b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n@@ -16,6 +16,8 @@\n \n package com.android.settings.notification;\n \n+import static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n+\n import static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\n \n import static com.google.common.truth.Truth.assertThat;\n@@ -41,6 +43,19 @@ import org.robolectric.RuntimeEnvironment;\n @RunWith(RobolectricTestRunner.class)\n public class NotificationAccessConfirmationActivityTest {\n \n+    @Test\n+    public void onCreate_setsWindowFlags() {\n+        ComponentName cn = new ComponentName(\"com.example\", \"com.example.SomeService\");\n+        installPackage(cn.getPackageName(), \"Example\");\n+\n+        NotificationAccessConfirmationActivity activity = startActivityWithIntent(cn);\n+\n+        assertThat(activity.getWindow().getAttributes().privateFlags\n+                & SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS).isNotEqualTo(0);\n+        assertThat(activity.getWindow().getAttributes().flags\n+                & SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS).isEqualTo(0);\n+    }\n+\n     @Test\n     public void start_withMissingIntentFilter_finishes() {\n         ComponentName cn = new ComponentName(\"com.example\", \"com.example.SomeService\");\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-376461726",
            "aliases": [
                "A-376461726",
                "CVE-2025-22432"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-376461726",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "4a358cfd8e403597651a6962e8e43c11ea906a59"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 4a358cfd8e403597651a6962e8e43c11ea906a59 Mon Sep 17 00:00:00 2001\nFrom: Grant Menke <grantmenke@google.com>\nDate: Fri, 3 Jan 2025 10:37:09 -0800\nSubject: [PATCH] Ensure connection is unbound on call redirection timeout.\n\nThis CL ensures that the connection is unbound when the call redirection timeout is hit in CallRedirectionProcessor. This resolves a reported security vulnerability.\n\nTest: manual using the provided APK + updated CallRedirectionProcessorTest\nFlag: EXEMPT Security High/Critical Severity CVE\nBug: 376461726\nChange-Id: I76a65c3993f5107652f98bbe0283043ecff27a7c\n---\n .../callredirection/CallRedirectionProcessor.java    |  8 ++++++++\n .../telecom/tests/CallRedirectionProcessorTest.java  | 12 ++++++++++++\n 2 files changed, 20 insertions(+)\n\ndiff --git a/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java b/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\nindex 05e73d544..15b8aa942 100644\n--- a/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\n+++ b/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\n@@ -133,6 +133,14 @@ public class CallRedirectionProcessor implements CallRedirectionCallback {\n                             + mServiceType + \" call redirection service\");\n                 }\n             }\n+            Log.i(this, \"notifyTimeout: call redirection has timed out so \"\n+                    + \"unbinding the connection\");\n+            if (mConnection != null) {\n+                // We still need to call unbind even if the service disconnected.\n+                mContext.unbindService(mConnection);\n+                mConnection = null;\n+            }\n+            mService = null;\n         }\n \n         private class CallRedirectionServiceConnection implements ServiceConnection {\ndiff --git a/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java b/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\nindex 241216aa2..185c08f42 100644\n--- a/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\n+++ b/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\n@@ -221,6 +221,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(false), eq(CallRedirectionProcessor.UI_TYPE_NO_ACTION));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n@@ -249,6 +252,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n@@ -280,6 +286,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n \n         // Wait for another carrier timeout time, but should not expect any carrier service request\n         // is triggered.\n@@ -289,6 +298,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 2,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "12e18223ec4167fcedf44b18a8627c5651286451"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "425b355b0e845595c0e1d698ff2f533a46f58830",
                            "result": "success",
                            "downstream_patch_content": "commit 425b355b0e845595c0e1d698ff2f533a46f58830\nAuthor: Grant Menke <grantmenke@google.com>\nDate:   Fri Jan 3 10:37:09 2025 -0800\n\n    Ensure connection is unbound on call redirection timeout.\n    \n    This CL ensures that the connection is unbound when the call redirection timeout is hit in CallRedirectionProcessor. This resolves a reported security vulnerability.\n    \n    Test: manual using the provided APK + updated CallRedirectionProcessorTest\n    Flag: EXEMPT Security High/Critical Severity CVE\n    Bug: 376461726\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:4a358cfd8e403597651a6962e8e43c11ea906a59)\n    Merged-In: I76a65c3993f5107652f98bbe0283043ecff27a7c\n    Change-Id: I76a65c3993f5107652f98bbe0283043ecff27a7c\n\ndiff --git a/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java b/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\nindex 02debcd6c..1b25441cb 100644\n--- a/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\n+++ b/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\n@@ -133,6 +133,14 @@ public class CallRedirectionProcessor implements CallRedirectionCallback {\n                             + mServiceType + \" call redirection service\");\n                 }\n             }\n+            Log.i(this, \"notifyTimeout: call redirection has timed out so \"\n+                    + \"unbinding the connection\");\n+            if (mConnection != null) {\n+                // We still need to call unbind even if the service disconnected.\n+                mContext.unbindService(mConnection);\n+                mConnection = null;\n+            }\n+            mService = null;\n         }\n \n         private class CallRedirectionServiceConnection implements ServiceConnection {\ndiff --git a/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java b/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\nindex f2fe045ef..9826f68b5 100644\n--- a/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\n+++ b/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\n@@ -219,6 +219,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(false), eq(CallRedirectionProcessor.UI_TYPE_NO_ACTION));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n@@ -247,6 +250,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n@@ -278,6 +284,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n \n         // Wait for another carrier timeout time, but should not expect any carrier service request\n         // is triggered.\n@@ -287,6 +296,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n"
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "9733de498bc44d9865b0061564ac3344426f4da9",
                            "result": "success",
                            "downstream_patch_content": "commit 9733de498bc44d9865b0061564ac3344426f4da9\nAuthor: Grant Menke <grantmenke@google.com>\nDate:   Fri Jan 3 10:37:09 2025 -0800\n\n    Ensure connection is unbound on call redirection timeout.\n    \n    This CL ensures that the connection is unbound when the call redirection timeout is hit in CallRedirectionProcessor. This resolves a reported security vulnerability.\n    \n    Test: manual using the provided APK + updated CallRedirectionProcessorTest\n    Flag: EXEMPT Security High/Critical Severity CVE\n    Bug: 376461726\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:4a358cfd8e403597651a6962e8e43c11ea906a59)\n    Merged-In: I76a65c3993f5107652f98bbe0283043ecff27a7c\n    Change-Id: I76a65c3993f5107652f98bbe0283043ecff27a7c\n\ndiff --git a/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java b/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\nindex 05e73d544..15b8aa942 100644\n--- a/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\n+++ b/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\n@@ -133,6 +133,14 @@ public class CallRedirectionProcessor implements CallRedirectionCallback {\n                             + mServiceType + \" call redirection service\");\n                 }\n             }\n+            Log.i(this, \"notifyTimeout: call redirection has timed out so \"\n+                    + \"unbinding the connection\");\n+            if (mConnection != null) {\n+                // We still need to call unbind even if the service disconnected.\n+                mContext.unbindService(mConnection);\n+                mConnection = null;\n+            }\n+            mService = null;\n         }\n \n         private class CallRedirectionServiceConnection implements ServiceConnection {\ndiff --git a/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java b/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\nindex 01446d158..a302420a0 100644\n--- a/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\n+++ b/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\n@@ -221,6 +221,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(false), eq(CallRedirectionProcessor.UI_TYPE_NO_ACTION));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n@@ -249,6 +252,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n@@ -280,6 +286,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n \n         // Wait for another carrier timeout time, but should not expect any carrier service request\n         // is triggered.\n@@ -289,6 +298,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-341680936",
            "aliases": [
                "A-341680936",
                "CVE-2024-43093"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-341680936",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "b91437020051b4f7fb78dbe14b40dd2f7c754f48"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From b91437020051b4f7fb78dbe14b40dd2f7c754f48 Mon Sep 17 00:00:00 2001\nFrom: Dipankar Bhardwaj <dipankarb@google.com>\nDate: Wed, 21 Aug 2024 14:26:50 +0000\nSubject: [PATCH] Restrict access to directories\n\nRestricted access to Android/data, Android/obb and Android/sandbox\ndirectories and its sub-directories. Replacing path's pattern match\ncheck with file equality check.\n\nTest: atest DocumentsClientTest\nBug: 341680936\nFlag: EXEMPT bug fix\nChange-Id: I8879900e57e1702d11797b81e86d0cc3f55bac22\n---\n .../ExternalStorageProvider.java              | 79 ++++++++++++++++---\n 1 file changed, 68 insertions(+), 11 deletions(-)\n\ndiff --git a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nindex 3409c29d3c2c..defbc1142adb 100644\n--- a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n+++ b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n@@ -16,8 +16,6 @@\n \n package com.android.externalstorage;\n \n-import static java.util.regex.Pattern.CASE_INSENSITIVE;\n-\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.usage.StorageStatsManager;\n@@ -61,12 +59,15 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Locale;\n import java.util.Objects;\n import java.util.UUID;\n-import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n \n /**\n  * Presents content of the shared (a.k.a. \"external\") storage.\n@@ -89,12 +90,9 @@ public class ExternalStorageProvider extends FileSystemProvider {\n     private static final Uri BASE_URI =\n             new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(AUTHORITY).build();\n \n-    /**\n-     * Regex for detecting {@code /Android/data/}, {@code /Android/obb/} and\n-     * {@code /Android/sandbox/} along with all their subdirectories and content.\n-     */\n-    private static final Pattern PATTERN_RESTRICTED_ANDROID_SUBTREES =\n-            Pattern.compile(\"^Android/(?:data|obb|sandbox)(?:/.+)?\", CASE_INSENSITIVE);\n+    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n+\n+    private static final String STORAGE_PATH = \"/storage/\";\n \n     private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n             Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON, Root.COLUMN_TITLE,\n@@ -309,10 +307,69 @@ public class ExternalStorageProvider extends FileSystemProvider {\n             return false;\n         }\n \n-        final String path = getPathFromDocId(documentId);\n-        return PATTERN_RESTRICTED_ANDROID_SUBTREES.matcher(path).matches();\n+        try {\n+            final RootInfo root = getRootFromDocId(documentId);\n+            final String canonicalPath = getPathFromDocId(documentId);\n+            return isRestrictedPath(root.rootId, canonicalPath);\n+        } catch (Exception e) {\n+            return true;\n+        }\n     }\n \n+    /**\n+     * Based on the given root id and path, we restrict path access if file is Android/data or\n+     * Android/obb or Android/sandbox or one of their subdirectories.\n+     *\n+     * @param canonicalPath of the file\n+     * @return true if path is restricted\n+     */\n+    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n+        if (rootId == null || canonicalPath == null) {\n+            return true;\n+        }\n+\n+        final String rootPath;\n+        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n+            // Creates \"/storage/emulated/<user-id>\"\n+            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n+        } else {\n+            // Creates \"/storage/<volume-uuid>\"\n+            rootPath = STORAGE_PATH + rootId;\n+        }\n+        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n+                Paths.get(rootPath, \"Android\", \"data\"),\n+                Paths.get(rootPath, \"Android\", \"obb\"),\n+                Paths.get(rootPath, \"Android\", \"sandbox\"));\n+        // We need to identify restricted parent paths which actually exist on the device\n+        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n+                Files::exists).collect(Collectors.toList());\n+\n+        boolean isRestricted = false;\n+        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n+        try {\n+            while (filePathToCheck != null) {\n+                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n+                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n+                        isRestricted = true;\n+                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n+                        break;\n+                    }\n+                }\n+                if (isRestricted) {\n+                    break;\n+                }\n+\n+                filePathToCheck = filePathToCheck.getParent();\n+            }\n+        } catch (Exception e) {\n+            Log.w(TAG, \"Error in checking file equality check.\", e);\n+            isRestricted = true;\n+        }\n+\n+        return isRestricted;\n+    }\n+\n+\n     /**\n      * Check that the directory is the root of storage or blocked file from tree.\n      * <p>\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 0,
                    "failed_patches": 4,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "01006f7f97083ae49a546f9e0a94db7bdfd2a152",
                            "result": "failure",
                            "downstream_patch_content": "commit 01006f7f97083ae49a546f9e0a94db7bdfd2a152\nAuthor: Dipankar Bhardwaj <dipankarb@google.com>\nDate:   Wed Aug 21 14:26:50 2024 +0000\n\n    DO NOT MERGE Restrict access to directories\n    \n    Restricted access to Android/data, Android/obb and Android/sandbox\n    directories and its sub-directories. Replacing path's pattern match\n    check with file equality check.\n    \n    Test: atest DocumentsClientTest\n    Bug: 341680936\n    Flag: EXEMPT bug fix\n    Change-Id: I8879900e57e1702d11797b81e86d0cc3f55bac22\n    Merged-In: I8879900e57e1702d11797b81e86d0cc3f55bac22\n\ndiff --git a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nindex 992de22f4265..fdeccfa7b9d0 100644\n--- a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n+++ b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n@@ -16,8 +16,6 @@\n \n package com.android.externalstorage;\n \n-import static java.util.regex.Pattern.CASE_INSENSITIVE;\n-\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.usage.StorageStatsManager;\n@@ -61,12 +59,15 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Locale;\n import java.util.Objects;\n import java.util.UUID;\n-import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n \n /**\n  * Presents content of the shared (a.k.a. \"external\") storage.\n@@ -89,12 +90,9 @@ public class ExternalStorageProvider extends FileSystemProvider {\n     private static final Uri BASE_URI =\n             new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(AUTHORITY).build();\n \n-    /**\n-     * Regex for detecting {@code /Android/data/}, {@code /Android/obb/} and\n-     * {@code /Android/sandbox/} along with all their subdirectories and content.\n-     */\n-    private static final Pattern PATTERN_RESTRICTED_ANDROID_SUBTREES =\n-            Pattern.compile(\"^Android/(?:data|obb|sandbox)(?:/.+)?\", CASE_INSENSITIVE);\n+    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n+\n+    private static final String STORAGE_PATH = \"/storage/\";\n \n     private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n             Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON, Root.COLUMN_TITLE,\n@@ -308,10 +306,69 @@ public class ExternalStorageProvider extends FileSystemProvider {\n             return false;\n         }\n \n-        final String path = getPathFromDocId(documentId);\n-        return PATTERN_RESTRICTED_ANDROID_SUBTREES.matcher(path).matches();\n+        try {\n+            final RootInfo root = getRootFromDocId(documentId);\n+            final String canonicalPath = getPathFromDocId(documentId);\n+            return isRestrictedPath(root.rootId, canonicalPath);\n+        } catch (Exception e) {\n+            return true;\n+        }\n     }\n \n+    /**\n+     * Based on the given root id and path, we restrict path access if file is Android/data or\n+     * Android/obb or Android/sandbox or one of their subdirectories.\n+     *\n+     * @param canonicalPath of the file\n+     * @return true if path is restricted\n+     */\n+    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n+        if (rootId == null || canonicalPath == null) {\n+            return true;\n+        }\n+\n+        final String rootPath;\n+        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n+            // Creates \"/storage/emulated/<user-id>\"\n+            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n+        } else {\n+            // Creates \"/storage/<volume-uuid>\"\n+            rootPath = STORAGE_PATH + rootId;\n+        }\n+        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n+                Paths.get(rootPath, \"Android\", \"data\"),\n+                Paths.get(rootPath, \"Android\", \"obb\"),\n+                Paths.get(rootPath, \"Android\", \"sandbox\"));\n+        // We need to identify restricted parent paths which actually exist on the device\n+        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n+                Files::exists).collect(Collectors.toList());\n+\n+        boolean isRestricted = false;\n+        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n+        try {\n+            while (filePathToCheck != null) {\n+                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n+                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n+                        isRestricted = true;\n+                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n+                        break;\n+                    }\n+                }\n+                if (isRestricted) {\n+                    break;\n+                }\n+\n+                filePathToCheck = filePathToCheck.getParent();\n+            }\n+        } catch (Exception e) {\n+            Log.w(TAG, \"Error in checking file equality check.\", e);\n+            isRestricted = true;\n+        }\n+\n+        return isRestricted;\n+    }\n+\n+\n     /**\n      * Check that the directory is the root of storage or blocked file from tree.\n      * <p>\n",
                            "file_conflicts": [
                                {
                                    "file_name": "packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n\n=======\nimport java.util.stream.Collectors;\n>>>>>>> UPSTREAM PATCH (commit b91437020051b4f7fb78dbe14b40dd2f7c754f48)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n    // docId format: root:path/to/file\n=======\n    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n\n    private static final String STORAGE_PATH = \"/storage/\";\n>>>>>>> UPSTREAM PATCH (commit b91437020051b4f7fb78dbe14b40dd2f7c754f48)"
                                        },
                                        {
                                            "hunk_number": 3,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n            } catch (FileNotFoundException e) {\n                Log.e(TAG, \"Failed to determine rootInfo for docId\");\n=======\n\n        try {\n            final RootInfo root = getRootFromDocId(documentId);\n            final String canonicalPath = getPathFromDocId(documentId);\n            return isRestrictedPath(root.rootId, canonicalPath);\n        } catch (Exception e) {\n            return true;\n        }\n>>>>>>> UPSTREAM PATCH (commit b91437020051b4f7fb78dbe14b40dd2f7c754f48)"
                                        },
                                        {
                                            "hunk_number": 4,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n\n=======\n    /**\n     * Based on the given root id and path, we restrict path access if file is Android/data or\n     * Android/obb or Android/sandbox or one of their subdirectories.\n     *\n     * @param canonicalPath of the file\n     * @return true if path is restricted\n     */\n    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n        if (rootId == null || canonicalPath == null) {\n            return true;\n        }\n\n        final String rootPath;\n        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n            // Creates \"/storage/emulated/<user-id>\"\n            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n        } else {\n            // Creates \"/storage/<volume-uuid>\"\n            rootPath = STORAGE_PATH + rootId;\n        }\n        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n                Paths.get(rootPath, \"Android\", \"data\"),\n                Paths.get(rootPath, \"Android\", \"obb\"),\n                Paths.get(rootPath, \"Android\", \"sandbox\"));\n        // We need to identify restricted parent paths which actually exist on the device\n        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n                Files::exists).collect(Collectors.toList());\n\n        boolean isRestricted = false;\n        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n        try {\n            while (filePathToCheck != null) {\n                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n                        isRestricted = true;\n                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n                        break;\n                    }\n                }\n                if (isRestricted) {\n                    break;\n                }\n\n                filePathToCheck = filePathToCheck.getParent();\n            }\n        } catch (Exception e) {\n            Log.w(TAG, \"Error in checking file equality check.\", e);\n            isRestricted = true;\n        }\n\n        return isRestricted;\n    }\n\n\n    /**\n     * Check that the directory is the root of storage or blocked file from tree.\n     * <p>\n>>>>>>> UPSTREAM PATCH (commit b91437020051b4f7fb78dbe14b40dd2f7c754f48)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n+++ packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n@@ -16,8 +16,6 @@\n \n package com.android.externalstorage;\n \n-import static java.util.regex.Pattern.CASE_INSENSITIVE;\n-\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.usage.StorageStatsManager;\n@@ -61,12 +59,15 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Locale;\n import java.util.Objects;\n import java.util.UUID;\n-import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n \n /**\n  * Presents content of the shared (a.k.a. \"external\") storage.\n@@ -89,12 +90,9 @@ public class ExternalStorageProvider extends FileSystemProvider {\n     private static final Uri BASE_URI =\n             new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(AUTHORITY).build();\n \n-    /**\n-     * Regex for detecting {@code /Android/data/}, {@code /Android/obb/} and\n-     * {@code /Android/sandbox/} along with all their subdirectories and content.\n-     */\n-    private static final Pattern PATTERN_RESTRICTED_ANDROID_SUBTREES =\n-            Pattern.compile(\"^Android/(?:data|obb|sandbox)(?:/.+)?\", CASE_INSENSITIVE);\n+    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n+\n+    private static final String STORAGE_PATH = \"/storage/\";\n \n     private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n             Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON, Root.COLUMN_TITLE,\n@@ -309,10 +307,69 @@ public class ExternalStorageProvider extends FileSystemProvider {\n             return false;\n         }\n \n-        final String path = getPathFromDocId(documentId);\n-        return PATTERN_RESTRICTED_ANDROID_SUBTREES.matcher(path).matches();\n+        try {\n+            final RootInfo root = getRootFromDocId(documentId);\n+            final String canonicalPath = getPathFromDocId(documentId);\n+            return isRestrictedPath(root.rootId, canonicalPath);\n+        } catch (Exception e) {\n+            return true;\n+        }\n     }\n \n+    /**\n+     * Based on the given root id and path, we restrict path access if file is Android/data or\n+     * Android/obb or Android/sandbox or one of their subdirectories.\n+     *\n+     * @param canonicalPath of the file\n+     * @return true if path is restricted\n+     */\n+    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n+        if (rootId == null || canonicalPath == null) {\n+            return true;\n+        }\n+\n+        final String rootPath;\n+        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n+            // Creates \"/storage/emulated/<user-id>\"\n+            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n+        } else {\n+            // Creates \"/storage/<volume-uuid>\"\n+            rootPath = STORAGE_PATH + rootId;\n+        }\n+        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n+                Paths.get(rootPath, \"Android\", \"data\"),\n+                Paths.get(rootPath, \"Android\", \"obb\"),\n+                Paths.get(rootPath, \"Android\", \"sandbox\"));\n+        // We need to identify restricted parent paths which actually exist on the device\n+        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n+                Files::exists).collect(Collectors.toList());\n+\n+        boolean isRestricted = false;\n+        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n+        try {\n+            while (filePathToCheck != null) {\n+                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n+                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n+                        isRestricted = true;\n+                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n+                        break;\n+                    }\n+                }\n+                if (isRestricted) {\n+                    break;\n+                }\n+\n+                filePathToCheck = filePathToCheck.getParent();\n+            }\n+        } catch (Exception e) {\n+            Log.w(TAG, \"Error in checking file equality check.\", e);\n+            isRestricted = true;\n+        }\n+\n+        return isRestricted;\n+    }\n+\n+\n     /**\n      * Check that the directory is the root of storage or blocked file from tree.\n      * <p>\n```",
                                    "patch_apply_output": "patching file packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n4 out of 4 hunks ignored -- saving rejects to file packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java.rej",
                                    "inline_merge_output": "patching file packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nHunk #1 already applied at 19.\nHunk #2 merged at 62-64, NOT MERGED at 69-72.\nHunk #3 NOT MERGED at 84-90.\nHunk #4 NOT MERGED at 321-333,336-395."
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "da4b7509afc15cda9195501b41ecc6c5a0670c19",
                            "result": "failure",
                            "downstream_patch_content": "commit da4b7509afc15cda9195501b41ecc6c5a0670c19\nAuthor: Dipankar Bhardwaj <dipankarb@google.com>\nDate:   Wed Aug 21 14:26:50 2024 +0000\n\n    DO NOT MERGE Restrict access to directories\n    \n    Restricted access to Android/data, Android/obb and Android/sandbox\n    directories and its sub-directories. Replacing path's pattern match\n    check with file equality check.\n    \n    Test: atest DocumentsClientTest\n    Bug: 341680936\n    Flag: EXEMPT bug fix\n    Change-Id: I8879900e57e1702d11797b81e86d0cc3f55bac22\n\ndiff --git a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nindex 992de22f4265..fdeccfa7b9d0 100644\n--- a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n+++ b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n@@ -16,8 +16,6 @@\n \n package com.android.externalstorage;\n \n-import static java.util.regex.Pattern.CASE_INSENSITIVE;\n-\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.usage.StorageStatsManager;\n@@ -61,12 +59,15 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Locale;\n import java.util.Objects;\n import java.util.UUID;\n-import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n \n /**\n  * Presents content of the shared (a.k.a. \"external\") storage.\n@@ -89,12 +90,9 @@ public class ExternalStorageProvider extends FileSystemProvider {\n     private static final Uri BASE_URI =\n             new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(AUTHORITY).build();\n \n-    /**\n-     * Regex for detecting {@code /Android/data/}, {@code /Android/obb/} and\n-     * {@code /Android/sandbox/} along with all their subdirectories and content.\n-     */\n-    private static final Pattern PATTERN_RESTRICTED_ANDROID_SUBTREES =\n-            Pattern.compile(\"^Android/(?:data|obb|sandbox)(?:/.+)?\", CASE_INSENSITIVE);\n+    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n+\n+    private static final String STORAGE_PATH = \"/storage/\";\n \n     private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n             Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON, Root.COLUMN_TITLE,\n@@ -308,10 +306,69 @@ public class ExternalStorageProvider extends FileSystemProvider {\n             return false;\n         }\n \n-        final String path = getPathFromDocId(documentId);\n-        return PATTERN_RESTRICTED_ANDROID_SUBTREES.matcher(path).matches();\n+        try {\n+            final RootInfo root = getRootFromDocId(documentId);\n+            final String canonicalPath = getPathFromDocId(documentId);\n+            return isRestrictedPath(root.rootId, canonicalPath);\n+        } catch (Exception e) {\n+            return true;\n+        }\n     }\n \n+    /**\n+     * Based on the given root id and path, we restrict path access if file is Android/data or\n+     * Android/obb or Android/sandbox or one of their subdirectories.\n+     *\n+     * @param canonicalPath of the file\n+     * @return true if path is restricted\n+     */\n+    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n+        if (rootId == null || canonicalPath == null) {\n+            return true;\n+        }\n+\n+        final String rootPath;\n+        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n+            // Creates \"/storage/emulated/<user-id>\"\n+            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n+        } else {\n+            // Creates \"/storage/<volume-uuid>\"\n+            rootPath = STORAGE_PATH + rootId;\n+        }\n+        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n+                Paths.get(rootPath, \"Android\", \"data\"),\n+                Paths.get(rootPath, \"Android\", \"obb\"),\n+                Paths.get(rootPath, \"Android\", \"sandbox\"));\n+        // We need to identify restricted parent paths which actually exist on the device\n+        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n+                Files::exists).collect(Collectors.toList());\n+\n+        boolean isRestricted = false;\n+        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n+        try {\n+            while (filePathToCheck != null) {\n+                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n+                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n+                        isRestricted = true;\n+                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n+                        break;\n+                    }\n+                }\n+                if (isRestricted) {\n+                    break;\n+                }\n+\n+                filePathToCheck = filePathToCheck.getParent();\n+            }\n+        } catch (Exception e) {\n+            Log.w(TAG, \"Error in checking file equality check.\", e);\n+            isRestricted = true;\n+        }\n+\n+        return isRestricted;\n+    }\n+\n+\n     /**\n      * Check that the directory is the root of storage or blocked file from tree.\n      * <p>\n",
                            "file_conflicts": [
                                {
                                    "file_name": "packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n\n=======\nimport java.util.stream.Collectors;\n>>>>>>> UPSTREAM PATCH (commit b91437020051b4f7fb78dbe14b40dd2f7c754f48)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n    // docId format: root:path/to/file\n=======\n    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n\n    private static final String STORAGE_PATH = \"/storage/\";\n>>>>>>> UPSTREAM PATCH (commit b91437020051b4f7fb78dbe14b40dd2f7c754f48)"
                                        },
                                        {
                                            "hunk_number": 3,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n            } catch (FileNotFoundException e) {\n                Log.e(TAG, \"Failed to determine rootInfo for docId\");\n=======\n\n        try {\n            final RootInfo root = getRootFromDocId(documentId);\n            final String canonicalPath = getPathFromDocId(documentId);\n            return isRestrictedPath(root.rootId, canonicalPath);\n        } catch (Exception e) {\n            return true;\n        }\n>>>>>>> UPSTREAM PATCH (commit b91437020051b4f7fb78dbe14b40dd2f7c754f48)"
                                        },
                                        {
                                            "hunk_number": 4,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n\n=======\n    /**\n     * Based on the given root id and path, we restrict path access if file is Android/data or\n     * Android/obb or Android/sandbox or one of their subdirectories.\n     *\n     * @param canonicalPath of the file\n     * @return true if path is restricted\n     */\n    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n        if (rootId == null || canonicalPath == null) {\n            return true;\n        }\n\n        final String rootPath;\n        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n            // Creates \"/storage/emulated/<user-id>\"\n            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n        } else {\n            // Creates \"/storage/<volume-uuid>\"\n            rootPath = STORAGE_PATH + rootId;\n        }\n        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n                Paths.get(rootPath, \"Android\", \"data\"),\n                Paths.get(rootPath, \"Android\", \"obb\"),\n                Paths.get(rootPath, \"Android\", \"sandbox\"));\n        // We need to identify restricted parent paths which actually exist on the device\n        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n                Files::exists).collect(Collectors.toList());\n\n        boolean isRestricted = false;\n        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n        try {\n            while (filePathToCheck != null) {\n                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n                        isRestricted = true;\n                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n                        break;\n                    }\n                }\n                if (isRestricted) {\n                    break;\n                }\n\n                filePathToCheck = filePathToCheck.getParent();\n            }\n        } catch (Exception e) {\n            Log.w(TAG, \"Error in checking file equality check.\", e);\n            isRestricted = true;\n        }\n\n        return isRestricted;\n    }\n\n\n    /**\n     * Check that the directory is the root of storage or blocked file from tree.\n     * <p>\n>>>>>>> UPSTREAM PATCH (commit b91437020051b4f7fb78dbe14b40dd2f7c754f48)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n+++ packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n@@ -16,8 +16,6 @@\n \n package com.android.externalstorage;\n \n-import static java.util.regex.Pattern.CASE_INSENSITIVE;\n-\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.usage.StorageStatsManager;\n@@ -61,12 +59,15 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Locale;\n import java.util.Objects;\n import java.util.UUID;\n-import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n \n /**\n  * Presents content of the shared (a.k.a. \"external\") storage.\n@@ -89,12 +90,9 @@ public class ExternalStorageProvider extends FileSystemProvider {\n     private static final Uri BASE_URI =\n             new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(AUTHORITY).build();\n \n-    /**\n-     * Regex for detecting {@code /Android/data/}, {@code /Android/obb/} and\n-     * {@code /Android/sandbox/} along with all their subdirectories and content.\n-     */\n-    private static final Pattern PATTERN_RESTRICTED_ANDROID_SUBTREES =\n-            Pattern.compile(\"^Android/(?:data|obb|sandbox)(?:/.+)?\", CASE_INSENSITIVE);\n+    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n+\n+    private static final String STORAGE_PATH = \"/storage/\";\n \n     private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n             Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON, Root.COLUMN_TITLE,\n@@ -309,10 +307,69 @@ public class ExternalStorageProvider extends FileSystemProvider {\n             return false;\n         }\n \n-        final String path = getPathFromDocId(documentId);\n-        return PATTERN_RESTRICTED_ANDROID_SUBTREES.matcher(path).matches();\n+        try {\n+            final RootInfo root = getRootFromDocId(documentId);\n+            final String canonicalPath = getPathFromDocId(documentId);\n+            return isRestrictedPath(root.rootId, canonicalPath);\n+        } catch (Exception e) {\n+            return true;\n+        }\n     }\n \n+    /**\n+     * Based on the given root id and path, we restrict path access if file is Android/data or\n+     * Android/obb or Android/sandbox or one of their subdirectories.\n+     *\n+     * @param canonicalPath of the file\n+     * @return true if path is restricted\n+     */\n+    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n+        if (rootId == null || canonicalPath == null) {\n+            return true;\n+        }\n+\n+        final String rootPath;\n+        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n+            // Creates \"/storage/emulated/<user-id>\"\n+            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n+        } else {\n+            // Creates \"/storage/<volume-uuid>\"\n+            rootPath = STORAGE_PATH + rootId;\n+        }\n+        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n+                Paths.get(rootPath, \"Android\", \"data\"),\n+                Paths.get(rootPath, \"Android\", \"obb\"),\n+                Paths.get(rootPath, \"Android\", \"sandbox\"));\n+        // We need to identify restricted parent paths which actually exist on the device\n+        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n+                Files::exists).collect(Collectors.toList());\n+\n+        boolean isRestricted = false;\n+        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n+        try {\n+            while (filePathToCheck != null) {\n+                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n+                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n+                        isRestricted = true;\n+                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n+                        break;\n+                    }\n+                }\n+                if (isRestricted) {\n+                    break;\n+                }\n+\n+                filePathToCheck = filePathToCheck.getParent();\n+            }\n+        } catch (Exception e) {\n+            Log.w(TAG, \"Error in checking file equality check.\", e);\n+            isRestricted = true;\n+        }\n+\n+        return isRestricted;\n+    }\n+\n+\n     /**\n      * Check that the directory is the root of storage or blocked file from tree.\n      * <p>\n```",
                                    "patch_apply_output": "patching file packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n4 out of 4 hunks ignored -- saving rejects to file packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java.rej",
                                    "inline_merge_output": "patching file packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nHunk #1 already applied at 19.\nHunk #2 merged at 62-64, NOT MERGED at 69-72.\nHunk #3 NOT MERGED at 84-90.\nHunk #4 NOT MERGED at 321-333,336-395."
                                }
                            ]
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "3ebd6405d2e87e6df0887d76470e4b7504bd3a4d"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "7f1bc271379d97bed56e33f8470992d38bce5531",
                            "result": "failure",
                            "downstream_patch_content": "commit 7f1bc271379d97bed56e33f8470992d38bce5531\nAuthor: Dipankar Bhardwaj <dipankarb@google.com>\nDate:   Wed Aug 21 14:26:50 2024 +0000\n\n    Restrict access to directories\n    \n    Restricted access to Android/data, Android/obb and Android/sandbox\n    directories and its sub-directories. Replacing path's pattern match\n    check with file equality check.\n    \n    Test: atest DocumentsClientTest\n    Bug: 341680936\n    Flag: EXEMPT bug fix\n    Change-Id: I8879900e57e1702d11797b81e86d0cc3f55bac22\n    Merged-In: I8879900e57e1702d11797b81e86d0cc3f55bac22\n\ndiff --git a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nindex 3409c29d3c2c..defbc1142adb 100644\n--- a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n+++ b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n@@ -16,8 +16,6 @@\n \n package com.android.externalstorage;\n \n-import static java.util.regex.Pattern.CASE_INSENSITIVE;\n-\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.usage.StorageStatsManager;\n@@ -61,12 +59,15 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Locale;\n import java.util.Objects;\n import java.util.UUID;\n-import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n \n /**\n  * Presents content of the shared (a.k.a. \"external\") storage.\n@@ -89,12 +90,9 @@ public class ExternalStorageProvider extends FileSystemProvider {\n     private static final Uri BASE_URI =\n             new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(AUTHORITY).build();\n \n-    /**\n-     * Regex for detecting {@code /Android/data/}, {@code /Android/obb/} and\n-     * {@code /Android/sandbox/} along with all their subdirectories and content.\n-     */\n-    private static final Pattern PATTERN_RESTRICTED_ANDROID_SUBTREES =\n-            Pattern.compile(\"^Android/(?:data|obb|sandbox)(?:/.+)?\", CASE_INSENSITIVE);\n+    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n+\n+    private static final String STORAGE_PATH = \"/storage/\";\n \n     private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n             Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON, Root.COLUMN_TITLE,\n@@ -309,10 +307,69 @@ public class ExternalStorageProvider extends FileSystemProvider {\n             return false;\n         }\n \n-        final String path = getPathFromDocId(documentId);\n-        return PATTERN_RESTRICTED_ANDROID_SUBTREES.matcher(path).matches();\n+        try {\n+            final RootInfo root = getRootFromDocId(documentId);\n+            final String canonicalPath = getPathFromDocId(documentId);\n+            return isRestrictedPath(root.rootId, canonicalPath);\n+        } catch (Exception e) {\n+            return true;\n+        }\n     }\n \n+    /**\n+     * Based on the given root id and path, we restrict path access if file is Android/data or\n+     * Android/obb or Android/sandbox or one of their subdirectories.\n+     *\n+     * @param canonicalPath of the file\n+     * @return true if path is restricted\n+     */\n+    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n+        if (rootId == null || canonicalPath == null) {\n+            return true;\n+        }\n+\n+        final String rootPath;\n+        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n+            // Creates \"/storage/emulated/<user-id>\"\n+            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n+        } else {\n+            // Creates \"/storage/<volume-uuid>\"\n+            rootPath = STORAGE_PATH + rootId;\n+        }\n+        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n+                Paths.get(rootPath, \"Android\", \"data\"),\n+                Paths.get(rootPath, \"Android\", \"obb\"),\n+                Paths.get(rootPath, \"Android\", \"sandbox\"));\n+        // We need to identify restricted parent paths which actually exist on the device\n+        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n+                Files::exists).collect(Collectors.toList());\n+\n+        boolean isRestricted = false;\n+        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n+        try {\n+            while (filePathToCheck != null) {\n+                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n+                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n+                        isRestricted = true;\n+                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n+                        break;\n+                    }\n+                }\n+                if (isRestricted) {\n+                    break;\n+                }\n+\n+                filePathToCheck = filePathToCheck.getParent();\n+            }\n+        } catch (Exception e) {\n+            Log.w(TAG, \"Error in checking file equality check.\", e);\n+            isRestricted = true;\n+        }\n+\n+        return isRestricted;\n+    }\n+\n+\n     /**\n      * Check that the directory is the root of storage or blocked file from tree.\n      * <p>\n",
                            "file_conflicts": [
                                {
                                    "file_name": "packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\nimport java.util.stream.Collectors;\n>>>>>>> UPSTREAM PATCH (commit b91437020051b4f7fb78dbe14b40dd2f7c754f48)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n    // docId format: root:path/to/file\n=======\n    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n\n    private static final String STORAGE_PATH = \"/storage/\";\n>>>>>>> UPSTREAM PATCH (commit b91437020051b4f7fb78dbe14b40dd2f7c754f48)"
                                        },
                                        {
                                            "hunk_number": 3,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n            } catch (FileNotFoundException e) {\n                Log.e(TAG, \"Failed to determine rootInfo for docId\");\n=======\n\n        try {\n            final RootInfo root = getRootFromDocId(documentId);\n            final String canonicalPath = getPathFromDocId(documentId);\n            return isRestrictedPath(root.rootId, canonicalPath);\n        } catch (Exception e) {\n            return true;\n        }\n>>>>>>> UPSTREAM PATCH (commit b91437020051b4f7fb78dbe14b40dd2f7c754f48)"
                                        },
                                        {
                                            "hunk_number": 4,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n    /**\n     * Based on the given root id and path, we restrict path access if file is Android/data or\n     * Android/obb or Android/sandbox or one of their subdirectories.\n     *\n     * @param canonicalPath of the file\n     * @return true if path is restricted\n     */\n    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n        if (rootId == null || canonicalPath == null) {\n            return true;\n        }\n\n        final String rootPath;\n        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n            // Creates \"/storage/emulated/<user-id>\"\n            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n        } else {\n            // Creates \"/storage/<volume-uuid>\"\n            rootPath = STORAGE_PATH + rootId;\n        }\n        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n                Paths.get(rootPath, \"Android\", \"data\"),\n                Paths.get(rootPath, \"Android\", \"obb\"),\n                Paths.get(rootPath, \"Android\", \"sandbox\"));\n        // We need to identify restricted parent paths which actually exist on the device\n        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n                Files::exists).collect(Collectors.toList());\n\n        boolean isRestricted = false;\n        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n        try {\n            while (filePathToCheck != null) {\n                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n                        isRestricted = true;\n                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n                        break;\n                    }\n                }\n                if (isRestricted) {\n                    break;\n                }\n\n                filePathToCheck = filePathToCheck.getParent();\n            }\n        } catch (Exception e) {\n            Log.w(TAG, \"Error in checking file equality check.\", e);\n            isRestricted = true;\n        }\n\n        return isRestricted;\n    }\n\n\n    /**\n     * Check that the directory is the root of storage or blocked file from tree.\n     * <p>\n>>>>>>> UPSTREAM PATCH (commit b91437020051b4f7fb78dbe14b40dd2f7c754f48)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n+++ packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n@@ -16,8 +16,6 @@\n \n package com.android.externalstorage;\n \n-import static java.util.regex.Pattern.CASE_INSENSITIVE;\n-\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.usage.StorageStatsManager;\n@@ -61,12 +59,15 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Locale;\n import java.util.Objects;\n import java.util.UUID;\n-import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n \n /**\n  * Presents content of the shared (a.k.a. \"external\") storage.\n@@ -89,12 +90,9 @@ public class ExternalStorageProvider extends FileSystemProvider {\n     private static final Uri BASE_URI =\n             new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(AUTHORITY).build();\n \n-    /**\n-     * Regex for detecting {@code /Android/data/}, {@code /Android/obb/} and\n-     * {@code /Android/sandbox/} along with all their subdirectories and content.\n-     */\n-    private static final Pattern PATTERN_RESTRICTED_ANDROID_SUBTREES =\n-            Pattern.compile(\"^Android/(?:data|obb|sandbox)(?:/.+)?\", CASE_INSENSITIVE);\n+    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n+\n+    private static final String STORAGE_PATH = \"/storage/\";\n \n     private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n             Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON, Root.COLUMN_TITLE,\n@@ -309,10 +307,69 @@ public class ExternalStorageProvider extends FileSystemProvider {\n             return false;\n         }\n \n-        final String path = getPathFromDocId(documentId);\n-        return PATTERN_RESTRICTED_ANDROID_SUBTREES.matcher(path).matches();\n+        try {\n+            final RootInfo root = getRootFromDocId(documentId);\n+            final String canonicalPath = getPathFromDocId(documentId);\n+            return isRestrictedPath(root.rootId, canonicalPath);\n+        } catch (Exception e) {\n+            return true;\n+        }\n     }\n \n+    /**\n+     * Based on the given root id and path, we restrict path access if file is Android/data or\n+     * Android/obb or Android/sandbox or one of their subdirectories.\n+     *\n+     * @param canonicalPath of the file\n+     * @return true if path is restricted\n+     */\n+    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n+        if (rootId == null || canonicalPath == null) {\n+            return true;\n+        }\n+\n+        final String rootPath;\n+        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n+            // Creates \"/storage/emulated/<user-id>\"\n+            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n+        } else {\n+            // Creates \"/storage/<volume-uuid>\"\n+            rootPath = STORAGE_PATH + rootId;\n+        }\n+        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n+                Paths.get(rootPath, \"Android\", \"data\"),\n+                Paths.get(rootPath, \"Android\", \"obb\"),\n+                Paths.get(rootPath, \"Android\", \"sandbox\"));\n+        // We need to identify restricted parent paths which actually exist on the device\n+        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n+                Files::exists).collect(Collectors.toList());\n+\n+        boolean isRestricted = false;\n+        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n+        try {\n+            while (filePathToCheck != null) {\n+                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n+                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n+                        isRestricted = true;\n+                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n+                        break;\n+                    }\n+                }\n+                if (isRestricted) {\n+                    break;\n+                }\n+\n+                filePathToCheck = filePathToCheck.getParent();\n+            }\n+        } catch (Exception e) {\n+            Log.w(TAG, \"Error in checking file equality check.\", e);\n+            isRestricted = true;\n+        }\n+\n+        return isRestricted;\n+    }\n+\n+\n     /**\n      * Check that the directory is the root of storage or blocked file from tree.\n      * <p>\n```",
                                    "patch_apply_output": "patching file packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n4 out of 4 hunks ignored -- saving rejects to file packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java.rej",
                                    "inline_merge_output": "patching file packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nHunk #1 already applied at 19.\nHunk #2 merged at 62-64, NOT MERGED at 70-73.\nHunk #3 NOT MERGED at 85-91.\nHunk #4 NOT MERGED at 323-335,338-397."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "c984c3b842c2b458db2f1a29574af1d137f28143",
                            "result": "failure",
                            "downstream_patch_content": "commit c984c3b842c2b458db2f1a29574af1d137f28143\nAuthor: Dipankar Bhardwaj <dipankarb@google.com>\nDate:   Wed Aug 21 14:26:50 2024 +0000\n\n    Restrict access to directories\n    \n    Restricted access to Android/data, Android/obb and Android/sandbox\n    directories and its sub-directories. Replacing path's pattern match\n    check with file equality check.\n    \n    Test: atest DocumentsClientTest\n    Bug: 341680936\n    Flag: EXEMPT bug fix\n    Change-Id: I8879900e57e1702d11797b81e86d0cc3f55bac22\n    Merged-In: I8879900e57e1702d11797b81e86d0cc3f55bac22\n\ndiff --git a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nindex 3409c29d3c2c..defbc1142adb 100644\n--- a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n+++ b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n@@ -16,8 +16,6 @@\n \n package com.android.externalstorage;\n \n-import static java.util.regex.Pattern.CASE_INSENSITIVE;\n-\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.usage.StorageStatsManager;\n@@ -61,12 +59,15 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Locale;\n import java.util.Objects;\n import java.util.UUID;\n-import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n \n /**\n  * Presents content of the shared (a.k.a. \"external\") storage.\n@@ -89,12 +90,9 @@ public class ExternalStorageProvider extends FileSystemProvider {\n     private static final Uri BASE_URI =\n             new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(AUTHORITY).build();\n \n-    /**\n-     * Regex for detecting {@code /Android/data/}, {@code /Android/obb/} and\n-     * {@code /Android/sandbox/} along with all their subdirectories and content.\n-     */\n-    private static final Pattern PATTERN_RESTRICTED_ANDROID_SUBTREES =\n-            Pattern.compile(\"^Android/(?:data|obb|sandbox)(?:/.+)?\", CASE_INSENSITIVE);\n+    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n+\n+    private static final String STORAGE_PATH = \"/storage/\";\n \n     private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n             Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON, Root.COLUMN_TITLE,\n@@ -309,10 +307,69 @@ public class ExternalStorageProvider extends FileSystemProvider {\n             return false;\n         }\n \n-        final String path = getPathFromDocId(documentId);\n-        return PATTERN_RESTRICTED_ANDROID_SUBTREES.matcher(path).matches();\n+        try {\n+            final RootInfo root = getRootFromDocId(documentId);\n+            final String canonicalPath = getPathFromDocId(documentId);\n+            return isRestrictedPath(root.rootId, canonicalPath);\n+        } catch (Exception e) {\n+            return true;\n+        }\n     }\n \n+    /**\n+     * Based on the given root id and path, we restrict path access if file is Android/data or\n+     * Android/obb or Android/sandbox or one of their subdirectories.\n+     *\n+     * @param canonicalPath of the file\n+     * @return true if path is restricted\n+     */\n+    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n+        if (rootId == null || canonicalPath == null) {\n+            return true;\n+        }\n+\n+        final String rootPath;\n+        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n+            // Creates \"/storage/emulated/<user-id>\"\n+            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n+        } else {\n+            // Creates \"/storage/<volume-uuid>\"\n+            rootPath = STORAGE_PATH + rootId;\n+        }\n+        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n+                Paths.get(rootPath, \"Android\", \"data\"),\n+                Paths.get(rootPath, \"Android\", \"obb\"),\n+                Paths.get(rootPath, \"Android\", \"sandbox\"));\n+        // We need to identify restricted parent paths which actually exist on the device\n+        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n+                Files::exists).collect(Collectors.toList());\n+\n+        boolean isRestricted = false;\n+        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n+        try {\n+            while (filePathToCheck != null) {\n+                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n+                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n+                        isRestricted = true;\n+                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n+                        break;\n+                    }\n+                }\n+                if (isRestricted) {\n+                    break;\n+                }\n+\n+                filePathToCheck = filePathToCheck.getParent();\n+            }\n+        } catch (Exception e) {\n+            Log.w(TAG, \"Error in checking file equality check.\", e);\n+            isRestricted = true;\n+        }\n+\n+        return isRestricted;\n+    }\n+\n+\n     /**\n      * Check that the directory is the root of storage or blocked file from tree.\n      * <p>\n",
                            "file_conflicts": [
                                {
                                    "file_name": "packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\nimport java.util.stream.Collectors;\n>>>>>>> UPSTREAM PATCH (commit b91437020051b4f7fb78dbe14b40dd2f7c754f48)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n    // docId format: root:path/to/file\n=======\n    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n\n    private static final String STORAGE_PATH = \"/storage/\";\n>>>>>>> UPSTREAM PATCH (commit b91437020051b4f7fb78dbe14b40dd2f7c754f48)"
                                        },
                                        {
                                            "hunk_number": 3,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n            } catch (FileNotFoundException e) {\n                Log.e(TAG, \"Failed to determine rootInfo for docId\");\n=======\n\n        try {\n            final RootInfo root = getRootFromDocId(documentId);\n            final String canonicalPath = getPathFromDocId(documentId);\n            return isRestrictedPath(root.rootId, canonicalPath);\n        } catch (Exception e) {\n            return true;\n        }\n>>>>>>> UPSTREAM PATCH (commit b91437020051b4f7fb78dbe14b40dd2f7c754f48)"
                                        },
                                        {
                                            "hunk_number": 4,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n    /**\n     * Based on the given root id and path, we restrict path access if file is Android/data or\n     * Android/obb or Android/sandbox or one of their subdirectories.\n     *\n     * @param canonicalPath of the file\n     * @return true if path is restricted\n     */\n    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n        if (rootId == null || canonicalPath == null) {\n            return true;\n        }\n\n        final String rootPath;\n        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n            // Creates \"/storage/emulated/<user-id>\"\n            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n        } else {\n            // Creates \"/storage/<volume-uuid>\"\n            rootPath = STORAGE_PATH + rootId;\n        }\n        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n                Paths.get(rootPath, \"Android\", \"data\"),\n                Paths.get(rootPath, \"Android\", \"obb\"),\n                Paths.get(rootPath, \"Android\", \"sandbox\"));\n        // We need to identify restricted parent paths which actually exist on the device\n        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n                Files::exists).collect(Collectors.toList());\n\n        boolean isRestricted = false;\n        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n        try {\n            while (filePathToCheck != null) {\n                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n                        isRestricted = true;\n                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n                        break;\n                    }\n                }\n                if (isRestricted) {\n                    break;\n                }\n\n                filePathToCheck = filePathToCheck.getParent();\n            }\n        } catch (Exception e) {\n            Log.w(TAG, \"Error in checking file equality check.\", e);\n            isRestricted = true;\n        }\n\n        return isRestricted;\n    }\n\n\n    /**\n     * Check that the directory is the root of storage or blocked file from tree.\n     * <p>\n>>>>>>> UPSTREAM PATCH (commit b91437020051b4f7fb78dbe14b40dd2f7c754f48)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n+++ packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n@@ -16,8 +16,6 @@\n \n package com.android.externalstorage;\n \n-import static java.util.regex.Pattern.CASE_INSENSITIVE;\n-\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.usage.StorageStatsManager;\n@@ -61,12 +59,15 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Locale;\n import java.util.Objects;\n import java.util.UUID;\n-import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n \n /**\n  * Presents content of the shared (a.k.a. \"external\") storage.\n@@ -89,12 +90,9 @@ public class ExternalStorageProvider extends FileSystemProvider {\n     private static final Uri BASE_URI =\n             new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(AUTHORITY).build();\n \n-    /**\n-     * Regex for detecting {@code /Android/data/}, {@code /Android/obb/} and\n-     * {@code /Android/sandbox/} along with all their subdirectories and content.\n-     */\n-    private static final Pattern PATTERN_RESTRICTED_ANDROID_SUBTREES =\n-            Pattern.compile(\"^Android/(?:data|obb|sandbox)(?:/.+)?\", CASE_INSENSITIVE);\n+    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n+\n+    private static final String STORAGE_PATH = \"/storage/\";\n \n     private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n             Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON, Root.COLUMN_TITLE,\n@@ -309,10 +307,69 @@ public class ExternalStorageProvider extends FileSystemProvider {\n             return false;\n         }\n \n-        final String path = getPathFromDocId(documentId);\n-        return PATTERN_RESTRICTED_ANDROID_SUBTREES.matcher(path).matches();\n+        try {\n+            final RootInfo root = getRootFromDocId(documentId);\n+            final String canonicalPath = getPathFromDocId(documentId);\n+            return isRestrictedPath(root.rootId, canonicalPath);\n+        } catch (Exception e) {\n+            return true;\n+        }\n     }\n \n+    /**\n+     * Based on the given root id and path, we restrict path access if file is Android/data or\n+     * Android/obb or Android/sandbox or one of their subdirectories.\n+     *\n+     * @param canonicalPath of the file\n+     * @return true if path is restricted\n+     */\n+    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n+        if (rootId == null || canonicalPath == null) {\n+            return true;\n+        }\n+\n+        final String rootPath;\n+        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n+            // Creates \"/storage/emulated/<user-id>\"\n+            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n+        } else {\n+            // Creates \"/storage/<volume-uuid>\"\n+            rootPath = STORAGE_PATH + rootId;\n+        }\n+        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n+                Paths.get(rootPath, \"Android\", \"data\"),\n+                Paths.get(rootPath, \"Android\", \"obb\"),\n+                Paths.get(rootPath, \"Android\", \"sandbox\"));\n+        // We need to identify restricted parent paths which actually exist on the device\n+        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n+                Files::exists).collect(Collectors.toList());\n+\n+        boolean isRestricted = false;\n+        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n+        try {\n+            while (filePathToCheck != null) {\n+                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n+                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n+                        isRestricted = true;\n+                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n+                        break;\n+                    }\n+                }\n+                if (isRestricted) {\n+                    break;\n+                }\n+\n+                filePathToCheck = filePathToCheck.getParent();\n+            }\n+        } catch (Exception e) {\n+            Log.w(TAG, \"Error in checking file equality check.\", e);\n+            isRestricted = true;\n+        }\n+\n+        return isRestricted;\n+    }\n+\n+\n     /**\n      * Check that the directory is the root of storage or blocked file from tree.\n      * <p>\n```",
                                    "patch_apply_output": "patching file packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n4 out of 4 hunks ignored -- saving rejects to file packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java.rej",
                                    "inline_merge_output": "patching file packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nHunk #1 already applied at 19.\nHunk #2 merged at 62-64, NOT MERGED at 70-73.\nHunk #3 NOT MERGED at 85-91.\nHunk #4 NOT MERGED at 323-335,338-397."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-369103643",
            "aliases": [
                "A-369103643",
                "CVE-2024-49737"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-369103643",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "20c568e77eae5d469cd5e594b644d8645d830dbd"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 20c568e77eae5d469cd5e594b644d8645d830dbd Mon Sep 17 00:00:00 2001\nFrom: Chris Li <lihongyu@google.com>\nDate: Wed, 9 Oct 2024 01:50:57 +0000\nSubject: [PATCH] Pass SafeActivityOptions with actual caller for\n startActivityInTF\n\nWe clearCallingUid before apply the WCT, but SafeActivityOptions will\nquery the Binder Uid when construct. Update to pass in the actual\ncaller.\n\nFlag: EXEMPT bug fix\nBug: 369103643\nTest: atest WmTests:WindowOrganizerTests#\n      testStartActivityInTaskFragment_checkCallerPermission\nChange-Id: I873ae576de0bc4a7402c2f522b45853bce48a0c5\n---\n .../java/com/android/server/wm/ActivityStartController.java  | 5 ++---\n .../com/android/server/wm/WindowOrganizerController.java     | 4 +++-\n 2 files changed, 5 insertions(+), 4 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/wm/ActivityStartController.java b/services/core/java/com/android/server/wm/ActivityStartController.java\nindex 35ec5adf54b0..0580d4a5a4a3 100644\n--- a/services/core/java/com/android/server/wm/ActivityStartController.java\n+++ b/services/core/java/com/android/server/wm/ActivityStartController.java\n@@ -43,7 +43,6 @@ import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageManager;\n import android.content.pm.ResolveInfo;\n import android.os.Binder;\n-import android.os.Bundle;\n import android.os.IBinder;\n import android.os.Trace;\n import android.os.UserHandle;\n@@ -550,14 +549,14 @@ public class ActivityStartController {\n      * Starts an activity in the TaskFragment.\n      * @param taskFragment TaskFragment {@link TaskFragment} to start the activity in.\n      * @param activityIntent intent to start the activity.\n-     * @param activityOptions ActivityOptions to start the activity with.\n+     * @param activityOptions SafeActivityOptions to start the activity with.\n      * @param resultTo the caller activity\n      * @param callingUid the caller uid\n      * @param callingPid the caller pid\n      * @return the start result.\n      */\n     int startActivityInTaskFragment(@NonNull TaskFragment taskFragment,\n-            @NonNull Intent activityIntent, @Nullable Bundle activityOptions,\n+            @NonNull Intent activityIntent, @Nullable SafeActivityOptions activityOptions,\n             @Nullable IBinder resultTo, int callingUid, int callingPid,\n             @Nullable IBinder errorCallbackToken) {\n         final ActivityRecord caller =\ndiff --git a/services/core/java/com/android/server/wm/WindowOrganizerController.java b/services/core/java/com/android/server/wm/WindowOrganizerController.java\nindex f8d0bc252b0f..fe2a8850905c 100644\n--- a/services/core/java/com/android/server/wm/WindowOrganizerController.java\n+++ b/services/core/java/com/android/server/wm/WindowOrganizerController.java\n@@ -1517,8 +1517,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = waitAsyncStart(() -> mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                 callerActivityToken, caller.mUid, caller.mPid,\n                                 errorCallbackToken));\n                 if (!isStartResultSuccessful(result)) {\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "31d655813075ed45f934080d1743231c3b75a0d2"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "ef9ea0faa26e0ce0ee5e8dc70a663f98e04b0ca0",
                            "result": "failure",
                            "downstream_patch_content": "commit ef9ea0faa26e0ce0ee5e8dc70a663f98e04b0ca0\nAuthor: Chris Li <lihongyu@google.com>\nDate:   Wed Oct 9 01:50:57 2024 +0000\n\n    Pass SafeActivityOptions with actual caller for startActivityInTF\n    \n    We clearCallingUid before apply the WCT, but SafeActivityOptions will\n    query the Binder Uid when construct. Update to pass in the actual\n    caller.\n    \n    Flag: EXEMPT bug fix\n    Bug: 369103643\n    Test: atest WmTests:WindowOrganizerTests#\n          testStartActivityInTaskFragment_checkCallerPermission\n    Merged-In: I873ae576de0bc4a7402c2f522b45853bce48a0c5\n    Change-Id: I873ae576de0bc4a7402c2f522b45853bce48a0c5\n    (cherry picked from commit 20c568e77eae5d469cd5e594b644d8645d830dbd)\n\ndiff --git a/services/core/java/com/android/server/wm/ActivityStartController.java b/services/core/java/com/android/server/wm/ActivityStartController.java\nindex 32ed4725b3b4..d51b90ef1ec0 100644\n--- a/services/core/java/com/android/server/wm/ActivityStartController.java\n+++ b/services/core/java/com/android/server/wm/ActivityStartController.java\n@@ -39,7 +39,6 @@ import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageManager;\n import android.content.pm.ResolveInfo;\n import android.os.Binder;\n-import android.os.Bundle;\n import android.os.IBinder;\n import android.os.UserHandle;\n import android.provider.Settings;\n@@ -500,14 +499,14 @@ public class ActivityStartController {\n      * Starts an activity in the TaskFragment.\n      * @param taskFragment TaskFragment {@link TaskFragment} to start the activity in.\n      * @param activityIntent intent to start the activity.\n-     * @param activityOptions ActivityOptions to start the activity with.\n+     * @param activityOptions SafeActivityOptions to start the activity with.\n      * @param resultTo the caller activity\n      * @param callingUid the caller uid\n      * @param callingPid the caller pid\n      * @return the start result.\n      */\n     int startActivityInTaskFragment(@NonNull TaskFragment taskFragment,\n-            @NonNull Intent activityIntent, @Nullable Bundle activityOptions,\n+            @NonNull Intent activityIntent, @Nullable SafeActivityOptions activityOptions,\n             @Nullable IBinder resultTo, int callingUid, int callingPid,\n             @Nullable IBinder errorCallbackToken) {\n         final ActivityRecord caller =\ndiff --git a/services/core/java/com/android/server/wm/WindowOrganizerController.java b/services/core/java/com/android/server/wm/WindowOrganizerController.java\nindex 4f4d5967365c..65dce1352ba4 100644\n--- a/services/core/java/com/android/server/wm/WindowOrganizerController.java\n+++ b/services/core/java/com/android/server/wm/WindowOrganizerController.java\n@@ -722,8 +722,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 }\n                 final Intent activityIntent = hop.getActivityIntent();\n                 final Bundle activityOptions = hop.getLaunchOptions();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(tf, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(tf, activityIntent, safeOptions,\n                                 hop.getCallingActivity(), caller.mUid, caller.mPid,\n                                 errorCallbackToken);\n                 if (!isStartResultSuccessful(result)) {\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/wm/WindowOrganizerController.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n                                errorCallbackToken);\n=======\n                final IBinder callerActivityToken = operation.getActivityToken();\n                final Intent activityIntent = operation.getActivityIntent();\n                final Bundle activityOptions = operation.getBundle();\n                final SafeActivityOptions safeOptions =\n                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                final int result = waitAsyncStart(() -> mService.getActivityStartController()\n                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                callerActivityToken, caller.mUid, caller.mPid,\n                                errorCallbackToken));\n>>>>>>> UPSTREAM PATCH (commit 20c568e77eae5d469cd5e594b644d8645d830dbd)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/wm/WindowOrganizerController.java\n+++ services/core/java/com/android/server/wm/WindowOrganizerController.java\n@@ -1517,8 +1517,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = waitAsyncStart(() -> mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                 callerActivityToken, caller.mUid, caller.mPid,\n                                 errorCallbackToken));\n                 if (!isStartResultSuccessful(result)) {\n```",
                                    "patch_apply_output": "patching file services/core/java/com/android/server/wm/ActivityStartController.java\nHunk #1 succeeded at 39 with fuzz 2 (offset -4 lines).\nHunk #2 succeeded at 499 (offset -50 lines).\npatching file services/core/java/com/android/server/wm/WindowOrganizerController.java\nHunk #1 FAILED at 1517.\n1 out of 1 hunk FAILED -- saving rejects to file services/core/java/com/android/server/wm/WindowOrganizerController.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/wm/WindowOrganizerController.java\nHunk #1 NOT MERGED at 728-740."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "198f7b559f9a13d5b9d26b41c6b95bc1e45fcb1e",
                            "result": "failure",
                            "downstream_patch_content": "commit 198f7b559f9a13d5b9d26b41c6b95bc1e45fcb1e\nAuthor: Chris Li <lihongyu@google.com>\nDate:   Wed Oct 9 01:50:57 2024 +0000\n\n    Pass SafeActivityOptions with actual caller for startActivityInTF\n    \n    We clearCallingUid before apply the WCT, but SafeActivityOptions will\n    query the Binder Uid when construct. Update to pass in the actual\n    caller.\n    \n    Flag: EXEMPT bug fix\n    Bug: 369103643\n    Test: atest WmTests:WindowOrganizerTests#\n          testStartActivityInTaskFragment_checkCallerPermission\n    Merged-In: I873ae576de0bc4a7402c2f522b45853bce48a0c5\n    Change-Id: I873ae576de0bc4a7402c2f522b45853bce48a0c5\n    (cherry picked from commit 20c568e77eae5d469cd5e594b644d8645d830dbd)\n\ndiff --git a/services/core/java/com/android/server/wm/ActivityStartController.java b/services/core/java/com/android/server/wm/ActivityStartController.java\nindex a6e50405e7d9..4de02f7f812f 100644\n--- a/services/core/java/com/android/server/wm/ActivityStartController.java\n+++ b/services/core/java/com/android/server/wm/ActivityStartController.java\n@@ -43,7 +43,6 @@ import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageManager;\n import android.content.pm.ResolveInfo;\n import android.os.Binder;\n-import android.os.Bundle;\n import android.os.IBinder;\n import android.os.Trace;\n import android.os.UserHandle;\n@@ -529,14 +528,14 @@ public class ActivityStartController {\n      * Starts an activity in the TaskFragment.\n      * @param taskFragment TaskFragment {@link TaskFragment} to start the activity in.\n      * @param activityIntent intent to start the activity.\n-     * @param activityOptions ActivityOptions to start the activity with.\n+     * @param activityOptions SafeActivityOptions to start the activity with.\n      * @param resultTo the caller activity\n      * @param callingUid the caller uid\n      * @param callingPid the caller pid\n      * @return the start result.\n      */\n     int startActivityInTaskFragment(@NonNull TaskFragment taskFragment,\n-            @NonNull Intent activityIntent, @Nullable Bundle activityOptions,\n+            @NonNull Intent activityIntent, @Nullable SafeActivityOptions activityOptions,\n             @Nullable IBinder resultTo, int callingUid, int callingPid,\n             @Nullable IBinder errorCallbackToken) {\n         final ActivityRecord caller =\ndiff --git a/services/core/java/com/android/server/wm/WindowOrganizerController.java b/services/core/java/com/android/server/wm/WindowOrganizerController.java\nindex 027ab97693fd..7b59d6fbd820 100644\n--- a/services/core/java/com/android/server/wm/WindowOrganizerController.java\n+++ b/services/core/java/com/android/server/wm/WindowOrganizerController.java\n@@ -1189,8 +1189,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                 callerActivityToken, caller.mUid, caller.mPid,\n                                 errorCallbackToken);\n                 if (!isStartResultSuccessful(result)) {\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/wm/WindowOrganizerController.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n                final int result = mService.getActivityStartController()\n                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n=======\n                final SafeActivityOptions safeOptions =\n                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                final int result = waitAsyncStart(() -> mService.getActivityStartController()\n                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n>>>>>>> UPSTREAM PATCH (commit 20c568e77eae5d469cd5e594b644d8645d830dbd)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/wm/WindowOrganizerController.java\n+++ services/core/java/com/android/server/wm/WindowOrganizerController.java\n@@ -1517,8 +1517,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = waitAsyncStart(() -> mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                 callerActivityToken, caller.mUid, caller.mPid,\n                                 errorCallbackToken));\n                 if (!isStartResultSuccessful(result)) {\n```",
                                    "patch_apply_output": "patching file services/core/java/com/android/server/wm/ActivityStartController.java\nHunk #2 succeeded at 528 (offset -21 lines).\npatching file services/core/java/com/android/server/wm/WindowOrganizerController.java\nHunk #1 FAILED at 1517.\n1 out of 1 hunk FAILED -- saving rejects to file services/core/java/com/android/server/wm/WindowOrganizerController.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/wm/WindowOrganizerController.java\nHunk #1 NOT MERGED at 1192-1200."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-375396810",
            "aliases": [
                "A-375396810",
                "CVE-2025-22407"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375396810",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "00555617ddbbc1a19089104c084d14f465c971ce"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 00555617ddbbc1a19089104c084d14f465c971ce Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Sat, 2 Nov 2024 02:29:10 +0000\nSubject: [PATCH] Fix more memory-unsafe logging\n\nIn various locations around the stack, log statements use structures that\nmay, in exceptional cases, have been freed by preceding calls.  This can\nlead to use after free and potentially to security vulnerabilities.\n\nUse local variables instead, or store the length before the call if no\nlocal variable is already convenient.\n\nBug: 375404242\nBug: 375398779\nBug: 375397720\nBug: 375397164\nBug: 375397370\nBug: 375396810\nBug: 375159652\nBug: 375160214\nBug: 375159480\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: Ia50e074de751661a0e617bfffa17871497b8d1ea\n---\n system/stack/avct/avct_lcb_act.cc    | 5 ++++-\n system/stack/bnep/bnep_main.cc       | 4 +++-\n system/stack/bnep/bnep_utils.cc      | 3 ++-\n system/stack/hid/hidd_conn.cc        | 4 ++--\n system/stack/rfcomm/rfc_ts_frames.cc | 3 ++-\n system/stack/rfcomm/rfc_utils.cc     | 3 ++-\n system/stack/sdp/sdp_discovery.cc    | 2 +-\n system/stack/sdp/sdp_server.cc       | 4 ++--\n 8 files changed, 18 insertions(+), 10 deletions(-)\n\ndiff --git a/system/stack/avct/avct_lcb_act.cc b/system/stack/avct/avct_lcb_act.cc\nindex 986bce7d34..32da9d865b 100644\n--- a/system/stack/avct/avct_lcb_act.cc\n+++ b/system/stack/avct/avct_lcb_act.cc\n@@ -727,10 +727,13 @@ void avct_lcb_msg_ind(tAVCT_LCB* p_lcb, tAVCT_LCB_EVT* p_data) {\n     p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n     AVCT_BUILD_HDR(p, label, AVCT_PKT_TYPE_SINGLE, AVCT_REJ);\n     UINT16_TO_BE_STREAM(p, pid);\n+\n+    uint16_t len = p_buf->len;\n+\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_lcb->ch_lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} lcid:0x{:04x} len:{}\", p_lcb->peer_addr,\n-                p_lcb->ch_lcid, p_buf->len);\n+                p_lcb->ch_lcid, len);\n     }\n   }\n }\ndiff --git a/system/stack/bnep/bnep_main.cc b/system/stack/bnep/bnep_main.cc\nindex e0e3c4540c..adf3c8666e 100644\n--- a/system/stack/bnep/bnep_main.cc\n+++ b/system/stack/bnep/bnep_main.cc\n@@ -295,10 +295,12 @@ static void bnep_congestion_ind(uint16_t l2cap_cid, bool is_congested) {\n         break;\n       }\n \n+      uint16_t len = p_buf->len;\n+\n       if (stack::l2cap::get_interface().L2CA_DataWrite(l2cap_cid, p_buf) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n         log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda, l2cap_cid,\n-                  p_buf->len);\n+                  len);\n       }\n     }\n   }\ndiff --git a/system/stack/bnep/bnep_utils.cc b/system/stack/bnep/bnep_utils.cc\nindex 252facf668..4092d9afee 100644\n--- a/system/stack/bnep/bnep_utils.cc\n+++ b/system/stack/bnep/bnep_utils.cc\n@@ -411,10 +411,11 @@ void bnepu_check_send_packet(tBNEP_CONN* p_bcb, BT_HDR* p_buf) {\n       fixed_queue_enqueue(p_bcb->xmit_q, p_buf);\n     }\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_bcb->l2cap_cid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda,\n-                p_bcb->l2cap_cid, p_buf->len);\n+                p_bcb->l2cap_cid, len);\n     }\n   }\n }\ndiff --git a/system/stack/hid/hidd_conn.cc b/system/stack/hid/hidd_conn.cc\nindex c64a7b9104..695e5d6c84 100644\n--- a/system/stack/hid/hidd_conn.cc\n+++ b/system/stack/hid/hidd_conn.cc\n@@ -88,10 +88,10 @@ static void hidd_check_config_done() {\n \n     // send outstanding data on intr\n     if (hd_cb.pending_data) {\n+      uint16_t len = hd_cb.pending_data->len;\n       if (stack::l2cap::get_interface().L2CA_DataWrite(p_hcon->intr_cid, hd_cb.pending_data) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n-        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid,\n-                  hd_cb.pending_data->len);\n+        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid, len);\n       }\n       hd_cb.pending_data = NULL;\n     }\ndiff --git a/system/stack/rfcomm/rfc_ts_frames.cc b/system/stack/rfcomm/rfc_ts_frames.cc\nindex ea57abf6dc..e93cfed9b8 100644\n--- a/system/stack/rfcomm/rfc_ts_frames.cc\n+++ b/system/stack/rfcomm/rfc_ts_frames.cc\n@@ -201,10 +201,11 @@ void rfc_send_buf_uih(tRFC_MCB* p_mcb, uint8_t dlci, BT_HDR* p_buf) {\n   if (dlci == RFCOMM_MX_DLCI) {\n     rfc_check_send_cmd(p_mcb, p_buf);\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p_buf->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/rfcomm/rfc_utils.cc b/system/stack/rfcomm/rfc_utils.cc\nindex 23420892cb..0c5074db76 100644\n--- a/system/stack/rfcomm/rfc_utils.cc\n+++ b/system/stack/rfcomm/rfc_utils.cc\n@@ -428,9 +428,10 @@ void rfc_check_send_cmd(tRFC_MCB* p_mcb, BT_HDR* p_buf) {\n     if (p == NULL) {\n       break;\n     }\n+    uint16_t len = p->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p) != tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/sdp/sdp_discovery.cc b/system/stack/sdp/sdp_discovery.cc\nindex 4fa484e14a..6aba1993af 100644\n--- a/system/stack/sdp/sdp_discovery.cc\n+++ b/system/stack/sdp/sdp_discovery.cc\n@@ -877,7 +877,7 @@ static void process_service_attr_rsp(tCONN_CB* p_ccb, uint8_t* p_reply, uint8_t*\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_msg) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-                p_ccb->connection_id, p_msg->len);\n+                p_ccb->connection_id, p - p_start);\n     }\n \n     /* Start inactivity timer */\ndiff --git a/system/stack/sdp/sdp_server.cc b/system/stack/sdp/sdp_server.cc\nindex abd70aedb1..0f379708e9 100644\n--- a/system/stack/sdp/sdp_server.cc\n+++ b/system/stack/sdp/sdp_server.cc\n@@ -300,7 +300,7 @@ static void process_service_search(tCONN_CB* p_ccb, uint16_t trans_num, uint16_t\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n@@ -564,7 +564,7 @@ static void process_service_attr_req(tCONN_CB* p_ccb, uint16_t trans_num, uint16\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "43cfd234de9ba9557118b0014513269cc1aeefda"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-364027038",
            "aliases": [
                "A-364027038",
                "CVE-2024-49747"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-364027038",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "7de5617f7d5266fe57c990c428621b5d4e92728a"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 7de5617f7d5266fe57c990c428621b5d4e92728a Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Thu, 12 Sep 2024 17:26:55 +0000\nSubject: [PATCH] Fix OOB writes in gatt_sr.cc\n\nAt various points in gatt_sr.cc, the output of the\ngatt_tcb_get_payload_size function is used without checking for a\npositive length.  However, in exceptional cases it is possible for the\nchannel to be closed at the time the function is called, which will lead\nto a zero length and cause an OOB write in subsequent processing.\n\nFix all of these.\n\nBug: 364026473\nBug: 364027038\nBug: 364027949\nBug: 364025411\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial validity checks\nTag: #security\nIgnore-AOSP-First: Security\nChange-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n---\n system/stack/gatt/gatt_sr.cc | 21 +++++++++++++++++++++\n 1 file changed, 21 insertions(+)\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 995ea810cb..0235ba964e 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n@@ -949,6 +960,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid, uint8_t\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1096,6 +1112,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12-release: Command '['git', 'checkout', 'android12-release']' returned non-zero exit status 1.",
                            "downstream_patch": "7e5f45df8880293e1ab40367670d1a8959a542f9"
                        },
                        {
                            "downstream_version": "12L",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12L-release: Command '['git', 'checkout', 'android12L-release']' returned non-zero exit status 1.",
                            "downstream_patch": "7e5f45df8880293e1ab40367670d1a8959a542f9"
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "84ea459acaf3c6e7215e044e59dc3e9187f1f7b8"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "2fc3087b9ac3019518c6ceb8a64d181d6bb04907",
                            "result": "failure",
                            "downstream_patch_content": "commit 2fc3087b9ac3019518c6ceb8a64d181d6bb04907\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 4 18:23:45 2024 +0000\n\n    Fix OOB writes in gatt_sr.cc\n    \n    At various points in gatt_sr.cc, the output of the\n    gatt_tcb_get_payload_size function is used without checking for a\n    positive length.  However, in exceptional cases it is possible for the\n    channel to be closed at the time the function is called, which will lead\n    to a zero length and cause an OOB write in subsequent processing.\n    \n    Fix all of these.\n    \n    Bug: 364026473\n    Bug: 364027038\n    Bug: 364027949\n    Bug: 364025411\n    Test: m libbluetooth\n    Test: researcher POC\n    Flag: EXEMPT trivial validity checks\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n    Change-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n",
                            "file_conflicts": [
                                {
                                    "file_name": "system/stack/gatt/gatt_sr.cc",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n=======\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n=======\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 3,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 4,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- system/stack/gatt/gatt_sr.cc\n+++ system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
                                    "patch_apply_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 FAILED at 772.\nHunk #2 FAILED at 804.\nHunk #3 succeeded at 886 with fuzz 2 (offset -63 lines).\nHunk #4 succeeded at 1038 with fuzz 2 (offset -63 lines).\n2 out of 4 hunks FAILED -- saving rejects to file system/stack/gatt/gatt_sr.cc.rej",
                                    "inline_merge_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 NOT MERGED at 889-898.\nHunk #2 NOT MERGED at 900-913.\nHunk #3 NOT MERGED at 1074-1083.\nHunk #4 NOT MERGED at 1128-1140."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "2fc3087b9ac3019518c6ceb8a64d181d6bb04907",
                            "result": "failure",
                            "downstream_patch_content": "commit 2fc3087b9ac3019518c6ceb8a64d181d6bb04907\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 4 18:23:45 2024 +0000\n\n    Fix OOB writes in gatt_sr.cc\n    \n    At various points in gatt_sr.cc, the output of the\n    gatt_tcb_get_payload_size function is used without checking for a\n    positive length.  However, in exceptional cases it is possible for the\n    channel to be closed at the time the function is called, which will lead\n    to a zero length and cause an OOB write in subsequent processing.\n    \n    Fix all of these.\n    \n    Bug: 364026473\n    Bug: 364027038\n    Bug: 364027949\n    Bug: 364025411\n    Test: m libbluetooth\n    Test: researcher POC\n    Flag: EXEMPT trivial validity checks\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n    Change-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n",
                            "file_conflicts": [
                                {
                                    "file_name": "system/stack/gatt/gatt_sr.cc",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n=======\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n=======\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 3,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 4,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- system/stack/gatt/gatt_sr.cc\n+++ system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
                                    "patch_apply_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 FAILED at 772.\nHunk #2 FAILED at 804.\nHunk #3 succeeded at 902 with fuzz 2 (offset -47 lines).\nHunk #4 succeeded at 1054 with fuzz 2 (offset -47 lines).\n2 out of 4 hunks FAILED -- saving rejects to file system/stack/gatt/gatt_sr.cc.rej",
                                    "inline_merge_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 NOT MERGED at 905-914.\nHunk #2 NOT MERGED at 916-929.\nHunk #3 NOT MERGED at 1089-1098.\nHunk #4 NOT MERGED at 1127-1139."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-364037868",
            "aliases": [
                "A-364037868",
                "CVE-2025-0097"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-364037868",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "ea329372d8426c6cdbc2d5570c10bef1003d9912"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From ea329372d8426c6cdbc2d5570c10bef1003d9912 Mon Sep 17 00:00:00 2001\nFrom: Vishnu Nair <vishnun@google.com>\nDate: Tue, 17 Sep 2024 10:00:39 -0700\nSubject: [PATCH] Validate originating process for transferTouchGesture API\n\nAddresses a security vulnerability where a malicious process could\npotentially steal an active touch gesture from its host or embedded\nprocess. The fix ensures that the requested is the owner of the\nInputTransferToken. This adds an additional verification on top of\nthe existing  association checks between the transferFrom and\ntransferTo processes.\n\nFlag: EXEMPT security fix\nBug: 364037868\nTest: presubmit\nChange-Id: I2654ccab807a62a341c8af69bf64bb33e56c4252\n---\n .../android/server/wm/EmbeddedWindowController.java  | 12 ++++++++++--\n .../com/android/server/wm/WindowManagerService.java  |  9 +++++++--\n 2 files changed, 17 insertions(+), 4 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/wm/EmbeddedWindowController.java b/services/core/java/com/android/server/wm/EmbeddedWindowController.java\nindex 5514294ed477..e007b1d07b34 100644\n--- a/services/core/java/com/android/server/wm/EmbeddedWindowController.java\n+++ b/services/core/java/com/android/server/wm/EmbeddedWindowController.java\n@@ -181,22 +181,30 @@ class EmbeddedWindowController {\n         return true;\n     }\n \n-    boolean transferToHost(@NonNull InputTransferToken embeddedWindowToken,\n+    boolean transferToHost(int callingUid, @NonNull InputTransferToken embeddedWindowToken,\n             @NonNull WindowState transferToHostWindowState) {\n         EmbeddedWindow ew = getByInputTransferToken(embeddedWindowToken);\n         if (!isValidTouchGestureParams(transferToHostWindowState, ew)) {\n             return false;\n         }\n+        if (callingUid != ew.mOwnerUid) {\n+            throw new SecurityException(\n+                    \"Transfer request must originate from owner of transferFromToken\");\n+        }\n         return mInputManagerService.transferTouchGesture(ew.getInputChannelToken(),\n                 transferToHostWindowState.mInputChannelToken);\n     }\n \n-    boolean transferToEmbedded(WindowState hostWindowState,\n+    boolean transferToEmbedded(int callingUid, WindowState hostWindowState,\n             @NonNull InputTransferToken transferToToken) {\n         final EmbeddedWindowController.EmbeddedWindow ew = getByInputTransferToken(transferToToken);\n         if (!isValidTouchGestureParams(hostWindowState, ew)) {\n             return false;\n         }\n+        if (callingUid != hostWindowState.mOwnerUid) {\n+            throw new SecurityException(\n+                    \"Transfer request must originate from owner of transferFromToken\");\n+        }\n         return mInputManagerService.transferTouchGesture(hostWindowState.mInputChannelToken,\n                 ew.getInputChannelToken());\n     }\ndiff --git a/services/core/java/com/android/server/wm/WindowManagerService.java b/services/core/java/com/android/server/wm/WindowManagerService.java\nindex 33f2dd103c2e..b8f47cce6005 100644\n--- a/services/core/java/com/android/server/wm/WindowManagerService.java\n+++ b/services/core/java/com/android/server/wm/WindowManagerService.java\n@@ -9212,6 +9212,8 @@ public class WindowManagerService extends IWindowManager.Stub\n         final InputApplicationHandle applicationHandle;\n         final String name;\n         Objects.requireNonNull(outInputChannel);\n+        Objects.requireNonNull(inputTransferToken);\n+\n         synchronized (mGlobalLock) {\n             WindowState hostWindowState = hostInputTransferToken != null\n                     ? mInputToWindowMap.get(hostInputTransferToken.getToken()) : null;\n@@ -9236,6 +9238,7 @@ public class WindowManagerService extends IWindowManager.Stub\n         Objects.requireNonNull(transferFromToken);\n         Objects.requireNonNull(transferToToken);\n \n+        final int callingUid = Binder.getCallingUid();\n         final long identity = Binder.clearCallingIdentity();\n         boolean didTransfer;\n         try {\n@@ -9245,12 +9248,14 @@ public class WindowManagerService extends IWindowManager.Stub\n                 // represents an embedded window so transfer from host to embedded.\n                 WindowState windowStateTo = mInputToWindowMap.get(transferToToken.getToken());\n                 if (windowStateTo != null) {\n-                    didTransfer = mEmbeddedWindowController.transferToHost(transferFromToken,\n+                    didTransfer = mEmbeddedWindowController.transferToHost(callingUid,\n+                            transferFromToken,\n                             windowStateTo);\n                 } else {\n                     WindowState windowStateFrom = mInputToWindowMap.get(\n                             transferFromToken.getToken());\n-                    didTransfer = mEmbeddedWindowController.transferToEmbedded(windowStateFrom,\n+                    didTransfer = mEmbeddedWindowController.transferToEmbedded(callingUid,\n+                            windowStateFrom,\n                             transferToToken);\n                 }\n             }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "4089c359361d8703bab3be0ab0a29723db76b356"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-364026473",
            "aliases": [
                "A-364026473",
                "CVE-2024-43770"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-364026473",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "7de5617f7d5266fe57c990c428621b5d4e92728a"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 7de5617f7d5266fe57c990c428621b5d4e92728a Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Thu, 12 Sep 2024 17:26:55 +0000\nSubject: [PATCH] Fix OOB writes in gatt_sr.cc\n\nAt various points in gatt_sr.cc, the output of the\ngatt_tcb_get_payload_size function is used without checking for a\npositive length.  However, in exceptional cases it is possible for the\nchannel to be closed at the time the function is called, which will lead\nto a zero length and cause an OOB write in subsequent processing.\n\nFix all of these.\n\nBug: 364026473\nBug: 364027038\nBug: 364027949\nBug: 364025411\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial validity checks\nTag: #security\nIgnore-AOSP-First: Security\nChange-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n---\n system/stack/gatt/gatt_sr.cc | 21 +++++++++++++++++++++\n 1 file changed, 21 insertions(+)\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 995ea810cb..0235ba964e 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n@@ -949,6 +960,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid, uint8_t\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1096,6 +1112,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12-release: Command '['git', 'checkout', 'android12-release']' returned non-zero exit status 1.",
                            "downstream_patch": "7e5f45df8880293e1ab40367670d1a8959a542f9"
                        },
                        {
                            "downstream_version": "12L",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12L-release: Command '['git', 'checkout', 'android12L-release']' returned non-zero exit status 1.",
                            "downstream_patch": "7e5f45df8880293e1ab40367670d1a8959a542f9"
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "84ea459acaf3c6e7215e044e59dc3e9187f1f7b8"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "2fc3087b9ac3019518c6ceb8a64d181d6bb04907",
                            "result": "failure",
                            "downstream_patch_content": "commit 2fc3087b9ac3019518c6ceb8a64d181d6bb04907\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 4 18:23:45 2024 +0000\n\n    Fix OOB writes in gatt_sr.cc\n    \n    At various points in gatt_sr.cc, the output of the\n    gatt_tcb_get_payload_size function is used without checking for a\n    positive length.  However, in exceptional cases it is possible for the\n    channel to be closed at the time the function is called, which will lead\n    to a zero length and cause an OOB write in subsequent processing.\n    \n    Fix all of these.\n    \n    Bug: 364026473\n    Bug: 364027038\n    Bug: 364027949\n    Bug: 364025411\n    Test: m libbluetooth\n    Test: researcher POC\n    Flag: EXEMPT trivial validity checks\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n    Change-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n",
                            "file_conflicts": [
                                {
                                    "file_name": "system/stack/gatt/gatt_sr.cc",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n=======\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n=======\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 3,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 4,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- system/stack/gatt/gatt_sr.cc\n+++ system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
                                    "patch_apply_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 FAILED at 772.\nHunk #2 FAILED at 804.\nHunk #3 succeeded at 886 with fuzz 2 (offset -63 lines).\nHunk #4 succeeded at 1038 with fuzz 2 (offset -63 lines).\n2 out of 4 hunks FAILED -- saving rejects to file system/stack/gatt/gatt_sr.cc.rej",
                                    "inline_merge_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 NOT MERGED at 889-898.\nHunk #2 NOT MERGED at 900-913.\nHunk #3 NOT MERGED at 1074-1083.\nHunk #4 NOT MERGED at 1128-1140."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "2fc3087b9ac3019518c6ceb8a64d181d6bb04907",
                            "result": "failure",
                            "downstream_patch_content": "commit 2fc3087b9ac3019518c6ceb8a64d181d6bb04907\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 4 18:23:45 2024 +0000\n\n    Fix OOB writes in gatt_sr.cc\n    \n    At various points in gatt_sr.cc, the output of the\n    gatt_tcb_get_payload_size function is used without checking for a\n    positive length.  However, in exceptional cases it is possible for the\n    channel to be closed at the time the function is called, which will lead\n    to a zero length and cause an OOB write in subsequent processing.\n    \n    Fix all of these.\n    \n    Bug: 364026473\n    Bug: 364027038\n    Bug: 364027949\n    Bug: 364025411\n    Test: m libbluetooth\n    Test: researcher POC\n    Flag: EXEMPT trivial validity checks\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n    Change-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n",
                            "file_conflicts": [
                                {
                                    "file_name": "system/stack/gatt/gatt_sr.cc",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n=======\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n=======\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 3,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 4,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- system/stack/gatt/gatt_sr.cc\n+++ system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
                                    "patch_apply_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 FAILED at 772.\nHunk #2 FAILED at 804.\nHunk #3 succeeded at 902 with fuzz 2 (offset -47 lines).\nHunk #4 succeeded at 1054 with fuzz 2 (offset -47 lines).\n2 out of 4 hunks FAILED -- saving rejects to file system/stack/gatt/gatt_sr.cc.rej",
                                    "inline_merge_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 NOT MERGED at 905-914.\nHunk #2 NOT MERGED at 916-929.\nHunk #3 NOT MERGED at 1089-1098.\nHunk #4 NOT MERGED at 1127-1139."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-375407167",
            "aliases": [
                "A-375407167",
                "CVE-2025-0075"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375407167",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "d62bf15de2fb8161bab7067f6e8704452bd52460"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From d62bf15de2fb8161bab7067f6e8704452bd52460 Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Thu, 31 Oct 2024 00:05:16 +0000\nSubject: [PATCH] Fix incorrect logging in sdp_server\n\nIn the function process_service_search_attr_req of sdp_server.cc, a log\nstatement uses a structure that may, in exceptional cases, have been\nfreed by preceding calls.  This can lead to use after free and\npotentially to security vulnerabilities.\n\nUse local variables instead.\n\nBug: 375407167\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: I04a295f3c451267aaad0f0d22401b9f5b5510d83\n---\n system/stack/sdp/sdp_server.cc | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/system/stack/sdp/sdp_server.cc b/system/stack/sdp/sdp_server.cc\nindex 58a17727cf..0ebe890dd6 100644\n--- a/system/stack/sdp/sdp_server.cc\n+++ b/system/stack/sdp/sdp_server.cc\n@@ -924,7 +924,7 @@ static void process_service_search_attr_req(tCONN_CB* p_ccb, uint16_t trans_num,\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "f23300552c43a4f503debcf0236f29211ee1c557"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-347735428",
            "aliases": [
                "A-347735428",
                "CVE-2025-0081"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-347735428",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "a22d1f0f07d998a53dd49a941d3a588f55b36399"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From a22d1f0f07d998a53dd49a941d3a588f55b36399 Mon Sep 17 00:00:00 2001\nFrom: Nick Chusid <nchusid@google.com>\nDate: Tue, 10 Dec 2024 22:46:28 +0000\nSubject: [PATCH] Catch null HuffmanTables when decoding jpeg\n\nBug: 347735428\nTest: TreeHugger\nChange-Id: Iaf36c076467d18e4e31d8436a6d199c3276a8786\n---\n source/dng_lossless_jpeg.cpp | 4 ++++\n 1 file changed, 4 insertions(+)\n\ndiff --git a/source/dng_lossless_jpeg.cpp b/source/dng_lossless_jpeg.cpp\nindex 9d0d01a..8802f32 100644\n--- a/source/dng_lossless_jpeg.cpp\n+++ b/source/dng_lossless_jpeg.cpp\n@@ -1616,6 +1616,10 @@ inline int32 dng_lossless_decoder::get_bit ()\n inline int32 dng_lossless_decoder::HuffDecode (HuffmanTable *htbl)\n \t{\n \t\n+\tif (htbl == nullptr) {\n+\t\tThrowBadFormat ();\n+\t}\n+\n     // If the huffman code is less than 8 bits, we can use the fast\n     // table lookup to get its value.  It's more than 8 bits about\n     // 3-4% of the time.\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "ef6549c8eb3b202e8b47c41ba39d7957274aa12b",
                            "result": "success",
                            "downstream_patch_content": "commit ef6549c8eb3b202e8b47c41ba39d7957274aa12b\nAuthor: Nick Chusid <nchusid@google.com>\nDate:   Tue Dec 10 22:46:28 2024 +0000\n\n    Catch null HuffmanTables when decoding jpeg\n    \n    Bug: 347735428\n    Test: TreeHugger\n    Change-Id: Iaf36c076467d18e4e31d8436a6d199c3276a8786\n\ndiff --git a/source/dng_lossless_jpeg.cpp b/source/dng_lossless_jpeg.cpp\nindex 9d0d01a..8802f32 100644\n--- a/source/dng_lossless_jpeg.cpp\n+++ b/source/dng_lossless_jpeg.cpp\n@@ -1616,6 +1616,10 @@ inline int32 dng_lossless_decoder::get_bit ()\n inline int32 dng_lossless_decoder::HuffDecode (HuffmanTable *htbl)\n \t{\n \t\n+\tif (htbl == nullptr) {\n+\t\tThrowBadFormat ();\n+\t}\n+\n     // If the huffman code is less than 8 bits, we can use the fast\n     // table lookup to get its value.  It's more than 8 bits about\n     // 3-4% of the time.\n"
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "97cbb86f575c92ccd097407bb1fe5ad9bb532944",
                            "result": "success",
                            "downstream_patch_content": "commit 97cbb86f575c92ccd097407bb1fe5ad9bb532944\nAuthor: Nick Chusid <nchusid@google.com>\nDate:   Tue Dec 10 22:46:28 2024 +0000\n\n    Catch null HuffmanTables when decoding jpeg\n    \n    Bug: 347735428\n    Test: TreeHugger\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:a22d1f0f07d998a53dd49a941d3a588f55b36399)\n    Merged-In: Iaf36c076467d18e4e31d8436a6d199c3276a8786\n    Change-Id: Iaf36c076467d18e4e31d8436a6d199c3276a8786\n\ndiff --git a/source/dng_lossless_jpeg.cpp b/source/dng_lossless_jpeg.cpp\nindex 9d0d01a..8802f32 100644\n--- a/source/dng_lossless_jpeg.cpp\n+++ b/source/dng_lossless_jpeg.cpp\n@@ -1616,6 +1616,10 @@ inline int32 dng_lossless_decoder::get_bit ()\n inline int32 dng_lossless_decoder::HuffDecode (HuffmanTable *htbl)\n \t{\n \t\n+\tif (htbl == nullptr) {\n+\t\tThrowBadFormat ();\n+\t}\n+\n     // If the huffman code is less than 8 bits, we can use the fast\n     // table lookup to get its value.  It's more than 8 bits about\n     // 3-4% of the time.\n"
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "6fd49d6ecdf53aa96b290ee5b3e30a7d73c71679"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "d125388473163ed70452c6e615b3c788805e0168",
                            "result": "success",
                            "downstream_patch_content": "commit d125388473163ed70452c6e615b3c788805e0168\nAuthor: Nick Chusid <nchusid@google.com>\nDate:   Tue Dec 10 22:46:28 2024 +0000\n\n    Catch null HuffmanTables when decoding jpeg\n    \n    Bug: 347735428\n    Test: TreeHugger\n    Change-Id: Iaf36c076467d18e4e31d8436a6d199c3276a8786\n\ndiff --git a/source/dng_lossless_jpeg.cpp b/source/dng_lossless_jpeg.cpp\nindex 9d0d01a..8802f32 100644\n--- a/source/dng_lossless_jpeg.cpp\n+++ b/source/dng_lossless_jpeg.cpp\n@@ -1616,6 +1616,10 @@ inline int32 dng_lossless_decoder::get_bit ()\n inline int32 dng_lossless_decoder::HuffDecode (HuffmanTable *htbl)\n \t{\n \t\n+\tif (htbl == nullptr) {\n+\t\tThrowBadFormat ();\n+\t}\n+\n     // If the huffman code is less than 8 bits, we can use the fast\n     // table lookup to get its value.  It's more than 8 bits about\n     // 3-4% of the time.\n"
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "89f7028f91aa2979fa88f51cdd37b6444b5cd9d9",
                            "result": "success",
                            "downstream_patch_content": "commit 89f7028f91aa2979fa88f51cdd37b6444b5cd9d9\nAuthor: Nick Chusid <nchusid@google.com>\nDate:   Tue Dec 10 22:46:28 2024 +0000\n\n    Catch null HuffmanTables when decoding jpeg\n    \n    Bug: 347735428\n    Test: TreeHugger\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:a22d1f0f07d998a53dd49a941d3a588f55b36399)\n    Merged-In: Iaf36c076467d18e4e31d8436a6d199c3276a8786\n    Change-Id: Iaf36c076467d18e4e31d8436a6d199c3276a8786\n\ndiff --git a/source/dng_lossless_jpeg.cpp b/source/dng_lossless_jpeg.cpp\nindex 9d0d01a..8802f32 100644\n--- a/source/dng_lossless_jpeg.cpp\n+++ b/source/dng_lossless_jpeg.cpp\n@@ -1616,6 +1616,10 @@ inline int32 dng_lossless_decoder::get_bit ()\n inline int32 dng_lossless_decoder::HuffDecode (HuffmanTable *htbl)\n \t{\n \t\n+\tif (htbl == nullptr) {\n+\t\tThrowBadFormat ();\n+\t}\n+\n     // If the huffman code is less than 8 bits, we can use the fast\n     // table lookup to get its value.  It's more than 8 bits about\n     // 3-4% of the time.\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-375623125",
            "aliases": [
                "A-375623125",
                "CVE-2025-22431"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375623125",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "790b7c82c0169752311dbd213f4669e05714fada"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 790b7c82c0169752311dbd213f4669e05714fada Mon Sep 17 00:00:00 2001\nFrom: Nate Myren <ntmyren@google.com>\nDate: Thu, 9 Jan 2025 10:09:56 -0800\nSubject: [PATCH] Do not allow non-system apps to provide unverified\n attributions\n\nSome apps (the shell, system server, etc) are exempt from the\nrequirement that attribution tags be registered. However, in the proxy\ncase, the tag provied by the proxy app is trusted if the proxied app is\none of these exemptions. We should only trust these tags if the proxy\napp is a system app.\n\nThis CL also adds a second restriction check when a restriction is\nremoved, to verify that an op is free of all restrictions, before\nresuming a started op\n\nBug: 375623125\nTest: upcoming\nFlag: EXEMPT: See bug\nChange-Id: I6a7b0a24359097c0ea2f52cc69637d929a931b4f\n---\n .../android/server/appop/AppOpsService.java   | 89 ++++++++++++-------\n 1 file changed, 57 insertions(+), 32 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/appop/AppOpsService.java b/services/core/java/com/android/server/appop/AppOpsService.java\nindex d2073aaa834c..d3a5cc4d4b07 100644\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -603,7 +603,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    /** Returned from {@link #verifyAndGetBypass(int, String, String, String, boolean)}. */\n+    /** Returned from {@link #verifyAndGetBypass(int, String, String, int, String, boolean)}. */\n     private static final class PackageVerificationResult {\n \n         final RestrictionBypass bypass;\n@@ -3086,10 +3086,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n     public int checkPackage(int uid, String packageName) {\n         Objects.requireNonNull(packageName);\n         try {\n-            verifyAndGetBypass(uid, packageName, null, null, true);\n+            verifyAndGetBypass(uid, packageName, null, Process.INVALID_UID, null, true);\n             // When the caller is the system, it's possible that the packageName is the special\n             // one (e.g., \"root\") which isn't actually existed.\n-            if (resolveUid(packageName) == uid\n+            if (resolveNonAppUid(packageName) == uid\n                     || (isPackageExisted(packageName)\n                             && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(uid)))) {\n                 return AppOpsManager.MODE_ALLOWED;\n@@ -3300,7 +3300,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             boolean shouldCollectMessage, int notedCount) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n@@ -3896,7 +3896,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             // Test if the proxied operation will succeed before starting the proxy operation\n             final SyncNotedAppOp testProxiedOp = startOperationDryRun(code,\n                     proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag,\n-                    proxiedVirtualDeviceId, resolvedProxyPackageName, proxiedFlags,\n+                    proxiedVirtualDeviceId, proxyUid, resolvedProxyPackageName, proxiedFlags,\n                     startIfModeDefault);\n \n             if (!shouldStartForMode(testProxiedOp.getOpMode(), startIfModeDefault)) {\n@@ -3936,7 +3936,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             int attributionChainId) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n@@ -4063,11 +4063,11 @@ public class AppOpsService extends IAppOpsService.Stub {\n      */\n     private SyncNotedAppOp startOperationDryRun(int code, int uid,\n             @NonNull String packageName, @Nullable String attributionTag, int virtualDeviceId,\n-            String proxyPackageName, @OpFlags int flags,\n+            int proxyUid, String proxyPackageName, @OpFlags int flags,\n             boolean startIfModeDefault) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n@@ -4622,13 +4622,17 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private boolean isSpecialPackage(int callingUid, @Nullable String packageName) {\n         final String resolvedPackage = AppOpsManager.resolvePackageName(callingUid, packageName);\n         return callingUid == Process.SYSTEM_UID\n-                || resolveUid(resolvedPackage) != Process.INVALID_UID;\n+                || resolveNonAppUid(resolvedPackage) != Process.INVALID_UID;\n     }\n \n     private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n         if (attributionSource.getUid() != Binder.getCallingUid()\n                 && attributionSource.isTrusted(mContext)) {\n-            return true;\n+            // if there is a next attribution source, it must be trusted, as well.\n+            if (attributionSource.getNext() == null\n+                    || attributionSource.getNext().isTrusted(mContext)) {\n+                return true;\n+            }\n         }\n         return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                 Binder.getCallingPid(), Binder.getCallingUid(), null)\n@@ -4723,19 +4727,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n             @Nullable String attributionTag) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, null);\n+        return verifyAndGetBypass(uid, packageName, attributionTag, Process.INVALID_UID, null);\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName, false);\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName) {\n+        return verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName,\n+                false);\n     }\n \n     /**\n@@ -4746,14 +4751,15 @@ public class AppOpsService extends IAppOpsService.Stub {\n      * @param uid The uid the package belongs to\n      * @param packageName The package the might belong to the uid\n      * @param attributionTag attribution tag or {@code null} if no need to verify\n-     * @param proxyPackageName The proxy package, from which the attribution tag is to be pulled\n+     * @param proxyUid The proxy uid, from which the attribution tag is to be pulled\n+     * @param proxyPackageName The proxy package, from which the attribution tag may be pulled\n      * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n      *\n      * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n      *         attribution tag is valid\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName,\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName,\n             boolean suppressErrorLogs) {\n         if (uid == Process.ROOT_UID) {\n             // For backwards compatibility, don't check package name for root UID.\n@@ -4797,34 +4803,47 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         int callingUid = Binder.getCallingUid();\n \n-        // Allow any attribution tag for resolvable uids\n-        int pkgUid;\n+        // Allow any attribution tag for resolvable, non-app uids\n+        int nonAppUid;\n         if (Objects.equals(packageName, \"com.android.shell\")) {\n             // Special case for the shell which is a package but should be able\n             // to bypass app attribution tag restrictions.\n-            pkgUid = Process.SHELL_UID;\n+            nonAppUid = Process.SHELL_UID;\n         } else {\n-            pkgUid = resolveUid(packageName);\n+            nonAppUid = resolveNonAppUid(packageName);\n         }\n-        if (pkgUid != Process.INVALID_UID) {\n-            if (pkgUid != UserHandle.getAppId(uid)) {\n+        if (nonAppUid != Process.INVALID_UID) {\n+            if (nonAppUid != UserHandle.getAppId(uid)) {\n                 if (!suppressErrorLogs) {\n                     Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n-                            + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n-                            + \".\");\n+                                + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n+                                + \".\");\n+                }\n+                String otherUidMessage =\n+                            DEBUG ? \" but it is really \" + nonAppUid : \" but it is not\";\n+                throw new SecurityException(\"Specified package \\\"\" + packageName\n+                            + \"\\\" under uid \" +  UserHandle.getAppId(uid) + otherUidMessage);\n+            }\n+            // We only allow bypassing the attribution tag verification if the proxy is a\n+            // system app (or is null), in order to prevent abusive apps clogging the appops\n+            // system with unlimited attribution tags via proxy calls.\n+            boolean proxyIsSystemAppOrNull = true;\n+            if (proxyPackageName != null) {\n+                int proxyAppId = UserHandle.getAppId(proxyUid);\n+                if (proxyAppId >= Process.FIRST_APPLICATION_UID) {\n+                    proxyIsSystemAppOrNull =\n+                            mPackageManagerInternal.isSystemPackage(proxyPackageName);\n                 }\n-                String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n-                throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \"\n-                        +  UserHandle.getAppId(uid) + otherUidMessage);\n             }\n             return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n-                    /* isAttributionTagValid */ true);\n+                    /* isAttributionTagValid */ proxyIsSystemAppOrNull);\n         }\n \n         int userId = UserHandle.getUserId(uid);\n         RestrictionBypass bypass = null;\n         boolean isAttributionTagValid = false;\n \n+        int pkgUid = nonAppUid;\n         final long ident = Binder.clearCallingIdentity();\n         try {\n             PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n@@ -5615,7 +5634,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             if (nonpackageUid != -1) {\n                 packageName = null;\n             } else {\n-                packageUid = resolveUid(packageName);\n+                packageUid = resolveNonAppUid(packageName);\n                 if (packageUid < 0) {\n                     packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                             PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n@@ -6715,7 +6734,13 @@ public class AppOpsService extends IAppOpsService.Stub {\n                 if (restricted && attrOp.isRunning()) {\n                     attrOp.pause();\n                 } else if (attrOp.isPaused()) {\n-                    attrOp.resume();\n+                    RestrictionBypass bypass = verifyAndGetBypass(uid, ops.packageName, attrOp.tag)\n+                            .bypass;\n+                    if (!isOpRestrictedLocked(uid, code, ops.packageName, attrOp.tag,\n+                            Context.DEVICE_ID_DEFAULT, bypass, false)) {\n+                        // Only resume if there are no other restrictions remaining on this op\n+                        attrOp.resume();\n+                    }\n                 }\n             }\n         }\n@@ -7164,7 +7189,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    private static int resolveUid(String packageName)  {\n+    private static int resolveNonAppUid(String packageName)  {\n         if (packageName == null) {\n             return Process.INVALID_UID;\n         }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "9dd915f74a88459fab5dc0b6518708b0d3df66e5"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "b645679d1d40d05944527eee4b5fe5cae0c3fc18",
                            "result": "failure",
                            "downstream_patch_content": "commit b645679d1d40d05944527eee4b5fe5cae0c3fc18\nAuthor: Nate Myren <ntmyren@google.com>\nDate:   Thu Jan 9 10:09:56 2025 -0800\n\n    Do not allow non-system apps to provide unverified attributions\n    \n    Some apps (the shell, system server, etc) are exempt from the\n    requirement that attribution tags be registered. However, in the proxy\n    case, the tag provied by the proxy app is trusted if the proxied app is\n    one of these exemptions. We should only trust these tags if the proxy\n    app is a system app.\n    \n    This CL also adds a second restriction check when a restriction is\n    removed, to verify that an op is free of all restrictions, before\n    resuming a started op\n    \n    Bug: 375623125\n    Test: upcoming\n    Flag: EXEMPT: See bug\n    Merged-In: I6a7b0a24359097c0ea2f52cc69637d929a931b4f\n    Change-Id: I6a7b0a24359097c0ea2f52cc69637d929a931b4f\n\ndiff --git a/services/core/java/com/android/server/appop/AppOpsService.java b/services/core/java/com/android/server/appop/AppOpsService.java\nindex b891aeeb527d..2e48b24eb25c 100644\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -699,7 +699,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    /** Returned from {@link #verifyAndGetBypass(int, String, String, String, boolean)}. */\n+    /** Returned from {@link #verifyAndGetBypass(int, String, String, int, String, boolean)}. */\n     private static final class PackageVerificationResult {\n \n         final RestrictionBypass bypass;\n@@ -3336,7 +3336,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             verifyAndGetBypass(uid, packageName, null);\n             // When the caller is the system, it's possible that the packageName is the special\n             // one (e.g., \"root\") which isn't actually existed.\n-            if (resolveUid(packageName) == uid\n+            if (resolveNonAppUid(packageName) == uid\n                     || (isPackageExisted(packageName) && !filterAppAccessUnlocked(packageName))) {\n                 return AppOpsManager.MODE_ALLOWED;\n             }\n@@ -3460,7 +3460,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             boolean shouldCollectMessage) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             boolean wasNull = attributionTag == null;\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n@@ -3979,7 +3979,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             int attributionChainId, boolean dryRun) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n@@ -4442,7 +4442,11 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n         if (attributionSource.getUid() != Binder.getCallingUid()\n                 && attributionSource.isTrusted(mContext)) {\n-            return true;\n+            // if there is a next attribution source, it must be trusted, as well.\n+            if (attributionSource.getNext() == null\n+                    || attributionSource.getNext().isTrusted(mContext)) {\n+                return true;\n+            }\n         }\n         return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                 Binder.getCallingPid(), Binder.getCallingUid(), null)\n@@ -4580,11 +4584,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n             @Nullable String attributionTag) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, null);\n+        return verifyAndGetBypass(uid, packageName, attributionTag, Process.INVALID_UID, null);\n+    }\n+\n+    /**\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n+     */\n+    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName) {\n+        return verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName,\n+                false);\n     }\n \n     /**\n@@ -4595,13 +4608,16 @@ public class AppOpsService extends IAppOpsService.Stub {\n      * @param uid The uid the package belongs to\n      * @param packageName The package the might belong to the uid\n      * @param attributionTag attribution tag or {@code null} if no need to verify\n-     * @param proxyPackageName The proxy package, from which the attribution tag is to be pulled\n+     * @param proxyUid The proxy uid, from which the attribution tag is to be pulled\n+     * @param proxyPackageName The proxy package, from which the attribution tag may be pulled\n+     * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n      *\n      * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n      *         attribution tag is valid\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName,\n+            boolean suppressErrorLogs) {\n         if (uid == Process.ROOT_UID) {\n             // For backwards compatibility, don't check package name for root UID.\n             return new PackageVerificationResult(null,\n@@ -4645,31 +4661,47 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         int callingUid = Binder.getCallingUid();\n \n-        // Allow any attribution tag for resolvable uids\n-        int pkgUid;\n+        // Allow any attribution tag for resolvable, non-app uids\n+        int nonAppUid;\n         if (Objects.equals(packageName, \"com.android.shell\")) {\n             // Special case for the shell which is a package but should be able\n             // to bypass app attribution tag restrictions.\n-            pkgUid = Process.SHELL_UID;\n+            nonAppUid = Process.SHELL_UID;\n         } else {\n-            pkgUid = resolveUid(packageName);\n-        }\n-        if (pkgUid != Process.INVALID_UID) {\n-            if (pkgUid != UserHandle.getAppId(uid)) {\n-                Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n-                        + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid + \".\");\n-                String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n-                throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \"\n-                        +  UserHandle.getAppId(uid) + otherUidMessage);\n+            nonAppUid = resolveNonAppUid(packageName);\n+        }\n+        if (nonAppUid != Process.INVALID_UID) {\n+            if (nonAppUid != UserHandle.getAppId(uid)) {\n+                if (!suppressErrorLogs) {\n+                    Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n+                                + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n+                                + \".\");\n+                }\n+                String otherUidMessage =\n+                            DEBUG ? \" but it is really \" + nonAppUid : \" but it is not\";\n+                throw new SecurityException(\"Specified package \\\"\" + packageName\n+                            + \"\\\" under uid \" +  UserHandle.getAppId(uid) + otherUidMessage);\n+            }\n+            // We only allow bypassing the attribution tag verification if the proxy is a\n+            // system app (or is null), in order to prevent abusive apps clogging the appops\n+            // system with unlimited attribution tags via proxy calls.\n+            boolean proxyIsSystemAppOrNull = true;\n+            if (proxyPackageName != null) {\n+                int proxyAppId = UserHandle.getAppId(proxyUid);\n+                if (proxyAppId >= Process.FIRST_APPLICATION_UID) {\n+                    proxyIsSystemAppOrNull =\n+                            mPackageManagerInternal.isSystemPackage(proxyPackageName);\n+                }\n             }\n             return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n-                    /* isAttributionTagValid */ true);\n+                    /* isAttributionTagValid */ proxyIsSystemAppOrNull);\n         }\n \n         int userId = UserHandle.getUserId(uid);\n         RestrictionBypass bypass = null;\n         boolean isAttributionTagValid = false;\n \n+        int pkgUid = nonAppUid;\n         final long ident = Binder.clearCallingIdentity();\n         try {\n             PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n@@ -5536,7 +5568,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             if (nonpackageUid != -1) {\n                 packageName = null;\n             } else {\n-                packageUid = resolveUid(packageName);\n+                packageUid = resolveNonAppUid(packageName);\n                 if (packageUid < 0) {\n                     packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                             PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n@@ -6720,7 +6752,13 @@ public class AppOpsService extends IAppOpsService.Stub {\n                 if (restricted && attrOp.isRunning()) {\n                     attrOp.pause();\n                 } else if (attrOp.isPaused()) {\n-                    attrOp.resume();\n+                    RestrictionBypass bypass = verifyAndGetBypass(uid, ops.packageName, attrOp.tag)\n+                            .bypass;\n+                    if (!isOpRestrictedLocked(uid, code, ops.packageName, attrOp.tag,\n+                            bypass, false)) {\n+                        // Only resume if there are no other restrictions remaining on this op\n+                        attrOp.resume();\n+                    }\n                 }\n             }\n         }\n@@ -7165,7 +7203,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    private static int resolveUid(String packageName)  {\n+    private static int resolveNonAppUid(String packageName)  {\n         if (packageName == null) {\n             return -1;\n         }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
                                    "total_hunks": 13,
                                    "failed_hunks": [
                                        2,
                                        4,
                                        5,
                                        6,
                                        7,
                                        8,
                                        9,
                                        10
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n            verifyAndGetBypass(uid, packageName, null);\n=======\n            verifyAndGetBypass(uid, packageName, null, Process.INVALID_UID, null, true);\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n            if (resolveUid(packageName) == uid\n                    || (isPackageExisted(packageName) && !filterAppAccessUnlocked(packageName))) {\n=======\n            if (resolveNonAppUid(packageName) == uid\n                    || (isPackageExisted(packageName)\n                            && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(uid)))) {\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        },
                                        {
                                            "hunk_number": 3,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n            boolean wasNull = attributionTag == null;\n=======\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        },
                                        {
                                            "hunk_number": 4,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n        }\n=======\n            // Test if the proxied operation will succeed before starting the proxy operation\n            final SyncNotedAppOp testProxiedOp = startOperationDryRun(code,\n                    proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag,\n                    proxiedVirtualDeviceId, proxyUid, resolvedProxyPackageName, proxiedFlags,\n                    startIfModeDefault);\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        },
                                        {
                                            "hunk_number": 5,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag);\n=======\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        },
                                        {
                                            "hunk_number": 6,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n        static NoteOpTrace fromJson(String jsonTrace) {\n=======\n    private SyncNotedAppOp startOperationDryRun(int code, int uid,\n            @NonNull String packageName, @Nullable String attributionTag, int virtualDeviceId,\n            int proxyUid, String proxyPackageName, @OpFlags int flags,\n            boolean startIfModeDefault) {\n        PackageVerificationResult pvr;\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        },
                                        {
                                            "hunk_number": 7,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        },
                                        {
                                            "hunk_number": 8,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n                // Re-add closing bracket which acted as a delimiter by the reader\n                JSONObject obj = new JSONObject(jsonTrace.concat(\"}\"));\n                return new NoteOpTrace(obj.getString(STACKTRACE), obj.getInt(OP),\n                        obj.getString(PACKAGENAME), obj.getLong(VERSION));\n=======\n    private boolean isSpecialPackage(int callingUid, @Nullable String packageName) {\n        final String resolvedPackage = AppOpsManager.resolvePackageName(callingUid, packageName);\n        return callingUid == Process.SYSTEM_UID\n                || resolveNonAppUid(resolvedPackage) != Process.INVALID_UID;\n    }\n\n    private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n        if (attributionSource.getUid() != Binder.getCallingUid()\n                && attributionSource.isTrusted(mContext)) {\n            // if there is a next attribution source, it must be trusted, as well.\n            if (attributionSource.getNext() == null\n                    || attributionSource.getNext().isTrusted(mContext)) {\n                return true;\n            }\n        }\n        return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null)\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        },
                                        {
                                            "hunk_number": 9,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n            } catch (JSONException e) {\n                // Swallow error, only meant for logging ops, should not affect flow of the code\n                Slog.e(TAG, \"Error constructing NoteOpTrace object \"\n                        + \"JSON trace format incorrect\", e);\n                return null;\n=======\n    }\n\n    /**\n     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag) {\n        return verifyAndGetBypass(uid, packageName, attributionTag, Process.INVALID_UID, null);\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        },
                                        {
                                            "hunk_number": 10,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n\n    /**\n     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName) {\n        return verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName,\n                false);\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        },
                                        {
                                            "hunk_number": 11,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n        NoteOpTrace(String stackTrace, int op, String packageName, long version) {\n            mStackTrace = stackTrace;\n            mOp = op;\n            mPackageName = packageName;\n=======\n     * @param uid The uid the package belongs to\n     * @param packageName The package the might belong to the uid\n     * @param attributionTag attribution tag or {@code null} if no need to verify\n     * @param proxyUid The proxy uid, from which the attribution tag is to be pulled\n     * @param proxyPackageName The proxy package, from which the attribution tag may be pulled\n     * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n     *\n     * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n     *         attribution tag is valid\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName,\n            boolean suppressErrorLogs) {\n        if (uid == Process.ROOT_UID) {\n            // For backwards compatibility, don't check package name for root UID.\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        },
                                        {
                                            "hunk_number": 12,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n            mVersion = version;\n=======\n\n        int callingUid = Binder.getCallingUid();\n\n        // Allow any attribution tag for resolvable, non-app uids\n        int nonAppUid;\n        if (Objects.equals(packageName, \"com.android.shell\")) {\n            // Special case for the shell which is a package but should be able\n            // to bypass app attribution tag restrictions.\n            nonAppUid = Process.SHELL_UID;\n        } else {\n            nonAppUid = resolveNonAppUid(packageName);\n        }\n        if (nonAppUid != Process.INVALID_UID) {\n            if (nonAppUid != UserHandle.getAppId(uid)) {\n                if (!suppressErrorLogs) {\n                    Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n                                + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n                                + \".\");\n                }\n                String otherUidMessage =\n                            DEBUG ? \" but it is really \" + nonAppUid : \" but it is not\";\n                throw new SecurityException(\"Specified package \\\"\" + packageName\n                            + \"\\\" under uid \" +  UserHandle.getAppId(uid) + otherUidMessage);\n            }\n            // We only allow bypassing the attribution tag verification if the proxy is a\n            // system app (or is null), in order to prevent abusive apps clogging the appops\n            // system with unlimited attribution tags via proxy calls.\n            boolean proxyIsSystemAppOrNull = true;\n            if (proxyPackageName != null) {\n                int proxyAppId = UserHandle.getAppId(proxyUid);\n                if (proxyAppId >= Process.FIRST_APPLICATION_UID) {\n                    proxyIsSystemAppOrNull =\n                            mPackageManagerInternal.isSystemPackage(proxyPackageName);\n                }\n            }\n            return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n                    /* isAttributionTagValid */ proxyIsSystemAppOrNull);\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        },
                                        {
                                            "hunk_number": 13,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n        @Override\n        public int hashCode() {\n=======\n        int pkgUid = nonAppUid;\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        },
                                        {
                                            "hunk_number": 14,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n        /**\n         * The object is formatted as a JSON object and returned as a String\n=======\n    private static int resolveNonAppUid(String packageName)  {\n        if (packageName == null) {\n            return Process.INVALID_UID;\n        }\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/appop/AppOpsService.java\n+++ services/core/java/com/android/server/appop/AppOpsService.java\n@@ -3086,10 +3086,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n     public int checkPackage(int uid, String packageName) {\n         Objects.requireNonNull(packageName);\n         try {\n-            verifyAndGetBypass(uid, packageName, null, null, true);\n+            verifyAndGetBypass(uid, packageName, null, Process.INVALID_UID, null, true);\n             // When the caller is the system, it's possible that the packageName is the special\n             // one (e.g., \"root\") which isn't actually existed.\n-            if (resolveUid(packageName) == uid\n+            if (resolveNonAppUid(packageName) == uid\n                     || (isPackageExisted(packageName)\n                             && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(uid)))) {\n                 return AppOpsManager.MODE_ALLOWED;\n@@ -3896,7 +3896,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             // Test if the proxied operation will succeed before starting the proxy operation\n             final SyncNotedAppOp testProxiedOp = startOperationDryRun(code,\n                     proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag,\n-                    proxiedVirtualDeviceId, resolvedProxyPackageName, proxiedFlags,\n+                    proxiedVirtualDeviceId, proxyUid, resolvedProxyPackageName, proxiedFlags,\n                     startIfModeDefault);\n \n             if (!shouldStartForMode(testProxiedOp.getOpMode(), startIfModeDefault)) {\n@@ -3936,7 +3936,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             int attributionChainId) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n@@ -4063,11 +4063,11 @@ public class AppOpsService extends IAppOpsService.Stub {\n      */\n     private SyncNotedAppOp startOperationDryRun(int code, int uid,\n             @NonNull String packageName, @Nullable String attributionTag, int virtualDeviceId,\n-            String proxyPackageName, @OpFlags int flags,\n+            int proxyUid, String proxyPackageName, @OpFlags int flags,\n             boolean startIfModeDefault) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n@@ -4622,13 +4622,17 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private boolean isSpecialPackage(int callingUid, @Nullable String packageName) {\n         final String resolvedPackage = AppOpsManager.resolvePackageName(callingUid, packageName);\n         return callingUid == Process.SYSTEM_UID\n-                || resolveUid(resolvedPackage) != Process.INVALID_UID;\n+                || resolveNonAppUid(resolvedPackage) != Process.INVALID_UID;\n     }\n \n     private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n         if (attributionSource.getUid() != Binder.getCallingUid()\n                 && attributionSource.isTrusted(mContext)) {\n-            return true;\n+            // if there is a next attribution source, it must be trusted, as well.\n+            if (attributionSource.getNext() == null\n+                    || attributionSource.getNext().isTrusted(mContext)) {\n+                return true;\n+            }\n         }\n         return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                 Binder.getCallingPid(), Binder.getCallingUid(), null)\n@@ -4723,19 +4727,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n             @Nullable String attributionTag) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, null);\n+        return verifyAndGetBypass(uid, packageName, attributionTag, Process.INVALID_UID, null);\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName, false);\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName) {\n+        return verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName,\n+                false);\n     }\n \n     /**\n@@ -4746,14 +4751,15 @@ public class AppOpsService extends IAppOpsService.Stub {\n      * @param uid The uid the package belongs to\n      * @param packageName The package the might belong to the uid\n      * @param attributionTag attribution tag or {@code null} if no need to verify\n-     * @param proxyPackageName The proxy package, from which the attribution tag is to be pulled\n+     * @param proxyUid The proxy uid, from which the attribution tag is to be pulled\n+     * @param proxyPackageName The proxy package, from which the attribution tag may be pulled\n      * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n      *\n      * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n      *         attribution tag is valid\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName,\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName,\n             boolean suppressErrorLogs) {\n         if (uid == Process.ROOT_UID) {\n             // For backwards compatibility, don't check package name for root UID.\n@@ -4797,34 +4803,47 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         int callingUid = Binder.getCallingUid();\n \n-        // Allow any attribution tag for resolvable uids\n-        int pkgUid;\n+        // Allow any attribution tag for resolvable, non-app uids\n+        int nonAppUid;\n         if (Objects.equals(packageName, \"com.android.shell\")) {\n             // Special case for the shell which is a package but should be able\n             // to bypass app attribution tag restrictions.\n-            pkgUid = Process.SHELL_UID;\n+            nonAppUid = Process.SHELL_UID;\n         } else {\n-            pkgUid = resolveUid(packageName);\n+            nonAppUid = resolveNonAppUid(packageName);\n         }\n-        if (pkgUid != Process.INVALID_UID) {\n-            if (pkgUid != UserHandle.getAppId(uid)) {\n+        if (nonAppUid != Process.INVALID_UID) {\n+            if (nonAppUid != UserHandle.getAppId(uid)) {\n                 if (!suppressErrorLogs) {\n                     Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n-                            + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n-                            + \".\");\n+                                + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n+                                + \".\");\n+                }\n+                String otherUidMessage =\n+                            DEBUG ? \" but it is really \" + nonAppUid : \" but it is not\";\n+                throw new SecurityException(\"Specified package \\\"\" + packageName\n+                            + \"\\\" under uid \" +  UserHandle.getAppId(uid) + otherUidMessage);\n+            }\n+            // We only allow bypassing the attribution tag verification if the proxy is a\n+            // system app (or is null), in order to prevent abusive apps clogging the appops\n+            // system with unlimited attribution tags via proxy calls.\n+            boolean proxyIsSystemAppOrNull = true;\n+            if (proxyPackageName != null) {\n+                int proxyAppId = UserHandle.getAppId(proxyUid);\n+                if (proxyAppId >= Process.FIRST_APPLICATION_UID) {\n+                    proxyIsSystemAppOrNull =\n+                            mPackageManagerInternal.isSystemPackage(proxyPackageName);\n                 }\n-                String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n-                throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \"\n-                        +  UserHandle.getAppId(uid) + otherUidMessage);\n             }\n             return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n-                    /* isAttributionTagValid */ true);\n+                    /* isAttributionTagValid */ proxyIsSystemAppOrNull);\n         }\n \n         int userId = UserHandle.getUserId(uid);\n         RestrictionBypass bypass = null;\n         boolean isAttributionTagValid = false;\n \n+        int pkgUid = nonAppUid;\n         final long ident = Binder.clearCallingIdentity();\n         try {\n             PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n```",
                                    "patch_apply_output": "patching file services/core/java/com/android/server/appop/AppOpsService.java\nHunk #1 succeeded at 699 (offset 96 lines).\nHunk #2 FAILED at 3086.\nHunk #3 succeeded at 3967 with fuzz 1 (offset 667 lines).\nHunk #4 FAILED at 3896.\nHunk #5 FAILED at 3936.\nHunk #6 FAILED at 4063.\nHunk #7 FAILED at 4622.\nHunk #8 FAILED at 4723.\nHunk #9 FAILED at 4746.\nHunk #10 FAILED at 4797.\nHunk #11 succeeded at 5481 (offset -134 lines).\nHunk #12 succeeded at 6665 (offset -50 lines).\nHunk #13 succeeded at 7116 with fuzz 2 (offset -54 lines).\n8 out of 13 hunks FAILED -- saving rejects to file services/core/java/com/android/server/appop/AppOpsService.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/appop/AppOpsService.java\nHunk #2 NOT MERGED at 3327-3331,3334-3341.\nHunk #3 NOT MERGED at 3464-3469.\nHunk #4 NOT MERGED at 3993-4001.\nHunk #5 NOT MERGED at 4167-4171.\nHunk #6 NOT MERGED at 7509-7517,7519-7525.\nHunk #7 NOT MERGED at 7526-7549.\nHunk #8 NOT MERGED at 7550-7565,7567-7577.\nHunk #9 NOT MERGED at 7580-7601.\nHunk #10 NOT MERGED at 7602-7642,7656-7664.\nmisordered hunks! output would be garbled\nHunk #11 FAILED at 5630.\nmisordered hunks! output would be garbled\nHunk #12 FAILED at 6814.\nHunk #13 NOT MERGED at 7668-7676.\n2 out of 13 hunks FAILED -- saving rejects to file services/core/java/com/android/server/appop/AppOpsService.java.rej"
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "ec8a2057c7aab9bf61acd24f9b02ee7afb699043",
                            "result": "failure",
                            "downstream_patch_content": "commit ec8a2057c7aab9bf61acd24f9b02ee7afb699043\nAuthor: Nate Myren <ntmyren@google.com>\nDate:   Thu Jan 9 10:09:56 2025 -0800\n\n    Do not allow non-system apps to provide unverified attributions\n    \n    Some apps (the shell, system server, etc) are exempt from the\n    requirement that attribution tags be registered. However, in the proxy\n    case, the tag provied by the proxy app is trusted if the proxied app is\n    one of these exemptions. We should only trust these tags if the proxy\n    app is a system app.\n    \n    This CL also adds a second restriction check when a restriction is\n    removed, to verify that an op is free of all restrictions, before\n    resuming a started op\n    \n    Bug: 375623125\n    Test: upcoming\n    Flag: EXEMPT: See bug\n    Merged-In: I6a7b0a24359097c0ea2f52cc69637d929a931b4f\n    Change-Id: I6a7b0a24359097c0ea2f52cc69637d929a931b4f\n\ndiff --git a/services/core/java/com/android/server/appop/AppOpsService.java b/services/core/java/com/android/server/appop/AppOpsService.java\nindex e2388e2918ab..fe98aa0be319 100644\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -589,7 +589,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    /** Returned from {@link #verifyAndGetBypass(int, String, String, String, boolean)}. */\n+    /** Returned from {@link #verifyAndGetBypass(int, String, String, int, String, boolean)}. */\n     private static final class PackageVerificationResult {\n \n         final RestrictionBypass bypass;\n@@ -2503,10 +2503,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n     public int checkPackage(int uid, String packageName) {\n         Objects.requireNonNull(packageName);\n         try {\n-            verifyAndGetBypass(uid, packageName, null, null, true);\n+            verifyAndGetBypass(uid, packageName, null, Process.INVALID_UID, null, true);\n             // When the caller is the system, it's possible that the packageName is the special\n             // one (e.g., \"root\") which isn't actually existed.\n-            if (resolveUid(packageName) == uid\n+            if (resolveNonAppUid(packageName) == uid\n                     || (isPackageExisted(packageName)\n                             && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(uid)))) {\n                 return AppOpsManager.MODE_ALLOWED;\n@@ -2636,7 +2636,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             boolean shouldCollectMessage) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             boolean wasNull = attributionTag == null;\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n@@ -3178,7 +3178,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             int attributionChainId, boolean dryRun) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n@@ -3671,13 +3671,17 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private boolean isSpecialPackage(int callingUid, @Nullable String packageName) {\n         final String resolvedPackage = AppOpsManager.resolvePackageName(callingUid, packageName);\n         return callingUid == Process.SYSTEM_UID\n-                || resolveUid(resolvedPackage) != Process.INVALID_UID;\n+                || resolveNonAppUid(resolvedPackage) != Process.INVALID_UID;\n     }\n \n     private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n         if (attributionSource.getUid() != Binder.getCallingUid()\n                 && attributionSource.isTrusted(mContext)) {\n-            return true;\n+            // if there is a next attribution source, it must be trusted, as well.\n+            if (attributionSource.getNext() == null\n+                    || attributionSource.getNext().isTrusted(mContext)) {\n+                return true;\n+            }\n         }\n         return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                 Binder.getCallingPid(), Binder.getCallingUid(), null)\n@@ -3760,19 +3764,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n             @Nullable String attributionTag) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, null);\n+        return verifyAndGetBypass(uid, packageName, attributionTag, Process.INVALID_UID, null);\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName, false);\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName) {\n+        return verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName,\n+                false);\n     }\n \n     /**\n@@ -3783,14 +3788,15 @@ public class AppOpsService extends IAppOpsService.Stub {\n      * @param uid The uid the package belongs to\n      * @param packageName The package the might belong to the uid\n      * @param attributionTag attribution tag or {@code null} if no need to verify\n-     * @param proxyPackageName The proxy package, from which the attribution tag is to be pulled\n+     * @param proxyUid The proxy uid, from which the attribution tag is to be pulled\n+     * @param proxyPackageName The proxy package, from which the attribution tag may be pulled\n      * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n      *\n      * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n      *         attribution tag is valid\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName,\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName,\n             boolean suppressErrorLogs) {\n         if (uid == Process.ROOT_UID) {\n             // For backwards compatibility, don't check package name for root UID.\n@@ -3834,34 +3840,47 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         int callingUid = Binder.getCallingUid();\n \n-        // Allow any attribution tag for resolvable uids\n-        int pkgUid;\n+        // Allow any attribution tag for resolvable, non-app uids\n+        int nonAppUid;\n         if (Objects.equals(packageName, \"com.android.shell\")) {\n             // Special case for the shell which is a package but should be able\n             // to bypass app attribution tag restrictions.\n-            pkgUid = Process.SHELL_UID;\n+            nonAppUid = Process.SHELL_UID;\n         } else {\n-            pkgUid = resolveUid(packageName);\n+            nonAppUid = resolveNonAppUid(packageName);\n         }\n-        if (pkgUid != Process.INVALID_UID) {\n-            if (pkgUid != UserHandle.getAppId(uid)) {\n+        if (nonAppUid != Process.INVALID_UID) {\n+            if (nonAppUid != UserHandle.getAppId(uid)) {\n                 if (!suppressErrorLogs) {\n                     Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n-                            + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n-                            + \".\");\n+                                + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n+                                + \".\");\n+                }\n+                String otherUidMessage =\n+                            DEBUG ? \" but it is really \" + nonAppUid : \" but it is not\";\n+                throw new SecurityException(\"Specified package \\\"\" + packageName\n+                            + \"\\\" under uid \" +  UserHandle.getAppId(uid) + otherUidMessage);\n+            }\n+            // We only allow bypassing the attribution tag verification if the proxy is a\n+            // system app (or is null), in order to prevent abusive apps clogging the appops\n+            // system with unlimited attribution tags via proxy calls.\n+            boolean proxyIsSystemAppOrNull = true;\n+            if (proxyPackageName != null) {\n+                int proxyAppId = UserHandle.getAppId(proxyUid);\n+                if (proxyAppId >= Process.FIRST_APPLICATION_UID) {\n+                    proxyIsSystemAppOrNull =\n+                            mPackageManagerInternal.isSystemPackage(proxyPackageName);\n                 }\n-                String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n-                throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \"\n-                        +  UserHandle.getAppId(uid) + otherUidMessage);\n             }\n             return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n-                    /* isAttributionTagValid */ true);\n+                    /* isAttributionTagValid */ proxyIsSystemAppOrNull);\n         }\n \n         int userId = UserHandle.getUserId(uid);\n         RestrictionBypass bypass = null;\n         boolean isAttributionTagValid = false;\n \n+        int pkgUid = nonAppUid;\n         final long ident = Binder.clearCallingIdentity();\n         try {\n             PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n@@ -4613,7 +4632,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             if (nonpackageUid != -1) {\n                 packageName = null;\n             } else {\n-                packageUid = resolveUid(packageName);\n+                packageUid = resolveNonAppUid(packageName);\n                 if (packageUid < 0) {\n                     packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                             PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n@@ -5628,7 +5647,13 @@ public class AppOpsService extends IAppOpsService.Stub {\n                 if (restricted && attrOp.isRunning()) {\n                     attrOp.pause();\n                 } else if (attrOp.isPaused()) {\n-                    attrOp.resume();\n+                    RestrictionBypass bypass = verifyAndGetBypass(uid, ops.packageName, attrOp.tag)\n+                            .bypass;\n+                    if (!isOpRestrictedLocked(uid, code, ops.packageName, attrOp.tag,\n+                            bypass, false)) {\n+                        // Only resume if there are no other restrictions remaining on this op\n+                        attrOp.resume();\n+                    }\n                 }\n             }\n         }\n@@ -6077,7 +6102,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    private static int resolveUid(String packageName)  {\n+    private static int resolveNonAppUid(String packageName)  {\n         if (packageName == null) {\n             return Process.INVALID_UID;\n         }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
                                    "total_hunks": 13,
                                    "failed_hunks": [
                                        4,
                                        5,
                                        6
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n            boolean wasNull = attributionTag == null;\n=======\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n    }\n=======\n            // Test if the proxied operation will succeed before starting the proxy operation\n            final SyncNotedAppOp testProxiedOp = startOperationDryRun(code,\n                    proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag,\n                    proxiedVirtualDeviceId, proxyUid, resolvedProxyPackageName, proxiedFlags,\n                    startIfModeDefault);\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        },
                                        {
                                            "hunk_number": 3,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag);\n=======\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        },
                                        {
                                            "hunk_number": 4,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n     */\n    private SyncNotedAppOp startOperationDryRun(int code, int uid,\n            @NonNull String packageName, @Nullable String attributionTag, int virtualDeviceId,\n            int proxyUid, String proxyPackageName, @OpFlags int flags,\n            boolean startIfModeDefault) {\n        PackageVerificationResult pvr;\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        },
                                        {
                                            "hunk_number": 5,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n=======\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n>>>>>>> UPSTREAM PATCH (commit 790b7c82c0169752311dbd213f4669e05714fada)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/appop/AppOpsService.java\n+++ services/core/java/com/android/server/appop/AppOpsService.java\n@@ -3896,7 +3896,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             // Test if the proxied operation will succeed before starting the proxy operation\n             final SyncNotedAppOp testProxiedOp = startOperationDryRun(code,\n                     proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag,\n-                    proxiedVirtualDeviceId, resolvedProxyPackageName, proxiedFlags,\n+                    proxiedVirtualDeviceId, proxyUid, resolvedProxyPackageName, proxiedFlags,\n                     startIfModeDefault);\n \n             if (!shouldStartForMode(testProxiedOp.getOpMode(), startIfModeDefault)) {\n@@ -3936,7 +3936,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             int attributionChainId) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n@@ -4063,11 +4063,11 @@ public class AppOpsService extends IAppOpsService.Stub {\n      */\n     private SyncNotedAppOp startOperationDryRun(int code, int uid,\n             @NonNull String packageName, @Nullable String attributionTag, int virtualDeviceId,\n-            String proxyPackageName, @OpFlags int flags,\n+            int proxyUid, String proxyPackageName, @OpFlags int flags,\n             boolean startIfModeDefault) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n```",
                                    "patch_apply_output": "patching file services/core/java/com/android/server/appop/AppOpsService.java\nHunk #1 succeeded at 589 (offset -14 lines).\nHunk #2 succeeded at 2493 (offset -593 lines).\nHunk #3 succeeded at 3164 with fuzz 1 (offset -136 lines).\nHunk #4 FAILED at 3896.\nHunk #5 FAILED at 3936.\nHunk #6 FAILED at 4063.\nHunk #7 succeeded at 3642 (offset -980 lines).\nHunk #8 succeeded at 3735 (offset -992 lines).\nHunk #9 succeeded at 3759 (offset -992 lines).\nHunk #10 succeeded at 3811 (offset -992 lines).\nHunk #11 succeeded at 4573 (offset -1061 lines).\nHunk #12 succeeded at 5588 (offset -1146 lines).\nHunk #13 succeeded at 6043 (offset -1146 lines).\n3 out of 13 hunks FAILED -- saving rejects to file services/core/java/com/android/server/appop/AppOpsService.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/appop/AppOpsService.java\nHunk #3 NOT MERGED at 2632-2637.\nHunk #4 NOT MERGED at 3306-3314.\nHunk #5 NOT MERGED at 3362-3366.\nHunk #6 NOT MERGED at 3497-3505,3507-3514."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-368069390",
            "aliases": [
                "A-368069390",
                "CVE-2024-49729"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-368069390",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "bc067ef9f0408f3b7c4f5dcae3b6aec51f386e4d"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From bc067ef9f0408f3b7c4f5dcae3b6aec51f386e4d Mon Sep 17 00:00:00 2001\nFrom: David Anderson <dvander@google.com>\nDate: Tue, 1 Oct 2024 11:01:08 -0700\nSubject: [PATCH] libdm: Redact keys from dm-crypt targets when calling\n GetTable.\n\nIgnore-AOSP-First: security fix\nBug: 368069390\nTest: libdm_test\nChange-Id: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n---\n fs_mgr/libdm/dm.cpp      | 14 ++++++++++++++\n fs_mgr/libdm/dm_test.cpp | 28 ++++++++++++++++++++++++++++\n 2 files changed, 42 insertions(+)\n\ndiff --git a/fs_mgr/libdm/dm.cpp b/fs_mgr/libdm/dm.cpp\nindex a9633226f..94c320ac4 100644\n--- a/fs_mgr/libdm/dm.cpp\n+++ b/fs_mgr/libdm/dm.cpp\n@@ -551,6 +551,17 @@ bool DeviceMapper::GetTableInfo(const std::string& name, std::vector<TargetInfo>\n     return GetTable(name, DM_STATUS_TABLE_FLAG, table);\n }\n \n+void RedactTableInfo(const struct dm_target_spec& spec, std::string* data) {\n+    if (DeviceMapper::GetTargetType(spec) == \"crypt\") {\n+        auto parts = android::base::Split(*data, \" \");\n+        if (parts.size() < 2) {\n+            return;\n+        }\n+        parts[1] = \"redacted\";\n+        *data = android::base::Join(parts, \" \");\n+    }\n+}\n+\n // private methods of DeviceMapper\n bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n                             std::vector<TargetInfo>* table) {\n@@ -589,6 +600,9 @@ bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n             // Note: we use c_str() to eliminate any extra trailing 0s.\n             data = std::string(&buffer[data_offset], next_cursor - data_offset).c_str();\n         }\n+        if (flags & DM_STATUS_TABLE_FLAG) {\n+            RedactTableInfo(*spec, &data);\n+        }\n         table->emplace_back(*spec, data);\n         cursor = next_cursor;\n     }\ndiff --git a/fs_mgr/libdm/dm_test.cpp b/fs_mgr/libdm/dm_test.cpp\nindex b890f4715..5eddb513c 100644\n--- a/fs_mgr/libdm/dm_test.cpp\n+++ b/fs_mgr/libdm/dm_test.cpp\n@@ -814,3 +814,31 @@ TEST_F(DmTest, ThinProvisioning) {\n     TempDevice thin(\"thin\", thinTable);\n     ASSERT_TRUE(thin.valid());\n }\n+\n+TEST_F(DmTest, RedactDmCrypt) {\n+    static constexpr uint64_t kImageSize = 65536;\n+    unique_fd temp_file(CreateTempFile(\"file_1\", kImageSize));\n+    ASSERT_GE(temp_file, 0);\n+\n+    LoopDevice loop(temp_file, 10s);\n+    ASSERT_TRUE(loop.valid());\n+\n+    static constexpr const char* kAlgorithm = \"aes-cbc-essiv:sha256\";\n+    static constexpr const char* kKey = \"0e64ef514e6a1315b1f6390cb57c9e6a\";\n+\n+    auto target = std::make_unique<DmTargetCrypt>(0, kImageSize / 512, kAlgorithm, kKey, 0,\n+                                                  loop.device(), 0);\n+    target->AllowDiscards();\n+\n+    DmTable table;\n+    table.AddTarget(std::move(target));\n+\n+    auto& dm = DeviceMapper::Instance();\n+    std::string crypt_path;\n+    ASSERT_TRUE(dm.CreateDevice(test_name_, table, &crypt_path, 10s));\n+\n+    std::vector<DeviceMapper::TargetInfo> targets;\n+    ASSERT_TRUE(dm.GetTableInfo(test_name_, &targets));\n+    ASSERT_EQ(targets.size(), 1);\n+    EXPECT_EQ(targets[0].data.find(kKey), std::string::npos);\n+}\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "c434d801d65372dd12d9bc8bd7717ef08f3fa984",
                            "result": "success",
                            "downstream_patch_content": "commit c434d801d65372dd12d9bc8bd7717ef08f3fa984\nAuthor: David Anderson <dvander@google.com>\nDate:   Tue Oct 1 11:01:08 2024 -0700\n\n    libdm: Redact keys from dm-crypt targets when calling GetTable.\n    \n    Ignore-AOSP-First: security fix\n    Bug: 368069390\n    Test: libdm_test\n    Change-Id: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n    Merged-In: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n\ndiff --git a/fs_mgr/libdm/dm.cpp b/fs_mgr/libdm/dm.cpp\nindex e43c00b44..dbee8a377 100644\n--- a/fs_mgr/libdm/dm.cpp\n+++ b/fs_mgr/libdm/dm.cpp\n@@ -494,6 +494,17 @@ bool DeviceMapper::GetTableInfo(const std::string& name, std::vector<TargetInfo>\n     return GetTable(name, DM_STATUS_TABLE_FLAG, table);\n }\n \n+void RedactTableInfo(const struct dm_target_spec& spec, std::string* data) {\n+    if (DeviceMapper::GetTargetType(spec) == \"crypt\") {\n+        auto parts = android::base::Split(*data, \" \");\n+        if (parts.size() < 2) {\n+            return;\n+        }\n+        parts[1] = \"redacted\";\n+        *data = android::base::Join(parts, \" \");\n+    }\n+}\n+\n // private methods of DeviceMapper\n bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n                             std::vector<TargetInfo>* table) {\n@@ -532,6 +543,9 @@ bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n             // Note: we use c_str() to eliminate any extra trailing 0s.\n             data = std::string(&buffer[data_offset], next_cursor - data_offset).c_str();\n         }\n+        if (flags & DM_STATUS_TABLE_FLAG) {\n+            RedactTableInfo(*spec, &data);\n+        }\n         table->emplace_back(*spec, data);\n         cursor = next_cursor;\n     }\n"
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "e68f6cd6c0a925fea1bbe7537f6029ef9b0e142c",
                            "result": "success",
                            "downstream_patch_content": "commit e68f6cd6c0a925fea1bbe7537f6029ef9b0e142c\nAuthor: David Anderson <dvander@google.com>\nDate:   Tue Oct 1 11:01:08 2024 -0700\n\n    libdm: Redact keys from dm-crypt targets when calling GetTable.\n    \n    Ignore-AOSP-First: security fix\n    Bug: 368069390\n    Test: libdm_test\n    Change-Id: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n    Merged-In: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n\ndiff --git a/fs_mgr/libdm/dm.cpp b/fs_mgr/libdm/dm.cpp\nindex b1d5b397a..762e83c30 100644\n--- a/fs_mgr/libdm/dm.cpp\n+++ b/fs_mgr/libdm/dm.cpp\n@@ -512,6 +512,17 @@ bool DeviceMapper::GetTableInfo(const std::string& name, std::vector<TargetInfo>\n     return GetTable(name, DM_STATUS_TABLE_FLAG, table);\n }\n \n+void RedactTableInfo(const struct dm_target_spec& spec, std::string* data) {\n+    if (DeviceMapper::GetTargetType(spec) == \"crypt\") {\n+        auto parts = android::base::Split(*data, \" \");\n+        if (parts.size() < 2) {\n+            return;\n+        }\n+        parts[1] = \"redacted\";\n+        *data = android::base::Join(parts, \" \");\n+    }\n+}\n+\n // private methods of DeviceMapper\n bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n                             std::vector<TargetInfo>* table) {\n@@ -550,6 +561,9 @@ bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n             // Note: we use c_str() to eliminate any extra trailing 0s.\n             data = std::string(&buffer[data_offset], next_cursor - data_offset).c_str();\n         }\n+        if (flags & DM_STATUS_TABLE_FLAG) {\n+            RedactTableInfo(*spec, &data);\n+        }\n         table->emplace_back(*spec, data);\n         cursor = next_cursor;\n     }\ndiff --git a/fs_mgr/libdm/dm_test.cpp b/fs_mgr/libdm/dm_test.cpp\nindex 541f254cb..f4c9784da 100644\n--- a/fs_mgr/libdm/dm_test.cpp\n+++ b/fs_mgr/libdm/dm_test.cpp\n@@ -690,3 +690,32 @@ TEST(libdm, CreateEmptyDevice) {\n     // Empty device should be in suspended state.\n     ASSERT_EQ(DmDeviceState::SUSPENDED, dm.GetState(\"empty-device\"));\n }\n+\n+TEST(libdm, RedactDmCrypt) {\n+    static constexpr uint64_t kImageSize = 65536;\n+    static constexpr const char* kTestName = \"RedactDmCrypt\";\n+    unique_fd temp_file(CreateTempFile(\"file_1\", kImageSize));\n+    ASSERT_GE(temp_file, 0);\n+\n+    LoopDevice loop(temp_file, 10s);\n+    ASSERT_TRUE(loop.valid());\n+\n+    static constexpr const char* kAlgorithm = \"aes-cbc-essiv:sha256\";\n+    static constexpr const char* kKey = \"0e64ef514e6a1315b1f6390cb57c9e6a\";\n+\n+    auto target = std::make_unique<DmTargetCrypt>(0, kImageSize / 512, kAlgorithm, kKey, 0,\n+                                                  loop.device(), 0);\n+    target->AllowDiscards();\n+\n+    DmTable table;\n+    table.AddTarget(std::move(target));\n+\n+    auto& dm = DeviceMapper::Instance();\n+    std::string crypt_path;\n+    ASSERT_TRUE(dm.CreateDevice(kTestName, table, &crypt_path, 10s));\n+\n+    std::vector<DeviceMapper::TargetInfo> targets;\n+    ASSERT_TRUE(dm.GetTableInfo(kTestName, &targets));\n+    ASSERT_EQ(targets.size(), 1);\n+    EXPECT_EQ(targets[0].data.find(kKey), std::string::npos);\n+}\n"
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "95ca31cecf7591d48664260712c0199ac9bfedeb"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "d94e6c537fd8283a33d899d627ff154cc2af2d10",
                            "result": "success",
                            "downstream_patch_content": "commit d94e6c537fd8283a33d899d627ff154cc2af2d10\nAuthor: David Anderson <dvander@google.com>\nDate:   Tue Oct 1 11:01:08 2024 -0700\n\n    libdm: Redact keys from dm-crypt targets when calling GetTable.\n    \n    Ignore-AOSP-First: security fix\n    Bug: 368069390\n    Test: libdm_test\n    Change-Id: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n    Merged-In: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n\ndiff --git a/fs_mgr/libdm/dm.cpp b/fs_mgr/libdm/dm.cpp\nindex 4034e30ab..6da7b48b6 100644\n--- a/fs_mgr/libdm/dm.cpp\n+++ b/fs_mgr/libdm/dm.cpp\n@@ -512,6 +512,17 @@ bool DeviceMapper::GetTableInfo(const std::string& name, std::vector<TargetInfo>\n     return GetTable(name, DM_STATUS_TABLE_FLAG, table);\n }\n \n+void RedactTableInfo(const struct dm_target_spec& spec, std::string* data) {\n+    if (DeviceMapper::GetTargetType(spec) == \"crypt\") {\n+        auto parts = android::base::Split(*data, \" \");\n+        if (parts.size() < 2) {\n+            return;\n+        }\n+        parts[1] = \"redacted\";\n+        *data = android::base::Join(parts, \" \");\n+    }\n+}\n+\n // private methods of DeviceMapper\n bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n                             std::vector<TargetInfo>* table) {\n@@ -550,6 +561,9 @@ bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n             // Note: we use c_str() to eliminate any extra trailing 0s.\n             data = std::string(&buffer[data_offset], next_cursor - data_offset).c_str();\n         }\n+        if (flags & DM_STATUS_TABLE_FLAG) {\n+            RedactTableInfo(*spec, &data);\n+        }\n         table->emplace_back(*spec, data);\n         cursor = next_cursor;\n     }\ndiff --git a/fs_mgr/libdm/dm_test.cpp b/fs_mgr/libdm/dm_test.cpp\nindex 541f254cb..f4c9784da 100644\n--- a/fs_mgr/libdm/dm_test.cpp\n+++ b/fs_mgr/libdm/dm_test.cpp\n@@ -690,3 +690,32 @@ TEST(libdm, CreateEmptyDevice) {\n     // Empty device should be in suspended state.\n     ASSERT_EQ(DmDeviceState::SUSPENDED, dm.GetState(\"empty-device\"));\n }\n+\n+TEST(libdm, RedactDmCrypt) {\n+    static constexpr uint64_t kImageSize = 65536;\n+    static constexpr const char* kTestName = \"RedactDmCrypt\";\n+    unique_fd temp_file(CreateTempFile(\"file_1\", kImageSize));\n+    ASSERT_GE(temp_file, 0);\n+\n+    LoopDevice loop(temp_file, 10s);\n+    ASSERT_TRUE(loop.valid());\n+\n+    static constexpr const char* kAlgorithm = \"aes-cbc-essiv:sha256\";\n+    static constexpr const char* kKey = \"0e64ef514e6a1315b1f6390cb57c9e6a\";\n+\n+    auto target = std::make_unique<DmTargetCrypt>(0, kImageSize / 512, kAlgorithm, kKey, 0,\n+                                                  loop.device(), 0);\n+    target->AllowDiscards();\n+\n+    DmTable table;\n+    table.AddTarget(std::move(target));\n+\n+    auto& dm = DeviceMapper::Instance();\n+    std::string crypt_path;\n+    ASSERT_TRUE(dm.CreateDevice(kTestName, table, &crypt_path, 10s));\n+\n+    std::vector<DeviceMapper::TargetInfo> targets;\n+    ASSERT_TRUE(dm.GetTableInfo(kTestName, &targets));\n+    ASSERT_EQ(targets.size(), 1);\n+    EXPECT_EQ(targets[0].data.find(kKey), std::string::npos);\n+}\n"
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "9b9233f4c1c31819fcd0fbc761f3b7ba6bd94344",
                            "result": "success",
                            "downstream_patch_content": "commit 9b9233f4c1c31819fcd0fbc761f3b7ba6bd94344\nAuthor: David Anderson <dvander@google.com>\nDate:   Tue Oct 1 11:01:08 2024 -0700\n\n    libdm: Redact keys from dm-crypt targets when calling GetTable.\n    \n    Ignore-AOSP-First: security fix\n    Bug: 368069390\n    Test: libdm_test\n    Change-Id: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n    Merged-In: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n    (cherry picked from commit bc067ef9f0408f3b7c4f5dcae3b6aec51f386e4d)\n\ndiff --git a/fs_mgr/libdm/dm.cpp b/fs_mgr/libdm/dm.cpp\nindex 1e8c14fe2..c6f9192ae 100644\n--- a/fs_mgr/libdm/dm.cpp\n+++ b/fs_mgr/libdm/dm.cpp\n@@ -540,6 +540,17 @@ bool DeviceMapper::GetTableInfo(const std::string& name, std::vector<TargetInfo>\n     return GetTable(name, DM_STATUS_TABLE_FLAG, table);\n }\n \n+void RedactTableInfo(const struct dm_target_spec& spec, std::string* data) {\n+    if (DeviceMapper::GetTargetType(spec) == \"crypt\") {\n+        auto parts = android::base::Split(*data, \" \");\n+        if (parts.size() < 2) {\n+            return;\n+        }\n+        parts[1] = \"redacted\";\n+        *data = android::base::Join(parts, \" \");\n+    }\n+}\n+\n // private methods of DeviceMapper\n bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n                             std::vector<TargetInfo>* table) {\n@@ -578,6 +589,9 @@ bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n             // Note: we use c_str() to eliminate any extra trailing 0s.\n             data = std::string(&buffer[data_offset], next_cursor - data_offset).c_str();\n         }\n+        if (flags & DM_STATUS_TABLE_FLAG) {\n+            RedactTableInfo(*spec, &data);\n+        }\n         table->emplace_back(*spec, data);\n         cursor = next_cursor;\n     }\ndiff --git a/fs_mgr/libdm/dm_test.cpp b/fs_mgr/libdm/dm_test.cpp\nindex c522eafae..08edbe832 100644\n--- a/fs_mgr/libdm/dm_test.cpp\n+++ b/fs_mgr/libdm/dm_test.cpp\n@@ -757,3 +757,31 @@ TEST_F(DmTest, GetNameAndUuid) {\n     ASSERT_EQ(name, test_name_);\n     ASSERT_FALSE(uuid.empty());\n }\n+\n+TEST_F(DmTest, RedactDmCrypt) {\n+    static constexpr uint64_t kImageSize = 65536;\n+    unique_fd temp_file(CreateTempFile(\"file_1\", kImageSize));\n+    ASSERT_GE(temp_file, 0);\n+\n+    LoopDevice loop(temp_file, 10s);\n+    ASSERT_TRUE(loop.valid());\n+\n+    static constexpr const char* kAlgorithm = \"aes-cbc-essiv:sha256\";\n+    static constexpr const char* kKey = \"0e64ef514e6a1315b1f6390cb57c9e6a\";\n+\n+    auto target = std::make_unique<DmTargetCrypt>(0, kImageSize / 512, kAlgorithm, kKey, 0,\n+                                                  loop.device(), 0);\n+    target->AllowDiscards();\n+\n+    DmTable table;\n+    table.AddTarget(std::move(target));\n+\n+    auto& dm = DeviceMapper::Instance();\n+    std::string crypt_path;\n+    ASSERT_TRUE(dm.CreateDevice(test_name_, table, &crypt_path, 10s));\n+\n+    std::vector<DeviceMapper::TargetInfo> targets;\n+    ASSERT_TRUE(dm.GetTableInfo(test_name_, &targets));\n+    ASSERT_EQ(targets.size(), 1);\n+    EXPECT_EQ(targets[0].data.find(kKey), std::string::npos);\n+}\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-375408314",
            "aliases": [
                "A-375408314",
                "CVE-2025-0074"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375408314",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "7f74d44cebf1cad4b3d7aa9b05236a41cb221e9e"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 7f74d44cebf1cad4b3d7aa9b05236a41cb221e9e Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Wed, 30 Oct 2024 23:58:27 +0000\nSubject: [PATCH] Fix incorrect logging in sdp_discovery\n\nIn two locations in sdp_discovery.cc, log statements use structures that\nmay, in exceptional cases, have been freed by preceding calls.  This can\nlead to use after free and potentially to security vulnerabilities.\n\nUse local variables instead.\n\nBug: 375408314\nBug: 375409435\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: I76e1ffa1fe463a5858d61d025447d855ff6b5b84\n---\n system/stack/sdp/sdp_discovery.cc | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\ndiff --git a/system/stack/sdp/sdp_discovery.cc b/system/stack/sdp/sdp_discovery.cc\nindex 2e5cd86da0..75cd5a7ea2 100644\n--- a/system/stack/sdp/sdp_discovery.cc\n+++ b/system/stack/sdp/sdp_discovery.cc\n@@ -183,7 +183,7 @@ static void sdp_snd_service_search_req(tCONN_CB* p_ccb, uint8_t cont_len, uint8_\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_cmd) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_cmd->len);\n+              p_ccb->connection_id, p - p_start);\n   }\n \n   /* Start inactivity timer */\n@@ -711,7 +711,7 @@ static void process_service_search_attr_rsp(tCONN_CB* p_ccb, uint8_t* p_reply,\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_msg) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-                p_ccb->connection_id, p_msg->len);\n+                p_ccb->connection_id, p - p_start);\n     }\n \n     /* Start inactivity timer */\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "bb2f54f9ed938267c2830da4a9d984529274d8a8"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-289811388",
            "aliases": [
                "A-289811388",
                "CVE-2025-0093"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-289811388",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "771aed3ea225d9ca2ef91e88f45f330ced952772"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 771aed3ea225d9ca2ef91e88f45f330ced952772 Mon Sep 17 00:00:00 2001\nFrom: Kyunglyul Hyun <klhyun@google.com>\nDate: Wed, 2 Oct 2024 03:50:00 +0000\nSubject: [PATCH] Reset permissions for not bonded device\n\nAccording to the PBAP specification,\nThe PSE user shall have to confirm at least the first Phone Book Access\nProfile connection from each new PCE.\n\nAccording to the MAP specification,\nThe MCE and MSE shall be bonded before setting up a Message Access Profile\nconnection.\n\nLet's remove the permissions when the device is unbonded.\n\nFlag: EXEMPT, security fix\nBug: 289375038\nBug: 289811388\nTest: atest BluetoothInstrumentationTests\nIgnore-AOSP-First: security fix\n\nChange-Id: I94478a4a45a434732d4bc4810da31ef45ef891af\n---\n .../com/android/bluetooth/btservice/AdapterService.java   | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\ndiff --git a/android/app/src/com/android/bluetooth/btservice/AdapterService.java b/android/app/src/com/android/bluetooth/btservice/AdapterService.java\nindex 19c8aee207..3937a8e881 100644\n--- a/android/app/src/com/android/bluetooth/btservice/AdapterService.java\n+++ b/android/app/src/com/android/bluetooth/btservice/AdapterService.java\n@@ -27,6 +27,7 @@ import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\n import static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n@@ -6121,6 +6122,13 @@ public class AdapterService extends Service {\n             mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n         }\n         mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n+\n+        if (toState == BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n     }\n \n     static int convertScanModeToHal(int mode) {\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12-release: Command '['git', 'checkout', 'android12-release']' returned non-zero exit status 1.",
                            "downstream_patch": "e3be5a26db30094f034a543ac60e6ff5da497bd7"
                        },
                        {
                            "downstream_version": "12L",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12L-release: Command '['git', 'checkout', 'android12L-release']' returned non-zero exit status 1.",
                            "downstream_patch": "e3be5a26db30094f034a543ac60e6ff5da497bd7"
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "8ef714b803127ca193773c6d032457c01c1963d6"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "038b1e8626399ff3f374d5af987e3efd64a19321",
                            "result": "failure",
                            "downstream_patch_content": "commit 038b1e8626399ff3f374d5af987e3efd64a19321\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Thu Nov 14 00:35:48 2024 +0000\n\n    Reset permissions for not bonded device\n    \n    According to the PBAP specification,\n    The PSE user shall have to confirm at least the first Phone Book Access\n    Profile connection from each new PCE.\n    \n    According to the MAP specification,\n    The MCE and MSE shall be bonded before setting up a Message Access Profile\n    connection.\n    \n    Let's remove the permissions when the device is unbonded.\n    \n    This is a backport of change ag/30386015 but requires minor changes to\n    logic.\n    \n    Flag: EXEMPT, security fix\n    Bug: 289375038\n    Bug: 289811388\n    Test: atest BluetoothInstrumentationTests\n    Ignore-AOSP-First: security fix\n    Merged-In: I94478a4a45a434732d4bc4810da31ef45ef891af\n    Change-Id: I8b9b29310db2d14e5dfaddc81a682366fbef42d3\n\ndiff --git a/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java b/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\nindex d62d7ba06d..1a1c912f3f 100644\n--- a/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\n+++ b/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\n@@ -439,6 +439,13 @@ final class BondStateMachine extends StateMachine {\n             }\n         }\n \n+        if (newState == BluetoothDevice.BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            mAdapterService.setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            mAdapterService.setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            mAdapterService.setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n+\n         Intent intent = new Intent(BluetoothDevice.ACTION_BOND_STATE_CHANGED);\n         intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);\n         intent.putExtra(BluetoothDevice.EXTRA_BOND_STATE, newState);\n",
                            "file_conflicts": [
                                {
                                    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\nimport static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\nimport static android.bluetooth.BluetoothDevice.BOND_NONE;\n>>>>>>> UPSTREAM PATCH (commit 771aed3ea225d9ca2ef91e88f45f330ced952772)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n        mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n\n        if (toState == BOND_NONE) {\n            // Remove the permissions for unbonded devices\n            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n        }\n>>>>>>> UPSTREAM PATCH (commit 771aed3ea225d9ca2ef91e88f45f330ced952772)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- android/app/src/com/android/bluetooth/btservice/AdapterService.java\n+++ android/app/src/com/android/bluetooth/btservice/AdapterService.java\n@@ -27,6 +27,7 @@ import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\n import static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n@@ -6121,6 +6122,13 @@ public class AdapterService extends Service {\n             mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n         }\n         mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n+\n+        if (toState == BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n     }\n \n     static int convertScanModeToHal(int mode) {\n```",
                                    "patch_apply_output": "patching file android/app/src/com/android/bluetooth/btservice/AdapterService.java\nHunk #1 FAILED at 27.\nHunk #2 FAILED at 6121.\n2 out of 2 hunks FAILED -- saving rejects to file android/app/src/com/android/bluetooth/btservice/AdapterService.java.rej",
                                    "inline_merge_output": "patching file android/app/src/com/android/bluetooth/btservice/AdapterService.java\nHunk #1 NOT MERGED at 19-25.\nHunk #2 NOT MERGED at 5338-5348."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "038b1e8626399ff3f374d5af987e3efd64a19321",
                            "result": "failure",
                            "downstream_patch_content": "commit 038b1e8626399ff3f374d5af987e3efd64a19321\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Thu Nov 14 00:35:48 2024 +0000\n\n    Reset permissions for not bonded device\n    \n    According to the PBAP specification,\n    The PSE user shall have to confirm at least the first Phone Book Access\n    Profile connection from each new PCE.\n    \n    According to the MAP specification,\n    The MCE and MSE shall be bonded before setting up a Message Access Profile\n    connection.\n    \n    Let's remove the permissions when the device is unbonded.\n    \n    This is a backport of change ag/30386015 but requires minor changes to\n    logic.\n    \n    Flag: EXEMPT, security fix\n    Bug: 289375038\n    Bug: 289811388\n    Test: atest BluetoothInstrumentationTests\n    Ignore-AOSP-First: security fix\n    Merged-In: I94478a4a45a434732d4bc4810da31ef45ef891af\n    Change-Id: I8b9b29310db2d14e5dfaddc81a682366fbef42d3\n\ndiff --git a/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java b/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\nindex d62d7ba06d..1a1c912f3f 100644\n--- a/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\n+++ b/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\n@@ -439,6 +439,13 @@ final class BondStateMachine extends StateMachine {\n             }\n         }\n \n+        if (newState == BluetoothDevice.BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            mAdapterService.setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            mAdapterService.setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            mAdapterService.setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n+\n         Intent intent = new Intent(BluetoothDevice.ACTION_BOND_STATE_CHANGED);\n         intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);\n         intent.putExtra(BluetoothDevice.EXTRA_BOND_STATE, newState);\n",
                            "file_conflicts": [
                                {
                                    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\nimport static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\nimport static android.bluetooth.BluetoothDevice.BOND_NONE;\n>>>>>>> UPSTREAM PATCH (commit 771aed3ea225d9ca2ef91e88f45f330ced952772)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n        mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n\n        if (toState == BOND_NONE) {\n            // Remove the permissions for unbonded devices\n            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n        }\n>>>>>>> UPSTREAM PATCH (commit 771aed3ea225d9ca2ef91e88f45f330ced952772)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- android/app/src/com/android/bluetooth/btservice/AdapterService.java\n+++ android/app/src/com/android/bluetooth/btservice/AdapterService.java\n@@ -27,6 +27,7 @@ import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\n import static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n@@ -6121,6 +6122,13 @@ public class AdapterService extends Service {\n             mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n         }\n         mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n+\n+        if (toState == BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n     }\n \n     static int convertScanModeToHal(int mode) {\n```",
                                    "patch_apply_output": "patching file android/app/src/com/android/bluetooth/btservice/AdapterService.java\nHunk #1 FAILED at 27.\nHunk #2 FAILED at 6121.\n2 out of 2 hunks FAILED -- saving rejects to file android/app/src/com/android/bluetooth/btservice/AdapterService.java.rej",
                                    "inline_merge_output": "patching file android/app/src/com/android/bluetooth/btservice/AdapterService.java\nHunk #1 NOT MERGED at 20-26.\nHunk #2 NOT MERGED at 6060-6070."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-382775095",
            "aliases": [
                "A-382775095",
                "CVE-2025-0078"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-382775095",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "90b14eab96ef0de6f91375a2d55768798ce11059"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 90b14eab96ef0de6f91375a2d55768798ce11059 Mon Sep 17 00:00:00 2001\nFrom: Steven Moreland <smoreland@google.com>\nDate: Fri, 6 Dec 2024 23:55:35 +0000\nSubject: [PATCH] servicemanager: set consistent flags for self-reg\n\nSM has special flags set to become a context object, but\nthese were not set when it registers as itself.\n\nBug: 382775095\nTest: boot w/ harsher checks\nChange-Id: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n---\n cmds/servicemanager/main.cpp | 1 +\n 1 file changed, 1 insertion(+)\n\ndiff --git a/cmds/servicemanager/main.cpp b/cmds/servicemanager/main.cpp\nindex c126e91373..df5a8ed0d1 100644\n--- a/cmds/servicemanager/main.cpp\n+++ b/cmds/servicemanager/main.cpp\n@@ -165,6 +165,7 @@ int main(int argc, char** argv) {\n     IPCThreadState::self()->disableBackgroundScheduling(true);\n \n     sp<ServiceManager> manager = sp<ServiceManager>::make(std::make_unique<Access>());\n+    manager->setRequestingSid(true);\n     if (!manager->addService(\"manager\", manager, false /*allowIsolated*/, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) {\n         LOG(ERROR) << \"Could not self register servicemanager\";\n     }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "6c86b6c926ab527eb88804711beb4bd09e348e06",
                            "result": "success",
                            "downstream_patch_content": "commit 6c86b6c926ab527eb88804711beb4bd09e348e06\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Fri Dec 6 23:55:35 2024 +0000\n\n    servicemanager: set consistent flags for self-reg\n    \n    SM has special flags set to become a context object, but\n    these were not set when it registers as itself.\n    \n    Bug: 382775095\n    Test: boot w/ harsher checks\n    Merged-In: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n    Change-Id: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n\ndiff --git a/cmds/servicemanager/main.cpp b/cmds/servicemanager/main.cpp\nindex 8c1beaca20..d8cc8e6a20 100644\n--- a/cmds/servicemanager/main.cpp\n+++ b/cmds/servicemanager/main.cpp\n@@ -122,6 +122,7 @@ int main(int argc, char** argv) {\n     ps->setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY);\n \n     sp<ServiceManager> manager = sp<ServiceManager>::make(std::make_unique<Access>());\n+    manager->setRequestingSid(true);\n     if (!manager->addService(\"manager\", manager, false /*allowIsolated*/, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) {\n         LOG(ERROR) << \"Could not self register servicemanager\";\n     }\n"
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "6c86b6c926ab527eb88804711beb4bd09e348e06",
                            "result": "success",
                            "downstream_patch_content": "commit 6c86b6c926ab527eb88804711beb4bd09e348e06\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Fri Dec 6 23:55:35 2024 +0000\n\n    servicemanager: set consistent flags for self-reg\n    \n    SM has special flags set to become a context object, but\n    these were not set when it registers as itself.\n    \n    Bug: 382775095\n    Test: boot w/ harsher checks\n    Merged-In: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n    Change-Id: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n\ndiff --git a/cmds/servicemanager/main.cpp b/cmds/servicemanager/main.cpp\nindex 8c1beaca20..d8cc8e6a20 100644\n--- a/cmds/servicemanager/main.cpp\n+++ b/cmds/servicemanager/main.cpp\n@@ -122,6 +122,7 @@ int main(int argc, char** argv) {\n     ps->setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY);\n \n     sp<ServiceManager> manager = sp<ServiceManager>::make(std::make_unique<Access>());\n+    manager->setRequestingSid(true);\n     if (!manager->addService(\"manager\", manager, false /*allowIsolated*/, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) {\n         LOG(ERROR) << \"Could not self register servicemanager\";\n     }\n"
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "f7e88ce3ad00852c92ec23997bb78b0a9b358d65"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "6c86b6c926ab527eb88804711beb4bd09e348e06",
                            "result": "success",
                            "downstream_patch_content": "commit 6c86b6c926ab527eb88804711beb4bd09e348e06\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Fri Dec 6 23:55:35 2024 +0000\n\n    servicemanager: set consistent flags for self-reg\n    \n    SM has special flags set to become a context object, but\n    these were not set when it registers as itself.\n    \n    Bug: 382775095\n    Test: boot w/ harsher checks\n    Merged-In: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n    Change-Id: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n\ndiff --git a/cmds/servicemanager/main.cpp b/cmds/servicemanager/main.cpp\nindex 8c1beaca20..d8cc8e6a20 100644\n--- a/cmds/servicemanager/main.cpp\n+++ b/cmds/servicemanager/main.cpp\n@@ -122,6 +122,7 @@ int main(int argc, char** argv) {\n     ps->setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY);\n \n     sp<ServiceManager> manager = sp<ServiceManager>::make(std::make_unique<Access>());\n+    manager->setRequestingSid(true);\n     if (!manager->addService(\"manager\", manager, false /*allowIsolated*/, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) {\n         LOG(ERROR) << \"Could not self register servicemanager\";\n     }\n"
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "6c86b6c926ab527eb88804711beb4bd09e348e06",
                            "result": "success",
                            "downstream_patch_content": "commit 6c86b6c926ab527eb88804711beb4bd09e348e06\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Fri Dec 6 23:55:35 2024 +0000\n\n    servicemanager: set consistent flags for self-reg\n    \n    SM has special flags set to become a context object, but\n    these were not set when it registers as itself.\n    \n    Bug: 382775095\n    Test: boot w/ harsher checks\n    Merged-In: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n    Change-Id: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n\ndiff --git a/cmds/servicemanager/main.cpp b/cmds/servicemanager/main.cpp\nindex 8c1beaca20..d8cc8e6a20 100644\n--- a/cmds/servicemanager/main.cpp\n+++ b/cmds/servicemanager/main.cpp\n@@ -122,6 +122,7 @@ int main(int argc, char** argv) {\n     ps->setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY);\n \n     sp<ServiceManager> manager = sp<ServiceManager>::make(std::make_unique<Access>());\n+    manager->setRequestingSid(true);\n     if (!manager->addService(\"manager\", manager, false /*allowIsolated*/, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) {\n         LOG(ERROR) << \"Could not self register servicemanager\";\n     }\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-353240784",
            "aliases": [
                "A-353240784",
                "CVE-2024-49741"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-353240784",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "2a75f7166b028150ea0dcd142e1ede51f7861eb3"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 2a75f7166b028150ea0dcd142e1ede51f7861eb3 Mon Sep 17 00:00:00 2001\nFrom: Pinyao Ting <pinyaoting@google.com>\nDate: Tue, 20 Aug 2024 21:17:13 +0000\nSubject: [PATCH] Enforce hard limits on hosts per package and widgets per\n host.\n\nBug: 353240784\nChange-Id: I60ee7faf57ed719f93cafad212fef24964dec99f\nTest: manually verified with PoC app that at most 20 hosts can exists\nFlag: EXEMPT CVE\n---\n .../appwidget/AppWidgetServiceImpl.java       | 50 ++++++++++++++++++-\n 1 file changed, 49 insertions(+), 1 deletion(-)\n\ndiff --git a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nindex 569615e1683c..f9b731db75b1 100644\n--- a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -217,6 +217,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // See {@link Provider#pendingDeletedWidgetIds}.\n     private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     // Handles user and package related broadcasts.\n     // See {@link #registerBroadcastReceiver}\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n@@ -2275,7 +2284,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -2283,6 +2292,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(@NonNull final HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         if (DEBUG) {\n             Slog.i(TAG, \"deleteHostLocked() \" + host);\n@@ -3573,11 +3600,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (DEBUG) {\n             Slog.i(TAG, \"addWidgetLocked() \" + widget);\n         }\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 0,
                    "failed_patches": 4,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "ae39a3f6538e5a5a73aea4daf8b552539247227f",
                            "result": "failure",
                            "downstream_patch_content": "commit ae39a3f6538e5a5a73aea4daf8b552539247227f\nAuthor: Pinyao Ting <pinyaoting@google.com>\nDate:   Tue Aug 20 21:17:13 2024 +0000\n\n    Enforce hard limits on hosts per package and widgets per host.\n    \n    Bug: 353240784\n    Merged-In: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Change-Id: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Test: manually verified with PoC app that at most 20 hosts can exists\n    Flag: EXEMPT CVE\n\ndiff --git a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nindex f5063ac4a023..356613ab3377 100644\n--- a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        4
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n\n=======\n    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n    // surfaces in the host app.\n    // @see AppWidgetHost\n    // @see AppWidgetHost#mHostId\n    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n    // Hard limit of number of widgets can be pinned by a host.\n    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n\n    // Handles user and package related broadcasts.\n    // See {@link #registerBroadcastReceiver}\n>>>>>>> UPSTREAM PATCH (commit 2a75f7166b028150ea0dcd142e1ede51f7861eb3)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n\n=======\n        if (DEBUG) {\n            Slog.i(TAG, \"addWidgetLocked() \" + widget);\n        }\n        ensureWidgetCountBeforeAddLocked(widget);\n>>>>>>> UPSTREAM PATCH (commit 2a75f7166b028150ea0dcd142e1ede51f7861eb3)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -217,6 +217,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // See {@link Provider#pendingDeletedWidgetIds}.\n     private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     // Handles user and package related broadcasts.\n     // See {@link #registerBroadcastReceiver}\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n@@ -3591,11 +3618,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (DEBUG) {\n             Slog.i(TAG, \"addWidgetLocked() \" + widget);\n         }\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n```",
                                    "patch_apply_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 FAILED at 217.\nHunk #2 succeeded at 1697 (offset -578 lines).\nHunk #3 succeeded at 1705 with fuzz 2 (offset -578 lines).\nHunk #4 FAILED at 3591.\n2 out of 4 hunks FAILED -- saving rejects to file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java.rej",
                                    "inline_merge_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 NOT MERGED at 173-186.\nHunk #3 merged at 1723-1740.\nHunk #4 NOT MERGED at 2868-2874, merged at 2880-2899."
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "ae39a3f6538e5a5a73aea4daf8b552539247227f",
                            "result": "failure",
                            "downstream_patch_content": "commit ae39a3f6538e5a5a73aea4daf8b552539247227f\nAuthor: Pinyao Ting <pinyaoting@google.com>\nDate:   Tue Aug 20 21:17:13 2024 +0000\n\n    Enforce hard limits on hosts per package and widgets per host.\n    \n    Bug: 353240784\n    Merged-In: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Change-Id: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Test: manually verified with PoC app that at most 20 hosts can exists\n    Flag: EXEMPT CVE\n\ndiff --git a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nindex f5063ac4a023..356613ab3377 100644\n--- a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        4
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n\n=======\n    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n    // surfaces in the host app.\n    // @see AppWidgetHost\n    // @see AppWidgetHost#mHostId\n    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n    // Hard limit of number of widgets can be pinned by a host.\n    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n\n    // Handles user and package related broadcasts.\n    // See {@link #registerBroadcastReceiver}\n>>>>>>> UPSTREAM PATCH (commit 2a75f7166b028150ea0dcd142e1ede51f7861eb3)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n\n=======\n        if (DEBUG) {\n            Slog.i(TAG, \"addWidgetLocked() \" + widget);\n        }\n        ensureWidgetCountBeforeAddLocked(widget);\n>>>>>>> UPSTREAM PATCH (commit 2a75f7166b028150ea0dcd142e1ede51f7861eb3)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -217,6 +217,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // See {@link Provider#pendingDeletedWidgetIds}.\n     private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     // Handles user and package related broadcasts.\n     // See {@link #registerBroadcastReceiver}\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n@@ -3591,11 +3618,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (DEBUG) {\n             Slog.i(TAG, \"addWidgetLocked() \" + widget);\n         }\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n```",
                                    "patch_apply_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 FAILED at 217.\nHunk #2 succeeded at 1697 (offset -578 lines).\nHunk #3 succeeded at 1705 with fuzz 2 (offset -578 lines).\nHunk #4 FAILED at 3591.\n2 out of 4 hunks FAILED -- saving rejects to file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java.rej",
                                    "inline_merge_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 NOT MERGED at 173-186.\nHunk #3 merged at 1723-1740.\nHunk #4 NOT MERGED at 2868-2874, merged at 2880-2899."
                                }
                            ]
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "1baa20c05661c8489e50693ec15f6c011cc72c18"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "ae39a3f6538e5a5a73aea4daf8b552539247227f",
                            "result": "failure",
                            "downstream_patch_content": "commit ae39a3f6538e5a5a73aea4daf8b552539247227f\nAuthor: Pinyao Ting <pinyaoting@google.com>\nDate:   Tue Aug 20 21:17:13 2024 +0000\n\n    Enforce hard limits on hosts per package and widgets per host.\n    \n    Bug: 353240784\n    Merged-In: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Change-Id: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Test: manually verified with PoC app that at most 20 hosts can exists\n    Flag: EXEMPT CVE\n\ndiff --git a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nindex f5063ac4a023..356613ab3377 100644\n--- a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        4
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n    // surfaces in the host app.\n    // @see AppWidgetHost\n    // @see AppWidgetHost#mHostId\n    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n    // Hard limit of number of widgets can be pinned by a host.\n    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n\n    // Handles user and package related broadcasts.\n    // See {@link #registerBroadcastReceiver}\n>>>>>>> UPSTREAM PATCH (commit 2a75f7166b028150ea0dcd142e1ede51f7861eb3)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n        if (DEBUG) {\n            Slog.i(TAG, \"addWidgetLocked() \" + widget);\n        }\n        ensureWidgetCountBeforeAddLocked(widget);\n>>>>>>> UPSTREAM PATCH (commit 2a75f7166b028150ea0dcd142e1ede51f7861eb3)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -217,6 +217,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // See {@link Provider#pendingDeletedWidgetIds}.\n     private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     // Handles user and package related broadcasts.\n     // See {@link #registerBroadcastReceiver}\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n@@ -3591,11 +3618,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (DEBUG) {\n             Slog.i(TAG, \"addWidgetLocked() \" + widget);\n         }\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n```",
                                    "patch_apply_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 FAILED at 217.\nHunk #2 succeeded at 1719 (offset -556 lines).\nHunk #3 succeeded at 1727 with fuzz 2 (offset -556 lines).\nHunk #4 FAILED at 3591.\n2 out of 4 hunks FAILED -- saving rejects to file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java.rej",
                                    "inline_merge_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 NOT MERGED at 180-193.\nHunk #3 merged at 1745-1762.\nHunk #4 NOT MERGED at 2941-2947, merged at 2953-2972."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "ae39a3f6538e5a5a73aea4daf8b552539247227f",
                            "result": "failure",
                            "downstream_patch_content": "commit ae39a3f6538e5a5a73aea4daf8b552539247227f\nAuthor: Pinyao Ting <pinyaoting@google.com>\nDate:   Tue Aug 20 21:17:13 2024 +0000\n\n    Enforce hard limits on hosts per package and widgets per host.\n    \n    Bug: 353240784\n    Merged-In: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Change-Id: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Test: manually verified with PoC app that at most 20 hosts can exists\n    Flag: EXEMPT CVE\n\ndiff --git a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nindex f5063ac4a023..356613ab3377 100644\n--- a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        4
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n    // surfaces in the host app.\n    // @see AppWidgetHost\n    // @see AppWidgetHost#mHostId\n    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n    // Hard limit of number of widgets can be pinned by a host.\n    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n\n    // Handles user and package related broadcasts.\n    // See {@link #registerBroadcastReceiver}\n>>>>>>> UPSTREAM PATCH (commit 2a75f7166b028150ea0dcd142e1ede51f7861eb3)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n        if (DEBUG) {\n            Slog.i(TAG, \"addWidgetLocked() \" + widget);\n        }\n        ensureWidgetCountBeforeAddLocked(widget);\n>>>>>>> UPSTREAM PATCH (commit 2a75f7166b028150ea0dcd142e1ede51f7861eb3)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -217,6 +217,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // See {@link Provider#pendingDeletedWidgetIds}.\n     private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     // Handles user and package related broadcasts.\n     // See {@link #registerBroadcastReceiver}\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n@@ -3591,11 +3618,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (DEBUG) {\n             Slog.i(TAG, \"addWidgetLocked() \" + widget);\n         }\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n```",
                                    "patch_apply_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 FAILED at 217.\nHunk #2 succeeded at 1796 (offset -479 lines).\nHunk #3 succeeded at 1804 with fuzz 2 (offset -479 lines).\nHunk #4 FAILED at 3591.\n2 out of 4 hunks FAILED -- saving rejects to file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java.rej",
                                    "inline_merge_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 NOT MERGED at 184-197.\nHunk #3 merged at 1822-1839.\nHunk #4 NOT MERGED at 3042-3048, merged at 3054-3073."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-340480881",
            "aliases": [
                "A-340480881",
                "CVE-2024-43095"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-340480881",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "46abb4e1fd365a88efdfe3f2b1f87da4d255b41b"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 46abb4e1fd365a88efdfe3f2b1f87da4d255b41b Mon Sep 17 00:00:00 2001\nFrom: Yi-an Chen <theianchen@google.com>\nDate: Wed, 17 Jul 2024 00:43:30 +0000\nSubject: [PATCH] Fix Dynamic Permission group auto grant behaivor\n\nFix the Dynamic Permission group auto grant behaivor so that a\npermission group is only considered granted when (1) all permissions\nwere auto-granted or (2) a platform permission in the same group is\ngranted.\n\nBug: 340480881\nTest: DynamicPermissionsTest\nChange-Id: Ie7de1b9826df72c708df02a4b73707c8fcffac86\n---\n .../permission/data/LightPermInfoLiveData.kt  |  2 +-\n .../permission/data/PermGroupLiveData.kt      | 45 ++++++++++---------\n .../model/livedatatypes/LightAppPermGroup.kt  | 30 +++++++++----\n .../model/livedatatypes/LightPackageInfo.kt   |  4 +-\n .../model/livedatatypes/LightPermInfo.kt      | 10 +++--\n .../model/livedatatypes/LightPermission.kt    | 19 +++++---\n .../service/AutoRevokePermissions.kt          |  2 +-\n .../RuntimePermissionsUpgradeController.kt    |  6 +--\n .../handheld/ReviewPermissionsFragment.java   |  4 +-\n .../ui/model/AppPermissionViewModel.kt        | 24 +++++-----\n .../ui/model/GrantPermissionsViewModel.kt     | 28 +++++++-----\n .../ui/model/ReviewPermissionsViewModel.kt    |  2 +-\n .../BackgroundGrantBehavior.kt                |  9 ++--\n .../model/grantPermissions/GrantBehavior.kt   |  2 +-\n .../grantPermissions/HealthGrantBehavior.kt   |  2 +-\n .../grantPermissions/LocationGrantBehavior.kt |  7 ++-\n .../grantPermissions/StorageGrantBehavior.kt  | 10 ++---\n .../permission/utils/KotlinUtils.kt           | 30 ++++++-------\n .../permission/utils/SafetyNetLogger.java     |  2 +-\n .../model/ReviewPermissionsViewModelTest.kt   |  2 +-\n .../permission/utils/GrantRevokeTests.kt      |  6 ++-\n 21 files changed, 138 insertions(+), 108 deletions(-)\n\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\nindex 091c45b928..68aa55e14b 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n@@ -67,7 +67,7 @@ private constructor(private val app: Application, private val permissionName: St\n \n         val newValue =\n             try {\n-                LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0))\n+                LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0), null)\n             } catch (e: PackageManager.NameNotFoundException) {\n                 Log.w(LOG_TAG, \"Permission \\\"$permissionName\\\" not found\")\n                 invalidateSingle(permissionName)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\nindex d44fea233a..e923746d73 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n@@ -17,6 +17,7 @@\n package com.android.permissioncontroller.permission.data\n \n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageItemInfo\n import android.content.pm.PackageManager\n import android.content.pm.PermissionGroupInfo\n@@ -64,7 +65,6 @@ private constructor(private val app: Application, private val groupName: String)\n      */\n     override fun onUpdate() {\n         val permissionInfos = mutableMapOf<String, LightPermInfo>()\n-\n         groupInfo =\n             Utils.getGroupInfo(groupName, context)\n                 ?: run {\n@@ -73,28 +73,25 @@ private constructor(private val app: Application, private val groupName: String)\n                     value = null\n                     return\n                 }\n-\n+        val permInfos = mutableListOf<PermissionInfo>()\n         when (groupInfo) {\n             is PermissionGroupInfo -> {\n-                val permInfos =\n-                    try {\n+                try {\n+                    permInfos.addAll(\n                         Utils.getInstalledRuntimePermissionInfosForGroup(\n                             context.packageManager,\n                             groupName\n                         )\n-                    } catch (e: PackageManager.NameNotFoundException) {\n-                        Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n-                        invalidateSingle(groupName)\n-                        value = null\n-                        return\n-                    }\n-\n-                for (permInfo in permInfos) {\n-                    permissionInfos[permInfo.name] = LightPermInfo(permInfo)\n+                    )\n+                } catch (e: PackageManager.NameNotFoundException) {\n+                    Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n+                    invalidateSingle(groupName)\n+                    value = null\n+                    return\n                 }\n             }\n             is PermissionInfo -> {\n-                permissionInfos[groupInfo.name] = LightPermInfo(groupInfo as PermissionInfo)\n+                permInfos.add(groupInfo as PermissionInfo)\n             }\n             else -> {\n                 value = null\n@@ -102,19 +99,25 @@ private constructor(private val app: Application, private val groupName: String)\n             }\n         }\n \n-        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n-\n-        value = permGroup\n-\n-        val packageNames =\n-            permissionInfos.values.map { permInfo -> permInfo.packageName }.toMutableSet()\n+        val packageNames = permInfos.map { permInfo -> permInfo.packageName }.toMutableSet()\n         packageNames.add(groupInfo.packageName)\n-\n         // TODO ntmyren: What if the package isn't installed for the system user?\n         val getLiveData = { packageName: String ->\n             LightPackageInfoLiveData[packageName, UserHandle.SYSTEM]\n         }\n         setSourcesToDifference(packageNames, packageLiveDatas, getLiveData)\n+        if (!packageLiveDatas.all { it.value.isInitialized }) {\n+            return\n+        }\n+        for (permInfo in permInfos) {\n+            val lightPackageInfo = packageLiveDatas[permInfo.packageName]?.value\n+            val isSystem =\n+                lightPackageInfo?.let { it.appFlags and ApplicationInfo.FLAG_SYSTEM != 0 }\n+            permissionInfos[permInfo.name] = LightPermInfo(permInfo, isSystem)\n+        }\n+\n+        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n+        value = permGroup\n     }\n \n     override fun onInactive() {\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\nindex a5736ca83a..61a604de85 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n@@ -20,6 +20,7 @@ import android.Manifest\n import android.Manifest.permission.ACCESS_COARSE_LOCATION\n import android.os.Build\n import android.os.UserHandle\n+import com.android.permissioncontroller.permission.utils.Utils\n \n /**\n  * A lightweight version of the AppPermissionGroup data structure. Represents information about a\n@@ -75,10 +76,13 @@ data class LightAppPermGroup(\n         get() =\n             permissions.mapNotNull { (name, _) -> if (name !in backgroundPermNames) name else null }\n \n+    val isPlatformPermissionGroup = permGroupInfo.packageName == Utils.OS_PKG\n+\n     val foreground =\n         AppPermSubGroup(\n             permissions.filter { it.key in foregroundPermNames },\n             packageInfo,\n+            isPlatformPermissionGroup,\n             specialLocationGrant\n         )\n \n@@ -86,6 +90,7 @@ data class LightAppPermGroup(\n         AppPermSubGroup(\n             permissions.filter { it.key in backgroundPermNames },\n             packageInfo,\n+            isPlatformPermissionGroup,\n             specialLocationGrant\n         )\n \n@@ -123,7 +128,7 @@ data class LightAppPermGroup(\n     val isOneTime =\n         (permGroupName != Manifest.permission_group.LOCATION &&\n             permissions.any { it.value.isOneTime } &&\n-            permissions.none { !it.value.isOneTime && it.value.isGrantedIncludingAppOp }) ||\n+            permissions.none { !it.value.isOneTime && it.value.isGranted }) ||\n             (permGroupName == Manifest.permission_group.LOCATION &&\n                 permissions[ACCESS_COARSE_LOCATION]?.isOneTime == true)\n \n@@ -160,16 +165,24 @@ data class LightAppPermGroup(\n      *\n      * @param permissions The permissions contained within this subgroup, a subset of those\n      *   contained in the full group\n+     * @param isPlatformPermissionGroup Whether this is a platform permission group\n      * @param specialLocationGrant Whether this is a special location package\n      */\n     data class AppPermSubGroup\n     internal constructor(\n         private val permissions: Map<String, LightPermission>,\n         private val packageInfo: LightPackageInfo,\n+        private val isPlatformPermissionGroup: Boolean,\n         private val specialLocationGrant: Boolean?\n     ) {\n         /** Whether any of this App Permission SubGroup's permissions are granted */\n-        val isGranted = specialLocationGrant ?: permissions.any { it.value.isGrantedIncludingAppOp }\n+        val isGranted =\n+            specialLocationGrant\n+                ?: permissions.any {\n+                    val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                    it.value.isGranted && mayGrantByPlatformOrSystem\n+                }\n \n         /**\n          * Whether this App Permission SubGroup should be treated as granted. This means either:\n@@ -178,14 +191,13 @@ data class LightAppPermGroup(\n          * 2) All permissions were auto-granted (all permissions are all granted and all\n          *    RevokeWhenRequested.)\n          */\n-        val isGrantedExcludingRWROrAllRWR =\n+        val allowFullGroupGrant =\n             specialLocationGrant\n                 ?: (permissions.any {\n-                    it.value.isGrantedIncludingAppOp && !it.value.isRevokeWhenRequested\n-                } ||\n-                    permissions.all {\n-                        it.value.isGrantedIncludingAppOp && it.value.isRevokeWhenRequested\n-                    })\n+                    val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                    it.value.allowFullGroupGrant && mayGrantByPlatformOrSystem\n+                } || permissions.all { it.value.isGranted && it.value.isRevokeWhenRequested })\n \n         /** Whether any of this App Permission SubGroup's permissions are granted by default */\n         val isGrantedByDefault = permissions.any { it.value.isGrantedByDefault }\n@@ -196,7 +208,7 @@ data class LightAppPermGroup(\n          */\n         val isOneTime =\n             permissions.any { it.value.isOneTime } &&\n-                permissions.none { it.value.isGrantedIncludingAppOp && !it.value.isOneTime }\n+                permissions.none { it.value.isGranted && !it.value.isOneTime }\n \n         /**\n          * Whether any of this App Permission Subgroup's foreground permissions are fixed by policy\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\nindex ab8afae08f..32bc3c5268 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n@@ -61,7 +61,9 @@ data class LightPackageInfo(\n         pI: PackageInfo\n     ) : this(\n         pI.packageName,\n-        pI.permissions?.map { perm -> LightPermInfo(perm) } ?: emptyList(),\n+        pI.permissions?.map { perm ->\n+            LightPermInfo(perm, pI.applicationInfo!!.flags and ApplicationInfo.FLAG_SYSTEM != 0)\n+        } ?: emptyList(),\n         pI.requestedPermissions?.toList() ?: emptyList(),\n         pI.requestedPermissionsFlags?.toList() ?: emptyList(),\n         pI.applicationInfo!!.uid,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\nindex c1d2710986..a25dcc24ba 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n@@ -30,6 +30,7 @@ import android.content.pm.PermissionInfo\n  * @param protection The protection level of this permission\n  * @param protection Extra information about the protection of this permission\n  * @param flags The system flags of this permission\n+ * @param isSystem Whether this permission is defined by a system app\n  */\n data class LightPermInfo(\n     val name: String,\n@@ -38,10 +39,12 @@ data class LightPermInfo(\n     val backgroundPermission: String?,\n     val protection: Int,\n     val protectionFlags: Int,\n-    val flags: Int\n+    val flags: Int,\n+    val isSystem: Boolean?,\n ) {\n     constructor(\n-        permInfo: PermissionInfo\n+        permInfo: PermissionInfo,\n+        isSystem: Boolean?\n     ) : this(\n         permInfo.name,\n         permInfo.packageName,\n@@ -49,7 +52,8 @@ data class LightPermInfo(\n         permInfo.backgroundPermission,\n         permInfo.protection,\n         permInfo.protectionFlags,\n-        permInfo.flags\n+        permInfo.flags,\n+        isSystem\n     )\n \n     /**\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\nindex 7492ea6e02..66a0765512 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n@@ -28,8 +28,8 @@ import com.android.permissioncontroller.permission.utils.Utils\n  *\n  * @param pkgInfo The package requesting the permission\n  * @param permInfo The permissionInfo this represents\n- * @param isGrantedIncludingAppOp Whether or not this permission is functionally granted. A\n- *   non-granted app op but granted permission is counted as not granted\n+ * @param isGranted Whether or not this permission is functionally granted. A non-granted app op but\n+ *   granted permission is counted as not granted\n  * @param flags The PermissionController flags for this permission\n  * @param foregroundPerms The foreground permission names corresponding to this permission, if this\n  *   permission is a background permission\n@@ -37,7 +37,7 @@ import com.android.permissioncontroller.permission.utils.Utils\n data class LightPermission(\n     val pkgInfo: LightPackageInfo,\n     val permInfo: LightPermInfo,\n-    val isGrantedIncludingAppOp: Boolean,\n+    val isGranted: Boolean,\n     val flags: Int,\n     val foregroundPerms: List<String>?\n ) {\n@@ -98,9 +98,9 @@ data class LightPermission(\n     /** Whether this permission is user sensitive in its current grant state */\n     val isUserSensitive =\n         !isRuntimePlatformPermission(permInfo.name) ||\n-            (isGrantedIncludingAppOp &&\n+            (isGranted &&\n                 (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED) != 0) ||\n-            (!isGrantedIncludingAppOp &&\n+            (!isGranted &&\n                 (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED) != 0)\n     /** Whether the permission is restricted */\n     val isRestricted =\n@@ -122,10 +122,17 @@ data class LightPermission(\n      */\n     val isSelectedLocationAccuracy =\n         flags and PackageManager.FLAG_PERMISSION_SELECTED_LOCATION_ACCURACY != 0\n+    /** Whether this permission is defined by platform or a system app */\n+    val isPlatformOrSystem = permInfo.packageName == Utils.OS_PKG || permInfo.isSystem == true\n+    /**\n+     * Whether this permission is granted including app op and does not hold the\n+     * PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED flag.\n+     */\n+    val allowFullGroupGrant = isGranted && !isRevokeWhenRequested\n \n     override fun toString() = buildString {\n         append(name)\n-        if (isGrantedIncludingAppOp) append(\", Granted\") else append(\", NotGranted\")\n+        if (isGranted) append(\", Granted\") else append(\", NotGranted\")\n         if (isPolicyFixed) append(\", PolicyFixed\")\n         if (isSystemFixed) append(\", SystemFixed\")\n         if (isUserFixed) append(\", UserFixed\")\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\nindex cfe753019a..aae2aa2120 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n@@ -132,7 +132,7 @@ suspend fun revokeAppPermissions(\n                 val fixed = group.isBackgroundFixed || group.isForegroundFixed\n                 val granted =\n                     group.permissions.any { (_, perm) ->\n-                        perm.isGrantedIncludingAppOp && perm.name !in AUTO_REVOKE_EXEMPT_PERMISSIONS\n+                        perm.isGranted && perm.name !in AUTO_REVOKE_EXEMPT_PERMISSIONS\n                     }\n                 if (\n                     !fixed &&\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\nindex af3b607023..2734116dd0 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n@@ -492,7 +492,7 @@ object RuntimePermissionsUpgradeController {\n                     LightPermission(\n                         perm.pkgInfo,\n                         perm.permInfo,\n-                        perm.isGrantedIncludingAppOp,\n+                        perm.isGranted,\n                         perm.flags or FLAG_PERMISSION_RESTRICTION_UPGRADE_EXEMPT,\n                         perm.foregroundPerms\n                     )\n@@ -569,7 +569,7 @@ object RuntimePermissionsUpgradeController {\n                         !perm.isUserSet &&\n                             !perm.isSystemFixed &&\n                             !perm.isPolicyFixed &&\n-                            !perm.isGrantedIncludingAppOp\n+                            !perm.isGranted\n                     ) {\n                         grants.add(\n                             Grant(false, appPermGroup, listOf(permission.ACCESS_MEDIA_LOCATION))\n@@ -670,7 +670,7 @@ object RuntimePermissionsUpgradeController {\n                         LightPermission(\n                             perm.pkgInfo,\n                             perm.permInfo,\n-                            perm.isGrantedIncludingAppOp,\n+                            perm.isGranted,\n                             perm.flags or FLAG_PERMISSION_RESTRICTION_UPGRADE_EXEMPT,\n                             perm.foregroundPerms\n                         )\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nindex 5a7c3f2b54..14f3497772 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -267,11 +267,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n \ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\nindex 5b6d8b8db7..1f0a41c59f 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n@@ -325,6 +325,7 @@ class AppPermissionViewModel(\n \n         private val mainLocListener = { isEnabled: Boolean -> checkAndUpdateStatus(!isEnabled) }\n         private val locBypassListener = { _: Boolean -> checkAndUpdateStatus() }\n+\n         override fun onUpdate() {\n             checkAndUpdateStatus()\n         }\n@@ -692,8 +693,7 @@ class AppPermissionViewModel(\n                 app,\n                 packageName,\n                 permGroupName\n-            )\n-                ?: return\n+            ) ?: return\n         fragment.startActivity(restrictionIntent)\n     }\n \n@@ -726,10 +726,8 @@ class AppPermissionViewModel(\n             // 2. Else if FINE or COARSE have the isSelectedLocationAccuracy flag set, then return\n             //    true if FINE isSelectedLocationAccuracy is set.\n             // 3. Else, return default precision from device config.\n-            return if (\n-                fineLocation.isGrantedIncludingAppOp || coarseLocation.isGrantedIncludingAppOp\n-            ) {\n-                fineLocation.isGrantedIncludingAppOp\n+            return if (fineLocation.isGranted || coarseLocation.isGranted) {\n+                fineLocation.isGranted\n             } else if (\n                 fineLocation.isSelectedLocationAccuracy || coarseLocation.isSelectedLocationAccuracy\n             ) {\n@@ -1381,9 +1379,7 @@ class AppPermissionViewModel(\n     }\n \n     private fun getIndividualPermissionDetailResId(group: LightAppPermGroup): Pair<Int, Int> {\n-        return when (\n-            val numRevoked = group.permissions.filter { !it.value.isGrantedIncludingAppOp }.size\n-        ) {\n+        return when (val numRevoked = group.permissions.filter { !it.value.isGranted }.size) {\n             0 -> R.string.permission_revoked_none to numRevoked\n             group.permissions.size -> R.string.permission_revoked_all to numRevoked\n             else -> R.string.permission_revoked_count to numRevoked\n@@ -1454,7 +1450,7 @@ class AppPermissionViewModel(\n             val newPermission = newGroup.permissions[permName] ?: continue\n \n             if (\n-                permission.isGrantedIncludingAppOp != newPermission.isGrantedIncludingAppOp ||\n+                permission.isGranted != newPermission.isGranted ||\n                     permission.flags != newPermission.flags\n             ) {\n                 logAppPermissionFragmentActionReported(changeId, newPermission, buttonPressed)\n@@ -1462,7 +1458,7 @@ class AppPermissionViewModel(\n                     app.applicationContext,\n                     packageName,\n                     permGroupName,\n-                    newPermission.isGrantedIncludingAppOp\n+                    newPermission.isGranted\n                 )\n                 PermissionChangeStorageImpl.recordPermissionChange(packageName)\n             }\n@@ -1492,7 +1488,7 @@ class AppPermissionViewModel(\n             uid,\n             packageName,\n             permission.permInfo.name,\n-            permission.isGrantedIncludingAppOp,\n+            permission.isGranted,\n             permission.flags,\n             buttonPressed\n         )\n@@ -1502,7 +1498,7 @@ class AppPermissionViewModel(\n                 \"$changeId uid=$uid packageName=$packageName permission=\" +\n                 permission.permInfo.name +\n                 \" isGranted=\" +\n-                permission.isGrantedIncludingAppOp +\n+                permission.isGranted +\n                 \" permissionFlags=\" +\n                 permission.flags +\n                 \" buttonPressed=$buttonPressed\"\n@@ -1544,7 +1540,7 @@ class AppPermissionViewModel(\n \n         return group.isGranted &&\n             group.permissions.values.all {\n-                it.name in partialPerms || (it.name !in partialPerms && !it.isGrantedIncludingAppOp)\n+                it.name in partialPerms || (it.name !in partialPerms && !it.isGranted)\n             }\n     }\n }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\nindex b5df6f4102..0a01929e6c 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n@@ -338,7 +338,7 @@ class GrantPermissionsViewModel(\n                     if (state != null) {\n                         val allAffectedGranted =\n                             state.affectedPermissions.all { perm ->\n-                                appPermGroup.permissions[perm]?.isGrantedIncludingAppOp == true &&\n+                                appPermGroup.permissions[perm]?.isGranted == true &&\n                                     appPermGroup.permissions[perm]?.isRevokeWhenRequested == false\n                             }\n                         if (allAffectedGranted) {\n@@ -592,7 +592,7 @@ class GrantPermissionsViewModel(\n \n         val behavior = getGrantBehavior(group)\n         return if (behavior.isGroupFullyGranted(group, groupRequestedPermissions)) {\n-            if (group.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+            if (group.permissions[perm]?.isGranted == false) {\n                 if (isBackground) {\n                     grantBackgroundRuntimePermissions(app, group, listOf(perm))\n                 } else {\n@@ -864,18 +864,15 @@ class GrantPermissionsViewModel(\n                 } else {\n                     PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_GRANTED\n                 }\n+            var affectedPermissions: Collection<String> = groupState.affectedPermissions\n             if (shouldAffectBackgroundPermissions) {\n-                grantBackgroundRuntimePermissions(\n-                    app,\n-                    groupState.group,\n-                    groupState.affectedPermissions\n-                )\n+                grantBackgroundRuntimePermissions(app, groupState.group, affectedPermissions)\n             } else if (shouldAffectForegroundPermssions) {\n                 if (affectedForegroundPermissions == null) {\n                     grantForegroundRuntimePermissions(\n                         app,\n                         groupState.group,\n-                        groupState.affectedPermissions,\n+                        affectedPermissions,\n                         isOneTime\n                     )\n                     // This prevents weird flag state when app targetSDK switches from S+ to R-\n@@ -883,11 +880,12 @@ class GrantPermissionsViewModel(\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(app, groupState.group, true)\n                     }\n                 } else {\n+                    affectedPermissions = affectedForegroundPermissions\n                     val newGroup =\n                         grantForegroundRuntimePermissions(\n                             app,\n                             groupState.group,\n-                            affectedForegroundPermissions,\n+                            affectedPermissions,\n                             isOneTime\n                         )\n                     if (!isOneTime || newGroup.isOneTime) {\n@@ -899,7 +897,17 @@ class GrantPermissionsViewModel(\n                     }\n                 }\n             }\n-            groupState.state = STATE_GRANTED\n+            val shouldDenyFullGroupGrant =\n+                groupState.group.isPlatformPermissionGroup &&\n+                    affectedPermissions.none {\n+                        groupState.group.permissions[it]?.isPlatformOrSystem == true\n+                    }\n+            groupState.state =\n+                if (shouldDenyFullGroupGrant) {\n+                    STATE_UNKNOWN\n+                } else {\n+                    STATE_GRANTED\n+                }\n         } else {\n             if (shouldAffectBackgroundPermissions) {\n                 revokeBackgroundRuntimePermissions(\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\nindex 8613d1cae6..ecb551ffc8 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\n@@ -133,7 +133,7 @@ class ReviewPermissionsViewModel(val app: Application, val packageInfo: PackageI\n         val lightPerms = permGroup.allPermissions.values.toList()\n         val permissionCount = lightPerms.size\n         for (i in 0 until permissionCount) {\n-            if (!lightPerms[i].isGrantedIncludingAppOp) {\n+            if (!lightPerms[i].isGranted) {\n                 revokedCount++\n             }\n         }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/BackgroundGrantBehavior.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/BackgroundGrantBehavior.kt\nindex 6234b27557..7112d180f3 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/BackgroundGrantBehavior.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/BackgroundGrantBehavior.kt\n@@ -57,7 +57,7 @@ object BackgroundGrantBehavior : GrantBehavior() {\n         val requestsBg = hasBgPerms(group, requestedPerms)\n         val requestsFg = requestedPerms.any { it !in group.backgroundPermNames }\n         val isOneTimeGroup = PermissionMapping.supportsOneTimeGrant(group.permGroupName)\n-        val isFgGranted = group.foreground.isGrantedExcludingRWROrAllRWR\n+        val isFgGranted = group.foreground.allowFullGroupGrant\n         val isFgOneTime = group.foreground.isOneTime\n         val splitSdk = getSdkGroupWasSplitToBg(requestedPerms)\n         val isAppIsOlderThanSplitToBg = group.packageInfo.targetSdkVersion < splitSdk\n@@ -171,16 +171,15 @@ object BackgroundGrantBehavior : GrantBehavior() {\n         group: LightAppPermGroup,\n         requestedPerms: Set<String>\n     ): Boolean {\n-        return (!hasBgPerms(group, requestedPerms) ||\n-            group.background.isGrantedExcludingRWROrAllRWR) &&\n-            group.foreground.isGrantedExcludingRWROrAllRWR\n+        return (!hasBgPerms(group, requestedPerms) || group.background.allowFullGroupGrant) &&\n+            group.foreground.allowFullGroupGrant\n     }\n \n     override fun isForegroundFullyGranted(\n         group: LightAppPermGroup,\n         requestedPerms: Set<String>\n     ): Boolean {\n-        return group.foreground.isGrantedExcludingRWROrAllRWR\n+        return group.foreground.allowFullGroupGrant\n     }\n \n     override fun isPermissionFixed(group: LightAppPermGroup, perm: String): Boolean {\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/GrantBehavior.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/GrantBehavior.kt\nindex 3b3619084d..54d6dc0f36 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/GrantBehavior.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/GrantBehavior.kt\n@@ -58,7 +58,7 @@ abstract class GrantBehavior {\n      * group not already granted will be granted.\n      */\n     open fun isGroupFullyGranted(group: LightAppPermGroup, requestedPerms: Set<String>): Boolean {\n-        return group.foreground.isGrantedExcludingRWROrAllRWR\n+        return group.foreground.allowFullGroupGrant\n     }\n \n     /**\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/HealthGrantBehavior.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/HealthGrantBehavior.kt\nindex 8e540701a6..4f5def312b 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/HealthGrantBehavior.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/HealthGrantBehavior.kt\n@@ -47,7 +47,7 @@ object HealthGrantBehavior : GrantBehavior() {\n         group: LightAppPermGroup,\n         requestedPerms: Set<String>\n     ): Boolean {\n-        return requestedPerms.all { group.permissions[it]?.isGrantedIncludingAppOp != false }\n+        return requestedPerms.all { group.permissions[it]?.isGranted != false }\n     }\n \n     override fun isPermissionFixed(group: LightAppPermGroup, perm: String): Boolean {\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/LocationGrantBehavior.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/LocationGrantBehavior.kt\nindex 2c5e2b7324..31ac04cab8 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/LocationGrantBehavior.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/LocationGrantBehavior.kt\n@@ -37,8 +37,7 @@ object LocationGrantBehavior : GrantBehavior() {\n     ): Prompt {\n         val backgroundPrompt = BackgroundGrantBehavior.getPrompt(group, requestedPerms)\n         val requestsBackground = requestedPerms.any { it in group.backgroundPermNames }\n-        val coarseGranted =\n-            group.permissions[ACCESS_COARSE_LOCATION]?.isGrantedIncludingAppOp == true\n+        val coarseGranted = group.permissions[ACCESS_COARSE_LOCATION]?.isGranted == true\n         return if (!supportsLocationAccuracy(group) || requestsBackground) {\n             backgroundPrompt\n         } else if (requestedPerms.contains(ACCESS_FINE_LOCATION)) {\n@@ -84,10 +83,10 @@ object LocationGrantBehavior : GrantBehavior() {\n         }\n \n         if (requestedPerms.contains(ACCESS_FINE_LOCATION)) {\n-            return group.permissions[ACCESS_FINE_LOCATION]?.isGrantedIncludingAppOp == true\n+            return group.permissions[ACCESS_FINE_LOCATION]?.isGranted == true\n         }\n \n-        return group.foreground.isGrantedExcludingRWROrAllRWR\n+        return group.foreground.allowFullGroupGrant\n     }\n \n     override fun isPermissionFixed(group: LightAppPermGroup, perm: String): Boolean {\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/StorageGrantBehavior.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/StorageGrantBehavior.kt\nindex a690f5f598..9dd87674ae 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/StorageGrantBehavior.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/StorageGrantBehavior.kt\n@@ -66,11 +66,11 @@ object StorageGrantBehavior : GrantBehavior() {\n         }\n \n         val userSelectedPerm = group.permissions[READ_MEDIA_VISUAL_USER_SELECTED]\n-        if (userSelectedPerm?.isUserFixed == true && userSelectedPerm.isGrantedIncludingAppOp) {\n+        if (userSelectedPerm?.isUserFixed == true && userSelectedPerm.isGranted) {\n             return Prompt.NO_UI_PHOTO_PICKER_REDIRECT\n         }\n \n-        if (userSelectedPerm?.isGrantedIncludingAppOp == true) {\n+        if (userSelectedPerm?.isGranted == true) {\n             return Prompt.SELECT_MORE_PHOTOS\n         } else {\n             return Prompt.SELECT_PHOTOS\n@@ -97,16 +97,14 @@ object StorageGrantBehavior : GrantBehavior() {\n         }\n \n         return group.permissions.values.any {\n-            it.name !in getPartialGrantPermissions(group) && it.isGrantedIncludingAppOp\n+            it.name !in getPartialGrantPermissions(group) && it.isGranted\n         }\n     }\n \n     override fun isPermissionFixed(group: LightAppPermGroup, perm: String): Boolean {\n         val userSelectedPerm = group.permissions[READ_MEDIA_VISUAL_USER_SELECTED]\n         if (\n-            userSelectedPerm != null &&\n-                userSelectedPerm.isGrantedIncludingAppOp &&\n-                userSelectedPerm.isUserFixed\n+            userSelectedPerm != null && userSelectedPerm.isGranted && userSelectedPerm.isUserFixed\n         ) {\n             // If the user selected permission is fixed and granted, we immediately show the\n             // photo picker, rather than filtering\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\nindex b822aa5418..93c30939d0 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n@@ -771,7 +771,7 @@ object KotlinUtils {\n                 LightPermission(\n                     group.packageInfo,\n                     perm.permInfo,\n-                    perm.isGrantedIncludingAppOp,\n+                    perm.isGranted,\n                     perm.flags or flagsToSet,\n                     perm.foregroundPerms\n                 )\n@@ -904,7 +904,7 @@ object KotlinUtils {\n                 group.specialLocationGrant\n             )\n         // If any permission in the group is one time granted, start one time permission session.\n-        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGrantedIncludingAppOp }) {\n+        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGranted }) {\n             if (SdkLevel.isAtLeastT()) {\n                 context\n                     .getSystemService(PermissionManager::class.java)!!\n@@ -966,7 +966,7 @@ object KotlinUtils {\n \n         var newFlags = perm.flags\n         var oldFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         var shouldKill = false\n \n         // Create a new context with the given deviceId so that permission updates will be bound\n@@ -974,7 +974,7 @@ object KotlinUtils {\n         val context = ContextCompat.createDeviceContext(app.applicationContext, deviceId)\n \n         // Grant the permission if needed.\n-        if (!perm.isGrantedIncludingAppOp) {\n+        if (!perm.isGranted) {\n             val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n             // TODO 195016052: investigate adding split permission handling\n@@ -1043,14 +1043,14 @@ object KotlinUtils {\n \n         // If we newly grant background access to the fine location, double-guess the user some\n         // time later if this was really the right choice.\n-        if (!perm.isGrantedIncludingAppOp && isGranted) {\n+        if (!perm.isGranted && isGranted) {\n             var triggerLocationAccessCheck = false\n             if (perm.name == ACCESS_FINE_LOCATION) {\n                 val bgPerm = group.permissions[perm.backgroundPermission]\n-                triggerLocationAccessCheck = bgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = bgPerm?.isGranted == true\n             } else if (perm.name == ACCESS_BACKGROUND_LOCATION) {\n                 val fgPerm = group.permissions[ACCESS_FINE_LOCATION]\n-                triggerLocationAccessCheck = fgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = fgPerm?.isGranted == true\n             }\n             if (triggerLocationAccessCheck) {\n                 // trigger location access check\n@@ -1289,7 +1289,7 @@ object KotlinUtils {\n         val user = UserHandle.getUserHandleForUid(group.packageInfo.uid)\n         var newFlags = perm.flags\n         val deviceId = group.deviceId\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         val supportsRuntime = group.packageInfo.targetSdkVersion >= Build.VERSION_CODES.M\n         var shouldKill = false\n \n@@ -1299,7 +1299,7 @@ object KotlinUtils {\n         // to the device\n         val context = ContextCompat.createDeviceContext(app.applicationContext, deviceId)\n \n-        if (perm.isGrantedIncludingAppOp || (perm.isCompatRevoked && forceRemoveRevokedCompat)) {\n+        if (perm.isGranted || (perm.isCompatRevoked && forceRemoveRevokedCompat)) {\n             if (\n                 supportsRuntime &&\n                     !isPermissionSplitFromNonRuntime(\n@@ -1363,14 +1363,14 @@ object KotlinUtils {\n \n         // If we revoke background access to the fine location, we trigger a check to remove\n         // notification warning about background location access\n-        if (perm.isGrantedIncludingAppOp && !isGranted) {\n+        if (perm.isGranted && !isGranted) {\n             var cancelLocationAccessWarning = false\n             if (perm.name == ACCESS_FINE_LOCATION) {\n                 val bgPerm = group.permissions[perm.backgroundPermission]\n-                cancelLocationAccessWarning = bgPerm?.isGrantedIncludingAppOp == true\n+                cancelLocationAccessWarning = bgPerm?.isGranted == true\n             } else if (perm.name == ACCESS_BACKGROUND_LOCATION) {\n                 val fgPerm = group.permissions[ACCESS_FINE_LOCATION]\n-                cancelLocationAccessWarning = fgPerm?.isGrantedIncludingAppOp == true\n+                cancelLocationAccessWarning = fgPerm?.isGranted == true\n             }\n             if (cancelLocationAccessWarning) {\n                 // cancel location access warning notification\n@@ -1430,7 +1430,7 @@ object KotlinUtils {\n                 val fgPerm = group.permissions[foregroundPermName]\n                 val appOpName = permissionToOp(foregroundPermName) ?: continue\n \n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     wasChanged =\n                         setOpMode(appOpName, uid, packageName, MODE_ALLOWED, appOpsManager) ||\n                             wasChanged\n@@ -1443,7 +1443,7 @@ object KotlinUtils {\n                     if (group.permissions.containsKey(perm.backgroundPermission)) {\n                         val bgPerm = group.permissions[perm.backgroundPermission]\n                         val mode =\n-                            if (bgPerm != null && bgPerm.isGrantedIncludingAppOp) MODE_ALLOWED\n+                            if (bgPerm != null && bgPerm.isGranted) MODE_ALLOWED\n                             else MODE_FOREGROUND\n \n                         setOpMode(appOpName, uid, packageName, mode, appOpsManager)\n@@ -1490,7 +1490,7 @@ object KotlinUtils {\n         if (perm.isBackgroundPermission && perm.foregroundPerms != null) {\n             for (foregroundPermName in perm.foregroundPerms) {\n                 val fgPerm = group.permissions[foregroundPermName]\n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     val appOpName = permissionToOp(foregroundPermName) ?: return false\n                     wasChanged =\n                         wasChanged ||\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\nindex 828857cc6d..c9b023c443 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n@@ -95,7 +95,7 @@ public final class SafetyNetLogger {\n             }\n \n             builder.append(permission.getName()).append('|');\n-            builder.append(permission.isGrantedIncludingAppOp()).append('|');\n+            builder.append(permission.isGranted()).append('|');\n             builder.append(permission.getFlags());\n         }\n     }\ndiff --git a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\nindex 899a026c42..0e8890df59 100644\n--- a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\n+++ b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\n@@ -104,7 +104,7 @@ class ReviewPermissionsViewModelTest {\n         permissionsMap[\"mockedPermission1\"] = permission2\n \n         whenever(permGroup.allPermissions).thenReturn(permissionsMap)\n-        whenever(permission1.isGrantedIncludingAppOp).thenReturn(true)\n+        whenever(permission1.isGranted).thenReturn(true)\n \n         val summary = model.getSummaryForIndividuallyControlledPermGroup(permGroup)\n         assertEquals(\ndiff --git a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\nindex 8bd61ebe6a..28f69b1369 100644\n--- a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\n+++ b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\n@@ -25,6 +25,7 @@ import android.app.AppOpsManager.MODE_IGNORED\n import android.app.AppOpsManager.permissionToOp\n import android.app.Application\n import android.content.Context\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageManager\n import android.content.pm.PackageManager.FLAG_PERMISSION_AUTO_REVOKED\n import android.content.pm.PackageManager.FLAG_PERMISSION_ONE_TIME\n@@ -216,7 +217,8 @@ class GrantRevokeTests {\n                 backgroundPerm,\n                 PermissionInfo.PROTECTION_DANGEROUS,\n                 permInfoProtectionFlags,\n-                0\n+                0,\n+                pkgInfo.appFlags and ApplicationInfo.FLAG_SYSTEM != 0\n             )\n         return LightPermission(\n             pkgInfo,\n@@ -292,7 +294,7 @@ class GrantRevokeTests {\n             val flags = state.second\n \n             assertWithMessage(\"permission $permName grant state incorrect\")\n-                .that(perms[permName]?.isGrantedIncludingAppOp)\n+                .that(perms[permName]?.isGranted)\n                 .isEqualTo(granted)\n \n             val actualFlags = perms[permName]!!.flags\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 0,
                    "failed_patches": 4,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "6843ffaa44ed01868c9b67bfc1c13bac4c2bd71a",
                            "result": "failure",
                            "downstream_patch_content": "commit 6843ffaa44ed01868c9b67bfc1c13bac4c2bd71a\nAuthor: Yi-an Chen <theianchen@google.com>\nDate:   Thu Aug 8 01:15:57 2024 +0000\n\n    RESTRICT AUTOMERGE Fix Dynamic Permission group auto grant behaivor\n    \n    Fix the Dynamic Permission group auto grant behaivor so that a\n    permission group is only considered granted when (1) all permissions\n    were auto-granted or (2) a platform permission in the same group is\n    granted.\n    \n    Bug: 340480881\n    Test: DynamicPermissionsTest\n    Change-Id: I37b550f0c3933bc790c2917a14e917efbcccc4e8\n    Merged-In: I37b550f0c3933bc790c2917a14e917efbcccc4e8\n\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\nindex 97389b0984..bf43f15c3f 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n@@ -66,7 +66,7 @@ class LightPermInfoLiveData private constructor(\n         }\n \n         val newValue = try {\n-            LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0))\n+            LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0), null)\n         } catch (e: PackageManager.NameNotFoundException) {\n             Log.w(LOG_TAG, \"Permission \\\"$permissionName\\\" not found\")\n             invalidateSingle(permissionName)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\nindex 78f2f72c63..948815646a 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n@@ -17,6 +17,7 @@\n package com.android.permissioncontroller.permission.data\n \n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageItemInfo\n import android.content.pm.PackageManager\n import android.content.pm.PermissionGroupInfo\n@@ -68,32 +69,31 @@ class PermGroupLiveData private constructor(\n      */\n     override fun onUpdate() {\n         val permissionInfos = mutableMapOf<String, LightPermInfo>()\n-\n         groupInfo = Utils.getGroupInfo(groupName, context) ?: run {\n             Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n             invalidateSingle(groupName)\n             value = null\n             return\n         }\n-\n+        val permInfos = mutableListOf<PermissionInfo>()\n         when (groupInfo) {\n             is PermissionGroupInfo -> {\n-                val permInfos = try {\n-                    Utils.getInstalledRuntimePermissionInfosForGroup(context.packageManager,\n-                        groupName)\n+                try {\n+                    permInfos.addAll(\n+                        Utils.getInstalledRuntimePermissionInfosForGroup(\n+                            context.packageManager,\n+                            groupName\n+                        )\n+                    )\n                 } catch (e: PackageManager.NameNotFoundException) {\n                     Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n                     invalidateSingle(groupName)\n                     value = null\n                     return\n                 }\n-\n-                for (permInfo in permInfos) {\n-                    permissionInfos[permInfo.name] = LightPermInfo(permInfo)\n-                }\n             }\n             is PermissionInfo -> {\n-                permissionInfos[groupInfo.name] = LightPermInfo(groupInfo as PermissionInfo)\n+                permInfos.add(groupInfo as PermissionInfo)\n             }\n             else -> {\n                 value = null\n@@ -101,19 +101,25 @@ class PermGroupLiveData private constructor(\n             }\n         }\n \n-        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n-\n-        value = permGroup\n-\n-        val packageNames = permissionInfos.values.map { permInfo -> permInfo.packageName }\n-            .toMutableSet()\n+        val packageNames = permInfos.map { permInfo -> permInfo.packageName }.toMutableSet()\n         packageNames.add(groupInfo.packageName)\n-\n         // TODO ntmyren: What if the package isn't installed for the system user?\n         val getLiveData = { packageName: String ->\n             LightPackageInfoLiveData[packageName, UserHandle.SYSTEM]\n         }\n         setSourcesToDifference(packageNames, packageLiveDatas, getLiveData)\n+        if (!packageLiveDatas.all { it.value.isInitialized }) {\n+            return\n+        }\n+        for (permInfo in permInfos) {\n+            val lightPackageInfo = packageLiveDatas[permInfo.packageName]?.value\n+            val isSystem =\n+                lightPackageInfo?.let { it.appFlags and ApplicationInfo.FLAG_SYSTEM != 0 }\n+            permissionInfos[permInfo.name] = LightPermInfo(permInfo, isSystem)\n+        }\n+\n+        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n+        value = permGroup\n     }\n \n     override fun onInactive() {\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\nindex cbfac4b244..1d807292ad 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n@@ -20,6 +20,7 @@ import android.Manifest\n import android.Manifest.permission.ACCESS_COARSE_LOCATION\n import android.os.Build\n import android.os.UserHandle\n+import com.android.permissioncontroller.permission.utils.Utils\n \n /**\n  * A lightweight version of the AppPermissionGroup data structure. Represents information about a\n@@ -79,11 +80,13 @@ data class LightAppPermGroup(\n         if (name !in backgroundPermNames) name else null\n     }\n \n+    val isPlatformPermissionGroup = permGroupInfo.packageName == Utils.OS_PKG\n+\n     val foreground = AppPermSubGroup(permissions.filter { it.key in foregroundPermNames },\n-        packageInfo, specialLocationGrant)\n+        packageInfo, isPlatformPermissionGroup, specialLocationGrant)\n \n     val background = AppPermSubGroup(permissions.filter { it.key in backgroundPermNames },\n-        packageInfo, specialLocationGrant)\n+        packageInfo, isPlatformPermissionGroup, specialLocationGrant)\n \n     /**\n      * Whether or not this App Permission Group has a permission which has a background mode\n@@ -152,24 +155,34 @@ data class LightAppPermGroup(\n      *\n      * @param permissions The permissions contained within this subgroup, a subset of those contained\n      * in the full group\n+     * @param isPlatformPermissionGroup Whether this is a platform permission group\n      * @param specialLocationGrant Whether this is a special location package\n      */\n     data class AppPermSubGroup internal constructor(\n         private val permissions: Map<String, LightPermission>,\n         private val packageInfo: LightPackageInfo,\n+        private val isPlatformPermissionGroup: Boolean,\n         private val specialLocationGrant: Boolean?\n     ) {\n-        /**\n-         * Whether any of this App Permission SubGroup's permissions are granted\n-         */\n-        val isGranted = specialLocationGrant ?: permissions.any { it.value.isGrantedIncludingAppOp }\n+        /** Whether any of this App Permission SubGroup's permissions are granted */\n+        val isGranted =\n+            specialLocationGrant\n+                ?: permissions.any {\n+                    val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                    it.value.isGranted && mayGrantByPlatformOrSystem\n+                }\n \n         /**\n          * Whether any of this App Permission SubGroup's permissions are granted excluding\n          * auto granted permissions during install time with flag RevokeWhenRequested\n          */\n-        val isGrantedExcludeRevokeWhenRequestedPermissions = specialLocationGrant ?: permissions\n-            .any { it.value.isGrantedIncludingAppOp && !it.value.isRevokeWhenRequested }\n+        val allowFullGroupGrant = specialLocationGrant ?: permissions\n+            .any {\n+                val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                it.value.allowFullGroupGrant && mayGrantByPlatformOrSystem\n+            }\n \n         /**\n          * Whether any of this App Permission SubGroup's permissions are granted by default\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\nindex 182de1a597..a37a47163f 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n@@ -49,7 +49,9 @@ data class LightPackageInfo(\n     val firstInstallTime: Long\n ) {\n     constructor(pI: PackageInfo) : this(pI.packageName,\n-        pI.permissions?.map { perm -> LightPermInfo(perm) } ?: emptyList(),\n+        pI.permissions?.map { perm ->\n+            LightPermInfo(perm, pI.applicationInfo!!.flags and ApplicationInfo.FLAG_SYSTEM != 0)\n+        } ?: emptyList(),\n         pI.requestedPermissions?.toList() ?: emptyList(),\n         pI.requestedPermissionsFlags?.toList() ?: emptyList(),\n         pI.applicationInfo.uid, pI.applicationInfo.targetSdkVersion,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\nindex 3954b74722..582742da43 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n@@ -30,6 +30,7 @@ import android.content.pm.PermissionInfo\n  * @param protection The protection level of this permission\n  * @param protection Extra information about the protection of this permission\n  * @param flags The system flags of this permission\n+ * @param isSystem Whether this permission is defined by a system app\n  */\n data class LightPermInfo(\n     val name: String,\n@@ -38,11 +39,13 @@ data class LightPermInfo(\n     val backgroundPermission: String?,\n     val protection: Int,\n     val protectionFlags: Int,\n-    val flags: Int\n+    val flags: Int,\n+    val isSystem: Boolean?\n ) {\n-    constructor (permInfo: PermissionInfo): this(permInfo.name, permInfo.packageName,\n-        permInfo.group, permInfo.backgroundPermission, permInfo.protection,\n-        permInfo.protectionFlags, permInfo.flags)\n+    constructor (permInfo: PermissionInfo, isSystem: Boolean?) : this(\n+        permInfo.name, permInfo.packageName, permInfo.group, permInfo.backgroundPermission,\n+        permInfo.protection, permInfo.protectionFlags, permInfo.flags, isSystem\n+    )\n \n     /**\n      * Gets the PermissionInfo for this permission from the system.\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\nindex c3d087fd24..45c3b1e92a 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n@@ -27,7 +27,7 @@ import com.android.permissioncontroller.permission.utils.Utils.isRuntimePlatform\n  *\n  * @param pkgInfo The package requesting the permission\n  * @param permInfo The permissionInfo this represents\n- * @param isGrantedIncludingAppOp Whether or not this permission is functionally granted.\n+ * @param isGranted Whether or not this permission is functionally granted.\n  * A non-granted app op but granted permission is counted as not granted\n  * @param flags The PermissionController flags for this permission\n  * @param foregroundPerms The foreground permission names corresponding to this permission, if this\n@@ -36,7 +36,7 @@ import com.android.permissioncontroller.permission.utils.Utils.isRuntimePlatform\n data class LightPermission(\n     val pkgInfo: LightPackageInfo,\n     val permInfo: LightPermInfo,\n-    val isGrantedIncludingAppOp: Boolean,\n+    val isGranted: Boolean,\n     val flags: Int,\n     val foregroundPerms: List<String>?\n ) {\n@@ -82,9 +82,9 @@ data class LightPermission(\n     val isRevokeWhenRequested = flags and PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED != 0\n     /** Whether this permission is user sensitive in its current grant state */\n     val isUserSensitive = !isRuntimePlatformPermission(permInfo.name) ||\n-            (isGrantedIncludingAppOp &&\n+            (isGranted &&\n                     (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED) != 0) ||\n-            (!isGrantedIncludingAppOp &&\n+            (!isGranted &&\n                     (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED) != 0)\n     /** Whether the permission is restricted */\n     val isRestricted = when {\n@@ -105,10 +105,17 @@ data class LightPermission(\n      */\n     val isSelectedLocationAccuracy =\n         flags and PackageManager.FLAG_PERMISSION_SELECTED_LOCATION_ACCURACY != 0\n+    /** Whether this permission is defined by platform or a system app */\n+    val isPlatformOrSystem = permInfo.packageName == Utils.OS_PKG || permInfo.isSystem == true\n+    /**\n+     * Whether this permission is granted including app op and does not hold the\n+     * PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED flag.\n+     */\n+    val allowFullGroupGrant = isGranted && !isRevokeWhenRequested\n \n     override fun toString() = buildString {\n         append(name)\n-        if (isGrantedIncludingAppOp) append(\", Granted\") else append(\", NotGranted\")\n+        if (isGranted) append(\", Granted\") else append(\", NotGranted\")\n         if (isPolicyFixed) append(\", PolicyFixed\")\n         if (isSystemFixed) append(\", SystemFixed\")\n         if (isUserFixed) append(\", UserFixed\")\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\nindex d57e797519..92bfa887e8 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n@@ -93,7 +93,7 @@ suspend fun revokeAppPermissions(\n \n                 val fixed = group.isBackgroundFixed || group.isForegroundFixed\n                 val granted = group.permissions.any { (_, perm) ->\n-                    perm.isGrantedIncludingAppOp && perm.name !in EXEMPT_PERMISSIONS\n+                    perm.isGranted && perm.name !in EXEMPT_PERMISSIONS\n                 }\n                 if (!fixed &&\n                     granted &&\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\nindex c22e5dd422..6369eeada3 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n@@ -382,7 +382,7 @@ internal object RuntimePermissionsUpgradeController {\n \n                 val allPermissionsWithxemption = bgApp.allPermissions.toMutableMap()\n                 allPermissionsWithxemption[permission.ACCESS_BACKGROUND_LOCATION] =\n-                        LightPermission(perm.pkgInfo, perm.permInfo, perm.isGrantedIncludingAppOp,\n+                        LightPermission(perm.pkgInfo, perm.permInfo, perm.isGranted,\n                         perm.flags or FLAG_PERMISSION_RESTRICTION_UPGRADE_EXEMPT,\n                         perm.foregroundPerms)\n \n@@ -444,7 +444,7 @@ internal object RuntimePermissionsUpgradeController {\n                             ?: continue\n \n                     if (!perm.isUserSet && !perm.isSystemFixed && !perm.isPolicyFixed &&\n-                            !perm.isGrantedIncludingAppOp) {\n+                            !perm.isGranted) {\n                         grants.add(Grant(false, appPermGroup,\n                                 listOf(permission.ACCESS_MEDIA_LOCATION)))\n                     }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\nindex 05c5849f06..244fdd2bb2 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n@@ -698,7 +698,7 @@ class AppPermissionViewModel(\n \n     private fun getIndividualPermissionDetailResId(group: LightAppPermGroup): Pair<Int, Int> {\n         return when (val numRevoked =\n-            group.permissions.filter { !it.value.isGrantedIncludingAppOp }.size) {\n+            group.permissions.filter { !it.value.isGranted }.size) {\n             0 -> R.string.permission_revoked_none to numRevoked\n             group.permissions.size -> R.string.permission_revoked_all to numRevoked\n             else -> R.string.permission_revoked_count to numRevoked\n@@ -767,7 +767,7 @@ class AppPermissionViewModel(\n         for ((permName, permission) in oldGroup.permissions) {\n             val newPermission = newGroup.permissions[permName] ?: continue\n \n-            if (permission.isGrantedIncludingAppOp != newPermission.isGrantedIncludingAppOp ||\n+            if (permission.isGranted != newPermission.isGranted ||\n                 permission.flags != newPermission.flags) {\n                 logAppPermissionFragmentActionReported(changeId, newPermission, buttonPressed)\n             }\n@@ -782,10 +782,10 @@ class AppPermissionViewModel(\n         val uid = KotlinUtils.getPackageUid(app, packageName, user) ?: return\n         PermissionControllerStatsLog.write(APP_PERMISSION_FRAGMENT_ACTION_REPORTED, sessionId,\n             changeId, uid, packageName, permission.permInfo.name,\n-            permission.isGrantedIncludingAppOp, permission.flags, buttonPressed)\n+            permission.isGranted, permission.flags, buttonPressed)\n         Log.v(LOG_TAG, \"Permission changed via UI with sessionId=$sessionId changeId=\" +\n             \"$changeId uid=$uid packageName=$packageName permission=\" + permission.permInfo.name +\n-            \" isGranted=\" + permission.isGrantedIncludingAppOp + \" permissionFlags=\" +\n+            \" isGranted=\" + permission.isGranted + \" permissionFlags=\" +\n             permission.flags + \" buttonPressed=$buttonPressed\")\n     }\n \ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\nindex 93f0f74a47..61211b0f02 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n@@ -237,7 +237,7 @@ class GrantPermissionsViewModel(\n                     // some requests might have been granted, check for that\n                     for ((key, state) in states) {\n                         val allAffectedGranted = state.affectedPermissions.all { perm ->\n-                            appPermGroup.permissions[perm]?.isGrantedIncludingAppOp == true &&\n+                            appPermGroup.permissions[perm]?.isGranted == true &&\n                                 appPermGroup.permissions[perm]?.isRevokeWhenRequested == false\n                         }\n                         if (allAffectedGranted) {\n@@ -275,7 +275,7 @@ class GrantPermissionsViewModel(\n                 if (fgState?.group != null) {\n                     val fgGroup = fgState.group\n                     for (perm in fgState.affectedPermissions) {\n-                        if (fgGroup.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+                        if (fgGroup.permissions[perm]?.isGranted == false) {\n                             // If any of the requested permissions is not granted,\n                             // needFgPermissions = true\n                             needFgPermissions = true\n@@ -425,7 +425,7 @@ class GrantPermissionsViewModel(\n                                 fgState.affectedPermissions.contains(ACCESS_FINE_LOCATION)) {\n                             val coarseLocationPerm =\n                                 groupState.group.allPermissions[ACCESS_COARSE_LOCATION]\n-                            if (coarseLocationPerm?.isGrantedIncludingAppOp == true) {\n+                            if (coarseLocationPerm?.isGranted == true) {\n                                 // Upgrade flow\n                                 locationVisibilities[DIALOG_WITH_FINE_LOCATION_ONLY] = true\n                                 message = RequestMessage.FG_FINE_LOCATION_MESSAGE\n@@ -648,7 +648,7 @@ class GrantPermissionsViewModel(\n \n         // Do not attempt to grant background access if foreground access is not either already\n         // granted or requested\n-        if (isBackground && !group.foreground.isGrantedExcludeRevokeWhenRequestedPermissions &&\n+        if (isBackground && !group.foreground.allowFullGroupGrant &&\n             !hasForegroundRequest) {\n             Log.w(LOG_TAG, \"Cannot grant $perm as the matching foreground permission is not \" +\n                 \"already granted.\")\n@@ -660,21 +660,22 @@ class GrantPermissionsViewModel(\n             return STATE_SKIPPED\n         }\n \n-        if (isBackground && group.background.isGrantedExcludeRevokeWhenRequestedPermissions ||\n-            !isBackground && group.foreground.isGrantedExcludeRevokeWhenRequestedPermissions) {\n+        if (isBackground && group.background.allowFullGroupGrant ||\n+            !isBackground && group.foreground.allowFullGroupGrant) {\n             // If FINE location is not granted, do not grant it automatically when COARSE\n             // location is already granted.\n             if (group.permGroupName == LOCATION &&\n-                    group.allPermissions[ACCESS_FINE_LOCATION]?.isGrantedIncludingAppOp\n+                    group.allPermissions[ACCESS_FINE_LOCATION]?.isGranted\n                     == false) {\n                 return STATE_UNKNOWN\n             }\n \n-            if (group.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+            if (group.permissions[perm]?.isGranted == false) {\n                 if (isBackground) {\n                     KotlinUtils.grantBackgroundRuntimePermissions(app, group, listOf(perm))\n                 } else {\n-                    KotlinUtils.grantForegroundRuntimePermissions(app, group, listOf(perm), group.isOneTime)\n+                    KotlinUtils.grantForegroundRuntimePermissions(app, group, listOf(perm),\n+                            group.isOneTime)\n                 }\n                 KotlinUtils.setGroupFlags(app, group, FLAG_PERMISSION_USER_SET to false,\n                     FLAG_PERMISSION_USER_FIXED to false, filterPermissions = listOf(perm))\n@@ -845,28 +846,40 @@ class GrantPermissionsViewModel(\n             } else {\n                 PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_GRANTED\n             }\n+            var affectedPermissions: List<String> = groupState.affectedPermissions\n             if (groupState.isBackground) {\n                 KotlinUtils.grantBackgroundRuntimePermissions(app, groupState.group,\n-                    groupState.affectedPermissions)\n+                    affectedPermissions)\n             } else {\n                 if (affectedForegroundPermissions == null) {\n                     KotlinUtils.grantForegroundRuntimePermissions(app, groupState.group,\n-                        groupState.affectedPermissions, isOneTime)\n+                        affectedPermissions, isOneTime)\n                     // This prevents weird flag state when app targetSDK switches from S+ to R-\n                     if (groupState.affectedPermissions.contains(ACCESS_FINE_LOCATION)) {\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(\n                                 app, groupState.group, true)\n                     }\n                 } else {\n+                    affectedPermissions = affectedForegroundPermissions\n                     val newGroup = KotlinUtils.grantForegroundRuntimePermissions(app,\n-                            groupState.group, affectedForegroundPermissions, isOneTime)\n+                            groupState.group, affectedPermissions, isOneTime)\n                     if (!isOneTime || newGroup.isOneTime) {\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(app, newGroup,\n                                 affectedForegroundPermissions.contains(ACCESS_FINE_LOCATION))\n                     }\n                 }\n             }\n-            groupState.state = STATE_ALLOWED\n+            val shouldDenyFullGroupGrant =\n+                groupState.group.isPlatformPermissionGroup &&\n+                        affectedPermissions.none {\n+                            groupState.group.permissions[it]?.isPlatformOrSystem == true\n+                        }\n+            groupState.state =\n+                if (shouldDenyFullGroupGrant) {\n+                    STATE_UNKNOWN\n+                } else {\n+                    STATE_ALLOWED\n+                }\n         } else {\n             if (groupState.isBackground) {\n                 KotlinUtils.revokeBackgroundRuntimePermissions(app, groupState.group,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\nindex da93d4f782..85908cb0ef 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n@@ -440,7 +440,7 @@ object KotlinUtils {\n                     group.userHandle, *flags)\n             }\n             newPerms[permName] = LightPermission(group.packageInfo, perm.permInfo,\n-                perm.isGrantedIncludingAppOp, perm.flags or flagsToSet, perm.foregroundPerms)\n+                perm.isGranted, perm.flags or flagsToSet, perm.foregroundPerms)\n         }\n         return LightAppPermGroup(group.packageInfo, group.permGroupInfo, newPerms,\n             group.hasInstallToRuntimeSplit, group.specialLocationGrant)\n@@ -518,7 +518,7 @@ object KotlinUtils {\n         val newGroup = LightAppPermGroup(group.packageInfo, group.permGroupInfo, newPerms,\n             group.hasInstallToRuntimeSplit, group.specialLocationGrant)\n         // If any permission in the group is one time granted, start one time permission session.\n-        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGrantedIncludingAppOp }) {\n+        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGranted }) {\n             app.getSystemService(PermissionManager::class.java)!!.startOneTimePermissionSession(\n                 group.packageName, Utils.getOneTimePermissionsTimeout(),\n                 ONE_TIME_PACKAGE_IMPORTANCE_LEVEL_TO_RESET_TIMER,\n@@ -555,11 +555,11 @@ object KotlinUtils {\n         }\n \n         var newFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         var shouldKill = false\n \n         // Grant the permission if needed.\n-        if (!perm.isGrantedIncludingAppOp) {\n+        if (!perm.isGranted) {\n             val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n             // TODO 195016052: investigate adding split permission handling\n@@ -602,14 +602,14 @@ object KotlinUtils {\n \n         // If we newly grant background access to the fine location, double-guess the user some\n         // time later if this was really the right choice.\n-        if (!perm.isGrantedIncludingAppOp && isGranted) {\n+        if (!perm.isGranted && isGranted) {\n             var triggerLocationAccessCheck = false\n             if (perm.name == ACCESS_FINE_LOCATION) {\n                 val bgPerm = group.permissions[perm.backgroundPermission]\n-                triggerLocationAccessCheck = bgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = bgPerm?.isGranted == true\n             } else if (perm.name == ACCESS_BACKGROUND_LOCATION) {\n                 val fgPerm = group.permissions[ACCESS_FINE_LOCATION]\n-                triggerLocationAccessCheck = fgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = fgPerm?.isGranted == true\n             }\n             if (triggerLocationAccessCheck) {\n                 // trigger location access check\n@@ -774,13 +774,13 @@ object KotlinUtils {\n \n         val user = UserHandle.getUserHandleForUid(group.packageInfo.uid)\n         var newFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         val supportsRuntime = group.packageInfo.targetSdkVersion >= Build.VERSION_CODES.M\n         var shouldKill = false\n \n         val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n-        if (perm.isGrantedIncludingAppOp) {\n+        if (perm.isGranted) {\n             if (supportsRuntime && !isPermissionSplitFromNonRuntime(app, perm.name,\n                             group.packageInfo.targetSdkVersion)) {\n                 // Revoke the permission if needed.\n@@ -874,7 +874,7 @@ object KotlinUtils {\n                 val fgPerm = group.permissions[foregroundPermName]\n                 val appOpName = permissionToOp(foregroundPermName) ?: continue\n \n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     wasChanged = wasChanged || setOpMode(appOpName, uid, packageName, MODE_ALLOWED,\n                         appOpsManager)\n                 }\n@@ -884,7 +884,7 @@ object KotlinUtils {\n             if (perm.backgroundPermission != null) {\n                 wasChanged = if (group.permissions.containsKey(perm.backgroundPermission)) {\n                     val bgPerm = group.permissions[perm.backgroundPermission]\n-                    val mode = if (bgPerm != null && bgPerm.isGrantedIncludingAppOp) MODE_ALLOWED\n+                    val mode = if (bgPerm != null && bgPerm.isGranted) MODE_ALLOWED\n                     else MODE_FOREGROUND\n \n                     setOpMode(appOpName, uid, packageName, mode, appOpsManager)\n@@ -935,7 +935,7 @@ object KotlinUtils {\n         if (perm.isBackgroundPermission && perm.foregroundPerms != null) {\n             for (foregroundPermName in perm.foregroundPerms) {\n                 val fgPerm = group.permissions[foregroundPermName]\n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     val appOpName = permissionToOp(foregroundPermName) ?: return false\n                     wasChanged = wasChanged || setOpMode(appOpName, uid, packageName,\n                         MODE_FOREGROUND, appOpsManager)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\nindex f0227cad54..96eccd0a8d 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n@@ -162,7 +162,7 @@ public final class SafetyNetLogger {\n             }\n \n             builder.append(permission.getName()).append('|');\n-            builder.append(permission.isGrantedIncludingAppOp()).append('|');\n+            builder.append(permission.isGranted()).append('|');\n             builder.append(permission.getFlags());\n         }\n     }\ndiff --git a/PermissionController/tests/mocking/src/com/android/permissioncontroller/permission/utils/GrantRevokeTests.kt b/PermissionController/tests/mocking/src/com/android/permissioncontroller/permission/utils/GrantRevokeTests.kt\nindex 8f7494124e..496cca01cc 100644\n--- a/PermissionController/tests/mocking/src/com/android/permissioncontroller/permission/utils/GrantRevokeTests.kt\n+++ b/PermissionController/tests/mocking/src/com/android/permissioncontroller/permission/utils/GrantRevokeTests.kt\n@@ -24,6 +24,7 @@ import android.app.AppOpsManager.MODE_FOREGROUND\n import android.app.AppOpsManager.MODE_IGNORED\n import android.app.AppOpsManager.permissionToOp\n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageManager\n import android.content.pm.PackageManager.FLAG_PERMISSION_AUTO_REVOKED\n import android.content.pm.PackageManager.FLAG_PERMISSION_ONE_TIME\n@@ -180,7 +181,8 @@ class GrantRevokeTests {\n         permInfoProtectionFlags: Int = 0\n     ): LightPermission {\n         val permInfo = LightPermInfo(permName, TEST_PACKAGE_NAME, PERM_GROUP_NAME, backgroundPerm,\n-            PermissionInfo.PROTECTION_DANGEROUS, permInfoProtectionFlags, 0)\n+            PermissionInfo.PROTECTION_DANGEROUS, permInfoProtectionFlags, 0,\n+                pkgInfo.appFlags and ApplicationInfo.FLAG_SYSTEM != 0)\n         return LightPermission(pkgInfo, permInfo,\n                 pkgInfo.requestedPermissionsFlags[pkgInfo.requestedPermissions.indexOf(permName)]\n                         == PERMISSION_GRANTED, flags, foregroundPerms)\n@@ -251,7 +253,7 @@ class GrantRevokeTests {\n             val flags = state.second\n \n             assertWithMessage(\"permission $permName grant state incorrect\")\n-                .that(perms[permName]?.isGrantedIncludingAppOp).isEqualTo(granted)\n+                .that(perms[permName]?.isGranted).isEqualTo(granted)\n \n             val actualFlags = perms[permName]!!.flags\n             assertWithMessage(\"permission $permName flags incorrect, expected\" +\n",
                            "file_conflicts": [
                                {
                                    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n=======\n            PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                    changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                    group.getPackageName(),\n                    permission.getName(), permission.isGranted());\n            Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                    + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                    + group.getPackageName() + \" permission=\"\n                    + permission.getName() + \" granted=\" + permission.isGranted());\n>>>>>>> UPSTREAM PATCH (commit 46abb4e1fd365a88efdfe3f2b1f87da4d255b41b)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -267,11 +267,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n```",
                                    "patch_apply_output": "patching file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nHunk #1 FAILED at 267.\n1 out of 1 hunk FAILED -- saving rejects to file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java.rej\npatching file PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\nHunk #1 succeeded at 162 (offset 67 lines).",
                                    "inline_merge_output": "patching file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nHunk #1 NOT MERGED at 264-275."
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "2bf7a6ef16585b120dfeee6e4f701be62525ee12",
                            "result": "failure",
                            "downstream_patch_content": "commit 2bf7a6ef16585b120dfeee6e4f701be62525ee12\nAuthor: Yi-an Chen <theianchen@google.com>\nDate:   Thu Aug 8 01:15:57 2024 +0000\n\n    RESTRICT AUTOMERGE Fix Dynamic Permission group auto grant behaivor\n    \n    Fix the Dynamic Permission group auto grant behaivor so that a\n    permission group is only considered granted when (1) all permissions\n    were auto-granted or (2) a platform permission in the same group is\n    granted.\n    \n    Bug: 340480881\n    Test: DynamicPermissionsTest\n    Change-Id: I37b550f0c3933bc790c2917a14e917efbcccc4e8\n    Merged-In: I37b550f0c3933bc790c2917a14e917efbcccc4e8\n\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\nindex 97389b0984..bf43f15c3f 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n@@ -66,7 +66,7 @@ class LightPermInfoLiveData private constructor(\n         }\n \n         val newValue = try {\n-            LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0))\n+            LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0), null)\n         } catch (e: PackageManager.NameNotFoundException) {\n             Log.w(LOG_TAG, \"Permission \\\"$permissionName\\\" not found\")\n             invalidateSingle(permissionName)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\nindex 78f2f72c63..948815646a 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n@@ -17,6 +17,7 @@\n package com.android.permissioncontroller.permission.data\n \n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageItemInfo\n import android.content.pm.PackageManager\n import android.content.pm.PermissionGroupInfo\n@@ -68,32 +69,31 @@ class PermGroupLiveData private constructor(\n      */\n     override fun onUpdate() {\n         val permissionInfos = mutableMapOf<String, LightPermInfo>()\n-\n         groupInfo = Utils.getGroupInfo(groupName, context) ?: run {\n             Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n             invalidateSingle(groupName)\n             value = null\n             return\n         }\n-\n+        val permInfos = mutableListOf<PermissionInfo>()\n         when (groupInfo) {\n             is PermissionGroupInfo -> {\n-                val permInfos = try {\n-                    Utils.getInstalledRuntimePermissionInfosForGroup(context.packageManager,\n-                        groupName)\n+                try {\n+                    permInfos.addAll(\n+                        Utils.getInstalledRuntimePermissionInfosForGroup(\n+                            context.packageManager,\n+                            groupName\n+                        )\n+                    )\n                 } catch (e: PackageManager.NameNotFoundException) {\n                     Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n                     invalidateSingle(groupName)\n                     value = null\n                     return\n                 }\n-\n-                for (permInfo in permInfos) {\n-                    permissionInfos[permInfo.name] = LightPermInfo(permInfo)\n-                }\n             }\n             is PermissionInfo -> {\n-                permissionInfos[groupInfo.name] = LightPermInfo(groupInfo as PermissionInfo)\n+                permInfos.add(groupInfo as PermissionInfo)\n             }\n             else -> {\n                 value = null\n@@ -101,19 +101,25 @@ class PermGroupLiveData private constructor(\n             }\n         }\n \n-        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n-\n-        value = permGroup\n-\n-        val packageNames = permissionInfos.values.map { permInfo -> permInfo.packageName }\n-            .toMutableSet()\n+        val packageNames = permInfos.map { permInfo -> permInfo.packageName }.toMutableSet()\n         packageNames.add(groupInfo.packageName)\n-\n         // TODO ntmyren: What if the package isn't installed for the system user?\n         val getLiveData = { packageName: String ->\n             LightPackageInfoLiveData[packageName, UserHandle.SYSTEM]\n         }\n         setSourcesToDifference(packageNames, packageLiveDatas, getLiveData)\n+        if (!packageLiveDatas.all { it.value.isInitialized }) {\n+            return\n+        }\n+        for (permInfo in permInfos) {\n+            val lightPackageInfo = packageLiveDatas[permInfo.packageName]?.value\n+            val isSystem =\n+                lightPackageInfo?.let { it.appFlags and ApplicationInfo.FLAG_SYSTEM != 0 }\n+            permissionInfos[permInfo.name] = LightPermInfo(permInfo, isSystem)\n+        }\n+\n+        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n+        value = permGroup\n     }\n \n     override fun onInactive() {\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\nindex cbfac4b244..1d807292ad 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n@@ -20,6 +20,7 @@ import android.Manifest\n import android.Manifest.permission.ACCESS_COARSE_LOCATION\n import android.os.Build\n import android.os.UserHandle\n+import com.android.permissioncontroller.permission.utils.Utils\n \n /**\n  * A lightweight version of the AppPermissionGroup data structure. Represents information about a\n@@ -79,11 +80,13 @@ data class LightAppPermGroup(\n         if (name !in backgroundPermNames) name else null\n     }\n \n+    val isPlatformPermissionGroup = permGroupInfo.packageName == Utils.OS_PKG\n+\n     val foreground = AppPermSubGroup(permissions.filter { it.key in foregroundPermNames },\n-        packageInfo, specialLocationGrant)\n+        packageInfo, isPlatformPermissionGroup, specialLocationGrant)\n \n     val background = AppPermSubGroup(permissions.filter { it.key in backgroundPermNames },\n-        packageInfo, specialLocationGrant)\n+        packageInfo, isPlatformPermissionGroup, specialLocationGrant)\n \n     /**\n      * Whether or not this App Permission Group has a permission which has a background mode\n@@ -152,24 +155,34 @@ data class LightAppPermGroup(\n      *\n      * @param permissions The permissions contained within this subgroup, a subset of those contained\n      * in the full group\n+     * @param isPlatformPermissionGroup Whether this is a platform permission group\n      * @param specialLocationGrant Whether this is a special location package\n      */\n     data class AppPermSubGroup internal constructor(\n         private val permissions: Map<String, LightPermission>,\n         private val packageInfo: LightPackageInfo,\n+        private val isPlatformPermissionGroup: Boolean,\n         private val specialLocationGrant: Boolean?\n     ) {\n-        /**\n-         * Whether any of this App Permission SubGroup's permissions are granted\n-         */\n-        val isGranted = specialLocationGrant ?: permissions.any { it.value.isGrantedIncludingAppOp }\n+        /** Whether any of this App Permission SubGroup's permissions are granted */\n+        val isGranted =\n+            specialLocationGrant\n+                ?: permissions.any {\n+                    val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                    it.value.isGranted && mayGrantByPlatformOrSystem\n+                }\n \n         /**\n          * Whether any of this App Permission SubGroup's permissions are granted excluding\n          * auto granted permissions during install time with flag RevokeWhenRequested\n          */\n-        val isGrantedExcludeRevokeWhenRequestedPermissions = specialLocationGrant ?: permissions\n-            .any { it.value.isGrantedIncludingAppOp && !it.value.isRevokeWhenRequested }\n+        val allowFullGroupGrant = specialLocationGrant ?: permissions\n+            .any {\n+                val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                it.value.allowFullGroupGrant && mayGrantByPlatformOrSystem\n+            }\n \n         /**\n          * Whether any of this App Permission SubGroup's permissions are granted by default\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\nindex 182de1a597..a37a47163f 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n@@ -49,7 +49,9 @@ data class LightPackageInfo(\n     val firstInstallTime: Long\n ) {\n     constructor(pI: PackageInfo) : this(pI.packageName,\n-        pI.permissions?.map { perm -> LightPermInfo(perm) } ?: emptyList(),\n+        pI.permissions?.map { perm ->\n+            LightPermInfo(perm, pI.applicationInfo!!.flags and ApplicationInfo.FLAG_SYSTEM != 0)\n+        } ?: emptyList(),\n         pI.requestedPermissions?.toList() ?: emptyList(),\n         pI.requestedPermissionsFlags?.toList() ?: emptyList(),\n         pI.applicationInfo.uid, pI.applicationInfo.targetSdkVersion,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\nindex 3954b74722..582742da43 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n@@ -30,6 +30,7 @@ import android.content.pm.PermissionInfo\n  * @param protection The protection level of this permission\n  * @param protection Extra information about the protection of this permission\n  * @param flags The system flags of this permission\n+ * @param isSystem Whether this permission is defined by a system app\n  */\n data class LightPermInfo(\n     val name: String,\n@@ -38,11 +39,13 @@ data class LightPermInfo(\n     val backgroundPermission: String?,\n     val protection: Int,\n     val protectionFlags: Int,\n-    val flags: Int\n+    val flags: Int,\n+    val isSystem: Boolean?\n ) {\n-    constructor (permInfo: PermissionInfo): this(permInfo.name, permInfo.packageName,\n-        permInfo.group, permInfo.backgroundPermission, permInfo.protection,\n-        permInfo.protectionFlags, permInfo.flags)\n+    constructor (permInfo: PermissionInfo, isSystem: Boolean?) : this(\n+        permInfo.name, permInfo.packageName, permInfo.group, permInfo.backgroundPermission,\n+        permInfo.protection, permInfo.protectionFlags, permInfo.flags, isSystem\n+    )\n \n     /**\n      * Gets the PermissionInfo for this permission from the system.\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\nindex c3d087fd24..45c3b1e92a 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n@@ -27,7 +27,7 @@ import com.android.permissioncontroller.permission.utils.Utils.isRuntimePlatform\n  *\n  * @param pkgInfo The package requesting the permission\n  * @param permInfo The permissionInfo this represents\n- * @param isGrantedIncludingAppOp Whether or not this permission is functionally granted.\n+ * @param isGranted Whether or not this permission is functionally granted.\n  * A non-granted app op but granted permission is counted as not granted\n  * @param flags The PermissionController flags for this permission\n  * @param foregroundPerms The foreground permission names corresponding to this permission, if this\n@@ -36,7 +36,7 @@ import com.android.permissioncontroller.permission.utils.Utils.isRuntimePlatform\n data class LightPermission(\n     val pkgInfo: LightPackageInfo,\n     val permInfo: LightPermInfo,\n-    val isGrantedIncludingAppOp: Boolean,\n+    val isGranted: Boolean,\n     val flags: Int,\n     val foregroundPerms: List<String>?\n ) {\n@@ -82,9 +82,9 @@ data class LightPermission(\n     val isRevokeWhenRequested = flags and PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED != 0\n     /** Whether this permission is user sensitive in its current grant state */\n     val isUserSensitive = !isRuntimePlatformPermission(permInfo.name) ||\n-            (isGrantedIncludingAppOp &&\n+            (isGranted &&\n                     (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED) != 0) ||\n-            (!isGrantedIncludingAppOp &&\n+            (!isGranted &&\n                     (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED) != 0)\n     /** Whether the permission is restricted */\n     val isRestricted = when {\n@@ -105,10 +105,17 @@ data class LightPermission(\n      */\n     val isSelectedLocationAccuracy =\n         flags and PackageManager.FLAG_PERMISSION_SELECTED_LOCATION_ACCURACY != 0\n+    /** Whether this permission is defined by platform or a system app */\n+    val isPlatformOrSystem = permInfo.packageName == Utils.OS_PKG || permInfo.isSystem == true\n+    /**\n+     * Whether this permission is granted including app op and does not hold the\n+     * PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED flag.\n+     */\n+    val allowFullGroupGrant = isGranted && !isRevokeWhenRequested\n \n     override fun toString() = buildString {\n         append(name)\n-        if (isGrantedIncludingAppOp) append(\", Granted\") else append(\", NotGranted\")\n+        if (isGranted) append(\", Granted\") else append(\", NotGranted\")\n         if (isPolicyFixed) append(\", PolicyFixed\")\n         if (isSystemFixed) append(\", SystemFixed\")\n         if (isUserFixed) append(\", UserFixed\")\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\nindex d57e797519..92bfa887e8 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n@@ -93,7 +93,7 @@ suspend fun revokeAppPermissions(\n \n                 val fixed = group.isBackgroundFixed || group.isForegroundFixed\n                 val granted = group.permissions.any { (_, perm) ->\n-                    perm.isGrantedIncludingAppOp && perm.name !in EXEMPT_PERMISSIONS\n+                    perm.isGranted && perm.name !in EXEMPT_PERMISSIONS\n                 }\n                 if (!fixed &&\n                     granted &&\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\nindex c22e5dd422..6369eeada3 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n@@ -382,7 +382,7 @@ internal object RuntimePermissionsUpgradeController {\n \n                 val allPermissionsWithxemption = bgApp.allPermissions.toMutableMap()\n                 allPermissionsWithxemption[permission.ACCESS_BACKGROUND_LOCATION] =\n-                        LightPermission(perm.pkgInfo, perm.permInfo, perm.isGrantedIncludingAppOp,\n+                        LightPermission(perm.pkgInfo, perm.permInfo, perm.isGranted,\n                         perm.flags or FLAG_PERMISSION_RESTRICTION_UPGRADE_EXEMPT,\n                         perm.foregroundPerms)\n \n@@ -444,7 +444,7 @@ internal object RuntimePermissionsUpgradeController {\n                             ?: continue\n \n                     if (!perm.isUserSet && !perm.isSystemFixed && !perm.isPolicyFixed &&\n-                            !perm.isGrantedIncludingAppOp) {\n+                            !perm.isGranted) {\n                         grants.add(Grant(false, appPermGroup,\n                                 listOf(permission.ACCESS_MEDIA_LOCATION)))\n                     }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\nindex 05c5849f06..244fdd2bb2 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n@@ -698,7 +698,7 @@ class AppPermissionViewModel(\n \n     private fun getIndividualPermissionDetailResId(group: LightAppPermGroup): Pair<Int, Int> {\n         return when (val numRevoked =\n-            group.permissions.filter { !it.value.isGrantedIncludingAppOp }.size) {\n+            group.permissions.filter { !it.value.isGranted }.size) {\n             0 -> R.string.permission_revoked_none to numRevoked\n             group.permissions.size -> R.string.permission_revoked_all to numRevoked\n             else -> R.string.permission_revoked_count to numRevoked\n@@ -767,7 +767,7 @@ class AppPermissionViewModel(\n         for ((permName, permission) in oldGroup.permissions) {\n             val newPermission = newGroup.permissions[permName] ?: continue\n \n-            if (permission.isGrantedIncludingAppOp != newPermission.isGrantedIncludingAppOp ||\n+            if (permission.isGranted != newPermission.isGranted ||\n                 permission.flags != newPermission.flags) {\n                 logAppPermissionFragmentActionReported(changeId, newPermission, buttonPressed)\n             }\n@@ -782,10 +782,10 @@ class AppPermissionViewModel(\n         val uid = KotlinUtils.getPackageUid(app, packageName, user) ?: return\n         PermissionControllerStatsLog.write(APP_PERMISSION_FRAGMENT_ACTION_REPORTED, sessionId,\n             changeId, uid, packageName, permission.permInfo.name,\n-            permission.isGrantedIncludingAppOp, permission.flags, buttonPressed)\n+            permission.isGranted, permission.flags, buttonPressed)\n         Log.v(LOG_TAG, \"Permission changed via UI with sessionId=$sessionId changeId=\" +\n             \"$changeId uid=$uid packageName=$packageName permission=\" + permission.permInfo.name +\n-            \" isGranted=\" + permission.isGrantedIncludingAppOp + \" permissionFlags=\" +\n+            \" isGranted=\" + permission.isGranted + \" permissionFlags=\" +\n             permission.flags + \" buttonPressed=$buttonPressed\")\n     }\n \ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\nindex 00c45a063b..4ab26a9aef 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n@@ -237,7 +237,7 @@ class GrantPermissionsViewModel(\n                     // some requests might have been granted, check for that\n                     for ((key, state) in states) {\n                         val allAffectedGranted = state.affectedPermissions.all { perm ->\n-                            appPermGroup.permissions[perm]?.isGrantedIncludingAppOp == true &&\n+                            appPermGroup.permissions[perm]?.isGranted == true &&\n                                 appPermGroup.permissions[perm]?.isRevokeWhenRequested == false\n                         }\n                         if (allAffectedGranted) {\n@@ -275,7 +275,7 @@ class GrantPermissionsViewModel(\n                 if (fgState?.group != null) {\n                     val fgGroup = fgState.group\n                     for (perm in fgState.affectedPermissions) {\n-                        if (fgGroup.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+                        if (fgGroup.permissions[perm]?.isGranted == false) {\n                             // If any of the requested permissions is not granted,\n                             // needFgPermissions = true\n                             needFgPermissions = true\n@@ -426,7 +426,7 @@ class GrantPermissionsViewModel(\n                                 fgState.affectedPermissions.contains(ACCESS_FINE_LOCATION)) {\n                             val coarseLocationPerm =\n                                 groupState.group.allPermissions[ACCESS_COARSE_LOCATION]\n-                            if (coarseLocationPerm?.isGrantedIncludingAppOp == true) {\n+                            if (coarseLocationPerm?.isGranted == true) {\n                                 // Upgrade flow\n                                 locationVisibilities[DIALOG_WITH_FINE_LOCATION_ONLY] = true\n                                 message = RequestMessage.FG_FINE_LOCATION_MESSAGE\n@@ -655,7 +655,7 @@ class GrantPermissionsViewModel(\n \n         // Do not attempt to grant background access if foreground access is not either already\n         // granted or requested\n-        if (isBackground && !group.foreground.isGrantedExcludeRevokeWhenRequestedPermissions &&\n+        if (isBackground && !group.foreground.allowFullGroupGrant &&\n             !hasForegroundRequest) {\n             Log.w(LOG_TAG, \"Cannot grant $perm as the matching foreground permission is not \" +\n                 \"already granted.\")\n@@ -667,21 +667,22 @@ class GrantPermissionsViewModel(\n             return STATE_SKIPPED\n         }\n \n-        if (isBackground && group.background.isGrantedExcludeRevokeWhenRequestedPermissions ||\n-            !isBackground && group.foreground.isGrantedExcludeRevokeWhenRequestedPermissions) {\n+        if (isBackground && group.background.allowFullGroupGrant ||\n+            !isBackground && group.foreground.allowFullGroupGrant) {\n             // If FINE location is not granted, do not grant it automatically when COARSE\n             // location is already granted.\n             if (group.permGroupName == LOCATION &&\n-                    group.allPermissions[ACCESS_FINE_LOCATION]?.isGrantedIncludingAppOp\n+                    group.allPermissions[ACCESS_FINE_LOCATION]?.isGranted\n                     == false) {\n                 return STATE_UNKNOWN\n             }\n \n-            if (group.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+            if (group.permissions[perm]?.isGranted == false) {\n                 if (isBackground) {\n                     KotlinUtils.grantBackgroundRuntimePermissions(app, group, listOf(perm))\n                 } else {\n-                    KotlinUtils.grantForegroundRuntimePermissions(app, group, listOf(perm), group.isOneTime)\n+                    KotlinUtils.grantForegroundRuntimePermissions(app, group, listOf(perm),\n+                            group.isOneTime)\n                 }\n                 KotlinUtils.setGroupFlags(app, group, FLAG_PERMISSION_USER_SET to false,\n                     FLAG_PERMISSION_USER_FIXED to false, filterPermissions = listOf(perm))\n@@ -852,28 +853,40 @@ class GrantPermissionsViewModel(\n             } else {\n                 PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_GRANTED\n             }\n+            var affectedPermissions: List<String> = groupState.affectedPermissions\n             if (groupState.isBackground) {\n                 KotlinUtils.grantBackgroundRuntimePermissions(app, groupState.group,\n-                    groupState.affectedPermissions)\n+                    affectedPermissions)\n             } else {\n                 if (affectedForegroundPermissions == null) {\n                     KotlinUtils.grantForegroundRuntimePermissions(app, groupState.group,\n-                        groupState.affectedPermissions, isOneTime)\n+                        affectedPermissions, isOneTime)\n                     // This prevents weird flag state when app targetSDK switches from S+ to R-\n                     if (groupState.affectedPermissions.contains(ACCESS_FINE_LOCATION)) {\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(\n                                 app, groupState.group, true)\n                     }\n                 } else {\n+                    affectedPermissions = affectedForegroundPermissions\n                     val newGroup = KotlinUtils.grantForegroundRuntimePermissions(app,\n-                            groupState.group, affectedForegroundPermissions, isOneTime)\n+                            groupState.group, affectedPermissions, isOneTime)\n                     if (!isOneTime || newGroup.isOneTime) {\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(app, newGroup,\n                                 affectedForegroundPermissions.contains(ACCESS_FINE_LOCATION))\n                     }\n                 }\n             }\n-            groupState.state = STATE_ALLOWED\n+            val shouldDenyFullGroupGrant =\n+                groupState.group.isPlatformPermissionGroup &&\n+                        affectedPermissions.none {\n+                            groupState.group.permissions[it]?.isPlatformOrSystem == true\n+                        }\n+            groupState.state =\n+                if (shouldDenyFullGroupGrant) {\n+                    STATE_UNKNOWN\n+                } else {\n+                    STATE_ALLOWED\n+                }\n         } else {\n             if (groupState.isBackground) {\n                 KotlinUtils.revokeBackgroundRuntimePermissions(app, groupState.group,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\nindex da93d4f782..85908cb0ef 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n@@ -440,7 +440,7 @@ object KotlinUtils {\n                     group.userHandle, *flags)\n             }\n             newPerms[permName] = LightPermission(group.packageInfo, perm.permInfo,\n-                perm.isGrantedIncludingAppOp, perm.flags or flagsToSet, perm.foregroundPerms)\n+                perm.isGranted, perm.flags or flagsToSet, perm.foregroundPerms)\n         }\n         return LightAppPermGroup(group.packageInfo, group.permGroupInfo, newPerms,\n             group.hasInstallToRuntimeSplit, group.specialLocationGrant)\n@@ -518,7 +518,7 @@ object KotlinUtils {\n         val newGroup = LightAppPermGroup(group.packageInfo, group.permGroupInfo, newPerms,\n             group.hasInstallToRuntimeSplit, group.specialLocationGrant)\n         // If any permission in the group is one time granted, start one time permission session.\n-        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGrantedIncludingAppOp }) {\n+        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGranted }) {\n             app.getSystemService(PermissionManager::class.java)!!.startOneTimePermissionSession(\n                 group.packageName, Utils.getOneTimePermissionsTimeout(),\n                 ONE_TIME_PACKAGE_IMPORTANCE_LEVEL_TO_RESET_TIMER,\n@@ -555,11 +555,11 @@ object KotlinUtils {\n         }\n \n         var newFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         var shouldKill = false\n \n         // Grant the permission if needed.\n-        if (!perm.isGrantedIncludingAppOp) {\n+        if (!perm.isGranted) {\n             val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n             // TODO 195016052: investigate adding split permission handling\n@@ -602,14 +602,14 @@ object KotlinUtils {\n \n         // If we newly grant background access to the fine location, double-guess the user some\n         // time later if this was really the right choice.\n-        if (!perm.isGrantedIncludingAppOp && isGranted) {\n+        if (!perm.isGranted && isGranted) {\n             var triggerLocationAccessCheck = false\n             if (perm.name == ACCESS_FINE_LOCATION) {\n                 val bgPerm = group.permissions[perm.backgroundPermission]\n-                triggerLocationAccessCheck = bgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = bgPerm?.isGranted == true\n             } else if (perm.name == ACCESS_BACKGROUND_LOCATION) {\n                 val fgPerm = group.permissions[ACCESS_FINE_LOCATION]\n-                triggerLocationAccessCheck = fgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = fgPerm?.isGranted == true\n             }\n             if (triggerLocationAccessCheck) {\n                 // trigger location access check\n@@ -774,13 +774,13 @@ object KotlinUtils {\n \n         val user = UserHandle.getUserHandleForUid(group.packageInfo.uid)\n         var newFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         val supportsRuntime = group.packageInfo.targetSdkVersion >= Build.VERSION_CODES.M\n         var shouldKill = false\n \n         val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n-        if (perm.isGrantedIncludingAppOp) {\n+        if (perm.isGranted) {\n             if (supportsRuntime && !isPermissionSplitFromNonRuntime(app, perm.name,\n                             group.packageInfo.targetSdkVersion)) {\n                 // Revoke the permission if needed.\n@@ -874,7 +874,7 @@ object KotlinUtils {\n                 val fgPerm = group.permissions[foregroundPermName]\n                 val appOpName = permissionToOp(foregroundPermName) ?: continue\n \n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     wasChanged = wasChanged || setOpMode(appOpName, uid, packageName, MODE_ALLOWED,\n                         appOpsManager)\n                 }\n@@ -884,7 +884,7 @@ object KotlinUtils {\n             if (perm.backgroundPermission != null) {\n                 wasChanged = if (group.permissions.containsKey(perm.backgroundPermission)) {\n                     val bgPerm = group.permissions[perm.backgroundPermission]\n-                    val mode = if (bgPerm != null && bgPerm.isGrantedIncludingAppOp) MODE_ALLOWED\n+                    val mode = if (bgPerm != null && bgPerm.isGranted) MODE_ALLOWED\n                     else MODE_FOREGROUND\n \n                     setOpMode(appOpName, uid, packageName, mode, appOpsManager)\n@@ -935,7 +935,7 @@ object KotlinUtils {\n         if (perm.isBackgroundPermission && perm.foregroundPerms != null) {\n             for (foregroundPermName in perm.foregroundPerms) {\n                 val fgPerm = group.permissions[foregroundPermName]\n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     val appOpName = permissionToOp(foregroundPermName) ?: return false\n                     wasChanged = wasChanged || setOpMode(appOpName, uid, packageName,\n                         MODE_FOREGROUND, appOpsManager)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\nindex f0227cad54..96eccd0a8d 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n@@ -162,7 +162,7 @@ public final class SafetyNetLogger {\n             }\n \n             builder.append(permission.getName()).append('|');\n-            builder.append(permission.isGrantedIncludingAppOp()).append('|');\n+            builder.append(permission.isGranted()).append('|');\n             builder.append(permission.getFlags());\n         }\n     }\ndiff --git a/PermissionController/tests/mocking/src/com/android/permissioncontroller/permission/utils/GrantRevokeTests.kt b/PermissionController/tests/mocking/src/com/android/permissioncontroller/permission/utils/GrantRevokeTests.kt\nindex 8f7494124e..496cca01cc 100644\n--- a/PermissionController/tests/mocking/src/com/android/permissioncontroller/permission/utils/GrantRevokeTests.kt\n+++ b/PermissionController/tests/mocking/src/com/android/permissioncontroller/permission/utils/GrantRevokeTests.kt\n@@ -24,6 +24,7 @@ import android.app.AppOpsManager.MODE_FOREGROUND\n import android.app.AppOpsManager.MODE_IGNORED\n import android.app.AppOpsManager.permissionToOp\n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageManager\n import android.content.pm.PackageManager.FLAG_PERMISSION_AUTO_REVOKED\n import android.content.pm.PackageManager.FLAG_PERMISSION_ONE_TIME\n@@ -180,7 +181,8 @@ class GrantRevokeTests {\n         permInfoProtectionFlags: Int = 0\n     ): LightPermission {\n         val permInfo = LightPermInfo(permName, TEST_PACKAGE_NAME, PERM_GROUP_NAME, backgroundPerm,\n-            PermissionInfo.PROTECTION_DANGEROUS, permInfoProtectionFlags, 0)\n+            PermissionInfo.PROTECTION_DANGEROUS, permInfoProtectionFlags, 0,\n+                pkgInfo.appFlags and ApplicationInfo.FLAG_SYSTEM != 0)\n         return LightPermission(pkgInfo, permInfo,\n                 pkgInfo.requestedPermissionsFlags[pkgInfo.requestedPermissions.indexOf(permName)]\n                         == PERMISSION_GRANTED, flags, foregroundPerms)\n@@ -251,7 +253,7 @@ class GrantRevokeTests {\n             val flags = state.second\n \n             assertWithMessage(\"permission $permName grant state incorrect\")\n-                .that(perms[permName]?.isGrantedIncludingAppOp).isEqualTo(granted)\n+                .that(perms[permName]?.isGranted).isEqualTo(granted)\n \n             val actualFlags = perms[permName]!!.flags\n             assertWithMessage(\"permission $permName flags incorrect, expected\" +\n",
                            "file_conflicts": [
                                {
                                    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n=======\n            PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                    changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                    group.getPackageName(),\n                    permission.getName(), permission.isGranted());\n            Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                    + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                    + group.getPackageName() + \" permission=\"\n                    + permission.getName() + \" granted=\" + permission.isGranted());\n>>>>>>> UPSTREAM PATCH (commit 46abb4e1fd365a88efdfe3f2b1f87da4d255b41b)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -267,11 +267,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n```",
                                    "patch_apply_output": "patching file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nHunk #1 FAILED at 267.\n1 out of 1 hunk FAILED -- saving rejects to file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java.rej\npatching file PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\nHunk #1 succeeded at 162 (offset 67 lines).",
                                    "inline_merge_output": "patching file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nHunk #1 NOT MERGED at 264-275."
                                }
                            ]
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "111cac570a0f596cdca1b1d512dfbef17751e1a5"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "06e7a4b6dced97632ef42670539d71cb6c68785a",
                            "result": "failure",
                            "downstream_patch_content": "commit 06e7a4b6dced97632ef42670539d71cb6c68785a\nAuthor: Yi-an Chen <theianchen@google.com>\nDate:   Thu Aug 8 01:15:57 2024 +0000\n\n    RESTRICT AUTOMERGE Fix Dynamic Permission group auto grant behaivor\n    \n    Fix the Dynamic Permission group auto grant behaivor so that a\n    permission group is only considered granted when (1) all permissions\n    were auto-granted or (2) a platform permission in the same group is\n    granted.\n    \n    Bug: 340480881\n    Test: DynamicPermissionsTest\n    Change-Id: I37b550f0c3933bc790c2917a14e917efbcccc4e8\n    Merged-In: I37b550f0c3933bc790c2917a14e917efbcccc4e8\n\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\nindex 97389b0984..bf43f15c3f 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n@@ -66,7 +66,7 @@ class LightPermInfoLiveData private constructor(\n         }\n \n         val newValue = try {\n-            LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0))\n+            LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0), null)\n         } catch (e: PackageManager.NameNotFoundException) {\n             Log.w(LOG_TAG, \"Permission \\\"$permissionName\\\" not found\")\n             invalidateSingle(permissionName)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\nindex 78f2f72c63..948815646a 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n@@ -17,6 +17,7 @@\n package com.android.permissioncontroller.permission.data\n \n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageItemInfo\n import android.content.pm.PackageManager\n import android.content.pm.PermissionGroupInfo\n@@ -68,32 +69,31 @@ class PermGroupLiveData private constructor(\n      */\n     override fun onUpdate() {\n         val permissionInfos = mutableMapOf<String, LightPermInfo>()\n-\n         groupInfo = Utils.getGroupInfo(groupName, context) ?: run {\n             Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n             invalidateSingle(groupName)\n             value = null\n             return\n         }\n-\n+        val permInfos = mutableListOf<PermissionInfo>()\n         when (groupInfo) {\n             is PermissionGroupInfo -> {\n-                val permInfos = try {\n-                    Utils.getInstalledRuntimePermissionInfosForGroup(context.packageManager,\n-                        groupName)\n+                try {\n+                    permInfos.addAll(\n+                        Utils.getInstalledRuntimePermissionInfosForGroup(\n+                            context.packageManager,\n+                            groupName\n+                        )\n+                    )\n                 } catch (e: PackageManager.NameNotFoundException) {\n                     Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n                     invalidateSingle(groupName)\n                     value = null\n                     return\n                 }\n-\n-                for (permInfo in permInfos) {\n-                    permissionInfos[permInfo.name] = LightPermInfo(permInfo)\n-                }\n             }\n             is PermissionInfo -> {\n-                permissionInfos[groupInfo.name] = LightPermInfo(groupInfo as PermissionInfo)\n+                permInfos.add(groupInfo as PermissionInfo)\n             }\n             else -> {\n                 value = null\n@@ -101,19 +101,25 @@ class PermGroupLiveData private constructor(\n             }\n         }\n \n-        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n-\n-        value = permGroup\n-\n-        val packageNames = permissionInfos.values.map { permInfo -> permInfo.packageName }\n-            .toMutableSet()\n+        val packageNames = permInfos.map { permInfo -> permInfo.packageName }.toMutableSet()\n         packageNames.add(groupInfo.packageName)\n-\n         // TODO ntmyren: What if the package isn't installed for the system user?\n         val getLiveData = { packageName: String ->\n             LightPackageInfoLiveData[packageName, UserHandle.SYSTEM]\n         }\n         setSourcesToDifference(packageNames, packageLiveDatas, getLiveData)\n+        if (!packageLiveDatas.all { it.value.isInitialized }) {\n+            return\n+        }\n+        for (permInfo in permInfos) {\n+            val lightPackageInfo = packageLiveDatas[permInfo.packageName]?.value\n+            val isSystem =\n+                lightPackageInfo?.let { it.appFlags and ApplicationInfo.FLAG_SYSTEM != 0 }\n+            permissionInfos[permInfo.name] = LightPermInfo(permInfo, isSystem)\n+        }\n+\n+        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n+        value = permGroup\n     }\n \n     override fun onInactive() {\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\nindex 64d63bd1ad..2e7d3b4a05 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n@@ -20,6 +20,7 @@ import android.Manifest\n import android.Manifest.permission.ACCESS_COARSE_LOCATION\n import android.os.Build\n import android.os.UserHandle\n+import com.android.permissioncontroller.permission.utils.Utils\n \n /**\n  * A lightweight version of the AppPermissionGroup data structure. Represents information about a\n@@ -79,11 +80,13 @@ data class LightAppPermGroup(\n         if (name !in backgroundPermNames) name else null\n     }\n \n+    val isPlatformPermissionGroup = permGroupInfo.packageName == Utils.OS_PKG\n+\n     val foreground = AppPermSubGroup(permissions.filter { it.key in foregroundPermNames },\n-        packageInfo, specialLocationGrant)\n+        packageInfo, isPlatformPermissionGroup, specialLocationGrant)\n \n     val background = AppPermSubGroup(permissions.filter { it.key in backgroundPermNames },\n-        packageInfo, specialLocationGrant)\n+        packageInfo, isPlatformPermissionGroup, specialLocationGrant)\n \n     /**\n      * Whether or not this App Permission Group has a permission which has a background mode\n@@ -124,7 +127,7 @@ data class LightAppPermGroup(\n      */\n     val isOneTime = (permGroupName != Manifest.permission_group.LOCATION &&\n             permissions.any { it.value.isOneTime } &&\n-            permissions.none { !it.value.isOneTime && it.value.isGrantedIncludingAppOp }) ||\n+            permissions.none { !it.value.isOneTime && it.value.isGranted }) ||\n             (permGroupName == Manifest.permission_group.LOCATION &&\n                     permissions[ACCESS_COARSE_LOCATION]?.isOneTime == true)\n \n@@ -176,17 +179,23 @@ data class LightAppPermGroup(\n      *\n      * @param permissions The permissions contained within this subgroup, a subset of those contained\n      * in the full group\n+     * @param isPlatformPermissionGroup Whether this is a platform permission group\n      * @param specialLocationGrant Whether this is a special location package\n      */\n     data class AppPermSubGroup internal constructor(\n         private val permissions: Map<String, LightPermission>,\n         private val packageInfo: LightPackageInfo,\n+        private val isPlatformPermissionGroup: Boolean,\n         private val specialLocationGrant: Boolean?\n     ) {\n-        /**\n-         * Whether any of this App Permission SubGroup's permissions are granted\n-         */\n-        val isGranted = specialLocationGrant ?: permissions.any { it.value.isGrantedIncludingAppOp }\n+        /** Whether any of this App Permission SubGroup's permissions are granted */\n+        val isGranted =\n+            specialLocationGrant\n+                ?: permissions.any {\n+                    val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                    it.value.isGranted && mayGrantByPlatformOrSystem\n+                }\n \n         /**\n          * Whether this App Permission SubGroup should be treated as granted. This means either:\n@@ -195,9 +204,15 @@ data class LightAppPermGroup(\n          * 2) All permissions were auto-granted (all permissions are all granted and all\n          * RevokeWhenRequested.)\n          */\n-        val isGrantedExcludingRWROrAllRWR = specialLocationGrant ?: (permissions\n-            .any { it.value.isGrantedIncludingAppOp && !it.value.isRevokeWhenRequested } ||\n-            permissions.all { it.value.isGrantedIncludingAppOp && it.value.isRevokeWhenRequested })\n+        val allowFullGroupGrant =\n+            specialLocationGrant\n+                ?: (permissions.any {\n+                    val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                    it.value.allowFullGroupGrant && mayGrantByPlatformOrSystem\n+                } || permissions.all {\n+                    it.value.isGranted && it.value.isRevokeWhenRequested\n+                })\n \n         /**\n          * Whether any of this App Permission SubGroup's permissions are granted by default\n@@ -209,7 +224,7 @@ data class LightAppPermGroup(\n          * none of the granted permissions are not one-time.\n          */\n         val isOneTime = permissions.any { it.value.isOneTime } &&\n-                permissions.none { it.value.isGrantedIncludingAppOp && !it.value.isOneTime }\n+                permissions.none { it.value.isGranted && !it.value.isOneTime }\n \n         /**\n          * Whether any of this App Permission Subgroup's foreground permissions are fixed by policy\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\nindex 182de1a597..a37a47163f 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n@@ -49,7 +49,9 @@ data class LightPackageInfo(\n     val firstInstallTime: Long\n ) {\n     constructor(pI: PackageInfo) : this(pI.packageName,\n-        pI.permissions?.map { perm -> LightPermInfo(perm) } ?: emptyList(),\n+        pI.permissions?.map { perm ->\n+            LightPermInfo(perm, pI.applicationInfo!!.flags and ApplicationInfo.FLAG_SYSTEM != 0)\n+        } ?: emptyList(),\n         pI.requestedPermissions?.toList() ?: emptyList(),\n         pI.requestedPermissionsFlags?.toList() ?: emptyList(),\n         pI.applicationInfo.uid, pI.applicationInfo.targetSdkVersion,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\nindex 3954b74722..582742da43 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n@@ -30,6 +30,7 @@ import android.content.pm.PermissionInfo\n  * @param protection The protection level of this permission\n  * @param protection Extra information about the protection of this permission\n  * @param flags The system flags of this permission\n+ * @param isSystem Whether this permission is defined by a system app\n  */\n data class LightPermInfo(\n     val name: String,\n@@ -38,11 +39,13 @@ data class LightPermInfo(\n     val backgroundPermission: String?,\n     val protection: Int,\n     val protectionFlags: Int,\n-    val flags: Int\n+    val flags: Int,\n+    val isSystem: Boolean?\n ) {\n-    constructor (permInfo: PermissionInfo): this(permInfo.name, permInfo.packageName,\n-        permInfo.group, permInfo.backgroundPermission, permInfo.protection,\n-        permInfo.protectionFlags, permInfo.flags)\n+    constructor (permInfo: PermissionInfo, isSystem: Boolean?) : this(\n+        permInfo.name, permInfo.packageName, permInfo.group, permInfo.backgroundPermission,\n+        permInfo.protection, permInfo.protectionFlags, permInfo.flags, isSystem\n+    )\n \n     /**\n      * Gets the PermissionInfo for this permission from the system.\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\nindex c3d087fd24..45c3b1e92a 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n@@ -27,7 +27,7 @@ import com.android.permissioncontroller.permission.utils.Utils.isRuntimePlatform\n  *\n  * @param pkgInfo The package requesting the permission\n  * @param permInfo The permissionInfo this represents\n- * @param isGrantedIncludingAppOp Whether or not this permission is functionally granted.\n+ * @param isGranted Whether or not this permission is functionally granted.\n  * A non-granted app op but granted permission is counted as not granted\n  * @param flags The PermissionController flags for this permission\n  * @param foregroundPerms The foreground permission names corresponding to this permission, if this\n@@ -36,7 +36,7 @@ import com.android.permissioncontroller.permission.utils.Utils.isRuntimePlatform\n data class LightPermission(\n     val pkgInfo: LightPackageInfo,\n     val permInfo: LightPermInfo,\n-    val isGrantedIncludingAppOp: Boolean,\n+    val isGranted: Boolean,\n     val flags: Int,\n     val foregroundPerms: List<String>?\n ) {\n@@ -82,9 +82,9 @@ data class LightPermission(\n     val isRevokeWhenRequested = flags and PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED != 0\n     /** Whether this permission is user sensitive in its current grant state */\n     val isUserSensitive = !isRuntimePlatformPermission(permInfo.name) ||\n-            (isGrantedIncludingAppOp &&\n+            (isGranted &&\n                     (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED) != 0) ||\n-            (!isGrantedIncludingAppOp &&\n+            (!isGranted &&\n                     (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED) != 0)\n     /** Whether the permission is restricted */\n     val isRestricted = when {\n@@ -105,10 +105,17 @@ data class LightPermission(\n      */\n     val isSelectedLocationAccuracy =\n         flags and PackageManager.FLAG_PERMISSION_SELECTED_LOCATION_ACCURACY != 0\n+    /** Whether this permission is defined by platform or a system app */\n+    val isPlatformOrSystem = permInfo.packageName == Utils.OS_PKG || permInfo.isSystem == true\n+    /**\n+     * Whether this permission is granted including app op and does not hold the\n+     * PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED flag.\n+     */\n+    val allowFullGroupGrant = isGranted && !isRevokeWhenRequested\n \n     override fun toString() = buildString {\n         append(name)\n-        if (isGrantedIncludingAppOp) append(\", Granted\") else append(\", NotGranted\")\n+        if (isGranted) append(\", Granted\") else append(\", NotGranted\")\n         if (isPolicyFixed) append(\", PolicyFixed\")\n         if (isSystemFixed) append(\", SystemFixed\")\n         if (isUserFixed) append(\", UserFixed\")\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\nindex aed275d8af..436612d585 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n@@ -102,7 +102,7 @@ suspend fun revokeAppPermissions(\n                         .getInitializedValue() ?: continue\n                 val fixed = group.isBackgroundFixed || group.isForegroundFixed\n                 val granted = group.permissions.any { (_, perm) ->\n-                    perm.isGrantedIncludingAppOp && perm.name !in EXEMPT_PERMISSIONS\n+                    perm.isGranted && perm.name !in EXEMPT_PERMISSIONS\n                 }\n                 if (!fixed && granted &&\n                     !group.isGrantedByDefault &&\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\nindex e105a69bc3..12d7d45ba2 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n@@ -389,7 +389,7 @@ internal object RuntimePermissionsUpgradeController {\n \n                 val allPermissionsWithxemption = bgApp.allPermissions.toMutableMap()\n                 allPermissionsWithxemption[permission.ACCESS_BACKGROUND_LOCATION] =\n-                        LightPermission(perm.pkgInfo, perm.permInfo, perm.isGrantedIncludingAppOp,\n+                        LightPermission(perm.pkgInfo, perm.permInfo, perm.isGranted,\n                         perm.flags or FLAG_PERMISSION_RESTRICTION_UPGRADE_EXEMPT,\n                         perm.foregroundPerms)\n \n@@ -451,7 +451,7 @@ internal object RuntimePermissionsUpgradeController {\n                             ?: continue\n \n                     if (!perm.isUserSet && !perm.isSystemFixed && !perm.isPolicyFixed &&\n-                            !perm.isGrantedIncludingAppOp) {\n+                            !perm.isGranted) {\n                         grants.add(Grant(false, appPermGroup,\n                                 listOf(permission.ACCESS_MEDIA_LOCATION)))\n                     }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nindex a6f74c822c..3bfe7ee691 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -257,11 +257,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n \ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\nindex e743d7c814..d4d63e31f7 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n@@ -868,7 +868,7 @@ class AppPermissionViewModel(\n \n     private fun getIndividualPermissionDetailResId(group: LightAppPermGroup): Pair<Int, Int> {\n         return when (val numRevoked =\n-            group.permissions.filter { !it.value.isGrantedIncludingAppOp }.size) {\n+            group.permissions.filter { !it.value.isGranted }.size) {\n             0 -> R.string.permission_revoked_none to numRevoked\n             group.permissions.size -> R.string.permission_revoked_all to numRevoked\n             else -> R.string.permission_revoked_count to numRevoked\n@@ -938,11 +938,11 @@ class AppPermissionViewModel(\n         for ((permName, permission) in oldGroup.permissions) {\n             val newPermission = newGroup.permissions[permName] ?: continue\n \n-            if (permission.isGrantedIncludingAppOp != newPermission.isGrantedIncludingAppOp ||\n+            if (permission.isGranted != newPermission.isGranted ||\n                 permission.flags != newPermission.flags) {\n                 logAppPermissionFragmentActionReported(changeId, newPermission, buttonPressed)\n                 PermissionDecisionStorageImpl.recordPermissionDecision(app.applicationContext,\n-                    packageName, permGroupName, newPermission.isGrantedIncludingAppOp)\n+                    packageName, permGroupName, newPermission.isGranted)\n             }\n         }\n     }\n@@ -955,10 +955,10 @@ class AppPermissionViewModel(\n         val uid = KotlinUtils.getPackageUid(app, packageName, user) ?: return\n         PermissionControllerStatsLog.write(APP_PERMISSION_FRAGMENT_ACTION_REPORTED, sessionId,\n             changeId, uid, packageName, permission.permInfo.name,\n-            permission.isGrantedIncludingAppOp, permission.flags, buttonPressed)\n+            permission.isGranted, permission.flags, buttonPressed)\n         Log.v(LOG_TAG, \"Permission changed via UI with sessionId=$sessionId changeId=\" +\n             \"$changeId uid=$uid packageName=$packageName permission=\" + permission.permInfo.name +\n-            \" isGranted=\" + permission.isGrantedIncludingAppOp + \" permissionFlags=\" +\n+            \" isGranted=\" + permission.isGranted + \" permissionFlags=\" +\n             permission.flags + \" buttonPressed=$buttonPressed\")\n     }\n \ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\nindex 71f729dc47..1fcd087ff6 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n@@ -261,7 +261,7 @@ class GrantPermissionsViewModel(\n                     //  REVIEW_REQUIRED flag setting\n                     for ((key, state) in states) {\n                         val allAffectedGranted = state.affectedPermissions.all { perm ->\n-                            appPermGroup.permissions[perm]?.isGrantedIncludingAppOp == true &&\n+                            appPermGroup.permissions[perm]?.isGranted == true &&\n                                 appPermGroup.permissions[perm]?.isRevokeWhenRequested == false\n                         } && !appPermGroup.isRuntimePermReviewRequired\n                         if (allAffectedGranted) {\n@@ -300,7 +300,7 @@ class GrantPermissionsViewModel(\n                     for (perm in fgState.affectedPermissions) {\n                         minSdkForOrderedSplitPermissions = maxOf(minSdkForOrderedSplitPermissions,\n                                 splitPermissionTargetSdkMap.getOrDefault(perm, 0))\n-                        if (fgGroup.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+                        if (fgGroup.permissions[perm]?.isGranted == false) {\n                             // If any of the requested permissions is not granted,\n                             // needFgPermissions = true\n                             needFgPermissions = true\n@@ -450,7 +450,7 @@ class GrantPermissionsViewModel(\n                                 fgState.affectedPermissions.contains(ACCESS_FINE_LOCATION)) {\n                             val coarseLocationPerm =\n                                 groupState.group.allPermissions[ACCESS_COARSE_LOCATION]\n-                            if (coarseLocationPerm?.isGrantedIncludingAppOp == true) {\n+                            if (coarseLocationPerm?.isGranted == true) {\n                                 // Upgrade flow\n                                 locationVisibilities[DIALOG_WITH_FINE_LOCATION_ONLY] = true\n                                 message = RequestMessage.FG_FINE_LOCATION_MESSAGE\n@@ -710,7 +710,7 @@ class GrantPermissionsViewModel(\n \n         // Do not attempt to grant background access if foreground access is not either already\n         // granted or requested\n-        if (isBackground && !group.foreground.isGrantedExcludingRWROrAllRWR &&\n+        if (isBackground && !group.foreground.allowFullGroupGrant &&\n             !hasForegroundRequest) {\n             Log.w(LOG_TAG, \"Cannot grant $perm as the matching foreground permission is not \" +\n                 \"already granted.\")\n@@ -724,18 +724,18 @@ class GrantPermissionsViewModel(\n \n         // TODO(b/205888750): remove isRuntimePermReview line once confident in\n         //  REVIEW_REQUIRED flag setting\n-        if ((isBackground && group.background.isGrantedExcludingRWROrAllRWR ||\n-            !isBackground && group.foreground.isGrantedExcludingRWROrAllRWR) &&\n+        if ((isBackground && group.background.allowFullGroupGrant ||\n+            !isBackground && group.foreground.allowFullGroupGrant) &&\n             !group.isRuntimePermReviewRequired) {\n             // If FINE location is not granted, do not grant it automatically when COARSE\n             // location is already granted.\n             if (group.permGroupName == LOCATION &&\n-                    group.allPermissions[ACCESS_FINE_LOCATION]?.isGrantedIncludingAppOp\n+                    group.allPermissions[ACCESS_FINE_LOCATION]?.isGranted\n                     == false) {\n                 return STATE_UNKNOWN\n             }\n \n-            if (group.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+            if (group.permissions[perm]?.isGranted == false) {\n                 if (isBackground) {\n                     KotlinUtils.grantBackgroundRuntimePermissions(app, group, listOf(perm))\n                 } else {\n@@ -939,28 +939,40 @@ class GrantPermissionsViewModel(\n             } else {\n                 PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_GRANTED\n             }\n+            var affectedPermissions: List<String> = groupState.affectedPermissions\n             if (groupState.isBackground) {\n                 KotlinUtils.grantBackgroundRuntimePermissions(app, groupState.group,\n-                    groupState.affectedPermissions)\n+                    affectedPermissions)\n             } else {\n                 if (affectedForegroundPermissions == null) {\n                     KotlinUtils.grantForegroundRuntimePermissions(app, groupState.group,\n-                        groupState.affectedPermissions, isOneTime)\n+                        affectedPermissions, isOneTime)\n                     // This prevents weird flag state when app targetSDK switches from S+ to R-\n                     if (groupState.affectedPermissions.contains(ACCESS_FINE_LOCATION)) {\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(\n                                 app, groupState.group, true)\n                     }\n                 } else {\n+                    affectedPermissions = affectedForegroundPermissions\n                     val newGroup = KotlinUtils.grantForegroundRuntimePermissions(app,\n-                            groupState.group, affectedForegroundPermissions, isOneTime)\n+                            groupState.group, affectedPermissions, isOneTime)\n                     if (!isOneTime || newGroup.isOneTime) {\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(app, newGroup,\n                                 affectedForegroundPermissions.contains(ACCESS_FINE_LOCATION))\n                     }\n                 }\n             }\n-            groupState.state = STATE_ALLOWED\n+            val shouldDenyFullGroupGrant =\n+                groupState.group.isPlatformPermissionGroup &&\n+                        affectedPermissions.none {\n+                            groupState.group.permissions[it]?.isPlatformOrSystem == true\n+                        }\n+            groupState.state =\n+                if (shouldDenyFullGroupGrant) {\n+                    STATE_UNKNOWN\n+                } else {\n+                    STATE_ALLOWED\n+                }\n         } else {\n             if (groupState.isBackground) {\n                 KotlinUtils.revokeBackgroundRuntimePermissions(app, groupState.group,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\nindex 94d0df0d56..79b2c87d81 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\n@@ -133,7 +133,7 @@ class ReviewPermissionsViewModel(\n         val lightPerms = permGroup.allPermissions.values.toList()\n         val permissionCount = lightPerms.size\n         for (i in 0 until permissionCount) {\n-            if (!lightPerms[i].isGrantedIncludingAppOp) {\n+            if (!lightPerms[i].isGranted) {\n                 revokedCount++\n             }\n         }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\nindex 2216802f30..e7f4874e44 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n@@ -470,7 +470,7 @@ object KotlinUtils {\n                     group.userHandle, *flags)\n             }\n             newPerms[permName] = LightPermission(group.packageInfo, perm.permInfo,\n-                perm.isGrantedIncludingAppOp, perm.flags or flagsToSet, perm.foregroundPerms)\n+                perm.isGranted, perm.flags or flagsToSet, perm.foregroundPerms)\n         }\n         return LightAppPermGroup(group.packageInfo, group.permGroupInfo, newPerms,\n             group.hasInstallToRuntimeSplit, group.specialLocationGrant)\n@@ -560,7 +560,7 @@ object KotlinUtils {\n         val newGroup = LightAppPermGroup(group.packageInfo, group.permGroupInfo, newPerms,\n             group.hasInstallToRuntimeSplit, group.specialLocationGrant)\n         // If any permission in the group is one time granted, start one time permission session.\n-        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGrantedIncludingAppOp }) {\n+        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGranted }) {\n             if (SdkLevel.isAtLeastT()) {\n                 app.getSystemService(PermissionManager::class.java)!!.startOneTimePermissionSession(\n                         group.packageName, Utils.getOneTimePermissionsTimeout(),\n@@ -605,11 +605,11 @@ object KotlinUtils {\n         }\n \n         var newFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         var shouldKill = false\n \n         // Grant the permission if needed.\n-        if (!perm.isGrantedIncludingAppOp) {\n+        if (!perm.isGranted) {\n             val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n             // TODO 195016052: investigate adding split permission handling\n@@ -653,14 +653,14 @@ object KotlinUtils {\n \n         // If we newly grant background access to the fine location, double-guess the user some\n         // time later if this was really the right choice.\n-        if (!perm.isGrantedIncludingAppOp && isGranted) {\n+        if (!perm.isGranted && isGranted) {\n             var triggerLocationAccessCheck = false\n             if (perm.name == ACCESS_FINE_LOCATION) {\n                 val bgPerm = group.permissions[perm.backgroundPermission]\n-                triggerLocationAccessCheck = bgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = bgPerm?.isGranted == true\n             } else if (perm.name == ACCESS_BACKGROUND_LOCATION) {\n                 val fgPerm = group.permissions[ACCESS_FINE_LOCATION]\n-                triggerLocationAccessCheck = fgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = fgPerm?.isGranted == true\n             }\n             if (triggerLocationAccessCheck) {\n                 // trigger location access check\n@@ -825,13 +825,13 @@ object KotlinUtils {\n \n         val user = UserHandle.getUserHandleForUid(group.packageInfo.uid)\n         var newFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         val supportsRuntime = group.packageInfo.targetSdkVersion >= Build.VERSION_CODES.M\n         var shouldKill = false\n \n         val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n-        if (perm.isGrantedIncludingAppOp) {\n+        if (perm.isGranted) {\n             if (supportsRuntime && !isPermissionSplitFromNonRuntime(app, perm.name,\n                             group.packageInfo.targetSdkVersion)) {\n                 // Revoke the permission if needed.\n@@ -926,7 +926,7 @@ object KotlinUtils {\n                 val fgPerm = group.permissions[foregroundPermName]\n                 val appOpName = permissionToOp(foregroundPermName) ?: continue\n \n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     wasChanged = wasChanged || setOpMode(appOpName, uid, packageName, MODE_ALLOWED,\n                         appOpsManager)\n                 }\n@@ -936,7 +936,7 @@ object KotlinUtils {\n             if (perm.backgroundPermission != null) {\n                 wasChanged = if (group.permissions.containsKey(perm.backgroundPermission)) {\n                     val bgPerm = group.permissions[perm.backgroundPermission]\n-                    val mode = if (bgPerm != null && bgPerm.isGrantedIncludingAppOp) MODE_ALLOWED\n+                    val mode = if (bgPerm != null && bgPerm.isGranted) MODE_ALLOWED\n                     else MODE_FOREGROUND\n \n                     setOpMode(appOpName, uid, packageName, mode, appOpsManager)\n@@ -987,7 +987,7 @@ object KotlinUtils {\n         if (perm.isBackgroundPermission && perm.foregroundPerms != null) {\n             for (foregroundPermName in perm.foregroundPerms) {\n                 val fgPerm = group.permissions[foregroundPermName]\n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     val appOpName = permissionToOp(foregroundPermName) ?: return false\n                     wasChanged = wasChanged || setOpMode(appOpName, uid, packageName,\n                         MODE_FOREGROUND, appOpsManager)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\nindex f0227cad54..96eccd0a8d 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n@@ -162,7 +162,7 @@ public final class SafetyNetLogger {\n             }\n \n             builder.append(permission.getName()).append('|');\n-            builder.append(permission.isGrantedIncludingAppOp()).append('|');\n+            builder.append(permission.isGranted()).append('|');\n             builder.append(permission.getFlags());\n         }\n     }\ndiff --git a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\nindex df6e921545..7e95fcef8a 100644\n--- a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\n+++ b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\n@@ -110,7 +110,7 @@ class ReviewPermissionsViewModelTest {\n         permissionsMap[\"mockedPermission1\"] = permission2\n \n         whenever(permGroup.allPermissions).thenReturn(permissionsMap)\n-        whenever(permission1.isGrantedIncludingAppOp).thenReturn(true)\n+        whenever(permission1.isGranted).thenReturn(true)\n \n         val summary = model.getSummaryForIndividuallyControlledPermGroup(permGroup)\n         assertEquals(\ndiff --git a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\nindex df4c4e80fa..0d0edc8669 100644\n--- a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\n+++ b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\n@@ -24,6 +24,7 @@ import android.app.AppOpsManager.MODE_FOREGROUND\n import android.app.AppOpsManager.MODE_IGNORED\n import android.app.AppOpsManager.permissionToOp\n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageManager\n import android.content.pm.PackageManager.FLAG_PERMISSION_AUTO_REVOKED\n import android.content.pm.PackageManager.FLAG_PERMISSION_ONE_TIME\n@@ -181,7 +182,8 @@ class GrantRevokeTests {\n         permInfoProtectionFlags: Int = 0\n     ): LightPermission {\n         val permInfo = LightPermInfo(permName, TEST_PACKAGE_NAME, PERM_GROUP_NAME, backgroundPerm,\n-            PermissionInfo.PROTECTION_DANGEROUS, permInfoProtectionFlags, 0)\n+            PermissionInfo.PROTECTION_DANGEROUS, permInfoProtectionFlags, 0,\n+            pkgInfo.appFlags and ApplicationInfo.FLAG_SYSTEM != 0)\n         return LightPermission(pkgInfo, permInfo,\n                 pkgInfo.requestedPermissionsFlags[pkgInfo.requestedPermissions.indexOf(permName)]\n                         == PERMISSION_GRANTED, flags, foregroundPerms)\n@@ -252,7 +254,7 @@ class GrantRevokeTests {\n             val flags = state.second\n \n             assertWithMessage(\"permission $permName grant state incorrect\")\n-                .that(perms[permName]?.isGrantedIncludingAppOp).isEqualTo(granted)\n+                .that(perms[permName]?.isGranted).isEqualTo(granted)\n \n             val actualFlags = perms[permName]!!.flags\n             assertWithMessage(\"permission $permName flags incorrect, expected\" +\n",
                            "file_conflicts": [
                                {
                                    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n                    permission.getName(), permission.isGrantedIncludingAppOp());\n            Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n=======\n                    permission.getName(), permission.isGranted());\n            Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n>>>>>>> UPSTREAM PATCH (commit 46abb4e1fd365a88efdfe3f2b1f87da4d255b41b)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -267,11 +267,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n```",
                                    "patch_apply_output": "patching file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nHunk #1 FAILED at 267.\n1 out of 1 hunk FAILED -- saving rejects to file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java.rej\npatching file PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\nHunk #1 succeeded at 162 (offset 67 lines).",
                                    "inline_merge_output": "patching file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nHunk #1 NOT MERGED at 260-266, merged at 269."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "89aedebdb811ada35a283455a1779026fd84772e",
                            "result": "failure",
                            "downstream_patch_content": "commit 89aedebdb811ada35a283455a1779026fd84772e\nAuthor: Yi-an Chen <theianchen@google.com>\nDate:   Thu Aug 8 01:15:57 2024 +0000\n\n    Fix Dynamic Permission group auto grant behaivor\n    \n    Fix the Dynamic Permission group auto grant behaivor so that a\n    permission group is only considered granted when (1) all permissions\n    were auto-granted or (2) a platform permission in the same group is\n    granted.\n    \n    Bug: 340480881\n    Test: DynamicPermissionsTest\n    Change-Id: I37b550f0c3933bc790c2917a14e917efbcccc4e8\n    Merged-In: Ia0b5776ecc2110a09f4eeaf54dad82169296a100\n\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\nindex 6f33cb1993..5c559c0db6 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n@@ -68,7 +68,7 @@ class LightPermInfoLiveData private constructor(\n         }\n \n         val newValue = try {\n-            LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0))\n+            LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0), null)\n         } catch (e: PackageManager.NameNotFoundException) {\n             Log.w(LOG_TAG, \"Permission \\\"$permissionName\\\" not found\")\n             invalidateSingle(permissionName)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\nindex 78f2f72c63..948815646a 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n@@ -17,6 +17,7 @@\n package com.android.permissioncontroller.permission.data\n \n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageItemInfo\n import android.content.pm.PackageManager\n import android.content.pm.PermissionGroupInfo\n@@ -68,32 +69,31 @@ class PermGroupLiveData private constructor(\n      */\n     override fun onUpdate() {\n         val permissionInfos = mutableMapOf<String, LightPermInfo>()\n-\n         groupInfo = Utils.getGroupInfo(groupName, context) ?: run {\n             Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n             invalidateSingle(groupName)\n             value = null\n             return\n         }\n-\n+        val permInfos = mutableListOf<PermissionInfo>()\n         when (groupInfo) {\n             is PermissionGroupInfo -> {\n-                val permInfos = try {\n-                    Utils.getInstalledRuntimePermissionInfosForGroup(context.packageManager,\n-                        groupName)\n+                try {\n+                    permInfos.addAll(\n+                        Utils.getInstalledRuntimePermissionInfosForGroup(\n+                            context.packageManager,\n+                            groupName\n+                        )\n+                    )\n                 } catch (e: PackageManager.NameNotFoundException) {\n                     Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n                     invalidateSingle(groupName)\n                     value = null\n                     return\n                 }\n-\n-                for (permInfo in permInfos) {\n-                    permissionInfos[permInfo.name] = LightPermInfo(permInfo)\n-                }\n             }\n             is PermissionInfo -> {\n-                permissionInfos[groupInfo.name] = LightPermInfo(groupInfo as PermissionInfo)\n+                permInfos.add(groupInfo as PermissionInfo)\n             }\n             else -> {\n                 value = null\n@@ -101,19 +101,25 @@ class PermGroupLiveData private constructor(\n             }\n         }\n \n-        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n-\n-        value = permGroup\n-\n-        val packageNames = permissionInfos.values.map { permInfo -> permInfo.packageName }\n-            .toMutableSet()\n+        val packageNames = permInfos.map { permInfo -> permInfo.packageName }.toMutableSet()\n         packageNames.add(groupInfo.packageName)\n-\n         // TODO ntmyren: What if the package isn't installed for the system user?\n         val getLiveData = { packageName: String ->\n             LightPackageInfoLiveData[packageName, UserHandle.SYSTEM]\n         }\n         setSourcesToDifference(packageNames, packageLiveDatas, getLiveData)\n+        if (!packageLiveDatas.all { it.value.isInitialized }) {\n+            return\n+        }\n+        for (permInfo in permInfos) {\n+            val lightPackageInfo = packageLiveDatas[permInfo.packageName]?.value\n+            val isSystem =\n+                lightPackageInfo?.let { it.appFlags and ApplicationInfo.FLAG_SYSTEM != 0 }\n+            permissionInfos[permInfo.name] = LightPermInfo(permInfo, isSystem)\n+        }\n+\n+        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n+        value = permGroup\n     }\n \n     override fun onInactive() {\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\nindex 3c87f0b7af..e98f01e478 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n@@ -20,6 +20,7 @@ import android.Manifest\n import android.Manifest.permission.ACCESS_COARSE_LOCATION\n import android.os.Build\n import android.os.UserHandle\n+import com.android.permissioncontroller.permission.utils.Utils\n \n /**\n  * A lightweight version of the AppPermissionGroup data structure. Represents information about a\n@@ -82,11 +83,13 @@ data class LightAppPermGroup(\n         if (name !in backgroundPermNames) name else null\n     }\n \n+    val isPlatformPermissionGroup = permGroupInfo.packageName == Utils.OS_PKG\n+\n     val foreground = AppPermSubGroup(permissions.filter { it.key in foregroundPermNames },\n-        packageInfo, specialLocationGrant)\n+        packageInfo, isPlatformPermissionGroup, specialLocationGrant)\n \n     val background = AppPermSubGroup(permissions.filter { it.key in backgroundPermNames },\n-        packageInfo, specialLocationGrant)\n+        packageInfo, isPlatformPermissionGroup, specialLocationGrant)\n \n     /**\n      * Whether or not this App Permission Group has a permission which has a background mode\n@@ -127,7 +130,7 @@ data class LightAppPermGroup(\n      */\n     val isOneTime = (permGroupName != Manifest.permission_group.LOCATION &&\n             permissions.any { it.value.isOneTime } &&\n-            permissions.none { !it.value.isOneTime && it.value.isGrantedIncludingAppOp }) ||\n+            permissions.none { !it.value.isOneTime && it.value.isGranted }) ||\n             (permGroupName == Manifest.permission_group.LOCATION &&\n                     permissions[ACCESS_COARSE_LOCATION]?.isOneTime == true)\n \n@@ -182,17 +185,23 @@ data class LightAppPermGroup(\n      *\n      * @param permissions The permissions contained within this subgroup, a subset of those contained\n      * in the full group\n+     * @param isPlatformPermissionGroup Whether this is a platform permission group\n      * @param specialLocationGrant Whether this is a special location package\n      */\n     data class AppPermSubGroup internal constructor(\n         private val permissions: Map<String, LightPermission>,\n         private val packageInfo: LightPackageInfo,\n+        private val isPlatformPermissionGroup: Boolean,\n         private val specialLocationGrant: Boolean?\n     ) {\n-        /**\n-         * Whether any of this App Permission SubGroup's permissions are granted\n-         */\n-        val isGranted = specialLocationGrant ?: permissions.any { it.value.isGrantedIncludingAppOp }\n+        /** Whether any of this App Permission SubGroup's permissions are granted */\n+        val isGranted =\n+            specialLocationGrant\n+                ?: permissions.any {\n+                    val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                    it.value.isGranted && mayGrantByPlatformOrSystem\n+                }\n \n         /**\n          * Whether this App Permission SubGroup should be treated as granted. This means either:\n@@ -201,9 +210,15 @@ data class LightAppPermGroup(\n          * 2) All permissions were auto-granted (all permissions are all granted and all\n          * RevokeWhenRequested.)\n          */\n-        val isGrantedExcludingRWROrAllRWR = specialLocationGrant ?: (permissions\n-            .any { it.value.isGrantedIncludingAppOp && !it.value.isRevokeWhenRequested } ||\n-            permissions.all { it.value.isGrantedIncludingAppOp && it.value.isRevokeWhenRequested })\n+        val allowFullGroupGrant =\n+            specialLocationGrant\n+                ?: (permissions.any {\n+                    val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                    it.value.allowFullGroupGrant && mayGrantByPlatformOrSystem\n+                } || permissions.all {\n+                    it.value.isGranted && it.value.isRevokeWhenRequested\n+                })\n \n         /**\n          * Whether any of this App Permission SubGroup's permissions are granted by default\n@@ -215,7 +230,7 @@ data class LightAppPermGroup(\n          * none of the granted permissions are not one-time.\n          */\n         val isOneTime = permissions.any { it.value.isOneTime } &&\n-                permissions.none { it.value.isGrantedIncludingAppOp && !it.value.isOneTime }\n+                permissions.none { it.value.isGranted && !it.value.isOneTime }\n \n         /**\n          * Whether any of this App Permission Subgroup's foreground permissions are fixed by policy\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\nindex 0f6b6c000c..cb6c47c761 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n@@ -58,7 +58,9 @@ data class LightPackageInfo(\n         pI: PackageInfo\n     ) : this(\n         pI.packageName,\n-        pI.permissions?.map { perm -> LightPermInfo(perm) } ?: emptyList(),\n+        pI.permissions?.map { perm ->\n+            LightPermInfo(perm, pI.applicationInfo!!.flags and ApplicationInfo.FLAG_SYSTEM != 0)\n+        } ?: emptyList(),\n         pI.requestedPermissions?.toList() ?: emptyList(),\n         pI.requestedPermissionsFlags?.toList() ?: emptyList(),\n         pI.applicationInfo.uid,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\nindex 3954b74722..582742da43 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n@@ -30,6 +30,7 @@ import android.content.pm.PermissionInfo\n  * @param protection The protection level of this permission\n  * @param protection Extra information about the protection of this permission\n  * @param flags The system flags of this permission\n+ * @param isSystem Whether this permission is defined by a system app\n  */\n data class LightPermInfo(\n     val name: String,\n@@ -38,11 +39,13 @@ data class LightPermInfo(\n     val backgroundPermission: String?,\n     val protection: Int,\n     val protectionFlags: Int,\n-    val flags: Int\n+    val flags: Int,\n+    val isSystem: Boolean?\n ) {\n-    constructor (permInfo: PermissionInfo): this(permInfo.name, permInfo.packageName,\n-        permInfo.group, permInfo.backgroundPermission, permInfo.protection,\n-        permInfo.protectionFlags, permInfo.flags)\n+    constructor (permInfo: PermissionInfo, isSystem: Boolean?) : this(\n+        permInfo.name, permInfo.packageName, permInfo.group, permInfo.backgroundPermission,\n+        permInfo.protection, permInfo.protectionFlags, permInfo.flags, isSystem\n+    )\n \n     /**\n      * Gets the PermissionInfo for this permission from the system.\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\nindex fd7d82dfcb..0ee60e5bff 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n@@ -28,7 +28,7 @@ import com.android.permissioncontroller.permission.utils.Utils\n  *\n  * @param pkgInfo The package requesting the permission\n  * @param permInfo The permissionInfo this represents\n- * @param isGrantedIncludingAppOp Whether or not this permission is functionally granted.\n+ * @param isGranted Whether or not this permission is functionally granted.\n  * A non-granted app op but granted permission is counted as not granted\n  * @param flags The PermissionController flags for this permission\n  * @param foregroundPerms The foreground permission names corresponding to this permission, if this\n@@ -37,7 +37,7 @@ import com.android.permissioncontroller.permission.utils.Utils\n data class LightPermission(\n     val pkgInfo: LightPackageInfo,\n     val permInfo: LightPermInfo,\n-    val isGrantedIncludingAppOp: Boolean,\n+    val isGranted: Boolean,\n     val flags: Int,\n     val foregroundPerms: List<String>?\n ) {\n@@ -97,9 +97,9 @@ data class LightPermission(\n     val isRevokeWhenRequested = flags and PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED != 0\n     /** Whether this permission is user sensitive in its current grant state */\n     val isUserSensitive = !isRuntimePlatformPermission(permInfo.name) ||\n-            (isGrantedIncludingAppOp &&\n+            (isGranted &&\n                     (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED) != 0) ||\n-            (!isGrantedIncludingAppOp &&\n+            (!isGranted &&\n                     (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED) != 0)\n     /** Whether the permission is restricted */\n     val isRestricted = when {\n@@ -120,10 +120,17 @@ data class LightPermission(\n      */\n     val isSelectedLocationAccuracy =\n         flags and PackageManager.FLAG_PERMISSION_SELECTED_LOCATION_ACCURACY != 0\n+    /** Whether this permission is defined by platform or a system app */\n+    val isPlatformOrSystem = permInfo.packageName == Utils.OS_PKG || permInfo.isSystem == true\n+    /**\n+     * Whether this permission is granted including app op and does not hold the\n+     * PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED flag.\n+     */\n+    val allowFullGroupGrant = isGranted && !isRevokeWhenRequested\n \n     override fun toString() = buildString {\n         append(name)\n-        if (isGrantedIncludingAppOp) append(\", Granted\") else append(\", NotGranted\")\n+        if (isGranted) append(\", Granted\") else append(\", NotGranted\")\n         if (isPolicyFixed) append(\", PolicyFixed\")\n         if (isSystemFixed) append(\", SystemFixed\")\n         if (isUserFixed) append(\", UserFixed\")\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\nindex ae9ccf19ed..3845a73dc3 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n@@ -114,7 +114,7 @@ suspend fun revokeAppPermissions(\n                         .getInitializedValue() ?: continue\n                 val fixed = group.isBackgroundFixed || group.isForegroundFixed\n                 val granted = group.permissions.any { (_, perm) ->\n-                    perm.isGrantedIncludingAppOp && perm.name !in EXEMPT_PERMISSIONS\n+                    perm.isGranted && perm.name !in EXEMPT_PERMISSIONS\n                 }\n                 if (!fixed && granted &&\n                     !group.isGrantedByDefault &&\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\nindex 3405ab0144..19b2b4803e 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n@@ -412,7 +412,7 @@ internal object RuntimePermissionsUpgradeController {\n \n                 val allPermissionsWithxemption = bgApp.allPermissions.toMutableMap()\n                 allPermissionsWithxemption[permission.ACCESS_BACKGROUND_LOCATION] =\n-                        LightPermission(perm.pkgInfo, perm.permInfo, perm.isGrantedIncludingAppOp,\n+                        LightPermission(perm.pkgInfo, perm.permInfo, perm.isGranted,\n                         perm.flags or FLAG_PERMISSION_RESTRICTION_UPGRADE_EXEMPT,\n                         perm.foregroundPerms)\n \n@@ -474,7 +474,7 @@ internal object RuntimePermissionsUpgradeController {\n                             ?: continue\n \n                     if (!perm.isUserSet && !perm.isSystemFixed && !perm.isPolicyFixed &&\n-                            !perm.isGrantedIncludingAppOp) {\n+                            !perm.isGranted) {\n                         grants.add(Grant(false, appPermGroup,\n                                 listOf(permission.ACCESS_MEDIA_LOCATION)))\n                     }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nindex 5e5c221aec..74719ef9f5 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -257,11 +257,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n \ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\nindex 99b40d8a79..169cc72227 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n@@ -501,9 +501,9 @@ class AppPermissionViewModel(\n             // 2. Else if FINE or COARSE have the isSelectedLocationAccuracy flag set, then return\n             //    true if FINE isSelectedLocationAccuracy is set.\n             // 3. Else, return default precision from device config.\n-            return if (fineLocation.isGrantedIncludingAppOp ||\n-                            coarseLocation.isGrantedIncludingAppOp) {\n-                fineLocation.isGrantedIncludingAppOp\n+            return if (fineLocation.isGranted ||\n+                            coarseLocation.isGranted) {\n+                fineLocation.isGranted\n             } else if (fineLocation.isSelectedLocationAccuracy ||\n                             coarseLocation.isSelectedLocationAccuracy) {\n                 fineLocation.isSelectedLocationAccuracy\n@@ -1040,7 +1040,7 @@ class AppPermissionViewModel(\n \n     private fun getIndividualPermissionDetailResId(group: LightAppPermGroup): Pair<Int, Int> {\n         return when (val numRevoked =\n-            group.permissions.filter { !it.value.isGrantedIncludingAppOp }.size) {\n+            group.permissions.filter { !it.value.isGranted }.size) {\n             0 -> R.string.permission_revoked_none to numRevoked\n             group.permissions.size -> R.string.permission_revoked_all to numRevoked\n             else -> R.string.permission_revoked_count to numRevoked\n@@ -1110,11 +1110,11 @@ class AppPermissionViewModel(\n         for ((permName, permission) in oldGroup.permissions) {\n             val newPermission = newGroup.permissions[permName] ?: continue\n \n-            if (permission.isGrantedIncludingAppOp != newPermission.isGrantedIncludingAppOp ||\n+            if (permission.isGranted != newPermission.isGranted ||\n                 permission.flags != newPermission.flags) {\n                 logAppPermissionFragmentActionReported(changeId, newPermission, buttonPressed)\n                 PermissionDecisionStorageImpl.recordPermissionDecision(app.applicationContext,\n-                    packageName, permGroupName, newPermission.isGrantedIncludingAppOp)\n+                    packageName, permGroupName, newPermission.isGranted)\n                 PermissionChangeStorageImpl.recordPermissionChange(packageName)\n             }\n         }\n@@ -1138,10 +1138,10 @@ class AppPermissionViewModel(\n         val uid = KotlinUtils.getPackageUid(app, packageName, user) ?: return\n         PermissionControllerStatsLog.write(APP_PERMISSION_FRAGMENT_ACTION_REPORTED, sessionId,\n             changeId, uid, packageName, permission.permInfo.name,\n-            permission.isGrantedIncludingAppOp, permission.flags, buttonPressed)\n+            permission.isGranted, permission.flags, buttonPressed)\n         Log.v(LOG_TAG, \"Permission changed via UI with sessionId=$sessionId changeId=\" +\n             \"$changeId uid=$uid packageName=$packageName permission=\" + permission.permInfo.name +\n-            \" isGranted=\" + permission.isGrantedIncludingAppOp + \" permissionFlags=\" +\n+            \" isGranted=\" + permission.isGranted + \" permissionFlags=\" +\n             permission.flags + \" buttonPressed=$buttonPressed\")\n     }\n \n@@ -1178,7 +1178,7 @@ class AppPermissionViewModel(\n         val partialPerms = getPartialStorageGrantPermissionsForGroup(group)\n \n         return group.isGranted && group.permissions.values.all {\n-            it.name in partialPerms || (it.name !in partialPerms && !it.isGrantedIncludingAppOp)\n+            it.name in partialPerms || (it.name !in partialPerms && !it.isGranted)\n         }\n     }\n }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\nindex 0680ffcd29..3891550f05 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n@@ -301,7 +301,7 @@ class GrantPermissionsViewModel(\n                 if (states.isNotEmpty()) {\n                     for ((key, state) in states) {\n                         val allAffectedGranted = state.affectedPermissions.all { perm ->\n-                            appPermGroup.permissions[perm]?.isGrantedIncludingAppOp == true &&\n+                            appPermGroup.permissions[perm]?.isGranted == true &&\n                                 appPermGroup.permissions[perm]?.isRevokeWhenRequested == false\n                         }\n                         if (allAffectedGranted) {\n@@ -340,7 +340,7 @@ class GrantPermissionsViewModel(\n                     for (perm in fgState.affectedPermissions) {\n                         minSdkForOrderedSplitPermissions = maxOf(minSdkForOrderedSplitPermissions,\n                                 splitPermissionTargetSdkMap.getOrDefault(perm, 0))\n-                        if (fgGroup.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+                        if (fgGroup.permissions[perm]?.isGranted == false) {\n                             // If any of the requested permissions is not granted,\n                             // needFgPermissions = true\n                             needFgPermissions = true\n@@ -373,7 +373,7 @@ class GrantPermissionsViewModel(\n                     // If the USER_SELECTED permission is user fixed and granted, or the app is only\n                     // requesting USER_SELECTED, direct straight to photo picker\n                     val userPerm = groupState.group.permissions[READ_MEDIA_VISUAL_USER_SELECTED]\n-                    if ((userPerm?.isUserFixed == true && userPerm.isGrantedIncludingAppOp) ||\n+                    if ((userPerm?.isUserFixed == true && userPerm.isGranted) ||\n                         groupState.affectedPermissions == listOf(READ_MEDIA_VISUAL_USER_SELECTED)) {\n                         requestInfos.add(RequestInfo(groupInfo, openPhotoPicker = true))\n                         continue\n@@ -524,7 +524,7 @@ class GrantPermissionsViewModel(\n                                 fgState.affectedPermissions.contains(ACCESS_FINE_LOCATION)) {\n                             val coarseLocationPerm =\n                                 groupState.group.allPermissions[ACCESS_COARSE_LOCATION]\n-                            if (coarseLocationPerm?.isGrantedIncludingAppOp == true) {\n+                            if (coarseLocationPerm?.isGranted == true) {\n                                 // Upgrade flow\n                                 locationVisibilities[DIALOG_WITH_FINE_LOCATION_ONLY] = true\n                                 message = RequestMessage.FG_FINE_LOCATION_MESSAGE\n@@ -773,7 +773,7 @@ class GrantPermissionsViewModel(\n                     return true\n                 }\n             } else if (perm in getPartialStorageGrantPermissionsForGroup(group) &&\n-                lightPermission.isGrantedIncludingAppOp) {\n+                lightPermission.isGranted) {\n                 // If a partial storage permission is granted as fixed, we should immediately show\n                 // the photo picker\n                 return true\n@@ -825,7 +825,7 @@ class GrantPermissionsViewModel(\n \n         // Do not attempt to grant background access if foreground access is not either already\n         // granted or requested\n-        if (isBackground && !group.foreground.isGrantedExcludingRWROrAllRWR &&\n+        if (isBackground && !group.foreground.allowFullGroupGrant &&\n             !hasForegroundRequest) {\n             Log.w(LOG_TAG, \"Cannot grant $perm as the matching foreground permission is not \" +\n                 \"already granted.\")\n@@ -837,10 +837,10 @@ class GrantPermissionsViewModel(\n             return STATE_SKIPPED\n         }\n \n-        if ((isBackground && group.background.isGrantedExcludingRWROrAllRWR ||\n-            !isBackground && group.foreground.isGrantedExcludingRWROrAllRWR) &&\n+        if ((isBackground && group.background.allowFullGroupGrant ||\n+            !isBackground && group.foreground.allowFullGroupGrant) &&\n             canAutoGrantWholeGroup(group)) {\n-            if (group.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+            if (group.permissions[perm]?.isGranted == false) {\n                 if (isBackground) {\n                     grantBackgroundRuntimePermissions(app, group, listOf(perm))\n                 } else {\n@@ -869,7 +869,7 @@ class GrantPermissionsViewModel(\n         // If FINE location is not granted, do not grant it automatically when COARSE\n         // location is already granted.\n         if (group.permGroupName == LOCATION &&\n-            group.allPermissions[ACCESS_FINE_LOCATION]?.isGrantedIncludingAppOp == false) {\n+            group.allPermissions[ACCESS_FINE_LOCATION]?.isGranted == false) {\n             return false\n         }\n         // If READ_MEDIA_VISUAL_USER_SELECTED is the only permission in the group that is granted,\n@@ -893,7 +893,7 @@ class GrantPermissionsViewModel(\n \n         val partialPerms = getPartialStorageGrantPermissionsForGroup(group)\n         return group.isGranted && group.permissions.values.all {\n-            it.name in partialPerms || (it.name !in partialPerms && !it.isGrantedIncludingAppOp)\n+            it.name in partialPerms || (it.name !in partialPerms && !it.isGranted)\n         }\n     }\n \n@@ -1114,28 +1114,39 @@ class GrantPermissionsViewModel(\n             } else {\n                 PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_GRANTED\n             }\n+            var affectedPermissions: List<String> = groupState.affectedPermissions\n             if (groupState.isBackground) {\n-                grantBackgroundRuntimePermissions(app, groupState.group,\n-                    groupState.affectedPermissions)\n+                grantBackgroundRuntimePermissions(app, groupState.group, affectedPermissions)\n             } else {\n                 if (affectedForegroundPermissions == null) {\n                     grantForegroundRuntimePermissions(app, groupState.group,\n-                        groupState.affectedPermissions, isOneTime)\n+                        affectedPermissions, isOneTime)\n                     // This prevents weird flag state when app targetSDK switches from S+ to R-\n                     if (groupState.affectedPermissions.contains(ACCESS_FINE_LOCATION)) {\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(\n                                 app, groupState.group, true)\n                     }\n                 } else {\n+                    affectedPermissions = affectedForegroundPermissions\n                     val newGroup = grantForegroundRuntimePermissions(app,\n-                            groupState.group, affectedForegroundPermissions, isOneTime)\n+                            groupState.group, affectedPermissions, isOneTime)\n                     if (!isOneTime || newGroup.isOneTime) {\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(app, newGroup,\n                                 affectedForegroundPermissions.contains(ACCESS_FINE_LOCATION))\n                     }\n                 }\n             }\n-            groupState.state = STATE_ALLOWED\n+            val shouldDenyFullGroupGrant =\n+                groupState.group.isPlatformPermissionGroup &&\n+                        affectedPermissions.none {\n+                            groupState.group.permissions[it]?.isPlatformOrSystem == true\n+                        }\n+            groupState.state =\n+                if (shouldDenyFullGroupGrant) {\n+                    STATE_UNKNOWN\n+                } else {\n+                    STATE_ALLOWED\n+                }\n         } else {\n             if (groupState.isBackground) {\n                 revokeBackgroundRuntimePermissions(app, groupState.group,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\nindex 4e1fc1861d..7431637a83 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\n@@ -135,7 +135,7 @@ class ReviewPermissionsViewModel(\n         val lightPerms = permGroup.allPermissions.values.toList()\n         val permissionCount = lightPerms.size\n         for (i in 0 until permissionCount) {\n-            if (!lightPerms[i].isGrantedIncludingAppOp) {\n+            if (!lightPerms[i].isGranted) {\n                 revokedCount++\n             }\n         }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\nindex f9345ef58f..fb188fca12 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n@@ -694,7 +694,7 @@ object KotlinUtils {\n                     group.userHandle, *flags)\n             }\n             newPerms[permName] = LightPermission(group.packageInfo, perm.permInfo,\n-                perm.isGrantedIncludingAppOp, perm.flags or flagsToSet, perm.foregroundPerms)\n+                perm.isGranted, perm.flags or flagsToSet, perm.foregroundPerms)\n         }\n         return LightAppPermGroup(group.packageInfo, group.permGroupInfo, newPerms,\n             group.hasInstallToRuntimeSplit, group.specialLocationGrant)\n@@ -790,7 +790,7 @@ object KotlinUtils {\n         val newGroup = LightAppPermGroup(group.packageInfo, group.permGroupInfo, newPerms,\n             group.hasInstallToRuntimeSplit, group.specialLocationGrant)\n         // If any permission in the group is one time granted, start one time permission session.\n-        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGrantedIncludingAppOp }) {\n+        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGranted }) {\n             if (SdkLevel.isAtLeastT()) {\n                 app.getSystemService(PermissionManager::class.java)!!.startOneTimePermissionSession(\n                         group.packageName, Utils.getOneTimePermissionsTimeout(),\n@@ -842,11 +842,11 @@ object KotlinUtils {\n \n         var newFlags = perm.flags\n         var oldFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         var shouldKill = false\n \n         // Grant the permission if needed.\n-        if (!perm.isGrantedIncludingAppOp) {\n+        if (!perm.isGranted) {\n             val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n             // TODO 195016052: investigate adding split permission handling\n@@ -906,14 +906,14 @@ object KotlinUtils {\n \n         // If we newly grant background access to the fine location, double-guess the user some\n         // time later if this was really the right choice.\n-        if (!perm.isGrantedIncludingAppOp && isGranted) {\n+        if (!perm.isGranted && isGranted) {\n             var triggerLocationAccessCheck = false\n             if (perm.name == ACCESS_FINE_LOCATION) {\n                 val bgPerm = group.permissions[perm.backgroundPermission]\n-                triggerLocationAccessCheck = bgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = bgPerm?.isGranted == true\n             } else if (perm.name == ACCESS_BACKGROUND_LOCATION) {\n                 val fgPerm = group.permissions[ACCESS_FINE_LOCATION]\n-                triggerLocationAccessCheck = fgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = fgPerm?.isGranted == true\n             }\n             if (triggerLocationAccessCheck) {\n                 // trigger location access check\n@@ -1113,13 +1113,13 @@ object KotlinUtils {\n \n         val user = UserHandle.getUserHandleForUid(group.packageInfo.uid)\n         var newFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         val supportsRuntime = group.packageInfo.targetSdkVersion >= Build.VERSION_CODES.M\n         var shouldKill = false\n \n         val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n-        if (perm.isGrantedIncludingAppOp || (perm.isCompatRevoked && forceRemoveRevokedCompat)) {\n+        if (perm.isGranted || (perm.isCompatRevoked && forceRemoveRevokedCompat)) {\n             if (supportsRuntime && !isPermissionSplitFromNonRuntime(app, perm.name,\n                             group.packageInfo.targetSdkVersion)) {\n                 // Revoke the permission if needed.\n@@ -1165,14 +1165,14 @@ object KotlinUtils {\n \n         // If we revoke background access to the fine location, we trigger a check to remove\n         // notification warning about background location access\n-        if (perm.isGrantedIncludingAppOp && !isGranted) {\n+        if (perm.isGranted && !isGranted) {\n             var cancelLocationAccessWarning = false\n             if (perm.name == ACCESS_FINE_LOCATION) {\n                 val bgPerm = group.permissions[perm.backgroundPermission]\n-                cancelLocationAccessWarning = bgPerm?.isGrantedIncludingAppOp == true\n+                cancelLocationAccessWarning = bgPerm?.isGranted == true\n             } else if (perm.name == ACCESS_BACKGROUND_LOCATION) {\n                 val fgPerm = group.permissions[ACCESS_FINE_LOCATION]\n-                cancelLocationAccessWarning = fgPerm?.isGrantedIncludingAppOp == true\n+                cancelLocationAccessWarning = fgPerm?.isGranted == true\n             }\n             if (cancelLocationAccessWarning) {\n                 // cancel location access warning notification\n@@ -1238,7 +1238,7 @@ object KotlinUtils {\n                 val fgPerm = group.permissions[foregroundPermName]\n                 val appOpName = permissionToOp(foregroundPermName) ?: continue\n \n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     wasChanged = setOpMode(appOpName, uid, packageName, MODE_ALLOWED,\n                         appOpsManager) || wasChanged\n                 }\n@@ -1248,7 +1248,7 @@ object KotlinUtils {\n             if (perm.backgroundPermission != null) {\n                 wasChanged = if (group.permissions.containsKey(perm.backgroundPermission)) {\n                     val bgPerm = group.permissions[perm.backgroundPermission]\n-                    val mode = if (bgPerm != null && bgPerm.isGrantedIncludingAppOp) MODE_ALLOWED\n+                    val mode = if (bgPerm != null && bgPerm.isGranted) MODE_ALLOWED\n                     else MODE_FOREGROUND\n \n                     setOpMode(appOpName, uid, packageName, mode, appOpsManager)\n@@ -1299,7 +1299,7 @@ object KotlinUtils {\n         if (perm.isBackgroundPermission && perm.foregroundPerms != null) {\n             for (foregroundPermName in perm.foregroundPerms) {\n                 val fgPerm = group.permissions[foregroundPermName]\n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     val appOpName = permissionToOp(foregroundPermName) ?: return false\n                     wasChanged = wasChanged || setOpMode(appOpName, uid, packageName,\n                         MODE_FOREGROUND, appOpsManager)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\nindex 828857cc6d..c9b023c443 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n@@ -95,7 +95,7 @@ public final class SafetyNetLogger {\n             }\n \n             builder.append(permission.getName()).append('|');\n-            builder.append(permission.isGrantedIncludingAppOp()).append('|');\n+            builder.append(permission.isGranted()).append('|');\n             builder.append(permission.getFlags());\n         }\n     }\ndiff --git a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\nindex 0f42160663..55aa40e50c 100644\n--- a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\n+++ b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\n@@ -110,7 +110,7 @@ class ReviewPermissionsViewModelTest {\n         permissionsMap[\"mockedPermission1\"] = permission2\n \n         whenever(permGroup.allPermissions).thenReturn(permissionsMap)\n-        whenever(permission1.isGrantedIncludingAppOp).thenReturn(true)\n+        whenever(permission1.isGranted).thenReturn(true)\n \n         val summary = model.getSummaryForIndividuallyControlledPermGroup(permGroup)\n         assertEquals(\ndiff --git a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\nindex be6518b235..c688273c6c 100644\n--- a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\n+++ b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\n@@ -24,6 +24,7 @@ import android.app.AppOpsManager.MODE_FOREGROUND\n import android.app.AppOpsManager.MODE_IGNORED\n import android.app.AppOpsManager.permissionToOp\n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageManager\n import android.content.pm.PackageManager.FLAG_PERMISSION_AUTO_REVOKED\n import android.content.pm.PackageManager.FLAG_PERMISSION_ONE_TIME\n@@ -180,7 +181,8 @@ class GrantRevokeTests {\n         permInfoProtectionFlags: Int = 0\n     ): LightPermission {\n         val permInfo = LightPermInfo(permName, TEST_PACKAGE_NAME, PERM_GROUP_NAME, backgroundPerm,\n-            PermissionInfo.PROTECTION_DANGEROUS, permInfoProtectionFlags, 0)\n+            PermissionInfo.PROTECTION_DANGEROUS, permInfoProtectionFlags, 0,\n+            pkgInfo.appFlags and ApplicationInfo.FLAG_SYSTEM != 0)\n         return LightPermission(pkgInfo, permInfo,\n                 pkgInfo.requestedPermissionsFlags[pkgInfo.requestedPermissions.indexOf(permName)]\n                         == PERMISSION_GRANTED, flags, foregroundPerms)\n@@ -251,7 +253,7 @@ class GrantRevokeTests {\n             val flags = state.second\n \n             assertWithMessage(\"permission $permName grant state incorrect\")\n-                .that(perms[permName]?.isGrantedIncludingAppOp).isEqualTo(granted)\n+                .that(perms[permName]?.isGranted).isEqualTo(granted)\n \n             val actualFlags = perms[permName]!!.flags\n             assertWithMessage(\"permission $permName flags incorrect, expected\" +\n",
                            "file_conflicts": [
                                {
                                    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n                    permission.getName(), permission.isGrantedIncludingAppOp());\n            Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n=======\n                    permission.getName(), permission.isGranted());\n            Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n>>>>>>> UPSTREAM PATCH (commit 46abb4e1fd365a88efdfe3f2b1f87da4d255b41b)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -267,11 +267,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n```",
                                    "patch_apply_output": "patching file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nHunk #1 FAILED at 267.\n1 out of 1 hunk FAILED -- saving rejects to file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java.rej\npatching file PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java",
                                    "inline_merge_output": "patching file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nHunk #1 NOT MERGED at 260-266, merged at 269."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-375160214",
            "aliases": [
                "A-375160214",
                "CVE-2025-22406"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375160214",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "00555617ddbbc1a19089104c084d14f465c971ce"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 00555617ddbbc1a19089104c084d14f465c971ce Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Sat, 2 Nov 2024 02:29:10 +0000\nSubject: [PATCH] Fix more memory-unsafe logging\n\nIn various locations around the stack, log statements use structures that\nmay, in exceptional cases, have been freed by preceding calls.  This can\nlead to use after free and potentially to security vulnerabilities.\n\nUse local variables instead, or store the length before the call if no\nlocal variable is already convenient.\n\nBug: 375404242\nBug: 375398779\nBug: 375397720\nBug: 375397164\nBug: 375397370\nBug: 375396810\nBug: 375159652\nBug: 375160214\nBug: 375159480\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: Ia50e074de751661a0e617bfffa17871497b8d1ea\n---\n system/stack/avct/avct_lcb_act.cc    | 5 ++++-\n system/stack/bnep/bnep_main.cc       | 4 +++-\n system/stack/bnep/bnep_utils.cc      | 3 ++-\n system/stack/hid/hidd_conn.cc        | 4 ++--\n system/stack/rfcomm/rfc_ts_frames.cc | 3 ++-\n system/stack/rfcomm/rfc_utils.cc     | 3 ++-\n system/stack/sdp/sdp_discovery.cc    | 2 +-\n system/stack/sdp/sdp_server.cc       | 4 ++--\n 8 files changed, 18 insertions(+), 10 deletions(-)\n\ndiff --git a/system/stack/avct/avct_lcb_act.cc b/system/stack/avct/avct_lcb_act.cc\nindex 986bce7d34..32da9d865b 100644\n--- a/system/stack/avct/avct_lcb_act.cc\n+++ b/system/stack/avct/avct_lcb_act.cc\n@@ -727,10 +727,13 @@ void avct_lcb_msg_ind(tAVCT_LCB* p_lcb, tAVCT_LCB_EVT* p_data) {\n     p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n     AVCT_BUILD_HDR(p, label, AVCT_PKT_TYPE_SINGLE, AVCT_REJ);\n     UINT16_TO_BE_STREAM(p, pid);\n+\n+    uint16_t len = p_buf->len;\n+\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_lcb->ch_lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} lcid:0x{:04x} len:{}\", p_lcb->peer_addr,\n-                p_lcb->ch_lcid, p_buf->len);\n+                p_lcb->ch_lcid, len);\n     }\n   }\n }\ndiff --git a/system/stack/bnep/bnep_main.cc b/system/stack/bnep/bnep_main.cc\nindex e0e3c4540c..adf3c8666e 100644\n--- a/system/stack/bnep/bnep_main.cc\n+++ b/system/stack/bnep/bnep_main.cc\n@@ -295,10 +295,12 @@ static void bnep_congestion_ind(uint16_t l2cap_cid, bool is_congested) {\n         break;\n       }\n \n+      uint16_t len = p_buf->len;\n+\n       if (stack::l2cap::get_interface().L2CA_DataWrite(l2cap_cid, p_buf) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n         log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda, l2cap_cid,\n-                  p_buf->len);\n+                  len);\n       }\n     }\n   }\ndiff --git a/system/stack/bnep/bnep_utils.cc b/system/stack/bnep/bnep_utils.cc\nindex 252facf668..4092d9afee 100644\n--- a/system/stack/bnep/bnep_utils.cc\n+++ b/system/stack/bnep/bnep_utils.cc\n@@ -411,10 +411,11 @@ void bnepu_check_send_packet(tBNEP_CONN* p_bcb, BT_HDR* p_buf) {\n       fixed_queue_enqueue(p_bcb->xmit_q, p_buf);\n     }\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_bcb->l2cap_cid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda,\n-                p_bcb->l2cap_cid, p_buf->len);\n+                p_bcb->l2cap_cid, len);\n     }\n   }\n }\ndiff --git a/system/stack/hid/hidd_conn.cc b/system/stack/hid/hidd_conn.cc\nindex c64a7b9104..695e5d6c84 100644\n--- a/system/stack/hid/hidd_conn.cc\n+++ b/system/stack/hid/hidd_conn.cc\n@@ -88,10 +88,10 @@ static void hidd_check_config_done() {\n \n     // send outstanding data on intr\n     if (hd_cb.pending_data) {\n+      uint16_t len = hd_cb.pending_data->len;\n       if (stack::l2cap::get_interface().L2CA_DataWrite(p_hcon->intr_cid, hd_cb.pending_data) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n-        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid,\n-                  hd_cb.pending_data->len);\n+        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid, len);\n       }\n       hd_cb.pending_data = NULL;\n     }\ndiff --git a/system/stack/rfcomm/rfc_ts_frames.cc b/system/stack/rfcomm/rfc_ts_frames.cc\nindex ea57abf6dc..e93cfed9b8 100644\n--- a/system/stack/rfcomm/rfc_ts_frames.cc\n+++ b/system/stack/rfcomm/rfc_ts_frames.cc\n@@ -201,10 +201,11 @@ void rfc_send_buf_uih(tRFC_MCB* p_mcb, uint8_t dlci, BT_HDR* p_buf) {\n   if (dlci == RFCOMM_MX_DLCI) {\n     rfc_check_send_cmd(p_mcb, p_buf);\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p_buf->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/rfcomm/rfc_utils.cc b/system/stack/rfcomm/rfc_utils.cc\nindex 23420892cb..0c5074db76 100644\n--- a/system/stack/rfcomm/rfc_utils.cc\n+++ b/system/stack/rfcomm/rfc_utils.cc\n@@ -428,9 +428,10 @@ void rfc_check_send_cmd(tRFC_MCB* p_mcb, BT_HDR* p_buf) {\n     if (p == NULL) {\n       break;\n     }\n+    uint16_t len = p->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p) != tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/sdp/sdp_discovery.cc b/system/stack/sdp/sdp_discovery.cc\nindex 4fa484e14a..6aba1993af 100644\n--- a/system/stack/sdp/sdp_discovery.cc\n+++ b/system/stack/sdp/sdp_discovery.cc\n@@ -877,7 +877,7 @@ static void process_service_attr_rsp(tCONN_CB* p_ccb, uint8_t* p_reply, uint8_t*\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_msg) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-                p_ccb->connection_id, p_msg->len);\n+                p_ccb->connection_id, p - p_start);\n     }\n \n     /* Start inactivity timer */\ndiff --git a/system/stack/sdp/sdp_server.cc b/system/stack/sdp/sdp_server.cc\nindex abd70aedb1..0f379708e9 100644\n--- a/system/stack/sdp/sdp_server.cc\n+++ b/system/stack/sdp/sdp_server.cc\n@@ -300,7 +300,7 @@ static void process_service_search(tCONN_CB* p_ccb, uint16_t trans_num, uint16_t\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n@@ -564,7 +564,7 @@ static void process_service_attr_req(tCONN_CB* p_ccb, uint16_t trans_num, uint16\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "43cfd234de9ba9557118b0014513269cc1aeefda"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-370831157",
            "aliases": [
                "A-370831157",
                "CVE-2024-49745"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-370831157",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "608524d462278c2c9f6716cd94f126c85e9f2e91"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 608524d462278c2c9f6716cd94f126c85e9f2e91 Mon Sep 17 00:00:00 2001\nFrom: Steven Moreland <smoreland@google.com>\nDate: Wed, 2 Oct 2024 01:00:23 +0000\nSubject: [PATCH] libbinder: Parcel: grow rejects large data pos\n\nThis is unexpected behavior so throw an error.\nAllocating this much memory may cause OOM or\nother issues.\n\nBug: 370831157\nTest: fuzzer\nChange-Id: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n---\n libs/binder/Parcel.cpp | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 37113629a8..3d36f2eed7 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -2948,6 +2948,14 @@ status_t Parcel::growData(size_t len)\n         return BAD_VALUE;\n     }\n \n+    if (mDataPos > mDataSize) {\n+        // b/370831157 - this case used to abort. We also don't expect mDataPos < mDataSize, but\n+        // this would only waste a bit of memory, so it's okay.\n+        ALOGE(\"growData only expected at the end of a Parcel. pos: %zu, size: %zu, capacity: %zu\",\n+              mDataPos, len, mDataCapacity);\n+        return BAD_VALUE;\n+    }\n+\n     if (len > SIZE_MAX - mDataSize) return NO_MEMORY; // overflow\n     if (mDataSize + len > SIZE_MAX / 3) return NO_MEMORY; // overflow\n     size_t newSize = ((mDataSize+len)*3)/2;\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "0db4fced4d2c8325c93f61ac4ab385b47e041f23",
                            "result": "success",
                            "downstream_patch_content": "commit 0db4fced4d2c8325c93f61ac4ab385b47e041f23\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Wed Oct 2 01:00:23 2024 +0000\n\n    libbinder: Parcel: grow rejects large data pos\n    \n    This is unexpected behavior so throw an error.\n    Allocating this much memory may cause OOM or\n    other issues.\n    \n    Bug: 370831157\n    Test: fuzzer\n    Merged-In: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n    Change-Id: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n    (cherry picked from commit 608524d462278c2c9f6716cd94f126c85e9f2e91)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 617708f3d4..abdd4875af 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -2253,6 +2253,14 @@ status_t Parcel::growData(size_t len)\n         return BAD_VALUE;\n     }\n \n+    if (mDataPos > mDataSize) {\n+        // b/370831157 - this case used to abort. We also don't expect mDataPos < mDataSize, but\n+        // this would only waste a bit of memory, so it's okay.\n+        ALOGE(\"growData only expected at the end of a Parcel. pos: %zu, size: %zu, capacity: %zu\",\n+              mDataPos, len, mDataCapacity);\n+        return BAD_VALUE;\n+    }\n+\n     if (len > SIZE_MAX - mDataSize) return NO_MEMORY; // overflow\n     if (mDataSize + len > SIZE_MAX / 3) return NO_MEMORY; // overflow\n     size_t newSize = ((mDataSize+len)*3)/2;\n"
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "0db4fced4d2c8325c93f61ac4ab385b47e041f23",
                            "result": "success",
                            "downstream_patch_content": "commit 0db4fced4d2c8325c93f61ac4ab385b47e041f23\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Wed Oct 2 01:00:23 2024 +0000\n\n    libbinder: Parcel: grow rejects large data pos\n    \n    This is unexpected behavior so throw an error.\n    Allocating this much memory may cause OOM or\n    other issues.\n    \n    Bug: 370831157\n    Test: fuzzer\n    Merged-In: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n    Change-Id: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n    (cherry picked from commit 608524d462278c2c9f6716cd94f126c85e9f2e91)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 617708f3d4..abdd4875af 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -2253,6 +2253,14 @@ status_t Parcel::growData(size_t len)\n         return BAD_VALUE;\n     }\n \n+    if (mDataPos > mDataSize) {\n+        // b/370831157 - this case used to abort. We also don't expect mDataPos < mDataSize, but\n+        // this would only waste a bit of memory, so it's okay.\n+        ALOGE(\"growData only expected at the end of a Parcel. pos: %zu, size: %zu, capacity: %zu\",\n+              mDataPos, len, mDataCapacity);\n+        return BAD_VALUE;\n+    }\n+\n     if (len > SIZE_MAX - mDataSize) return NO_MEMORY; // overflow\n     if (mDataSize + len > SIZE_MAX / 3) return NO_MEMORY; // overflow\n     size_t newSize = ((mDataSize+len)*3)/2;\n"
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "94e777ab39848540f9ef9d47229338d8996709d6"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "0db4fced4d2c8325c93f61ac4ab385b47e041f23",
                            "result": "success",
                            "downstream_patch_content": "commit 0db4fced4d2c8325c93f61ac4ab385b47e041f23\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Wed Oct 2 01:00:23 2024 +0000\n\n    libbinder: Parcel: grow rejects large data pos\n    \n    This is unexpected behavior so throw an error.\n    Allocating this much memory may cause OOM or\n    other issues.\n    \n    Bug: 370831157\n    Test: fuzzer\n    Merged-In: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n    Change-Id: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n    (cherry picked from commit 608524d462278c2c9f6716cd94f126c85e9f2e91)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 617708f3d4..abdd4875af 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -2253,6 +2253,14 @@ status_t Parcel::growData(size_t len)\n         return BAD_VALUE;\n     }\n \n+    if (mDataPos > mDataSize) {\n+        // b/370831157 - this case used to abort. We also don't expect mDataPos < mDataSize, but\n+        // this would only waste a bit of memory, so it's okay.\n+        ALOGE(\"growData only expected at the end of a Parcel. pos: %zu, size: %zu, capacity: %zu\",\n+              mDataPos, len, mDataCapacity);\n+        return BAD_VALUE;\n+    }\n+\n     if (len > SIZE_MAX - mDataSize) return NO_MEMORY; // overflow\n     if (mDataSize + len > SIZE_MAX / 3) return NO_MEMORY; // overflow\n     size_t newSize = ((mDataSize+len)*3)/2;\n"
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "0db4fced4d2c8325c93f61ac4ab385b47e041f23",
                            "result": "success",
                            "downstream_patch_content": "commit 0db4fced4d2c8325c93f61ac4ab385b47e041f23\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Wed Oct 2 01:00:23 2024 +0000\n\n    libbinder: Parcel: grow rejects large data pos\n    \n    This is unexpected behavior so throw an error.\n    Allocating this much memory may cause OOM or\n    other issues.\n    \n    Bug: 370831157\n    Test: fuzzer\n    Merged-In: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n    Change-Id: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n    (cherry picked from commit 608524d462278c2c9f6716cd94f126c85e9f2e91)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 617708f3d4..abdd4875af 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -2253,6 +2253,14 @@ status_t Parcel::growData(size_t len)\n         return BAD_VALUE;\n     }\n \n+    if (mDataPos > mDataSize) {\n+        // b/370831157 - this case used to abort. We also don't expect mDataPos < mDataSize, but\n+        // this would only waste a bit of memory, so it's okay.\n+        ALOGE(\"growData only expected at the end of a Parcel. pos: %zu, size: %zu, capacity: %zu\",\n+              mDataPos, len, mDataCapacity);\n+        return BAD_VALUE;\n+    }\n+\n     if (len > SIZE_MAX - mDataSize) return NO_MEMORY; // overflow\n     if (mDataSize + len > SIZE_MAX / 3) return NO_MEMORY; // overflow\n     size_t newSize = ((mDataSize+len)*3)/2;\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-375397164",
            "aliases": [
                "A-375397164",
                "CVE-2025-22408"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375397164",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "00555617ddbbc1a19089104c084d14f465c971ce"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 00555617ddbbc1a19089104c084d14f465c971ce Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Sat, 2 Nov 2024 02:29:10 +0000\nSubject: [PATCH] Fix more memory-unsafe logging\n\nIn various locations around the stack, log statements use structures that\nmay, in exceptional cases, have been freed by preceding calls.  This can\nlead to use after free and potentially to security vulnerabilities.\n\nUse local variables instead, or store the length before the call if no\nlocal variable is already convenient.\n\nBug: 375404242\nBug: 375398779\nBug: 375397720\nBug: 375397164\nBug: 375397370\nBug: 375396810\nBug: 375159652\nBug: 375160214\nBug: 375159480\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: Ia50e074de751661a0e617bfffa17871497b8d1ea\n---\n system/stack/avct/avct_lcb_act.cc    | 5 ++++-\n system/stack/bnep/bnep_main.cc       | 4 +++-\n system/stack/bnep/bnep_utils.cc      | 3 ++-\n system/stack/hid/hidd_conn.cc        | 4 ++--\n system/stack/rfcomm/rfc_ts_frames.cc | 3 ++-\n system/stack/rfcomm/rfc_utils.cc     | 3 ++-\n system/stack/sdp/sdp_discovery.cc    | 2 +-\n system/stack/sdp/sdp_server.cc       | 4 ++--\n 8 files changed, 18 insertions(+), 10 deletions(-)\n\ndiff --git a/system/stack/avct/avct_lcb_act.cc b/system/stack/avct/avct_lcb_act.cc\nindex 986bce7d34..32da9d865b 100644\n--- a/system/stack/avct/avct_lcb_act.cc\n+++ b/system/stack/avct/avct_lcb_act.cc\n@@ -727,10 +727,13 @@ void avct_lcb_msg_ind(tAVCT_LCB* p_lcb, tAVCT_LCB_EVT* p_data) {\n     p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n     AVCT_BUILD_HDR(p, label, AVCT_PKT_TYPE_SINGLE, AVCT_REJ);\n     UINT16_TO_BE_STREAM(p, pid);\n+\n+    uint16_t len = p_buf->len;\n+\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_lcb->ch_lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} lcid:0x{:04x} len:{}\", p_lcb->peer_addr,\n-                p_lcb->ch_lcid, p_buf->len);\n+                p_lcb->ch_lcid, len);\n     }\n   }\n }\ndiff --git a/system/stack/bnep/bnep_main.cc b/system/stack/bnep/bnep_main.cc\nindex e0e3c4540c..adf3c8666e 100644\n--- a/system/stack/bnep/bnep_main.cc\n+++ b/system/stack/bnep/bnep_main.cc\n@@ -295,10 +295,12 @@ static void bnep_congestion_ind(uint16_t l2cap_cid, bool is_congested) {\n         break;\n       }\n \n+      uint16_t len = p_buf->len;\n+\n       if (stack::l2cap::get_interface().L2CA_DataWrite(l2cap_cid, p_buf) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n         log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda, l2cap_cid,\n-                  p_buf->len);\n+                  len);\n       }\n     }\n   }\ndiff --git a/system/stack/bnep/bnep_utils.cc b/system/stack/bnep/bnep_utils.cc\nindex 252facf668..4092d9afee 100644\n--- a/system/stack/bnep/bnep_utils.cc\n+++ b/system/stack/bnep/bnep_utils.cc\n@@ -411,10 +411,11 @@ void bnepu_check_send_packet(tBNEP_CONN* p_bcb, BT_HDR* p_buf) {\n       fixed_queue_enqueue(p_bcb->xmit_q, p_buf);\n     }\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_bcb->l2cap_cid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda,\n-                p_bcb->l2cap_cid, p_buf->len);\n+                p_bcb->l2cap_cid, len);\n     }\n   }\n }\ndiff --git a/system/stack/hid/hidd_conn.cc b/system/stack/hid/hidd_conn.cc\nindex c64a7b9104..695e5d6c84 100644\n--- a/system/stack/hid/hidd_conn.cc\n+++ b/system/stack/hid/hidd_conn.cc\n@@ -88,10 +88,10 @@ static void hidd_check_config_done() {\n \n     // send outstanding data on intr\n     if (hd_cb.pending_data) {\n+      uint16_t len = hd_cb.pending_data->len;\n       if (stack::l2cap::get_interface().L2CA_DataWrite(p_hcon->intr_cid, hd_cb.pending_data) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n-        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid,\n-                  hd_cb.pending_data->len);\n+        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid, len);\n       }\n       hd_cb.pending_data = NULL;\n     }\ndiff --git a/system/stack/rfcomm/rfc_ts_frames.cc b/system/stack/rfcomm/rfc_ts_frames.cc\nindex ea57abf6dc..e93cfed9b8 100644\n--- a/system/stack/rfcomm/rfc_ts_frames.cc\n+++ b/system/stack/rfcomm/rfc_ts_frames.cc\n@@ -201,10 +201,11 @@ void rfc_send_buf_uih(tRFC_MCB* p_mcb, uint8_t dlci, BT_HDR* p_buf) {\n   if (dlci == RFCOMM_MX_DLCI) {\n     rfc_check_send_cmd(p_mcb, p_buf);\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p_buf->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/rfcomm/rfc_utils.cc b/system/stack/rfcomm/rfc_utils.cc\nindex 23420892cb..0c5074db76 100644\n--- a/system/stack/rfcomm/rfc_utils.cc\n+++ b/system/stack/rfcomm/rfc_utils.cc\n@@ -428,9 +428,10 @@ void rfc_check_send_cmd(tRFC_MCB* p_mcb, BT_HDR* p_buf) {\n     if (p == NULL) {\n       break;\n     }\n+    uint16_t len = p->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p) != tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/sdp/sdp_discovery.cc b/system/stack/sdp/sdp_discovery.cc\nindex 4fa484e14a..6aba1993af 100644\n--- a/system/stack/sdp/sdp_discovery.cc\n+++ b/system/stack/sdp/sdp_discovery.cc\n@@ -877,7 +877,7 @@ static void process_service_attr_rsp(tCONN_CB* p_ccb, uint8_t* p_reply, uint8_t*\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_msg) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-                p_ccb->connection_id, p_msg->len);\n+                p_ccb->connection_id, p - p_start);\n     }\n \n     /* Start inactivity timer */\ndiff --git a/system/stack/sdp/sdp_server.cc b/system/stack/sdp/sdp_server.cc\nindex abd70aedb1..0f379708e9 100644\n--- a/system/stack/sdp/sdp_server.cc\n+++ b/system/stack/sdp/sdp_server.cc\n@@ -300,7 +300,7 @@ static void process_service_search(tCONN_CB* p_ccb, uint16_t trans_num, uint16_t\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n@@ -564,7 +564,7 @@ static void process_service_attr_req(tCONN_CB* p_ccb, uint16_t trans_num, uint16\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "43cfd234de9ba9557118b0014513269cc1aeefda"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-371975420",
            "aliases": [
                "A-371975420",
                "CVE-2024-49732"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-371975420",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "7e5e47611d6f3271df264bb8ca9545ca3ba80361"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 7e5e47611d6f3271df264bb8ca9545ca3ba80361 Mon Sep 17 00:00:00 2001\nFrom: Guojing Yuan <guojing@google.com>\nDate: Tue, 22 Oct 2024 17:06:48 +0000\nSubject: [PATCH] [CDM] Check if it's system UID for hidden Perm Sync APIs\n\nBug: 371975420\nTest: Manual test\nFlag: EXEMPT bugfix\nChange-Id: I9771ce38728d40b026d94cb6785d55f144c66790\n---\n .../server/companion/CompanionDeviceManagerService.java  | 9 +++++++++\n 1 file changed, 9 insertions(+)\n\ndiff --git a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nindex 42f69e9ae02f..c73e457c565d 100644\n--- a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -628,16 +628,25 @@ public class CompanionDeviceManagerService extends SystemService {\n \n         @Override\n         public void enablePermissionsSync(int associationId) {\n+            if (getCallingUid() != SYSTEM_UID) {\n+                throw new SecurityException(\"Caller must be system UID\");\n+            }\n             mSystemDataTransferProcessor.enablePermissionsSync(associationId);\n         }\n \n         @Override\n         public void disablePermissionsSync(int associationId) {\n+            if (getCallingUid() != SYSTEM_UID) {\n+                throw new SecurityException(\"Caller must be system UID\");\n+            }\n             mSystemDataTransferProcessor.disablePermissionsSync(associationId);\n         }\n \n         @Override\n         public PermissionSyncRequest getPermissionSyncRequest(int associationId) {\n+            if (getCallingUid() != SYSTEM_UID) {\n+                throw new SecurityException(\"Caller must be system UID\");\n+            }\n             return mSystemDataTransferProcessor.getPermissionSyncRequest(associationId);\n         }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "08f57da9e39869f696de4225197530aa2b9187e8"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-338024220",
            "aliases": [
                "A-338024220",
                "CVE-2025-22421"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-338024220",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "e55a350cb80404544d2b227b4de0058505788c3c",
                        "0674f38d3a5d0d469b68e04cfc1e320a3227c8a7"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From e55a350cb80404544d2b227b4de0058505788c3c Mon Sep 17 00:00:00 2001\nFrom: Julia Reynolds <juliacr@google.com>\nDate: Mon, 4 Nov 2024 16:33:51 -0500\nSubject: [PATCH] Remove notification content from icon a11y\n\nThe content can be read when the full cards are visible\n\nTest: StatusBarIconViewTest\nTest: enable talkback, highlight icons\nFlag: EXEMPT bug fix\nBug: 338024220\nChange-Id: I3d3b7329c187808a28663aab16838a93a288b051\n---\n .../statusbar/StatusBarIconViewTest.java      | 15 ++++++++++++\n .../NotificationContentDescriptionTest.kt     | 24 +------------------\n .../NotificationContentDescription.kt         | 11 +--------\n 3 files changed, 17 insertions(+), 33 deletions(-)\n\ndiff --git a/packages/SystemUI/multivalentTests/src/com/android/systemui/statusbar/StatusBarIconViewTest.java b/packages/SystemUI/multivalentTests/src/com/android/systemui/statusbar/StatusBarIconViewTest.java\nindex 60a185537b0d..fb7252b24295 100644\n--- a/packages/SystemUI/multivalentTests/src/com/android/systemui/statusbar/StatusBarIconViewTest.java\n+++ b/packages/SystemUI/multivalentTests/src/com/android/systemui/statusbar/StatusBarIconViewTest.java\n@@ -16,6 +16,8 @@\n \n package com.android.systemui.statusbar;\n \n+import static android.app.Notification.CATEGORY_CALL;\n+\n import static com.google.common.truth.Truth.assertThat;\n \n import static junit.framework.Assert.assertEquals;\n@@ -196,6 +198,19 @@ public class StatusBarIconViewTest extends SysuiTestCase {\n         // no crash, good\n     }\n \n+    @Test\n+    public void testContentDescForNotification_noNotifContent() {\n+        Notification n = new Notification.Builder(mContext, \"test\")\n+                .setSmallIcon(0)\n+                .setContentTitle(\"hello\")\n+                .setCategory(CATEGORY_CALL)\n+                .build();\n+        assertThat(NotificationContentDescription.contentDescForNotification(mContext, n)\n+                .toString()).startsWith(\"com.android.systemui.tests notification\");\n+        assertThat(NotificationContentDescription.contentDescForNotification(mContext, n)\n+                .toString()).doesNotContain(\"hello\");\n+    }\n+\n     @Test\n     @EnableFlags({Flags.FLAG_MODES_UI, Flags.FLAG_MODES_UI_ICONS})\n     public void setIcon_withPreloaded_usesPreloaded() {\ndiff --git a/packages/SystemUI/multivalentTests/src/com/android/systemui/statusbar/notification/NotificationContentDescriptionTest.kt b/packages/SystemUI/multivalentTests/src/com/android/systemui/statusbar/notification/NotificationContentDescriptionTest.kt\nindex 12473cb46793..896f940f8a60 100644\n--- a/packages/SystemUI/multivalentTests/src/com/android/systemui/statusbar/notification/NotificationContentDescriptionTest.kt\n+++ b/packages/SystemUI/multivalentTests/src/com/android/systemui/statusbar/notification/NotificationContentDescriptionTest.kt\n@@ -34,31 +34,9 @@ class NotificationContentDescriptionTest : SysuiTestCase() {\n     private val TICKER = \"this is a ticker\"\n \n     @Test\n-    fun notificationWithAllDifferentFields_descriptionIsTitle() {\n+    fun notificationWithAllDifferentFields_descriptionIsAppName() {\n         val n = createNotification(TITLE, TEXT, TICKER)\n         val description = contentDescForNotification(context, n)\n-        assertThat(description).isEqualTo(createDescriptionText(n, TITLE))\n-    }\n-\n-    @Test\n-    fun notificationWithAllDifferentFields_titleMatchesAppName_descriptionIsText() {\n-        val n = createNotification(getTestAppName(), TEXT, TICKER)\n-        val description = contentDescForNotification(context, n)\n-        assertThat(description).isEqualTo(createDescriptionText(n, TEXT))\n-    }\n-\n-    @Test\n-    fun notificationWithAllDifferentFields_titleMatchesAppNameNoText_descriptionIsTicker() {\n-        val n = createNotification(getTestAppName(), null, TICKER)\n-        val description = contentDescForNotification(context, n)\n-        assertThat(description).isEqualTo(createDescriptionText(n, TICKER))\n-    }\n-\n-    @Test\n-    fun notificationWithAllDifferentFields_titleMatchesAppNameNoTextNoTicker_descriptionEmpty() {\n-        val appName = getTestAppName()\n-        val n = createNotification(appName, null, null)\n-        val description = contentDescForNotification(context, n)\n         assertThat(description).isEqualTo(createDescriptionText(n, \"\"))\n     }\n \ndiff --git a/packages/SystemUI/src/com/android/systemui/statusbar/notification/NotificationContentDescription.kt b/packages/SystemUI/src/com/android/systemui/statusbar/notification/NotificationContentDescription.kt\nindex bdd9fd032800..6b6920a3621a 100644\n--- a/packages/SystemUI/src/com/android/systemui/statusbar/notification/NotificationContentDescription.kt\n+++ b/packages/SystemUI/src/com/android/systemui/statusbar/notification/NotificationContentDescription.kt\n@@ -28,14 +28,5 @@ import com.android.systemui.res.R\n @MainThread\n fun contentDescForNotification(c: Context, n: Notification): CharSequence {\n     val appName = n.loadHeaderAppName(c) ?: \"\"\n-    val title = n.extras?.getCharSequence(Notification.EXTRA_TITLE)\n-    val text = n.extras?.getCharSequence(Notification.EXTRA_TEXT)\n-    val ticker = n.tickerText\n-\n-    // Some apps just put the app name into the title\n-    val titleOrText = if (TextUtils.equals(title, appName)) text else title\n-    val desc =\n-        if (!TextUtils.isEmpty(titleOrText)) titleOrText\n-        else if (!TextUtils.isEmpty(ticker)) ticker else \"\"\n-    return c.getString(R.string.accessibility_desc_notification_icon, appName, desc)\n+    return c.getString(R.string.accessibility_desc_notification_icon, appName, \"\")\n }\n-- \n2.39.5 (Apple Git-154)\n\nFrom 0674f38d3a5d0d469b68e04cfc1e320a3227c8a7 Mon Sep 17 00:00:00 2001\nFrom: Julia Reynolds <juliacr@google.com>\nDate: Mon, 18 Nov 2024 09:19:51 -0500\nSubject: [PATCH] Remove unneeded test\n\ndupe of test in NotificationContentDescriptionTest\n\nTest: make\nFixes: 378029337\nBug: 338024220\nFlag: EXEMPT test only\n\nChange-Id: I3fead1794cd016c1142e46c4f288dfc687ab52db\n---\n .../systemui/statusbar/StatusBarIconViewTest.java | 15 ---------------\n 1 file changed, 15 deletions(-)\n\ndiff --git a/packages/SystemUI/multivalentTests/src/com/android/systemui/statusbar/StatusBarIconViewTest.java b/packages/SystemUI/multivalentTests/src/com/android/systemui/statusbar/StatusBarIconViewTest.java\nindex fb7252b24295..60a185537b0d 100644\n--- a/packages/SystemUI/multivalentTests/src/com/android/systemui/statusbar/StatusBarIconViewTest.java\n+++ b/packages/SystemUI/multivalentTests/src/com/android/systemui/statusbar/StatusBarIconViewTest.java\n@@ -16,8 +16,6 @@\n \n package com.android.systemui.statusbar;\n \n-import static android.app.Notification.CATEGORY_CALL;\n-\n import static com.google.common.truth.Truth.assertThat;\n \n import static junit.framework.Assert.assertEquals;\n@@ -198,19 +196,6 @@ public class StatusBarIconViewTest extends SysuiTestCase {\n         // no crash, good\n     }\n \n-    @Test\n-    public void testContentDescForNotification_noNotifContent() {\n-        Notification n = new Notification.Builder(mContext, \"test\")\n-                .setSmallIcon(0)\n-                .setContentTitle(\"hello\")\n-                .setCategory(CATEGORY_CALL)\n-                .build();\n-        assertThat(NotificationContentDescription.contentDescForNotification(mContext, n)\n-                .toString()).startsWith(\"com.android.systemui.tests notification\");\n-        assertThat(NotificationContentDescription.contentDescForNotification(mContext, n)\n-                .toString()).doesNotContain(\"hello\");\n-    }\n-\n     @Test\n     @EnableFlags({Flags.FLAG_MODES_UI, Flags.FLAG_MODES_UI_ICONS})\n     public void setIcon_withPreloaded_usesPreloaded() {\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "9d00ab315dd7d661e71b5fcc51152ced2b2ae28a"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "1aa8f6d4de1c1e731fe1757c3f9d0115ba7c7d68",
                            "result": "failure",
                            "downstream_patch_content": "commit 1aa8f6d4de1c1e731fe1757c3f9d0115ba7c7d68\nAuthor: Julia Reynolds <juliacr@google.com>\nDate:   Fri Jan 10 07:43:44 2025 -0800\n\n    Remove notification content from icon a11y\n    \n    The content can be read when the full cards are visible\n    \n    Change-Id: Ic607ab91e77bc660e3fccbc2390dd60151798ad7\n    Test: StatusBarIconViewTest\n    Test: enable talkback, highlight icons\n    Flag: EXEMPT bug fix\n    Bug: 338024220\n    Merged-In: I3d3b7329c187808a28663aab16838a93a288b051\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/statusbar/StatusBarIconView.java b/packages/SystemUI/src/com/android/systemui/statusbar/StatusBarIconView.java\nindex 5302188ccb31..ac8f582dd807 100644\n--- a/packages/SystemUI/src/com/android/systemui/statusbar/StatusBarIconView.java\n+++ b/packages/SystemUI/src/com/android/systemui/statusbar/StatusBarIconView.java\n@@ -588,17 +588,7 @@ public class StatusBarIconView extends AnimatedImageView implements StatusIconDi\n             }\n         }\n \n-        CharSequence title = n.extras.getCharSequence(Notification.EXTRA_TITLE);\n-        CharSequence text = n.extras.getCharSequence(Notification.EXTRA_TEXT);\n-        CharSequence ticker = n.tickerText;\n-\n-        // Some apps just put the app name into the title\n-        CharSequence titleOrText = TextUtils.equals(title, appName) ? text : title;\n-\n-        CharSequence desc = !TextUtils.isEmpty(titleOrText) ? titleOrText\n-                : !TextUtils.isEmpty(ticker) ? ticker : \"\";\n-\n-        return c.getString(R.string.accessibility_desc_notification_icon, appName, desc);\n+        return c.getString(R.string.accessibility_desc_notification_icon, appName, \"\");\n     }\n \n     /**\n",
                            "file_conflicts": []
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "1aa8f6d4de1c1e731fe1757c3f9d0115ba7c7d68",
                            "result": "failure",
                            "downstream_patch_content": "commit 1aa8f6d4de1c1e731fe1757c3f9d0115ba7c7d68\nAuthor: Julia Reynolds <juliacr@google.com>\nDate:   Fri Jan 10 07:43:44 2025 -0800\n\n    Remove notification content from icon a11y\n    \n    The content can be read when the full cards are visible\n    \n    Change-Id: Ic607ab91e77bc660e3fccbc2390dd60151798ad7\n    Test: StatusBarIconViewTest\n    Test: enable talkback, highlight icons\n    Flag: EXEMPT bug fix\n    Bug: 338024220\n    Merged-In: I3d3b7329c187808a28663aab16838a93a288b051\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/statusbar/StatusBarIconView.java b/packages/SystemUI/src/com/android/systemui/statusbar/StatusBarIconView.java\nindex 5302188ccb31..ac8f582dd807 100644\n--- a/packages/SystemUI/src/com/android/systemui/statusbar/StatusBarIconView.java\n+++ b/packages/SystemUI/src/com/android/systemui/statusbar/StatusBarIconView.java\n@@ -588,17 +588,7 @@ public class StatusBarIconView extends AnimatedImageView implements StatusIconDi\n             }\n         }\n \n-        CharSequence title = n.extras.getCharSequence(Notification.EXTRA_TITLE);\n-        CharSequence text = n.extras.getCharSequence(Notification.EXTRA_TEXT);\n-        CharSequence ticker = n.tickerText;\n-\n-        // Some apps just put the app name into the title\n-        CharSequence titleOrText = TextUtils.equals(title, appName) ? text : title;\n-\n-        CharSequence desc = !TextUtils.isEmpty(titleOrText) ? titleOrText\n-                : !TextUtils.isEmpty(ticker) ? ticker : \"\";\n-\n-        return c.getString(R.string.accessibility_desc_notification_icon, appName, desc);\n+        return c.getString(R.string.accessibility_desc_notification_icon, appName, \"\");\n     }\n \n     /**\n",
                            "file_conflicts": []
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-352294617",
            "aliases": [
                "A-352294617",
                "CVE-2025-22439"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-352294617",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "30596588b508f1e5e97631470af479214898064a"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 30596588b508f1e5e97631470af479214898064a Mon Sep 17 00:00:00 2001\nFrom: Aditya <adityasngh@google.com>\nDate: Thu, 2 Jan 2025 09:53:16 +0000\nSubject: [PATCH] Fix for SAF loophole in the lastAccessedStack.\n\nWhen loading the last accessed stack, the code did not check if the file\npath (uri) should be blocked, thereby allowing an attacker to bypass the\nscoped storage restriction put on initial uri.\nThis change adds the check when loading last accessed stack.\n\nBug: 352294617\nTest: Manual as per http://b/352294617#comment4\nFlag: EXEMPT bugfix\nChange-Id: I4de8bad7174273c9390da978e186ad6a85f27be5\n---\n src/com/android/documentsui/picker/ActionHandler.java | 3 +++\n 1 file changed, 3 insertions(+)\n\ndiff --git a/src/com/android/documentsui/picker/ActionHandler.java b/src/com/android/documentsui/picker/ActionHandler.java\nindex 4ea7bbc2d..553fa6986 100644\n--- a/src/com/android/documentsui/picker/ActionHandler.java\n+++ b/src/com/android/documentsui/picker/ActionHandler.java\n@@ -272,6 +272,9 @@ class ActionHandler<T extends FragmentActivity & Addons> extends AbstractActionH\n     private void onLastAccessedStackLoaded(@Nullable DocumentStack stack) {\n         if (stack == null) {\n             loadDefaultLocation();\n+        } else if (shouldPreemptivelyRestrictRequestedInitialUri(stack.peek().getDocumentUri())) {\n+            // If the last accessed stack has restricted uri, load default location\n+            loadDefaultLocation();\n         } else {\n             mState.stack.reset(stack);\n             mActivity.refreshCurrentRootAndDirectory(AnimationView.ANIM_NONE);\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 2,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "0f051c7b87a5150edb2b851eba15793ef9f0ae54"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "d560a29f2713717cf33960a1c0e115fdea448d70",
                            "result": "success",
                            "downstream_patch_content": "commit d560a29f2713717cf33960a1c0e115fdea448d70\nAuthor: Sergey Nikolaienkov <sergeynv@google.com>\nDate:   Tue Jun 27 21:11:16 2023 +0200\n\n    Restrict initial location for ACTION_OPEN_DOCUMENT/_TREE\n    \n    Implement privacy restriction introduced in Android 11 that application\n    are not allowed to request initial location for intent actions\n    ACTION_OPEN_DOCUMENT and ACTION_OPEN_DOCUMENT_TREE to be /Android/data/,\n    /Android/obb/, /Android/sandbox/ and all their subdirectories.\n    If an application does request the initial location to be one of these\n    directories (or their subdirs) redirect to the default location - last\n    accessed stack.\n    \n    Bug: 200034476\n    Bug: 220066255\n    Test: atest\n      DocumentsUIGoogleTests:com.android.documentsui.picker.ActionHandlerTest\n    Test: adb shell am start\n      -a android.intent.action.OPEN_DOCUMENT_TREE\n      --eu android.provider.extra.INITIAL_URI\n      \"content://com.android.externalstorage.documents/document/primary%3AAndroid%2Fdata\"\n    Change-Id: I7e31a8fb76b5ddb0e3af67852b1e1ccc9a825648\n    Merged-In: I7e31a8fb76b5ddb0e3af67852b1e1ccc9a825648\n\ndiff --git a/src/com/android/documentsui/AbstractActionHandler.java b/src/com/android/documentsui/AbstractActionHandler.java\nindex a310acee2..4407a62b2 100644\n--- a/src/com/android/documentsui/AbstractActionHandler.java\n+++ b/src/com/android/documentsui/AbstractActionHandler.java\n@@ -779,32 +779,48 @@ public abstract class AbstractActionHandler<T extends FragmentActivity & CommonA\n     }\n \n     protected final boolean launchToDocument(Uri uri) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"launchToDocument() uri=\" + uri);\n+        }\n+\n         // We don't support launching to a document in an archive.\n-        if (!Providers.isArchiveUri(uri)) {\n-            loadDocument(uri, UserId.DEFAULT_USER, this::onStackLoaded);\n-            return true;\n+        if (Providers.isArchiveUri(uri)) {\n+            return false;\n         }\n \n-        return false;\n+        loadDocument(uri, UserId.DEFAULT_USER, this::onStackToLaunchToLoaded);\n+        return true;\n     }\n \n-    private void onStackLoaded(@Nullable DocumentStack stack) {\n-        if (stack != null) {\n-            if (!stack.peek().isDirectory()) {\n-                // Requested document is not a directory. Pop it so that we can launch into its\n-                // parent.\n-                stack.pop();\n-            }\n-            mState.stack.reset(stack);\n-            mActivity.refreshCurrentRootAndDirectory(AnimationView.ANIM_NONE);\n+    /**\n+     * Invoked <b>only</b> once, when the initial stack (that is the stack we are going to\n+     * \"launch to\") is loaded.\n+     *\n+     * @see #launchToDocument(Uri)\n+     */\n+    private void onStackToLaunchToLoaded(@Nullable DocumentStack stack) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"onLaunchStackLoaded() stack=\" + stack);\n+        }\n \n-            Metrics.logLaunchAtLocation(mState, stack.getRoot().getUri());\n-        } else {\n+        if (stack == null) {\n             Log.w(TAG, \"Failed to launch into the given uri. Launch to default location.\");\n             launchToDefaultLocation();\n \n             Metrics.logLaunchAtLocation(mState, null);\n+            return;\n         }\n+\n+        // Make sure the document at the top of the stack is a directory (if it isn't - just pop\n+        // one off).\n+        if (!stack.peek().isDirectory()) {\n+            stack.pop();\n+        }\n+\n+        mState.stack.reset(stack);\n+        mActivity.refreshCurrentRootAndDirectory(AnimationView.ANIM_NONE);\n+\n+        Metrics.logLaunchAtLocation(mState, stack.getRoot().getUri());\n     }\n \n     private void onRootLoaded(@Nullable RootInfo root) {\ndiff --git a/src/com/android/documentsui/picker/ActionHandler.java b/src/com/android/documentsui/picker/ActionHandler.java\nindex 53a285110..1fc35b360 100644\n--- a/src/com/android/documentsui/picker/ActionHandler.java\n+++ b/src/com/android/documentsui/picker/ActionHandler.java\n@@ -16,6 +16,9 @@\n \n package com.android.documentsui.picker;\n \n+import static android.provider.DocumentsContract.isDocumentUri;\n+import static android.provider.DocumentsContract.isRootUri;\n+\n import static com.android.documentsui.base.SharedMinimal.DEBUG;\n import static com.android.documentsui.base.State.ACTION_CREATE;\n import static com.android.documentsui.base.State.ACTION_GET_CONTENT;\n@@ -23,6 +26,8 @@ import static com.android.documentsui.base.State.ACTION_OPEN;\n import static com.android.documentsui.base.State.ACTION_OPEN_TREE;\n import static com.android.documentsui.base.State.ACTION_PICK_COPY_DESTINATION;\n \n+import static java.util.regex.Pattern.CASE_INSENSITIVE;\n+\n import android.content.ActivityNotFoundException;\n import android.content.ClipData;\n import android.content.ComponentName;\n@@ -35,6 +40,8 @@ import android.provider.DocumentsContract;\n import android.provider.Settings;\n import android.util.Log;\n \n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n import androidx.annotation.VisibleForTesting;\n import androidx.fragment.app.FragmentActivity;\n import androidx.fragment.app.FragmentManager;\n@@ -52,6 +59,7 @@ import com.android.documentsui.base.DocumentInfo;\n import com.android.documentsui.base.DocumentStack;\n import com.android.documentsui.base.Features;\n import com.android.documentsui.base.Lookup;\n+import com.android.documentsui.base.Providers;\n import com.android.documentsui.base.RootInfo;\n import com.android.documentsui.base.Shared;\n import com.android.documentsui.base.State;\n@@ -61,11 +69,12 @@ import com.android.documentsui.picker.ActionHandler.Addons;\n import com.android.documentsui.queries.SearchViewManager;\n import com.android.documentsui.roots.ProvidersAccess;\n import com.android.documentsui.services.FileOperationService;\n+import com.android.documentsui.util.FileUtils;\n \n+import java.io.IOException;\n import java.util.Arrays;\n import java.util.concurrent.Executor;\n-\n-import javax.annotation.Nullable;\n+import java.util.regex.Pattern;\n \n /**\n  * Provides {@link PickActivity} action specializations to fragments.\n@@ -74,6 +83,20 @@ class ActionHandler<T extends FragmentActivity & Addons> extends AbstractActionH\n \n     private static final String TAG = \"PickerActionHandler\";\n \n+    /**\n+     * Used to prevent applications from using {@link Intent.ACTION_OPEN_DOCUMENT_TREE} and\n+     * the {@link Intent.ACTION_OPEN_DOCUMENT} actions to request that the user select individual\n+     * files from \"/Android/data\", \"/Android/obb\", \"/Android/sandbox\" directories and all their\n+     * subdirectories (on the external storage), in accordance with the SAF privacy restrictions\n+     * introduced in Android 11 (R).\n+     *\n+     * <p>\n+     * See <a href=\"https://developer.android.com/about/versions/11/privacy/storage#file-access\">\n+     * Storage updates in Android 11</a>.\n+     */\n+    private static final Pattern PATTERN_RESTRICTED_INITIAL_PATH =\n+            Pattern.compile(\"^/Android/(?:data|obb|sandbox).*\", CASE_INSENSITIVE);\n+\n     private final Features mFeatures;\n     private final ActivityConfig mConfig;\n     private final LastAccessedStorage mLastAccessed;\n@@ -155,17 +178,84 @@ class ActionHandler<T extends FragmentActivity & Addons> extends AbstractActionH\n     }\n \n     private boolean launchToInitialUri(Intent intent) {\n-        Uri uri = intent.getParcelableExtra(DocumentsContract.EXTRA_INITIAL_URI);\n-        if (uri != null) {\n-            if (DocumentsContract.isRootUri(mActivity, uri)) {\n-                loadRoot(uri, UserId.DEFAULT_USER);\n-                return true;\n-            } else if (DocumentsContract.isDocumentUri(mActivity, uri)) {\n-                return launchToDocument(uri);\n-            }\n+        final Uri initialUri = intent.getParcelableExtra(DocumentsContract.EXTRA_INITIAL_URI);\n+        if (initialUri == null) {\n+            return false;\n         }\n \n-        return false;\n+        final boolean isRoot = isRootUri(mActivity, initialUri);\n+        final boolean isDocument = !isRoot && isDocumentUri(mActivity, initialUri);\n+\n+        if (!isRoot && !isDocument) {\n+            // Neither a root nor a document.\n+            return false;\n+        }\n+\n+        if (isRoot) {\n+            loadRoot(initialUri, UserId.DEFAULT_USER);\n+            return true;\n+        }\n+        // From here onwards: isDoc == true.\n+\n+        if (shouldPreemptivelyRestrictRequestedInitialUri(initialUri)) {\n+            Log.w(TAG, \"Requested initial URI - \" + initialUri + \" - is restricted: \"\n+                    + \"loading device root instead.\");\n+            return false;\n+        }\n+\n+        return launchToDocument(initialUri);\n+    }\n+\n+    /**\n+     * Starting with Android 11 (R, API Level 30) applications are no longer allowed to use the\n+     * {@link Intent#ACTION_OPEN_DOCUMENT} and {@link Intent#ACTION_OPEN_DOCUMENT_TREE} to request\n+     * that the user select individual files from \"Android/data/\", \"Android/obb/\",\n+     * \"Android/sandbox/\" directories and all their subdirectories on \"external storage\".\n+     * <p>\n+     * See <a href=\"https://developer.android.com/about/versions/11/privacy/storage#file-access\">\n+     * Storage updates in Android 11</a>.\n+     * <p>\n+     * Ideally, this should be handled on the {@code ExternalStorageProvider} side, but as of\n+     * Android 14 (U) FRC, {@code ExternalStorageProvider} \"hides\" only \"Android/data/\",\n+     * \"Android/obb/\" and \"Android/sandbox/\" directories, but NOT their subdirectories.\n+     */\n+    private boolean shouldPreemptivelyRestrictRequestedInitialUri(@NonNull Uri uri) {\n+        // Not restricting SAF access for the calling app.\n+        if (!Shared.shouldRestrictStorageAccessFramework(mActivity)) {\n+            return false;\n+        }\n+\n+        // We only need to restrict some locations on the \"external\" storage.\n+        if (!Providers.AUTHORITY_STORAGE.equals(uri.getAuthority())) {\n+            return false;\n+        }\n+\n+        // TODO(b/283962634): in the future this will have to be platform-version specific.\n+        //  For example, if the fix on the ExternalStorageProvider side makes it to the Android 15,\n+        //  we would change this to check if the platform version >= 15.\n+        //  In the upcoming Android 14 release, however, ExternalStorageProvider does NOT yet\n+        //  implement this logic.\n+        final boolean externalProviderImplementsSafRestrictions = false;\n+        if (externalProviderImplementsSafRestrictions) {\n+            return false;\n+        }\n+\n+        // External Storage Provider's docId format is \"root:path/to/file\"\n+        // The getPathFromStorageDocId() turns that into \"/path/to/file\"\n+        // Note the missing leading \"/\" in the path part of the docId, while the path returned by\n+        // the getPathFromStorageDocId() start with \"/\".\n+        final String docId = DocumentsContract.getDocumentId(uri);\n+        final String filePath;\n+        try {\n+             filePath = FileUtils.getPathFromStorageDocId(docId);\n+        } catch (IOException e) {\n+            Log.w(TAG, \"Could not get canonical file path from docId '\" + docId + \"'\");\n+            return true;\n+        }\n+\n+        // Check if the app is asking for /Android/data, /Android/obb, /Android/sandbox or any of\n+        // their subdirectories (on the external storage).\n+        return PATTERN_RESTRICTED_INITIAL_PATH.matcher(filePath).matches();\n     }\n \n     private void initLoadLastAccessedStack() {\ndiff --git a/src/com/android/documentsui/util/FileUtils.java b/src/com/android/documentsui/util/FileUtils.java\nnew file mode 100644\nindex 000000000..40f7fbae9\n--- /dev/null\n+++ b/src/com/android/documentsui/util/FileUtils.java\n@@ -0,0 +1,58 @@\n+/*\n+ * Copyright (C) 2023 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.android.documentsui.util;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+public class FileUtils {\n+\n+    /**\n+     * Returns the canonical pathname string of the provided abstract pathname.\n+     *\n+     * @return The canonical pathname string denoting the same file or directory as this abstract\n+     *         pathname.\n+     * @see File#getCanonicalPath()\n+     */\n+    @NonNull\n+    public static String getCanonicalPath(@NonNull String path) throws IOException {\n+        Objects.requireNonNull(path);\n+        return new File(path).getCanonicalPath();\n+    }\n+\n+    /**\n+     * This is basically a very slightly tweaked fork of\n+     * {@link com.android.externalstorage.ExternalStorageProvider#getPathFromDocId(String)}.\n+     * The difference between this fork and the \"original\" method is that here we do not strip\n+     * the leading and trailing \"/\"s (because we don't worry about those).\n+     *\n+     * @return canonicalized file path.\n+     */\n+    public static String getPathFromStorageDocId(String docId) throws IOException {\n+        // Remove the root tag from the docId, e.g. \"primary:\", which should leave with the file\n+        // path.\n+        final String docIdPath = docId.substring(docId.indexOf(':', 1) + 1);\n+\n+        return getCanonicalPath(docIdPath);\n+    }\n+\n+    private FileUtils() {\n+    }\n+}\n"
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "ae840b1f17869f5592cb1957d2e0e2d0af1be96b",
                            "result": "success",
                            "downstream_patch_content": "commit ae840b1f17869f5592cb1957d2e0e2d0af1be96b\nAuthor: Sergey Nikolaienkov <sergeynv@google.com>\nDate:   Tue Jun 27 21:11:16 2023 +0200\n\n    Restrict initial location for ACTION_OPEN_DOCUMENT/_TREE\n    \n    Implement privacy restriction introduced in Android 11 that application\n    are not allowed to request initial location for intent actions\n    ACTION_OPEN_DOCUMENT and ACTION_OPEN_DOCUMENT_TREE to be /Android/data/,\n    /Android/obb/, /Android/sandbox/ and all their subdirectories.\n    If an application does request the initial location to be one of these\n    directories (or their subdirs) redirect to the default location - last\n    accessed stack.\n    \n    Bug: 200034476\n    Bug: 220066255\n    Test: atest\n      DocumentsUIGoogleTests:com.android.documentsui.picker.ActionHandlerTest\n    Test: adb shell am start\n      -a android.intent.action.OPEN_DOCUMENT_TREE\n      --eu android.provider.extra.INITIAL_URI\n      \"content://com.android.externalstorage.documents/document/primary%3AAndroid%2Fdata\"\n    Change-Id: I7e31a8fb76b5ddb0e3af67852b1e1ccc9a825648\n    Merged-In: I7e31a8fb76b5ddb0e3af67852b1e1ccc9a825648\n\ndiff --git a/src/com/android/documentsui/AbstractActionHandler.java b/src/com/android/documentsui/AbstractActionHandler.java\nindex a310acee2..4407a62b2 100644\n--- a/src/com/android/documentsui/AbstractActionHandler.java\n+++ b/src/com/android/documentsui/AbstractActionHandler.java\n@@ -779,32 +779,48 @@ public abstract class AbstractActionHandler<T extends FragmentActivity & CommonA\n     }\n \n     protected final boolean launchToDocument(Uri uri) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"launchToDocument() uri=\" + uri);\n+        }\n+\n         // We don't support launching to a document in an archive.\n-        if (!Providers.isArchiveUri(uri)) {\n-            loadDocument(uri, UserId.DEFAULT_USER, this::onStackLoaded);\n-            return true;\n+        if (Providers.isArchiveUri(uri)) {\n+            return false;\n         }\n \n-        return false;\n+        loadDocument(uri, UserId.DEFAULT_USER, this::onStackToLaunchToLoaded);\n+        return true;\n     }\n \n-    private void onStackLoaded(@Nullable DocumentStack stack) {\n-        if (stack != null) {\n-            if (!stack.peek().isDirectory()) {\n-                // Requested document is not a directory. Pop it so that we can launch into its\n-                // parent.\n-                stack.pop();\n-            }\n-            mState.stack.reset(stack);\n-            mActivity.refreshCurrentRootAndDirectory(AnimationView.ANIM_NONE);\n+    /**\n+     * Invoked <b>only</b> once, when the initial stack (that is the stack we are going to\n+     * \"launch to\") is loaded.\n+     *\n+     * @see #launchToDocument(Uri)\n+     */\n+    private void onStackToLaunchToLoaded(@Nullable DocumentStack stack) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"onLaunchStackLoaded() stack=\" + stack);\n+        }\n \n-            Metrics.logLaunchAtLocation(mState, stack.getRoot().getUri());\n-        } else {\n+        if (stack == null) {\n             Log.w(TAG, \"Failed to launch into the given uri. Launch to default location.\");\n             launchToDefaultLocation();\n \n             Metrics.logLaunchAtLocation(mState, null);\n+            return;\n         }\n+\n+        // Make sure the document at the top of the stack is a directory (if it isn't - just pop\n+        // one off).\n+        if (!stack.peek().isDirectory()) {\n+            stack.pop();\n+        }\n+\n+        mState.stack.reset(stack);\n+        mActivity.refreshCurrentRootAndDirectory(AnimationView.ANIM_NONE);\n+\n+        Metrics.logLaunchAtLocation(mState, stack.getRoot().getUri());\n     }\n \n     private void onRootLoaded(@Nullable RootInfo root) {\ndiff --git a/src/com/android/documentsui/picker/ActionHandler.java b/src/com/android/documentsui/picker/ActionHandler.java\nindex cc349a854..1fc35b360 100644\n--- a/src/com/android/documentsui/picker/ActionHandler.java\n+++ b/src/com/android/documentsui/picker/ActionHandler.java\n@@ -16,6 +16,9 @@\n \n package com.android.documentsui.picker;\n \n+import static android.provider.DocumentsContract.isDocumentUri;\n+import static android.provider.DocumentsContract.isRootUri;\n+\n import static com.android.documentsui.base.SharedMinimal.DEBUG;\n import static com.android.documentsui.base.State.ACTION_CREATE;\n import static com.android.documentsui.base.State.ACTION_GET_CONTENT;\n@@ -23,6 +26,8 @@ import static com.android.documentsui.base.State.ACTION_OPEN;\n import static com.android.documentsui.base.State.ACTION_OPEN_TREE;\n import static com.android.documentsui.base.State.ACTION_PICK_COPY_DESTINATION;\n \n+import static java.util.regex.Pattern.CASE_INSENSITIVE;\n+\n import android.content.ActivityNotFoundException;\n import android.content.ClipData;\n import android.content.ComponentName;\n@@ -35,6 +40,8 @@ import android.provider.DocumentsContract;\n import android.provider.Settings;\n import android.util.Log;\n \n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n import androidx.annotation.VisibleForTesting;\n import androidx.fragment.app.FragmentActivity;\n import androidx.fragment.app.FragmentManager;\n@@ -52,6 +59,7 @@ import com.android.documentsui.base.DocumentInfo;\n import com.android.documentsui.base.DocumentStack;\n import com.android.documentsui.base.Features;\n import com.android.documentsui.base.Lookup;\n+import com.android.documentsui.base.Providers;\n import com.android.documentsui.base.RootInfo;\n import com.android.documentsui.base.Shared;\n import com.android.documentsui.base.State;\n@@ -61,14 +69,12 @@ import com.android.documentsui.picker.ActionHandler.Addons;\n import com.android.documentsui.queries.SearchViewManager;\n import com.android.documentsui.roots.ProvidersAccess;\n import com.android.documentsui.services.FileOperationService;\n+import com.android.documentsui.util.FileUtils;\n \n-import com.android.documentsui.util.VersionUtils;\n+import java.io.IOException;\n import java.util.Arrays;\n-import java.util.Locale;\n import java.util.concurrent.Executor;\n-\n import java.util.regex.Pattern;\n-import javax.annotation.Nullable;\n \n /**\n  * Provides {@link PickActivity} action specializations to fragments.\n@@ -77,12 +83,24 @@ class ActionHandler<T extends FragmentActivity & Addons> extends AbstractActionH\n \n     private static final String TAG = \"PickerActionHandler\";\n \n+    /**\n+     * Used to prevent applications from using {@link Intent.ACTION_OPEN_DOCUMENT_TREE} and\n+     * the {@link Intent.ACTION_OPEN_DOCUMENT} actions to request that the user select individual\n+     * files from \"/Android/data\", \"/Android/obb\", \"/Android/sandbox\" directories and all their\n+     * subdirectories (on the external storage), in accordance with the SAF privacy restrictions\n+     * introduced in Android 11 (R).\n+     *\n+     * <p>\n+     * See <a href=\"https://developer.android.com/about/versions/11/privacy/storage#file-access\">\n+     * Storage updates in Android 11</a>.\n+     */\n+    private static final Pattern PATTERN_RESTRICTED_INITIAL_PATH =\n+            Pattern.compile(\"^/Android/(?:data|obb|sandbox).*\", CASE_INSENSITIVE);\n+\n     private final Features mFeatures;\n     private final ActivityConfig mConfig;\n     private final LastAccessedStorage mLastAccessed;\n     private final UserIdManager mUserIdManager;\n-    private final static Pattern PATTERN_BLOCK_PATH = Pattern.compile(\n-        \".*:android\\\\/(?:data|obb|sandbox)$\");\n \n     private UpdatePickResultTask mUpdatePickResultTask;\n \n@@ -160,25 +178,84 @@ class ActionHandler<T extends FragmentActivity & Addons> extends AbstractActionH\n     }\n \n     private boolean launchToInitialUri(Intent intent) {\n-        Uri uri = intent.getParcelableExtra(DocumentsContract.EXTRA_INITIAL_URI);\n-        if (uri != null) {\n-            // In android S and above if path contains Android/data, Android/obb\n-            // or Android/sandbox redirect to the root for which\n-            // FLAG_DIR_BLOCKS_OPEN_DOCUMENT_TREE is already set\n-            if(Shared.shouldRestrictStorageAccessFramework(mActivity)\n-                && (PATTERN_BLOCK_PATH.matcher(uri.getPath().toLowerCase(Locale.ROOT)).matches())){\n-                loadDeviceRoot();\n-                return true;\n-            }\n-            if (DocumentsContract.isRootUri(mActivity, uri)) {\n-                loadRoot(uri, UserId.DEFAULT_USER);\n-                return true;\n-            } else if (DocumentsContract.isDocumentUri(mActivity, uri)) {\n-                return launchToDocument(uri);\n-            }\n+        final Uri initialUri = intent.getParcelableExtra(DocumentsContract.EXTRA_INITIAL_URI);\n+        if (initialUri == null) {\n+            return false;\n         }\n \n-        return false;\n+        final boolean isRoot = isRootUri(mActivity, initialUri);\n+        final boolean isDocument = !isRoot && isDocumentUri(mActivity, initialUri);\n+\n+        if (!isRoot && !isDocument) {\n+            // Neither a root nor a document.\n+            return false;\n+        }\n+\n+        if (isRoot) {\n+            loadRoot(initialUri, UserId.DEFAULT_USER);\n+            return true;\n+        }\n+        // From here onwards: isDoc == true.\n+\n+        if (shouldPreemptivelyRestrictRequestedInitialUri(initialUri)) {\n+            Log.w(TAG, \"Requested initial URI - \" + initialUri + \" - is restricted: \"\n+                    + \"loading device root instead.\");\n+            return false;\n+        }\n+\n+        return launchToDocument(initialUri);\n+    }\n+\n+    /**\n+     * Starting with Android 11 (R, API Level 30) applications are no longer allowed to use the\n+     * {@link Intent#ACTION_OPEN_DOCUMENT} and {@link Intent#ACTION_OPEN_DOCUMENT_TREE} to request\n+     * that the user select individual files from \"Android/data/\", \"Android/obb/\",\n+     * \"Android/sandbox/\" directories and all their subdirectories on \"external storage\".\n+     * <p>\n+     * See <a href=\"https://developer.android.com/about/versions/11/privacy/storage#file-access\">\n+     * Storage updates in Android 11</a>.\n+     * <p>\n+     * Ideally, this should be handled on the {@code ExternalStorageProvider} side, but as of\n+     * Android 14 (U) FRC, {@code ExternalStorageProvider} \"hides\" only \"Android/data/\",\n+     * \"Android/obb/\" and \"Android/sandbox/\" directories, but NOT their subdirectories.\n+     */\n+    private boolean shouldPreemptivelyRestrictRequestedInitialUri(@NonNull Uri uri) {\n+        // Not restricting SAF access for the calling app.\n+        if (!Shared.shouldRestrictStorageAccessFramework(mActivity)) {\n+            return false;\n+        }\n+\n+        // We only need to restrict some locations on the \"external\" storage.\n+        if (!Providers.AUTHORITY_STORAGE.equals(uri.getAuthority())) {\n+            return false;\n+        }\n+\n+        // TODO(b/283962634): in the future this will have to be platform-version specific.\n+        //  For example, if the fix on the ExternalStorageProvider side makes it to the Android 15,\n+        //  we would change this to check if the platform version >= 15.\n+        //  In the upcoming Android 14 release, however, ExternalStorageProvider does NOT yet\n+        //  implement this logic.\n+        final boolean externalProviderImplementsSafRestrictions = false;\n+        if (externalProviderImplementsSafRestrictions) {\n+            return false;\n+        }\n+\n+        // External Storage Provider's docId format is \"root:path/to/file\"\n+        // The getPathFromStorageDocId() turns that into \"/path/to/file\"\n+        // Note the missing leading \"/\" in the path part of the docId, while the path returned by\n+        // the getPathFromStorageDocId() start with \"/\".\n+        final String docId = DocumentsContract.getDocumentId(uri);\n+        final String filePath;\n+        try {\n+             filePath = FileUtils.getPathFromStorageDocId(docId);\n+        } catch (IOException e) {\n+            Log.w(TAG, \"Could not get canonical file path from docId '\" + docId + \"'\");\n+            return true;\n+        }\n+\n+        // Check if the app is asking for /Android/data, /Android/obb, /Android/sandbox or any of\n+        // their subdirectories (on the external storage).\n+        return PATTERN_RESTRICTED_INITIAL_PATH.matcher(filePath).matches();\n     }\n \n     private void initLoadLastAccessedStack() {\ndiff --git a/src/com/android/documentsui/util/FileUtils.java b/src/com/android/documentsui/util/FileUtils.java\nnew file mode 100644\nindex 000000000..40f7fbae9\n--- /dev/null\n+++ b/src/com/android/documentsui/util/FileUtils.java\n@@ -0,0 +1,58 @@\n+/*\n+ * Copyright (C) 2023 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.android.documentsui.util;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+public class FileUtils {\n+\n+    /**\n+     * Returns the canonical pathname string of the provided abstract pathname.\n+     *\n+     * @return The canonical pathname string denoting the same file or directory as this abstract\n+     *         pathname.\n+     * @see File#getCanonicalPath()\n+     */\n+    @NonNull\n+    public static String getCanonicalPath(@NonNull String path) throws IOException {\n+        Objects.requireNonNull(path);\n+        return new File(path).getCanonicalPath();\n+    }\n+\n+    /**\n+     * This is basically a very slightly tweaked fork of\n+     * {@link com.android.externalstorage.ExternalStorageProvider#getPathFromDocId(String)}.\n+     * The difference between this fork and the \"original\" method is that here we do not strip\n+     * the leading and trailing \"/\"s (because we don't worry about those).\n+     *\n+     * @return canonicalized file path.\n+     */\n+    public static String getPathFromStorageDocId(String docId) throws IOException {\n+        // Remove the root tag from the docId, e.g. \"primary:\", which should leave with the file\n+        // path.\n+        final String docIdPath = docId.substring(docId.indexOf(':', 1) + 1);\n+\n+        return getCanonicalPath(docIdPath);\n+    }\n+\n+    private FileUtils() {\n+    }\n+}\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-372671447",
            "aliases": [
                "A-372671447",
                "CVE-2025-22428"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-372671447",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "e719575e92c1e6bd0b9088663e6c909bccf2b007"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From e719575e92c1e6bd0b9088663e6c909bccf2b007 Mon Sep 17 00:00:00 2001\nFrom: Fan Wu <cechkahn@google.com>\nDate: Thu, 2 Jan 2025 11:18:59 +0800\nSubject: [PATCH] Check the permission of the callingUid instead of the calling\n package\n\nBug: 372671447\nTest: atest\nFlag: EXEMPT bug fix\nChange-Id: Ib36c0a3ba482bcddd53c2c09409ea818e6f43cad\n---\n .../settings/applications/AppInfoBase.java    | 25 ++++++++++---------\n 1 file changed, 13 insertions(+), 12 deletions(-)\n\ndiff --git a/src/com/android/settings/applications/AppInfoBase.java b/src/com/android/settings/applications/AppInfoBase.java\nindex 1d774826c2d..02237b886d9 100644\n--- a/src/com/android/settings/applications/AppInfoBase.java\n+++ b/src/com/android/settings/applications/AppInfoBase.java\n@@ -20,6 +20,7 @@ import static com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\n \n import android.Manifest;\n import android.app.Activity;\n+import android.app.ActivityManager;\n import android.app.Dialog;\n import android.app.admin.DevicePolicyManager;\n import android.app.settings.SettingsEnums;\n@@ -34,6 +35,7 @@ import android.content.pm.PackageManager.NameNotFoundException;\n import android.hardware.usb.IUsbManager;\n import android.os.Bundle;\n import android.os.IBinder;\n+import android.os.RemoteException;\n import android.os.ServiceManager;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -176,20 +178,19 @@ public abstract class AppInfoBase extends SettingsPreferenceFragment\n         if (!(activity instanceof SettingsActivity)) {\n             return false;\n         }\n-        final String callingPackageName =\n-                ((SettingsActivity) activity).getInitialCallingPackage();\n-\n-        if (TextUtils.isEmpty(callingPackageName)) {\n-            Log.w(TAG, \"Not able to get calling package name for permission check\");\n-            return false;\n-        }\n-        if (mPm.checkPermission(Manifest.permission.INTERACT_ACROSS_USERS_FULL, callingPackageName)\n-                != PackageManager.PERMISSION_GRANTED) {\n-            Log.w(TAG, \"Package \" + callingPackageName + \" does not have required permission \"\n-                    + Manifest.permission.INTERACT_ACROSS_USERS_FULL);\n+        try {\n+            int callerUid = ActivityManager.getService().getLaunchedFromUid(\n+                    activity.getActivityToken());\n+            if (ActivityManager.checkUidPermission(Manifest.permission.INTERACT_ACROSS_USERS_FULL,\n+                    callerUid) != PackageManager.PERMISSION_GRANTED) {\n+                Log.w(TAG, \"Uid \" + callerUid + \" does not have required permission \"\n+                        + Manifest.permission.INTERACT_ACROSS_USERS_FULL);\n+                return false;\n+            }\n+            return true;\n+        } catch (RemoteException e) {\n             return false;\n         }\n-        return true;\n     }\n \n     protected void setIntentAndFinish(boolean appChanged) {\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 2,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "5bd45baa9365ea8db42249bf83d780c7a0473656"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "87645011fc78104372d08b303b361b83e4ce1a70",
                            "result": "success",
                            "downstream_patch_content": "commit 87645011fc78104372d08b303b361b83e4ce1a70\nAuthor: Fan Wu <cechkahn@google.com>\nDate:   Thu Jan 2 11:18:59 2025 +0800\n\n    Check the permission of the callingUid instead of the calling package\n    \n    Bug: 372671447\n    Test: atest\n    Flag: EXEMPT bug fix\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:e719575e92c1e6bd0b9088663e6c909bccf2b007)\n    Merged-In: Ib36c0a3ba482bcddd53c2c09409ea818e6f43cad\n    Change-Id: Ib36c0a3ba482bcddd53c2c09409ea818e6f43cad\n\ndiff --git a/src/com/android/settings/applications/AppInfoBase.java b/src/com/android/settings/applications/AppInfoBase.java\nindex 3e91d2d792f..a5f1a1438a2 100644\n--- a/src/com/android/settings/applications/AppInfoBase.java\n+++ b/src/com/android/settings/applications/AppInfoBase.java\n@@ -20,6 +20,7 @@ import static com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\n \n import android.Manifest;\n import android.app.Activity;\n+import android.app.ActivityManager;\n import android.app.Dialog;\n import android.app.admin.DevicePolicyManager;\n import android.app.settings.SettingsEnums;\n@@ -33,6 +34,7 @@ import android.content.pm.PackageManager.NameNotFoundException;\n import android.hardware.usb.IUsbManager;\n import android.os.Bundle;\n import android.os.IBinder;\n+import android.os.RemoteException;\n import android.os.ServiceManager;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -171,20 +173,19 @@ public abstract class AppInfoBase extends SettingsPreferenceFragment\n         if (!(activity instanceof SettingsActivity)) {\n             return false;\n         }\n-        final String callingPackageName =\n-                ((SettingsActivity) activity).getInitialCallingPackage();\n-\n-        if (TextUtils.isEmpty(callingPackageName)) {\n-            Log.w(TAG, \"Not able to get calling package name for permission check\");\n-            return false;\n-        }\n-        if (mPm.checkPermission(Manifest.permission.INTERACT_ACROSS_USERS_FULL, callingPackageName)\n-                != PackageManager.PERMISSION_GRANTED) {\n-            Log.w(TAG, \"Package \" + callingPackageName + \" does not have required permission \"\n-                    + Manifest.permission.INTERACT_ACROSS_USERS_FULL);\n+        try {\n+            int callerUid = ActivityManager.getService().getLaunchedFromUid(\n+                    activity.getActivityToken());\n+            if (ActivityManager.checkUidPermission(Manifest.permission.INTERACT_ACROSS_USERS_FULL,\n+                    callerUid) != PackageManager.PERMISSION_GRANTED) {\n+                Log.w(TAG, \"Uid \" + callerUid + \" does not have required permission \"\n+                        + Manifest.permission.INTERACT_ACROSS_USERS_FULL);\n+                return false;\n+            }\n+            return true;\n+        } catch (RemoteException e) {\n             return false;\n         }\n-        return true;\n     }\n \n     protected void setIntentAndFinish(boolean appChanged) {\n"
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "63656485eaeb51defab1b507f2351cba904c933e",
                            "result": "success",
                            "downstream_patch_content": "commit 63656485eaeb51defab1b507f2351cba904c933e\nAuthor: Fan Wu <cechkahn@google.com>\nDate:   Thu Jan 2 11:18:59 2025 +0800\n\n    Check the permission of the callingUid instead of the calling package\n    \n    Bug: 372671447\n    Test: atest\n    Flag: EXEMPT bug fix\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:e719575e92c1e6bd0b9088663e6c909bccf2b007)\n    Merged-In: Ib36c0a3ba482bcddd53c2c09409ea818e6f43cad\n    Change-Id: Ib36c0a3ba482bcddd53c2c09409ea818e6f43cad\n\ndiff --git a/src/com/android/settings/applications/AppInfoBase.java b/src/com/android/settings/applications/AppInfoBase.java\nindex 10fce8ebac0..e8a67de5a52 100644\n--- a/src/com/android/settings/applications/AppInfoBase.java\n+++ b/src/com/android/settings/applications/AppInfoBase.java\n@@ -20,6 +20,7 @@ import static com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\n \n import android.Manifest;\n import android.app.Activity;\n+import android.app.ActivityManager;\n import android.app.Dialog;\n import android.app.admin.DevicePolicyManager;\n import android.app.settings.SettingsEnums;\n@@ -34,6 +35,7 @@ import android.content.pm.PackageManager.NameNotFoundException;\n import android.hardware.usb.IUsbManager;\n import android.os.Bundle;\n import android.os.IBinder;\n+import android.os.RemoteException;\n import android.os.ServiceManager;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -172,20 +174,19 @@ public abstract class AppInfoBase extends SettingsPreferenceFragment\n         if (!(activity instanceof SettingsActivity)) {\n             return false;\n         }\n-        final String callingPackageName =\n-                ((SettingsActivity) activity).getInitialCallingPackage();\n-\n-        if (TextUtils.isEmpty(callingPackageName)) {\n-            Log.w(TAG, \"Not able to get calling package name for permission check\");\n-            return false;\n-        }\n-        if (mPm.checkPermission(Manifest.permission.INTERACT_ACROSS_USERS_FULL, callingPackageName)\n-                != PackageManager.PERMISSION_GRANTED) {\n-            Log.w(TAG, \"Package \" + callingPackageName + \" does not have required permission \"\n-                    + Manifest.permission.INTERACT_ACROSS_USERS_FULL);\n+        try {\n+            int callerUid = ActivityManager.getService().getLaunchedFromUid(\n+                    activity.getActivityToken());\n+            if (ActivityManager.checkUidPermission(Manifest.permission.INTERACT_ACROSS_USERS_FULL,\n+                    callerUid) != PackageManager.PERMISSION_GRANTED) {\n+                Log.w(TAG, \"Uid \" + callerUid + \" does not have required permission \"\n+                        + Manifest.permission.INTERACT_ACROSS_USERS_FULL);\n+                return false;\n+            }\n+            return true;\n+        } catch (RemoteException e) {\n             return false;\n         }\n-        return true;\n     }\n \n     protected void setIntentAndFinish(boolean appChanged) {\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-284989074",
            "aliases": [
                "A-284989074",
                "CVE-2024-49730"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-284989074",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "37e30a263c455ea9cff8ee887965ce0fefcfcf37"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 37e30a263c455ea9cff8ee887965ce0fefcfcf37 Mon Sep 17 00:00:00 2001\nFrom: Dipankar Bhardwaj <dipankarb@google.com>\nDate: Tue, 25 Jul 2023 17:42:15 +0000\nSubject: [PATCH] Expand the size of zero_addr to the maximum size of a single\n request.\n\nBug: 285078221\nBug: 284989074\nTest: atest RedactUriDeviceTest\nChange-Id: Ibf9f024a8d0bd5c3b3f2c7509f27adeb5077aa5e\nMerged-In: I44ba6302c3997266be7001a254b2d90d875b9d14\n(cherry picked from commit e45ef2e4c41c94b930c7c385b15f5756e0d24a81)\nDISABLE_TOPIC_PROTECTOR\n---\n jni/FuseDaemon.cpp | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\ndiff --git a/jni/FuseDaemon.cpp b/jni/FuseDaemon.cpp\nindex f71140546..232682d72 100755\n--- a/jni/FuseDaemon.cpp\n+++ b/jni/FuseDaemon.cpp\n@@ -102,7 +102,9 @@ const bool IS_OS_DEBUGABLE = android::base::GetIntProperty(\"ro.debuggable\", 0);\n // Stolen from: android_filesystem_config.h\n #define AID_APP_START 10000\n \n-constexpr size_t MAX_READ_SIZE = 128 * 1024;\n+#define FUSE_MAX_MAX_PAGES 256\n+\n+const size_t MAX_READ_SIZE = FUSE_MAX_MAX_PAGES * getpagesize();\n // Stolen from: UserHandle#getUserId\n constexpr int PER_USER_RANGE = 100000;\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 2,
                    "successful_patches": 2,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "37e30a263c455ea9cff8ee887965ce0fefcfcf37",
                            "result": "success",
                            "downstream_patch_content": "commit 37e30a263c455ea9cff8ee887965ce0fefcfcf37\nAuthor: Dipankar Bhardwaj <dipankarb@google.com>\nDate:   Tue Jul 25 17:42:15 2023 +0000\n\n    Expand the size of zero_addr to the maximum size of a single request.\n    \n    Bug: 285078221\n    Bug: 284989074\n    Test: atest RedactUriDeviceTest\n    Change-Id: Ibf9f024a8d0bd5c3b3f2c7509f27adeb5077aa5e\n    Merged-In: I44ba6302c3997266be7001a254b2d90d875b9d14\n    (cherry picked from commit e45ef2e4c41c94b930c7c385b15f5756e0d24a81)\n    DISABLE_TOPIC_PROTECTOR\n\ndiff --git a/jni/FuseDaemon.cpp b/jni/FuseDaemon.cpp\nindex f71140546..232682d72 100755\n--- a/jni/FuseDaemon.cpp\n+++ b/jni/FuseDaemon.cpp\n@@ -102,7 +102,9 @@ const bool IS_OS_DEBUGABLE = android::base::GetIntProperty(\"ro.debuggable\", 0);\n // Stolen from: android_filesystem_config.h\n #define AID_APP_START 10000\n \n-constexpr size_t MAX_READ_SIZE = 128 * 1024;\n+#define FUSE_MAX_MAX_PAGES 256\n+\n+const size_t MAX_READ_SIZE = FUSE_MAX_MAX_PAGES * getpagesize();\n // Stolen from: UserHandle#getUserId\n constexpr int PER_USER_RANGE = 100000;\n \n"
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "37e30a263c455ea9cff8ee887965ce0fefcfcf37",
                            "result": "success",
                            "downstream_patch_content": "commit 37e30a263c455ea9cff8ee887965ce0fefcfcf37\nAuthor: Dipankar Bhardwaj <dipankarb@google.com>\nDate:   Tue Jul 25 17:42:15 2023 +0000\n\n    Expand the size of zero_addr to the maximum size of a single request.\n    \n    Bug: 285078221\n    Bug: 284989074\n    Test: atest RedactUriDeviceTest\n    Change-Id: Ibf9f024a8d0bd5c3b3f2c7509f27adeb5077aa5e\n    Merged-In: I44ba6302c3997266be7001a254b2d90d875b9d14\n    (cherry picked from commit e45ef2e4c41c94b930c7c385b15f5756e0d24a81)\n    DISABLE_TOPIC_PROTECTOR\n\ndiff --git a/jni/FuseDaemon.cpp b/jni/FuseDaemon.cpp\nindex f71140546..232682d72 100755\n--- a/jni/FuseDaemon.cpp\n+++ b/jni/FuseDaemon.cpp\n@@ -102,7 +102,9 @@ const bool IS_OS_DEBUGABLE = android::base::GetIntProperty(\"ro.debuggable\", 0);\n // Stolen from: android_filesystem_config.h\n #define AID_APP_START 10000\n \n-constexpr size_t MAX_READ_SIZE = 128 * 1024;\n+#define FUSE_MAX_MAX_PAGES 256\n+\n+const size_t MAX_READ_SIZE = FUSE_MAX_MAX_PAGES * getpagesize();\n // Stolen from: UserHandle#getUserId\n constexpr int PER_USER_RANGE = 100000;\n \n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-332277530",
            "aliases": [
                "A-332277530",
                "CVE-2025-22417"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-332277530",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "7366b99644fa61279591eec54ea725d86d6e2e93"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 7366b99644fa61279591eec54ea725d86d6e2e93 Mon Sep 17 00:00:00 2001\nFrom: Vishnu Nair <vishnun@google.com>\nDate: Fri, 24 Jan 2025 05:37:23 +0000\nSubject: [PATCH] Update ActivityRecordInputSink using the pending transaction\n\nIn some cases where finishTransition happens before the pending\ntransaction is applied, we can end up with a stale state. Subsequent\nprepareSurfaces does not fix the issue because the InputWindowHandle is\nonly applied on changes.\n\nFix the race by only using pending transactions to apply\nActivityRecordInputSink state changes.\n\nBug: 332277530\nTest: POC from bug\nFlag: EXEMPT bug fix\nChange-Id: If93840ad7b2abbcb48c0c332870c48046c0f8fdc\n---\n .../core/java/com/android/server/wm/Transition.java   | 11 +++++------\n 1 file changed, 5 insertions(+), 6 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/wm/Transition.java b/services/core/java/com/android/server/wm/Transition.java\nindex 37cc0d22c063..27683b2fcff2 100644\n--- a/services/core/java/com/android/server/wm/Transition.java\n+++ b/services/core/java/com/android/server/wm/Transition.java\n@@ -1504,16 +1504,15 @@ class Transition implements BLASTSyncEngine.TransactionReadyListener {\n         }\n \n         // Update the input-sink (touch-blocking) state now that the animation is finished.\n-        SurfaceControl.Transaction inputSinkTransaction = null;\n+        boolean scheduleAnimation = false;\n         for (int i = 0; i < mParticipants.size(); ++i) {\n             final ActivityRecord ar = mParticipants.valueAt(i).asActivityRecord();\n             if (ar == null || !ar.isVisible() || ar.getParent() == null) continue;\n-            if (inputSinkTransaction == null) {\n-                inputSinkTransaction = ar.mWmService.mTransactionFactory.get();\n-            }\n-            ar.mActivityRecordInputSink.applyChangesToSurfaceIfChanged(inputSinkTransaction);\n+            scheduleAnimation = true;\n+            ar.mActivityRecordInputSink.applyChangesToSurfaceIfChanged(ar.getPendingTransaction());\n         }\n-        if (inputSinkTransaction != null) inputSinkTransaction.apply();\n+        // To apply pending transactions.\n+        if (scheduleAnimation) mController.mAtm.mWindowManager.scheduleAnimationLocked();\n \n         // Always schedule stop processing when transition finishes because activities don't\n         // stop while they are in a transition thus their stop could still be pending.\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 2,
                    "successful_patches": 1,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "24aeaa1b55d3c602ddd4e53a44bf304a21c8d3df"
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "806927c67cbb308739b06efe78ee474c83b66e24",
                            "result": "success",
                            "downstream_patch_content": "commit 806927c67cbb308739b06efe78ee474c83b66e24\nAuthor: Vishnu Nair <vishnun@google.com>\nDate:   Fri Jan 24 05:37:23 2025 +0000\n\n    DO NOT MERGE: Update ActivityRecordInputSink using the pending transaction\n    \n    In some cases where finishTransition happens before the pending\n    transaction is applied, we can end up with a stale state. Subsequent\n    prepareSurfaces does not fix the issue because the InputWindowHandle is\n    only applied on changes.\n    \n    Fix the race by only using pending transactions to apply\n    ActivityRecordInputSink state changes.\n    \n    Bug: 332277530\n    Test: POC from bug\n    Flag: EXEMPT bug fix\n    Change-Id: If93840ad7b2abbcb48c0c332870c48046c0f8fdc\n    Merged-In: If93840ad7b2abbcb48c0c332870c48046c0f8fdc\n\ndiff --git a/services/core/java/com/android/server/wm/Transition.java b/services/core/java/com/android/server/wm/Transition.java\nindex 2ac3125de961..6037fa55d78f 100644\n--- a/services/core/java/com/android/server/wm/Transition.java\n+++ b/services/core/java/com/android/server/wm/Transition.java\n@@ -1240,16 +1240,15 @@ class Transition implements BLASTSyncEngine.TransactionReadyListener {\n         }\n \n         // Update the input-sink (touch-blocking) state now that the animation is finished.\n-        SurfaceControl.Transaction inputSinkTransaction = null;\n+        boolean scheduleAnimation = false;\n         for (int i = 0; i < mParticipants.size(); ++i) {\n             final ActivityRecord ar = mParticipants.valueAt(i).asActivityRecord();\n             if (ar == null || !ar.isVisible() || ar.getParent() == null) continue;\n-            if (inputSinkTransaction == null) {\n-                inputSinkTransaction = ar.mWmService.mTransactionFactory.get();\n-            }\n-            ar.mActivityRecordInputSink.applyChangesToSurfaceIfChanged(inputSinkTransaction);\n+            scheduleAnimation = true;\n+            ar.mActivityRecordInputSink.applyChangesToSurfaceIfChanged(ar.getPendingTransaction());\n         }\n-        if (inputSinkTransaction != null) inputSinkTransaction.apply();\n+        // To apply pending transactions.\n+        if (scheduleAnimation) mController.mAtm.mWindowManager.scheduleAnimationLocked();\n \n         // Always schedule stop processing when transition finishes because activities don't\n         // stop while they are in a transition thus their stop could still be pending.\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-374257207",
            "aliases": [
                "A-374257207",
                "CVE-2025-22430"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-374257207",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "389e4cf737571bf0c438239400295fd229acc3e8"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 389e4cf737571bf0c438239400295fd229acc3e8 Mon Sep 17 00:00:00 2001\nFrom: Soonil Nagarkar <sooniln@google.com>\nDate: Fri, 25 Oct 2024 10:41:26 -0700\nSubject: [PATCH] Add permissions check to isInSignificantPlace()\n\nRequire the ACCESS_FINE_LOCATION permission for this API.\n\nFlag: EXEMPT bugfix\nBug: 374257207\nTest: manual\nChange-Id: I1c5ef857c750dbbd0577f5aadc43e9b6122de790\n---\n core/java/android/app/trust/ITrustManager.aidl                | 1 +\n core/java/android/app/trust/TrustManager.java                 | 1 +\n .../java/com/android/server/trust/TrustManagerService.java    | 4 ++++\n 3 files changed, 6 insertions(+)\n\ndiff --git a/core/java/android/app/trust/ITrustManager.aidl b/core/java/android/app/trust/ITrustManager.aidl\nindex 740f5932f902..730bb73da3bb 100644\n--- a/core/java/android/app/trust/ITrustManager.aidl\n+++ b/core/java/android/app/trust/ITrustManager.aidl\n@@ -41,5 +41,6 @@ interface ITrustManager {\n     void unlockedByBiometricForUser(int userId, in BiometricSourceType source);\n     void clearAllBiometricRecognized(in BiometricSourceType target, int unlockedUser);\n     boolean isActiveUnlockRunning(int userId);\n+    @EnforcePermission(\"ACCESS_FINE_LOCATION\")\n     boolean isInSignificantPlace();\n }\ndiff --git a/core/java/android/app/trust/TrustManager.java b/core/java/android/app/trust/TrustManager.java\nindex 88d4d691cd97..1ef83cdf3f85 100644\n--- a/core/java/android/app/trust/TrustManager.java\n+++ b/core/java/android/app/trust/TrustManager.java\n@@ -305,6 +305,7 @@ public class TrustManager {\n      *\n      * @hide\n      */\n+    @RequiresPermission(Manifest.permission.ACCESS_FINE_LOCATION)\n     public boolean isInSignificantPlace() {\n         try {\n             return mService.isInSignificantPlace();\ndiff --git a/services/core/java/com/android/server/trust/TrustManagerService.java b/services/core/java/com/android/server/trust/TrustManagerService.java\nindex 457196b74d2e..465ac2f1731d 100644\n--- a/services/core/java/com/android/server/trust/TrustManagerService.java\n+++ b/services/core/java/com/android/server/trust/TrustManagerService.java\n@@ -21,6 +21,7 @@ import static android.service.trust.GrantTrustResult.STATUS_UNLOCKED_BY_GRANT;\n import static android.service.trust.TrustAgentService.FLAG_GRANT_TRUST_TEMPORARY_AND_RENEWABLE;\n \n import android.Manifest;\n+import android.annotation.EnforcePermission;\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.annotation.UserIdInt;\n@@ -1896,8 +1897,11 @@ public class TrustManagerService extends SystemService {\n             }\n         }\n \n+        @EnforcePermission(Manifest.permission.ACCESS_FINE_LOCATION)\n         @Override\n         public boolean isInSignificantPlace() {\n+            super.isInSignificantPlace_enforcePermission();\n+\n             if (android.security.Flags.significantPlaces()) {\n                 mSignificantPlaceServiceWatcher.runOnBinder(\n                         binder -> ISignificantPlaceProvider.Stub.asInterface(binder)\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "f085fccf0bb7963962ae56618c5b3a1762d3aeab"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-375409435",
            "aliases": [
                "A-375409435",
                "CVE-2025-22403"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375409435",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "7f74d44cebf1cad4b3d7aa9b05236a41cb221e9e"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 7f74d44cebf1cad4b3d7aa9b05236a41cb221e9e Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Wed, 30 Oct 2024 23:58:27 +0000\nSubject: [PATCH] Fix incorrect logging in sdp_discovery\n\nIn two locations in sdp_discovery.cc, log statements use structures that\nmay, in exceptional cases, have been freed by preceding calls.  This can\nlead to use after free and potentially to security vulnerabilities.\n\nUse local variables instead.\n\nBug: 375408314\nBug: 375409435\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: I76e1ffa1fe463a5858d61d025447d855ff6b5b84\n---\n system/stack/sdp/sdp_discovery.cc | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\ndiff --git a/system/stack/sdp/sdp_discovery.cc b/system/stack/sdp/sdp_discovery.cc\nindex 2e5cd86da0..75cd5a7ea2 100644\n--- a/system/stack/sdp/sdp_discovery.cc\n+++ b/system/stack/sdp/sdp_discovery.cc\n@@ -183,7 +183,7 @@ static void sdp_snd_service_search_req(tCONN_CB* p_ccb, uint8_t cont_len, uint8_\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_cmd) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_cmd->len);\n+              p_ccb->connection_id, p - p_start);\n   }\n \n   /* Start inactivity timer */\n@@ -711,7 +711,7 @@ static void process_service_search_attr_rsp(tCONN_CB* p_ccb, uint8_t* p_reply,\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_msg) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-                p_ccb->connection_id, p_msg->len);\n+                p_ccb->connection_id, p - p_start);\n     }\n \n     /* Start inactivity timer */\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "bb2f54f9ed938267c2830da4a9d984529274d8a8"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-345881518",
            "aliases": [
                "A-345881518",
                "CVE-2024-49735"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-345881518",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "1181fd1b6769e6f093cd409e2b9f7aa0f91d7ed9",
                        "4db9092ad1d099f75726367544bb8949fdb79c2f"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 1181fd1b6769e6f093cd409e2b9f7aa0f91d7ed9 Mon Sep 17 00:00:00 2001\nFrom: Yuri Lin <yurilin@google.com>\nDate: Thu, 22 Aug 2024 18:18:43 -0400\nSubject: [PATCH] Limit the size of vibration effects stored on a\n NotificationChannel\n\nThis change adds a cropToLengthOrNull() @hide method to the VibrationEffect interface, implemented only by compositions, to provide a best-effort crop of the number of segments involved in a vibration effect.\n\nFor notification channels, changes the max vibration length to 500 from 1000. We probably don't need that much space, and serializing vibration effects means that the data ends up taking up a lot more space than just the array for the vibration pattern.\n\nAdds android.app.notif_channel_crop_vibration_effects bugfix flag that limits when we attempt to crop the vibration effects.\n\nBug: 345881518\nTest: manual with flag on/off; NotificationChannelTest; VibrationEffectTest\nFlag: android.app.notif_channel_crop_vibration_effects\nChange-Id: I885f733112af89fe9f255db626fcdc297b1a18c8\n---\n .../java/android/app/NotificationChannel.java | 59 ++++++++++++--\n core/java/android/app/notification.aconfig    | 10 +++\n core/java/android/os/VibrationEffect.java     | 42 ++++++++++\n .../android/app/NotificationChannelTest.java  | 27 +++++++\n .../src/android/os/VibrationEffectTest.java   | 80 +++++++++++++++++++\n 5 files changed, 212 insertions(+), 6 deletions(-)\n\ndiff --git a/core/java/android/app/NotificationChannel.java b/core/java/android/app/NotificationChannel.java\nindex 789c99d8e017..1b29b7a294df 100644\n--- a/core/java/android/app/NotificationChannel.java\n+++ b/core/java/android/app/NotificationChannel.java\n@@ -168,7 +168,11 @@ public final class NotificationChannel implements Parcelable {\n     /**\n      * @hide\n      */\n-    public static final int MAX_VIBRATION_LENGTH = 1000;\n+    public static final int MAX_VIBRATION_LENGTH = 500;\n+    /**\n+     * @hide\n+     */\n+    public static final int MAX_SERIALIZED_VIBRATION_LENGTH = 32_768;\n \n     private static final String TAG_CHANNEL = \"channel\";\n     private static final String ATT_NAME = \"name\";\n@@ -368,6 +372,9 @@ public final class NotificationChannel implements Parcelable {\n         if (Flags.notificationChannelVibrationEffectApi()) {\n             mVibrationEffect =\n                     in.readInt() != 0 ? VibrationEffect.CREATOR.createFromParcel(in) : null;\n+            if (Flags.notifChannelCropVibrationEffects() && mVibrationEffect != null) {\n+                mVibrationEffect = getTrimmedVibrationEffect(mVibrationEffect);\n+            }\n         }\n         mUserLockedFields = in.readInt();\n         mUserVisibleTaskShown = in.readByte() != 0;\n@@ -582,6 +589,23 @@ public final class NotificationChannel implements Parcelable {\n         return input;\n     }\n \n+    // Returns trimmed vibration effect or null if not trimmable.\n+    private VibrationEffect getTrimmedVibrationEffect(VibrationEffect effect) {\n+        if (effect == null) {\n+            return null;\n+        }\n+        // trim if possible; check serialized length; reject if it is still too long\n+        VibrationEffect result = effect;\n+        VibrationEffect trimmed = effect.cropToLengthOrNull(MAX_VIBRATION_LENGTH);\n+        if (trimmed != null) {\n+            result = trimmed;\n+        }\n+        if (vibrationToString(result).length() > MAX_SERIALIZED_VIBRATION_LENGTH) {\n+            return null;\n+        }\n+        return result;\n+    }\n+\n     /**\n      * @hide\n      */\n@@ -685,6 +709,11 @@ public final class NotificationChannel implements Parcelable {\n     public void setVibrationPattern(long[] vibrationPattern) {\n         this.mVibrationEnabled = vibrationPattern != null && vibrationPattern.length > 0;\n         this.mVibrationPattern = vibrationPattern;\n+        if (Flags.notifChannelCropVibrationEffects()) {\n+            if (vibrationPattern != null && vibrationPattern.length > MAX_VIBRATION_LENGTH) {\n+                this.mVibrationPattern = Arrays.copyOf(vibrationPattern, MAX_VIBRATION_LENGTH);\n+            }\n+        }\n         if (Flags.notificationChannelVibrationEffectApi()) {\n             try {\n                 this.mVibrationEffect =\n@@ -731,9 +760,21 @@ public final class NotificationChannel implements Parcelable {\n     public void setVibrationEffect(@Nullable VibrationEffect effect) {\n         this.mVibrationEnabled = effect != null;\n         this.mVibrationEffect = effect;\n-        this.mVibrationPattern =\n-                effect == null\n-                ? null : effect.computeCreateWaveformOffOnTimingsOrNull();\n+        if (Flags.notifChannelCropVibrationEffects() && effect != null) {\n+            // Try converting to a vibration pattern and trimming that array. If not convertible\n+            // to a pattern directly, try trimming the vibration effect if possible and storing\n+            // that version instead.\n+            long[] pattern = effect.computeCreateWaveformOffOnTimingsOrNull();\n+            if (pattern != null) {\n+                setVibrationPattern(pattern);\n+            } else {\n+                this.mVibrationEffect = getTrimmedVibrationEffect(mVibrationEffect);\n+            }\n+        } else {\n+            this.mVibrationPattern =\n+                    mVibrationEffect == null\n+                            ? null : mVibrationEffect.computeCreateWaveformOffOnTimingsOrNull();\n+        }\n     }\n \n     /**\n@@ -1172,7 +1213,9 @@ public final class NotificationChannel implements Parcelable {\n             if (vibrationEffect != null) {\n                 // Restore the effect only if it is not null. This allows to avoid undoing a\n                 // `setVibrationPattern` call above, if that was done with a non-null pattern\n-                // (e.g. back up from a version that did not support `setVibrationEffect`).\n+                // (e.g. back up from a version that did not support `setVibrationEffect`), or\n+                // when notif_channel_crop_vibration_effects is true, if there is an equivalent\n+                // vibration pattern available.\n                 setVibrationEffect(vibrationEffect);\n             }\n         }\n@@ -1365,7 +1408,11 @@ public final class NotificationChannel implements Parcelable {\n             out.attribute(null, ATT_VIBRATION, longArrayToString(getVibrationPattern()));\n         }\n         if (getVibrationEffect() != null) {\n-            out.attribute(null, ATT_VIBRATION_EFFECT, vibrationToString(getVibrationEffect()));\n+            if (!Flags.notifChannelCropVibrationEffects() || getVibrationPattern() == null) {\n+                // When notif_channel_crop_vibration_effects is on, only serialize the vibration\n+                // effect if we do not already have an equivalent vibration pattern.\n+                out.attribute(null, ATT_VIBRATION_EFFECT, vibrationToString(getVibrationEffect()));\n+            }\n         }\n         if (getUserLockedFields() != 0) {\n             out.attributeInt(null, ATT_USER_LOCKED, getUserLockedFields());\ndiff --git a/core/java/android/app/notification.aconfig b/core/java/android/app/notification.aconfig\nindex 606ca3393de0..9891e8930936 100644\n--- a/core/java/android/app/notification.aconfig\n+++ b/core/java/android/app/notification.aconfig\n@@ -127,6 +127,16 @@ flag {\n   bug: \"241732519\"\n }\n \n+flag {\n+  name: \"notif_channel_crop_vibration_effects\"\n+  namespace: \"systemui\"\n+  description: \"Limits the size of vibration effects that can be stored in a NotificationChannel\"\n+  bug: \"345881518\"\n+  metadata {\n+    purpose: PURPOSE_BUGFIX\n+  }\n+}\n+\n flag {\n   name: \"evenly_divided_call_style_action_layout\"\n   namespace: \"systemui\"\ndiff --git a/core/java/android/os/VibrationEffect.java b/core/java/android/os/VibrationEffect.java\nindex f02d4a9ce4a7..64a2dbcb6a83 100644\n--- a/core/java/android/os/VibrationEffect.java\n+++ b/core/java/android/os/VibrationEffect.java\n@@ -540,6 +540,17 @@ public abstract class VibrationEffect implements Parcelable {\n     /** @hide */\n     public abstract void validate();\n \n+\n+    /**\n+     * If supported, truncate the length of this vibration effect to the provided length and return\n+     * the result. Will always return null for repeating effects.\n+     *\n+     * @return The desired effect, or {@code null} if truncation is not applicable.\n+     * @hide\n+     */\n+    @Nullable\n+    public abstract VibrationEffect cropToLengthOrNull(int length);\n+\n     /**\n      * Gets the estimated duration of the vibration in milliseconds.\n      *\n@@ -866,6 +877,30 @@ public abstract class VibrationEffect implements Parcelable {\n             }\n         }\n \n+        /** @hide */\n+        @Override\n+        @Nullable\n+        public VibrationEffect cropToLengthOrNull(int length) {\n+            // drop repeating effects\n+            if (mRepeatIndex >= 0) {\n+                return null;\n+            }\n+\n+            int segmentCount = mSegments.size();\n+            if (segmentCount <= length) {\n+                return this;\n+            }\n+\n+            ArrayList truncated = new ArrayList(mSegments.subList(0, length));\n+            Composed updated = new Composed(truncated, mRepeatIndex);\n+            try {\n+                updated.validate();\n+            } catch (IllegalArgumentException e) {\n+                return null;\n+            }\n+            return updated;\n+        }\n+\n         @Override\n         public long getDuration() {\n             if (mRepeatIndex >= 0) {\n@@ -1150,6 +1185,13 @@ public abstract class VibrationEffect implements Parcelable {\n                     \"Vendor effect bundle must be non-empty\");\n         }\n \n+        /** @hide */\n+        @Override\n+        @Nullable\n+        public VibrationEffect cropToLengthOrNull(int length) {\n+            return null;\n+        }\n+\n         @Override\n         public long getDuration() {\n             return -1; // UNKNOWN\ndiff --git a/core/tests/coretests/src/android/app/NotificationChannelTest.java b/core/tests/coretests/src/android/app/NotificationChannelTest.java\nindex c08e42b7179c..e47ef2df48b9 100644\n--- a/core/tests/coretests/src/android/app/NotificationChannelTest.java\n+++ b/core/tests/coretests/src/android/app/NotificationChannelTest.java\n@@ -232,6 +232,33 @@ public class NotificationChannelTest {\n                 fromParcel.getSound().toString().length());\n     }\n \n+    @Test\n+    @EnableFlags({Flags.FLAG_NOTIFICATION_CHANNEL_VIBRATION_EFFECT_API,\n+            Flags.FLAG_NOTIF_CHANNEL_CROP_VIBRATION_EFFECTS})\n+    public void testLongVibrationFields_canWriteToXml() throws Exception {\n+        NotificationChannel channel = new NotificationChannel(\"id\", \"name\", 3);\n+        // populate pattern with contents\n+        long[] pattern = new long[65550 / 2];\n+        for (int i = 0; i < pattern.length; i++) {\n+            pattern[i] = 100;\n+        }\n+        channel.setVibrationPattern(pattern);  // with flag on, also sets effect\n+\n+        // Send it through parceling & unparceling to simulate being passed through a binder call\n+        NotificationChannel fromParcel = writeToAndReadFromParcel(channel);\n+        assertThat(fromParcel.getVibrationPattern().length).isEqualTo(\n+                NotificationChannel.MAX_VIBRATION_LENGTH);\n+\n+        // Confirm that this also survives writing to & restoring from XML\n+        NotificationChannel result = backUpAndRestore(fromParcel);\n+        assertThat(result.getVibrationPattern().length).isEqualTo(\n+                NotificationChannel.MAX_VIBRATION_LENGTH);\n+        assertThat(result.getVibrationEffect()).isNotNull();\n+        assertThat(result.getVibrationEffect()\n+                .computeCreateWaveformOffOnTimingsOrNull())\n+                .isEqualTo(result.getVibrationPattern());\n+    }\n+\n     @Test\n     public void testRestoreSoundUri_customLookup() throws Exception {\n         Uri uriToBeRestoredUncanonicalized = Uri.parse(\"content://media/1\");\ndiff --git a/core/tests/vibrator/src/android/os/VibrationEffectTest.java b/core/tests/vibrator/src/android/os/VibrationEffectTest.java\nindex 4f76dd636c30..f5b04ee759a5 100644\n--- a/core/tests/vibrator/src/android/os/VibrationEffectTest.java\n+++ b/core/tests/vibrator/src/android/os/VibrationEffectTest.java\n@@ -429,6 +429,86 @@ public class VibrationEffectTest {\n         assertNull(effect.computeCreateWaveformOffOnTimingsOrNull());\n     }\n \n+    @Test\n+    public void cropToLength_waveform_underLength() {\n+        VibrationEffect effect = VibrationEffect.createWaveform(\n+                /* timings= */ new long[]{0, 1, 2},\n+                /* repeatIndex= */ -1);\n+        VibrationEffect result = effect.cropToLengthOrNull(5);\n+\n+        assertThat(result).isEqualTo(effect); // unchanged\n+    }\n+\n+    @Test\n+    public void cropToLength_waveform_overLength() {\n+        VibrationEffect effect = VibrationEffect.createWaveform(\n+                /* timings= */ new long[]{0, 1, 2, 3, 4, 5, 6},\n+                /* repeatIndex= */ -1);\n+        VibrationEffect result = effect.cropToLengthOrNull(4);\n+\n+        assertThat(result).isEqualTo(VibrationEffect.createWaveform(\n+                new long[]{0, 1, 2, 3},\n+                -1));\n+    }\n+\n+    @Test\n+    public void cropToLength_waveform_repeating() {\n+        // repeating waveforms cannot be truncated\n+        VibrationEffect effect = VibrationEffect.createWaveform(\n+                /* timings= */ new long[]{0, 1, 2, 3, 4, 5, 6},\n+                /* repeatIndex= */ 2);\n+        VibrationEffect result = effect.cropToLengthOrNull(3);\n+\n+        assertThat(result).isNull();\n+    }\n+\n+    @Test\n+    public void cropToLength_waveform_withAmplitudes() {\n+        VibrationEffect effect = VibrationEffect.createWaveform(\n+                /* timings= */ new long[]{0, 1, 2, 3, 4, 5, 6},\n+                /* amplitudes= */ new int[]{10, 20, 40, 10, 20, 40, 10},\n+                /* repeatIndex= */ -1);\n+        VibrationEffect result = effect.cropToLengthOrNull(3);\n+\n+        assertThat(result).isEqualTo(VibrationEffect.createWaveform(\n+                new long[]{0, 1, 2},\n+                new int[]{10, 20, 40},\n+                -1));\n+    }\n+\n+    @Test\n+    public void cropToLength_composed() {\n+        VibrationEffect effect = VibrationEffect.startComposition()\n+                .addPrimitive(VibrationEffect.Composition.PRIMITIVE_CLICK)\n+                .addPrimitive(VibrationEffect.Composition.PRIMITIVE_TICK)\n+                .compose();\n+        VibrationEffect result = effect.cropToLengthOrNull(1);\n+\n+        assertThat(result).isNotNull();\n+        assertThat(result).isEqualTo(VibrationEffect.startComposition()\n+                        .addPrimitive(VibrationEffect.Composition.PRIMITIVE_CLICK)\n+                        .compose());\n+    }\n+\n+    @Test\n+    public void cropToLength_composed_repeating() {\n+        VibrationEffect effect = VibrationEffect.startComposition()\n+                .addPrimitive(VibrationEffect.Composition.PRIMITIVE_CLICK)\n+                .repeatEffectIndefinitely(TEST_ONE_SHOT)\n+                .compose();\n+        assertThat(effect.cropToLengthOrNull(1)).isNull();\n+    }\n+\n+    @Test\n+    @RequiresFlagsEnabled(android.os.vibrator.Flags.FLAG_VENDOR_VIBRATION_EFFECTS)\n+    public void cropToLength_vendorEffect() {\n+        PersistableBundle vendorData = new PersistableBundle();\n+        vendorData.putInt(\"key\", 1);\n+        VibrationEffect effect = VibrationEffect.createVendorEffect(vendorData);\n+\n+        assertThat(effect.cropToLengthOrNull(2)).isNull();\n+    }\n+\n     @Test\n     public void getRingtones_noPrebakedRingtones() {\n         Resources r = mockRingtoneResources(new String[0]);\n-- \n2.39.5 (Apple Git-154)\n\nFrom 4db9092ad1d099f75726367544bb8949fdb79c2f Mon Sep 17 00:00:00 2001\nFrom: Yuri Lin <yurilin@google.com>\nDate: Mon, 9 Sep 2024 15:40:24 -0400\nSubject: [PATCH] Update handling of vibration effects that don't need cropping\n\nThis change splits the addition of vibration effects into three cases:\n- has equivalent vibration pattern, and that pattern needs trimming: delegate to setVibrationPattern to trim & re-convert to a vibration effect\n- has equivalent vibration pattern, which is under the size limit: set vibration pattern directly, and store the effect passed in by the caller\n- has no equivalent vibration pattern: trim effect if possible\n\nAlso: when there is no equivalent vibration pattern, set it to null, thus making sure to override any value previously set by setVibrationPattern.\n\nThis fixes some tests that were expecting the effect to be exactly the same as what was passed in, but we were instead producing an equivalent one with an extra \"0\"-duration at the beginning, and otherwise avoids doing some redundant conversions.\n\nAlso parameterizes the unit test to run with both values of notif_channel_crop_vibration_effects, to avoid running into any further potential test issues when the flag turns on.\n\nBug: 345881518\nBug: 365538915\nFixes: 364960520\nTest: NotificationChannelTest (both CTS and unit)\nFlag: android.app.notif_channel_crop_vibration_effects\nChange-Id: I3073e88a95169b049b051b37936e3fb9e8c16e9f\n---\n .../java/android/app/NotificationChannel.java | 16 +++++++++---\n .../android/app/NotificationChannelTest.java  | 26 ++++++++++++++++---\n 2 files changed, 35 insertions(+), 7 deletions(-)\n\ndiff --git a/core/java/android/app/NotificationChannel.java b/core/java/android/app/NotificationChannel.java\nindex 1b29b7a294df..32e9542e91a7 100644\n--- a/core/java/android/app/NotificationChannel.java\n+++ b/core/java/android/app/NotificationChannel.java\n@@ -761,14 +761,22 @@ public final class NotificationChannel implements Parcelable {\n         this.mVibrationEnabled = effect != null;\n         this.mVibrationEffect = effect;\n         if (Flags.notifChannelCropVibrationEffects() && effect != null) {\n-            // Try converting to a vibration pattern and trimming that array. If not convertible\n-            // to a pattern directly, try trimming the vibration effect if possible and storing\n-            // that version instead.\n             long[] pattern = effect.computeCreateWaveformOffOnTimingsOrNull();\n             if (pattern != null) {\n-                setVibrationPattern(pattern);\n+                // If this effect has an equivalent pattern, AND the pattern needs to be truncated\n+                // due to being too long, we delegate to setVibrationPattern to re-generate the\n+                // effect as well. Otherwise, we use the effect (already set above) and converted\n+                // pattern directly.\n+                if (pattern.length > MAX_VIBRATION_LENGTH) {\n+                    setVibrationPattern(pattern);\n+                } else {\n+                    this.mVibrationPattern = pattern;\n+                }\n             } else {\n+                // If not convertible to a pattern directly, try trimming the vibration effect if\n+                // possible and storing that version instead.\n                 this.mVibrationEffect = getTrimmedVibrationEffect(mVibrationEffect);\n+                this.mVibrationPattern = null;\n             }\n         } else {\n             this.mVibrationPattern =\ndiff --git a/core/tests/coretests/src/android/app/NotificationChannelTest.java b/core/tests/coretests/src/android/app/NotificationChannelTest.java\nindex e47ef2df48b9..e19f887c1284 100644\n--- a/core/tests/coretests/src/android/app/NotificationChannelTest.java\n+++ b/core/tests/coretests/src/android/app/NotificationChannelTest.java\n@@ -47,12 +47,13 @@ import android.os.RemoteException;\n import android.os.VibrationEffect;\n import android.platform.test.annotations.EnableFlags;\n import android.platform.test.annotations.Presubmit;\n+import android.platform.test.annotations.UsesFlags;\n+import android.platform.test.flag.junit.FlagsParameterization;\n import android.platform.test.flag.junit.SetFlagsRule;\n import android.provider.MediaStore.Audio.AudioColumns;\n import android.test.mock.MockContentResolver;\n import android.util.Xml;\n \n-import androidx.test.ext.junit.runners.AndroidJUnit4;\n import androidx.test.filters.SmallTest;\n \n import com.android.modules.utils.TypedXmlPullParser;\n@@ -61,6 +62,7 @@ import com.android.modules.utils.TypedXmlSerializer;\n import com.google.common.base.Strings;\n \n import org.junit.Before;\n+import org.junit.ClassRule;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -71,14 +73,28 @@ import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.lang.reflect.Field;\n import java.util.Arrays;\n+import java.util.List;\n import java.util.function.Consumer;\n \n-@RunWith(AndroidJUnit4.class)\n+import platform.test.runner.parameterized.ParameterizedAndroidJunit4;\n+import platform.test.runner.parameterized.Parameters;\n+\n+@RunWith(ParameterizedAndroidJunit4.class)\n+@UsesFlags(android.app.Flags.class)\n @SmallTest\n @Presubmit\n public class NotificationChannelTest {\n+    @ClassRule\n+    public static final SetFlagsRule.ClassRule mSetFlagsClassRule = new SetFlagsRule.ClassRule();\n+\n+    @Parameters(name = \"{0}\")\n+    public static List<FlagsParameterization> getParams() {\n+        return FlagsParameterization.allCombinationsOf(\n+                Flags.FLAG_NOTIF_CHANNEL_CROP_VIBRATION_EFFECTS);\n+    }\n+\n     @Rule\n-    public final SetFlagsRule mSetFlagsRule = new SetFlagsRule();\n+    public final SetFlagsRule mSetFlagsRule;\n \n     private final String CLASS = \"android.app.NotificationChannel\";\n \n@@ -86,6 +102,10 @@ public class NotificationChannelTest {\n     ContentProvider mContentProvider;\n     IContentProvider mIContentProvider;\n \n+    public NotificationChannelTest(FlagsParameterization flags) {\n+        mSetFlagsRule = mSetFlagsClassRule.createSetFlagsRule(flags);\n+    }\n+\n     @Before\n     public void setUp() throws Exception {\n         mContext = mock(Context.class);\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "dd6c8b4b334af950f7c26d7b8be2e052b2667ea6"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-233605527",
            "aliases": [
                "A-233605527",
                "CVE-2024-43765"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-233605527",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "f19514065f9807f579d3cbb45feee96184f36411"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From f19514065f9807f579d3cbb45feee96184f36411 Mon Sep 17 00:00:00 2001\nFrom: Aditya <adityasngh@google.com>\nDate: Sat, 24 Aug 2024 11:21:13 +0000\nSubject: [PATCH] Prevent clickjacking attack in DocsUi.\n\n* Added permission `HIDE_OVERLAY_WINDOWS` in the Manifest.\n* Set the flag to hide overlay windows to true in BaseActivity and\n  ConfirmFragment.\n\nBug: 233605527\nTest: Manually, see http://b/233605527#comment4\nFlag: EXEMPT bugfix\nChange-Id: I511730856be58cad3e13fa50bfac1e1ee2f5fee0\n---\n AndroidManifest.xml                                     | 1 +\n src/com/android/documentsui/BaseActivity.java           | 4 ++++\n src/com/android/documentsui/picker/ConfirmFragment.java | 7 ++++++-\n 3 files changed, 11 insertions(+), 1 deletion(-)\n\ndiff --git a/AndroidManifest.xml b/AndroidManifest.xml\nindex 76802342e..be98d1d08 100644\n--- a/AndroidManifest.xml\n+++ b/AndroidManifest.xml\n@@ -33,6 +33,7 @@\n     <uses-permission android:name=\"android.permission.MODIFY_QUIET_MODE\" />\n     <uses-permission android:name=\"android.permission.QUERY_ALL_PACKAGES\" />\n     <uses-permission android:name=\"android.permission.POST_NOTIFICATIONS\" />\n+    <uses-permission android:name=\"android.permission.HIDE_OVERLAY_WINDOWS\"/>\n \n     <!-- Permissions required for reading and logging compat changes -->\n     <uses-permission android:name=\"android.permission.LOG_COMPAT_CHANGE\"/>\ndiff --git a/src/com/android/documentsui/BaseActivity.java b/src/com/android/documentsui/BaseActivity.java\nindex 3f0ff5834..31c287393 100644\n--- a/src/com/android/documentsui/BaseActivity.java\n+++ b/src/com/android/documentsui/BaseActivity.java\n@@ -172,6 +172,10 @@ public abstract class BaseActivity\n         // Record the time when onCreate is invoked for metric.\n         mStartTime = new Date().getTime();\n \n+        if (SdkLevel.isAtLeastS()) {\n+            getWindow().setHideOverlayWindows(true);\n+        }\n+\n         // ToDo Create tool to check resource version before applyStyle for the theme\n         // If version code is not match, we should reset overlay package to default,\n         // in case Activity continueusly encounter resource not found exception\ndiff --git a/src/com/android/documentsui/picker/ConfirmFragment.java b/src/com/android/documentsui/picker/ConfirmFragment.java\nindex 94015e930..e1af281bc 100644\n--- a/src/com/android/documentsui/picker/ConfirmFragment.java\n+++ b/src/com/android/documentsui/picker/ConfirmFragment.java\n@@ -32,6 +32,7 @@ import com.android.documentsui.BaseActivity;\n import com.android.documentsui.R;\n import com.android.documentsui.base.DocumentInfo;\n import com.android.documentsui.base.Shared;\n+import com.android.modules.utils.build.SdkLevel;\n \n import com.google.android.material.dialog.MaterialAlertDialogBuilder;\n \n@@ -102,7 +103,11 @@ public class ConfirmFragment extends DialogFragment {\n         builder.setNegativeButton(android.R.string.cancel,\n                 (DialogInterface dialog, int id) -> pickResult.increaseActionCount());\n \n-        return builder.create();\n+        Dialog dialog = builder.create();\n+        if (SdkLevel.isAtLeastS()) {\n+            dialog.getWindow().setHideOverlayWindows(true);\n+        }\n+        return dialog;\n     }\n \n     @Override\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "2de5d72a3cd83be5adafd00bfef50850784c21c9",
                            "result": "success",
                            "downstream_patch_content": "commit 2de5d72a3cd83be5adafd00bfef50850784c21c9\nAuthor: Aditya Singh <adityasngh@google.com>\nDate:   Wed Sep 18 03:41:54 2024 +0000\n\n    Prevent clickjacking attack in DocsUi.\n    \n    * Added permission `HIDE_OVERLAY_WINDOWS` in the Manifest.\n    * Set the flag to hide overlay windows to true in BaseActivity and\n      ConfirmFragment.\n    \n    Bug: 233605527\n    Test: Manually, see http://b/233605527#comment4\n    Flag: EXEMPT bugfix\n    Change-Id: I511730856be58cad3e13fa50bfac1e1ee2f5fee0\n    Merged-In: I511730856be58cad3e13fa50bfac1e1ee2f5fee0\n\ndiff --git a/AndroidManifest.xml b/AndroidManifest.xml\nindex 8b86febcf..8ec6dbd8c 100644\n--- a/AndroidManifest.xml\n+++ b/AndroidManifest.xml\n@@ -31,6 +31,7 @@\n     <uses-permission android:name=\"android.permission.INTERACT_ACROSS_USERS\" />\n     <uses-permission android:name=\"android.permission.MODIFY_QUIET_MODE\" />\n     <uses-permission android:name=\"android.permission.QUERY_ALL_PACKAGES\" />\n+    <uses-permission android:name=\"android.permission.HIDE_OVERLAY_WINDOWS\"/>\n \n     <!-- Permissions required for reading and logging compat changes -->\n     <uses-permission android:name=\"android.permission.LOG_COMPAT_CHANGE\"/>\ndiff --git a/src/com/android/documentsui/BaseActivity.java b/src/com/android/documentsui/BaseActivity.java\nindex b4ab5bdf0..8f9d4dd01 100644\n--- a/src/com/android/documentsui/BaseActivity.java\n+++ b/src/com/android/documentsui/BaseActivity.java\n@@ -134,6 +134,10 @@ public abstract class BaseActivity\n         // Record the time when onCreate is invoked for metric.\n         mStartTime = new Date().getTime();\n \n+        if (Build.VERSION.SDK_INT >= 31) {\n+            getWindow().setHideOverlayWindows(true);\n+        }\n+\n         // ToDo Create tool to check resource version before applyStyle for the theme\n         // If version code is not match, we should reset overlay package to default,\n         // in case Activity continueusly encounter resource not found exception\ndiff --git a/src/com/android/documentsui/picker/ConfirmFragment.java b/src/com/android/documentsui/picker/ConfirmFragment.java\nindex 94015e930..ae5fb2b3a 100644\n--- a/src/com/android/documentsui/picker/ConfirmFragment.java\n+++ b/src/com/android/documentsui/picker/ConfirmFragment.java\n@@ -21,6 +21,7 @@ import static com.android.documentsui.base.Shared.getCallingAppName;\n import android.app.Dialog;\n import android.content.DialogInterface;\n import android.net.Uri;\n+import android.os.Build;\n import android.os.Bundle;\n \n import androidx.fragment.app.DialogFragment;\n@@ -102,7 +103,11 @@ public class ConfirmFragment extends DialogFragment {\n         builder.setNegativeButton(android.R.string.cancel,\n                 (DialogInterface dialog, int id) -> pickResult.increaseActionCount());\n \n-        return builder.create();\n+        Dialog dialog = builder.create();\n+        if (Build.VERSION.SDK_INT >= 31) {\n+            dialog.getWindow().setHideOverlayWindows(true);\n+        }\n+        return dialog;\n     }\n \n     @Override\n"
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "14c45fc9056f9841e51533fda4805e8ee5cdce51",
                            "result": "success",
                            "downstream_patch_content": "commit 14c45fc9056f9841e51533fda4805e8ee5cdce51\nAuthor: Aditya Singh <adityasngh@google.com>\nDate:   Mon Sep 9 12:52:31 2024 +0000\n\n    Prevent clickjacking attack in DocsUi.\n    \n    * Added permission `HIDE_OVERLAY_WINDOWS` in the Manifest.\n    * Set the flag to hide overlay windows to true in BaseActivity and\n      ConfirmFragment.\n    \n    Bug: 233605527\n    Test: Manually, see http://b/233605527#comment4\n    Flag: EXEMPT bugfix\n    Change-Id: I511730856be58cad3e13fa50bfac1e1ee2f5fee0\n    Merged-In: I511730856be58cad3e13fa50bfac1e1ee2f5fee0\n\ndiff --git a/AndroidManifest.xml b/AndroidManifest.xml\nindex 8b86febcf..8ec6dbd8c 100644\n--- a/AndroidManifest.xml\n+++ b/AndroidManifest.xml\n@@ -31,6 +31,7 @@\n     <uses-permission android:name=\"android.permission.INTERACT_ACROSS_USERS\" />\n     <uses-permission android:name=\"android.permission.MODIFY_QUIET_MODE\" />\n     <uses-permission android:name=\"android.permission.QUERY_ALL_PACKAGES\" />\n+    <uses-permission android:name=\"android.permission.HIDE_OVERLAY_WINDOWS\"/>\n \n     <!-- Permissions required for reading and logging compat changes -->\n     <uses-permission android:name=\"android.permission.LOG_COMPAT_CHANGE\"/>\ndiff --git a/src/com/android/documentsui/BaseActivity.java b/src/com/android/documentsui/BaseActivity.java\nindex b4ab5bdf0..8f9d4dd01 100644\n--- a/src/com/android/documentsui/BaseActivity.java\n+++ b/src/com/android/documentsui/BaseActivity.java\n@@ -134,6 +134,10 @@ public abstract class BaseActivity\n         // Record the time when onCreate is invoked for metric.\n         mStartTime = new Date().getTime();\n \n+        if (Build.VERSION.SDK_INT >= 31) {\n+            getWindow().setHideOverlayWindows(true);\n+        }\n+\n         // ToDo Create tool to check resource version before applyStyle for the theme\n         // If version code is not match, we should reset overlay package to default,\n         // in case Activity continueusly encounter resource not found exception\ndiff --git a/src/com/android/documentsui/picker/ConfirmFragment.java b/src/com/android/documentsui/picker/ConfirmFragment.java\nindex 94015e930..ae5fb2b3a 100644\n--- a/src/com/android/documentsui/picker/ConfirmFragment.java\n+++ b/src/com/android/documentsui/picker/ConfirmFragment.java\n@@ -21,6 +21,7 @@ import static com.android.documentsui.base.Shared.getCallingAppName;\n import android.app.Dialog;\n import android.content.DialogInterface;\n import android.net.Uri;\n+import android.os.Build;\n import android.os.Bundle;\n \n import androidx.fragment.app.DialogFragment;\n@@ -102,7 +103,11 @@ public class ConfirmFragment extends DialogFragment {\n         builder.setNegativeButton(android.R.string.cancel,\n                 (DialogInterface dialog, int id) -> pickResult.increaseActionCount());\n \n-        return builder.create();\n+        Dialog dialog = builder.create();\n+        if (Build.VERSION.SDK_INT >= 31) {\n+            dialog.getWindow().setHideOverlayWindows(true);\n+        }\n+        return dialog;\n     }\n \n     @Override\n"
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "5178a952e18ee66f1b3c14796708d0d60058a157"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "0f5f4b53ad43b891cc04ef8bd059e28fba1cc44c",
                            "result": "success",
                            "downstream_patch_content": "commit 0f5f4b53ad43b891cc04ef8bd059e28fba1cc44c\nAuthor: Aditya Singh <adityasngh@google.com>\nDate:   Mon Sep 9 13:04:51 2024 +0000\n\n    Prevent clickjacking attack in DocsUi.\n    \n    * Added permission `HIDE_OVERLAY_WINDOWS` in the Manifest.\n    * Set the flag to hide overlay windows to true in BaseActivity and\n      ConfirmFragment.\n    \n    Bug: 233605527\n    Test: Manually, see http://b/233605527#comment4\n    Flag: EXEMPT bugfix\n    Change-Id: I511730856be58cad3e13fa50bfac1e1ee2f5fee0\n    Merged-In: I511730856be58cad3e13fa50bfac1e1ee2f5fee0\n\ndiff --git a/AndroidManifest.xml b/AndroidManifest.xml\nindex e15805e28..9dbbb70c6 100644\n--- a/AndroidManifest.xml\n+++ b/AndroidManifest.xml\n@@ -32,6 +32,7 @@\n     <uses-permission android:name=\"android.permission.MODIFY_QUIET_MODE\" />\n     <uses-permission android:name=\"android.permission.QUERY_ALL_PACKAGES\" />\n     <uses-permission android:name=\"android.permission.POST_NOTIFICATIONS\" />\n+    <uses-permission android:name=\"android.permission.HIDE_OVERLAY_WINDOWS\"/>\n \n     <!-- Permissions required for reading and logging compat changes -->\n     <uses-permission android:name=\"android.permission.LOG_COMPAT_CHANGE\"/>\ndiff --git a/src/com/android/documentsui/BaseActivity.java b/src/com/android/documentsui/BaseActivity.java\nindex 5efb9a93e..eed9ecc00 100644\n--- a/src/com/android/documentsui/BaseActivity.java\n+++ b/src/com/android/documentsui/BaseActivity.java\n@@ -74,6 +74,7 @@ import com.android.documentsui.roots.ProvidersCache;\n import com.android.documentsui.sidebar.RootsFragment;\n import com.android.documentsui.sorting.SortController;\n import com.android.documentsui.sorting.SortModel;\n+import com.android.modules.utils.build.SdkLevel;\n \n import com.google.android.material.appbar.AppBarLayout;\n \n@@ -134,6 +135,10 @@ public abstract class BaseActivity\n         // Record the time when onCreate is invoked for metric.\n         mStartTime = new Date().getTime();\n \n+        if (SdkLevel.isAtLeastS()) {\n+            getWindow().setHideOverlayWindows(true);\n+        }\n+\n         // ToDo Create tool to check resource version before applyStyle for the theme\n         // If version code is not match, we should reset overlay package to default,\n         // in case Activity continueusly encounter resource not found exception\ndiff --git a/src/com/android/documentsui/picker/ConfirmFragment.java b/src/com/android/documentsui/picker/ConfirmFragment.java\nindex 94015e930..e1af281bc 100644\n--- a/src/com/android/documentsui/picker/ConfirmFragment.java\n+++ b/src/com/android/documentsui/picker/ConfirmFragment.java\n@@ -32,6 +32,7 @@ import com.android.documentsui.BaseActivity;\n import com.android.documentsui.R;\n import com.android.documentsui.base.DocumentInfo;\n import com.android.documentsui.base.Shared;\n+import com.android.modules.utils.build.SdkLevel;\n \n import com.google.android.material.dialog.MaterialAlertDialogBuilder;\n \n@@ -102,7 +103,11 @@ public class ConfirmFragment extends DialogFragment {\n         builder.setNegativeButton(android.R.string.cancel,\n                 (DialogInterface dialog, int id) -> pickResult.increaseActionCount());\n \n-        return builder.create();\n+        Dialog dialog = builder.create();\n+        if (SdkLevel.isAtLeastS()) {\n+            dialog.getWindow().setHideOverlayWindows(true);\n+        }\n+        return dialog;\n     }\n \n     @Override\n"
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "0f5f4b53ad43b891cc04ef8bd059e28fba1cc44c",
                            "result": "success",
                            "downstream_patch_content": "commit 0f5f4b53ad43b891cc04ef8bd059e28fba1cc44c\nAuthor: Aditya Singh <adityasngh@google.com>\nDate:   Mon Sep 9 13:04:51 2024 +0000\n\n    Prevent clickjacking attack in DocsUi.\n    \n    * Added permission `HIDE_OVERLAY_WINDOWS` in the Manifest.\n    * Set the flag to hide overlay windows to true in BaseActivity and\n      ConfirmFragment.\n    \n    Bug: 233605527\n    Test: Manually, see http://b/233605527#comment4\n    Flag: EXEMPT bugfix\n    Change-Id: I511730856be58cad3e13fa50bfac1e1ee2f5fee0\n    Merged-In: I511730856be58cad3e13fa50bfac1e1ee2f5fee0\n\ndiff --git a/AndroidManifest.xml b/AndroidManifest.xml\nindex e15805e28..9dbbb70c6 100644\n--- a/AndroidManifest.xml\n+++ b/AndroidManifest.xml\n@@ -32,6 +32,7 @@\n     <uses-permission android:name=\"android.permission.MODIFY_QUIET_MODE\" />\n     <uses-permission android:name=\"android.permission.QUERY_ALL_PACKAGES\" />\n     <uses-permission android:name=\"android.permission.POST_NOTIFICATIONS\" />\n+    <uses-permission android:name=\"android.permission.HIDE_OVERLAY_WINDOWS\"/>\n \n     <!-- Permissions required for reading and logging compat changes -->\n     <uses-permission android:name=\"android.permission.LOG_COMPAT_CHANGE\"/>\ndiff --git a/src/com/android/documentsui/BaseActivity.java b/src/com/android/documentsui/BaseActivity.java\nindex 5efb9a93e..eed9ecc00 100644\n--- a/src/com/android/documentsui/BaseActivity.java\n+++ b/src/com/android/documentsui/BaseActivity.java\n@@ -74,6 +74,7 @@ import com.android.documentsui.roots.ProvidersCache;\n import com.android.documentsui.sidebar.RootsFragment;\n import com.android.documentsui.sorting.SortController;\n import com.android.documentsui.sorting.SortModel;\n+import com.android.modules.utils.build.SdkLevel;\n \n import com.google.android.material.appbar.AppBarLayout;\n \n@@ -134,6 +135,10 @@ public abstract class BaseActivity\n         // Record the time when onCreate is invoked for metric.\n         mStartTime = new Date().getTime();\n \n+        if (SdkLevel.isAtLeastS()) {\n+            getWindow().setHideOverlayWindows(true);\n+        }\n+\n         // ToDo Create tool to check resource version before applyStyle for the theme\n         // If version code is not match, we should reset overlay package to default,\n         // in case Activity continueusly encounter resource not found exception\ndiff --git a/src/com/android/documentsui/picker/ConfirmFragment.java b/src/com/android/documentsui/picker/ConfirmFragment.java\nindex 94015e930..e1af281bc 100644\n--- a/src/com/android/documentsui/picker/ConfirmFragment.java\n+++ b/src/com/android/documentsui/picker/ConfirmFragment.java\n@@ -32,6 +32,7 @@ import com.android.documentsui.BaseActivity;\n import com.android.documentsui.R;\n import com.android.documentsui.base.DocumentInfo;\n import com.android.documentsui.base.Shared;\n+import com.android.modules.utils.build.SdkLevel;\n \n import com.google.android.material.dialog.MaterialAlertDialogBuilder;\n \n@@ -102,7 +103,11 @@ public class ConfirmFragment extends DialogFragment {\n         builder.setNegativeButton(android.R.string.cancel,\n                 (DialogInterface dialog, int id) -> pickResult.increaseActionCount());\n \n-        return builder.create();\n+        Dialog dialog = builder.create();\n+        if (SdkLevel.isAtLeastS()) {\n+            dialog.getWindow().setHideOverlayWindows(true);\n+        }\n+        return dialog;\n     }\n \n     @Override\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-375159480",
            "aliases": [
                "A-375159480",
                "CVE-2025-22404"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375159480",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "00555617ddbbc1a19089104c084d14f465c971ce"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 00555617ddbbc1a19089104c084d14f465c971ce Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Sat, 2 Nov 2024 02:29:10 +0000\nSubject: [PATCH] Fix more memory-unsafe logging\n\nIn various locations around the stack, log statements use structures that\nmay, in exceptional cases, have been freed by preceding calls.  This can\nlead to use after free and potentially to security vulnerabilities.\n\nUse local variables instead, or store the length before the call if no\nlocal variable is already convenient.\n\nBug: 375404242\nBug: 375398779\nBug: 375397720\nBug: 375397164\nBug: 375397370\nBug: 375396810\nBug: 375159652\nBug: 375160214\nBug: 375159480\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: Ia50e074de751661a0e617bfffa17871497b8d1ea\n---\n system/stack/avct/avct_lcb_act.cc    | 5 ++++-\n system/stack/bnep/bnep_main.cc       | 4 +++-\n system/stack/bnep/bnep_utils.cc      | 3 ++-\n system/stack/hid/hidd_conn.cc        | 4 ++--\n system/stack/rfcomm/rfc_ts_frames.cc | 3 ++-\n system/stack/rfcomm/rfc_utils.cc     | 3 ++-\n system/stack/sdp/sdp_discovery.cc    | 2 +-\n system/stack/sdp/sdp_server.cc       | 4 ++--\n 8 files changed, 18 insertions(+), 10 deletions(-)\n\ndiff --git a/system/stack/avct/avct_lcb_act.cc b/system/stack/avct/avct_lcb_act.cc\nindex 986bce7d34..32da9d865b 100644\n--- a/system/stack/avct/avct_lcb_act.cc\n+++ b/system/stack/avct/avct_lcb_act.cc\n@@ -727,10 +727,13 @@ void avct_lcb_msg_ind(tAVCT_LCB* p_lcb, tAVCT_LCB_EVT* p_data) {\n     p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n     AVCT_BUILD_HDR(p, label, AVCT_PKT_TYPE_SINGLE, AVCT_REJ);\n     UINT16_TO_BE_STREAM(p, pid);\n+\n+    uint16_t len = p_buf->len;\n+\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_lcb->ch_lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} lcid:0x{:04x} len:{}\", p_lcb->peer_addr,\n-                p_lcb->ch_lcid, p_buf->len);\n+                p_lcb->ch_lcid, len);\n     }\n   }\n }\ndiff --git a/system/stack/bnep/bnep_main.cc b/system/stack/bnep/bnep_main.cc\nindex e0e3c4540c..adf3c8666e 100644\n--- a/system/stack/bnep/bnep_main.cc\n+++ b/system/stack/bnep/bnep_main.cc\n@@ -295,10 +295,12 @@ static void bnep_congestion_ind(uint16_t l2cap_cid, bool is_congested) {\n         break;\n       }\n \n+      uint16_t len = p_buf->len;\n+\n       if (stack::l2cap::get_interface().L2CA_DataWrite(l2cap_cid, p_buf) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n         log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda, l2cap_cid,\n-                  p_buf->len);\n+                  len);\n       }\n     }\n   }\ndiff --git a/system/stack/bnep/bnep_utils.cc b/system/stack/bnep/bnep_utils.cc\nindex 252facf668..4092d9afee 100644\n--- a/system/stack/bnep/bnep_utils.cc\n+++ b/system/stack/bnep/bnep_utils.cc\n@@ -411,10 +411,11 @@ void bnepu_check_send_packet(tBNEP_CONN* p_bcb, BT_HDR* p_buf) {\n       fixed_queue_enqueue(p_bcb->xmit_q, p_buf);\n     }\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_bcb->l2cap_cid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda,\n-                p_bcb->l2cap_cid, p_buf->len);\n+                p_bcb->l2cap_cid, len);\n     }\n   }\n }\ndiff --git a/system/stack/hid/hidd_conn.cc b/system/stack/hid/hidd_conn.cc\nindex c64a7b9104..695e5d6c84 100644\n--- a/system/stack/hid/hidd_conn.cc\n+++ b/system/stack/hid/hidd_conn.cc\n@@ -88,10 +88,10 @@ static void hidd_check_config_done() {\n \n     // send outstanding data on intr\n     if (hd_cb.pending_data) {\n+      uint16_t len = hd_cb.pending_data->len;\n       if (stack::l2cap::get_interface().L2CA_DataWrite(p_hcon->intr_cid, hd_cb.pending_data) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n-        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid,\n-                  hd_cb.pending_data->len);\n+        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid, len);\n       }\n       hd_cb.pending_data = NULL;\n     }\ndiff --git a/system/stack/rfcomm/rfc_ts_frames.cc b/system/stack/rfcomm/rfc_ts_frames.cc\nindex ea57abf6dc..e93cfed9b8 100644\n--- a/system/stack/rfcomm/rfc_ts_frames.cc\n+++ b/system/stack/rfcomm/rfc_ts_frames.cc\n@@ -201,10 +201,11 @@ void rfc_send_buf_uih(tRFC_MCB* p_mcb, uint8_t dlci, BT_HDR* p_buf) {\n   if (dlci == RFCOMM_MX_DLCI) {\n     rfc_check_send_cmd(p_mcb, p_buf);\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p_buf->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/rfcomm/rfc_utils.cc b/system/stack/rfcomm/rfc_utils.cc\nindex 23420892cb..0c5074db76 100644\n--- a/system/stack/rfcomm/rfc_utils.cc\n+++ b/system/stack/rfcomm/rfc_utils.cc\n@@ -428,9 +428,10 @@ void rfc_check_send_cmd(tRFC_MCB* p_mcb, BT_HDR* p_buf) {\n     if (p == NULL) {\n       break;\n     }\n+    uint16_t len = p->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p) != tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/sdp/sdp_discovery.cc b/system/stack/sdp/sdp_discovery.cc\nindex 4fa484e14a..6aba1993af 100644\n--- a/system/stack/sdp/sdp_discovery.cc\n+++ b/system/stack/sdp/sdp_discovery.cc\n@@ -877,7 +877,7 @@ static void process_service_attr_rsp(tCONN_CB* p_ccb, uint8_t* p_reply, uint8_t*\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_msg) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-                p_ccb->connection_id, p_msg->len);\n+                p_ccb->connection_id, p - p_start);\n     }\n \n     /* Start inactivity timer */\ndiff --git a/system/stack/sdp/sdp_server.cc b/system/stack/sdp/sdp_server.cc\nindex abd70aedb1..0f379708e9 100644\n--- a/system/stack/sdp/sdp_server.cc\n+++ b/system/stack/sdp/sdp_server.cc\n@@ -300,7 +300,7 @@ static void process_service_search(tCONN_CB* p_ccb, uint16_t trans_num, uint16_t\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n@@ -564,7 +564,7 @@ static void process_service_attr_req(tCONN_CB* p_ccb, uint16_t trans_num, uint16\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "43cfd234de9ba9557118b0014513269cc1aeefda"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-382064697",
            "aliases": [
                "A-382064697",
                "CVE-2025-22442"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-382064697",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "73b54cdf4b70831c4f952d7556274609cb46214e"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 73b54cdf4b70831c4f952d7556274609cb46214e Mon Sep 17 00:00:00 2001\nFrom: Sinduran Sivarajan <sinduran@google.com>\nDate: Fri, 31 Jan 2025 05:23:56 -0800\nSubject: [PATCH] Disable \"Developer options\" by default for managed profiles.\n\nBug: 382064697\nTest: go/work-profile-creation-developer-access\nFlag: EXEMPT bugfix\nChange-Id: Ibe6b721f2552d9e72aba0582a2eed4ba87178c7c\n---\n .../server/pm/UserRestrictionsUtils.java      |  3 +-\n .../DevicePolicyManagerService.java           | 34 +++++++++++++------\n 2 files changed, 25 insertions(+), 12 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/pm/UserRestrictionsUtils.java b/services/core/java/com/android/server/pm/UserRestrictionsUtils.java\nindex 2bc6d53147fb..a1082481abb8 100644\n--- a/services/core/java/com/android/server/pm/UserRestrictionsUtils.java\n+++ b/services/core/java/com/android/server/pm/UserRestrictionsUtils.java\n@@ -309,7 +309,8 @@ public class UserRestrictionsUtils {\n      * in settings. So it is handled separately.\n      */\n     private static final Set<String> DEFAULT_ENABLED_FOR_MANAGED_PROFILES = Sets.newArraySet(\n-            UserManager.DISALLOW_BLUETOOTH_SHARING\n+            UserManager.DISALLOW_BLUETOOTH_SHARING,\n+            UserManager.DISALLOW_DEBUGGING_FEATURES\n     );\n \n     /**\ndiff --git a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\nindex 582cd4ed8003..e11c31c88c87 100644\n--- a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n+++ b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n@@ -2723,16 +2723,16 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         }\n     }\n \n-    /**\n-     * Apply default restrictions that haven't been applied to a given admin yet.\n-     */\n+    /** Apply default restrictions that haven't been applied to a given admin yet. */\n     private void maybeSetDefaultRestrictionsForAdminLocked(int userId, ActiveAdmin admin) {\n-        Set<String> defaultRestrictions =\n-                UserRestrictionsUtils.getDefaultEnabledForManagedProfiles();\n-        if (defaultRestrictions.equals(admin.defaultEnabledRestrictionsAlreadySet)) {\n+        Set<String> newDefaultRestrictions = new HashSet(\n+            UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n+        newDefaultRestrictions.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n+        if (newDefaultRestrictions.isEmpty()) {\n             return; // The same set of default restrictions has been already applied.\n         }\n-        for (String restriction : defaultRestrictions) {\n+\n+        for (String restriction : newDefaultRestrictions) {\n             mDevicePolicyEngine.setLocalPolicy(\n                     PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction),\n                     EnforcingAdmin.createEnterpriseEnforcingAdmin(\n@@ -2740,10 +2740,9 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                             admin.getUserHandle().getIdentifier()),\n                     new BooleanPolicyValue(true),\n                     userId);\n+            admin.defaultEnabledRestrictionsAlreadySet.add(restriction);\n+            Slogf.i(LOG_TAG, \"Enabled the following restriction by default: \" + restriction);\n         }\n-        admin.defaultEnabledRestrictionsAlreadySet.addAll(defaultRestrictions);\n-        Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \"\n-                + defaultRestrictions);\n     }\n \n     private void maybeStartSecurityLogMonitorOnActivityManagerReady() {\n@@ -10282,7 +10281,8 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                 return false;\n             }\n \n-            if (isAdb(caller)) {\n+            boolean isAdb = isAdb(caller);\n+            if (isAdb) {\n                 // Log profile owner provisioning was started using adb.\n                 MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_PROFILE_OWNER);\n                 DevicePolicyEventLogger\n@@ -10305,6 +10305,18 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                     ensureUnknownSourcesRestrictionForProfileOwnerLocked(userHandle, admin,\n                             true /* newOwner */);\n                 }\n+                if(isAdb) {\n+                    // DISALLOW_DEBUGGING_FEATURES is being added to newly-created\n+                    // work profile by default due to b/382064697 . This would have\n+                    //  impacted certain CTS test flows when they interact with the\n+                    // work profile via ADB (for example installing an app into the\n+                    // work profile). Remove DISALLOW_DEBUGGING_FEATURES here to\n+                    // reduce the potential impact.\n+                    setLocalUserRestrictionInternal(\n+                        EnforcingAdmin.createEnterpriseEnforcingAdmin(who, userHandle),\n+                        UserManager.DISALLOW_DEBUGGING_FEATURES, false, userHandle);\n+                }\n+\n                 sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                         userHandle);\n             });\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "a44611648b44ceee8e2337dfba92398475c72602"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "3298a1c9eb899d02e532f5dcf88904640a626dcd",
                            "result": "failure",
                            "downstream_patch_content": "commit 3298a1c9eb899d02e532f5dcf88904640a626dcd\nAuthor: Sinduran Sivarajan <sinduran@google.com>\nDate:   Tue Feb 4 01:59:53 2025 -0800\n\n    Disable \"Developer options\" by default for managed profiles.\n    \n    Bug: 382064697\n    Test: go/work-profile-creation-developer-access\n    Flag: EXEMPT bugfix\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:73b54cdf4b70831c4f952d7556274609cb46214e)\n    Merged-In: Ibe6b721f2552d9e72aba0582a2eed4ba87178c7c\n    Change-Id: Ibe6b721f2552d9e72aba0582a2eed4ba87178c7c\n\ndiff --git a/services/core/java/com/android/server/pm/UserRestrictionsUtils.java b/services/core/java/com/android/server/pm/UserRestrictionsUtils.java\nindex 016c1cb7bdf0..13b6d9a46e2e 100644\n--- a/services/core/java/com/android/server/pm/UserRestrictionsUtils.java\n+++ b/services/core/java/com/android/server/pm/UserRestrictionsUtils.java\n@@ -273,7 +273,8 @@ public class UserRestrictionsUtils {\n      * in settings. So it is handled separately.\n      */\n     private static final Set<String> DEFAULT_ENABLED_FOR_MANAGED_PROFILES = Sets.newArraySet(\n-            UserManager.DISALLOW_BLUETOOTH_SHARING\n+            UserManager.DISALLOW_BLUETOOTH_SHARING,\n+            UserManager.DISALLOW_DEBUGGING_FEATURES\n     );\n \n     /**\ndiff --git a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\nindex d87683073844..38efe0c59571 100644\n--- a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n+++ b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n@@ -8868,7 +8868,8 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n                 return false;\n             }\n \n-            if (isAdb(caller)) {\n+            boolean isAdb = isAdb(caller);\n+            if (isAdb) {\n                 // Log profile owner provisioning was started using adb.\n                 MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_PROFILE_OWNER);\n                 DevicePolicyEventLogger\n@@ -8891,6 +8892,17 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n                             UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n                     ensureUnknownSourcesRestrictionForProfileOwnerLocked(userHandle, admin,\n                             true /* newOwner */);\n+                    if (isAdb) {\n+                        // DISALLOW_DEBUGGING_FEATURES is being added to newly-created\n+                        // work profile by default due to b/382064697 . This would have\n+                        //  impacted certain CTS test flows when they interact with the\n+                        // work profile via ADB (for example installing an app into the\n+                        // work profile). Remove DISALLOW_DEBUGGING_FEATURES here to\n+                        // reduce the potential impact.\n+                        admin.ensureUserRestrictions().putBoolean(\n+                            UserManager.DISALLOW_DEBUGGING_FEATURES, false);\n+                        saveUserRestrictionsLocked(userHandle);\n+                    }\n                 }\n                 sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                         userHandle);\ndiff --git a/services/tests/servicestests/src/com/android/server/devicepolicy/DevicePolicyManagerServiceMigrationTest.java b/services/tests/servicestests/src/com/android/server/devicepolicy/DevicePolicyManagerServiceMigrationTest.java\nindex 673b696a2f99..75e2239720e9 100644\n--- a/services/tests/servicestests/src/com/android/server/devicepolicy/DevicePolicyManagerServiceMigrationTest.java\n+++ b/services/tests/servicestests/src/com/android/server/devicepolicy/DevicePolicyManagerServiceMigrationTest.java\n@@ -131,6 +131,7 @@ public class DevicePolicyManagerServiceMigrationTest extends DpmTestBase {\n         // Check that default restrictions were applied.\n         DpmTestUtils.assertRestrictions(\n                 DpmTestUtils.newRestrictions(\n+                        UserManager.DISALLOW_DEBUGGING_FEATURES,\n                         UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES,\n                         UserManager.DISALLOW_BLUETOOTH_SHARING\n                 ),\n@@ -138,8 +139,9 @@ public class DevicePolicyManagerServiceMigrationTest extends DpmTestBase {\n \n         final Set<String> alreadySet =\n                 dpms.getProfileOwnerAdminLocked(10).defaultEnabledRestrictionsAlreadySet;\n-        assertThat(alreadySet).hasSize(1);\n+        assertThat(alreadySet).hasSize(2);\n         assertThat(alreadySet.contains(UserManager.DISALLOW_BLUETOOTH_SHARING)).isTrue();\n+        assertThat(alreadySet.contains(UserManager.DISALLOW_DEBUGGING_FEATURES)).isTrue();\n     }\n \n     @SmallTest\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n    /**\n     * Apply default restrictions that haven't been applied to a given admin yet.\n     */\n    private void maybeSetDefaultRestrictionsForAdminLocked(\n            int userId, ActiveAdmin admin, Set<String> defaultRestrictions) {\n        if (defaultRestrictions.equals(admin.defaultEnabledRestrictionsAlreadySet)) {\n=======\n    /** Apply default restrictions that haven't been applied to a given admin yet. */\n    private void maybeSetDefaultRestrictionsForAdminLocked(int userId, ActiveAdmin admin) {\n        Set<String> newDefaultRestrictions = new HashSet(\n            UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n        newDefaultRestrictions.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n        if (newDefaultRestrictions.isEmpty()) {\n>>>>>>> UPSTREAM PATCH (commit 73b54cdf4b70831c4f952d7556274609cb46214e)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n\n        for (String restriction : newDefaultRestrictions) {\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction),\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n>>>>>>> UPSTREAM PATCH (commit 73b54cdf4b70831c4f952d7556274609cb46214e)"
                                        },
                                        {
                                            "hunk_number": 3,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n            mInjector.systemPropertiesSet(PROPERTY_ORGANIZATION_OWNED, value);\n        } else if (!value.equals(currentVal)) {\n            Slogf.w(LOG_TAG, \"Cannot change existing ro.organization_owned to \" + value);\n=======\n                            admin.getUserHandle().getIdentifier()),\n                    new BooleanPolicyValue(true),\n                    userId);\n            admin.defaultEnabledRestrictionsAlreadySet.add(restriction);\n            Slogf.i(LOG_TAG, \"Enabled the following restriction by default: \" + restriction);\n>>>>>>> UPSTREAM PATCH (commit 73b54cdf4b70831c4f952d7556274609cb46214e)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n+++ services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n@@ -2723,16 +2723,16 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         }\n     }\n \n-    /**\n-     * Apply default restrictions that haven't been applied to a given admin yet.\n-     */\n+    /** Apply default restrictions that haven't been applied to a given admin yet. */\n     private void maybeSetDefaultRestrictionsForAdminLocked(int userId, ActiveAdmin admin) {\n-        Set<String> defaultRestrictions =\n-                UserRestrictionsUtils.getDefaultEnabledForManagedProfiles();\n-        if (defaultRestrictions.equals(admin.defaultEnabledRestrictionsAlreadySet)) {\n+        Set<String> newDefaultRestrictions = new HashSet(\n+            UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n+        newDefaultRestrictions.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n+        if (newDefaultRestrictions.isEmpty()) {\n             return; // The same set of default restrictions has been already applied.\n         }\n-        for (String restriction : defaultRestrictions) {\n+\n+        for (String restriction : newDefaultRestrictions) {\n             mDevicePolicyEngine.setLocalPolicy(\n                     PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction),\n                     EnforcingAdmin.createEnterpriseEnforcingAdmin(\n@@ -2740,10 +2740,9 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                             admin.getUserHandle().getIdentifier()),\n                     new BooleanPolicyValue(true),\n                     userId);\n+            admin.defaultEnabledRestrictionsAlreadySet.add(restriction);\n+            Slogf.i(LOG_TAG, \"Enabled the following restriction by default: \" + restriction);\n         }\n-        admin.defaultEnabledRestrictionsAlreadySet.addAll(defaultRestrictions);\n-        Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \"\n-                + defaultRestrictions);\n     }\n \n     private void maybeStartSecurityLogMonitorOnActivityManagerReady() {\n```",
                                    "patch_apply_output": "patching file services/core/java/com/android/server/pm/UserRestrictionsUtils.java\nHunk #1 succeeded at 273 (offset -36 lines).\npatching file services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\nHunk #1 FAILED at 2723.\nHunk #2 FAILED at 2740.\nHunk #3 succeeded at 8865 (offset -1417 lines).\nHunk #4 succeeded at 8890 (offset -1416 lines).\n2 out of 4 hunks FAILED -- saving rejects to file services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java.rej",
                                    "inline_merge_output": "patching file services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\nHunk #1 NOT MERGED at 2313-2327,2330-2337.\nHunk #2 NOT MERGED at 2374-2384, already applied at 2386."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "3461e84908b46b6fe82ac391d43a43f23c0b1d3e",
                            "result": "failure",
                            "downstream_patch_content": "commit 3461e84908b46b6fe82ac391d43a43f23c0b1d3e\nAuthor: Sinduran Sivarajan <sinduran@google.com>\nDate:   Mon Feb 3 07:11:37 2025 -0800\n\n    Disable \"Developer options\" by default for managed profiles.\n    \n    Bug: 382064697\n    Test: go/work-profile-creation-developer-access\n    Flag: EXEMPT bugfix\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:73b54cdf4b70831c4f952d7556274609cb46214e)\n    Merged-In: Ibe6b721f2552d9e72aba0582a2eed4ba87178c7c\n    Change-Id: Ibe6b721f2552d9e72aba0582a2eed4ba87178c7c\n\ndiff --git a/services/core/java/com/android/server/pm/UserRestrictionsUtils.java b/services/core/java/com/android/server/pm/UserRestrictionsUtils.java\nindex 8815834f6b5c..0b3f6fd87013 100644\n--- a/services/core/java/com/android/server/pm/UserRestrictionsUtils.java\n+++ b/services/core/java/com/android/server/pm/UserRestrictionsUtils.java\n@@ -282,7 +282,8 @@ public class UserRestrictionsUtils {\n      * in settings. So it is handled separately.\n      */\n     private static final Set<String> DEFAULT_ENABLED_FOR_MANAGED_PROFILES = Sets.newArraySet(\n-            UserManager.DISALLOW_BLUETOOTH_SHARING\n+            UserManager.DISALLOW_BLUETOOTH_SHARING,\n+            UserManager.DISALLOW_DEBUGGING_FEATURES\n     );\n \n     /**\ndiff --git a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\nindex 1549677fdbb2..59ca6151639b 100644\n--- a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n+++ b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n@@ -2663,13 +2663,14 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n      * Apply default restrictions that haven't been applied to a given admin yet.\n      */\n     private void maybeSetDefaultRestrictionsForAdminLocked(int userId, ActiveAdmin admin) {\n-        Set<String> defaultRestrictions =\n-                UserRestrictionsUtils.getDefaultEnabledForManagedProfiles();\n-        if (defaultRestrictions.equals(admin.defaultEnabledRestrictionsAlreadySet)) {\n+        final Set<String> restrictionsToSet =\n+            new ArraySet<>(UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n+        restrictionsToSet.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n+        if (restrictionsToSet.isEmpty()) {\n             return; // The same set of default restrictions has been already applied.\n         }\n         if (isPolicyEngineForFinanceFlagEnabled()) {\n-            for (String restriction : defaultRestrictions) {\n+            for (String restriction : restrictionsToSet) {\n                 mDevicePolicyEngine.setLocalPolicy(\n                         PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction),\n                         EnforcingAdmin.createEnterpriseEnforcingAdmin(\n@@ -2678,9 +2679,9 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                         new BooleanPolicyValue(true),\n                         userId);\n             }\n-            admin.defaultEnabledRestrictionsAlreadySet.addAll(defaultRestrictions);\n+            admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n             Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" +\n-                    defaultRestrictions);\n+                    restrictionsToSet);\n             return;\n         }\n \n@@ -2688,21 +2689,16 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n \n         if (VERBOSE_LOG) {\n             Slogf.d(LOG_TAG, \"Default enabled restrictions: \"\n-                    + defaultRestrictions\n+                    + restrictionsToSet\n                     + \". Restrictions already enabled: \"\n                     + admin.defaultEnabledRestrictionsAlreadySet);\n         }\n-\n-        final Set<String> restrictionsToSet = new ArraySet<>(defaultRestrictions);\n-        restrictionsToSet.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n-        if (!restrictionsToSet.isEmpty()) {\n-            for (final String restriction : restrictionsToSet) {\n-                admin.ensureUserRestrictions().putBoolean(restriction, true);\n-            }\n-            admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n-            Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" + restrictionsToSet);\n-            saveUserRestrictionsLocked(userId);\n+        for (final String restriction : restrictionsToSet) {\n+            admin.ensureUserRestrictions().putBoolean(restriction, true);\n         }\n+        admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n+        Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" + restrictionsToSet);\n+        saveUserRestrictionsLocked(userId);\n     }\n \n     private void setDeviceOwnershipSystemPropertyLocked() {\n@@ -10192,7 +10188,8 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                 return false;\n             }\n \n-            if (isAdb(caller)) {\n+            boolean isAdb = isAdb(caller);\n+            if (isAdb) {\n                 // Log profile owner provisioning was started using adb.\n                 MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_PROFILE_OWNER);\n                 DevicePolicyEventLogger\n@@ -10214,7 +10211,19 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                     maybeSetDefaultRestrictionsForAdminLocked(userHandle, admin);\n                     ensureUnknownSourcesRestrictionForProfileOwnerLocked(userHandle, admin,\n                             true /* newOwner */);\n+                    if (isAdb) {\n+                        // DISALLOW_DEBUGGING_FEATURES is being added to newly-created\n+                        // work profile by default due to b/382064697 . This would have\n+                        //  impacted certain CTS test flows when they interact with the\n+                        // work profile via ADB (for example installing an app into the\n+                        // work profile). Remove DISALLOW_DEBUGGING_FEATURES here to\n+                        // reduce the potential impact.\n+                        setLocalUserRestrictionInternal(\n+                            EnforcingAdmin.createEnterpriseEnforcingAdmin(who, userHandle),\n+                            UserManager.DISALLOW_DEBUGGING_FEATURES, false, userHandle);\n+                    }\n                 }\n+\n                 sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                         userHandle);\n             });\n@@ -11131,7 +11140,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         if (mOwners.hasDeviceOwner()) {\n             return false;\n         }\n-        \n+\n         final ComponentName profileOwner = getProfileOwnerAsUser(userId);\n         if (profileOwner == null) {\n             return false;\n@@ -11140,7 +11149,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         if (isManagedProfile(userId)) {\n             return false;\n         }\n-        \n+\n         return true;\n     }\n     private void enforceCanQueryLockTaskLocked(ComponentName who, String callerPackageName) {\n@@ -24460,7 +24469,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n             }\n         });\n     }\n-    \n+\n     private void migrateUserControlDisabledPackagesLocked() {\n         Binder.withCleanCallingIdentity(() -> {\n             List<UserInfo> users = mUserManager.getUsers();\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            for (String restriction : defaultRestrictions) {\n=======\n\n        for (String restriction : newDefaultRestrictions) {\n>>>>>>> UPSTREAM PATCH (commit 73b54cdf4b70831c4f952d7556274609cb46214e)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n            admin.defaultEnabledRestrictionsAlreadySet.addAll(defaultRestrictions);\n=======\n    }\n\n    private void maybeStartSecurityLogMonitorOnActivityManagerReady() {\n>>>>>>> UPSTREAM PATCH (commit 73b54cdf4b70831c4f952d7556274609cb46214e)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n+++ services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n@@ -2723,16 +2723,16 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         }\n     }\n \n-    /**\n-     * Apply default restrictions that haven't been applied to a given admin yet.\n-     */\n+    /** Apply default restrictions that haven't been applied to a given admin yet. */\n     private void maybeSetDefaultRestrictionsForAdminLocked(int userId, ActiveAdmin admin) {\n-        Set<String> defaultRestrictions =\n-                UserRestrictionsUtils.getDefaultEnabledForManagedProfiles();\n-        if (defaultRestrictions.equals(admin.defaultEnabledRestrictionsAlreadySet)) {\n+        Set<String> newDefaultRestrictions = new HashSet(\n+            UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n+        newDefaultRestrictions.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n+        if (newDefaultRestrictions.isEmpty()) {\n             return; // The same set of default restrictions has been already applied.\n         }\n-        for (String restriction : defaultRestrictions) {\n+\n+        for (String restriction : newDefaultRestrictions) {\n             mDevicePolicyEngine.setLocalPolicy(\n                     PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction),\n                     EnforcingAdmin.createEnterpriseEnforcingAdmin(\n@@ -2740,10 +2740,9 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                             admin.getUserHandle().getIdentifier()),\n                     new BooleanPolicyValue(true),\n                     userId);\n+            admin.defaultEnabledRestrictionsAlreadySet.add(restriction);\n+            Slogf.i(LOG_TAG, \"Enabled the following restriction by default: \" + restriction);\n         }\n-        admin.defaultEnabledRestrictionsAlreadySet.addAll(defaultRestrictions);\n-        Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \"\n-                + defaultRestrictions);\n     }\n \n     private void maybeStartSecurityLogMonitorOnActivityManagerReady() {\n```",
                                    "patch_apply_output": "patching file services/core/java/com/android/server/pm/UserRestrictionsUtils.java\nHunk #1 succeeded at 282 (offset -27 lines).\npatching file services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\nHunk #1 FAILED at 2723.\nHunk #2 FAILED at 2740.\nHunk #3 succeeded at 10190 (offset -92 lines).\nHunk #4 succeeded at 10214 (offset -92 lines).\n2 out of 4 hunks FAILED -- saving rejects to file services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java.rej",
                                    "inline_merge_output": "patching file services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\nHunk #1 merged at 2662,2667-2670, NOT MERGED at 2676-2682.\nHunk #2 merged at 2690-2691, NOT MERGED at 2693-2699."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-375397370",
            "aliases": [
                "A-375397370",
                "CVE-2025-22409"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375397370",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "00555617ddbbc1a19089104c084d14f465c971ce"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 00555617ddbbc1a19089104c084d14f465c971ce Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Sat, 2 Nov 2024 02:29:10 +0000\nSubject: [PATCH] Fix more memory-unsafe logging\n\nIn various locations around the stack, log statements use structures that\nmay, in exceptional cases, have been freed by preceding calls.  This can\nlead to use after free and potentially to security vulnerabilities.\n\nUse local variables instead, or store the length before the call if no\nlocal variable is already convenient.\n\nBug: 375404242\nBug: 375398779\nBug: 375397720\nBug: 375397164\nBug: 375397370\nBug: 375396810\nBug: 375159652\nBug: 375160214\nBug: 375159480\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: Ia50e074de751661a0e617bfffa17871497b8d1ea\n---\n system/stack/avct/avct_lcb_act.cc    | 5 ++++-\n system/stack/bnep/bnep_main.cc       | 4 +++-\n system/stack/bnep/bnep_utils.cc      | 3 ++-\n system/stack/hid/hidd_conn.cc        | 4 ++--\n system/stack/rfcomm/rfc_ts_frames.cc | 3 ++-\n system/stack/rfcomm/rfc_utils.cc     | 3 ++-\n system/stack/sdp/sdp_discovery.cc    | 2 +-\n system/stack/sdp/sdp_server.cc       | 4 ++--\n 8 files changed, 18 insertions(+), 10 deletions(-)\n\ndiff --git a/system/stack/avct/avct_lcb_act.cc b/system/stack/avct/avct_lcb_act.cc\nindex 986bce7d34..32da9d865b 100644\n--- a/system/stack/avct/avct_lcb_act.cc\n+++ b/system/stack/avct/avct_lcb_act.cc\n@@ -727,10 +727,13 @@ void avct_lcb_msg_ind(tAVCT_LCB* p_lcb, tAVCT_LCB_EVT* p_data) {\n     p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n     AVCT_BUILD_HDR(p, label, AVCT_PKT_TYPE_SINGLE, AVCT_REJ);\n     UINT16_TO_BE_STREAM(p, pid);\n+\n+    uint16_t len = p_buf->len;\n+\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_lcb->ch_lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} lcid:0x{:04x} len:{}\", p_lcb->peer_addr,\n-                p_lcb->ch_lcid, p_buf->len);\n+                p_lcb->ch_lcid, len);\n     }\n   }\n }\ndiff --git a/system/stack/bnep/bnep_main.cc b/system/stack/bnep/bnep_main.cc\nindex e0e3c4540c..adf3c8666e 100644\n--- a/system/stack/bnep/bnep_main.cc\n+++ b/system/stack/bnep/bnep_main.cc\n@@ -295,10 +295,12 @@ static void bnep_congestion_ind(uint16_t l2cap_cid, bool is_congested) {\n         break;\n       }\n \n+      uint16_t len = p_buf->len;\n+\n       if (stack::l2cap::get_interface().L2CA_DataWrite(l2cap_cid, p_buf) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n         log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda, l2cap_cid,\n-                  p_buf->len);\n+                  len);\n       }\n     }\n   }\ndiff --git a/system/stack/bnep/bnep_utils.cc b/system/stack/bnep/bnep_utils.cc\nindex 252facf668..4092d9afee 100644\n--- a/system/stack/bnep/bnep_utils.cc\n+++ b/system/stack/bnep/bnep_utils.cc\n@@ -411,10 +411,11 @@ void bnepu_check_send_packet(tBNEP_CONN* p_bcb, BT_HDR* p_buf) {\n       fixed_queue_enqueue(p_bcb->xmit_q, p_buf);\n     }\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_bcb->l2cap_cid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda,\n-                p_bcb->l2cap_cid, p_buf->len);\n+                p_bcb->l2cap_cid, len);\n     }\n   }\n }\ndiff --git a/system/stack/hid/hidd_conn.cc b/system/stack/hid/hidd_conn.cc\nindex c64a7b9104..695e5d6c84 100644\n--- a/system/stack/hid/hidd_conn.cc\n+++ b/system/stack/hid/hidd_conn.cc\n@@ -88,10 +88,10 @@ static void hidd_check_config_done() {\n \n     // send outstanding data on intr\n     if (hd_cb.pending_data) {\n+      uint16_t len = hd_cb.pending_data->len;\n       if (stack::l2cap::get_interface().L2CA_DataWrite(p_hcon->intr_cid, hd_cb.pending_data) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n-        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid,\n-                  hd_cb.pending_data->len);\n+        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid, len);\n       }\n       hd_cb.pending_data = NULL;\n     }\ndiff --git a/system/stack/rfcomm/rfc_ts_frames.cc b/system/stack/rfcomm/rfc_ts_frames.cc\nindex ea57abf6dc..e93cfed9b8 100644\n--- a/system/stack/rfcomm/rfc_ts_frames.cc\n+++ b/system/stack/rfcomm/rfc_ts_frames.cc\n@@ -201,10 +201,11 @@ void rfc_send_buf_uih(tRFC_MCB* p_mcb, uint8_t dlci, BT_HDR* p_buf) {\n   if (dlci == RFCOMM_MX_DLCI) {\n     rfc_check_send_cmd(p_mcb, p_buf);\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p_buf->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/rfcomm/rfc_utils.cc b/system/stack/rfcomm/rfc_utils.cc\nindex 23420892cb..0c5074db76 100644\n--- a/system/stack/rfcomm/rfc_utils.cc\n+++ b/system/stack/rfcomm/rfc_utils.cc\n@@ -428,9 +428,10 @@ void rfc_check_send_cmd(tRFC_MCB* p_mcb, BT_HDR* p_buf) {\n     if (p == NULL) {\n       break;\n     }\n+    uint16_t len = p->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p) != tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/sdp/sdp_discovery.cc b/system/stack/sdp/sdp_discovery.cc\nindex 4fa484e14a..6aba1993af 100644\n--- a/system/stack/sdp/sdp_discovery.cc\n+++ b/system/stack/sdp/sdp_discovery.cc\n@@ -877,7 +877,7 @@ static void process_service_attr_rsp(tCONN_CB* p_ccb, uint8_t* p_reply, uint8_t*\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_msg) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-                p_ccb->connection_id, p_msg->len);\n+                p_ccb->connection_id, p - p_start);\n     }\n \n     /* Start inactivity timer */\ndiff --git a/system/stack/sdp/sdp_server.cc b/system/stack/sdp/sdp_server.cc\nindex abd70aedb1..0f379708e9 100644\n--- a/system/stack/sdp/sdp_server.cc\n+++ b/system/stack/sdp/sdp_server.cc\n@@ -300,7 +300,7 @@ static void process_service_search(tCONN_CB* p_ccb, uint16_t trans_num, uint16_t\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n@@ -564,7 +564,7 @@ static void process_service_attr_req(tCONN_CB* p_ccb, uint16_t trans_num, uint16\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "43cfd234de9ba9557118b0014513269cc1aeefda"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-346797131",
            "aliases": [
                "A-346797131",
                "CVE-2025-22423"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-346797131",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "c3a37d2bb97c78bac71b0293866a2397df00f8b0"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From c3a37d2bb97c78bac71b0293866a2397df00f8b0 Mon Sep 17 00:00:00 2001\nFrom: Nick Chusid <nchusid@google.com>\nDate: Mon, 27 Jan 2025 22:10:56 +0000\nSubject: [PATCH] Fail fast in dng sdk if an invalid tag count is seen\n\nBug: 346797131\nTest: TreeHugger\nChange-Id: I76da86b063ce4a0a329aca2a1309997cd62ac58d\n---\n source/dng_ifd.cpp | 9 ++++++---\n 1 file changed, 6 insertions(+), 3 deletions(-)\n\ndiff --git a/source/dng_ifd.cpp b/source/dng_ifd.cpp\nindex 7f22065..bf3fb2c 100644\n--- a/source/dng_ifd.cpp\n+++ b/source/dng_ifd.cpp\n@@ -351,7 +351,8 @@ bool dng_ifd::ParseTag (dng_stream &stream,\n \t\t\t\n \t\t\tCheckTagType (parentCode, tagCode, tagType, ttShort);\n \t\t\t\n-\t\t\tCheckTagCount (parentCode, tagCode, tagCount, 1, 0x0FFFF);\n+\t\t\tif (!CheckTagCount (parentCode, tagCode, tagCount, 1, 0x0FFFF))\n+\t\t\t\treturn false;\n \t\t\t\n \t\t\t#if qDNGValidate\n \t\t\t\n@@ -973,7 +974,8 @@ bool dng_ifd::ParseTag (dng_stream &stream,\n \t\t\t\n \t\t\tCheckTagType (parentCode, tagCode, tagType, ttShort);\n \t\t\t\n-\t\t\tCheckTagCount (parentCode, tagCode, tagCount, 1, fSamplesPerPixel);\n+\t\t\tif (!CheckTagCount (parentCode, tagCode, tagCount, 1, fSamplesPerPixel))\n+\t\t\t\treturn false;\n \t\t\t\n \t\t\t#if qDNGValidate\n \t\t\t\n@@ -1025,7 +1027,8 @@ bool dng_ifd::ParseTag (dng_stream &stream,\n \t\t\t\n \t\t\tCheckTagType (parentCode, tagCode, tagType, ttShort);\n \t\t\t\n-\t\t\tCheckTagCount (parentCode, tagCode, tagCount, fSamplesPerPixel);\n+\t\t\tif (!CheckTagCount (parentCode, tagCode, tagCount, fSamplesPerPixel))\n+\t\t\t\treturn false;\n \t\t\t\n \t\t\t#if qDNGValidate\n \t\t\t\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 2,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "445d85031ac9c1cffd06bf8b3356d9391170a319"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "f2e6d5540ca1eda4d313bf4071a29ef8bffea7f7",
                            "result": "success",
                            "downstream_patch_content": "commit f2e6d5540ca1eda4d313bf4071a29ef8bffea7f7\nAuthor: Nick Chusid <nchusid@google.com>\nDate:   Mon Jan 27 22:10:56 2025 +0000\n\n    Fail fast in dng sdk if an invalid tag count is seen\n    \n    Bug: 346797131\n    Test: TreeHugger\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:84b0c687ce847c80a2454b206c046da8241db41b)\n    Merged-In: I76da86b063ce4a0a329aca2a1309997cd62ac58d\n    Change-Id: I76da86b063ce4a0a329aca2a1309997cd62ac58d\n\ndiff --git a/source/dng_ifd.cpp b/source/dng_ifd.cpp\nindex 7f22065..bf3fb2c 100644\n--- a/source/dng_ifd.cpp\n+++ b/source/dng_ifd.cpp\n@@ -351,7 +351,8 @@ bool dng_ifd::ParseTag (dng_stream &stream,\n \t\t\t\n \t\t\tCheckTagType (parentCode, tagCode, tagType, ttShort);\n \t\t\t\n-\t\t\tCheckTagCount (parentCode, tagCode, tagCount, 1, 0x0FFFF);\n+\t\t\tif (!CheckTagCount (parentCode, tagCode, tagCount, 1, 0x0FFFF))\n+\t\t\t\treturn false;\n \t\t\t\n \t\t\t#if qDNGValidate\n \t\t\t\n@@ -973,7 +974,8 @@ bool dng_ifd::ParseTag (dng_stream &stream,\n \t\t\t\n \t\t\tCheckTagType (parentCode, tagCode, tagType, ttShort);\n \t\t\t\n-\t\t\tCheckTagCount (parentCode, tagCode, tagCount, 1, fSamplesPerPixel);\n+\t\t\tif (!CheckTagCount (parentCode, tagCode, tagCount, 1, fSamplesPerPixel))\n+\t\t\t\treturn false;\n \t\t\t\n \t\t\t#if qDNGValidate\n \t\t\t\n@@ -1025,7 +1027,8 @@ bool dng_ifd::ParseTag (dng_stream &stream,\n \t\t\t\n \t\t\tCheckTagType (parentCode, tagCode, tagType, ttShort);\n \t\t\t\n-\t\t\tCheckTagCount (parentCode, tagCode, tagCount, fSamplesPerPixel);\n+\t\t\tif (!CheckTagCount (parentCode, tagCode, tagCount, fSamplesPerPixel))\n+\t\t\t\treturn false;\n \t\t\t\n \t\t\t#if qDNGValidate\n \t\t\t\n"
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "d11e3fa5130e1cd249e94ba3575a1b6e7903d056",
                            "result": "success",
                            "downstream_patch_content": "commit d11e3fa5130e1cd249e94ba3575a1b6e7903d056\nAuthor: Nick Chusid <nchusid@google.com>\nDate:   Mon Jan 27 22:10:56 2025 +0000\n\n    Fail fast in dng sdk if an invalid tag count is seen\n    \n    Bug: 346797131\n    Test: TreeHugger\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:84b0c687ce847c80a2454b206c046da8241db41b)\n    Merged-In: I76da86b063ce4a0a329aca2a1309997cd62ac58d\n    Change-Id: I76da86b063ce4a0a329aca2a1309997cd62ac58d\n\ndiff --git a/source/dng_ifd.cpp b/source/dng_ifd.cpp\nindex 7f22065..bf3fb2c 100644\n--- a/source/dng_ifd.cpp\n+++ b/source/dng_ifd.cpp\n@@ -351,7 +351,8 @@ bool dng_ifd::ParseTag (dng_stream &stream,\n \t\t\t\n \t\t\tCheckTagType (parentCode, tagCode, tagType, ttShort);\n \t\t\t\n-\t\t\tCheckTagCount (parentCode, tagCode, tagCount, 1, 0x0FFFF);\n+\t\t\tif (!CheckTagCount (parentCode, tagCode, tagCount, 1, 0x0FFFF))\n+\t\t\t\treturn false;\n \t\t\t\n \t\t\t#if qDNGValidate\n \t\t\t\n@@ -973,7 +974,8 @@ bool dng_ifd::ParseTag (dng_stream &stream,\n \t\t\t\n \t\t\tCheckTagType (parentCode, tagCode, tagType, ttShort);\n \t\t\t\n-\t\t\tCheckTagCount (parentCode, tagCode, tagCount, 1, fSamplesPerPixel);\n+\t\t\tif (!CheckTagCount (parentCode, tagCode, tagCount, 1, fSamplesPerPixel))\n+\t\t\t\treturn false;\n \t\t\t\n \t\t\t#if qDNGValidate\n \t\t\t\n@@ -1025,7 +1027,8 @@ bool dng_ifd::ParseTag (dng_stream &stream,\n \t\t\t\n \t\t\tCheckTagType (parentCode, tagCode, tagType, ttShort);\n \t\t\t\n-\t\t\tCheckTagCount (parentCode, tagCode, tagCount, fSamplesPerPixel);\n+\t\t\tif (!CheckTagCount (parentCode, tagCode, tagCount, fSamplesPerPixel))\n+\t\t\t\treturn false;\n \t\t\t\n \t\t\t#if qDNGValidate\n \t\t\t\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-375397720",
            "aliases": [
                "A-375397720",
                "CVE-2025-22410"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375397720",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "00555617ddbbc1a19089104c084d14f465c971ce"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 00555617ddbbc1a19089104c084d14f465c971ce Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Sat, 2 Nov 2024 02:29:10 +0000\nSubject: [PATCH] Fix more memory-unsafe logging\n\nIn various locations around the stack, log statements use structures that\nmay, in exceptional cases, have been freed by preceding calls.  This can\nlead to use after free and potentially to security vulnerabilities.\n\nUse local variables instead, or store the length before the call if no\nlocal variable is already convenient.\n\nBug: 375404242\nBug: 375398779\nBug: 375397720\nBug: 375397164\nBug: 375397370\nBug: 375396810\nBug: 375159652\nBug: 375160214\nBug: 375159480\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: Ia50e074de751661a0e617bfffa17871497b8d1ea\n---\n system/stack/avct/avct_lcb_act.cc    | 5 ++++-\n system/stack/bnep/bnep_main.cc       | 4 +++-\n system/stack/bnep/bnep_utils.cc      | 3 ++-\n system/stack/hid/hidd_conn.cc        | 4 ++--\n system/stack/rfcomm/rfc_ts_frames.cc | 3 ++-\n system/stack/rfcomm/rfc_utils.cc     | 3 ++-\n system/stack/sdp/sdp_discovery.cc    | 2 +-\n system/stack/sdp/sdp_server.cc       | 4 ++--\n 8 files changed, 18 insertions(+), 10 deletions(-)\n\ndiff --git a/system/stack/avct/avct_lcb_act.cc b/system/stack/avct/avct_lcb_act.cc\nindex 986bce7d34..32da9d865b 100644\n--- a/system/stack/avct/avct_lcb_act.cc\n+++ b/system/stack/avct/avct_lcb_act.cc\n@@ -727,10 +727,13 @@ void avct_lcb_msg_ind(tAVCT_LCB* p_lcb, tAVCT_LCB_EVT* p_data) {\n     p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n     AVCT_BUILD_HDR(p, label, AVCT_PKT_TYPE_SINGLE, AVCT_REJ);\n     UINT16_TO_BE_STREAM(p, pid);\n+\n+    uint16_t len = p_buf->len;\n+\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_lcb->ch_lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} lcid:0x{:04x} len:{}\", p_lcb->peer_addr,\n-                p_lcb->ch_lcid, p_buf->len);\n+                p_lcb->ch_lcid, len);\n     }\n   }\n }\ndiff --git a/system/stack/bnep/bnep_main.cc b/system/stack/bnep/bnep_main.cc\nindex e0e3c4540c..adf3c8666e 100644\n--- a/system/stack/bnep/bnep_main.cc\n+++ b/system/stack/bnep/bnep_main.cc\n@@ -295,10 +295,12 @@ static void bnep_congestion_ind(uint16_t l2cap_cid, bool is_congested) {\n         break;\n       }\n \n+      uint16_t len = p_buf->len;\n+\n       if (stack::l2cap::get_interface().L2CA_DataWrite(l2cap_cid, p_buf) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n         log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda, l2cap_cid,\n-                  p_buf->len);\n+                  len);\n       }\n     }\n   }\ndiff --git a/system/stack/bnep/bnep_utils.cc b/system/stack/bnep/bnep_utils.cc\nindex 252facf668..4092d9afee 100644\n--- a/system/stack/bnep/bnep_utils.cc\n+++ b/system/stack/bnep/bnep_utils.cc\n@@ -411,10 +411,11 @@ void bnepu_check_send_packet(tBNEP_CONN* p_bcb, BT_HDR* p_buf) {\n       fixed_queue_enqueue(p_bcb->xmit_q, p_buf);\n     }\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_bcb->l2cap_cid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda,\n-                p_bcb->l2cap_cid, p_buf->len);\n+                p_bcb->l2cap_cid, len);\n     }\n   }\n }\ndiff --git a/system/stack/hid/hidd_conn.cc b/system/stack/hid/hidd_conn.cc\nindex c64a7b9104..695e5d6c84 100644\n--- a/system/stack/hid/hidd_conn.cc\n+++ b/system/stack/hid/hidd_conn.cc\n@@ -88,10 +88,10 @@ static void hidd_check_config_done() {\n \n     // send outstanding data on intr\n     if (hd_cb.pending_data) {\n+      uint16_t len = hd_cb.pending_data->len;\n       if (stack::l2cap::get_interface().L2CA_DataWrite(p_hcon->intr_cid, hd_cb.pending_data) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n-        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid,\n-                  hd_cb.pending_data->len);\n+        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid, len);\n       }\n       hd_cb.pending_data = NULL;\n     }\ndiff --git a/system/stack/rfcomm/rfc_ts_frames.cc b/system/stack/rfcomm/rfc_ts_frames.cc\nindex ea57abf6dc..e93cfed9b8 100644\n--- a/system/stack/rfcomm/rfc_ts_frames.cc\n+++ b/system/stack/rfcomm/rfc_ts_frames.cc\n@@ -201,10 +201,11 @@ void rfc_send_buf_uih(tRFC_MCB* p_mcb, uint8_t dlci, BT_HDR* p_buf) {\n   if (dlci == RFCOMM_MX_DLCI) {\n     rfc_check_send_cmd(p_mcb, p_buf);\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p_buf->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/rfcomm/rfc_utils.cc b/system/stack/rfcomm/rfc_utils.cc\nindex 23420892cb..0c5074db76 100644\n--- a/system/stack/rfcomm/rfc_utils.cc\n+++ b/system/stack/rfcomm/rfc_utils.cc\n@@ -428,9 +428,10 @@ void rfc_check_send_cmd(tRFC_MCB* p_mcb, BT_HDR* p_buf) {\n     if (p == NULL) {\n       break;\n     }\n+    uint16_t len = p->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p) != tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/sdp/sdp_discovery.cc b/system/stack/sdp/sdp_discovery.cc\nindex 4fa484e14a..6aba1993af 100644\n--- a/system/stack/sdp/sdp_discovery.cc\n+++ b/system/stack/sdp/sdp_discovery.cc\n@@ -877,7 +877,7 @@ static void process_service_attr_rsp(tCONN_CB* p_ccb, uint8_t* p_reply, uint8_t*\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_msg) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-                p_ccb->connection_id, p_msg->len);\n+                p_ccb->connection_id, p - p_start);\n     }\n \n     /* Start inactivity timer */\ndiff --git a/system/stack/sdp/sdp_server.cc b/system/stack/sdp/sdp_server.cc\nindex abd70aedb1..0f379708e9 100644\n--- a/system/stack/sdp/sdp_server.cc\n+++ b/system/stack/sdp/sdp_server.cc\n@@ -300,7 +300,7 @@ static void process_service_search(tCONN_CB* p_ccb, uint16_t trans_num, uint16_t\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n@@ -564,7 +564,7 @@ static void process_service_attr_req(tCONN_CB* p_ccb, uint16_t trans_num, uint16\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "43cfd234de9ba9557118b0014513269cc1aeefda"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-356630194",
            "aliases": [
                "A-356630194",
                "CVE-2025-0096"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-356630194",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "b7056d70f2cdd1596a95048e4ee80b6d91bcb3e0"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From b7056d70f2cdd1596a95048e4ee80b6d91bcb3e0 Mon Sep 17 00:00:00 2001\nFrom: Kyle Hsiao <kylehsiao@google.com>\nDate: Thu, 1 Aug 2024 07:57:47 +0000\nSubject: [PATCH] Fix malloc buffer size\n\nMalloc the correct buffer.\n\nBug: 356630194\nTest: manual\nChange-Id: I831f584c0ebd26821029198998ecc5cc47c3400c\n---\n st21nfc/hal/hal_fwlog.cc | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/st21nfc/hal/hal_fwlog.cc b/st21nfc/hal/hal_fwlog.cc\nindex 8704639..cd75907 100644\n--- a/st21nfc/hal/hal_fwlog.cc\n+++ b/st21nfc/hal/hal_fwlog.cc\n@@ -55,7 +55,7 @@ uint8_t handlePollingLoopData(uint8_t format, uint8_t* tlvBuffer,\n     case T_fieldOn:\n     case T_fieldOff:\n       STLOG_HAL_D(\"%s - FieldOn/Off\", __func__);\n-      *NewTlv = (uint8_t*)malloc(8 * sizeof(uint8_t));\n+      *NewTlv = (uint8_t*)malloc(9 * sizeof(uint8_t));\n       value_len = 0x06;\n       (*NewTlv)[0] = TYPE_REMOTE_FIELD;\n       (*NewTlv)[1] = flag;\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "2c6225e82a0d3d721fb84a3828a9916bc9b7aa89"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-367266072",
            "aliases": [
                "A-367266072",
                "CVE-2025-0098"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-367266072",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "61ab2b65caf855c48fdb4166f94e02bf79c90e7b"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 61ab2b65caf855c48fdb4166f94e02bf79c90e7b Mon Sep 17 00:00:00 2001\nFrom: Louis Chang <louischang@google.com>\nDate: Mon, 23 Sep 2024 03:47:15 +0000\nSubject: [PATCH] Prevent activity token leaked to another process\n\nMalicious app could register the organizer via one-way binder call\nto disguise as running on pid 0.\n\nBug: 367266072\nTest: verified via the sample app\nFlag: EXEMPT bugfix\nChange-Id: I51378c7d2da06fb83670abd082a089cfd82d699d\n---\n .../server/wm/TaskFragmentOrganizerController.java       | 9 +++++++--\n 1 file changed, 7 insertions(+), 2 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/wm/TaskFragmentOrganizerController.java b/services/core/java/com/android/server/wm/TaskFragmentOrganizerController.java\nindex 92953e5a5041..83e714d82dd2 100644\n--- a/services/core/java/com/android/server/wm/TaskFragmentOrganizerController.java\n+++ b/services/core/java/com/android/server/wm/TaskFragmentOrganizerController.java\n@@ -429,7 +429,7 @@ public class TaskFragmentOrganizerController extends ITaskFragmentOrganizerContr\n             }\n \n             final IBinder activityToken;\n-            if (activity.getPid() == mOrganizerPid) {\n+            if (activity.getPid() == mOrganizerPid && activity.getUid() == mOrganizerUid) {\n                 // We only pass the actual token if the activity belongs to the organizer process.\n                 activityToken = activity.token;\n             } else {\n@@ -458,7 +458,8 @@ public class TaskFragmentOrganizerController extends ITaskFragmentOrganizerContr\n                 change.setTaskFragmentToken(lastParentTfToken);\n             }\n             // Only pass the activity token to the client if it belongs to the same process.\n-            if (nextFillTaskActivity != null && nextFillTaskActivity.getPid() == mOrganizerPid) {\n+            if (nextFillTaskActivity != null && nextFillTaskActivity.getPid() == mOrganizerPid\n+                    && nextFillTaskActivity.getUid() == mOrganizerUid) {\n                 change.setOtherActivityToken(nextFillTaskActivity.token);\n             }\n             return change;\n@@ -553,6 +554,10 @@ public class TaskFragmentOrganizerController extends ITaskFragmentOrganizerContr\n                         \"Replacing existing organizer currently unsupported\");\n             }\n \n+            if (pid <= 0) {\n+                throw new IllegalStateException(\"Cannot register from invalid pid: \" + pid);\n+            }\n+\n             if (restoreFromCachedStateIfPossible(organizer, pid, uid, outSavedState)) {\n                 return;\n             }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "6ab778a0dd3d09c6e3e2b6176245d3c99b5170ce"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-364269936",
            "aliases": [
                "A-364269936",
                "CVE-2025-0086"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-364269936",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "a3788486f2c7f728721c9700f7485f865b462609"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From a3788486f2c7f728721c9700f7485f865b462609 Mon Sep 17 00:00:00 2001\nFrom: Dmitry Dementyev <dementyev@google.com>\nDate: Thu, 19 Dec 2024 11:02:42 -0800\nSubject: [PATCH] Check account type returned by AbstractAccountAuthenticator.\n\nAccountManagerService already knows which account is used during\nAbstractAccountAuthenticator.getAuthToken.\n\nKEY_ACCOUNT_NAME and KEY_ACCOUNT_TYPE in the response look unnecessary,\nbut we can't change API at this moment.\n\nBug: 364269936\nTest: manual\nFlag: EXEMPT bugfix\nChange-Id: Ifc62866f4feaca43abc32bc542b97f3741953f56\n---\n .../com/android/server/accounts/AccountManagerService.java  | 6 ++++++\n 1 file changed, 6 insertions(+)\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 3ce645158fe4..6095ab65f977 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -3214,6 +3214,12 @@ public class AccountManagerService\n                                         \"the type and name should not be empty\");\n                                 return;\n                             }\n+                            if (!type.equals(mAccountType)) {\n+                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n+                                        \"incorrect account type\");\n+                                return;\n+                            }\n+\n                             Account resultAccount = new Account(name, type);\n                             if (!customTokens) {\n                                 saveAuthTokenToDatabase(\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "fb41e444fd13d26477175c6154491d49e736d11e",
                            "result": "success",
                            "downstream_patch_content": "commit fb41e444fd13d26477175c6154491d49e736d11e\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Thu Dec 19 11:02:42 2024 -0800\n\n    Check account type returned by AbstractAccountAuthenticator.\n    \n    AccountManagerService already knows which account is used during\n    AbstractAccountAuthenticator.getAuthToken.\n    \n    KEY_ACCOUNT_NAME and KEY_ACCOUNT_TYPE in the response look unnecessary,\n    but we can't change API at this moment.\n    \n    Bug: 364269936\n    Test: manual\n    Flag: EXEMPT bugfix\n    Change-Id: Ifc62866f4feaca43abc32bc542b97f3741953f56\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 5f434ee267d4..5b83a02de8b2 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -3070,6 +3070,12 @@ public class AccountManagerService\n                                         \"the type and name should not be empty\");\n                                 return;\n                             }\n+                            if (!type.equals(mAccountType)) {\n+                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n+                                        \"incorrect account type\");\n+                                return;\n+                            }\n+\n                             Account resultAccount = new Account(name, type);\n                             if (!customTokens) {\n                                 saveAuthTokenToDatabase(\n"
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "fb41e444fd13d26477175c6154491d49e736d11e",
                            "result": "success",
                            "downstream_patch_content": "commit fb41e444fd13d26477175c6154491d49e736d11e\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Thu Dec 19 11:02:42 2024 -0800\n\n    Check account type returned by AbstractAccountAuthenticator.\n    \n    AccountManagerService already knows which account is used during\n    AbstractAccountAuthenticator.getAuthToken.\n    \n    KEY_ACCOUNT_NAME and KEY_ACCOUNT_TYPE in the response look unnecessary,\n    but we can't change API at this moment.\n    \n    Bug: 364269936\n    Test: manual\n    Flag: EXEMPT bugfix\n    Change-Id: Ifc62866f4feaca43abc32bc542b97f3741953f56\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 5f434ee267d4..5b83a02de8b2 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -3070,6 +3070,12 @@ public class AccountManagerService\n                                         \"the type and name should not be empty\");\n                                 return;\n                             }\n+                            if (!type.equals(mAccountType)) {\n+                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n+                                        \"incorrect account type\");\n+                                return;\n+                            }\n+\n                             Account resultAccount = new Account(name, type);\n                             if (!customTokens) {\n                                 saveAuthTokenToDatabase(\n"
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "87b546c56dfa8259508c108cd9726090cef31856"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "fb41e444fd13d26477175c6154491d49e736d11e",
                            "result": "success",
                            "downstream_patch_content": "commit fb41e444fd13d26477175c6154491d49e736d11e\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Thu Dec 19 11:02:42 2024 -0800\n\n    Check account type returned by AbstractAccountAuthenticator.\n    \n    AccountManagerService already knows which account is used during\n    AbstractAccountAuthenticator.getAuthToken.\n    \n    KEY_ACCOUNT_NAME and KEY_ACCOUNT_TYPE in the response look unnecessary,\n    but we can't change API at this moment.\n    \n    Bug: 364269936\n    Test: manual\n    Flag: EXEMPT bugfix\n    Change-Id: Ifc62866f4feaca43abc32bc542b97f3741953f56\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 5f434ee267d4..5b83a02de8b2 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -3070,6 +3070,12 @@ public class AccountManagerService\n                                         \"the type and name should not be empty\");\n                                 return;\n                             }\n+                            if (!type.equals(mAccountType)) {\n+                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n+                                        \"incorrect account type\");\n+                                return;\n+                            }\n+\n                             Account resultAccount = new Account(name, type);\n                             if (!customTokens) {\n                                 saveAuthTokenToDatabase(\n"
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "fb41e444fd13d26477175c6154491d49e736d11e",
                            "result": "success",
                            "downstream_patch_content": "commit fb41e444fd13d26477175c6154491d49e736d11e\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Thu Dec 19 11:02:42 2024 -0800\n\n    Check account type returned by AbstractAccountAuthenticator.\n    \n    AccountManagerService already knows which account is used during\n    AbstractAccountAuthenticator.getAuthToken.\n    \n    KEY_ACCOUNT_NAME and KEY_ACCOUNT_TYPE in the response look unnecessary,\n    but we can't change API at this moment.\n    \n    Bug: 364269936\n    Test: manual\n    Flag: EXEMPT bugfix\n    Change-Id: Ifc62866f4feaca43abc32bc542b97f3741953f56\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 5f434ee267d4..5b83a02de8b2 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -3070,6 +3070,12 @@ public class AccountManagerService\n                                         \"the type and name should not be empty\");\n                                 return;\n                             }\n+                            if (!type.equals(mAccountType)) {\n+                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n+                                        \"incorrect account type\");\n+                                return;\n+                            }\n+\n                             Account resultAccount = new Account(name, type);\n                             if (!customTokens) {\n                                 saveAuthTokenToDatabase(\n"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-375159652",
            "aliases": [
                "A-375159652",
                "CVE-2025-22405"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375159652",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "00555617ddbbc1a19089104c084d14f465c971ce"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 00555617ddbbc1a19089104c084d14f465c971ce Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Sat, 2 Nov 2024 02:29:10 +0000\nSubject: [PATCH] Fix more memory-unsafe logging\n\nIn various locations around the stack, log statements use structures that\nmay, in exceptional cases, have been freed by preceding calls.  This can\nlead to use after free and potentially to security vulnerabilities.\n\nUse local variables instead, or store the length before the call if no\nlocal variable is already convenient.\n\nBug: 375404242\nBug: 375398779\nBug: 375397720\nBug: 375397164\nBug: 375397370\nBug: 375396810\nBug: 375159652\nBug: 375160214\nBug: 375159480\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: Ia50e074de751661a0e617bfffa17871497b8d1ea\n---\n system/stack/avct/avct_lcb_act.cc    | 5 ++++-\n system/stack/bnep/bnep_main.cc       | 4 +++-\n system/stack/bnep/bnep_utils.cc      | 3 ++-\n system/stack/hid/hidd_conn.cc        | 4 ++--\n system/stack/rfcomm/rfc_ts_frames.cc | 3 ++-\n system/stack/rfcomm/rfc_utils.cc     | 3 ++-\n system/stack/sdp/sdp_discovery.cc    | 2 +-\n system/stack/sdp/sdp_server.cc       | 4 ++--\n 8 files changed, 18 insertions(+), 10 deletions(-)\n\ndiff --git a/system/stack/avct/avct_lcb_act.cc b/system/stack/avct/avct_lcb_act.cc\nindex 986bce7d34..32da9d865b 100644\n--- a/system/stack/avct/avct_lcb_act.cc\n+++ b/system/stack/avct/avct_lcb_act.cc\n@@ -727,10 +727,13 @@ void avct_lcb_msg_ind(tAVCT_LCB* p_lcb, tAVCT_LCB_EVT* p_data) {\n     p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n     AVCT_BUILD_HDR(p, label, AVCT_PKT_TYPE_SINGLE, AVCT_REJ);\n     UINT16_TO_BE_STREAM(p, pid);\n+\n+    uint16_t len = p_buf->len;\n+\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_lcb->ch_lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} lcid:0x{:04x} len:{}\", p_lcb->peer_addr,\n-                p_lcb->ch_lcid, p_buf->len);\n+                p_lcb->ch_lcid, len);\n     }\n   }\n }\ndiff --git a/system/stack/bnep/bnep_main.cc b/system/stack/bnep/bnep_main.cc\nindex e0e3c4540c..adf3c8666e 100644\n--- a/system/stack/bnep/bnep_main.cc\n+++ b/system/stack/bnep/bnep_main.cc\n@@ -295,10 +295,12 @@ static void bnep_congestion_ind(uint16_t l2cap_cid, bool is_congested) {\n         break;\n       }\n \n+      uint16_t len = p_buf->len;\n+\n       if (stack::l2cap::get_interface().L2CA_DataWrite(l2cap_cid, p_buf) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n         log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda, l2cap_cid,\n-                  p_buf->len);\n+                  len);\n       }\n     }\n   }\ndiff --git a/system/stack/bnep/bnep_utils.cc b/system/stack/bnep/bnep_utils.cc\nindex 252facf668..4092d9afee 100644\n--- a/system/stack/bnep/bnep_utils.cc\n+++ b/system/stack/bnep/bnep_utils.cc\n@@ -411,10 +411,11 @@ void bnepu_check_send_packet(tBNEP_CONN* p_bcb, BT_HDR* p_buf) {\n       fixed_queue_enqueue(p_bcb->xmit_q, p_buf);\n     }\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_bcb->l2cap_cid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda,\n-                p_bcb->l2cap_cid, p_buf->len);\n+                p_bcb->l2cap_cid, len);\n     }\n   }\n }\ndiff --git a/system/stack/hid/hidd_conn.cc b/system/stack/hid/hidd_conn.cc\nindex c64a7b9104..695e5d6c84 100644\n--- a/system/stack/hid/hidd_conn.cc\n+++ b/system/stack/hid/hidd_conn.cc\n@@ -88,10 +88,10 @@ static void hidd_check_config_done() {\n \n     // send outstanding data on intr\n     if (hd_cb.pending_data) {\n+      uint16_t len = hd_cb.pending_data->len;\n       if (stack::l2cap::get_interface().L2CA_DataWrite(p_hcon->intr_cid, hd_cb.pending_data) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n-        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid,\n-                  hd_cb.pending_data->len);\n+        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid, len);\n       }\n       hd_cb.pending_data = NULL;\n     }\ndiff --git a/system/stack/rfcomm/rfc_ts_frames.cc b/system/stack/rfcomm/rfc_ts_frames.cc\nindex ea57abf6dc..e93cfed9b8 100644\n--- a/system/stack/rfcomm/rfc_ts_frames.cc\n+++ b/system/stack/rfcomm/rfc_ts_frames.cc\n@@ -201,10 +201,11 @@ void rfc_send_buf_uih(tRFC_MCB* p_mcb, uint8_t dlci, BT_HDR* p_buf) {\n   if (dlci == RFCOMM_MX_DLCI) {\n     rfc_check_send_cmd(p_mcb, p_buf);\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p_buf->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/rfcomm/rfc_utils.cc b/system/stack/rfcomm/rfc_utils.cc\nindex 23420892cb..0c5074db76 100644\n--- a/system/stack/rfcomm/rfc_utils.cc\n+++ b/system/stack/rfcomm/rfc_utils.cc\n@@ -428,9 +428,10 @@ void rfc_check_send_cmd(tRFC_MCB* p_mcb, BT_HDR* p_buf) {\n     if (p == NULL) {\n       break;\n     }\n+    uint16_t len = p->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p) != tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/sdp/sdp_discovery.cc b/system/stack/sdp/sdp_discovery.cc\nindex 4fa484e14a..6aba1993af 100644\n--- a/system/stack/sdp/sdp_discovery.cc\n+++ b/system/stack/sdp/sdp_discovery.cc\n@@ -877,7 +877,7 @@ static void process_service_attr_rsp(tCONN_CB* p_ccb, uint8_t* p_reply, uint8_t*\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_msg) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-                p_ccb->connection_id, p_msg->len);\n+                p_ccb->connection_id, p - p_start);\n     }\n \n     /* Start inactivity timer */\ndiff --git a/system/stack/sdp/sdp_server.cc b/system/stack/sdp/sdp_server.cc\nindex abd70aedb1..0f379708e9 100644\n--- a/system/stack/sdp/sdp_server.cc\n+++ b/system/stack/sdp/sdp_server.cc\n@@ -300,7 +300,7 @@ static void process_service_search(tCONN_CB* p_ccb, uint16_t trans_num, uint16_t\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n@@ -564,7 +564,7 @@ static void process_service_attr_req(tCONN_CB* p_ccb, uint16_t trans_num, uint16\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "43cfd234de9ba9557118b0014513269cc1aeefda"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-360846772",
            "aliases": [
                "A-360846772",
                "CVE-2024-49744"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-360846772",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "cde345a7ee06db716e613e12a2c218ce248ad1c4"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From cde345a7ee06db716e613e12a2c218ce248ad1c4 Mon Sep 17 00:00:00 2001\nFrom: Dmitry Dementyev <dementyev@google.com>\nDate: Tue, 1 Oct 2024 14:57:44 -0700\nSubject: [PATCH] Update checkKeyIntent\n\n1) Explicityly set  component after target activity check.\n2) Update Intent subclass check.\n\nBug: 360846772\nTest: manual\nFlag: EXEMPT bugfix\nChange-Id: Ied7961c73299681aa5b523cf3f00fd905893116f\n---\n .../android/server/accounts/AccountManagerService.java   | 9 ++++++---\n 1 file changed, 6 insertions(+), 3 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 3499a3a5edde..0ca3b56486e3 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5062,6 +5062,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -5083,14 +5085,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 0,
                    "failed_patches": 4,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "185048041e6f9d43c38829c09965e7a4740d2a6a",
                            "result": "failure",
                            "downstream_patch_content": "commit 185048041e6f9d43c38829c09965e7a4740d2a6a\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Wed Oct 16 15:01:59 2024 -0700\n\n    Update checkKeyIntent\n    \n    1) Explicityly set  component after target activity check.\n    2) Update Intent subclass check.\n    \n    Bug: 360846772\n    Test: manual\n    Flag: EXEMPT bugfix\n    \n    Merged-In: Ied7961c73299681aa5b523cf3f00fd905893116f\n    Change-Id: Iafc1e2260107f7ecc18c90ce12f8987b4fc76350\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 36ffc40bf5f7..5f434ee267d4 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n                }\n=======\n            Bundle simulateBundle = p.readBundle();\n            p.recycle();\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                    Intent.class);\n            if (intent == null) {\n                return (simulateIntent == null);\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n        }\n=======\n            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n                return false;\n            }\n\n            if (!intent.filterEquals(simulateIntent)) {\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5085,14 +5087,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
                                    "patch_apply_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #1 succeeded at 4886 (offset -176 lines).\nHunk #2 FAILED at 5085.\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/accounts/AccountManagerService.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #2 NOT MERGED at 5289-5299,5301-5309."
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "185048041e6f9d43c38829c09965e7a4740d2a6a",
                            "result": "failure",
                            "downstream_patch_content": "commit 185048041e6f9d43c38829c09965e7a4740d2a6a\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Wed Oct 16 15:01:59 2024 -0700\n\n    Update checkKeyIntent\n    \n    1) Explicityly set  component after target activity check.\n    2) Update Intent subclass check.\n    \n    Bug: 360846772\n    Test: manual\n    Flag: EXEMPT bugfix\n    \n    Merged-In: Ied7961c73299681aa5b523cf3f00fd905893116f\n    Change-Id: Iafc1e2260107f7ecc18c90ce12f8987b4fc76350\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 36ffc40bf5f7..5f434ee267d4 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n                }\n=======\n            Bundle simulateBundle = p.readBundle();\n            p.recycle();\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                    Intent.class);\n            if (intent == null) {\n                return (simulateIntent == null);\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n        }\n=======\n            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n                return false;\n            }\n\n            if (!intent.filterEquals(simulateIntent)) {\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5085,14 +5087,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
                                    "patch_apply_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #1 succeeded at 4886 (offset -176 lines).\nHunk #2 FAILED at 5085.\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/accounts/AccountManagerService.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #2 NOT MERGED at 5289-5299,5301-5309."
                                }
                            ]
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "0397dd35e6cc696b0ea3949c5d29f90b42a0ce59"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "d04cea5ea08f91f55a14209c1e424e163e2d50ab",
                            "result": "failure",
                            "downstream_patch_content": "commit d04cea5ea08f91f55a14209c1e424e163e2d50ab\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Tue Oct 1 14:57:44 2024 -0700\n\n    Update checkKeyIntent\n    \n    1) Explicityly set  component after target activity check.\n    2) Update Intent subclass check.\n    \n    Bug: 360846772\n    Test: manual\n    Flag: EXEMPT bugfix\n    Change-Id: Ied7961c73299681aa5b523cf3f00fd905893116f\n    (cherry picked from commit cde345a7ee06db716e613e12a2c218ce248ad1c4)\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex fe5375233d8f..70f66cae50f0 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4917,6 +4917,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4938,14 +4940,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n                }\n=======\n            Bundle simulateBundle = p.readBundle();\n            p.recycle();\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                    Intent.class);\n            if (intent == null) {\n                return (simulateIntent == null);\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n        }\n=======\n            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n                return false;\n            }\n\n            if (!intent.filterEquals(simulateIntent)) {\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5085,14 +5087,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
                                    "patch_apply_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #1 succeeded at 4899 (offset -163 lines).\nHunk #2 FAILED at 5085.\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/accounts/AccountManagerService.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #2 NOT MERGED at 5302-5312,5314-5322."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "d04cea5ea08f91f55a14209c1e424e163e2d50ab",
                            "result": "failure",
                            "downstream_patch_content": "commit d04cea5ea08f91f55a14209c1e424e163e2d50ab\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Tue Oct 1 14:57:44 2024 -0700\n\n    Update checkKeyIntent\n    \n    1) Explicityly set  component after target activity check.\n    2) Update Intent subclass check.\n    \n    Bug: 360846772\n    Test: manual\n    Flag: EXEMPT bugfix\n    Change-Id: Ied7961c73299681aa5b523cf3f00fd905893116f\n    (cherry picked from commit cde345a7ee06db716e613e12a2c218ce248ad1c4)\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex fe5375233d8f..70f66cae50f0 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4917,6 +4917,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4938,14 +4940,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n            if (intent != null && intent.getClass() != Intent.class) {\n                return false;\n            }\n=======\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5085,14 +5087,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
                                    "patch_apply_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #1 succeeded at 4964 (offset -98 lines).\nHunk #2 FAILED at 5085.\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/accounts/AccountManagerService.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #2 NOT MERGED at 4989-4996, merged at 5002-5005."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-273995284",
            "aliases": [
                "A-273995284",
                "CVE-2025-22435"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-273995284",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "6012433653b2770ddb67f5d6e9042e8ff6f8d66c",
                        "ca504bbacbdb2478cf18103c28ca39915bc352f6"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 6012433653b2770ddb67f5d6e9042e8ff6f8d66c Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Thu, 8 Aug 2024 00:27:51 +0000\nSubject: [PATCH] Fix type confusion in avdt_msg.cc\n\nIt is possible for a malicious user to reply to a pending AVDT message\nwith the wrong type, leading to type confusion and an eventual OOB\naccess.\n\nAdd message type validation.\n\nBug: 273995284\nBug: 358212054\nFlag: com.android.bluetooth.flags.btsec_avdt_msg_ind_type_confusion\nTest: m libbluetooth\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: Iea207e7e5e3d469ccbc81f5abf945723cf7b60d3\n---\n system/stack/avdt/avdt_msg.cc | 11 +++++++++++\n 1 file changed, 11 insertions(+)\n\ndiff --git a/system/stack/avdt/avdt_msg.cc b/system/stack/avdt/avdt_msg.cc\nindex d8d5269340..6d59fbaaf3 100644\n--- a/system/stack/avdt/avdt_msg.cc\n+++ b/system/stack/avdt/avdt_msg.cc\n@@ -29,6 +29,7 @@\n #define LOG_TAG \"bluetooth-a2dp\"\n \n #include <bluetooth/log.h>\n+#include <com_android_bluetooth_flags.h>\n #include <string.h>\n \n #include \"avdt_api.h\"\n@@ -1548,6 +1549,16 @@ void avdt_msg_ind(AvdtpCcb* p_ccb, BT_HDR* p_buf) {\n         avdt_msg_send_grej(p_ccb, sig, &msg);\n       }\n     }\n+\n+    /* validate reject/response against cached sig */\n+    if (com::android::bluetooth::flags::btsec_avdt_msg_ind_type_confusion()) {\n+      if (((msg_type == AVDT_MSG_TYPE_RSP) || (msg_type == AVDT_MSG_TYPE_REJ)) &&\n+          (p_ccb->p_curr_cmd == nullptr || p_ccb->p_curr_cmd->event != sig)) {\n+        log::warn(\"Dropping msg with mismatched sig; sig={} event type={}\", sig,\n+                  p_ccb->p_curr_cmd->event);\n+        ok = false;\n+      }\n+    }\n   }\n \n   log::verbose(\"msg_type={}, sig={}\", msg_type, sig);\n-- \n2.39.5 (Apple Git-154)\n\nFrom ca504bbacbdb2478cf18103c28ca39915bc352f6 Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Thu, 16 Jan 2025 22:09:04 +0000\nSubject: [PATCH] Remove flag\n com.android.bluetooth.flag.btsec_avdt_msg_ind_type_confusion\n\nBug: 358212054\nBug: 315241296\nTest: m libbluetooth\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: I022e46fdd9f4e00ebbaca63273e084384d453ca9\n---\n flags/security.aconfig        | 10 ----------\n system/stack/avdt/avdt_msg.cc | 10 ++++------\n 2 files changed, 4 insertions(+), 16 deletions(-)\n\ndiff --git a/flags/security.aconfig b/flags/security.aconfig\nindex 2723bafa6d..bc8ed543d4 100644\n--- a/flags/security.aconfig\n+++ b/flags/security.aconfig\n@@ -55,16 +55,6 @@ flag {\n   }\n }\n \n-flag {\n-  name: \"btsec_avdt_msg_ind_type_confusion\"\n-  namespace: \"bluetooth\"\n-  description: \"Properly check current state and sig value of avdt rej/rsp messages before parsing\"\n-  bug: \"358212054\"\n-  metadata {\n-    purpose: PURPOSE_BUGFIX\n-  }\n-}\n-\n flag {\n   name: \"btsec_cycle_irks\"\n   namespace: \"bluetooth\"\ndiff --git a/system/stack/avdt/avdt_msg.cc b/system/stack/avdt/avdt_msg.cc\nindex eb623b1b2a..3464fcefc8 100644\n--- a/system/stack/avdt/avdt_msg.cc\n+++ b/system/stack/avdt/avdt_msg.cc\n@@ -1547,12 +1547,10 @@ void avdt_msg_ind(AvdtpCcb* p_ccb, BT_HDR* p_buf) {\n     }\n \n     /* validate reject/response against cached sig */\n-    if (com::android::bluetooth::flags::btsec_avdt_msg_ind_type_confusion()) {\n-      if (((msg_type == AVDT_MSG_TYPE_RSP) || (msg_type == AVDT_MSG_TYPE_REJ)) &&\n-          (p_ccb->p_curr_cmd == nullptr || p_ccb->p_curr_cmd->event != sig)) {\n-        log::warn(\"Dropping msg with mismatched sig; sig={}\", sig);\n-        ok = false;\n-      }\n+    if (((msg_type == AVDT_MSG_TYPE_RSP) || (msg_type == AVDT_MSG_TYPE_REJ)) &&\n+        (p_ccb->p_curr_cmd == nullptr || p_ccb->p_curr_cmd->event != sig)) {\n+      log::warn(\"Dropping msg with mismatched sig; sig={}\", sig);\n+      ok = false;\n     }\n   }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 3,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "80c094a66067efc42837cb8da445de4c3f5b637f"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "359bdee195ff58652663b2721e966b2604a93f94",
                            "result": "failure",
                            "downstream_patch_content": "commit 359bdee195ff58652663b2721e966b2604a93f94\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 11 21:06:29 2024 +0000\n\n    Fix type confusion in avdt_msg.cc\n    \n    It is possible for a malicious user to reply to a pending AVDT message\n    with the wrong type, leading to type confusion and an eventual OOB\n    access.\n    \n    Add message type validation.\n    \n    Bug: 273995284\n    Test: m libbluetooth\n    Ignore-AOSP-First: security\n    Tag: #security\n    Merged-In: I87a0df92710658d6c27d9b63ee7813a0d45a301a\n    Merged-In: Iea207e7e5e3d469ccbc81f5abf945723cf7b60d3\n    Change-Id: I87a0df92710658d6c27d9b63ee7813a0d45a301a\n\ndiff --git a/system/stack/avdt/avdt_msg.cc b/system/stack/avdt/avdt_msg.cc\nindex e6286b8ada..d52dc8e500 100644\n--- a/system/stack/avdt/avdt_msg.cc\n+++ b/system/stack/avdt/avdt_msg.cc\n@@ -1586,6 +1586,14 @@ void avdt_msg_ind(AvdtpCcb* p_ccb, BT_HDR* p_buf) {\n         avdt_msg_send_grej(p_ccb, sig, &msg);\n       }\n     }\n+\n+    /* validate reject/response against cached sig */\n+    if (((msg_type == AVDT_MSG_TYPE_RSP) || (msg_type == AVDT_MSG_TYPE_REJ)) &&\n+        (p_ccb->p_curr_cmd == nullptr || p_ccb->p_curr_cmd->event != sig)) {\n+      AVDT_TRACE_WARNING(\n+          \"Dropping msg with mismatched sig; sig=%d\", sig);\n+      ok = false;\n+    }\n   }\n \n   if (ok && !gen_rej) {\n",
                            "file_conflicts": [
                                {
                                    "file_name": "system/stack/avdt/avdt_msg.cc",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        1,
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n#include <bluetooth/log.h>\n#include <com_android_bluetooth_flags.h>\n>>>>>>> UPSTREAM PATCH (commit 6012433653b2770ddb67f5d6e9042e8ff6f8d66c)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n    if (com::android::bluetooth::flags::btsec_avdt_msg_ind_type_confusion()) {\n      if (((msg_type == AVDT_MSG_TYPE_RSP) || (msg_type == AVDT_MSG_TYPE_REJ)) &&\n          (p_ccb->p_curr_cmd == nullptr || p_ccb->p_curr_cmd->event != sig)) {\n        log::warn(\"Dropping msg with mismatched sig; sig={} event type={}\", sig,\n                  p_ccb->p_curr_cmd->event);\n        ok = false;\n      }\n=======\n    if (((msg_type == AVDT_MSG_TYPE_RSP) || (msg_type == AVDT_MSG_TYPE_REJ)) &&\n        (p_ccb->p_curr_cmd == nullptr || p_ccb->p_curr_cmd->event != sig)) {\n      log::warn(\"Dropping msg with mismatched sig; sig={}\", sig);\n      ok = false;\n>>>>>>> UPSTREAM PATCH (commit 6012433653b2770ddb67f5d6e9042e8ff6f8d66c)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- system/stack/avdt/avdt_msg.cc\n+++ system/stack/avdt/avdt_msg.cc\n@@ -29,6 +29,7 @@\n #define LOG_TAG \"bluetooth-a2dp\"\n \n #include <bluetooth/log.h>\n+#include <com_android_bluetooth_flags.h>\n #include <string.h>\n \n #include \"avdt_api.h\"\n--- system/stack/avdt/avdt_msg.cc\n+++ system/stack/avdt/avdt_msg.cc\n@@ -1547,12 +1547,10 @@ void avdt_msg_ind(AvdtpCcb* p_ccb, BT_HDR* p_buf) {\n     }\n \n     /* validate reject/response against cached sig */\n-    if (com::android::bluetooth::flags::btsec_avdt_msg_ind_type_confusion()) {\n-      if (((msg_type == AVDT_MSG_TYPE_RSP) || (msg_type == AVDT_MSG_TYPE_REJ)) &&\n-          (p_ccb->p_curr_cmd == nullptr || p_ccb->p_curr_cmd->event != sig)) {\n-        log::warn(\"Dropping msg with mismatched sig; sig={}\", sig);\n-        ok = false;\n-      }\n+    if (((msg_type == AVDT_MSG_TYPE_RSP) || (msg_type == AVDT_MSG_TYPE_REJ)) &&\n+        (p_ccb->p_curr_cmd == nullptr || p_ccb->p_curr_cmd->event != sig)) {\n+      log::warn(\"Dropping msg with mismatched sig; sig={}\", sig);\n+      ok = false;\n     }\n   }\n```",
                                    "patch_apply_output": "patching file system/stack/avdt/avdt_msg.cc\nHunk #1 FAILED at 29.\nHunk #2 succeeded at 1580 with fuzz 1 (offset 32 lines).\n1 out of 2 hunks FAILED -- saving rejects to file system/stack/avdt/avdt_msg.cc.rej\npatching file system/stack/avdt/avdt_msg.cc\nHunk #1 FAILED at 1547.\n1 out of 1 hunk FAILED -- saving rejects to file system/stack/avdt/avdt_msg.cc.rej",
                                    "inline_merge_output": "patching file system/stack/avdt/avdt_msg.cc\nHunk #1 NOT MERGED at 31-35.\nHunk #2 merged at 1588-1597.\npatching file system/stack/avdt/avdt_msg.cc\nHunk #1 NOT MERGED at 1590-1603."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "359bdee195ff58652663b2721e966b2604a93f94",
                            "result": "failure",
                            "downstream_patch_content": "commit 359bdee195ff58652663b2721e966b2604a93f94\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 11 21:06:29 2024 +0000\n\n    Fix type confusion in avdt_msg.cc\n    \n    It is possible for a malicious user to reply to a pending AVDT message\n    with the wrong type, leading to type confusion and an eventual OOB\n    access.\n    \n    Add message type validation.\n    \n    Bug: 273995284\n    Test: m libbluetooth\n    Ignore-AOSP-First: security\n    Tag: #security\n    Merged-In: I87a0df92710658d6c27d9b63ee7813a0d45a301a\n    Merged-In: Iea207e7e5e3d469ccbc81f5abf945723cf7b60d3\n    Change-Id: I87a0df92710658d6c27d9b63ee7813a0d45a301a\n\ndiff --git a/system/stack/avdt/avdt_msg.cc b/system/stack/avdt/avdt_msg.cc\nindex e6286b8ada..d52dc8e500 100644\n--- a/system/stack/avdt/avdt_msg.cc\n+++ b/system/stack/avdt/avdt_msg.cc\n@@ -1586,6 +1586,14 @@ void avdt_msg_ind(AvdtpCcb* p_ccb, BT_HDR* p_buf) {\n         avdt_msg_send_grej(p_ccb, sig, &msg);\n       }\n     }\n+\n+    /* validate reject/response against cached sig */\n+    if (((msg_type == AVDT_MSG_TYPE_RSP) || (msg_type == AVDT_MSG_TYPE_REJ)) &&\n+        (p_ccb->p_curr_cmd == nullptr || p_ccb->p_curr_cmd->event != sig)) {\n+      AVDT_TRACE_WARNING(\n+          \"Dropping msg with mismatched sig; sig=%d\", sig);\n+      ok = false;\n+    }\n   }\n \n   if (ok && !gen_rej) {\n",
                            "file_conflicts": [
                                {
                                    "file_name": "system/stack/avdt/avdt_msg.cc",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        1,
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n#include <bluetooth/log.h>\n#include <com_android_bluetooth_flags.h>\n>>>>>>> UPSTREAM PATCH (commit 6012433653b2770ddb67f5d6e9042e8ff6f8d66c)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n    if (com::android::bluetooth::flags::btsec_avdt_msg_ind_type_confusion()) {\n      if (((msg_type == AVDT_MSG_TYPE_RSP) || (msg_type == AVDT_MSG_TYPE_REJ)) &&\n          (p_ccb->p_curr_cmd == nullptr || p_ccb->p_curr_cmd->event != sig)) {\n        log::warn(\"Dropping msg with mismatched sig; sig={} event type={}\", sig,\n                  p_ccb->p_curr_cmd->event);\n        ok = false;\n      }\n=======\n    if (((msg_type == AVDT_MSG_TYPE_RSP) || (msg_type == AVDT_MSG_TYPE_REJ)) &&\n        (p_ccb->p_curr_cmd == nullptr || p_ccb->p_curr_cmd->event != sig)) {\n      log::warn(\"Dropping msg with mismatched sig; sig={}\", sig);\n      ok = false;\n>>>>>>> UPSTREAM PATCH (commit 6012433653b2770ddb67f5d6e9042e8ff6f8d66c)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- system/stack/avdt/avdt_msg.cc\n+++ system/stack/avdt/avdt_msg.cc\n@@ -29,6 +29,7 @@\n #define LOG_TAG \"bluetooth-a2dp\"\n \n #include <bluetooth/log.h>\n+#include <com_android_bluetooth_flags.h>\n #include <string.h>\n \n #include \"avdt_api.h\"\n--- system/stack/avdt/avdt_msg.cc\n+++ system/stack/avdt/avdt_msg.cc\n@@ -1547,12 +1547,10 @@ void avdt_msg_ind(AvdtpCcb* p_ccb, BT_HDR* p_buf) {\n     }\n \n     /* validate reject/response against cached sig */\n-    if (com::android::bluetooth::flags::btsec_avdt_msg_ind_type_confusion()) {\n-      if (((msg_type == AVDT_MSG_TYPE_RSP) || (msg_type == AVDT_MSG_TYPE_REJ)) &&\n-          (p_ccb->p_curr_cmd == nullptr || p_ccb->p_curr_cmd->event != sig)) {\n-        log::warn(\"Dropping msg with mismatched sig; sig={}\", sig);\n-        ok = false;\n-      }\n+    if (((msg_type == AVDT_MSG_TYPE_RSP) || (msg_type == AVDT_MSG_TYPE_REJ)) &&\n+        (p_ccb->p_curr_cmd == nullptr || p_ccb->p_curr_cmd->event != sig)) {\n+      log::warn(\"Dropping msg with mismatched sig; sig={}\", sig);\n+      ok = false;\n     }\n   }\n```",
                                    "patch_apply_output": "patching file system/stack/avdt/avdt_msg.cc\nHunk #1 FAILED at 29.\nHunk #2 succeeded at 1580 with fuzz 1 (offset 32 lines).\n1 out of 2 hunks FAILED -- saving rejects to file system/stack/avdt/avdt_msg.cc.rej\npatching file system/stack/avdt/avdt_msg.cc\nHunk #1 FAILED at 1547.\n1 out of 1 hunk FAILED -- saving rejects to file system/stack/avdt/avdt_msg.cc.rej",
                                    "inline_merge_output": "patching file system/stack/avdt/avdt_msg.cc\nHunk #1 NOT MERGED at 31-35.\nHunk #2 merged at 1588-1597.\npatching file system/stack/avdt/avdt_msg.cc\nHunk #1 NOT MERGED at 1590-1603."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-369351375",
            "aliases": [
                "A-369351375",
                "CVE-2024-49724"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-369351375",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "cde345a7ee06db716e613e12a2c218ce248ad1c4"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From cde345a7ee06db716e613e12a2c218ce248ad1c4 Mon Sep 17 00:00:00 2001\nFrom: Dmitry Dementyev <dementyev@google.com>\nDate: Tue, 1 Oct 2024 14:57:44 -0700\nSubject: [PATCH] Update checkKeyIntent\n\n1) Explicityly set  component after target activity check.\n2) Update Intent subclass check.\n\nBug: 360846772\nTest: manual\nFlag: EXEMPT bugfix\nChange-Id: Ied7961c73299681aa5b523cf3f00fd905893116f\n---\n .../android/server/accounts/AccountManagerService.java   | 9 ++++++---\n 1 file changed, 6 insertions(+), 3 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 3499a3a5edde..0ca3b56486e3 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5062,6 +5062,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -5083,14 +5085,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 0,
                    "failed_patches": 4,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "185048041e6f9d43c38829c09965e7a4740d2a6a",
                            "result": "failure",
                            "downstream_patch_content": "commit 185048041e6f9d43c38829c09965e7a4740d2a6a\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Wed Oct 16 15:01:59 2024 -0700\n\n    Update checkKeyIntent\n    \n    1) Explicityly set  component after target activity check.\n    2) Update Intent subclass check.\n    \n    Bug: 360846772\n    Test: manual\n    Flag: EXEMPT bugfix\n    \n    Merged-In: Ied7961c73299681aa5b523cf3f00fd905893116f\n    Change-Id: Iafc1e2260107f7ecc18c90ce12f8987b4fc76350\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 36ffc40bf5f7..5f434ee267d4 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n                }\n=======\n            Bundle simulateBundle = p.readBundle();\n            p.recycle();\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                    Intent.class);\n            if (intent == null) {\n                return (simulateIntent == null);\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n        }\n=======\n            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n                return false;\n            }\n\n            if (!intent.filterEquals(simulateIntent)) {\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5085,14 +5087,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
                                    "patch_apply_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #1 succeeded at 4886 (offset -176 lines).\nHunk #2 FAILED at 5085.\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/accounts/AccountManagerService.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #2 NOT MERGED at 5289-5299,5301-5309."
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "185048041e6f9d43c38829c09965e7a4740d2a6a",
                            "result": "failure",
                            "downstream_patch_content": "commit 185048041e6f9d43c38829c09965e7a4740d2a6a\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Wed Oct 16 15:01:59 2024 -0700\n\n    Update checkKeyIntent\n    \n    1) Explicityly set  component after target activity check.\n    2) Update Intent subclass check.\n    \n    Bug: 360846772\n    Test: manual\n    Flag: EXEMPT bugfix\n    \n    Merged-In: Ied7961c73299681aa5b523cf3f00fd905893116f\n    Change-Id: Iafc1e2260107f7ecc18c90ce12f8987b4fc76350\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 36ffc40bf5f7..5f434ee267d4 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n                }\n=======\n            Bundle simulateBundle = p.readBundle();\n            p.recycle();\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                    Intent.class);\n            if (intent == null) {\n                return (simulateIntent == null);\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n        }\n=======\n            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n                return false;\n            }\n\n            if (!intent.filterEquals(simulateIntent)) {\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5085,14 +5087,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
                                    "patch_apply_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #1 succeeded at 4886 (offset -176 lines).\nHunk #2 FAILED at 5085.\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/accounts/AccountManagerService.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #2 NOT MERGED at 5289-5299,5301-5309."
                                }
                            ]
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "0397dd35e6cc696b0ea3949c5d29f90b42a0ce59"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "d04cea5ea08f91f55a14209c1e424e163e2d50ab",
                            "result": "failure",
                            "downstream_patch_content": "commit d04cea5ea08f91f55a14209c1e424e163e2d50ab\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Tue Oct 1 14:57:44 2024 -0700\n\n    Update checkKeyIntent\n    \n    1) Explicityly set  component after target activity check.\n    2) Update Intent subclass check.\n    \n    Bug: 360846772\n    Test: manual\n    Flag: EXEMPT bugfix\n    Change-Id: Ied7961c73299681aa5b523cf3f00fd905893116f\n    (cherry picked from commit cde345a7ee06db716e613e12a2c218ce248ad1c4)\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex fe5375233d8f..70f66cae50f0 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4917,6 +4917,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4938,14 +4940,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n                }\n=======\n            Bundle simulateBundle = p.readBundle();\n            p.recycle();\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                    Intent.class);\n            if (intent == null) {\n                return (simulateIntent == null);\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n        }\n=======\n            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n                return false;\n            }\n\n            if (!intent.filterEquals(simulateIntent)) {\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5085,14 +5087,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
                                    "patch_apply_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #1 succeeded at 4899 (offset -163 lines).\nHunk #2 FAILED at 5085.\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/accounts/AccountManagerService.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #2 NOT MERGED at 5302-5312,5314-5322."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "d04cea5ea08f91f55a14209c1e424e163e2d50ab",
                            "result": "failure",
                            "downstream_patch_content": "commit d04cea5ea08f91f55a14209c1e424e163e2d50ab\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Tue Oct 1 14:57:44 2024 -0700\n\n    Update checkKeyIntent\n    \n    1) Explicityly set  component after target activity check.\n    2) Update Intent subclass check.\n    \n    Bug: 360846772\n    Test: manual\n    Flag: EXEMPT bugfix\n    Change-Id: Ied7961c73299681aa5b523cf3f00fd905893116f\n    (cherry picked from commit cde345a7ee06db716e613e12a2c218ce248ad1c4)\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex fe5375233d8f..70f66cae50f0 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4917,6 +4917,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4938,14 +4940,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n",
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n            if (intent != null && intent.getClass() != Intent.class) {\n                return false;\n            }\n=======\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5085,14 +5087,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
                                    "patch_apply_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #1 succeeded at 4964 (offset -98 lines).\nHunk #2 FAILED at 5085.\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/accounts/AccountManagerService.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #2 NOT MERGED at 4989-4996, merged at 5002-5005."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-289375038",
            "aliases": [
                "A-289375038",
                "CVE-2025-0092"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-289375038",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "771aed3ea225d9ca2ef91e88f45f330ced952772"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 771aed3ea225d9ca2ef91e88f45f330ced952772 Mon Sep 17 00:00:00 2001\nFrom: Kyunglyul Hyun <klhyun@google.com>\nDate: Wed, 2 Oct 2024 03:50:00 +0000\nSubject: [PATCH] Reset permissions for not bonded device\n\nAccording to the PBAP specification,\nThe PSE user shall have to confirm at least the first Phone Book Access\nProfile connection from each new PCE.\n\nAccording to the MAP specification,\nThe MCE and MSE shall be bonded before setting up a Message Access Profile\nconnection.\n\nLet's remove the permissions when the device is unbonded.\n\nFlag: EXEMPT, security fix\nBug: 289375038\nBug: 289811388\nTest: atest BluetoothInstrumentationTests\nIgnore-AOSP-First: security fix\n\nChange-Id: I94478a4a45a434732d4bc4810da31ef45ef891af\n---\n .../com/android/bluetooth/btservice/AdapterService.java   | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\ndiff --git a/android/app/src/com/android/bluetooth/btservice/AdapterService.java b/android/app/src/com/android/bluetooth/btservice/AdapterService.java\nindex 19c8aee207..3937a8e881 100644\n--- a/android/app/src/com/android/bluetooth/btservice/AdapterService.java\n+++ b/android/app/src/com/android/bluetooth/btservice/AdapterService.java\n@@ -27,6 +27,7 @@ import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\n import static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n@@ -6121,6 +6122,13 @@ public class AdapterService extends Service {\n             mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n         }\n         mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n+\n+        if (toState == BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n     }\n \n     static int convertScanModeToHal(int mode) {\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12-release: Command '['git', 'checkout', 'android12-release']' returned non-zero exit status 1.",
                            "downstream_patch": "e3be5a26db30094f034a543ac60e6ff5da497bd7"
                        },
                        {
                            "downstream_version": "12L",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12L-release: Command '['git', 'checkout', 'android12L-release']' returned non-zero exit status 1.",
                            "downstream_patch": "e3be5a26db30094f034a543ac60e6ff5da497bd7"
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "8ef714b803127ca193773c6d032457c01c1963d6"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "038b1e8626399ff3f374d5af987e3efd64a19321",
                            "result": "failure",
                            "downstream_patch_content": "commit 038b1e8626399ff3f374d5af987e3efd64a19321\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Thu Nov 14 00:35:48 2024 +0000\n\n    Reset permissions for not bonded device\n    \n    According to the PBAP specification,\n    The PSE user shall have to confirm at least the first Phone Book Access\n    Profile connection from each new PCE.\n    \n    According to the MAP specification,\n    The MCE and MSE shall be bonded before setting up a Message Access Profile\n    connection.\n    \n    Let's remove the permissions when the device is unbonded.\n    \n    This is a backport of change ag/30386015 but requires minor changes to\n    logic.\n    \n    Flag: EXEMPT, security fix\n    Bug: 289375038\n    Bug: 289811388\n    Test: atest BluetoothInstrumentationTests\n    Ignore-AOSP-First: security fix\n    Merged-In: I94478a4a45a434732d4bc4810da31ef45ef891af\n    Change-Id: I8b9b29310db2d14e5dfaddc81a682366fbef42d3\n\ndiff --git a/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java b/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\nindex d62d7ba06d..1a1c912f3f 100644\n--- a/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\n+++ b/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\n@@ -439,6 +439,13 @@ final class BondStateMachine extends StateMachine {\n             }\n         }\n \n+        if (newState == BluetoothDevice.BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            mAdapterService.setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            mAdapterService.setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            mAdapterService.setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n+\n         Intent intent = new Intent(BluetoothDevice.ACTION_BOND_STATE_CHANGED);\n         intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);\n         intent.putExtra(BluetoothDevice.EXTRA_BOND_STATE, newState);\n",
                            "file_conflicts": [
                                {
                                    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\nimport static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\nimport static android.bluetooth.BluetoothDevice.BOND_NONE;\n>>>>>>> UPSTREAM PATCH (commit 771aed3ea225d9ca2ef91e88f45f330ced952772)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n        mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n\n        if (toState == BOND_NONE) {\n            // Remove the permissions for unbonded devices\n            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n        }\n>>>>>>> UPSTREAM PATCH (commit 771aed3ea225d9ca2ef91e88f45f330ced952772)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- android/app/src/com/android/bluetooth/btservice/AdapterService.java\n+++ android/app/src/com/android/bluetooth/btservice/AdapterService.java\n@@ -27,6 +27,7 @@ import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\n import static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n@@ -6121,6 +6122,13 @@ public class AdapterService extends Service {\n             mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n         }\n         mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n+\n+        if (toState == BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n     }\n \n     static int convertScanModeToHal(int mode) {\n```",
                                    "patch_apply_output": "patching file android/app/src/com/android/bluetooth/btservice/AdapterService.java\nHunk #1 FAILED at 27.\nHunk #2 FAILED at 6121.\n2 out of 2 hunks FAILED -- saving rejects to file android/app/src/com/android/bluetooth/btservice/AdapterService.java.rej",
                                    "inline_merge_output": "patching file android/app/src/com/android/bluetooth/btservice/AdapterService.java\nHunk #1 NOT MERGED at 19-25.\nHunk #2 NOT MERGED at 5338-5348."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "038b1e8626399ff3f374d5af987e3efd64a19321",
                            "result": "failure",
                            "downstream_patch_content": "commit 038b1e8626399ff3f374d5af987e3efd64a19321\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Thu Nov 14 00:35:48 2024 +0000\n\n    Reset permissions for not bonded device\n    \n    According to the PBAP specification,\n    The PSE user shall have to confirm at least the first Phone Book Access\n    Profile connection from each new PCE.\n    \n    According to the MAP specification,\n    The MCE and MSE shall be bonded before setting up a Message Access Profile\n    connection.\n    \n    Let's remove the permissions when the device is unbonded.\n    \n    This is a backport of change ag/30386015 but requires minor changes to\n    logic.\n    \n    Flag: EXEMPT, security fix\n    Bug: 289375038\n    Bug: 289811388\n    Test: atest BluetoothInstrumentationTests\n    Ignore-AOSP-First: security fix\n    Merged-In: I94478a4a45a434732d4bc4810da31ef45ef891af\n    Change-Id: I8b9b29310db2d14e5dfaddc81a682366fbef42d3\n\ndiff --git a/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java b/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\nindex d62d7ba06d..1a1c912f3f 100644\n--- a/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\n+++ b/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\n@@ -439,6 +439,13 @@ final class BondStateMachine extends StateMachine {\n             }\n         }\n \n+        if (newState == BluetoothDevice.BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            mAdapterService.setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            mAdapterService.setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            mAdapterService.setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n+\n         Intent intent = new Intent(BluetoothDevice.ACTION_BOND_STATE_CHANGED);\n         intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);\n         intent.putExtra(BluetoothDevice.EXTRA_BOND_STATE, newState);\n",
                            "file_conflicts": [
                                {
                                    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\nimport static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\nimport static android.bluetooth.BluetoothDevice.BOND_NONE;\n>>>>>>> UPSTREAM PATCH (commit 771aed3ea225d9ca2ef91e88f45f330ced952772)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n        mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n\n        if (toState == BOND_NONE) {\n            // Remove the permissions for unbonded devices\n            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n        }\n>>>>>>> UPSTREAM PATCH (commit 771aed3ea225d9ca2ef91e88f45f330ced952772)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- android/app/src/com/android/bluetooth/btservice/AdapterService.java\n+++ android/app/src/com/android/bluetooth/btservice/AdapterService.java\n@@ -27,6 +27,7 @@ import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\n import static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n@@ -6121,6 +6122,13 @@ public class AdapterService extends Service {\n             mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n         }\n         mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n+\n+        if (toState == BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n     }\n \n     static int convertScanModeToHal(int mode) {\n```",
                                    "patch_apply_output": "patching file android/app/src/com/android/bluetooth/btservice/AdapterService.java\nHunk #1 FAILED at 27.\nHunk #2 FAILED at 6121.\n2 out of 2 hunks FAILED -- saving rejects to file android/app/src/com/android/bluetooth/btservice/AdapterService.java.rej",
                                    "inline_merge_output": "patching file android/app/src/com/android/bluetooth/btservice/AdapterService.java\nHunk #1 NOT MERGED at 20-26.\nHunk #2 NOT MERGED at 6060-6070."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-364025411",
            "aliases": [
                "A-364025411",
                "CVE-2024-49748"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-364025411",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "7de5617f7d5266fe57c990c428621b5d4e92728a"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 7de5617f7d5266fe57c990c428621b5d4e92728a Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Thu, 12 Sep 2024 17:26:55 +0000\nSubject: [PATCH] Fix OOB writes in gatt_sr.cc\n\nAt various points in gatt_sr.cc, the output of the\ngatt_tcb_get_payload_size function is used without checking for a\npositive length.  However, in exceptional cases it is possible for the\nchannel to be closed at the time the function is called, which will lead\nto a zero length and cause an OOB write in subsequent processing.\n\nFix all of these.\n\nBug: 364026473\nBug: 364027038\nBug: 364027949\nBug: 364025411\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial validity checks\nTag: #security\nIgnore-AOSP-First: Security\nChange-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n---\n system/stack/gatt/gatt_sr.cc | 21 +++++++++++++++++++++\n 1 file changed, 21 insertions(+)\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 995ea810cb..0235ba964e 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n@@ -949,6 +960,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid, uint8_t\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1096,6 +1112,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12-release: Command '['git', 'checkout', 'android12-release']' returned non-zero exit status 1.",
                            "downstream_patch": "7e5f45df8880293e1ab40367670d1a8959a542f9"
                        },
                        {
                            "downstream_version": "12L",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12L-release: Command '['git', 'checkout', 'android12L-release']' returned non-zero exit status 1.",
                            "downstream_patch": "7e5f45df8880293e1ab40367670d1a8959a542f9"
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "84ea459acaf3c6e7215e044e59dc3e9187f1f7b8"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "2fc3087b9ac3019518c6ceb8a64d181d6bb04907",
                            "result": "failure",
                            "downstream_patch_content": "commit 2fc3087b9ac3019518c6ceb8a64d181d6bb04907\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 4 18:23:45 2024 +0000\n\n    Fix OOB writes in gatt_sr.cc\n    \n    At various points in gatt_sr.cc, the output of the\n    gatt_tcb_get_payload_size function is used without checking for a\n    positive length.  However, in exceptional cases it is possible for the\n    channel to be closed at the time the function is called, which will lead\n    to a zero length and cause an OOB write in subsequent processing.\n    \n    Fix all of these.\n    \n    Bug: 364026473\n    Bug: 364027038\n    Bug: 364027949\n    Bug: 364025411\n    Test: m libbluetooth\n    Test: researcher POC\n    Flag: EXEMPT trivial validity checks\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n    Change-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n",
                            "file_conflicts": [
                                {
                                    "file_name": "system/stack/gatt/gatt_sr.cc",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n=======\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n=======\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 3,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 4,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- system/stack/gatt/gatt_sr.cc\n+++ system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
                                    "patch_apply_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 FAILED at 772.\nHunk #2 FAILED at 804.\nHunk #3 succeeded at 886 with fuzz 2 (offset -63 lines).\nHunk #4 succeeded at 1038 with fuzz 2 (offset -63 lines).\n2 out of 4 hunks FAILED -- saving rejects to file system/stack/gatt/gatt_sr.cc.rej",
                                    "inline_merge_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 NOT MERGED at 889-898.\nHunk #2 NOT MERGED at 900-913.\nHunk #3 NOT MERGED at 1074-1083.\nHunk #4 NOT MERGED at 1128-1140."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "2fc3087b9ac3019518c6ceb8a64d181d6bb04907",
                            "result": "failure",
                            "downstream_patch_content": "commit 2fc3087b9ac3019518c6ceb8a64d181d6bb04907\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 4 18:23:45 2024 +0000\n\n    Fix OOB writes in gatt_sr.cc\n    \n    At various points in gatt_sr.cc, the output of the\n    gatt_tcb_get_payload_size function is used without checking for a\n    positive length.  However, in exceptional cases it is possible for the\n    channel to be closed at the time the function is called, which will lead\n    to a zero length and cause an OOB write in subsequent processing.\n    \n    Fix all of these.\n    \n    Bug: 364026473\n    Bug: 364027038\n    Bug: 364027949\n    Bug: 364025411\n    Test: m libbluetooth\n    Test: researcher POC\n    Flag: EXEMPT trivial validity checks\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n    Change-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n",
                            "file_conflicts": [
                                {
                                    "file_name": "system/stack/gatt/gatt_sr.cc",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n=======\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n=======\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 3,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 4,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- system/stack/gatt/gatt_sr.cc\n+++ system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
                                    "patch_apply_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 FAILED at 772.\nHunk #2 FAILED at 804.\nHunk #3 succeeded at 902 with fuzz 2 (offset -47 lines).\nHunk #4 succeeded at 1054 with fuzz 2 (offset -47 lines).\n2 out of 4 hunks FAILED -- saving rejects to file system/stack/gatt/gatt_sr.cc.rej",
                                    "inline_merge_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 NOT MERGED at 905-914.\nHunk #2 NOT MERGED at 916-929.\nHunk #3 NOT MERGED at 1089-1098.\nHunk #4 NOT MERGED at 1127-1139."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-375398779",
            "aliases": [
                "A-375398779",
                "CVE-2025-22411"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375398779",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "00555617ddbbc1a19089104c084d14f465c971ce"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 00555617ddbbc1a19089104c084d14f465c971ce Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Sat, 2 Nov 2024 02:29:10 +0000\nSubject: [PATCH] Fix more memory-unsafe logging\n\nIn various locations around the stack, log statements use structures that\nmay, in exceptional cases, have been freed by preceding calls.  This can\nlead to use after free and potentially to security vulnerabilities.\n\nUse local variables instead, or store the length before the call if no\nlocal variable is already convenient.\n\nBug: 375404242\nBug: 375398779\nBug: 375397720\nBug: 375397164\nBug: 375397370\nBug: 375396810\nBug: 375159652\nBug: 375160214\nBug: 375159480\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: Ia50e074de751661a0e617bfffa17871497b8d1ea\n---\n system/stack/avct/avct_lcb_act.cc    | 5 ++++-\n system/stack/bnep/bnep_main.cc       | 4 +++-\n system/stack/bnep/bnep_utils.cc      | 3 ++-\n system/stack/hid/hidd_conn.cc        | 4 ++--\n system/stack/rfcomm/rfc_ts_frames.cc | 3 ++-\n system/stack/rfcomm/rfc_utils.cc     | 3 ++-\n system/stack/sdp/sdp_discovery.cc    | 2 +-\n system/stack/sdp/sdp_server.cc       | 4 ++--\n 8 files changed, 18 insertions(+), 10 deletions(-)\n\ndiff --git a/system/stack/avct/avct_lcb_act.cc b/system/stack/avct/avct_lcb_act.cc\nindex 986bce7d34..32da9d865b 100644\n--- a/system/stack/avct/avct_lcb_act.cc\n+++ b/system/stack/avct/avct_lcb_act.cc\n@@ -727,10 +727,13 @@ void avct_lcb_msg_ind(tAVCT_LCB* p_lcb, tAVCT_LCB_EVT* p_data) {\n     p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n     AVCT_BUILD_HDR(p, label, AVCT_PKT_TYPE_SINGLE, AVCT_REJ);\n     UINT16_TO_BE_STREAM(p, pid);\n+\n+    uint16_t len = p_buf->len;\n+\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_lcb->ch_lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} lcid:0x{:04x} len:{}\", p_lcb->peer_addr,\n-                p_lcb->ch_lcid, p_buf->len);\n+                p_lcb->ch_lcid, len);\n     }\n   }\n }\ndiff --git a/system/stack/bnep/bnep_main.cc b/system/stack/bnep/bnep_main.cc\nindex e0e3c4540c..adf3c8666e 100644\n--- a/system/stack/bnep/bnep_main.cc\n+++ b/system/stack/bnep/bnep_main.cc\n@@ -295,10 +295,12 @@ static void bnep_congestion_ind(uint16_t l2cap_cid, bool is_congested) {\n         break;\n       }\n \n+      uint16_t len = p_buf->len;\n+\n       if (stack::l2cap::get_interface().L2CA_DataWrite(l2cap_cid, p_buf) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n         log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda, l2cap_cid,\n-                  p_buf->len);\n+                  len);\n       }\n     }\n   }\ndiff --git a/system/stack/bnep/bnep_utils.cc b/system/stack/bnep/bnep_utils.cc\nindex 252facf668..4092d9afee 100644\n--- a/system/stack/bnep/bnep_utils.cc\n+++ b/system/stack/bnep/bnep_utils.cc\n@@ -411,10 +411,11 @@ void bnepu_check_send_packet(tBNEP_CONN* p_bcb, BT_HDR* p_buf) {\n       fixed_queue_enqueue(p_bcb->xmit_q, p_buf);\n     }\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_bcb->l2cap_cid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda,\n-                p_bcb->l2cap_cid, p_buf->len);\n+                p_bcb->l2cap_cid, len);\n     }\n   }\n }\ndiff --git a/system/stack/hid/hidd_conn.cc b/system/stack/hid/hidd_conn.cc\nindex c64a7b9104..695e5d6c84 100644\n--- a/system/stack/hid/hidd_conn.cc\n+++ b/system/stack/hid/hidd_conn.cc\n@@ -88,10 +88,10 @@ static void hidd_check_config_done() {\n \n     // send outstanding data on intr\n     if (hd_cb.pending_data) {\n+      uint16_t len = hd_cb.pending_data->len;\n       if (stack::l2cap::get_interface().L2CA_DataWrite(p_hcon->intr_cid, hd_cb.pending_data) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n-        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid,\n-                  hd_cb.pending_data->len);\n+        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid, len);\n       }\n       hd_cb.pending_data = NULL;\n     }\ndiff --git a/system/stack/rfcomm/rfc_ts_frames.cc b/system/stack/rfcomm/rfc_ts_frames.cc\nindex ea57abf6dc..e93cfed9b8 100644\n--- a/system/stack/rfcomm/rfc_ts_frames.cc\n+++ b/system/stack/rfcomm/rfc_ts_frames.cc\n@@ -201,10 +201,11 @@ void rfc_send_buf_uih(tRFC_MCB* p_mcb, uint8_t dlci, BT_HDR* p_buf) {\n   if (dlci == RFCOMM_MX_DLCI) {\n     rfc_check_send_cmd(p_mcb, p_buf);\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p_buf->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/rfcomm/rfc_utils.cc b/system/stack/rfcomm/rfc_utils.cc\nindex 23420892cb..0c5074db76 100644\n--- a/system/stack/rfcomm/rfc_utils.cc\n+++ b/system/stack/rfcomm/rfc_utils.cc\n@@ -428,9 +428,10 @@ void rfc_check_send_cmd(tRFC_MCB* p_mcb, BT_HDR* p_buf) {\n     if (p == NULL) {\n       break;\n     }\n+    uint16_t len = p->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p) != tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/sdp/sdp_discovery.cc b/system/stack/sdp/sdp_discovery.cc\nindex 4fa484e14a..6aba1993af 100644\n--- a/system/stack/sdp/sdp_discovery.cc\n+++ b/system/stack/sdp/sdp_discovery.cc\n@@ -877,7 +877,7 @@ static void process_service_attr_rsp(tCONN_CB* p_ccb, uint8_t* p_reply, uint8_t*\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_msg) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-                p_ccb->connection_id, p_msg->len);\n+                p_ccb->connection_id, p - p_start);\n     }\n \n     /* Start inactivity timer */\ndiff --git a/system/stack/sdp/sdp_server.cc b/system/stack/sdp/sdp_server.cc\nindex abd70aedb1..0f379708e9 100644\n--- a/system/stack/sdp/sdp_server.cc\n+++ b/system/stack/sdp/sdp_server.cc\n@@ -300,7 +300,7 @@ static void process_service_search(tCONN_CB* p_ccb, uint16_t trans_num, uint16_t\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n@@ -564,7 +564,7 @@ static void process_service_attr_req(tCONN_CB* p_ccb, uint16_t trans_num, uint16\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "43cfd234de9ba9557118b0014513269cc1aeefda"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-364027949",
            "aliases": [
                "A-364027949",
                "CVE-2024-43771"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-364027949",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "7de5617f7d5266fe57c990c428621b5d4e92728a"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 7de5617f7d5266fe57c990c428621b5d4e92728a Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Thu, 12 Sep 2024 17:26:55 +0000\nSubject: [PATCH] Fix OOB writes in gatt_sr.cc\n\nAt various points in gatt_sr.cc, the output of the\ngatt_tcb_get_payload_size function is used without checking for a\npositive length.  However, in exceptional cases it is possible for the\nchannel to be closed at the time the function is called, which will lead\nto a zero length and cause an OOB write in subsequent processing.\n\nFix all of these.\n\nBug: 364026473\nBug: 364027038\nBug: 364027949\nBug: 364025411\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial validity checks\nTag: #security\nIgnore-AOSP-First: Security\nChange-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n---\n system/stack/gatt/gatt_sr.cc | 21 +++++++++++++++++++++\n 1 file changed, 21 insertions(+)\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 995ea810cb..0235ba964e 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n@@ -949,6 +960,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid, uint8_t\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1096,6 +1112,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "total_versions_tested": 5,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12-release: Command '['git', 'checkout', 'android12-release']' returned non-zero exit status 1.",
                            "downstream_patch": "7e5f45df8880293e1ab40367670d1a8959a542f9"
                        },
                        {
                            "downstream_version": "12L",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12L-release: Command '['git', 'checkout', 'android12L-release']' returned non-zero exit status 1.",
                            "downstream_patch": "7e5f45df8880293e1ab40367670d1a8959a542f9"
                        },
                        {
                            "downstream_version": "15",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "84ea459acaf3c6e7215e044e59dc3e9187f1f7b8"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "2fc3087b9ac3019518c6ceb8a64d181d6bb04907",
                            "result": "failure",
                            "downstream_patch_content": "commit 2fc3087b9ac3019518c6ceb8a64d181d6bb04907\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 4 18:23:45 2024 +0000\n\n    Fix OOB writes in gatt_sr.cc\n    \n    At various points in gatt_sr.cc, the output of the\n    gatt_tcb_get_payload_size function is used without checking for a\n    positive length.  However, in exceptional cases it is possible for the\n    channel to be closed at the time the function is called, which will lead\n    to a zero length and cause an OOB write in subsequent processing.\n    \n    Fix all of these.\n    \n    Bug: 364026473\n    Bug: 364027038\n    Bug: 364027949\n    Bug: 364025411\n    Test: m libbluetooth\n    Test: researcher POC\n    Flag: EXEMPT trivial validity checks\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n    Change-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n",
                            "file_conflicts": [
                                {
                                    "file_name": "system/stack/gatt/gatt_sr.cc",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n=======\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n=======\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 3,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 4,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- system/stack/gatt/gatt_sr.cc\n+++ system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
                                    "patch_apply_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 FAILED at 772.\nHunk #2 FAILED at 804.\nHunk #3 succeeded at 886 with fuzz 2 (offset -63 lines).\nHunk #4 succeeded at 1038 with fuzz 2 (offset -63 lines).\n2 out of 4 hunks FAILED -- saving rejects to file system/stack/gatt/gatt_sr.cc.rej",
                                    "inline_merge_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 NOT MERGED at 889-898.\nHunk #2 NOT MERGED at 900-913.\nHunk #3 NOT MERGED at 1074-1083.\nHunk #4 NOT MERGED at 1128-1140."
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "2fc3087b9ac3019518c6ceb8a64d181d6bb04907",
                            "result": "failure",
                            "downstream_patch_content": "commit 2fc3087b9ac3019518c6ceb8a64d181d6bb04907\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 4 18:23:45 2024 +0000\n\n    Fix OOB writes in gatt_sr.cc\n    \n    At various points in gatt_sr.cc, the output of the\n    gatt_tcb_get_payload_size function is used without checking for a\n    positive length.  However, in exceptional cases it is possible for the\n    channel to be closed at the time the function is called, which will lead\n    to a zero length and cause an OOB write in subsequent processing.\n    \n    Fix all of these.\n    \n    Bug: 364026473\n    Bug: 364027038\n    Bug: 364027949\n    Bug: 364025411\n    Test: m libbluetooth\n    Test: researcher POC\n    Flag: EXEMPT trivial validity checks\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n    Change-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n",
                            "file_conflicts": [
                                {
                                    "file_name": "system/stack/gatt/gatt_sr.cc",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n=======\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n=======\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 3,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        },
                                        {
                                            "hunk_number": 4,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                                        }
                                    ],
                                    "rej_file_content": "```diff\n--- system/stack/gatt/gatt_sr.cc\n+++ system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
                                    "patch_apply_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 FAILED at 772.\nHunk #2 FAILED at 804.\nHunk #3 succeeded at 902 with fuzz 2 (offset -47 lines).\nHunk #4 succeeded at 1054 with fuzz 2 (offset -47 lines).\n2 out of 4 hunks FAILED -- saving rejects to file system/stack/gatt/gatt_sr.cc.rej",
                                    "inline_merge_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 NOT MERGED at 905-914.\nHunk #2 NOT MERGED at 916-929.\nHunk #3 NOT MERGED at 1089-1098.\nHunk #4 NOT MERGED at 1127-1139."
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ],
    "vulnerabilities_skipped": [
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-343129193",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/native/services/inputflinger/dispatcher/InputDispatcher.h.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-377311997",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-381898850",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-376461551",
            "skipped": true,
            "error": "Command '['git', 'format-patch', '-1', '5f1be4f4b02ded791ad72725c4eef44287b08b1b', '--stdout']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-377312708",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-376674080",
            "skipped": true,
            "error": "Command '['git', 'format-patch', '-1', '85ef51a7a91de0e51dd65ce5f09badcd96835817', '--stdout']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-355461643",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-283962634",
            "skipped": true,
            "error": "Command '['git', 'format-patch', '-1', 'eae60a878ffa8eafe854539d3381ceba9ff6cca4', '--stdout']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-388048345",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-381901669",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-356117796",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/Settings/src/com/android/settings/spa/app/appinfo/AppTimeSpentPreference.kt.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-317203980",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/base/media/java/android/media/session/MediaSession.java.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-293458004",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/Telecomm/src/com/android/server/telecom/LogUtils.java.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-228837201",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-357870429",
            "skipped": true,
            "error": "Command '['git', 'format-patch', '-1', '7f433dcc4e483fdf93c556b2f5a1455932b9790e', '--stdout']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-316578327",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-377312892",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-292104015",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/base/services/autofill/java/com/android/server/autofill/ui/FillUi.java.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-373357090",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/base/core/java/android/os/Parcel.java.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-388048322",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-350500921",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-388480622",
            "skipped": true,
            "error": "Command '['git', 'format-patch', '-1', 'bfae9080f53da925d53c24537e901a5015aa9311', '--stdout']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-388047607",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-335387175",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/Telephony/src/com/android/phone/EnableIccPinScreen.java.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-377312055",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-381899455",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-377311993",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-308932906",
            "skipped": true,
            "error": "Command '['git', 'format-patch', '-1', '1c55f991ae08deaa1630beb2c24da16bcdc71f29', '--stdout']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-388047866",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-345258562",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-333344157",
            "skipped": true,
            "error": "Command '['git', 'format-patch', '-1', '6a4ba5cd84cbaf6a52dfd15be0a6d61dffb1af52', '--stdout']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-372003017",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-377312238",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-193031925",
            "skipped": true,
            "error": "Command '['git', 'format-patch', '-1', '9a0a647f50dde062bb0846a87961607b4ca1c4c8', '--stdout']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-286235483",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/base/services/autofill/java/com/android/server/autofill/ui/FillUi.java.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-305695605",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/base/services/core/java/com/android/server/notification/NotificationManagerService.java.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-378900798",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/base/services/tests/wmtests/src/com/android/server/policy/TestPhoneWindowManager.java.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-291281168",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/Bluetooth/system/stack/sdp/sdp_discovery.cc.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-359179312",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/native/libs/binder/include/binder/Parcel.h.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-308429049",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-339532378",
            "skipped": true,
            "error": "Command '['git', 'format-patch', '-1', '3d357eedb80fd93d6ae2e1c41a20c40fe0c1670b', '--stdout']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-388048166",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-356886209",
            "skipped": true,
            "error": "Command '['git', 'format-patch', '-1', '298fdca3f2700432e30c2a1fdfec6f93af453dd8', '--stdout']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-377312377",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-376259166",
            "skipped": true,
            "error": "Command '['git', 'format-patch', '-1', '5f1be4f4b02ded791ad72725c4eef44287b08b1b', '--stdout']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-372002616",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-377313069",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-377313194",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-377312639",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-331180422",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/base/packages/SystemUI/src/com/android/systemui/statusbar/KeyboardShortcuts.java.rej'"
        }
    ]
}