[
  {
    "id": "ASB-A-309938635",
    "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-309938635",
    "severity": "High",
    "failures": [
      {
        "downstream_version": "14",
        "gemini_token_usage": 37332,
        "branch_used": "android14-release",
        "downstream_patch": "c7b495dc8c466de602cd7b78468864acd6b2f9b3",
        "repo_path": "android_repos/libcore",
        "result": "failure",
        "downstream_patch_content": "commit c7b495dc8c466de602cd7b78468864acd6b2f9b3\nAuthor: Almaz Mingaleev <mingaleev@google.com>\nDate:   Wed Jul 10 12:30:24 2024 +0100\n\n    Do not accept zip files with invalid headers.\n    \n    According to Section 4.3.6 in [1] non-empty zip file starts with\n    local file header. 4.3.1 allows empty files, and in such case\n    file starts with \"end of central directory record\".\n    \n    This aligns ZipFile with libziparchive modulo empty zip files -\n    libziparchive rejects them.\n    \n    Tests are skipped because udc-dev branch uses ART module\n    prebuilts, but builds tests from sources which leads to presubmit\n    failures.\n    \n    Ignore-AOSP-First: b/309938635#comment1\n    \n    [1] https://pkwaredownloads.blob.core.windows.net/pem/APPNOTE.txt\n    \n    Bug: 309938635\n    Test: CtsLibcoreTestCases\n    Test: CtsLibcoreOjTestCases\n    Change-Id: I545cdd49ec3cc138331145f4716c8148662a478b\n    Merged-In: I545cdd49ec3cc138331145f4716c8148662a478b\n\ndiff --git a/ojluni/src/main/native/zip_util.c b/ojluni/src/main/native/zip_util.c\nindex 2b63d6bfd9a..1c1f45b37f2 100644\n--- a/ojluni/src/main/native/zip_util.c\n+++ b/ojluni/src/main/native/zip_util.c\n@@ -958,6 +958,17 @@ ZIP_Put_In_Cache0(JNIEnv *env, jobject thiz, const char *name, ZFILE zfd, char *\n     // Assumption, zfd refers to start of file. Trivially, reuse errbuf.\n     if (readFullyAt(zfd, errbuf, 4, 0 /* offset */) != -1) {  // errors will be handled later\n         zip->locsig = LOCSIG_AT(errbuf) ? JNI_TRUE : JNI_FALSE;\n+\n+        // BEGIN Android-changed: do not accept files with invalid header.\n+        if (!LOCSIG_AT(errbuf) && !ENDSIG_AT(errbuf)) {\n+            if (pmsg) {\n+                *pmsg = strdup(\"Entry at offset zero has invalid LFH signature.\");\n+            }\n+            ZFILE_Close(zfd);\n+            freeZip(zip);\n+            return NULL;\n+        }\n+        // END Android-changed: do not accept files with invalid header.\n     }\n \n     // This lseek is safe because it happens during construction of the ZipFile\n",
        "downstream_patch_tokens": {
          "openai": 617,
          "general": {
            "word_based": 254,
            "char_based": 504
          },
          "gemini": 771
        },
        "file_conflicts": [
          {
            "file_name": "ojluni/src/main/java/java/util/zip/ZipFile.java",
            "total_hunks": 1,
            "failed_hunks": [
              1
            ],
            "inline_merge_conflicts": [
              {
                "hunk_number": 1,
                "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n                // BEGIN Android-changed: do not accept files with invalid header\n                // this.startsWithLoc = (LOCSIG(buf) == LOCSIG);\n                long locsig = LOCSIG(buf);\n                this.startsWithLoc = (locsig == LOCSIG);\n                // If a zip file starts with \"end of central directory record\" it means that such\n                // file is empty.\n                if (locsig != LOCSIG && locsig != ENDSIG) {\n                    String msg = \"Entry at offset zero has invalid LFH signature \"\n                                    + Long.toHexString(locsig);\n                    throw new ZipException(msg);\n                }\n                // END Android-changed: do not accept files with invalid header\n            } catch (IOException x) {\n                try {\n                    this.zfile.close();\n>>>>>>> UPSTREAM PATCH (commit 549d249b9a83c9d82837799584afb6381e54254e)",
                "merge_conflict_tokens": {
                  "openai": 200,
                  "general": {
                    "word_based": 87,
                    "char_based": 236
                  },
                  "gemini": 238
                }
              }
            ],
            "inline_merge_token_summary": {
              "gemini": 8330,
              "openai": 7200,
              "general_word": 3132,
              "general_char": 8496
            },
            "rej_file_content": "```diff\n--- ojluni/src/main/java/java/util/zip/ZipFile.java\n+++ ojluni/src/main/java/java/util/zip/ZipFile.java\n@@ -1436,7 +1436,18 @@ public class ZipFile implements ZipConstants, Closeable {\n                 initCEN(-1);\n                 byte[] buf = new byte[4];\n                 readFullyAt(buf, 0, 4, 0);\n-                this.startsWithLoc = (LOCSIG(buf) == LOCSIG);\n+                // BEGIN Android-changed: do not accept files with invalid header\n+                // this.startsWithLoc = (LOCSIG(buf) == LOCSIG);\n+                long locsig = LOCSIG(buf);\n+                this.startsWithLoc = (locsig == LOCSIG);\n+                // If a zip file starts with \"end of central directory record\" it means that such\n+                // file is empty.\n+                if (locsig != LOCSIG && locsig != ENDSIG) {\n+                    String msg = \"Entry at offset zero has invalid LFH signature \"\n+                                    + Long.toHexString(locsig);\n+                    throw new ZipException(msg);\n+                }\n+                // END Android-changed: do not accept files with invalid header\n             } catch (IOException x) {\n                 try {\n                     this.zfile.close();\n```",
            "rej_file_tokens": {
              "openai": 278,
              "general": {
                "word_based": 125,
                "char_based": 303
              },
              "gemini": 318
            },
            "patch_apply_output": "patching file ojluni/src/main/java/java/util/zip/ZipFile.java\nHunk #1 FAILED at 1436.\n1 out of 1 hunk FAILED -- saving rejects to file ojluni/src/main/java/java/util/zip/ZipFile.java.rej",
            "inline_merge_output": "patching file ojluni/src/main/java/java/util/zip/ZipFile.java\nHunk #1 NOT MERGED at 1439-1456.",
            "upstream_file_content": "```java\n/*\n * Copyright (C) 2014 The Android Open Source Project\n * Copyright (c) 1995, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.util.zip;\n\nimport java.io.Closeable;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.RandomAccessFile;\nimport java.io.UncheckedIOException;\nimport java.lang.ref.Cleaner.Cleanable;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.InvalidPathException;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.Files;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.TreeSet;\nimport java.util.WeakHashMap;\nimport java.util.function.Consumer;\nimport java.util.function.IntFunction;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.ref.CleanerFactory;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.security.util.SignatureFileVerifier;\n\nimport dalvik.system.CloseGuard;\nimport dalvik.system.ZipPathValidator;\n\nimport static java.util.zip.ZipConstants64.*;\nimport static java.util.zip.ZipUtils.*;\n\n/**\n * This class is used to read entries from a zip file.\n *\n * <p> Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * @apiNote\n * To release resources used by this {@code ZipFile}, the {@link #close()} method\n * should be called explicitly or by try-with-resources. Subclasses are responsible\n * for the cleanup of resources acquired by the subclass. Subclasses that override\n * {@link #finalize()} in order to perform cleanup should be modified to use alternative\n * cleanup mechanisms such as {@link java.lang.ref.Cleaner} and remove the overriding\n * {@code finalize} method.\n *\n * @author      David Connelly\n * @since 1.1\n */\npublic class ZipFile implements ZipConstants, Closeable {\n\n    private final String name;     // zip file name\n    private volatile boolean closeRequested;\n\n    // The \"resource\" used by this zip file that needs to be\n    // cleaned after use.\n    // a) the input streams that need to be closed\n    // b) the list of cached Inflater objects\n    // c) the \"native\" source of this zip file.\n    private final @Stable CleanableResource res;\n\n    // Android-added: CloseGuard support.\n    private final CloseGuard guard = CloseGuard.get();\n\n    private static final int STORED = ZipEntry.STORED;\n    private static final int DEFLATED = ZipEntry.DEFLATED;\n\n    /**\n     * Mode flag to open a zip file for reading.\n     */\n    public static final int OPEN_READ = 0x1;\n\n    /**\n     * Mode flag to open a zip file and mark it for deletion.  The file will be\n     * deleted some time between the moment that it is opened and the moment\n     * that it is closed, but its contents will remain accessible via the\n     * {@code ZipFile} object until either the close method is invoked or the\n     * virtual machine exits.\n     */\n    public static final int OPEN_DELETE = 0x4;\n\n    // Android-changed: Additional ZipException throw scenario with ZipPathValidator.\n    /**\n     * Opens a zip file for reading.\n     *\n     * <p>First, if there is a security manager, its {@code checkRead}\n     * method is called with the {@code name} argument as its argument\n     * to ensure the read is allowed.\n     *\n     * <p>The UTF-8 {@link java.nio.charset.Charset charset} is used to\n     * decode the entry names and comments.\n     *\n     * <p>If the app targets Android U or above, zip file entry names containing\n     * \"..\" or starting with \"/\" passed here will throw a {@link ZipException}.\n     * For more details, see {@link dalvik.system.ZipPathValidator}.\n     *\n     * @param name the name of the zip file\n     * @throws ZipException if (1) a ZIP format error has occurred or\n     *         (2) <code>targetSdkVersion >= BUILD.VERSION_CODES.UPSIDE_DOWN_CAKE</code>\n     *         and (the <code>name</code> argument contains \"..\" or starts with \"/\").\n     * @throws IOException if an I/O error has occurred\n     * @throws SecurityException if a security manager exists and its\n     *         {@code checkRead} method doesn't allow read access to the file.\n     *\n     * @see SecurityManager#checkRead(java.lang.String)\n     */\n    public ZipFile(String name) throws IOException {\n        this(new File(name), OPEN_READ);\n    }\n\n    /**\n     * Opens a new {@code ZipFile} to read from the specified\n     * {@code File} object in the specified mode.  The mode argument\n     * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.\n     *\n     * <p>First, if there is a security manager, its {@code checkRead}\n     * method is called with the {@code name} argument as its argument to\n     * ensure the read is allowed.\n     *\n     * <p>The UTF-8 {@link java.nio.charset.Charset charset} is used to\n     * decode the entry names and comments\n     *\n     * @param file the ZIP file to be opened for reading\n     * @param mode the mode in which the file is to be opened\n     * @throws ZipException if a ZIP format error has occurred\n     * @throws IOException if an I/O error has occurred\n     * @throws SecurityException if a security manager exists and\n     *         its {@code checkRead} method\n     *         doesn't allow read access to the file,\n     *         or its {@code checkDelete} method doesn't allow deleting\n     *         the file when the {@code OPEN_DELETE} flag is set.\n     * @throws IllegalArgumentException if the {@code mode} argument is invalid\n     * @see SecurityManager#checkRead(java.lang.String)\n     * @since 1.3\n     */\n    public ZipFile(File file, int mode) throws IOException {\n        // Android-changed: Use StandardCharsets.UTF_8.\n        // this(file, mode, UTF_8.INSTANCE);\n        this(file, mode, StandardCharsets.UTF_8);\n    }\n\n    /**\n     * Opens a ZIP file for reading given the specified File object.\n     *\n     * <p>The UTF-8 {@link java.nio.charset.Charset charset} is used to\n     * decode the entry names and comments.\n     *\n     * @param file the ZIP file to be opened for reading\n     * @throws ZipException if a ZIP format error has occurred\n     * @throws IOException if an I/O error has occurred\n     */\n    public ZipFile(File file) throws ZipException, IOException {\n        this(file, OPEN_READ);\n    }\n\n    // Android-changed: Use of the hidden constructor with a new argument for zip path validation.\n    /**\n     * Opens a new {@code ZipFile} to read from the specified\n     * {@code File} object in the specified mode.  The mode argument\n     * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.\n     *\n     * <p>First, if there is a security manager, its {@code checkRead}\n     * method is called with the {@code name} argument as its argument to\n     * ensure the read is allowed.\n     *\n     * @param file the ZIP file to be opened for reading\n     * @param mode the mode in which the file is to be opened\n     * @param charset\n     *        the {@linkplain java.nio.charset.Charset charset} to\n     *        be used to decode the ZIP entry name and comment that are not\n     *        encoded by using UTF-8 encoding (indicated by entry's general\n     *        purpose flag).\n     *\n     * @throws ZipException if a ZIP format error has occurred\n     * @throws IOException if an I/O error has occurred\n     *\n     * @throws SecurityException\n     *         if a security manager exists and its {@code checkRead}\n     *         method doesn't allow read access to the file,or its\n     *         {@code checkDelete} method doesn't allow deleting the\n     *         file when the {@code OPEN_DELETE} flag is set\n     *\n     * @throws IllegalArgumentException if the {@code mode} argument is invalid\n     *\n     * @see SecurityManager#checkRead(java.lang.String)\n     *\n     * @since 1.7\n     */\n    public ZipFile(File file, int mode, Charset charset) throws IOException\n    {\n        this(file, mode, charset, /* enableZipPathValidator */ true);\n    }\n\n    // Android-added: New hidden constructor with an argument for zip path validation.\n    /** @hide */\n    public ZipFile(File file, int mode, boolean enableZipPathValidator) throws IOException {\n        this(file, mode, StandardCharsets.UTF_8, enableZipPathValidator);\n    }\n\n    // Android-changed: Change existing constructor ZipFile(File file, int mode, Charset charset)\n    // to have a new argument enableZipPathValidator in order to set the isZipPathValidatorEnabled\n    // variable before calling the native method open().\n    /** @hide */\n    public ZipFile(File file, int mode, Charset charset, boolean enableZipPathValidator)\n            throws IOException {\n        if (((mode & OPEN_READ) == 0) ||\n            ((mode & ~(OPEN_READ | OPEN_DELETE)) != 0)) {\n            throw new IllegalArgumentException(\"Illegal mode: 0x\"+\n                                               Integer.toHexString(mode));\n        }\n        String name = file.getPath();\n        file = new File(name);\n        // Android-removed: SecurityManager is always null.\n        /*\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkRead(name);\n            if ((mode & OPEN_DELETE) != 0) {\n                sm.checkDelete(name);\n            }\n        }\n        */\n\n        Objects.requireNonNull(charset, \"charset\");\n\n        this.name = name;\n        // Android-removed: Skip perf counters.\n        // long t0 = System.nanoTime();\n\n        // Android-changed: pass isZipPathValidatorEnabled flag.\n        // this.res = new CleanableResource(this, ZipCoder.get(charset), file, mode);\n        boolean isZipPathValidatorEnabled = enableZipPathValidator && !ZipPathValidator.isClear();\n        this.res = new CleanableResource(\n                this, ZipCoder.get(charset), file, mode, isZipPathValidatorEnabled);\n\n        // Android-removed: Skip perf counters.\n        // PerfCounter.getZipFileOpenTime().addElapsedTimeFrom(t0);\n        // PerfCounter.getZipFileCount().increment();\n    }\n\n    /**\n     * Opens a zip file for reading.\n     *\n     * <p>First, if there is a security manager, its {@code checkRead}\n     * method is called with the {@code name} argument as its argument\n     * to ensure the read is allowed.\n     *\n     * @param name the name of the zip file\n     * @param charset\n     *        the {@linkplain java.nio.charset.Charset charset} to\n     *        be used to decode the ZIP entry name and comment that are not\n     *        encoded by using UTF-8 encoding (indicated by entry's general\n     *        purpose flag).\n     *\n     * @throws ZipException if a ZIP format error has occurred\n     * @throws IOException if an I/O error has occurred\n     * @throws SecurityException\n     *         if a security manager exists and its {@code checkRead}\n     *         method doesn't allow read access to the file\n     *\n     * @see SecurityManager#checkRead(java.lang.String)\n     *\n     * @since 1.7\n     */\n    public ZipFile(String name, Charset charset) throws IOException\n    {\n        this(new File(name), OPEN_READ, charset);\n    }\n\n    /**\n     * Opens a ZIP file for reading given the specified File object.\n     *\n     * @param file the ZIP file to be opened for reading\n     * @param charset\n     *        The {@linkplain java.nio.charset.Charset charset} to be\n     *        used to decode the ZIP entry name and comment (ignored if\n     *        the <a href=\"package-summary.html#lang_encoding\"> language\n     *        encoding bit</a> of the ZIP entry's general purpose bit\n     *        flag is set).\n     *\n     * @throws ZipException if a ZIP format error has occurred\n     * @throws IOException if an I/O error has occurred\n     *\n     * @since 1.7\n     */\n    public ZipFile(File file, Charset charset) throws IOException\n    {\n        this(file, OPEN_READ, charset);\n    }\n\n    /**\n     * Returns the zip file comment, or null if none.\n     *\n     * @return the comment string for the zip file, or null if none\n     *\n     * @throws IllegalStateException if the zip file has been closed\n     *\n     * @since 1.7\n     */\n    public String getComment() {\n        synchronized (this) {\n            ensureOpen();\n            if (res.zsrc.comment == null) {\n                return null;\n            }\n            return res.zsrc.zc.toString(res.zsrc.comment);\n        }\n    }\n\n    /**\n     * Returns the zip file entry for the specified name, or null\n     * if not found.\n     *\n     * @param name the name of the entry\n     * @return the zip file entry, or null if not found\n     * @throws IllegalStateException if the zip file has been closed\n     */\n    public ZipEntry getEntry(String name) {\n        Objects.requireNonNull(name, \"name\");\n        ZipEntry entry = null;\n        synchronized (this) {\n            ensureOpen();\n            int pos = res.zsrc.getEntryPos(name, true);\n            if (pos != -1) {\n                entry = getZipEntry(name, pos);\n            }\n        }\n        return entry;\n    }\n\n    /**\n     * Returns an input stream for reading the contents of the specified\n     * zip file entry.\n     * <p>\n     * Closing this ZIP file will, in turn, close all input streams that\n     * have been returned by invocations of this method.\n     *\n     * @param entry the zip file entry\n     * @return the input stream for reading the contents of the specified\n     * zip file entry.\n     * @throws ZipException if a ZIP format error has occurred\n     * @throws IOException if an I/O error has occurred\n     * @throws IllegalStateException if the zip file has been closed\n     */\n    public InputStream getInputStream(ZipEntry entry) throws IOException {\n        Objects.requireNonNull(entry, \"entry\");\n        int pos;\n        ZipFileInputStream in;\n        Source zsrc = res.zsrc;\n        Set<InputStream> istreams = res.istreams;\n        synchronized (this) {\n            ensureOpen();\n            if (Objects.equals(lastEntryName, entry.name)) {\n                pos = lastEntryPos;\n            } else {\n                pos = zsrc.getEntryPos(entry.name, false);\n            }\n            if (pos == -1) {\n                return null;\n            }\n            in = new ZipFileInputStream(zsrc.cen, pos);\n            switch (CENHOW(zsrc.cen, pos)) {\n            case STORED:\n                synchronized (istreams) {\n                    istreams.add(in);\n                }\n                return in;\n            case DEFLATED:\n                // Inflater likes a bit of slack\n                // MORE: Compute good size for inflater stream:\n                long size = CENLEN(zsrc.cen, pos) + 2;\n                if (size > 65536) {\n                    // Android-changed: Use 64k buffer size, performs\n                    // better than 8k. See http://b/65491407.\n                    // size = 8192;\n                    size = 65536;\n                }\n                if (size <= 0) {\n                    size = 4096;\n                }\n                InputStream is = new ZipFileInflaterInputStream(in, res, (int)size);\n                synchronized (istreams) {\n                    istreams.add(is);\n                }\n                return is;\n            default:\n                throw new ZipException(\"invalid compression method\");\n            }\n        }\n    }\n\n    private static class InflaterCleanupAction implements Runnable {\n        private final Inflater inf;\n        private final CleanableResource res;\n\n        InflaterCleanupAction(Inflater inf, CleanableResource res) {\n            this.inf = inf;\n            this.res = res;\n        }\n\n        @Override\n        public void run() {\n            res.releaseInflater(inf);\n        }\n    }\n\n    private class ZipFileInflaterInputStream extends InflaterInputStream {\n        private volatile boolean closeRequested;\n        private boolean eof = false;\n        private final Cleanable cleanable;\n\n        ZipFileInflaterInputStream(ZipFileInputStream zfin,\n                                   CleanableResource res, int size) {\n            this(zfin, res, res.getInflater(), size);\n        }\n\n        private ZipFileInflaterInputStream(ZipFileInputStream zfin,\n                                           CleanableResource res,\n                                           Inflater inf, int size) {\n            // Android-changed: ZipFileInflaterInputStream does not control its inflater's lifetime\n            // and hence it shouldn't be closed when the stream is closed.\n            // super(zfin, inf, size);\n            super(zfin, inf, size, /* ownsInflater */ false);\n            this.cleanable = CleanerFactory.cleaner().register(this,\n                    new InflaterCleanupAction(inf, res));\n        }\n\n        public void close() throws IOException {\n            if (closeRequested)\n                return;\n            closeRequested = true;\n            super.close();\n            synchronized (res.istreams) {\n                res.istreams.remove(this);\n            }\n            cleanable.clean();\n        }\n\n        // Override fill() method to provide an extra \"dummy\" byte\n        // at the end of the input stream. This is required when\n        // using the \"nowrap\" Inflater option.\n        protected void fill() throws IOException {\n            if (eof) {\n                throw new EOFException(\"Unexpected end of ZLIB input stream\");\n            }\n            len = in.read(buf, 0, buf.length);\n            if (len == -1) {\n                buf[0] = 0;\n                len = 1;\n                eof = true;\n            }\n            inf.setInput(buf, 0, len);\n        }\n\n        public int available() throws IOException {\n            if (closeRequested)\n                return 0;\n            long avail = ((ZipFileInputStream)in).size() - inf.getBytesWritten();\n            return (avail > (long) Integer.MAX_VALUE ?\n                    Integer.MAX_VALUE : (int) avail);\n        }\n    }\n\n    /**\n     * Returns the path name of the ZIP file.\n     * @return the path name of the ZIP file\n     */\n    public String getName() {\n        return name;\n    }\n\n    private class ZipEntryIterator<T extends ZipEntry>\n            implements Enumeration<T>, Iterator<T> {\n\n        private int i = 0;\n        private final int entryCount;\n\n        public ZipEntryIterator(int entryCount) {\n            this.entryCount = entryCount;\n        }\n\n        @Override\n        public boolean hasMoreElements() {\n            return hasNext();\n        }\n\n        @Override\n        public boolean hasNext() {\n            // Android-changed: check that file is open.\n            // return i < entryCount;\n            synchronized (ZipFile.this) {\n                ensureOpen();\n                return i < entryCount;\n            }\n        }\n\n        @Override\n        public T nextElement() {\n            return next();\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public T next() {\n            synchronized (ZipFile.this) {\n                ensureOpen();\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                // each \"entry\" has 3 ints in table entries\n                return (T)getZipEntry(null, res.zsrc.getEntryPos(i++ * 3));\n            }\n        }\n\n        @Override\n        public Iterator<T> asIterator() {\n            return this;\n        }\n    }\n\n    /**\n     * Returns an enumeration of the ZIP file entries.\n     * @return an enumeration of the ZIP file entries\n     * @throws IllegalStateException if the zip file has been closed\n     */\n    public Enumeration<? extends ZipEntry> entries() {\n        synchronized (this) {\n            ensureOpen();\n            return new ZipEntryIterator<ZipEntry>(res.zsrc.total);\n        }\n    }\n\n    private Enumeration<JarEntry> jarEntries() {\n        synchronized (this) {\n            ensureOpen();\n            return new ZipEntryIterator<JarEntry>(res.zsrc.total);\n        }\n    }\n\n    private class EntrySpliterator<T> extends Spliterators.AbstractSpliterator<T> {\n        private int index;\n        private final int fence;\n        private final IntFunction<T> gen;\n\n        EntrySpliterator(int index, int fence, IntFunction<T> gen) {\n            super((long)fence,\n                  Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.IMMUTABLE |\n                  Spliterator.NONNULL);\n            this.index = index;\n            this.fence = fence;\n            this.gen = gen;\n        }\n\n        @Override\n        public boolean tryAdvance(Consumer<? super T> action) {\n            if (action == null)\n                throw new NullPointerException();\n            if (index >= 0 && index < fence) {\n                synchronized (ZipFile.this) {\n                    ensureOpen();\n                    action.accept(gen.apply(res.zsrc.getEntryPos(index++ * 3)));\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Returns an ordered {@code Stream} over the ZIP file entries.\n     *\n     * Entries appear in the {@code Stream} in the order they appear in\n     * the central directory of the ZIP file.\n     *\n     * @return an ordered {@code Stream} of entries in this ZIP file\n     * @throws IllegalStateException if the zip file has been closed\n     * @since 1.8\n     */\n    public Stream<? extends ZipEntry> stream() {\n        synchronized (this) {\n            ensureOpen();\n            return StreamSupport.stream(new EntrySpliterator<>(0, res.zsrc.total,\n                pos -> getZipEntry(null, pos)), false);\n       }\n    }\n\n    private String getEntryName(int pos) {\n        byte[] cen = res.zsrc.cen;\n        int nlen = CENNAM(cen, pos);\n        ZipCoder zc = res.zsrc.zipCoderForPos(pos);\n        return zc.toString(cen, pos + CENHDR, nlen);\n    }\n\n    /*\n     * Returns an ordered {@code Stream} over the zip file entry names.\n     *\n     * Entry names appear in the {@code Stream} in the order they appear in\n     * the central directory of the ZIP file.\n     *\n     * @return an ordered {@code Stream} of entry names in this zip file\n     * @throws IllegalStateException if the zip file has been closed\n     * @since 10\n     */\n    private Stream<String> entryNameStream() {\n        synchronized (this) {\n            ensureOpen();\n            return StreamSupport.stream(\n                new EntrySpliterator<>(0, res.zsrc.total, this::getEntryName), false);\n        }\n    }\n\n    /*\n     * Returns an ordered {@code Stream} over the zip file entries.\n     *\n     * Entries appear in the {@code Stream} in the order they appear in\n     * the central directory of the jar file.\n     *\n     * @return an ordered {@code Stream} of entries in this zip file\n     * @throws IllegalStateException if the zip file has been closed\n     * @since 10\n     */\n    private Stream<JarEntry> jarStream() {\n        synchronized (this) {\n            ensureOpen();\n            return StreamSupport.stream(new EntrySpliterator<>(0, res.zsrc.total,\n                pos -> (JarEntry)getZipEntry(null, pos)), false);\n        }\n    }\n\n    private String lastEntryName;\n    private int lastEntryPos;\n\n    /* Check ensureOpen() before invoking this method */\n    private ZipEntry getZipEntry(String name, int pos) {\n        byte[] cen = res.zsrc.cen;\n        int nlen = CENNAM(cen, pos);\n        int elen = CENEXT(cen, pos);\n        int clen = CENCOM(cen, pos);\n\n        ZipCoder zc = res.zsrc.zipCoderForPos(pos);\n        if (name != null) {\n            // only need to check for mismatch of trailing slash\n            if (nlen > 0 &&\n                !name.isEmpty() &&\n                zc.hasTrailingSlash(cen, pos + CENHDR + nlen) &&\n                !name.endsWith(\"/\"))\n            {\n                name += '/';\n            }\n        } else {\n            // invoked from iterator, use the entry name stored in cen\n            name = zc.toString(cen, pos + CENHDR, nlen);\n        }\n        ZipEntry e;\n        if (this instanceof JarFile) {\n            // Android-changed: access method directly.\n            // e = Source.JUJA.entryFor((JarFile)this, name);\n            e = ((JarFile) this).entryFor(name);\n        } else {\n            e = new ZipEntry(name);\n        }\n        e.flag = CENFLG(cen, pos);\n        e.xdostime = CENTIM(cen, pos);\n        e.crc = CENCRC(cen, pos);\n        e.size = CENLEN(cen, pos);\n        e.csize = CENSIZ(cen, pos);\n        e.method = CENHOW(cen, pos);\n        if (CENVEM_FA(cen, pos) == FILE_ATTRIBUTES_UNIX) {\n            // read all bits in this field, including sym link attributes\n            e.extraAttributes = CENATX_PERMS(cen, pos) & 0xFFFF;\n        }\n\n        if (elen != 0) {\n            int start = pos + CENHDR + nlen;\n            e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true, false);\n        }\n        if (clen != 0) {\n            int start = pos + CENHDR + nlen + elen;\n            e.comment = zc.toString(cen, start, clen);\n        }\n        lastEntryName = e.name;\n        lastEntryPos = pos;\n        return e;\n    }\n\n    /**\n     * Returns the number of entries in the ZIP file.\n     *\n     * @return the number of entries in the ZIP file\n     * @throws IllegalStateException if the zip file has been closed\n     */\n    public int size() {\n        synchronized (this) {\n            ensureOpen();\n            return res.zsrc.total;\n        }\n    }\n\n    private static class CleanableResource implements Runnable {\n        // The outstanding inputstreams that need to be closed\n        final Set<InputStream> istreams;\n\n        // List of cached Inflater objects for decompression\n        Deque<Inflater> inflaterCache;\n\n        final Cleanable cleanable;\n\n        Source zsrc;\n\n        CleanableResource(ZipFile zf, ZipCoder zc, File file, int mode) throws IOException {\n            this(zf, zc, file, mode, false);\n        }\n\n        // Android-added: added extra enableZipPathValidator argument.\n        CleanableResource(ZipFile zf, ZipCoder zc, File file,\n                int mode, boolean enableZipPathValidator) throws IOException {\n            this.cleanable = CleanerFactory.cleaner().register(zf, this);\n            this.istreams = Collections.newSetFromMap(new WeakHashMap<>());\n            this.inflaterCache = new ArrayDeque<>();\n            this.zsrc = Source.get(file, (mode & OPEN_DELETE) != 0, zc, enableZipPathValidator);\n        }\n\n        void clean() {\n            cleanable.clean();\n        }\n\n        /*\n         * Gets an inflater from the list of available inflaters or allocates\n         * a new one.\n         */\n        Inflater getInflater() {\n            Inflater inf;\n            synchronized (inflaterCache) {\n                if ((inf = inflaterCache.poll()) != null) {\n                    return inf;\n                }\n            }\n            return new Inflater(true);\n        }\n\n        /*\n         * Releases the specified inflater to the list of available inflaters.\n         */\n        void releaseInflater(Inflater inf) {\n            Deque<Inflater> inflaters = this.inflaterCache;\n            if (inflaters != null) {\n                synchronized (inflaters) {\n                    // double checked!\n                    if (inflaters == this.inflaterCache) {\n                        inf.reset();\n                        inflaters.add(inf);\n                        return;\n                    }\n                }\n            }\n            // inflaters cache already closed - just end it.\n            inf.end();\n        }\n\n        public void run() {\n            IOException ioe = null;\n\n            // Release cached inflaters and close the cache first\n            Deque<Inflater> inflaters = this.inflaterCache;\n            if (inflaters != null) {\n                synchronized (inflaters) {\n                    // no need to double-check as only one thread gets a\n                    // chance to execute run() (Cleaner guarantee)...\n                    Inflater inf;\n                    while ((inf = inflaters.poll()) != null) {\n                        inf.end();\n                    }\n                    // close inflaters cache\n                    this.inflaterCache = null;\n                }\n            }\n\n            // Close streams, release their inflaters\n            if (istreams != null) {\n                synchronized (istreams) {\n                    if (!istreams.isEmpty()) {\n                        InputStream[] copy = istreams.toArray(new InputStream[0]);\n                        istreams.clear();\n                        for (InputStream is : copy) {\n                            try {\n                                is.close();\n                            } catch (IOException e) {\n                                if (ioe == null) ioe = e;\n                                else ioe.addSuppressed(e);\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Release zip src\n            if (zsrc != null) {\n                synchronized (zsrc) {\n                    try {\n                        Source.release(zsrc);\n                        zsrc = null;\n                    } catch (IOException e) {\n                        if (ioe == null) ioe = e;\n                        else ioe.addSuppressed(e);\n                    }\n                }\n            }\n            if (ioe != null) {\n                throw new UncheckedIOException(ioe);\n            }\n        }\n    }\n\n    /**\n     * Closes the ZIP file.\n     *\n     * <p> Closing this ZIP file will close all of the input streams\n     * previously returned by invocations of the {@link #getInputStream\n     * getInputStream} method.\n     *\n     * @throws IOException if an I/O error has occurred\n     */\n    public void close() throws IOException {\n        if (closeRequested) {\n            return;\n        }\n        // Android-added: CloseGuard support.\n        if (guard != null) {\n            guard.close();\n        }\n        closeRequested = true;\n\n        synchronized (this) {\n            // Close streams, release their inflaters, release cached inflaters\n            // and release zip source\n            try {\n                res.clean();\n            } catch (UncheckedIOException ioe) {\n                throw ioe.getCause();\n            }\n        }\n    }\n\n    private void ensureOpen() {\n        if (closeRequested) {\n            throw new IllegalStateException(\"zip file closed\");\n        }\n        if (res.zsrc == null) {\n            throw new IllegalStateException(\"The object is not initialized.\");\n        }\n    }\n\n    private void ensureOpenOrZipException() throws IOException {\n        if (closeRequested) {\n            throw new ZipException(\"ZipFile closed\");\n        }\n    }\n\n    /*\n     * Inner class implementing the input stream used to read a\n     * (possibly compressed) zip file entry.\n     */\n    private class ZipFileInputStream extends InputStream {\n        private volatile boolean closeRequested;\n        private   long pos;     // current position within entry data\n        private   long startingPos; // Start position for the entry data\n        protected long rem;     // number of remaining bytes within entry\n        protected long size;    // uncompressed size of this entry\n\n        ZipFileInputStream(byte[] cen, int cenpos) {\n            rem = CENSIZ(cen, cenpos);\n            size = CENLEN(cen, cenpos);\n            pos = CENOFF(cen, cenpos);\n            // zip64\n            if (rem == ZIP64_MAGICVAL || size == ZIP64_MAGICVAL ||\n                pos == ZIP64_MAGICVAL) {\n                checkZIP64(cen, cenpos);\n            }\n            // negative for lazy initialization, see getDataOffset();\n            pos = - (pos + ZipFile.this.res.zsrc.locpos);\n        }\n\n        private void checkZIP64(byte[] cen, int cenpos) {\n            int off = cenpos + CENHDR + CENNAM(cen, cenpos);\n            int end = off + CENEXT(cen, cenpos);\n            while (off + 4 < end) {\n                int tag = get16(cen, off);\n                int sz = get16(cen, off + 2);\n                off += 4;\n                if (off + sz > end)         // invalid data\n                    break;\n                if (tag == EXTID_ZIP64) {\n                    if (size == ZIP64_MAGICVAL) {\n                        if (sz < 8 || (off + 8) > end)\n                            break;\n                        size = get64(cen, off);\n                        sz -= 8;\n                        off += 8;\n                    }\n                    if (rem == ZIP64_MAGICVAL) {\n                        if (sz < 8 || (off + 8) > end)\n                            break;\n                        rem = get64(cen, off);\n                        sz -= 8;\n                        off += 8;\n                    }\n                    if (pos == ZIP64_MAGICVAL) {\n                        if (sz < 8 || (off + 8) > end)\n                            break;\n                        pos = get64(cen, off);\n                        sz -= 8;\n                        off += 8;\n                    }\n                    break;\n                }\n                off += sz;\n            }\n        }\n\n        /*\n         * The Zip file spec explicitly allows the LOC extra data size to\n         * be different from the CEN extra data size. Since we cannot trust\n         * the CEN extra data size, we need to read the LOC to determine\n         * the entry data offset.\n         */\n        private long initDataOffset() throws IOException {\n            if (pos <= 0) {\n                byte[] loc = new byte[LOCHDR];\n                pos = -pos;\n                int len = ZipFile.this.res.zsrc.readFullyAt(loc, 0, loc.length, pos);\n                if (len != LOCHDR) {\n                    throw new ZipException(\"ZipFile error reading zip file\");\n                }\n                if (LOCSIG(loc) != LOCSIG) {\n                    throw new ZipException(\"ZipFile invalid LOC header (bad signature)\");\n                }\n                pos += LOCHDR + LOCNAM(loc) + LOCEXT(loc);\n                startingPos = pos; // Save starting position for the entry\n            }\n            return pos;\n        }\n\n        public int read(byte b[], int off, int len) throws IOException {\n            synchronized (ZipFile.this) {\n                ensureOpenOrZipException();\n                initDataOffset();\n                if (rem == 0) {\n                    return -1;\n                }\n                if (len > rem) {\n                    len = (int) rem;\n                }\n                if (len <= 0) {\n                    return 0;\n                }\n                len = ZipFile.this.res.zsrc.readAt(b, off, len, pos);\n                if (len > 0) {\n                    pos += len;\n                    rem -= len;\n                }\n            }\n            if (rem == 0) {\n                close();\n            }\n            return len;\n        }\n\n        public int read() throws IOException {\n            byte[] b = new byte[1];\n            if (read(b, 0, 1) == 1) {\n                return b[0] & 0xff;\n            } else {\n                return -1;\n            }\n        }\n\n        public long skip(long n) throws IOException {\n            synchronized (ZipFile.this) {\n                initDataOffset();\n                long newPos = pos + n;\n                if (n > 0) {\n                    // If we overflowed adding the skip value or are moving\n                    // past EOF, set the skip value to number of bytes remaining\n                    // to reach EOF\n                    if (newPos < 0 || n > rem) {\n                        n = rem;\n                    }\n                } else if (newPos < startingPos) {\n                    // Tried to position before BOF so set position to the\n                    // BOF and return the number of bytes we moved backwards\n                    // to reach BOF\n                    n = startingPos - pos;\n                }\n                pos += n;\n                rem -= n;\n            }\n            if (rem == 0) {\n                close();\n            }\n            return n;\n        }\n\n        public int available() {\n            return rem > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) rem;\n        }\n\n        public long size() {\n            return size;\n        }\n\n        public void close() {\n            if (closeRequested) {\n                return;\n            }\n            closeRequested = true;\n            rem = 0;\n            synchronized (res.istreams) {\n                res.istreams.remove(this);\n            }\n        }\n\n    }\n\n    /**\n     * Returns {@code true} if, and only if, the zip file begins with {@code\n     * LOCSIG}.\n     * @hide\n     */\n    // Android-added: Access startsWithLocHeader() directly.\n    // Make hidden public for use by sun.misc.URLClassPath\n    public boolean startsWithLocHeader() {\n        return res.zsrc.startsWithLoc;\n    }\n\n    // Android-changed: marked as protected so JarFile can access it.\n    /**\n     * Returns the names of the META-INF/MANIFEST.MF entry - if exists -\n     * and any signature-related files under META-INF. This method is used in\n     * JarFile, via SharedSecrets, as an optimization.\n     * @hide\n     */\n    protected List<String> getManifestAndSignatureRelatedFiles() {\n        synchronized (this) {\n            ensureOpen();\n            Source zsrc = res.zsrc;\n            int[] metanames = zsrc.signatureMetaNames;\n            List<String> files = null;\n            if (zsrc.manifestPos >= 0) {\n                files = new ArrayList<>();\n                files.add(getEntryName(zsrc.manifestPos));\n            }\n            if (metanames != null) {\n                if (files == null) {\n                    files = new ArrayList<>();\n                }\n                for (int i = 0; i < metanames.length; i++) {\n                    files.add(getEntryName(metanames[i]));\n                }\n            }\n            return files == null ? List.of() : files;\n        }\n    }\n\n    /**\n     * Returns the number of the META-INF/MANIFEST.MF entries, case insensitive.\n     * When this number is greater than 1, JarVerifier will treat a file as\n     * unsigned.\n     */\n    private int getManifestNum() {\n        synchronized (this) {\n            ensureOpen();\n            return res.zsrc.manifestNum;\n        }\n    }\n\n    // Android-changed: marked public and @hide as alternative to JavaUtilZipFileAccess.getManifestName.\n    /**\n     * Returns the name of the META-INF/MANIFEST.MF entry, ignoring\n     * case. If {@code onlyIfSignatureRelatedFiles} is true, we only return the\n     * manifest if there is also at least one signature-related file.\n     * This method is used in JarFile, via SharedSecrets, as an optimization\n     * when looking up the manifest file.\n     * @hide\n     */\n    protected String getManifestName(boolean onlyIfSignatureRelatedFiles) {\n        synchronized (this) {\n            ensureOpen();\n            Source zsrc = res.zsrc;\n            int pos = zsrc.manifestPos;\n            if (pos >= 0 && (!onlyIfSignatureRelatedFiles || zsrc.signatureMetaNames != null)) {\n                return getEntryName(pos);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the versions for which there exists a non-directory\n     * entry that begin with \"META-INF/versions/\" (case ignored).\n     * This method is used in JarFile, via SharedSecrets, as an\n     * optimization when looking up potentially versioned entries.\n     * Returns an empty array if no versioned entries exist.\n     */\n    private int[] getMetaInfVersions() {\n        synchronized (this) {\n            ensureOpen();\n            return res.zsrc.metaVersions;\n        }\n    }\n\n    // Android-removed: this code does not run on Windows and JavaUtilZipFileAccess is not imported.\n    /*\n    private static boolean isWindows;\n\n    static {\n        SharedSecrets.setJavaUtilZipFileAccess(\n            new JavaUtilZipFileAccess() {\n                @Override\n                public boolean startsWithLocHeader(ZipFile zip) {\n                    return zip.res.zsrc.startsWithLoc;\n                }\n                @Override\n                public List<String> getManifestAndSignatureRelatedFiles(JarFile jar) {\n                    return ((ZipFile)jar).getManifestAndSignatureRelatedFiles();\n                }\n                @Override\n                public int getManifestNum(JarFile jar) {\n                    return ((ZipFile)jar).getManifestNum();\n                }\n                @Override\n                public String getManifestName(JarFile jar, boolean onlyIfHasSignatureRelatedFiles) {\n                    return ((ZipFile)jar).getManifestName(onlyIfHasSignatureRelatedFiles);\n                }\n                @Override\n                public int[] getMetaInfVersions(JarFile jar) {\n                    return ((ZipFile)jar).getMetaInfVersions();\n                }\n                @Override\n                public Enumeration<JarEntry> entries(ZipFile zip) {\n                    return zip.jarEntries();\n                }\n                @Override\n                public Stream<JarEntry> stream(ZipFile zip) {\n                    return zip.jarStream();\n                }\n                @Override\n                public Stream<String> entryNameStream(ZipFile zip) {\n                    return zip.entryNameStream();\n                }\n                @Override\n                public int getExtraAttributes(ZipEntry ze) {\n                    return ze.extraAttributes;\n                }\n                @Override\n                public void setExtraAttributes(ZipEntry ze, int extraAttrs) {\n                    ze.extraAttributes = extraAttrs;\n                }\n\n             }\n        );\n        isWindows = VM.getSavedProperty(\"os.name\").contains(\"Windows\");\n    }\n    */\n\n    private static class Source {\n        // While this is only used from ZipFile, defining it there would cause\n        // a bootstrap cycle that would leave this initialized as null\n        // Android-removed: JavaUtilJarAccess is not available.\n        // private static final JavaUtilJarAccess JUJA = SharedSecrets.javaUtilJarAccess();\n        // \"META-INF/\".length()\n        private static final int META_INF_LEN = 9;\n        private static final int[] EMPTY_META_VERSIONS = new int[0];\n\n        private final Key key;               // the key in files\n        private final @Stable ZipCoder zc;   // zip coder used to decode/encode\n\n        private int refs = 1;\n\n        private RandomAccessFile zfile;      // zfile of the underlying zip file\n        private byte[] cen;                  // CEN & ENDHDR\n        private long locpos;                 // position of first LOC header (usually 0)\n        private byte[] comment;              // zip file comment\n                                             // list of meta entries in META-INF dir\n        private int   manifestPos = -1;      // position of the META-INF/MANIFEST.MF, if exists\n        private int   manifestNum = 0;       // number of META-INF/MANIFEST.MF, case insensitive\n        private int[] signatureMetaNames;    // positions of signature related entries, if such exist\n        private int[] metaVersions;          // list of unique versions found in META-INF/versions/\n        private final boolean startsWithLoc; // true, if zip file starts with LOCSIG (usually true)\n\n        // A Hashmap for all entries.\n        //\n        // A cen entry of Zip/JAR file. As we have one for every entry in every active Zip/JAR,\n        // We might have a lot of these in a typical system. In order to save space we don't\n        // keep the name in memory, but merely remember a 32 bit {@code hash} value of the\n        // entry name and its offset {@code pos} in the central directory hdeader.\n        //\n        // private static class Entry {\n        //     int hash;       // 32 bit hashcode on name\n        //     int next;       // hash chain: index into entries\n        //     int pos;        // Offset of central directory file header\n        // }\n        // private Entry[] entries;             // array of hashed cen entry\n        //\n        // To reduce the total size of entries further, we use a int[] here to store 3 \"int\"\n        // {@code hash}, {@code next} and {@code pos} for each entry. The entry can then be\n        // referred by their index of their positions in the {@code entries}.\n        //\n        private int[] entries;                  // array of hashed cen entry\n\n        // Checks the entry at offset pos in the CEN, calculates the Entry values as per above,\n        // then returns the length of the entry name.\n        private int checkAndAddEntry(int pos, int index)\n            throws ZipException\n        {\n            byte[] cen = this.cen;\n            if (CENSIG(cen, pos) != CENSIG) {\n                zerror(\"invalid CEN header (bad signature)\");\n            }\n            int method = CENHOW(cen, pos);\n            int flag   = CENFLG(cen, pos);\n            if ((flag & 1) != 0) {\n                zerror(\"invalid CEN header (encrypted entry)\");\n            }\n            if (method != STORED && method != DEFLATED) {\n                zerror(\"invalid CEN header (bad compression method: \" + method + \")\");\n            }\n            int entryPos = pos + CENHDR;\n            int nlen = CENNAM(cen, pos);\n            if (entryPos + nlen > cen.length - ENDHDR) {\n                zerror(\"invalid CEN header (bad header size)\");\n            }\n            try {\n                ZipCoder zcp = zipCoderForPos(pos);\n                int hash = zcp.checkedHash(cen, entryPos, nlen);\n                int hsh = (hash & 0x7fffffff) % tablelen;\n                int next = table[hsh];\n                table[hsh] = index;\n                // Record the CEN offset and the name hash in our hash cell.\n                entries[index++] = hash;\n                entries[index++] = next;\n                entries[index  ] = pos;\n            } catch (Exception e) {\n                zerror(\"invalid CEN header (bad entry name)\");\n            }\n            return nlen;\n        }\n\n        private int getEntryHash(int index) { return entries[index]; }\n        private int getEntryNext(int index) { return entries[index + 1]; }\n        private int getEntryPos(int index)  { return entries[index + 2]; }\n        private static final int ZIP_ENDCHAIN  = -1;\n        private int total;                   // total number of entries\n        private int[] table;                 // Hash chain heads: indexes into entries\n        private int tablelen;                // number of hash heads\n\n        // Android-changed: isZipFilePathValidatorEnabled added as Key part. Key is used as key in\n        // files HashMap, so not including it could lead to opening ZipFile w/o entry names\n        // validation.\n        private static class Key {\n            final BasicFileAttributes attrs;\n            File file;\n            final boolean utf8;\n            // Android-added: isZipFilePathValidatorEnabled added as Key part.\n            final boolean isZipFilePathValidatorEnabled;\n\n            public Key(File file, BasicFileAttributes attrs, ZipCoder zc) {\n                this(file, attrs, zc, /* isZipFilePathValidatorEnabled= */ false);\n            }\n\n            // Android-added: added constructor with isZipFilePathValidatorEnabled argument.\n            public Key(File file, BasicFileAttributes attrs, ZipCoder zc,\n                    boolean isZipFilePathValidatorEnabled) {\n                this.attrs = attrs;\n                this.file = file;\n                this.utf8 = zc.isUTF8();\n                this.isZipFilePathValidatorEnabled = isZipFilePathValidatorEnabled;\n            }\n\n            public int hashCode() {\n                long t = utf8 ? 0 : Long.MAX_VALUE;\n                t += attrs.lastModifiedTime().toMillis();\n                // Android-changed: include izZipFilePathValidatorEnabled in hash computation.\n                // return ((int)(t ^ (t >>> 32))) + file.hashCode();\n                return ((int)(t ^ (t >>> 32))) + file.hashCode()\n                        + Boolean.hashCode(isZipFilePathValidatorEnabled);\n            }\n\n            public boolean equals(Object obj) {\n                if (obj instanceof Key key) {\n                    if (key.utf8 != utf8) {\n                        return false;\n                    }\n                    if (!attrs.lastModifiedTime().equals(key.attrs.lastModifiedTime())) {\n                        return false;\n                    }\n                    // Android-added: include isZipFilePathValidatorEnabled as equality part.\n                    if (key.isZipFilePathValidatorEnabled != isZipFilePathValidatorEnabled) {\n                        return false;\n                    }\n                    Object fk = attrs.fileKey();\n                    if (fk != null) {\n                        return fk.equals(key.attrs.fileKey());\n                    } else {\n                        return file.equals(key.file);\n                    }\n                }\n                return false;\n            }\n        }\n        private static final HashMap<Key, Source> files = new HashMap<>();\n\n\n        // Android-changed: pass izZipFilePathValidatorEnabled argument.\n        // static Source get(File file, boolean toDelete, ZipCoder zc) throws IOException {\n        static Source get(File file, boolean toDelete, ZipCoder zc,\n                boolean isZipPathValidatorEnabled) throws IOException {\n            final Key key;\n            try {\n                // BEGIN Android-changed: isZipFilePathValidatorEnabled passed as part of Key.\n                /*\n                key = new Key(file,\n                        Files.readAttributes(file.toPath(), BasicFileAttributes.class),\n                        zc);\n                */\n                key = new Key(file,\n                        Files.readAttributes(file.toPath(), BasicFileAttributes.class),\n                        zc, isZipPathValidatorEnabled);\n                // END Android-changed: isZipFilePathValidatorEnabled passed as part of Key.\n            } catch (InvalidPathException ipe) {\n                throw new IOException(ipe);\n            }\n            Source src;\n            synchronized (files) {\n                src = files.get(key);\n                if (src != null) {\n                    src.refs++;\n                    return src;\n                }\n            }\n            src = new Source(key, toDelete, zc);\n\n            synchronized (files) {\n                if (files.containsKey(key)) {    // someone else put in first\n                    src.close();                 // close the newly created one\n                    src = files.get(key);\n                    src.refs++;\n                    return src;\n                }\n                files.put(key, src);\n                return src;\n            }\n        }\n\n        static void release(Source src) throws IOException {\n            synchronized (files) {\n                if (src != null && --src.refs == 0) {\n                    files.remove(src.key);\n                    src.close();\n                }\n            }\n        }\n\n        private Source(Key key, boolean toDelete, ZipCoder zc) throws IOException {\n            this.zc = zc;\n            this.key = key;\n            if (toDelete) {\n                // BEGIN Android-changed: we are not targeting Windows, keep else branch only. Also\n                // open file with O_CLOEXEC flag set.\n                /*\n                if (isWindows) {\n                    this.zfile = SharedSecrets.getJavaIORandomAccessFileAccess()\n                                              .openAndDelete(key.file, \"r\");\n                } else {\n                    this.zfile = new RandomAccessFile(key.file, \"r\");\n                    key.file.delete();\n                }\n                */\n                this.zfile = new RandomAccessFile(key.file, \"r\", /* setCloExecFlag= */ true);\n                key.file.delete();\n                // END Android-changed: we are not targeting Windows, keep else branch only.\n            } else {\n                // Android-changed: open with O_CLOEXEC flag set.\n                // this.zfile = new RandomAccessFile(key.file, \"r\");\n                this.zfile = new RandomAccessFile(key.file, \"r\", /* setCloExecFlag= */ true);\n            }\n            try {\n                initCEN(-1);\n                byte[] buf = new byte[4];\n                readFullyAt(buf, 0, 4, 0);\n                // BEGIN Android-changed: do not accept files with invalid header\n                // this.startsWithLoc = (LOCSIG(buf) == LOCSIG);\n                long locsig = LOCSIG(buf);\n                this.startsWithLoc = (locsig == LOCSIG);\n                // If a zip file starts with \"end of central directory record\" it means that such\n                // file is empty.\n                if (locsig != LOCSIG && locsig != ENDSIG) {\n                    String msg = \"Entry at offset zero has invalid LFH signature \"\n                                    + Long.toHexString(locsig);\n                    throw new ZipException(msg);\n                }\n                // END Android-changed: do not accept files with invalid header\n            } catch (IOException x) {\n                try {\n                    this.zfile.close();\n                } catch (IOException xx) {}\n                throw x;\n            }\n        }\n\n        private void close() throws IOException {\n            zfile.close();\n            zfile = null;\n            cen = null;\n            entries = null;\n            table = null;\n            manifestPos = -1;\n            manifestNum = 0;\n            signatureMetaNames = null;\n            metaVersions = EMPTY_META_VERSIONS;\n        }\n\n        private static final int BUF_SIZE = 8192;\n        private final int readFullyAt(byte[] buf, int off, int len, long pos)\n            throws IOException\n        {\n            synchronized (zfile) {\n                zfile.seek(pos);\n                int N = len;\n                while (N > 0) {\n                    int n = Math.min(BUF_SIZE, N);\n                    zfile.readFully(buf, off, n);\n                    off += n;\n                    N -= n;\n                }\n                return len;\n            }\n        }\n\n        private final int readAt(byte[] buf, int off, int len, long pos)\n            throws IOException\n        {\n            synchronized (zfile) {\n                zfile.seek(pos);\n                return zfile.read(buf, off, len);\n            }\n        }\n\n\n        private static class End {\n            int  centot;     // 4 bytes\n            long cenlen;     // 4 bytes\n            long cenoff;     // 4 bytes\n            long endpos;     // 4 bytes\n        }\n\n        /*\n         * Searches for end of central directory (END) header. The contents of\n         * the END header will be read and placed in endbuf. Returns the file\n         * position of the END header, otherwise returns -1 if the END header\n         * was not found or an error occurred.\n         */\n        private End findEND() throws IOException {\n            long ziplen = zfile.length();\n            if (ziplen <= 0)\n                zerror(\"zip file is empty\");\n            End end = new End();\n            byte[] buf = new byte[READBLOCKSZ];\n            long minHDR = (ziplen - END_MAXLEN) > 0 ? ziplen - END_MAXLEN : 0;\n            long minPos = minHDR - (buf.length - ENDHDR);\n            for (long pos = ziplen - buf.length; pos >= minPos; pos -= (buf.length - ENDHDR)) {\n                int off = 0;\n                if (pos < 0) {\n                    // Pretend there are some NUL bytes before start of file\n                    off = (int)-pos;\n                    Arrays.fill(buf, 0, off, (byte)0);\n                }\n                int len = buf.length - off;\n                if (readFullyAt(buf, off, len, pos + off) != len ) {\n                    zerror(\"zip END header not found\");\n                }\n                // Now scan the block backwards for END header signature\n                for (int i = buf.length - ENDHDR; i >= 0; i--) {\n                    if (buf[i+0] == (byte)'P'    &&\n                        buf[i+1] == (byte)'K'    &&\n                        buf[i+2] == (byte)'\\005' &&\n                        buf[i+3] == (byte)'\\006') {\n                        // Found ENDSIG header\n                        byte[] endbuf = Arrays.copyOfRange(buf, i, i + ENDHDR);\n                        end.centot = ENDTOT(endbuf);\n                        end.cenlen = ENDSIZ(endbuf);\n                        end.cenoff = ENDOFF(endbuf);\n                        end.endpos = pos + i;\n                        int comlen = ENDCOM(endbuf);\n                        if (end.endpos + ENDHDR + comlen != ziplen) {\n                            // ENDSIG matched, however the size of file comment in it does\n                            // not match the real size. One \"common\" cause for this problem\n                            // is some \"extra\" bytes are padded at the end of the zipfile.\n                            // Let's do some extra verification, we don't care about the\n                            // performance in this situation.\n                            byte[] sbuf = new byte[4];\n                            long cenpos = end.endpos - end.cenlen;\n                            long locpos = cenpos - end.cenoff;\n                            if  (cenpos < 0 ||\n                                 locpos < 0 ||\n                                 readFullyAt(sbuf, 0, sbuf.length, cenpos) != 4 ||\n                                 GETSIG(sbuf) != CENSIG ||\n                                 readFullyAt(sbuf, 0, sbuf.length, locpos) != 4 ||\n                                 GETSIG(sbuf) != LOCSIG) {\n                                continue;\n                            }\n                        }\n                        if (comlen > 0) {    // this zip file has comlen\n                            comment = new byte[comlen];\n                            if (readFullyAt(comment, 0, comlen, end.endpos + ENDHDR) != comlen) {\n                                zerror(\"zip comment read failed\");\n                            }\n                        }\n                        // must check for a zip64 end record; it is always permitted to be present\n                        try {\n                            byte[] loc64 = new byte[ZIP64_LOCHDR];\n                            if (end.endpos < ZIP64_LOCHDR ||\n                                readFullyAt(loc64, 0, loc64.length, end.endpos - ZIP64_LOCHDR)\n                                != loc64.length || GETSIG(loc64) != ZIP64_LOCSIG) {\n                                return end;\n                            }\n                            long end64pos = ZIP64_LOCOFF(loc64);\n                            byte[] end64buf = new byte[ZIP64_ENDHDR];\n                            if (readFullyAt(end64buf, 0, end64buf.length, end64pos)\n                                != end64buf.length || GETSIG(end64buf) != ZIP64_ENDSIG) {\n                                return end;\n                            }\n                            // end64 candidate found,\n                            long cenlen64 = ZIP64_ENDSIZ(end64buf);\n                            long cenoff64 = ZIP64_ENDOFF(end64buf);\n                            long centot64 = ZIP64_ENDTOT(end64buf);\n                            // double-check\n                            if (cenlen64 != end.cenlen && end.cenlen != ZIP64_MAGICVAL ||\n                                cenoff64 != end.cenoff && end.cenoff != ZIP64_MAGICVAL ||\n                                centot64 != end.centot && end.centot != ZIP64_MAGICCOUNT) {\n                                return end;\n                            }\n                            // to use the end64 values\n                            end.cenlen = cenlen64;\n                            end.cenoff = cenoff64;\n                            end.centot = (int)centot64; // assume total < 2g\n                            end.endpos = end64pos;\n                        } catch (IOException x) {}    // no zip64 loc/end\n                        return end;\n                    }\n                }\n            }\n            throw new ZipException(\"zip END header not found\");\n        }\n\n        // Reads zip file central directory.\n        private void initCEN(int knownTotal) throws IOException {\n            // Prefer locals for better performance during startup\n            byte[] cen;\n            if (knownTotal == -1) {\n                End end = findEND();\n                if (end.endpos == 0) {\n                    locpos = 0;\n                    total = 0;\n                    entries = new int[0];\n                    this.cen = null;\n                    return;         // only END header present\n                }\n                if (end.cenlen > end.endpos)\n                    zerror(\"invalid END header (bad central directory size)\");\n                long cenpos = end.endpos - end.cenlen;     // position of CEN table\n                // Get position of first local file (LOC) header, taking into\n                // account that there may be a stub prefixed to the zip file.\n                locpos = cenpos - end.cenoff;\n                if (locpos < 0) {\n                    zerror(\"invalid END header (bad central directory offset)\");\n                }\n                // read in the CEN and END\n                cen = this.cen = new byte[(int)(end.cenlen + ENDHDR)];\n                if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {\n                    zerror(\"read CEN tables failed\");\n                }\n                this.total = end.centot;\n            } else {\n                cen = this.cen;\n                this.total = knownTotal;\n            }\n            // hash table for entries\n            int entriesLength = this.total * 3;\n            entries = new int[entriesLength];\n\n            int tablelen = ((total/2) | 1); // Odd -> fewer collisions\n            this.tablelen = tablelen;\n\n            int[] table = new int[tablelen];\n            this.table = table;\n\n            Arrays.fill(table, ZIP_ENDCHAIN);\n\n            // list for all meta entries\n            ArrayList<Integer> signatureNames = null;\n            // Set of all version numbers seen in META-INF/versions/\n            Set<Integer> metaVersionsSet = null;\n\n            // Iterate through the entries in the central directory\n            int idx = 0; // Index into the entries array\n            int pos = 0;\n            int entryPos = CENHDR;\n            int limit = cen.length - ENDHDR;\n            manifestNum = 0;\n            // Android-added: duplicate entries are not allowed. See CVE-2013-4787 and b/8219321\n            Set<String> entriesNames = new HashSet<>();\n            while (entryPos <= limit) {\n                if (idx >= entriesLength) {\n                    // This will only happen if the zip file has an incorrect\n                    // ENDTOT field, which usually means it contains more than\n                    // 65535 entries.\n                    initCEN(countCENHeaders(cen, limit));\n                    return;\n                }\n\n                // Checks the entry and adds values to entries[idx ... idx+2]\n                int nlen = checkAndAddEntry(pos, idx);\n\n                // BEGIN Android-added: duplicate entries are not allowed. See CVE-2013-4787\n                // and b/8219321.\n                // zipCoderForPos takes USE_UTF8 flag into account.\n                ZipCoder zcp = zipCoderForPos(entryPos);\n                String name = zcp.toString(cen, pos + CENHDR, nlen);\n                if (!entriesNames.add(name)) {\n                    zerror(\"Duplicate entry name: \" + name);\n                }\n                // END Android-added: duplicate entries are not allowed. See CVE-2013-4787\n                // and b/8219321\n                // BEGIN Android-added: don't allow NUL in entry names. We can handle it in Java fine,\n                // but it is of questionable utility as a valid pathname can't contain NUL.\n                for (int nameIdx = 0; nameIdx < nlen; ++nameIdx) {\n                    byte b = cen[pos + CENHDR + nameIdx];\n\n                    if (b == 0) {\n                        zerror(\"Filename contains NUL byte: \" + name);\n                    }\n                }\n                // END Android-added: don't allow NUL in entry names.\n                // BEGIN Android-changed: validation of zip entry names.\n                if (key.isZipFilePathValidatorEnabled && !ZipPathValidator.isClear()) {\n                    ZipPathValidator.getInstance().onZipEntryAccess(name);\n                }\n                // END Android-changed: validation of zip entry names.\n                idx += 3;\n\n                // Adds name to metanames.\n                if (isMetaName(cen, entryPos, nlen)) {\n                    // nlen is at least META_INF_LENGTH\n                    if (isManifestName(entryPos + META_INF_LEN, nlen - META_INF_LEN)) {\n                        manifestPos = pos;\n                        manifestNum++;\n                    } else {\n                        if (isSignatureRelated(entryPos, nlen)) {\n                            if (signatureNames == null)\n                                signatureNames = new ArrayList<>(4);\n                            signatureNames.add(pos);\n                        }\n\n                        // If this is a versioned entry, parse the version\n                        // and store it for later. This optimizes lookup\n                        // performance in multi-release jar files\n                        int version = getMetaVersion(entryPos + META_INF_LEN, nlen - META_INF_LEN);\n                        if (version > 0) {\n                            if (metaVersionsSet == null)\n                                metaVersionsSet = new TreeSet<>();\n                            metaVersionsSet.add(version);\n                        }\n                    }\n                }\n                // skip to the start of the next entry\n                pos = nextEntryPos(pos, entryPos, nlen);\n                entryPos = pos + CENHDR;\n            }\n\n            // Adjust the total entries\n            this.total = idx / 3;\n\n            if (signatureNames != null) {\n                int len = signatureNames.size();\n                signatureMetaNames = new int[len];\n                for (int j = 0; j < len; j++) {\n                    signatureMetaNames[j] = signatureNames.get(j);\n                }\n            }\n            if (metaVersionsSet != null) {\n                metaVersions = new int[metaVersionsSet.size()];\n                int c = 0;\n                for (Integer version : metaVersionsSet) {\n                    metaVersions[c++] = version;\n                }\n            } else {\n                metaVersions = EMPTY_META_VERSIONS;\n            }\n            if (pos + ENDHDR != cen.length) {\n                zerror(\"invalid CEN header (bad header size)\");\n            }\n        }\n\n        private int nextEntryPos(int pos, int entryPos, int nlen) {\n            return entryPos + nlen + CENCOM(cen, pos) + CENEXT(cen, pos);\n        }\n\n        private static void zerror(String msg) throws ZipException {\n            throw new ZipException(msg);\n        }\n\n        /*\n         * Returns the {@code pos} of the zip cen entry corresponding to the\n         * specified entry name, or -1 if not found.\n         */\n        private int getEntryPos(String name, boolean addSlash) {\n            if (total == 0) {\n                return -1;\n            }\n\n            int hsh = ZipCoder.hash(name);\n            int idx = table[(hsh & 0x7fffffff) % tablelen];\n\n            // Search down the target hash chain for a entry whose\n            // 32 bit hash matches the hashed name.\n            while (idx != ZIP_ENDCHAIN) {\n                if (getEntryHash(idx) == hsh) {\n                    // The CEN name must match the specfied one\n                    int pos = getEntryPos(idx);\n\n                    try {\n                        ZipCoder zc = zipCoderForPos(pos);\n                        String entry = zc.toString(cen, pos + CENHDR, CENNAM(cen, pos));\n\n                        // If addSlash is true we'll test for name+/ in addition to\n                        // name, unless name is the empty string or already ends with a\n                        // slash\n                        int entryLen = entry.length();\n                        int nameLen = name.length();\n                        if ((entryLen == nameLen && entry.equals(name)) ||\n                                (addSlash &&\n                                nameLen + 1 == entryLen &&\n                                entry.startsWith(name) &&\n                                entry.charAt(entryLen - 1) == '/')) {\n                            return pos;\n                        }\n                    } catch (IllegalArgumentException iae) {\n                        // Ignore\n                    }\n                }\n                idx = getEntryNext(idx);\n            }\n            return -1;\n        }\n\n        private ZipCoder zipCoderForPos(int pos) {\n            if (zc.isUTF8()) {\n                return zc;\n            }\n            if ((CENFLG(cen, pos) & USE_UTF8) != 0) {\n                return ZipCoder.UTF8;\n            }\n            return zc;\n        }\n\n        /**\n         * Returns true if the bytes represent a non-directory name\n         * beginning with \"META-INF/\", disregarding ASCII case.\n         */\n        private static boolean isMetaName(byte[] name, int off, int len) {\n            // Use the \"oldest ASCII trick in the book\":\n            // ch | 0x20 == Character.toLowerCase(ch)\n            return len > META_INF_LEN       // \"META-INF/\".length()\n                && name[off + len - 1] != '/'  // non-directory\n                && (name[off++] | 0x20) == 'm'\n                && (name[off++] | 0x20) == 'e'\n                && (name[off++] | 0x20) == 't'\n                && (name[off++] | 0x20) == 'a'\n                && (name[off++]       ) == '-'\n                && (name[off++] | 0x20) == 'i'\n                && (name[off++] | 0x20) == 'n'\n                && (name[off++] | 0x20) == 'f'\n                && (name[off]         ) == '/';\n        }\n\n        /*\n         * Check if the bytes represents a name equals to MANIFEST.MF\n         */\n        private boolean isManifestName(int off, int len) {\n            byte[] name = cen;\n            return (len == 11 // \"MANIFEST.MF\".length()\n                    && (name[off++] | 0x20) == 'm'\n                    && (name[off++] | 0x20) == 'a'\n                    && (name[off++] | 0x20) == 'n'\n                    && (name[off++] | 0x20) == 'i'\n                    && (name[off++] | 0x20) == 'f'\n                    && (name[off++] | 0x20) == 'e'\n                    && (name[off++] | 0x20) == 's'\n                    && (name[off++] | 0x20) == 't'\n                    && (name[off++]       ) == '.'\n                    && (name[off++] | 0x20) == 'm'\n                    && (name[off]   | 0x20) == 'f');\n        }\n\n        private boolean isSignatureRelated(int off, int len) {\n            // Only called when isMetaName(name, off, len) is true, which means\n            // len is at least META_INF_LENGTH\n            // assert isMetaName(name, off, len)\n            boolean signatureRelated = false;\n            byte[] name = cen;\n            if (name[off + len - 3] == '.') {\n                // Check if entry ends with .EC and .SF\n                int b1 = name[off + len - 2] | 0x20;\n                int b2 = name[off + len - 1] | 0x20;\n                if ((b1 == 'e' && b2 == 'c') || (b1 == 's' && b2 == 'f')) {\n                    signatureRelated = true;\n                }\n            } else if (name[off + len - 4] == '.') {\n                // Check if entry ends with .DSA and .RSA\n                int b1 = name[off + len - 3] | 0x20;\n                int b2 = name[off + len - 2] | 0x20;\n                int b3 = name[off + len - 1] | 0x20;\n                if ((b1 == 'r' || b1 == 'd') && b2 == 's' && b3 == 'a') {\n                    signatureRelated = true;\n                }\n            }\n            // Above logic must match SignatureFileVerifier.isBlockOrSF\n            assert(signatureRelated == SignatureFileVerifier\n                // Android-changed: use StandardCharsets.\n                // .isBlockOrSF(new String(name, off, len, UTF_8.INSTANCE)\n                .isBlockOrSF(new String(name, off, len, StandardCharsets.UTF_8)\n                    .toUpperCase(Locale.ENGLISH)));\n            return signatureRelated;\n        }\n\n        /*\n         * If the bytes represents a non-directory name beginning\n         * with \"versions/\", continuing with a positive integer,\n         * followed by a '/', then return that integer value.\n         * Otherwise, return 0\n         */\n        private int getMetaVersion(int off, int len) {\n            byte[] name = cen;\n            int nend = off + len;\n            if (!(len > 10                         // \"versions//\".length()\n                    && name[off + len - 1] != '/'  // non-directory\n                    && (name[off++] | 0x20) == 'v'\n                    && (name[off++] | 0x20) == 'e'\n                    && (name[off++] | 0x20) == 'r'\n                    && (name[off++] | 0x20) == 's'\n                    && (name[off++] | 0x20) == 'i'\n                    && (name[off++] | 0x20) == 'o'\n                    && (name[off++] | 0x20) == 'n'\n                    && (name[off++] | 0x20) == 's'\n                    && (name[off++]       ) == '/')) {\n                return 0;\n            }\n            int version = 0;\n            while (off < nend) {\n                final byte c = name[off++];\n                if (c == '/') {\n                    return version;\n                }\n                if (c < '0' || c > '9') {\n                    return 0;\n                }\n                version = version * 10 + c - '0';\n                // Check for overflow and leading zeros\n                if (version <= 0) {\n                    return 0;\n                }\n            }\n            return 0;\n        }\n\n        /**\n         * Returns the number of CEN headers in a central directory.\n         * Will not throw, even if the zip file is corrupt.\n         *\n         * @param cen copy of the bytes in a zip file's central directory\n         * @param size number of bytes in central directory\n         */\n        private static int countCENHeaders(byte[] cen, int size) {\n            int count = 0;\n            for (int p = 0;\n                 p + CENHDR <= size;\n                 p += CENHDR + CENNAM(cen, p) + CENEXT(cen, p) + CENCOM(cen, p))\n                count++;\n            return count;\n        }\n    }\n}\n```",
            "upstream_file_tokens": {
              "openai": 16348,
              "general": {
                "word_based": 7485,
                "char_based": 19058
              },
              "gemini": 18713
            },
            "downstream_file_content": "```java\n/*\n * Copyright (C) 2014 The Android Open Source Project\n * Copyright (c) 1995, 2015, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.util.zip;\n\nimport java.io.Closeable;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.WeakHashMap;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport dalvik.system.CloseGuard;\nimport dalvik.system.ZipPathValidator;\n\nimport static java.util.zip.ZipConstants64.*;\n\n/**\n * This class is used to read entries from a zip file.\n *\n * <p> Unless otherwise noted, passing a <tt>null</tt> argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * @author      David Connelly\n */\npublic\nclass ZipFile implements ZipConstants, Closeable {\n    // Android-note: jzfile does not require @ReachabilitySensitive annotation.\n    // The @ReachabilitySensitive annotation is usually added to instance fields that references\n    // native data that is cleaned up when the instance becomes unreachable. Its presence ensures\n    // that the instance object is not finalized until the field is no longer used. Without it an\n    // instance could be finalized during execution of an instance method iff that method's this\n    // variable holds the last reference to the instance and the method had copied all the fields\n    // it needs out of the instance. That would release the native data, invalidating its reference\n    // and would cause serious problems if the method had taken a copy of that field and\n    // then called a native method that would try to use it.\n    //\n    // This field does not require the annotation because all usages of this field are enclosed\n    // within a synchronized(this) block and finalizing of the object referenced in a synchronized\n    // block is not allowed as that would release its monitor that is currently in use.\n    private long jzfile;  // address of jzfile data\n    private final String name;     // zip file name\n    private final int total;       // total number of entries\n    private final boolean locsig;  // if zip file starts with LOCSIG (usually true)\n    private volatile boolean closeRequested = false;\n\n    // Android-added: CloseGuard support.\n    private final CloseGuard guard = CloseGuard.get();\n\n    // Android-added: Do not use unlink() to implement OPEN_DELETE.\n    // Upstream uses unlink() to cause the file name to be removed from the filesystem after it is\n    // opened but that does not work on fuse fs as it causes problems with lseek. Android simply\n    // keeps a reference to the File so that it can explicitly delete it during close.\n    //\n    // OpenJDK 9+181 has a pure Java implementation of ZipFile that does not use unlink() and\n    // instead does something very similar to what Android does. If Android adopts it then this\n    // patch can be dropped.\n    // See http://b/28950284 and http://b/28901232 for more details.\n    private final File fileToRemoveOnClose;\n\n    private static final int STORED = ZipEntry.STORED;\n    private static final int DEFLATED = ZipEntry.DEFLATED;\n\n    /**\n     * Mode flag to open a zip file for reading.\n     */\n    public static final int OPEN_READ = 0x1;\n\n    /**\n     * Mode flag to open a zip file and mark it for deletion.  The file will be\n     * deleted some time between the moment that it is opened and the moment\n     * that it is closed, but its contents will remain accessible via the\n     * <tt>ZipFile</tt> object until either the close method is invoked or the\n     * virtual machine exits.\n     */\n    public static final int OPEN_DELETE = 0x4;\n\n    // Android-removed: initIDs() not used on Android.\n    /*\n    static {\n        /* Zip library is loaded from System.initializeSystemClass *\n        initIDs();\n    }\n\n    private static native void initIDs();\n    */\n\n    private static final boolean usemmap;\n\n    // Android-added: An instance variable that determines if zip path validation should be enabled.\n    private final boolean isZipPathValidatorEnabled;\n\n    static {\n        // Android-changed: Always use mmap.\n        /*\n        // A system prpperty to disable mmap use to avoid vm crash when\n        // in-use zip file is accidently overwritten by others.\n        String prop = sun.misc.VM.getSavedProperty(\"sun.zip.disableMemoryMapping\");\n        usemmap = (prop == null ||\n                   !(prop.length() == 0 || prop.equalsIgnoreCase(\"true\")));\n        */\n        usemmap = true;\n    }\n\n    // Android-changed: Additional ZipException throw scenario with ZipPathValidator.\n    /**\n     * Opens a zip file for reading.\n     *\n     * <p>First, if there is a security manager, its <code>checkRead</code>\n     * method is called with the <code>name</code> argument as its argument\n     * to ensure the read is allowed.\n     *\n     * <p>The UTF-8 {@link java.nio.charset.Charset charset} is used to\n     * decode the entry names and comments.\n     *\n     * <p>If the app targets Android U or above, zip file entry names containing\n     * \"..\" or starting with \"/\" passed here will throw a {@link ZipException}.\n     * For more details, see {@link dalvik.system.ZipPathValidator}.\n     *\n     * @param name the name of the zip file\n     * @throws ZipException if (1) a ZIP format error has occurred or\n     *         (2) <code>targetSdkVersion >= BUILD.VERSION_CODES.UPSIDE_DOWN_CAKE</code>\n     *         and (the <code>name</code> argument contains \"..\" or starts with \"/\").\n     * @throws IOException if an I/O error has occurred\n     * @throws SecurityException if a security manager exists and its\n     *         <code>checkRead</code> method doesn't allow read access to the file.\n     *\n     * @see SecurityManager#checkRead(java.lang.String)\n     */\n    public ZipFile(String name) throws IOException {\n        this(new File(name), OPEN_READ);\n    }\n\n    /**\n     * Opens a new <code>ZipFile</code> to read from the specified\n     * <code>File</code> object in the specified mode.  The mode argument\n     * must be either <tt>OPEN_READ</tt> or <tt>OPEN_READ | OPEN_DELETE</tt>.\n     *\n     * <p>First, if there is a security manager, its <code>checkRead</code>\n     * method is called with the <code>name</code> argument as its argument to\n     * ensure the read is allowed.\n     *\n     * <p>The UTF-8 {@link java.nio.charset.Charset charset} is used to\n     * decode the entry names and comments\n     *\n     * @param file the ZIP file to be opened for reading\n     * @param mode the mode in which the file is to be opened\n     * @throws ZipException if a ZIP format error has occurred\n     * @throws IOException if an I/O error has occurred\n     * @throws SecurityException if a security manager exists and\n     *         its <code>checkRead</code> method\n     *         doesn't allow read access to the file,\n     *         or its <code>checkDelete</code> method doesn't allow deleting\n     *         the file when the <tt>OPEN_DELETE</tt> flag is set.\n     * @throws IllegalArgumentException if the <tt>mode</tt> argument is invalid\n     * @see SecurityManager#checkRead(java.lang.String)\n     * @since 1.3\n     */\n    public ZipFile(File file, int mode) throws IOException {\n        this(file, mode, StandardCharsets.UTF_8);\n    }\n\n    /**\n     * Opens a ZIP file for reading given the specified File object.\n     *\n     * <p>The UTF-8 {@link java.nio.charset.Charset charset} is used to\n     * decode the entry names and comments.\n     *\n     * @param file the ZIP file to be opened for reading\n     * @throws ZipException if a ZIP format error has occurred\n     * @throws IOException if an I/O error has occurred\n     */\n    public ZipFile(File file) throws ZipException, IOException {\n        this(file, OPEN_READ);\n    }\n\n    private ZipCoder zc;\n\n    // Android-changed: Use of the hidden constructor with a new argument for zip path validation.\n    /**\n     * Opens a new <code>ZipFile</code> to read from the specified\n     * <code>File</code> object in the specified mode.  The mode argument\n     * must be either <tt>OPEN_READ</tt> or <tt>OPEN_READ | OPEN_DELETE</tt>.\n     *\n     * <p>First, if there is a security manager, its <code>checkRead</code>\n     * method is called with the <code>name</code> argument as its argument to\n     * ensure the read is allowed.\n     *\n     * @param file the ZIP file to be opened for reading\n     * @param mode the mode in which the file is to be opened\n     * @param charset\n     *        the {@linkplain java.nio.charset.Charset charset} to\n     *        be used to decode the ZIP entry name and comment that are not\n     *        encoded by using UTF-8 encoding (indicated by entry's general\n     *        purpose flag).\n     *\n     * @throws ZipException if a ZIP format error has occurred\n     * @throws IOException if an I/O error has occurred\n     *\n     * @throws SecurityException\n     *         if a security manager exists and its <code>checkRead</code>\n     *         method doesn't allow read access to the file,or its\n     *         <code>checkDelete</code> method doesn't allow deleting the\n     *         file when the <tt>OPEN_DELETE</tt> flag is set\n     *\n     * @throws IllegalArgumentException if the <tt>mode</tt> argument is invalid\n     *\n     * @see SecurityManager#checkRead(java.lang.String)\n     *\n     * @since 1.7\n     */\n    public ZipFile(File file, int mode, Charset charset) throws IOException\n    {\n        this(file, mode, charset, /* enableZipPathValidator */ true);\n    }\n\n    // Android-added: New hidden constructor with an argument for zip path validation.\n    /** @hide */\n    public ZipFile(File file, int mode, boolean enableZipPathValidator) throws IOException {\n        this(file, mode, StandardCharsets.UTF_8, enableZipPathValidator);\n    }\n\n    // Android-changed: Change existing constructor ZipFile(File file, int mode, Charset charset)\n    // to have a new argument enableZipPathValidator in order to set the isZipPathValidatorEnabled\n    // variable before calling the native method open().\n    /** @hide */\n    public ZipFile(File file, int mode, Charset charset, boolean enableZipPathValidator)\n            throws IOException {\n        isZipPathValidatorEnabled = enableZipPathValidator && !ZipPathValidator.isClear();\n        if (((mode & OPEN_READ) == 0) ||\n            ((mode & ~(OPEN_READ | OPEN_DELETE)) != 0)) {\n            throw new IllegalArgumentException(\"Illegal mode: 0x\"+\n                                               Integer.toHexString(mode));\n        }\n        String name = file.getPath();\n        // Android-removed: SecurityManager is always null.\n        /*\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkRead(name);\n            if ((mode & OPEN_DELETE) != 0) {\n                sm.checkDelete(name);\n            }\n        }\n        */\n\n        // Android-added: Do not use unlink() to implement OPEN_DELETE.\n        fileToRemoveOnClose = ((mode & OPEN_DELETE) != 0) ? file : null;\n\n        if (charset == null)\n            throw new NullPointerException(\"charset is null\");\n        this.zc = ZipCoder.get(charset);\n        // Android-removed: Skip perf counters.\n        // long t0 = System.nanoTime();\n        jzfile = open(name, mode, file.lastModified(), usemmap);\n        // Android-removed: Skip perf counters.\n        // sun.misc.PerfCounter.getZipFileOpenTime().addElapsedTimeFrom(t0);\n        // sun.misc.PerfCounter.getZipFileCount().increment();\n        this.name = name;\n        this.total = getTotal(jzfile);\n        this.locsig = startsWithLOC(jzfile);\n        // Android-added: CloseGuard support.\n        guard.open(\"close\");\n    }\n\n    /**\n     * Opens a zip file for reading.\n     *\n     * <p>First, if there is a security manager, its <code>checkRead</code>\n     * method is called with the <code>name</code> argument as its argument\n     * to ensure the read is allowed.\n     *\n     * @param name the name of the zip file\n     * @param charset\n     *        the {@linkplain java.nio.charset.Charset charset} to\n     *        be used to decode the ZIP entry name and comment that are not\n     *        encoded by using UTF-8 encoding (indicated by entry's general\n     *        purpose flag).\n     *\n     * @throws ZipException if a ZIP format error has occurred\n     * @throws IOException if an I/O error has occurred\n     * @throws SecurityException\n     *         if a security manager exists and its <code>checkRead</code>\n     *         method doesn't allow read access to the file\n     *\n     * @see SecurityManager#checkRead(java.lang.String)\n     *\n     * @since 1.7\n     */\n    public ZipFile(String name, Charset charset) throws IOException\n    {\n        this(new File(name), OPEN_READ, charset);\n    }\n\n    /**\n     * Opens a ZIP file for reading given the specified File object.\n     * @param file the ZIP file to be opened for reading\n     * @param charset\n     *        The {@linkplain java.nio.charset.Charset charset} to be\n     *        used to decode the ZIP entry name and comment (ignored if\n     *        the <a href=\"package-summary.html#lang_encoding\"> language\n     *        encoding bit</a> of the ZIP entry's general purpose bit\n     *        flag is set).\n     *\n     * @throws ZipException if a ZIP format error has occurred\n     * @throws IOException if an I/O error has occurred\n     *\n     * @since 1.7\n     */\n    public ZipFile(File file, Charset charset) throws IOException\n    {\n        this(file, OPEN_READ, charset);\n    }\n\n    /**\n     * Returns the zip file comment, or null if none.\n     *\n     * @return the comment string for the zip file, or null if none\n     *\n     * @throws IllegalStateException if the zip file has been closed\n     *\n     * Since 1.7\n     */\n    public String getComment() {\n        synchronized (this) {\n            ensureOpen();\n            byte[] bcomm = getCommentBytes(jzfile);\n            if (bcomm == null)\n                return null;\n            return zc.toString(bcomm, bcomm.length);\n        }\n    }\n\n    /**\n     * Returns the zip file entry for the specified name, or null\n     * if not found.\n     *\n     * @param name the name of the entry\n     * @return the zip file entry, or null if not found\n     * @throws IllegalStateException if the zip file has been closed\n     */\n    public ZipEntry getEntry(String name) {\n        if (name == null) {\n            throw new NullPointerException(\"name\");\n        }\n        long jzentry = 0;\n        synchronized (this) {\n            ensureOpen();\n            jzentry = getEntry(jzfile, zc.getBytes(name), true);\n            if (jzentry != 0) {\n                ZipEntry ze = getZipEntry(name, jzentry);\n                freeEntry(jzfile, jzentry);\n                return ze;\n            }\n        }\n        return null;\n    }\n\n    private static native long getEntry(long jzfile, byte[] name,\n                                        boolean addSlash);\n\n    // freeEntry releases the C jzentry struct.\n    private static native void freeEntry(long jzfile, long jzentry);\n\n    // the outstanding inputstreams that need to be closed,\n    // mapped to the inflater objects they use.\n    private final Map<InputStream, Inflater> streams = new WeakHashMap<>();\n\n    /**\n     * Returns an input stream for reading the contents of the specified\n     * zip file entry.\n     *\n     * <p> Closing this ZIP file will, in turn, close all input\n     * streams that have been returned by invocations of this method.\n     *\n     * @param entry the zip file entry\n     * @return the input stream for reading the contents of the specified\n     * zip file entry.\n     * @throws ZipException if a ZIP format error has occurred\n     * @throws IOException if an I/O error has occurred\n     * @throws IllegalStateException if the zip file has been closed\n     */\n    public InputStream getInputStream(ZipEntry entry) throws IOException {\n        if (entry == null) {\n            throw new NullPointerException(\"entry\");\n        }\n        long jzentry = 0;\n        ZipFileInputStream in = null;\n        synchronized (this) {\n            ensureOpen();\n            if (!zc.isUTF8() && (entry.flag & USE_UTF8) != 0) {\n                // Android-changed: Find entry by name, falling back to name/ if cannot be found.\n                // Needed for ClassPathURLStreamHandler handling of URLs without trailing slashes.\n                // This was added as part of the work to move StrictJarFile from libcore to\n                // framework, see http://b/111293098 for more details.\n                // It should be possible to revert this after upgrading to OpenJDK 8u144 or above.\n                // jzentry = getEntry(jzfile, zc.getBytesUTF8(entry.name), false);\n                jzentry = getEntry(jzfile, zc.getBytesUTF8(entry.name), true);\n            } else {\n                // Android-changed: Find entry by name, falling back to name/ if cannot be found.\n                // jzentry = getEntry(jzfile, zc.getBytes(entry.name), false);\n                jzentry = getEntry(jzfile, zc.getBytes(entry.name), true);\n            }\n            if (jzentry == 0) {\n                return null;\n            }\n            in = new ZipFileInputStream(jzentry);\n\n            switch (getEntryMethod(jzentry)) {\n            case STORED:\n                synchronized (streams) {\n                    streams.put(in, null);\n                }\n                return in;\n            case DEFLATED:\n                // MORE: Compute good size for inflater stream:\n                long size = getEntrySize(jzentry) + 2; // Inflater likes a bit of slack\n                // Android-changed: Use 64k buffer size, performs better than 8k.\n                // See http://b/65491407.\n                // if (size > 65536) size = 8192;\n                if (size > 65536) size = 65536;\n                if (size <= 0) size = 4096;\n                Inflater inf = getInflater();\n                InputStream is =\n                    new ZipFileInflaterInputStream(in, inf, (int)size);\n                synchronized (streams) {\n                    streams.put(is, inf);\n                }\n                return is;\n            default:\n                throw new ZipException(\"invalid compression method\");\n            }\n        }\n    }\n\n    private class ZipFileInflaterInputStream extends InflaterInputStream {\n        private volatile boolean closeRequested = false;\n        private boolean eof = false;\n        private final ZipFileInputStream zfin;\n\n        ZipFileInflaterInputStream(ZipFileInputStream zfin, Inflater inf,\n                int size) {\n            super(zfin, inf, size);\n            this.zfin = zfin;\n        }\n\n        public void close() throws IOException {\n            if (closeRequested)\n                return;\n            closeRequested = true;\n\n            super.close();\n            Inflater inf;\n            synchronized (streams) {\n                inf = streams.remove(this);\n            }\n            if (inf != null) {\n                releaseInflater(inf);\n            }\n        }\n\n        // Override fill() method to provide an extra \"dummy\" byte\n        // at the end of the input stream. This is required when\n        // using the \"nowrap\" Inflater option.\n        protected void fill() throws IOException {\n            if (eof) {\n                throw new EOFException(\"Unexpected end of ZLIB input stream\");\n            }\n            len = in.read(buf, 0, buf.length);\n            if (len == -1) {\n                buf[0] = 0;\n                len = 1;\n                eof = true;\n            }\n            inf.setInput(buf, 0, len);\n        }\n\n        public int available() throws IOException {\n            if (closeRequested)\n                return 0;\n            long avail = zfin.size() - inf.getBytesWritten();\n            return (avail > (long) Integer.MAX_VALUE ?\n                    Integer.MAX_VALUE : (int) avail);\n        }\n\n        protected void finalize() throws Throwable {\n            close();\n        }\n    }\n\n    /*\n     * Gets an inflater from the list of available inflaters or allocates\n     * a new one.\n     */\n    private Inflater getInflater() {\n        Inflater inf;\n        synchronized (inflaterCache) {\n            while (null != (inf = inflaterCache.poll())) {\n                if (false == inf.ended()) {\n                    return inf;\n                }\n            }\n        }\n        return new Inflater(true);\n    }\n\n    /*\n     * Releases the specified inflater to the list of available inflaters.\n     */\n    private void releaseInflater(Inflater inf) {\n        if (false == inf.ended()) {\n            inf.reset();\n            synchronized (inflaterCache) {\n                inflaterCache.add(inf);\n            }\n        }\n    }\n\n    // List of available Inflater objects for decompression\n    private Deque<Inflater> inflaterCache = new ArrayDeque<>();\n\n    /**\n     * Returns the path name of the ZIP file.\n     * @return the path name of the ZIP file\n     */\n    public String getName() {\n        return name;\n    }\n\n    private class ZipEntryIterator implements Enumeration<ZipEntry>, Iterator<ZipEntry> {\n        private int i = 0;\n\n        public ZipEntryIterator() {\n            ensureOpen();\n        }\n\n        public boolean hasMoreElements() {\n            return hasNext();\n        }\n\n        public boolean hasNext() {\n            synchronized (ZipFile.this) {\n                ensureOpen();\n                return i < total;\n            }\n        }\n\n        public ZipEntry nextElement() {\n            return next();\n        }\n\n        public ZipEntry next() {\n            synchronized (ZipFile.this) {\n                ensureOpen();\n                if (i >= total) {\n                    throw new NoSuchElementException();\n                }\n                long jzentry = getNextEntry(jzfile, i++);\n                if (jzentry == 0) {\n                    String message;\n                    if (closeRequested) {\n                        message = \"ZipFile concurrently closed\";\n                    } else {\n                        message = getZipMessage(ZipFile.this.jzfile);\n                    }\n                    throw new ZipError(\"jzentry == 0\" +\n                                       \",\\n jzfile = \" + ZipFile.this.jzfile +\n                                       \",\\n total = \" + ZipFile.this.total +\n                                       \",\\n name = \" + ZipFile.this.name +\n                                       \",\\n i = \" + i +\n                                       \",\\n message = \" + message\n                        );\n                }\n                ZipEntry ze = getZipEntry(null, jzentry);\n                freeEntry(jzfile, jzentry);\n                return ze;\n            }\n        }\n    }\n\n    /**\n     * Returns an enumeration of the ZIP file entries.\n     * @return an enumeration of the ZIP file entries\n     * @throws IllegalStateException if the zip file has been closed\n     */\n    public Enumeration<? extends ZipEntry> entries() {\n        return new ZipEntryIterator();\n    }\n\n    /**\n     * Return an ordered {@code Stream} over the ZIP file entries.\n     * Entries appear in the {@code Stream} in the order they appear in\n     * the central directory of the ZIP file.\n     *\n     * @return an ordered {@code Stream} of entries in this ZIP file\n     * @throws IllegalStateException if the zip file has been closed\n     * @since 1.8\n     */\n    public Stream<? extends ZipEntry> stream() {\n        return StreamSupport.stream(Spliterators.spliterator(\n                new ZipEntryIterator(), size(),\n                Spliterator.ORDERED | Spliterator.DISTINCT |\n                        Spliterator.IMMUTABLE | Spliterator.NONNULL), false);\n    }\n\n    // Android-added: Hook to validate zip entry name by ZipPathValidator.\n    private void onZipEntryAccess(byte[] bname, int flag) throws ZipException {\n        String name;\n        if (!zc.isUTF8() && (flag & USE_UTF8) != 0) {\n            name = zc.toStringUTF8(bname, bname.length);\n        } else {\n            name = zc.toString(bname, bname.length);\n        }\n        ZipPathValidator.getInstance().onZipEntryAccess(name);\n    }\n\n    private ZipEntry getZipEntry(String name, long jzentry) {\n        ZipEntry e = new ZipEntry();\n        e.flag = getEntryFlag(jzentry);  // get the flag first\n        if (name != null) {\n            e.name = name;\n        } else {\n            byte[] bname = getEntryBytes(jzentry, JZENTRY_NAME);\n            if (!zc.isUTF8() && (e.flag & USE_UTF8) != 0) {\n                e.name = zc.toStringUTF8(bname, bname.length);\n            } else {\n                e.name = zc.toString(bname, bname.length);\n            }\n        }\n        e.xdostime = getEntryTime(jzentry);\n        e.crc = getEntryCrc(jzentry);\n        e.size = getEntrySize(jzentry);\n        e.csize = getEntryCSize(jzentry);\n        e.method = getEntryMethod(jzentry);\n        e.setExtra0(getEntryBytes(jzentry, JZENTRY_EXTRA), false);\n        byte[] bcomm = getEntryBytes(jzentry, JZENTRY_COMMENT);\n        if (bcomm == null) {\n            e.comment = null;\n        } else {\n            if (!zc.isUTF8() && (e.flag & USE_UTF8) != 0) {\n                e.comment = zc.toStringUTF8(bcomm, bcomm.length);\n            } else {\n                e.comment = zc.toString(bcomm, bcomm.length);\n            }\n        }\n        return e;\n    }\n\n    private static native long getNextEntry(long jzfile, int i);\n\n    /**\n     * Returns the number of entries in the ZIP file.\n     * @return the number of entries in the ZIP file\n     * @throws IllegalStateException if the zip file has been closed\n     */\n    public int size() {\n        ensureOpen();\n        return total;\n    }\n\n    /**\n     * Closes the ZIP file.\n     * <p> Closing this ZIP file will close all of the input streams\n     * previously returned by invocations of the {@link #getInputStream\n     * getInputStream} method.\n     *\n     * @throws IOException if an I/O error has occurred\n     */\n    public void close() throws IOException {\n        if (closeRequested)\n            return;\n        // Android-added: CloseGuard support.\n        if (guard != null) {\n            guard.close();\n        }\n        closeRequested = true;\n\n        synchronized (this) {\n            // Close streams, release their inflaters\n            // BEGIN Android-added: null field check to avoid NullPointerException during finalize.\n            // If the constructor threw an exception then the streams / inflaterCache fields can\n            // be null and close() can be called by the finalizer.\n            if (streams != null) {\n            // END Android-added: null field check to avoid NullPointerException during finalize.\n                synchronized (streams) {\n                    if (false == streams.isEmpty()) {\n                        Map<InputStream, Inflater> copy = new HashMap<>(streams);\n                        streams.clear();\n                        for (Map.Entry<InputStream, Inflater> e : copy.entrySet()) {\n                            e.getKey().close();\n                            Inflater inf = e.getValue();\n                            if (inf != null) {\n                                inf.end();\n                            }\n                        }\n                    }\n                }\n            // BEGIN Android-added: null field check to avoid NullPointerException during finalize.\n            }\n\n            if (inflaterCache != null) {\n            // END Android-added: null field check to avoid NullPointerException during finalize.\n                // Release cached inflaters\n                Inflater inf;\n                synchronized (inflaterCache) {\n                    while (null != (inf = inflaterCache.poll())) {\n                        inf.end();\n                    }\n                }\n            // BEGIN Android-added: null field check to avoid NullPointerException during finalize.\n            }\n            // END Android-added: null field check to avoid NullPointerException during finalize.\n\n            if (jzfile != 0) {\n                // Close the zip file\n                long zf = this.jzfile;\n                jzfile = 0;\n\n                close(zf);\n            }\n            // Android-added: Do not use unlink() to implement OPEN_DELETE.\n            if (fileToRemoveOnClose != null) {\n                fileToRemoveOnClose.delete();\n            }\n        }\n    }\n\n    /**\n     * Ensures that the system resources held by this ZipFile object are\n     * released when there are no more references to it.\n     *\n     * <p>\n     * Since the time when GC would invoke this method is undetermined,\n     * it is strongly recommended that applications invoke the <code>close</code>\n     * method as soon they have finished accessing this <code>ZipFile</code>.\n     * This will prevent holding up system resources for an undetermined\n     * length of time.\n     *\n     * @throws IOException if an I/O error has occurred\n     * @see    java.util.zip.ZipFile#close()\n     */\n    protected void finalize() throws IOException {\n        // Android-added: CloseGuard support.\n        if (guard != null) {\n            guard.warnIfOpen();\n        }\n        close();\n    }\n\n    private static native void close(long jzfile);\n\n    private void ensureOpen() {\n        if (closeRequested) {\n            throw new IllegalStateException(\"zip file closed\");\n        }\n\n        if (jzfile == 0) {\n            throw new IllegalStateException(\"The object is not initialized.\");\n        }\n    }\n\n    private void ensureOpenOrZipException() throws IOException {\n        if (closeRequested) {\n            throw new ZipException(\"ZipFile closed\");\n        }\n    }\n\n    /*\n     * Inner class implementing the input stream used to read a\n     * (possibly compressed) zip file entry.\n     */\n   private class ZipFileInputStream extends InputStream {\n        private volatile boolean zfisCloseRequested = false;\n        protected long jzentry; // address of jzentry data\n        private   long pos;     // current position within entry data\n        protected long rem;     // number of remaining bytes within entry\n        protected long size;    // uncompressed size of this entry\n\n        ZipFileInputStream(long jzentry) {\n            pos = 0;\n            rem = getEntryCSize(jzentry);\n            size = getEntrySize(jzentry);\n            this.jzentry = jzentry;\n        }\n\n        public int read(byte b[], int off, int len) throws IOException {\n            // Android-added: Always throw an exception when reading from closed zipfile.\n            // Required by the JavaDoc for InputStream.read(byte[], int, int). Upstream version\n            // 8u121-b13 is not compliant but that bug has been fixed in upstream version 9+181\n            // as part of a major change to switch to a pure Java implementation.\n            // See https://bugs.openjdk.java.net/browse/JDK-8145260 and\n            // https://bugs.openjdk.java.net/browse/JDK-8142508.\n            ensureOpenOrZipException();\n\n            synchronized (ZipFile.this) {\n                long rem = this.rem;\n                long pos = this.pos;\n                if (rem == 0) {\n                    return -1;\n                }\n                if (len <= 0) {\n                    return 0;\n                }\n                if (len > rem) {\n                    len = (int) rem;\n                }\n\n                // Android-removed: Always throw an exception when reading from closed zipfile.\n                // Moved to the start of the method.\n                //ensureOpenOrZipException();\n                len = ZipFile.read(ZipFile.this.jzfile, jzentry, pos, b,\n                                   off, len);\n                if (len > 0) {\n                    this.pos = (pos + len);\n                    this.rem = (rem - len);\n                }\n            }\n            if (rem == 0) {\n                close();\n            }\n            return len;\n        }\n\n        public int read() throws IOException {\n            byte[] b = new byte[1];\n            if (read(b, 0, 1) == 1) {\n                return b[0] & 0xff;\n            } else {\n                return -1;\n            }\n        }\n\n        public long skip(long n) {\n            if (n > rem)\n                n = rem;\n            pos += n;\n            rem -= n;\n            if (rem == 0) {\n                close();\n            }\n            return n;\n        }\n\n        public int available() {\n            return rem > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) rem;\n        }\n\n        public long size() {\n            return size;\n        }\n\n        public void close() {\n            if (zfisCloseRequested)\n                return;\n            zfisCloseRequested = true;\n\n            rem = 0;\n            synchronized (ZipFile.this) {\n                if (jzentry != 0 && ZipFile.this.jzfile != 0) {\n                    freeEntry(ZipFile.this.jzfile, jzentry);\n                    jzentry = 0;\n                }\n            }\n            synchronized (streams) {\n                streams.remove(this);\n            }\n        }\n\n        protected void finalize() {\n            close();\n        }\n    }\n\n    // Android-removed: Access startsWithLocHeader() directly.\n    /*\n    static {\n        sun.misc.SharedSecrets.setJavaUtilZipFileAccess(\n            new sun.misc.JavaUtilZipFileAccess() {\n                public boolean startsWithLocHeader(ZipFile zip) {\n                    return zip.startsWithLocHeader();\n                }\n             }\n        );\n    }\n    */\n\n    /**\n     * Returns {@code true} if, and only if, the zip file begins with {@code\n     * LOCSIG}.\n     * @hide\n     */\n    // Android-changed: Access startsWithLocHeader() directly.\n    // Make hidden public for use by sun.misc.URLClassPath\n    // private boolean startsWithLocHeader() {\n    public boolean startsWithLocHeader() {\n        return locsig;\n    }\n\n    // BEGIN Android-added: Provide access to underlying file descriptor for testing.\n    // See http://b/111148957 for background information.\n    /** @hide */\n    // @VisibleForTesting\n    public int getFileDescriptor() {\n        return getFileDescriptor(jzfile);\n    }\n\n    private static native int getFileDescriptor(long jzfile);\n    // END Android-added: Provide access to underlying file descriptor for testing.\n\n    // Android-changed: Make it as a non-static method, so it can access charset config.\n    private native long open(String name, int mode, long lastModified,\n                                    boolean usemmap) throws IOException;\n    private static native int getTotal(long jzfile);\n    private static native boolean startsWithLOC(long jzfile);\n    private static native int read(long jzfile, long jzentry,\n                                   long pos, byte[] b, int off, int len);\n\n    // access to the native zentry object\n    private static native long getEntryTime(long jzentry);\n    private static native long getEntryCrc(long jzentry);\n    private static native long getEntryCSize(long jzentry);\n    private static native long getEntrySize(long jzentry);\n    private static native int getEntryMethod(long jzentry);\n    private static native int getEntryFlag(long jzentry);\n    private static native byte[] getCommentBytes(long jzfile);\n\n    private static final int JZENTRY_NAME = 0;\n    private static final int JZENTRY_EXTRA = 1;\n    private static final int JZENTRY_COMMENT = 2;\n    private static native byte[] getEntryBytes(long jzentry, int type);\n\n    private static native String getZipMessage(long jzfile);\n}\n```",
            "downstream_file_tokens": {
              "openai": 8093,
              "general": {
                "word_based": 4072,
                "char_based": 9235
              },
              "gemini": 9200
            },
            "downstream_file_content_context_3": [
              ""
            ],
            "downstream_file_content_context_5": [
              ""
            ],
            "downstream_file_content_context_10": [
              ""
            ],
            "downstream_file_content_context_20": [
              ""
            ],
            "llm_patch_context_3": "@@ -1436,7 +1436,18 @@\n                 initCEN(-1);\n                 byte[] buf = new byte[4];\n                 readFullyAt(buf, 0, 4, 0);\n-                this.startsWithLoc = (LOCSIG(buf) == LOCSIG);\n+                // BEGIN Android-changed: do not accept files with invalid header\n+                // this.startsWithLoc = (LOCSIG(buf) == LOCSIG);\n+                long locsig = LOCSIG(buf);\n+                this.startsWithLoc = (locsig == LOCSIG);\n+                // If a zip file starts with \"end of central directory record\" it means that such\n+                // file is empty.\n+                if (locsig != LOCSIG && locsig != ENDSIG) {\n+                    String msg = \"Entry at offset zero has invalid LFH signature \"\n+                                    + Long.toHexString(locsig);\n+                    throw new ZipException(msg);\n+                }\n+                // END Android-changed: do not accept files with invalid header\n             } catch (IOException x) {\n                 try {\n                     this.zfile.close();\n",
            "llm_patch_context_3_duration_seconds": 130.35,
            "llm_patch_context_5": "@@ -1436,7 +1436,18 @@\n                 initCEN(-1);\n                 byte[] buf = new byte[4];\n                 readFullyAt(buf, 0, 4, 0);\n-                this.startsWithLoc = (LOCSIG(buf) == LOCSIG);\n+                // BEGIN Android-changed: do not accept files with invalid header\n+                // this.startsWithLoc = (LOCSIG(buf) == LOCSIG);\n+                long locsig = LOCSIG(buf);\n+                this.startsWithLoc = (locsig == LOCSIG);\n+                // If a zip file starts with \"end of central directory record\" it means that such\n+                // file is empty.\n+                if (locsig != LOCSIG && locsig != ENDSIG) {\n+                    String msg = \"Entry at offset zero has invalid LFH signature \"\n+                                    + Long.toHexString(locsig);\n+                    throw new ZipException(msg);\n+                }\n+                // END Android-changed: do not accept files with invalid header\n             } catch (IOException x) {\n                 try {\n                     this.zfile.close();\n",
            "llm_patch_context_5_duration_seconds": 72.81,
            "llm_patch_context_10": "@@ -1436,7 +1436,18 @@\n                 initCEN(-1);\n                 byte[] buf = new byte[4];\n                 readFullyAt(buf, 0, 4, 0);\n-                this.startsWithLoc = (LOCSIG(buf) == LOCSIG);\n+                // BEGIN Android-changed: do not accept files with invalid header\n+                // this.startsWithLoc = (LOCSIG(buf) == LOCSIG);\n+                long locsig = LOCSIG(buf);\n+                this.startsWithLoc = (locsig == LOCSIG);\n+                // If a zip file starts with \"end of central directory record\" it means that such\n+                // file is empty.\n+                if (locsig != LOCSIG && locsig != ENDSIG) {\n+                    String msg = \"Entry at offset zero has invalid LFH signature \"\n+                                    + Long.toHexString(locsig);\n+                    throw new ZipException(msg);\n+                }\n+                // END Android-changed: do not accept files with invalid header\n             } catch (IOException x) {\n                 try {\n                     this.zfile.close();\n",
            "llm_patch_context_10_duration_seconds": 54.95,
            "llm_patch_context_20": "@@ -1436,7 +1436,18 @@\n                 initCEN(-1);\n                 byte[] buf = new byte[4];\n                 readFullyAt(buf, 0, 4, 0);\n-                this.startsWithLoc = (LOCSIG(buf) == LOCSIG);\n+                // BEGIN Android-changed: do not accept files with invalid header\n+                // this.startsWithLoc = (LOCSIG(buf) == LOCSIG);\n+                long locsig = LOCSIG(buf);\n+                this.startsWithLoc = (locsig == LOCSIG);\n+                // If a zip file starts with \"end of central directory record\" it means that such\n+                // file is empty.\n+                if (locsig != LOCSIG && locsig != ENDSIG) {\n+                    String msg = \"Entry at offset zero has invalid LFH signature \"\n+                                    + Long.toHexString(locsig);\n+                    throw new ZipException(msg);\n+                }\n+                // END Android-changed: do not accept files with invalid header\n             } catch (IOException x) {\n                 try {\n                     this.zfile.close();\n",
            "llm_patch_context_20_duration_seconds": 86.37
          }
        ]
      }
    ]
  },
  {
    "id": "ASB-A-353712853",
    "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-353712853",
    "severity": "High",
    "failures": [
      {
        "downstream_version": "14",
        "gemini_token_usage": 50755,
        "branch_used": "android14-release",
        "downstream_patch": "37be5d18e529877fcd3c62063aec205a96660449",
        "repo_path": "android_repos/base",
        "result": "failure",
        "downstream_patch_content": "commit 37be5d18e529877fcd3c62063aec205a96660449\nAuthor: Ashish Kumar Gupta <kumarashishg@google.com>\nDate:   Wed Jul 31 16:02:29 2024 +0000\n\n    Set no data transfer on function switch timeout for accessory mode\n    \n    In case of function switch times out, we will check whether\n    the last function set was accessory. If this is the case, it is\n    recommended to set the function to NONE(No data transfer) rather than\n    setting it to the default USB function.\n    \n    Bug: 353712853\n    Test: Build the code, flash the device and test it.\n    Test: atest CtsUsbManagerTestCases\n    Test: run CtsVerifier tool\n    Test: atest CtsUsbTests\n    Change-Id: I698e9df0333cbb51dd9bd5917a94d81273a2784a\n    Merged-In: I698e9df0333cbb51dd9bd5917a94d81273a2784a\n    (cherry picked from commit 7c6ec68537ba8abf798afd9ab7c3e5889841171f)\n\ndiff --git a/services/usb/java/com/android/server/usb/UsbDeviceManager.java b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\nindex 77b263824b78..3d012f6eacc0 100644\n--- a/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -819,7 +819,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit(int operationId) {\n+        protected void notifyAccessoryModeExit(int operationId) {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -2145,8 +2145,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      */\n                     operationId = sUsbOperationCount.incrementAndGet();\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit(operationId);\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:\n",
        "downstream_patch_tokens": {
          "openai": 621,
          "general": {
            "word_based": 245,
            "char_based": 634
          },
          "gemini": 758
        },
        "file_conflicts": [
          {
            "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
            "total_hunks": 3,
            "failed_hunks": [
              1
            ],
            "inline_merge_conflicts": [],
            "inline_merge_token_summary": {
              "gemini": 0,
              "openai": 0,
              "general_word": 0,
              "general_char": 0
            },
            "rej_file_content": "```diff\n--- services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -80,9 +80,9 @@ import android.os.storage.StorageVolume;\n import android.provider.Settings;\n import android.service.usb.UsbDeviceManagerProto;\n import android.service.usb.UsbHandlerProto;\n+import android.text.TextUtils;\n import android.util.Pair;\n import android.util.Slog;\n-import android.text.TextUtils;\n \n import com.android.internal.R;\n import com.android.internal.annotations.GuardedBy;\n```",
            "rej_file_tokens": {
              "openai": 118,
              "general": {
                "word_based": 68,
                "char_based": 132
              },
              "gemini": 159
            },
            "patch_apply_output": "patching file services/usb/java/com/android/server/usb/UsbDeviceManager.java\nHunk #1 FAILED at 80.\nHunk #2 succeeded at 819 (offset -61 lines).\nHunk #3 succeeded at 2145 (offset -168 lines).\n1 out of 3 hunks FAILED -- saving rejects to file services/usb/java/com/android/server/usb/UsbDeviceManager.java.rej",
            "inline_merge_output": "patching file services/usb/java/com/android/server/usb/UsbDeviceManager.java\nHunk #1 already applied at 83,86.\nHunk #2 already applied at 883.\nHunk #3 merged at 2291-2297.",
            "upstream_file_content": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport com.android.internal.annotations.Keep;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.text.TextUtils;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.usb.flags.Flags;\nimport com.android.server.usb.hal.gadget.UsbGadgetHal;\nimport com.android.server.usb.hal.gadget.UsbGadgetHalInstance;\nimport com.android.server.utils.EventLogger;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    /**\n     *  UDC controller for the ConfigFS USB Gadgets.\n     */\n    private static final String USB_CONTROLLER_NAME_PROPERTY = \"sys.usb.controller\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String UDC_SUBSYS_MATCH =\n            \"SUBSYSTEM=udc\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final int DUMPSYS_LOG_BUFFER = 200;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    private static EventLogger sEventLogger;\n\n    private static UsbGadgetHal mUsbGadgetHal;\n\n    private final boolean mEnableUdcSysfsUsbStateUpdate;\n    private String mUdcName = \"\";\n\n    /**\n     * Counter for tracking UsbOperation operations.\n     */\n    private static final AtomicInteger sUsbOperationCount = new AtomicInteger();\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n            if (sEventLogger != null) {\n                sEventLogger.enqueue(new EventLogger.StringEvent(\"USB UEVENT: \"\n                        + event.toString()));\n            } else {\n                if (DEBUG) Slog.d(TAG, \"sEventLogger == null\");\n            }\n\n            String accessory = event.get(\"ACCESSORY\");\n\n            if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                mHandler.setAccessoryUEventTime(SystemClock.elapsedRealtime());\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n\n            if (mEnableUdcSysfsUsbStateUpdate) {\n                if (!mUdcName.isEmpty()\n                        && \"udc\".equals(event.get(\"SUBSYSTEM\"))\n                        && event.get(\"DEVPATH\").contains(mUdcName)) {\n                    String action = event.get(\"ACTION\");\n                    if (\"add\".equals(action)) {\n                        nativeStartGadgetMonitor(mUdcName);\n                    } else if (\"remove\".equals(action)) {\n                        nativeStopGadgetMonitor();\n                    }\n                }\n            } else {\n                String state = event.get(\"USB_STATE\");\n                if (state != null) {\n                    mHandler.updateState(state);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n        boolean halNotPresent = false;\n\n        mUsbGadgetHal = UsbGadgetHalInstance.getInstance(this, null);\n        Slog.d(TAG, \"getInstance done\");\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (mUsbGadgetHal == null) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        mHandler.handlerInitDone(operationId);\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT, android.hardware.usb.ParcelableUsbPort.class);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS, android.hardware.usb.UsbPortStatus.class);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n\n        mEnableUdcSysfsUsbStateUpdate =\n                android.hardware.usb.flags.Flags.enableUdcSysfsUsbStateUpdate()\n                && context.getResources().getBoolean(R.bool.config_enableUdcSysfsUsbStateUpdate);\n\n        if (mEnableUdcSysfsUsbStateUpdate) {\n            mUEventObserver.startObserving(UDC_SUBSYS_MATCH);\n            new Thread(\"GetUsbControllerSysprop\") {\n                public void run() {\n                    String udcName;\n                    // blocking wait until usb controller sysprop is available\n                    udcName = nativeWaitAndGetProperty(USB_CONTROLLER_NAME_PROPERTY);\n                    nativeStartGadgetMonitor(udcName);\n                    mUdcName = udcName;\n                    Slog.v(TAG, \"USB controller name \" + udcName);\n                }\n            }.start();\n        } else {\n            mUEventObserver.startObserving(USB_STATE_MATCH);\n        }\n\n        sEventLogger = new EventLogger(DUMPSYS_LOG_BUFFER, \"UsbDeviceManager activity\");\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions, operationId);\n        }\n    }\n\n    //TODO It is not clear that this method serves any purpose (at least on Pixel devices)\n    // consider removing\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.i(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    public static void logAndPrint(int priority, IndentingPrintWriter pw, String msg) {\n        Slog.println(priority, TAG, msg);\n        if (pw != null) {\n            pw.println(msg);\n        }\n    }\n\n    public static void logAndPrintException(IndentingPrintWriter pw, String msg, Exception e) {\n        Slog.e(TAG, msg, e);\n        if (pw != null) {\n            pw.println(msg + e);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mUsbAccessoryConnected;\n        private boolean mInHostModeWithNoAccessoryConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n        private boolean mConnectedToDataDisabledPort;\n        private int mPowerBrickConnectionStatus;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        /**\n         * Do not debounce for the first disconnect after resetUsbGadget.\n         */\n        protected boolean mResetUsbGadgetDisableDebounce;\n        protected boolean mConnected;\n        protected boolean mConfigured;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n        protected boolean mPendingBootAccessoryHandshakeBroadcast;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        protected static final String MTP_PACKAGE_NAME = \"com.android.mtp\";\n        protected static final String MTP_SERVICE_CLASS_NAME = \"com.android.mtp.MtpService\";\n\n        private boolean mIsMtpServiceBound = false;\n\n        /**\n         * {@link ServiceConnection} for {@link MtpService}.\n         */\n        private ServiceConnection mMtpServiceConnection = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName className, IBinder service) {}\n\n            @Override\n            public void onServiceDisconnected(ComponentName arg0) {}\n        };\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public boolean sendMessage(int what) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            return sendMessageDelayed(m,0);\n        }\n\n        public void sendMessage(int what, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, long arg, boolean arg1, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            if (DEBUG) {\n                Slog.i(TAG, \"mResetUsbGadgetDisableDebounce:\" + mResetUsbGadgetDisableDebounce\n                       + \" connected:\" + connected + \"configured:\" + configured);\n            }\n            if (mResetUsbGadgetDisableDebounce) {\n                // Do not debounce disconnect after resetUsbGadget.\n                sendMessage(msg);\n                if (connected == 1) mResetUsbGadgetDisableDebounce = false;\n            } else {\n                if (configured == 0) {\n                    removeMessages(MSG_UPDATE_STATE);\n                    if (DEBUG) Slog.i(TAG, \"removeMessages MSG_UPDATE_STATE\");\n                }\n                if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n                // debounce disconnects to avoid problems bringing up USB tethering.\n                sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n            }\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable, int operationId) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true, operationId);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            int operationId = sUsbOperationCount.incrementAndGet();\n\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit(operationId);\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        protected void notifyAccessoryModeExit(int operationId) {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                        | Intent.FLAG_RECEIVER_FOREGROUND)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            SystemClock.elapsedRealtime());\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n            sEventLogger.enqueue(new EventLogger.StringEvent(\"USB intent: \" + intent));\n        }\n\n        private void getMidiCardDevice() throws FileNotFoundException {\n            String controllerName =  getSystemProperty(USB_CONTROLLER_NAME_PROPERTY, \"\");\n            if (TextUtils.isEmpty(controllerName)) {\n                throw new FileNotFoundException(\"controller name not found\");\n            }\n\n            File soundDir = new File(\"/sys/class/udc/\" + controllerName + \"/gadget/sound\");\n            if (!soundDir.exists()) {\n                throw new FileNotFoundException(\"sound device not found\");\n            }\n\n            // There should be exactly one sound card\n            File[] cardDirs = FileUtils.listFilesOrEmpty(soundDir,\n                                                         (dir, file) -> file.startsWith(\"card\"));\n            if (cardDirs.length != 1) {\n                throw new FileNotFoundException(\"sound card not match\");\n            }\n\n            // There should be exactly one midi device\n            File[] midis = FileUtils.listFilesOrEmpty(cardDirs[0],\n                                                      (dir, file) -> file.startsWith(\"midi\"));\n            if (midis.length != 1) {\n                throw new FileNotFoundException(\"MIDI device not match\");\n            }\n\n            Pattern pattern = Pattern.compile(\"midiC(\\\\d+)D(\\\\d+)\");\n            Matcher matcher = pattern.matcher(midis[0].getName());\n            if (matcher.matches()) {\n                mMidiCard = Integer.parseInt(matcher.group(1));\n                mMidiDevice = Integer.parseInt(matcher.group(2));\n                Slog.i(TAG, \"Found MIDI card \" + mMidiCard + \" device \" + mMidiDevice);\n            } else {\n                throw new FileNotFoundException(\"MIDI name not match\");\n            }\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n            updateMtpFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    if (android.hardware.usb.flags.Flags.enableUsbSysfsMidiIdentification()) {\n                        try {\n                            getMidiCardDevice();\n                        } catch (FileNotFoundException e) {\n                            Slog.e(TAG, \"could not identify MIDI device\", e);\n                            enabled = false;\n                        }\n                    } else {\n                        Scanner scanner = null;\n                        try {\n                            scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                            mMidiCard = scanner.nextInt();\n                            mMidiDevice = scanner.nextInt();\n                        } catch (FileNotFoundException e) {\n                            Slog.e(TAG, \"could not open MIDI file\", e);\n                            enabled = false;\n                        } finally {\n                            if (scanner != null) {\n                                scanner.close();\n                            }\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        /**\n         * Bind to MtpService when MTP or PTP is enabled. This is done to prevent activity manager\n         * from freezing the corresponding process.\n         */\n        private void updateMtpFunction() {\n            if (!Flags.enableBindToMtpService()) {\n                return;\n            }\n\n            boolean mtpEnabled = ((mCurrentFunctions & UsbManager.FUNCTION_MTP) != 0);\n            boolean ptpEnabled = ((mCurrentFunctions & UsbManager.FUNCTION_PTP) != 0);\n\n            if (DEBUG) {\n                Slog.d(TAG, \"updateMtpFunction \"\n                        + \", mtpEnabled: \" + mtpEnabled\n                        + \", ptpEnabled: \" + ptpEnabled\n                        + \", mIsMtpServiceBound: \" + mIsMtpServiceBound\n                );\n            }\n\n            if (mConfigured && (mtpEnabled || ptpEnabled)) {\n                bindToMtpService();\n            } else if (mIsMtpServiceBound) {\n                unbindMtpService();\n            }\n        }\n\n        private void bindToMtpService() {\n            Intent intent = new Intent();\n            intent.setComponent(new ComponentName(MTP_PACKAGE_NAME, MTP_SERVICE_CLASS_NAME));\n\n            if (DEBUG) Slog.d(TAG, \"Binding to MtpService\");\n\n            try {\n                mIsMtpServiceBound = mContext.bindServiceAsUser(\n                    intent,\n                    mMtpServiceConnection,\n                    Context.BIND_AUTO_CREATE,\n                    UserHandle.CURRENT\n                );\n            } catch (SecurityException exception) {\n                Slog.e(TAG, \"Unable to bind to MtpService due to SecurityException\", exception);\n            }\n\n            // Unbinding from the service if binding was not successful to release the connection.\n            // https://developer.android.com/reference/android/content/Context#bindService(android.content.Intent,%20android.content.ServiceConnection,%20int)\n            if (!mIsMtpServiceBound) {\n                unbindMtpService();\n                Slog.e(TAG, \"Binding to MtpService failed\");\n            }\n\n            if (DEBUG && mIsMtpServiceBound) Slog.d(TAG, \"Successfully bound to MtpService\");\n        }\n\n        private void unbindMtpService() {\n            if (DEBUG) Slog.d(TAG, \"Unbinding from MtpService\");\n\n            mContext.unbindService(mMtpServiceConnection);\n            mIsMtpServiceBound = false;\n        }\n\n        private void setScreenUnlockedFunctions(int operationId) {\n            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"handleMessage MSG_UPDATE_STATE \" + \"mConnected:\" + mConnected\n                               + \" mConfigured:\" + mConfigured);\n                    }\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions(operationId);\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n\n                        boolean usbDataDisabled =\n                                status.getUsbDataStatus() != UsbPortStatus.DATA_STATUS_ENABLED;\n                        mConnectedToDataDisabledPort = status.isConnected() && usbDataDisabled;\n                        mPowerBrickConnectionStatus = status.getPowerBrickConnectionStatus();\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                        mConnectedToDataDisabledPort = false;\n                        mPowerBrickConnectionStatus = UsbPortStatus.POWER_BRICK_STATUS_UNKNOWN;\n                    }\n\n                    if (mHostConnected) {\n                        if (!mUsbAccessoryConnected) {\n                            mInHostModeWithNoAccessoryConnected = true;\n                        } else {\n                            mInHostModeWithNoAccessoryConnected = false;\n                        }\n                    } else {\n                        // if not in host mode, reset value to false\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    mUsbAccessoryConnected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + mUsbAccessoryConnected);\n                    }\n\n                    if (!devices.hasNext()) {\n                        mInHostModeWithNoAccessoryConnected = true;\n                    } else {\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1, msg.arg2);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    operationId = (int) msg.arg1;\n                    setEnabledFunctions(functions, false, operationId);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions(operationId);\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions(operationId);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true, operationId);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mBootCompleted = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_USER_SWITCHED: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected\n                                    + \" ,operationId: \" + operationId);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit(operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    if (mBootCompleted) {\n                        broadcastUsbAccessoryHandshake();\n                    } else {\n                        if (DEBUG) Slog.v(TAG, \"Pending broadcasting intent as \"\n                                + \"not boot completed yet.\");\n                        mPendingBootAccessoryHandshakeBroadcast = true;\n                    }\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        public abstract void handlerInitDone(int operationId);\n\n        protected void finishBoot(int operationId) {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions(operationId);\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                } else if (mPendingBootAccessoryHandshakeBroadcast) {\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                mPendingBootAccessoryHandshakeBroadcast = false;\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if ((mHideUsbNotification || mInHostModeWithNoAccessoryConnected)\n                    && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_UVC) {\n                    titleRes = com.android.internal.R.string.usb_uvc_notification_title;\n                    id = SystemMessage.NOTE_USB_UVC;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && (mUsbCharging || mUsbAccessoryConnected)) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            } else if (mSinkPower && mConnectedToDataDisabledPort\n                    && mPowerBrickConnectionStatus != UsbPortStatus.POWER_BRICK_STATUS_CONNECTED) {\n                // Show charging notification when USB Data is disabled on the port, and not\n                // connected to a wall charger.\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions,\n                boolean forceRestart, int operationId);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n\n        public abstract void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions);\n\n        public abstract void getUsbSpeedCb(int speed);\n\n        public abstract void resetCb(int status);\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions,\n                boolean forceRestart, int operationId) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions +\n                        \" ,forceRestart=\" + forceRestart +\n                        \" ,usbDataUnlocked=\" + usbDataUnlocked +\n                        \" ,operationId=\" + operationId);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void getUsbSpeedCb(int speed){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void resetCb(int status){\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            int operationId = sUsbOperationCount.incrementAndGet();\n            try {\n\n                synchronized (mGadgetProxyLock) {\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    updateUsbGadgetHalVersion();\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mUsbGadgetHal = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\"\n                                + \" ,operationId:\" + operationId);\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.i(TAG, \"processing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n                    operationId = msg.arg2;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.i(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.i(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot(operationId);\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 != 1) {\n                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                            notifyAccessoryModeExit(operationId);\n                        } else {\n                            // Set this since default function may be selected from Developer\n                            // options\n                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                        }\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mUsbGadgetHal = UsbGadgetHalInstance.getInstance(mUsbDeviceManager,\n                                    null);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false, operationId);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        if (mUsbGadgetHal == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mUsbGadgetHal is null\");\n                            break;\n                        }\n\n                        try {\n                            // MSG_ACCESSORY_MODE_ENTER_TIMEOUT has to be removed to allow exiting\n                            // AOAP mode during resetUsbGadget.\n                            removeMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n                            if (mConfigured) {\n                                mResetUsbGadgetDisableDebounce = true;\n                            }\n                            mUsbGadgetHal.reset(operationId);\n                        } catch (Exception e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                            mResetUsbGadgetDisableDebounce = false;\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mGadgetHal is null, operationId:\" + operationId);\n                        break;\n                    }\n\n                    try {\n                        mUsbGadgetHal.getUsbSpeed(operationId);\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"get UsbSpeed failed\", e);\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mUsbGadgetHal is null\");\n                        break;\n                    }\n                    else {\n                        try {\n                            mCurrentGadgetHalVersion = mUsbGadgetHal.getGadgetHalVersion();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"update Usb gadget version failed\", e);\n                        }\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n\n            if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                  || (mFunctions != functions)) {\n                return;\n            }\n\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            Slog.i(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n            if (status == Status.SUCCESS) {\n                mCurrentFunctionsApplied = true;\n            } else if (!mChargingFunctions) {\n                Slog.e(TAG, \"Setting default fuctions\");\n                sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n            }\n        }\n\n        @Override\n        public void getUsbSpeedCb(int speed) {\n            mUsbSpeed = speed;\n        }\n\n        @Override\n        public void resetCb(int status) {\n            if (status != Status.SUCCESS)\n                Slog.e(TAG, \"resetCb fail\");\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions, int operationId) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mUsbGadgetHal == null) {\n                    Slog.e(TAG, \"setUsbConfig mUsbGadgetHal is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    mUsbGadgetHal.setCurrentUsbFunctions(mCurrentRequest,\n                            config, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS, operationId);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (Exception e) {//RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart, int operationId) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctionsi \" +\n                        \"functions=\" + functions +\n                        \", forceRestart=\" + forceRestart +\n                        \", operationId=\" + operationId);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions, operationId);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n            mUsbGadgetHal.getCurrentUsbFunctions(operationId);\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int pid, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, pid, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n        mHandler.setCurrentUsbFunctionsCb(functions, status,\n                    mRequest, mFunctions, mChargingFunctions);\n    }\n\n    public void getCurrentUsbFunctionsCb(long functions, int status) {\n        mHandler.sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                    status == Status.FUNCTIONS_APPLIED);\n    }\n\n    public void getUsbSpeedCb(int speed) {\n        mHandler.getUsbSpeedCb(speed);\n    }\n\n    public void resetCb(int status) {\n        mHandler.resetCb(status);\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions, int operationId) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        } else if (functions == UsbManager.FUNCTION_UVC) {\n            // MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_UVC);\n            // TODO: Add MetricsEvent for UVC?\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions, operationId);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        int operationId = sUsbOperationCount.incrementAndGet();\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n            sEventLogger.dump(new DualOutputStreamDumpSink(dump, UsbHandlerProto.UEVENT));\n        }\n\n        dump.end(token);\n    }\n\n    /**\n     * Update usb state (Called by native code).\n     */\n    @Keep\n    private void updateGadgetState(String state) {\n        Slog.d(TAG, \"Usb state update \" + state);\n\n        mHandler.updateState(state);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native String nativeWaitAndGetProperty(String propName);\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native boolean nativeStartGadgetMonitor(String udcName);\n\n    private native void nativeStopGadgetMonitor();\n}\n```",
            "upstream_file_tokens": {
              "openai": 21808,
              "general": {
                "word_based": 8151,
                "char_based": 29003
              },
              "gemini": 25756
            },
            "downstream_file_content": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions an\n * limitations under the License.\n */\n\npackage com.android.server.usb;\n\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_DEVICE;\nimport static android.hardware.usb.UsbPortStatus.DATA_ROLE_HOST;\nimport static android.hardware.usb.UsbPortStatus.MODE_AUDIO_ACCESSORY;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SINK;\nimport static android.hardware.usb.UsbPortStatus.POWER_ROLE_SOURCE;\n\nimport static com.android.internal.usb.DumpUtils.writeAccessory;\nimport static com.android.internal.util.dump.DumpUtils.writeStringIfNotNull;\n\nimport android.app.ActivityManager;\nimport android.app.KeyguardManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.debug.AdbManagerInternal;\nimport android.debug.AdbNotifications;\nimport android.debug.AdbTransportType;\nimport android.debug.IAdbTransport;\nimport android.hardware.usb.ParcelableUsbPort;\nimport android.hardware.usb.UsbAccessory;\nimport android.hardware.usb.UsbConfiguration;\nimport android.hardware.usb.UsbConstants;\nimport android.hardware.usb.UsbDevice;\nimport android.hardware.usb.UsbInterface;\nimport android.hardware.usb.UsbManager;\nimport android.hardware.usb.UsbPort;\nimport android.hardware.usb.UsbPortStatus;\nimport android.hardware.usb.gadget.V1_0.GadgetFunction;\nimport android.hardware.usb.gadget.V1_0.Status;\nimport android.hardware.usb.gadget.V1_2.UsbSpeed;\nimport android.hidl.manager.V1_0.IServiceNotification;\nimport android.os.BatteryManager;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HwBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UEventObserver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Settings;\nimport android.service.usb.UsbDeviceManagerProto;\nimport android.service.usb.UsbHandlerProto;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.dump.DualDumpOutputStream;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.usb.hal.gadget.UsbGadgetHal;\nimport com.android.server.usb.hal.gadget.UsbGadgetHalInstance;\nimport com.android.server.utils.EventLogger;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * UsbDeviceManager manages USB state in device mode.\n */\npublic class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObserver {\n\n    private static final String TAG = UsbDeviceManager.class.getSimpleName();\n    private static final boolean DEBUG = false;\n\n    /**\n     * The name of the xml file in which screen unlocked functions are stored.\n     */\n    private static final String USB_PREFS_XML = \"UsbDeviceManagerPrefs.xml\";\n\n    /**\n     * The SharedPreference setting per user that stores the screen unlocked functions between\n     * sessions.\n     */\n    static final String UNLOCKED_CONFIG_PREF = \"usb-screen-unlocked-config-%d\";\n\n    /**\n     * ro.bootmode value when phone boots into usual Android.\n     */\n    private static final String NORMAL_BOOT = \"normal\";\n\n    private static final String USB_STATE_MATCH =\n            \"DEVPATH=/devices/virtual/android_usb/android0\";\n    private static final String ACCESSORY_START_MATCH =\n            \"DEVPATH=/devices/virtual/misc/usb_accessory\";\n    private static final String FUNCTIONS_PATH =\n            \"/sys/class/android_usb/android0/functions\";\n    private static final String STATE_PATH =\n            \"/sys/class/android_usb/android0/state\";\n    private static final String RNDIS_ETH_ADDR_PATH =\n            \"/sys/class/android_usb/android0/f_rndis/ethaddr\";\n    private static final String AUDIO_SOURCE_PCM_PATH =\n            \"/sys/class/android_usb/android0/f_audio_source/pcm\";\n    private static final String MIDI_ALSA_PATH =\n            \"/sys/class/android_usb/android0/f_midi/alsa\";\n\n    private static final int MSG_UPDATE_STATE = 0;\n    private static final int MSG_ENABLE_ADB = 1;\n    private static final int MSG_SET_CURRENT_FUNCTIONS = 2;\n    private static final int MSG_SYSTEM_READY = 3;\n    private static final int MSG_BOOT_COMPLETED = 4;\n    private static final int MSG_USER_SWITCHED = 5;\n    private static final int MSG_UPDATE_USER_RESTRICTIONS = 6;\n    private static final int MSG_UPDATE_PORT_STATE = 7;\n    private static final int MSG_ACCESSORY_MODE_ENTER_TIMEOUT = 8;\n    private static final int MSG_UPDATE_CHARGING_STATE = 9;\n    private static final int MSG_UPDATE_HOST_STATE = 10;\n    private static final int MSG_LOCALE_CHANGED = 11;\n    private static final int MSG_SET_SCREEN_UNLOCKED_FUNCTIONS = 12;\n    private static final int MSG_UPDATE_SCREEN_LOCK = 13;\n    private static final int MSG_SET_CHARGING_FUNCTIONS = 14;\n    private static final int MSG_SET_FUNCTIONS_TIMEOUT = 15;\n    private static final int MSG_GET_CURRENT_USB_FUNCTIONS = 16;\n    private static final int MSG_FUNCTION_SWITCH_TIMEOUT = 17;\n    private static final int MSG_GADGET_HAL_REGISTERED = 18;\n    private static final int MSG_RESET_USB_GADGET = 19;\n    private static final int MSG_ACCESSORY_HANDSHAKE_TIMEOUT = 20;\n    private static final int MSG_INCREASE_SENDSTRING_COUNT = 21;\n    private static final int MSG_UPDATE_USB_SPEED = 22;\n    private static final int MSG_UPDATE_HAL_VERSION = 23;\n\n    private static final int AUDIO_MODE_SOURCE = 1;\n\n    // Delay for debouncing USB disconnects.\n    // We often get rapid connect/disconnect events when enabling USB functions,\n    // which need debouncing.\n    private static final int DEVICE_STATE_UPDATE_DELAY_EXT = 3000;\n    private static final int DEVICE_STATE_UPDATE_DELAY = 1000;\n\n    // Delay for debouncing USB disconnects on Type-C ports in host mode\n    private static final int HOST_STATE_UPDATE_DELAY = 1000;\n\n    // Timeout for entering USB request mode.\n    // Request is cancelled if host does not configure device within 10 seconds.\n    private static final int ACCESSORY_REQUEST_TIMEOUT = 10 * 1000;\n\n    /**\n     * Timeout for receiving USB accessory request\n     * Reset when receive next control request\n     * Broadcast intent if not receive next control request or enter next step.\n     */\n    private static final int ACCESSORY_HANDSHAKE_TIMEOUT = 10 * 1000;\n\n    private static final int DUMPSYS_LOG_BUFFER = 200;\n\n    private static final String BOOT_MODE_PROPERTY = \"ro.bootmode\";\n\n    private static final String ADB_NOTIFICATION_CHANNEL_ID_TV = \"usbdevicemanager.adb.tv\";\n    private UsbHandler mHandler;\n\n    private final Object mLock = new Object();\n\n    private final Context mContext;\n    private final ContentResolver mContentResolver;\n    @GuardedBy(\"mLock\")\n    private UsbProfileGroupSettingsManager mCurrentSettings;\n    private final boolean mHasUsbAccessory;\n    @GuardedBy(\"mLock\")\n    private String[] mAccessoryStrings;\n    private final UEventObserver mUEventObserver;\n\n    private static Set<Integer> sDenyInterfaces;\n    private HashMap<Long, FileDescriptor> mControlFds;\n\n    private static EventLogger sEventLogger;\n\n    private static UsbGadgetHal mUsbGadgetHal;\n\n    /**\n     * Counter for tracking UsbOperation operations.\n     */\n    private static final AtomicInteger sUsbOperationCount = new AtomicInteger();\n\n    static {\n        sDenyInterfaces = new HashSet<>();\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_AUDIO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_COMM);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_PRINTER);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_MASS_STORAGE);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_HUB);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CDC_DATA);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CSCID);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_CONTENT_SEC);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_VIDEO);\n        sDenyInterfaces.add(UsbConstants.USB_CLASS_WIRELESS_CONTROLLER);\n    }\n\n    /*\n     * Listens for uevent messages from the kernel to monitor the USB state\n     */\n    private final class UsbUEventObserver extends UEventObserver {\n        @Override\n        public void onUEvent(UEventObserver.UEvent event) {\n            if (DEBUG) Slog.v(TAG, \"USB UEVENT: \" + event.toString());\n            if (sEventLogger != null) {\n                sEventLogger.enqueue(new EventLogger.StringEvent(\"USB UEVENT: \"\n                        + event.toString()));\n            } else {\n                if (DEBUG) Slog.d(TAG, \"sEventLogger == null\");\n            }\n\n            String state = event.get(\"USB_STATE\");\n            String accessory = event.get(\"ACCESSORY\");\n\n            if (state != null) {\n                mHandler.updateState(state);\n            } else if (\"GETPROTOCOL\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory get protocol\");\n                mHandler.setAccessoryUEventTime(SystemClock.elapsedRealtime());\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"SENDSTRING\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory send string\");\n                mHandler.sendEmptyMessage(MSG_INCREASE_SENDSTRING_COUNT);\n                resetAccessoryHandshakeTimeoutHandler();\n            } else if (\"START\".equals(accessory)) {\n                if (DEBUG) Slog.d(TAG, \"got accessory start\");\n                mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                mHandler.setStartAccessoryTrue();\n                startAccessoryMode();\n            }\n        }\n    }\n\n    @Override\n    public void onKeyguardStateChanged(boolean isShowing) {\n        int userHandle = ActivityManager.getCurrentUser();\n        boolean secure = mContext.getSystemService(KeyguardManager.class)\n                .isDeviceSecure(userHandle);\n        if (DEBUG) {\n            Slog.v(TAG, \"onKeyguardStateChanged: isShowing:\" + isShowing + \" secure:\" + secure\n                    + \" user:\" + userHandle);\n        }\n        // We are unlocked when the keyguard is down or non-secure.\n        mHandler.sendMessage(MSG_UPDATE_SCREEN_LOCK, (isShowing && secure));\n    }\n\n    @Override\n    public void onAwakeStateChanged(boolean isAwake) {\n        // ignore\n    }\n\n    /** Called when a user is unlocked. */\n    public void onUnlockUser(int userHandle) {\n        onKeyguardStateChanged(false);\n    }\n\n    public UsbDeviceManager(Context context, UsbAlsaManager alsaManager,\n            UsbSettingsManager settingsManager, UsbPermissionManager permissionManager) {\n        mContext = context;\n        mContentResolver = context.getContentResolver();\n        PackageManager pm = mContext.getPackageManager();\n        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);\n        initRndisAddress();\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n        boolean halNotPresent = false;\n\n        mUsbGadgetHal = UsbGadgetHalInstance.getInstance(this, null);\n        Slog.d(TAG, \"getInstance done\");\n\n        mControlFds = new HashMap<>();\n        FileDescriptor mtpFd = nativeOpenControl(UsbManager.USB_FUNCTION_MTP);\n        if (mtpFd == null) {\n            Slog.e(TAG, \"Failed to open control for mtp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_MTP, mtpFd);\n        FileDescriptor ptpFd = nativeOpenControl(UsbManager.USB_FUNCTION_PTP);\n        if (ptpFd == null) {\n            Slog.e(TAG, \"Failed to open control for ptp\");\n        }\n        mControlFds.put(UsbManager.FUNCTION_PTP, ptpFd);\n\n        if (mUsbGadgetHal == null) {\n            /**\n             * Initialze the legacy UsbHandler\n             */\n            mHandler = new UsbHandlerLegacy(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        } else {\n            /**\n             * Initialize HAL based UsbHandler\n             */\n            mHandler = new UsbHandlerHal(FgThread.get().getLooper(), mContext, this,\n                    alsaManager, permissionManager);\n        }\n\n        mHandler.handlerInitDone(operationId);\n\n        if (nativeIsStartRequested()) {\n            if (DEBUG) Slog.d(TAG, \"accessory attached at boot\");\n            startAccessoryMode();\n        }\n\n        BroadcastReceiver portReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                ParcelableUsbPort port = intent.getParcelableExtra(UsbManager.EXTRA_PORT, android.hardware.usb.ParcelableUsbPort.class);\n                UsbPortStatus status = intent.getParcelableExtra(UsbManager.EXTRA_PORT_STATUS, android.hardware.usb.UsbPortStatus.class);\n                mHandler.updateHostState(\n                        port.getUsbPort(context.getSystemService(UsbManager.class)), status);\n            }\n        };\n\n        BroadcastReceiver chargingReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\n                boolean usbCharging = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;\n                mHandler.sendMessage(MSG_UPDATE_CHARGING_STATE, usbCharging);\n            }\n        };\n\n        BroadcastReceiver hostReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                Iterator devices = ((UsbManager) context.getSystemService(Context.USB_SERVICE))\n                        .getDeviceList().entrySet().iterator();\n                if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, true);\n                } else {\n                    mHandler.sendMessage(MSG_UPDATE_HOST_STATE, devices, false);\n                }\n            }\n        };\n\n        BroadcastReceiver languageChangedReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);\n            }\n        };\n\n        mContext.registerReceiver(portReceiver,\n                new IntentFilter(UsbManager.ACTION_USB_PORT_CHANGED));\n        mContext.registerReceiver(chargingReceiver,\n                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\n\n        IntentFilter filter =\n                new IntentFilter(UsbManager.ACTION_USB_DEVICE_ATTACHED);\n        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);\n        mContext.registerReceiver(hostReceiver, filter);\n\n        mContext.registerReceiver(languageChangedReceiver,\n                new IntentFilter(Intent.ACTION_LOCALE_CHANGED));\n\n        // Watch for USB configuration changes\n        mUEventObserver = new UsbUEventObserver();\n        mUEventObserver.startObserving(USB_STATE_MATCH);\n        mUEventObserver.startObserving(ACCESSORY_START_MATCH);\n\n        sEventLogger = new EventLogger(DUMPSYS_LOG_BUFFER, \"UsbDeviceManager activity\");\n    }\n\n    UsbProfileGroupSettingsManager getCurrentSettings() {\n        synchronized (mLock) {\n            return mCurrentSettings;\n        }\n    }\n\n    String[] getAccessoryStrings() {\n        synchronized (mLock) {\n            return mAccessoryStrings;\n        }\n    }\n\n    public void systemReady() {\n        if (DEBUG) Slog.d(TAG, \"systemReady\");\n\n        LocalServices.getService(ActivityTaskManagerInternal.class).registerScreenObserver(this);\n\n        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);\n    }\n\n    public void bootCompleted() {\n        if (DEBUG) Slog.d(TAG, \"boot completed\");\n        mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);\n    }\n\n    public void setCurrentUser(int newCurrentUserId, UsbProfileGroupSettingsManager settings) {\n        synchronized (mLock) {\n            mCurrentSettings = settings;\n            mHandler.obtainMessage(MSG_USER_SWITCHED, newCurrentUserId, 0).sendToTarget();\n        }\n    }\n\n    public void updateUserRestrictions() {\n        mHandler.sendEmptyMessage(MSG_UPDATE_USER_RESTRICTIONS);\n    }\n\n    /*\n     * Start the timeout-timer upon receiving \"get_protocol\" uevent.\n     * Restart the timer every time if any succeeding uevnet received.\n     * (Only when USB is under accessory mode)\n     * <p>About the details of the related control request and sequence ordering, refer to\n     * <a href=\"https://source.android.com/devices/accessories/aoa\">AOA</a> developer guide.</p>\n     */\n    private void resetAccessoryHandshakeTimeoutHandler() {\n        long functions = getCurrentFunctions();\n        // some accesories send get_protocol after start accessory\n        if ((functions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n            mHandler.removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n        }\n    }\n\n    private void startAccessoryMode() {\n        if (!mHasUsbAccessory) return;\n\n        int operationId = sUsbOperationCount.incrementAndGet();\n\n        mAccessoryStrings = nativeGetAccessoryStrings();\n        boolean enableAudio = (nativeGetAudioMode() == AUDIO_MODE_SOURCE);\n        // don't start accessory mode if our mandatory strings have not been set\n        boolean enableAccessory = (mAccessoryStrings != null &&\n                mAccessoryStrings[UsbAccessory.MANUFACTURER_STRING] != null &&\n                mAccessoryStrings[UsbAccessory.MODEL_STRING] != null);\n\n        long functions = UsbManager.FUNCTION_NONE;\n        if (enableAccessory) {\n            functions |= UsbManager.FUNCTION_ACCESSORY;\n        }\n        if (enableAudio) {\n            functions |= UsbManager.FUNCTION_AUDIO_SOURCE;\n        }\n\n        if (functions != UsbManager.FUNCTION_NONE) {\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_MODE_ENTER_TIMEOUT),\n                    ACCESSORY_REQUEST_TIMEOUT);\n            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ACCESSORY_HANDSHAKE_TIMEOUT),\n                    ACCESSORY_HANDSHAKE_TIMEOUT);\n            setCurrentFunctions(functions, operationId);\n        }\n    }\n\n    //TODO It is not clear that this method serves any purpose (at least on Pixel devices)\n    // consider removing\n    private static void initRndisAddress() {\n        // configure RNDIS ethernet address based on our serial number using the same algorithm\n        // we had been previously using in kernel board files\n        final int ETH_ALEN = 6;\n        int address[] = new int[ETH_ALEN];\n        // first byte is 0x02 to signify a locally administered address\n        address[0] = 0x02;\n\n        String serial = SystemProperties.get(\"ro.serialno\", \"1234567890ABCDEF\");\n        int serialLength = serial.length();\n        // XOR the USB serial across the remaining 5 bytes\n        for (int i = 0; i < serialLength; i++) {\n            address[i % (ETH_ALEN - 1) + 1] ^= (int) serial.charAt(i);\n        }\n        String addrString = String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]);\n        try {\n            FileUtils.stringToFile(RNDIS_ETH_ADDR_PATH, addrString);\n        } catch (IOException e) {\n            Slog.i(TAG, \"failed to write to \" + RNDIS_ETH_ADDR_PATH);\n        }\n    }\n\n    public static void logAndPrint(int priority, IndentingPrintWriter pw, String msg) {\n        Slog.println(priority, TAG, msg);\n        if (pw != null) {\n            pw.println(msg);\n        }\n    }\n\n    public static void logAndPrintException(IndentingPrintWriter pw, String msg, Exception e) {\n        Slog.e(TAG, msg, e);\n        if (pw != null) {\n            pw.println(msg + e);\n        }\n    }\n\n    abstract static class UsbHandler extends Handler {\n\n        // current USB state\n        private boolean mHostConnected;\n        private boolean mUsbAccessoryConnected;\n        private boolean mInHostModeWithNoAccessoryConnected;\n        private boolean mSourcePower;\n        private boolean mSinkPower;\n        private boolean mAudioAccessoryConnected;\n        private boolean mAudioAccessorySupported;\n        private boolean mConnectedToDataDisabledPort;\n        private int mPowerBrickConnectionStatus;\n\n        private UsbAccessory mCurrentAccessory;\n        private int mUsbNotificationId;\n        private boolean mAdbNotificationShown;\n        private boolean mUsbCharging;\n        private boolean mHideUsbNotification;\n        private boolean mSupportsAllCombinations;\n        private boolean mScreenLocked;\n        private boolean mSystemReady;\n        private Intent mBroadcastedIntent;\n        private boolean mPendingBootBroadcast;\n        private boolean mAudioSourceEnabled;\n        private boolean mMidiEnabled;\n        private int mMidiCard;\n        private int mMidiDevice;\n\n        /**\n         * mAccessoryConnectionStartTime record the timing of start_accessory\n         * mSendStringCount count the number of receiving uevent send_string\n         * mStartAccessory record whether start_accessory is received\n         */\n        private long mAccessoryConnectionStartTime = 0L;\n        private int mSendStringCount = 0;\n        private boolean mStartAccessory = false;\n\n        private final Context mContext;\n        private final UsbAlsaManager mUsbAlsaManager;\n        private final UsbPermissionManager mPermissionManager;\n        private NotificationManager mNotificationManager;\n\n        /**\n         * Do not debounce for the first disconnect after resetUsbGadget.\n         */\n        protected boolean mResetUsbGadgetDisableDebounce;\n        protected boolean mConnected;\n        protected boolean mConfigured;\n        protected long mScreenUnlockedFunctions;\n        protected boolean mBootCompleted;\n        protected boolean mCurrentFunctionsApplied;\n        protected boolean mUseUsbNotification;\n        protected long mCurrentFunctions;\n        protected final UsbDeviceManager mUsbDeviceManager;\n        protected final ContentResolver mContentResolver;\n        protected SharedPreferences mSettings;\n        protected int mCurrentUser;\n        protected boolean mCurrentUsbFunctionsReceived;\n        protected int mUsbSpeed;\n        protected int mCurrentGadgetHalVersion;\n        protected boolean mPendingBootAccessoryHandshakeBroadcast;\n\n        /**\n         * The persistent property which stores whether adb is enabled or not.\n         * May also contain vendor-specific default functions for testing purposes.\n         */\n        protected static final String USB_PERSISTENT_CONFIG_PROPERTY = \"persist.sys.usb.config\";\n\n        UsbHandler(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper);\n            mContext = context;\n            mUsbDeviceManager = deviceManager;\n            mUsbAlsaManager = alsaManager;\n            mPermissionManager = permissionManager;\n            mContentResolver = context.getContentResolver();\n\n            mCurrentUser = ActivityManager.getCurrentUser();\n            mScreenLocked = true;\n\n            mSettings = getPinnedSharedPrefs(mContext);\n            if (mSettings == null) {\n                Slog.e(TAG, \"Couldn't load shared preferences\");\n            } else {\n                mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                        mSettings.getString(\n                                String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF, mCurrentUser),\n                                \"\"));\n            }\n\n            // We do not show the USB notification if the primary volume supports mass storage.\n            // The legacy mass storage UI will be used instead.\n            final StorageManager storageManager = StorageManager.from(mContext);\n            final StorageVolume primary =\n                    storageManager != null ? storageManager.getPrimaryVolume() : null;\n\n            boolean massStorageSupported = primary != null && primary.allowMassStorage();\n            mUseUsbNotification = !massStorageSupported && mContext.getResources().getBoolean(\n                    com.android.internal.R.bool.config_usbChargingMessage);\n        }\n\n        public void sendMessage(int what, boolean arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public boolean sendMessage(int what) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            return sendMessageDelayed(m,0);\n        }\n\n        public void sendMessage(int what, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, Object arg, boolean arg1) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, long arg, boolean arg1, int operationId) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.obj = arg;\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = operationId;\n            sendMessage(m);\n        }\n\n        public void sendMessage(int what, boolean arg1, boolean arg2) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg1 ? 1 : 0);\n            m.arg2 = (arg2 ? 1 : 0);\n            sendMessage(m);\n        }\n\n        public void sendMessageDelayed(int what, boolean arg, long delayMillis) {\n            removeMessages(what);\n            Message m = Message.obtain(this, what);\n            m.arg1 = (arg ? 1 : 0);\n            sendMessageDelayed(m, delayMillis);\n        }\n\n        public void updateState(String state) {\n            int connected, configured;\n\n            if (\"DISCONNECTED\".equals(state)) {\n                connected = 0;\n                configured = 0;\n            } else if (\"CONNECTED\".equals(state)) {\n                connected = 1;\n                configured = 0;\n            } else if (\"CONFIGURED\".equals(state)) {\n                connected = 1;\n                configured = 1;\n            } else {\n                Slog.e(TAG, \"unknown state \" + state);\n                return;\n            }\n            if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            Message msg = Message.obtain(this, MSG_UPDATE_STATE);\n            msg.arg1 = connected;\n            msg.arg2 = configured;\n            if (DEBUG) {\n                Slog.i(TAG, \"mResetUsbGadgetDisableDebounce:\" + mResetUsbGadgetDisableDebounce\n                       + \" connected:\" + connected + \"configured:\" + configured);\n            }\n            if (mResetUsbGadgetDisableDebounce) {\n                // Do not debounce disconnect after resetUsbGadget.\n                sendMessage(msg);\n                if (connected == 1) mResetUsbGadgetDisableDebounce = false;\n            } else {\n                if (configured == 0) {\n                    removeMessages(MSG_UPDATE_STATE);\n                    if (DEBUG) Slog.i(TAG, \"removeMessages MSG_UPDATE_STATE\");\n                }\n                if (connected == 1) removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n                // debounce disconnects to avoid problems bringing up USB tethering.\n                sendMessageDelayed(msg,\n                    (connected == 0) ? (mScreenLocked ? DEVICE_STATE_UPDATE_DELAY\n                                                      : DEVICE_STATE_UPDATE_DELAY_EXT) : 0);\n            }\n        }\n\n        public void updateHostState(UsbPort port, UsbPortStatus status) {\n            if (DEBUG) {\n                Slog.i(TAG, \"updateHostState \" + port + \" status=\" + status);\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = port;\n            args.arg2 = status;\n\n            removeMessages(MSG_UPDATE_PORT_STATE);\n            Message msg = obtainMessage(MSG_UPDATE_PORT_STATE, args);\n            // debounce rapid transitions of connect/disconnect on type-c ports\n            sendMessageDelayed(msg, HOST_STATE_UPDATE_DELAY);\n        }\n\n        private void setAdbEnabled(boolean enable, int operationId) {\n            if (DEBUG) Slog.d(TAG, \"setAdbEnabled: \" + enable);\n\n            if (enable) {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                setSystemProperty(USB_PERSISTENT_CONFIG_PROPERTY, \"\");\n            }\n\n            setEnabledFunctions(mCurrentFunctions, true, operationId);\n            updateAdbNotification(false);\n        }\n\n        protected boolean isUsbTransferAllowed() {\n            UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n            return !userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);\n        }\n\n        private void updateCurrentAccessory() {\n            // We are entering accessory mode if we have received a request from the host\n            // and the request has not timed out yet.\n            int operationId = sUsbOperationCount.incrementAndGet();\n\n            boolean enteringAccessoryMode = hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n\n            if (mConfigured && enteringAccessoryMode) {\n                // successfully entered accessory mode\n                String[] accessoryStrings = mUsbDeviceManager.getAccessoryStrings();\n                if (accessoryStrings != null) {\n                    UsbSerialReader serialReader = new UsbSerialReader(mContext, mPermissionManager,\n                            accessoryStrings[UsbAccessory.SERIAL_STRING]);\n\n                    mCurrentAccessory = new UsbAccessory(\n                            accessoryStrings[UsbAccessory.MANUFACTURER_STRING],\n                            accessoryStrings[UsbAccessory.MODEL_STRING],\n                            accessoryStrings[UsbAccessory.DESCRIPTION_STRING],\n                            accessoryStrings[UsbAccessory.VERSION_STRING],\n                            accessoryStrings[UsbAccessory.URI_STRING],\n                            serialReader);\n\n                    serialReader.setDevice(mCurrentAccessory);\n\n                    Slog.d(TAG, \"entering USB accessory mode: \" + mCurrentAccessory);\n                    // defer accessoryAttached if system is not ready\n                    if (mBootCompleted) {\n                        mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                        removeMessages(MSG_ACCESSORY_HANDSHAKE_TIMEOUT);\n                        broadcastUsbAccessoryHandshake();\n                    } // else handle in boot completed\n                } else {\n                    Slog.e(TAG, \"nativeGetAccessoryStrings failed\");\n                }\n            } else {\n                if (!enteringAccessoryMode) {\n                    notifyAccessoryModeExit(operationId);\n                } else if (DEBUG) {\n                    Slog.v(TAG, \"Debouncing accessory mode exit\");\n                }\n            }\n        }\n\n        protected void notifyAccessoryModeExit(int operationId) {\n            // make sure accessory mode is off\n            // and restore default functions\n            Slog.d(TAG, \"exited USB accessory mode\");\n            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n\n            if (mCurrentAccessory != null) {\n                if (mBootCompleted) {\n                    mPermissionManager.usbAccessoryRemoved(mCurrentAccessory);\n                }\n                mCurrentAccessory = null;\n            }\n        }\n\n        protected SharedPreferences getPinnedSharedPrefs(Context context) {\n            final File prefsFile = new File(\n                    Environment.getDataSystemDeDirectory(UserHandle.USER_SYSTEM), USB_PREFS_XML);\n            return context.createDeviceProtectedStorageContext()\n                    .getSharedPreferences(prefsFile, Context.MODE_PRIVATE);\n        }\n\n        private boolean isUsbStateChanged(Intent intent) {\n            final Set<String> keySet = intent.getExtras().keySet();\n            if (mBroadcastedIntent == null) {\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            } else {\n                if (!keySet.equals(mBroadcastedIntent.getExtras().keySet())) {\n                    return true;\n                }\n                for (String key : keySet) {\n                    if (intent.getBooleanExtra(key, false) !=\n                            mBroadcastedIntent.getBooleanExtra(key, false)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void broadcastUsbAccessoryHandshake() {\n            // send a sticky broadcast containing USB accessory handshake information\n            Intent intent = new Intent(UsbManager.ACTION_USB_ACCESSORY_HANDSHAKE)\n                    .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                        | Intent.FLAG_RECEIVER_FOREGROUND)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_UEVENT_TIME,\n                            mAccessoryConnectionStartTime)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_STRING_COUNT,\n                            mSendStringCount)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_START,\n                            mStartAccessory)\n                    .putExtra(UsbManager.EXTRA_ACCESSORY_HANDSHAKE_END,\n                            SystemClock.elapsedRealtime());\n\n            if (DEBUG) {\n                Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            }\n\n            sendStickyBroadcast(intent);\n            resetUsbAccessoryHandshakeDebuggingInfo();\n        }\n\n        protected void updateUsbStateBroadcastIfNeeded(long functions) {\n            // send a sticky broadcast containing current USB state\n            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);\n            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING\n                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND\n                    | Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);\n            intent.putExtra(UsbManager.USB_HOST_CONNECTED, mHostConnected);\n            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);\n            intent.putExtra(UsbManager.USB_DATA_UNLOCKED,\n                    isUsbTransferAllowed() && isUsbDataTransferActive(mCurrentFunctions));\n\n            long remainingFunctions = functions;\n            while (remainingFunctions != 0) {\n                intent.putExtra(UsbManager.usbFunctionsToString(\n                        Long.highestOneBit(remainingFunctions)), true);\n                remainingFunctions -= Long.highestOneBit(remainingFunctions);\n            }\n\n            // send broadcast intent only if the USB state has changed\n            if (!isUsbStateChanged(intent)) {\n                if (DEBUG) {\n                    Slog.d(TAG, \"skip broadcasting \" + intent + \" extras: \" + intent.getExtras());\n                }\n                return;\n            }\n\n            if (DEBUG) Slog.d(TAG, \"broadcasting \" + intent + \" extras: \" + intent.getExtras());\n            sendStickyBroadcast(intent);\n            mBroadcastedIntent = intent;\n        }\n\n        protected void sendStickyBroadcast(Intent intent) {\n            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);\n            sEventLogger.enqueue(new EventLogger.StringEvent(\"USB intent: \" + intent));\n        }\n\n        private void updateUsbFunctions() {\n            updateMidiFunction();\n        }\n\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                if (enabled) {\n                    Scanner scanner = null;\n                    try {\n                        scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                        mMidiCard = scanner.nextInt();\n                        mMidiDevice = scanner.nextInt();\n                    } catch (FileNotFoundException e) {\n                        Slog.e(TAG, \"could not open MIDI file\", e);\n                        enabled = false;\n                    } finally {\n                        if (scanner != null) {\n                            scanner.close();\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n        private void setScreenUnlockedFunctions(int operationId) {\n            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n        }\n\n        private static class AdbTransport extends IAdbTransport.Stub {\n            private final UsbHandler mHandler;\n\n            AdbTransport(UsbHandler handler) {\n                mHandler = handler;\n            }\n\n            @Override\n            public void onAdbEnabled(boolean enabled, byte transportType) {\n                if (transportType == AdbTransportType.USB) {\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n                }\n            }\n        }\n\n        /**\n         * Returns the functions that are passed down to the low level driver once adb and\n         * charging are accounted for.\n         */\n        long getAppliedFunctions(long functions) {\n            if (functions == UsbManager.FUNCTION_NONE) {\n                return getChargingFunctions();\n            }\n            if (isAdbEnabled()) {\n                return functions | UsbManager.FUNCTION_ADB;\n            }\n            return functions;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_STATE:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    mConnected = (msg.arg1 == 1);\n                    mConfigured = (msg.arg2 == 1);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"handleMessage MSG_UPDATE_STATE \" + \"mConnected:\" + mConnected\n                               + \" mConfigured:\" + mConfigured);\n                    }\n                    updateUsbNotification(false);\n                    updateAdbNotification(false);\n                    if (mBootCompleted) {\n                        updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    }\n                    if ((mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) != 0) {\n                        updateCurrentAccessory();\n                    }\n                    if (mBootCompleted) {\n                        if (!mConnected && !hasMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT)\n                                && !hasMessages(MSG_FUNCTION_SWITCH_TIMEOUT)) {\n                            // restore defaults when USB is disconnected\n                            if (!mScreenLocked\n                                    && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                                setScreenUnlockedFunctions(operationId);\n                            } else {\n                                setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                            }\n                        }\n                        updateUsbFunctions();\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    updateUsbSpeed();\n                    break;\n                case MSG_UPDATE_PORT_STATE:\n                    SomeArgs args = (SomeArgs) msg.obj;\n                    boolean prevHostConnected = mHostConnected;\n                    UsbPort port = (UsbPort) args.arg1;\n                    UsbPortStatus status = (UsbPortStatus) args.arg2;\n\n                    if (status != null) {\n                        mHostConnected = status.getCurrentDataRole() == DATA_ROLE_HOST;\n                        mSourcePower = status.getCurrentPowerRole() == POWER_ROLE_SOURCE;\n                        mSinkPower = status.getCurrentPowerRole() == POWER_ROLE_SINK;\n                        mAudioAccessoryConnected = (status.getCurrentMode() == MODE_AUDIO_ACCESSORY);\n\n                        // Ideally we want to see if PR_SWAP and DR_SWAP is supported.\n                        // But, this should be suffice, since, all four combinations are only supported\n                        // when PR_SWAP and DR_SWAP are supported.\n                        mSupportsAllCombinations = status.isRoleCombinationSupported(\n                                POWER_ROLE_SOURCE, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_HOST)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SOURCE,\n                                DATA_ROLE_DEVICE)\n                                && status.isRoleCombinationSupported(POWER_ROLE_SINK, DATA_ROLE_DEVICE);\n\n                        boolean usbDataDisabled =\n                                status.getUsbDataStatus() != UsbPortStatus.DATA_STATUS_ENABLED;\n                        mConnectedToDataDisabledPort = status.isConnected() && usbDataDisabled;\n                        mPowerBrickConnectionStatus = status.getPowerBrickConnectionStatus();\n                    } else {\n                        mHostConnected = false;\n                        mSourcePower = false;\n                        mSinkPower = false;\n                        mAudioAccessoryConnected = false;\n                        mSupportsAllCombinations = false;\n                        mConnectedToDataDisabledPort = false;\n                        mPowerBrickConnectionStatus = UsbPortStatus.POWER_BRICK_STATUS_UNKNOWN;\n                    }\n\n                    if (mHostConnected) {\n                        if (!mUsbAccessoryConnected) {\n                            mInHostModeWithNoAccessoryConnected = true;\n                        } else {\n                            mInHostModeWithNoAccessoryConnected = false;\n                        }\n                    } else {\n                        // if not in host mode, reset value to false\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mAudioAccessorySupported = port.isModeSupported(MODE_AUDIO_ACCESSORY);\n\n                    args.recycle();\n                    updateUsbNotification(false);\n                    if (mBootCompleted) {\n                        if (mHostConnected || prevHostConnected) {\n                            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                        }\n                    } else {\n                        mPendingBootBroadcast = true;\n                    }\n                    break;\n                case MSG_UPDATE_CHARGING_STATE:\n                    mUsbCharging = (msg.arg1 == 1);\n                    updateUsbNotification(false);\n                    break;\n                case MSG_UPDATE_HOST_STATE:\n                    Iterator devices = (Iterator) msg.obj;\n                    mUsbAccessoryConnected = (msg.arg1 == 1);\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"HOST_STATE connected:\" + mUsbAccessoryConnected);\n                    }\n\n                    if (!devices.hasNext()) {\n                        mInHostModeWithNoAccessoryConnected = true;\n                    } else {\n                        mInHostModeWithNoAccessoryConnected = false;\n                    }\n\n                    mHideUsbNotification = false;\n                    while (devices.hasNext()) {\n                        Map.Entry pair = (Map.Entry) devices.next();\n                        if (DEBUG) {\n                            Slog.i(TAG, pair.getKey() + \" = \" + pair.getValue());\n                        }\n                        UsbDevice device = (UsbDevice) pair.getValue();\n                        int configurationCount = device.getConfigurationCount() - 1;\n                        while (configurationCount >= 0) {\n                            UsbConfiguration config = device.getConfiguration(configurationCount);\n                            configurationCount--;\n                            int interfaceCount = config.getInterfaceCount() - 1;\n                            while (interfaceCount >= 0) {\n                                UsbInterface intrface = config.getInterface(interfaceCount);\n                                interfaceCount--;\n                                if (sDenyInterfaces.contains(intrface.getInterfaceClass())) {\n                                    mHideUsbNotification = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    updateUsbNotification(false);\n                    break;\n                case MSG_ENABLE_ADB:\n                    setAdbEnabled(msg.arg1 == 1, msg.arg2);\n                    break;\n                case MSG_SET_CURRENT_FUNCTIONS:\n                    long functions = (Long) msg.obj;\n                    operationId = (int) msg.arg1;\n                    setEnabledFunctions(functions, false, operationId);\n                    break;\n                case MSG_SET_SCREEN_UNLOCKED_FUNCTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mScreenUnlockedFunctions = (Long) msg.obj;\n                    if (mSettings != null) {\n                        SharedPreferences.Editor editor = mSettings.edit();\n                        editor.putString(String.format(Locale.ENGLISH, UNLOCKED_CONFIG_PREF,\n                                mCurrentUser),\n                                UsbManager.usbFunctionsToString(mScreenUnlockedFunctions));\n                        editor.commit();\n                    }\n                    if (!mScreenLocked && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                        // If the screen is unlocked, also set current functions.\n                        setScreenUnlockedFunctions(operationId);\n                    } else {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                case MSG_UPDATE_SCREEN_LOCK:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 == 1 == mScreenLocked) {\n                        break;\n                    }\n                    mScreenLocked = msg.arg1 == 1;\n                    if (!mBootCompleted) {\n                        break;\n                    }\n                    if (mScreenLocked) {\n                        if (!mConnected) {\n                            setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                        }\n                    } else {\n                        if (mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE\n                                && mCurrentFunctions == UsbManager.FUNCTION_NONE) {\n                            // Set the screen unlocked functions if current function is charging.\n                            setScreenUnlockedFunctions(operationId);\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USER_RESTRICTIONS:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    // Restart the USB stack if USB transfer is enabled but no longer allowed.\n                    if (isUsbDataTransferActive(mCurrentFunctions) && !isUsbTransferAllowed()) {\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, true, operationId);\n                    }\n                    break;\n                case MSG_SYSTEM_READY:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mNotificationManager = (NotificationManager)\n                            mContext.getSystemService(Context.NOTIFICATION_SERVICE);\n\n                    LocalServices.getService(\n                            AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n\n                    // Ensure that the notification channels are set up\n                    if (isTv()) {\n                        // TV-specific notification channel\n                        mNotificationManager.createNotificationChannel(\n                                new NotificationChannel(ADB_NOTIFICATION_CHANNEL_ID_TV,\n                                        mContext.getString(\n                                                com.android.internal.R.string\n                                                        .adb_debugging_notification_channel_tv),\n                                        NotificationManager.IMPORTANCE_HIGH));\n                    }\n                    mSystemReady = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_LOCALE_CHANGED:\n                    updateAdbNotification(true);\n                    updateUsbNotification(true);\n                    break;\n                case MSG_BOOT_COMPLETED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    mBootCompleted = true;\n                    finishBoot(operationId);\n                    break;\n                case MSG_USER_SWITCHED: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mCurrentUser != msg.arg1) {\n                        if (DEBUG) {\n                            Slog.v(TAG, \"Current user switched to \" + msg.arg1);\n                        }\n                        mCurrentUser = msg.arg1;\n                        mScreenLocked = true;\n                        mScreenUnlockedFunctions = UsbManager.FUNCTION_NONE;\n                        if (mSettings != null) {\n                            mScreenUnlockedFunctions = UsbManager.usbFunctionsFromString(\n                                    mSettings.getString(String.format(Locale.ENGLISH,\n                                            UNLOCKED_CONFIG_PREF, mCurrentUser), \"\"));\n                        }\n                        setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_MODE_ENTER_TIMEOUT: {\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory mode enter timeout: \" + mConnected\n                                    + \" ,operationId: \" + operationId);\n                    }\n                    if (!mConnected || (mCurrentFunctions & UsbManager.FUNCTION_ACCESSORY) == 0) {\n                        notifyAccessoryModeExit(operationId);\n                    }\n                    break;\n                }\n                case MSG_ACCESSORY_HANDSHAKE_TIMEOUT: {\n                    if (DEBUG) {\n                        Slog.v(TAG, \"Accessory handshake timeout\");\n                    }\n                    if (mBootCompleted) {\n                        broadcastUsbAccessoryHandshake();\n                    } else {\n                        if (DEBUG) Slog.v(TAG, \"Pending broadcasting intent as \"\n                                + \"not boot completed yet.\");\n                        mPendingBootAccessoryHandshakeBroadcast = true;\n                    }\n                    break;\n                }\n                case MSG_INCREASE_SENDSTRING_COUNT: {\n                    mSendStringCount = mSendStringCount + 1;\n                }\n            }\n        }\n\n        public abstract void handlerInitDone(int operationId);\n\n        protected void finishBoot(int operationId) {\n            if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {\n                if (mPendingBootBroadcast) {\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                    mPendingBootBroadcast = false;\n                }\n                if (!mScreenLocked\n                        && mScreenUnlockedFunctions != UsbManager.FUNCTION_NONE) {\n                    setScreenUnlockedFunctions(operationId);\n                } else {\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                }\n                if (mCurrentAccessory != null) {\n                    mUsbDeviceManager.getCurrentSettings().accessoryAttached(mCurrentAccessory);\n                    broadcastUsbAccessoryHandshake();\n                } else if (mPendingBootAccessoryHandshakeBroadcast) {\n                    broadcastUsbAccessoryHandshake();\n                }\n\n                mPendingBootAccessoryHandshakeBroadcast = false;\n                updateUsbNotification(false);\n                updateAdbNotification(false);\n                updateUsbFunctions();\n            }\n        }\n\n        protected boolean isUsbDataTransferActive(long functions) {\n            return (functions & UsbManager.FUNCTION_MTP) != 0\n                    || (functions & UsbManager.FUNCTION_PTP) != 0;\n        }\n\n        public UsbAccessory getCurrentAccessory() {\n            return mCurrentAccessory;\n        }\n\n        protected void updateUsbGadgetHalVersion() {\n            sendMessage(MSG_UPDATE_HAL_VERSION, null);\n        }\n\n        protected void updateUsbSpeed() {\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_0) {\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                return;\n            }\n\n            if (mConnected && mConfigured) {\n                sendMessage(MSG_UPDATE_USB_SPEED, null);\n            } else {\n                // clear USB speed due to disconnected\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n            }\n\n            return;\n        }\n\n        protected void updateUsbNotification(boolean force) {\n            if (mNotificationManager == null || !mUseUsbNotification\n                    || (\"0\".equals(getSystemProperty(\"persist.charging.notify\", \"\")))) {\n                return;\n            }\n\n            // Dont show the notification when connected to a USB peripheral\n            // and the link does not support PR_SWAP and DR_SWAP\n            if ((mHideUsbNotification || mInHostModeWithNoAccessoryConnected)\n                    && !mSupportsAllCombinations) {\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    mUsbNotificationId = 0;\n                    Slog.d(TAG, \"Clear notification\");\n                }\n                return;\n            }\n\n            int id = 0;\n            int titleRes = 0;\n            Resources r = mContext.getResources();\n            CharSequence message = r.getText(\n                    com.android.internal.R.string.usb_notification_message);\n            if (mAudioAccessoryConnected && !mAudioAccessorySupported) {\n                titleRes = com.android.internal.R.string.usb_unsupported_audio_accessory_title;\n                id = SystemMessage.NOTE_USB_AUDIO_ACCESSORY_NOT_SUPPORTED;\n            } else if (mConnected) {\n                if (mCurrentFunctions == UsbManager.FUNCTION_MTP) {\n                    titleRes = com.android.internal.R.string.usb_mtp_notification_title;\n                    id = SystemMessage.NOTE_USB_MTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_PTP) {\n                    titleRes = com.android.internal.R.string.usb_ptp_notification_title;\n                    id = SystemMessage.NOTE_USB_PTP;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_MIDI) {\n                    titleRes = com.android.internal.R.string.usb_midi_notification_title;\n                    id = SystemMessage.NOTE_USB_MIDI;\n                } else if ((mCurrentFunctions == UsbManager.FUNCTION_RNDIS)\n                        || (mCurrentFunctions == UsbManager.FUNCTION_NCM)) {\n                    titleRes = com.android.internal.R.string.usb_tether_notification_title;\n                    id = SystemMessage.NOTE_USB_TETHER;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_UVC) {\n                    titleRes = com.android.internal.R.string.usb_uvc_notification_title;\n                    id = SystemMessage.NOTE_USB_UVC;\n                } else if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                    titleRes = com.android.internal.R.string.usb_accessory_notification_title;\n                    id = SystemMessage.NOTE_USB_ACCESSORY;\n                }\n                if (mSourcePower) {\n                    if (titleRes != 0) {\n                        message = r.getText(\n                                com.android.internal.R.string.usb_power_notification_message);\n                    } else {\n                        titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                        id = SystemMessage.NOTE_USB_SUPPLYING;\n                    }\n                } else if (titleRes == 0) {\n                    titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                    id = SystemMessage.NOTE_USB_CHARGING;\n                }\n            } else if (mSourcePower) {\n                titleRes = com.android.internal.R.string.usb_supplying_notification_title;\n                id = SystemMessage.NOTE_USB_SUPPLYING;\n            } else if (mHostConnected && mSinkPower && (mUsbCharging || mUsbAccessoryConnected)) {\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            } else if (mSinkPower && mConnectedToDataDisabledPort\n                    && mPowerBrickConnectionStatus != UsbPortStatus.POWER_BRICK_STATUS_CONNECTED) {\n                // Show charging notification when USB Data is disabled on the port, and not\n                // connected to a wall charger.\n                titleRes = com.android.internal.R.string.usb_charging_notification_title;\n                id = SystemMessage.NOTE_USB_CHARGING;\n            }\n            if (id != mUsbNotificationId || force) {\n                // clear notification if title needs changing\n                if (mUsbNotificationId != 0) {\n                    mNotificationManager.cancelAsUser(null, mUsbNotificationId,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"Clear notification\");\n                    mUsbNotificationId = 0;\n                }\n                // Not relevant for automotive and watch.\n                if ((mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_AUTOMOTIVE)\n                        || mContext.getPackageManager().hasSystemFeature(\n                        PackageManager.FEATURE_WATCH))\n                        && id == SystemMessage.NOTE_USB_CHARGING) {\n                    mUsbNotificationId = 0;\n                    return;\n                }\n\n                if (id != 0) {\n                    CharSequence title = r.getText(titleRes);\n                    PendingIntent pi;\n                    String channel;\n\n                    if (titleRes\n                            != com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        Intent intent = Intent.makeRestartActivityTask(\n                                new ComponentName(\"com.android.settings\",\n                                        \"com.android.settings.Settings$UsbDetailsActivity\"));\n                        // Simple notification clicks are immutable\n                        pi = PendingIntent.getActivityAsUser(mContext, 0,\n                                intent, PendingIntent.FLAG_IMMUTABLE, null, UserHandle.CURRENT);\n                        channel = SystemNotificationChannels.USB;\n                    } else {\n                        final Intent intent = new Intent();\n                        intent.setClassName(\"com.android.settings\",\n                                \"com.android.settings.HelpTrampoline\");\n                        intent.putExtra(Intent.EXTRA_TEXT,\n                                \"help_url_audio_accessory_not_supported\");\n\n                        if (mContext.getPackageManager().resolveActivity(intent, 0) != null) {\n                            // Simple notification clicks are immutable\n                            pi = PendingIntent.getActivity(mContext, 0, intent,\n                                    PendingIntent.FLAG_IMMUTABLE);\n                        } else {\n                            pi = null;\n                        }\n\n                        channel = SystemNotificationChannels.ALERTS;\n                        message = r.getText(\n                                com.android.internal.R.string\n                                        .usb_unsupported_audio_accessory_message);\n                    }\n\n                    Notification.Builder builder = new Notification.Builder(mContext, channel)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(title)\n                            .setDefaults(0)  // please be quiet\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color\n                                            .system_notification_accent_color))\n                            .setContentTitle(title)\n                            .setContentText(message)\n                            .setContentIntent(pi)\n                            .setVisibility(Notification.VISIBILITY_PUBLIC);\n\n                    if (titleRes\n                            == com.android.internal.R.string\n                            .usb_unsupported_audio_accessory_title) {\n                        builder.setStyle(new Notification.BigTextStyle()\n                                .bigText(message));\n                    }\n                    Notification notification = builder.build();\n\n                    mNotificationManager.notifyAsUser(null, id, notification,\n                            UserHandle.ALL);\n                    Slog.d(TAG, \"push notification:\" + title);\n                    mUsbNotificationId = id;\n                }\n            }\n        }\n\n        protected boolean isAdbEnabled() {\n            return LocalServices.getService(AdbManagerInternal.class)\n                    .isAdbEnabled(AdbTransportType.USB);\n        }\n\n        protected void updateAdbNotification(boolean force) {\n            if (mNotificationManager == null) return;\n            final int id = SystemMessage.NOTE_ADB_ACTIVE;\n\n            if (isAdbEnabled() && mConnected) {\n                if (\"0\".equals(getSystemProperty(\"persist.adb.notify\", \"\"))) return;\n\n                if (force && mAdbNotificationShown) {\n                    mAdbNotificationShown = false;\n                    mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n                }\n\n                if (!mAdbNotificationShown) {\n                    Notification notification = AdbNotifications.createNotification(mContext,\n                            AdbTransportType.USB);\n                    mAdbNotificationShown = true;\n                    mNotificationManager.notifyAsUser(null, id, notification, UserHandle.ALL);\n                }\n            } else if (mAdbNotificationShown) {\n                mAdbNotificationShown = false;\n                mNotificationManager.cancelAsUser(null, id, UserHandle.ALL);\n            }\n        }\n\n        private boolean isTv() {\n            return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);\n        }\n\n        protected long getChargingFunctions() {\n            // if ADB is enabled, reset functions to ADB\n            // else enable MTP as usual.\n            if (isAdbEnabled()) {\n                return UsbManager.FUNCTION_ADB;\n            } else {\n                return UsbManager.FUNCTION_MTP;\n            }\n        }\n\n        protected void setSystemProperty(String prop, String val) {\n            SystemProperties.set(prop, val);\n        }\n\n        protected String getSystemProperty(String prop, String def) {\n            return SystemProperties.get(prop, def);\n        }\n\n        protected void putGlobalSettings(ContentResolver contentResolver, String setting, int val) {\n            Settings.Global.putInt(contentResolver, setting, val);\n        }\n\n        public long getEnabledFunctions() {\n            return mCurrentFunctions;\n        }\n\n        public long getScreenUnlockedFunctions() {\n            return mScreenUnlockedFunctions;\n        }\n\n        public int getUsbSpeed() {\n            return mUsbSpeed;\n        }\n\n        public int getGadgetHalVersion() {\n            return mCurrentGadgetHalVersion;\n        }\n\n        /**\n         * Dump a functions mask either as proto-enums (if dumping to proto) or a string (if dumping\n         * to a print writer)\n         */\n        private void dumpFunctions(DualDumpOutputStream dump, String idName, long id,\n                long functions) {\n            // UsbHandlerProto.UsbFunction matches GadgetFunction\n            for (int i = 0; i < 63; i++) {\n                if ((functions & (1L << i)) != 0) {\n                    if (dump.isProto()) {\n                        dump.write(idName, id, 1L << i);\n                    } else {\n                        dump.write(idName, id, GadgetFunction.toString(1L << i));\n                    }\n                }\n            }\n        }\n\n        public void dump(DualDumpOutputStream dump, String idName, long id) {\n            long token = dump.start(idName, id);\n\n            dumpFunctions(dump, \"current_functions\", UsbHandlerProto.CURRENT_FUNCTIONS,\n                    mCurrentFunctions);\n            dump.write(\"current_functions_applied\", UsbHandlerProto.CURRENT_FUNCTIONS_APPLIED,\n                    mCurrentFunctionsApplied);\n            dumpFunctions(dump, \"screen_unlocked_functions\",\n                    UsbHandlerProto.SCREEN_UNLOCKED_FUNCTIONS, mScreenUnlockedFunctions);\n            dump.write(\"screen_locked\", UsbHandlerProto.SCREEN_LOCKED, mScreenLocked);\n            dump.write(\"connected\", UsbHandlerProto.CONNECTED, mConnected);\n            dump.write(\"configured\", UsbHandlerProto.CONFIGURED, mConfigured);\n            if (mCurrentAccessory != null) {\n                writeAccessory(dump, \"current_accessory\", UsbHandlerProto.CURRENT_ACCESSORY,\n                        mCurrentAccessory);\n            }\n            dump.write(\"host_connected\", UsbHandlerProto.HOST_CONNECTED, mHostConnected);\n            dump.write(\"source_power\", UsbHandlerProto.SOURCE_POWER, mSourcePower);\n            dump.write(\"sink_power\", UsbHandlerProto.SINK_POWER, mSinkPower);\n            dump.write(\"usb_charging\", UsbHandlerProto.USB_CHARGING, mUsbCharging);\n            dump.write(\"hide_usb_notification\", UsbHandlerProto.HIDE_USB_NOTIFICATION,\n                    mHideUsbNotification);\n            dump.write(\"audio_accessory_connected\", UsbHandlerProto.AUDIO_ACCESSORY_CONNECTED,\n                    mAudioAccessoryConnected);\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_state\", UsbHandlerProto.KERNEL_STATE,\n                        FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel state:\" + STATE_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel state\", e);\n            }\n\n            try {\n                writeStringIfNotNull(dump, \"kernel_function_list\",\n                        UsbHandlerProto.KERNEL_FUNCTION_LIST,\n                        FileUtils.readTextFile(new File(FUNCTIONS_PATH), 0, null).trim());\n            } catch (FileNotFoundException exNotFound) {\n                Slog.w(TAG, \"Ignore missing legacy kernel path in bugreport dump: \"\n                        + \"kernel function list:\" + FUNCTIONS_PATH);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Could not read kernel function list\", e);\n            }\n\n            dump.end(token);\n        }\n\n        /**\n         * Evaluates USB function policies and applies the change accordingly.\n         */\n        protected abstract void setEnabledFunctions(long functions,\n                boolean forceRestart, int operationId);\n\n        public void setAccessoryUEventTime(long accessoryConnectionStartTime) {\n            mAccessoryConnectionStartTime = accessoryConnectionStartTime;\n        }\n\n        public void setStartAccessoryTrue() {\n            mStartAccessory = true;\n        }\n\n        public void resetUsbAccessoryHandshakeDebuggingInfo() {\n            mAccessoryConnectionStartTime = 0L;\n            mSendStringCount = 0;\n            mStartAccessory = false;\n        }\n\n        public abstract void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions);\n\n        public abstract void getUsbSpeedCb(int speed);\n\n        public abstract void resetCb(int status);\n    }\n\n    private static final class UsbHandlerLegacy extends UsbHandler {\n        /**\n         * The non-persistent property which stores the current USB settings.\n         */\n        private static final String USB_CONFIG_PROPERTY = \"sys.usb.config\";\n\n        /**\n         * The non-persistent property which stores the current USB actual state.\n         */\n        private static final String USB_STATE_PROPERTY = \"sys.usb.state\";\n\n        private HashMap<String, HashMap<String, Pair<String, String>>> mOemModeMap;\n        private String mCurrentOemFunctions;\n        private String mCurrentFunctionsStr;\n        private boolean mUsbDataUnlocked;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        UsbHandlerLegacy(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            try {\n                readOemUsbOverrideConfig(context);\n                // Restore default functions.\n                mCurrentOemFunctions = getSystemProperty(getPersistProp(false),\n                        UsbManager.USB_FUNCTION_NONE);\n                if (isNormalBoot()) {\n                    mCurrentFunctionsStr = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = mCurrentFunctionsStr.equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                } else {\n                    mCurrentFunctionsStr = getSystemProperty(getPersistProp(true),\n                            UsbManager.USB_FUNCTION_NONE);\n                    mCurrentFunctionsApplied = getSystemProperty(USB_CONFIG_PROPERTY,\n                            UsbManager.USB_FUNCTION_NONE).equals(\n                            getSystemProperty(USB_STATE_PROPERTY, UsbManager.USB_FUNCTION_NONE));\n                }\n                mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                mCurrentUsbFunctionsReceived = true;\n\n                mUsbSpeed = UsbSpeed.UNKNOWN;\n                mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_NOT_SUPPORTED;\n\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n        }\n\n        private void readOemUsbOverrideConfig(Context context) {\n            String[] configList = context.getResources().getStringArray(\n                    com.android.internal.R.array.config_oemUsbModeOverride);\n\n            if (configList != null) {\n                for (String config : configList) {\n                    String[] items = config.split(\":\");\n                    if (items.length == 3 || items.length == 4) {\n                        if (mOemModeMap == null) {\n                            mOemModeMap = new HashMap<>();\n                        }\n                        HashMap<String, Pair<String, String>> overrideMap =\n                                mOemModeMap.get(items[0]);\n                        if (overrideMap == null) {\n                            overrideMap = new HashMap<>();\n                            mOemModeMap.put(items[0], overrideMap);\n                        }\n\n                        // Favoring the first combination if duplicate exists\n                        if (!overrideMap.containsKey(items[1])) {\n                            if (items.length == 3) {\n                                overrideMap.put(items[1], new Pair<>(items[2], \"\"));\n                            } else {\n                                overrideMap.put(items[1], new Pair<>(items[2], items[3]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private String applyOemOverrideFunction(String usbFunctions) {\n            if ((usbFunctions == null) || (mOemModeMap == null)) {\n                return usbFunctions;\n            }\n\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            Slog.d(TAG, \"applyOemOverride usbfunctions=\" + usbFunctions + \" bootmode=\" + bootMode);\n\n            Map<String, Pair<String, String>> overridesMap =\n                    mOemModeMap.get(bootMode);\n            // Check to ensure that the oem is not overriding in the normal\n            // boot mode\n            if (overridesMap != null && !(bootMode.equals(NORMAL_BOOT)\n                    || bootMode.equals(\"unknown\"))) {\n                Pair<String, String> overrideFunctions =\n                        overridesMap.get(usbFunctions);\n                if (overrideFunctions != null) {\n                    Slog.d(TAG, \"OEM USB override: \" + usbFunctions\n                            + \" ==> \" + overrideFunctions.first\n                            + \" persist across reboot \"\n                            + overrideFunctions.second);\n                    if (!overrideFunctions.second.equals(\"\")) {\n                        String newFunction;\n                        if (isAdbEnabled()) {\n                            newFunction = addFunction(overrideFunctions.second,\n                                    UsbManager.USB_FUNCTION_ADB);\n                        } else {\n                            newFunction = overrideFunctions.second;\n                        }\n                        Slog.d(TAG, \"OEM USB override persisting: \" + newFunction + \"in prop: \"\n                                + getPersistProp(false));\n                        setSystemProperty(getPersistProp(false), newFunction);\n                    }\n                    return overrideFunctions.first;\n                } else if (isAdbEnabled()) {\n                    String newFunction = addFunction(UsbManager.USB_FUNCTION_NONE,\n                            UsbManager.USB_FUNCTION_ADB);\n                    setSystemProperty(getPersistProp(false), newFunction);\n                } else {\n                    setSystemProperty(getPersistProp(false), UsbManager.USB_FUNCTION_NONE);\n                }\n            }\n            // return passed in functions as is.\n            return usbFunctions;\n        }\n\n        private boolean waitForState(String state) {\n            // wait for the transition to complete.\n            // give up after 1 second.\n            String value = null;\n            for (int i = 0; i < 20; i++) {\n                // State transition is done when sys.usb.state is set to the new configuration\n                value = getSystemProperty(USB_STATE_PROPERTY, \"\");\n                if (state.equals(value)) return true;\n                SystemClock.sleep(50);\n            }\n            Slog.e(TAG, \"waitForState(\" + state + \") FAILED: got \" + value);\n            return false;\n        }\n\n        private void setUsbConfig(String config) {\n            if (DEBUG) Slog.d(TAG, \"setUsbConfig(\" + config + \")\");\n            /**\n             * set the new configuration\n             * we always set it due to b/23631400, where adbd was getting killed\n             * and not restarted due to property timeouts on some devices\n             */\n            setSystemProperty(USB_CONFIG_PROPERTY, config);\n        }\n\n        @Override\n        protected void setEnabledFunctions(long usbFunctions,\n                boolean forceRestart, int operationId) {\n            boolean usbDataUnlocked = isUsbDataTransferActive(usbFunctions);\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctions functions=\" + usbFunctions +\n                        \" ,forceRestart=\" + forceRestart +\n                        \" ,usbDataUnlocked=\" + usbDataUnlocked +\n                        \" ,operationId=\" + operationId);\n            }\n\n            if (usbDataUnlocked != mUsbDataUnlocked) {\n                mUsbDataUnlocked = usbDataUnlocked;\n                updateUsbNotification(false);\n                forceRestart = true;\n            }\n\n            /**\n             * Try to set the enabled functions.\n             */\n            final long oldFunctions = mCurrentFunctions;\n            final boolean oldFunctionsApplied = mCurrentFunctionsApplied;\n            if (trySetEnabledFunctions(usbFunctions, forceRestart)) {\n                return;\n            }\n\n            /**\n             * Didn't work.  Try to revert changes.\n             * We always reapply the policy in case certain constraints changed such as\n             * user restrictions independently of any other new functions we were\n             * trying to activate.\n             */\n            if (oldFunctionsApplied && oldFunctions != usbFunctions) {\n                Slog.e(TAG, \"Failsafe 1: Restoring previous USB functions.\");\n                if (trySetEnabledFunctions(oldFunctions, false)) {\n                    return;\n                }\n            }\n\n            /**\n             * Still didn't work.  Try to restore the default functions.\n             */\n            Slog.e(TAG, \"Failsafe 2: Restoring default USB functions.\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Now we're desperate.  Ignore the default functions.\n             * Try to get ADB working if enabled.\n             */\n            Slog.e(TAG, \"Failsafe 3: Restoring empty function list (with ADB if enabled).\");\n            if (trySetEnabledFunctions(UsbManager.FUNCTION_NONE, false)) {\n                return;\n            }\n\n            /**\n             * Ouch.\n             */\n            Slog.e(TAG, \"Unable to set any USB functions!\");\n        }\n\n        private boolean isNormalBoot() {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            return bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\");\n        }\n\n        protected String applyAdbFunction(String functions) {\n            // Do not pass null pointer to the UsbManager.\n            // There isn't a check there.\n            if (functions == null) {\n                functions = \"\";\n            }\n            if (isAdbEnabled()) {\n                functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            } else {\n                functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);\n            }\n            return functions;\n        }\n\n        private boolean trySetEnabledFunctions(long usbFunctions, boolean forceRestart) {\n            String functions = null;\n            if (usbFunctions != UsbManager.FUNCTION_NONE) {\n                functions = UsbManager.usbFunctionsToString(usbFunctions);\n            }\n            mCurrentFunctions = usbFunctions;\n            if (functions == null || applyAdbFunction(functions)\n                    .equals(UsbManager.USB_FUNCTION_NONE)) {\n                functions = UsbManager.usbFunctionsToString(getChargingFunctions());\n            }\n            functions = applyAdbFunction(functions);\n\n            String oemFunctions = applyOemOverrideFunction(functions);\n\n            if (!isNormalBoot() && !mCurrentFunctionsStr.equals(functions)) {\n                setSystemProperty(getPersistProp(true), functions);\n            }\n\n            if ((!functions.equals(oemFunctions)\n                    && !mCurrentOemFunctions.equals(oemFunctions))\n                    || !mCurrentFunctionsStr.equals(functions)\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                mCurrentFunctionsStr = functions;\n                mCurrentOemFunctions = oemFunctions;\n                mCurrentFunctionsApplied = false;\n\n                /**\n                 * Kick the USB stack to close existing connections.\n                 */\n                setUsbConfig(UsbManager.USB_FUNCTION_NONE);\n\n                if (!waitForState(UsbManager.USB_FUNCTION_NONE)) {\n                    Slog.e(TAG, \"Failed to kick USB config\");\n                    return false;\n                }\n\n                /**\n                 * Set the new USB configuration.\n                 */\n                setUsbConfig(oemFunctions);\n\n                if (mBootCompleted\n                        && (containsFunction(functions, UsbManager.USB_FUNCTION_MTP)\n                        || containsFunction(functions, UsbManager.USB_FUNCTION_PTP))) {\n                    /**\n                     * Start up dependent services.\n                     */\n                    updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));\n                }\n\n                if (!waitForState(oemFunctions)) {\n                    Slog.e(TAG, \"Failed to switch USB config to \" + functions);\n                    return false;\n                }\n\n                mCurrentFunctionsApplied = true;\n            }\n            return true;\n        }\n\n        private String getPersistProp(boolean functions) {\n            String bootMode = getSystemProperty(BOOT_MODE_PROPERTY, \"unknown\");\n            String persistProp = USB_PERSISTENT_CONFIG_PROPERTY;\n            if (!(bootMode.equals(NORMAL_BOOT) || bootMode.equals(\"unknown\"))) {\n                if (functions) {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".func\";\n                } else {\n                    persistProp = \"persist.sys.usb.\" + bootMode + \".config\";\n                }\n            }\n            return persistProp;\n        }\n\n        private static String addFunction(String functions, String function) {\n            if (UsbManager.USB_FUNCTION_NONE.equals(functions)) {\n                return function;\n            }\n            if (!containsFunction(functions, function)) {\n                if (functions.length() > 0) {\n                    functions += \",\";\n                }\n                functions += function;\n            }\n            return functions;\n        }\n\n        private static String removeFunction(String functions, String function) {\n            String[] split = functions.split(\",\");\n            for (int i = 0; i < split.length; i++) {\n                if (function.equals(split[i])) {\n                    split[i] = null;\n                }\n            }\n            if (split.length == 1 && split[0] == null) {\n                return UsbManager.USB_FUNCTION_NONE;\n            }\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < split.length; i++) {\n                String s = split[i];\n                if (s != null) {\n                    if (builder.length() > 0) {\n                        builder.append(\",\");\n                    }\n                    builder.append(s);\n                }\n            }\n            return builder.toString();\n        }\n\n        static boolean containsFunction(String functions, String function) {\n            int index = functions.indexOf(function);\n            if (index < 0) return false;\n            if (index > 0 && functions.charAt(index - 1) != ',') return false;\n            int charAfter = index + function.length();\n            if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;\n            return true;\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void getUsbSpeedCb(int speed){\n        }\n\n        /**\n         * This callback function is only applicable for USB Gadget HAL,\n         * USBHandlerLegacy does not supported it.\n         */\n        @Override\n        public void resetCb(int status){\n        }\n    }\n\n    private static final class UsbHandlerHal extends UsbHandler {\n\n        private final Object mGadgetProxyLock = new Object();\n\n        /**\n         * Cookie sent for usb gadget hal death notification.\n         */\n        private static final int USB_GADGET_HAL_DEATH_COOKIE = 2000;\n\n        /**\n         * Keeps track of the latest setCurrentUsbFunctions request number.\n         */\n        private int mCurrentRequest = 0;\n\n        /**\n         * The maximum time for which the UsbDeviceManager would wait once\n         * setCurrentUsbFunctions is called.\n         */\n        private static final int SET_FUNCTIONS_TIMEOUT_MS = 3000;\n\n        /**\n         * Conseration leeway to make sure that the hal callback arrives before\n         * SET_FUNCTIONS_TIMEOUT_MS expires. If the callback does not arrive\n         * within SET_FUNCTIONS_TIMEOUT_MS, UsbDeviceManager retries enabling\n         * default functions.\n         */\n        private static final int SET_FUNCTIONS_LEEWAY_MS = 500;\n\n        /**\n         * While switching functions, a disconnect is excpect as the usb gadget\n         * us torn down and brought back up. Wait for SET_FUNCTIONS_TIMEOUT_MS +\n         * ENUMERATION_TIME_OUT_MS before switching back to default fumctions when\n         * switching functions.\n         */\n        private static final int ENUMERATION_TIME_OUT_MS = 2000;\n\n        /**\n         * Gadget HAL fully qualified instance name for registering for ServiceNotification.\n         */\n        protected static final String GADGET_HAL_FQ_NAME =\n                \"android.hardware.usb.gadget@1.0::IUsbGadget\";\n\n        protected boolean mCurrentUsbFunctionsRequested;\n\n        UsbHandlerHal(Looper looper, Context context, UsbDeviceManager deviceManager,\n                UsbAlsaManager alsaManager, UsbPermissionManager permissionManager) {\n            super(looper, context, deviceManager, alsaManager, permissionManager);\n            int operationId = sUsbOperationCount.incrementAndGet();\n            try {\n\n                synchronized (mGadgetProxyLock) {\n                    mCurrentFunctions = UsbManager.FUNCTION_NONE;\n                    mCurrentUsbFunctionsRequested = true;\n                    mUsbSpeed = UsbSpeed.UNKNOWN;\n                    mCurrentGadgetHalVersion = UsbManager.GADGET_HAL_V1_0;\n                    updateUsbGadgetHalVersion();\n                }\n                String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();\n                updateState(state);\n            } catch (NoSuchElementException e) {\n                Slog.e(TAG, \"Usb gadget hal not found\", e);\n            } catch (Exception e) {\n                Slog.e(TAG, \"Error initializing UsbHandler\", e);\n            }\n        }\n\n\n        final class UsbGadgetDeathRecipient implements HwBinder.DeathRecipient {\n            @Override\n            public void serviceDied(long cookie) {\n                if (cookie == USB_GADGET_HAL_DEATH_COOKIE) {\n                    Slog.e(TAG, \"Usb Gadget hal service died cookie: \" + cookie);\n                    synchronized (mGadgetProxyLock) {\n                        mUsbGadgetHal = null;\n                    }\n                }\n            }\n        }\n\n        final class ServiceNotification extends IServiceNotification.Stub {\n            @Override\n            public void onRegistration(String fqName, String name, boolean preexisting) {\n                Slog.i(TAG, \"Usb gadget hal service started \" + fqName + \" \" + name);\n                if (!fqName.equals(GADGET_HAL_FQ_NAME)) {\n                    Slog.e(TAG, \"fqName does not match\");\n                    return;\n                }\n\n                sendMessage(MSG_GADGET_HAL_REGISTERED, preexisting);\n            }\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_SET_CHARGING_FUNCTIONS:\n                    int operationId = sUsbOperationCount.incrementAndGet();\n                    setEnabledFunctions(UsbManager.FUNCTION_NONE, false, operationId);\n                    break;\n                case MSG_SET_FUNCTIONS_TIMEOUT:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    Slog.e(TAG, \"Set functions timed out! no reply from usb hal\"\n                                + \" ,operationId:\" + operationId);\n                    if (msg.arg1 != 1) {\n                        // Set this since default function may be selected from Developer options\n                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                    }\n                    break;\n                case MSG_GET_CURRENT_USB_FUNCTIONS:\n                    Slog.i(TAG, \"processing MSG_GET_CURRENT_USB_FUNCTIONS\");\n                    mCurrentUsbFunctionsReceived = true;\n                    operationId = msg.arg2;\n\n                    if (mCurrentUsbFunctionsRequested) {\n                        Slog.i(TAG, \"updating mCurrentFunctions\");\n                        // Mask out adb, since it is stored in mAdbEnabled\n                        mCurrentFunctions = ((Long) msg.obj) & ~UsbManager.FUNCTION_ADB;\n                        Slog.i(TAG,\n                                \"mCurrentFunctions:\" + mCurrentFunctions + \"applied:\" + msg.arg1);\n                        mCurrentFunctionsApplied = msg.arg1 == 1;\n                    }\n                    finishBoot(operationId);\n                    break;\n                case MSG_FUNCTION_SWITCH_TIMEOUT:\n                    /**\n                     * Dont force to default when the configuration is already set to default.\n                     */\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (msg.arg1 != 1) {\n                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n                            notifyAccessoryModeExit(operationId);\n                        } else {\n                            // Set this since default function may be selected from Developer\n                            // options\n                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n                        }\n                    }\n                    break;\n                case MSG_GADGET_HAL_REGISTERED:\n                    boolean preexisting = msg.arg1 == 1;\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        try {\n                            mUsbGadgetHal = UsbGadgetHalInstance.getInstance(mUsbDeviceManager,\n                                    null);\n                            if (!mCurrentFunctionsApplied && !preexisting) {\n                                setEnabledFunctions(mCurrentFunctions, false, operationId);\n                            }\n                        } catch (NoSuchElementException e) {\n                            Slog.e(TAG, \"Usb gadget hal not found\", e);\n                        }\n                    }\n                    break;\n                case MSG_RESET_USB_GADGET:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    synchronized (mGadgetProxyLock) {\n                        if (mUsbGadgetHal == null) {\n                            Slog.e(TAG, \"reset Usb Gadget mUsbGadgetHal is null\");\n                            break;\n                        }\n\n                        try {\n                            // MSG_ACCESSORY_MODE_ENTER_TIMEOUT has to be removed to allow exiting\n                            // AOAP mode during resetUsbGadget.\n                            removeMessages(MSG_ACCESSORY_MODE_ENTER_TIMEOUT);\n                            if (mConfigured) {\n                                mResetUsbGadgetDisableDebounce = true;\n                            }\n                            mUsbGadgetHal.reset(operationId);\n                        } catch (Exception e) {\n                            Slog.e(TAG, \"reset Usb Gadget failed\", e);\n                            mResetUsbGadgetDisableDebounce = false;\n                        }\n                    }\n                    break;\n                case MSG_UPDATE_USB_SPEED:\n                    operationId = sUsbOperationCount.incrementAndGet();\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mGadgetHal is null, operationId:\" + operationId);\n                        break;\n                    }\n\n                    try {\n                        mUsbGadgetHal.getUsbSpeed(operationId);\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"get UsbSpeed failed\", e);\n                    }\n                    break;\n                case MSG_UPDATE_HAL_VERSION:\n                    if (mUsbGadgetHal == null) {\n                        Slog.e(TAG, \"mUsbGadgetHal is null\");\n                        break;\n                    }\n                    else {\n                        try {\n                            mCurrentGadgetHalVersion = mUsbGadgetHal.getGadgetHalVersion();\n                        } catch (RemoteException e) {\n                            Slog.e(TAG, \"update Usb gadget version failed\", e);\n                        }\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n\n        @Override\n        public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n\n            if ((mCurrentRequest != mRequest) || !hasMessages(MSG_SET_FUNCTIONS_TIMEOUT)\n                  || (mFunctions != functions)) {\n                return;\n            }\n\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            Slog.i(TAG, \"notifyCurrentFunction request:\" + mRequest + \" status:\" + status);\n            if (status == Status.SUCCESS) {\n                mCurrentFunctionsApplied = true;\n            } else if (!mChargingFunctions) {\n                Slog.e(TAG, \"Setting default fuctions\");\n                sendEmptyMessage(MSG_SET_CHARGING_FUNCTIONS);\n            }\n        }\n\n        @Override\n        public void getUsbSpeedCb(int speed) {\n            mUsbSpeed = speed;\n        }\n\n        @Override\n        public void resetCb(int status) {\n            if (status != Status.SUCCESS)\n                Slog.e(TAG, \"resetCb fail\");\n        }\n\n        private void setUsbConfig(long config, boolean chargingFunctions, int operationId) {\n            if (true) Slog.d(TAG, \"setUsbConfig(\" + config + \") request:\" + ++mCurrentRequest);\n            /**\n             * Cancel any ongoing requests, if present.\n             */\n            removeMessages(MSG_FUNCTION_SWITCH_TIMEOUT);\n            removeMessages(MSG_SET_FUNCTIONS_TIMEOUT);\n            removeMessages(MSG_SET_CHARGING_FUNCTIONS);\n\n            synchronized (mGadgetProxyLock) {\n                if (mUsbGadgetHal == null) {\n                    Slog.e(TAG, \"setUsbConfig mUsbGadgetHal is null\");\n                    return;\n                }\n                try {\n                    if ((config & UsbManager.FUNCTION_ADB) != 0) {\n                        /**\n                         * Start adbd if ADB function is included in the configuration.\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .startAdbdForTransport(AdbTransportType.USB);\n                    } else {\n                        /**\n                         * Stop adbd otherwise\n                         */\n                        LocalServices.getService(AdbManagerInternal.class)\n                                .stopAdbdForTransport(AdbTransportType.USB);\n                    }\n                    mUsbGadgetHal.setCurrentUsbFunctions(mCurrentRequest,\n                            config, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS - SET_FUNCTIONS_LEEWAY_MS, operationId);\n                    sendMessageDelayed(MSG_SET_FUNCTIONS_TIMEOUT, chargingFunctions,\n                            SET_FUNCTIONS_TIMEOUT_MS);\n                    if (mConnected) {\n                        // Only queue timeout of enumeration when the USB is connected\n                        sendMessageDelayed(MSG_FUNCTION_SWITCH_TIMEOUT, chargingFunctions,\n                                SET_FUNCTIONS_TIMEOUT_MS + ENUMERATION_TIME_OUT_MS);\n                    }\n                    if (DEBUG) Slog.d(TAG, \"timeout message queued\");\n                } catch (Exception e) {//RemoteException e) {\n                    Slog.e(TAG, \"Remoteexception while calling setCurrentUsbFunctions\", e);\n                }\n            }\n        }\n\n        @Override\n        protected void setEnabledFunctions(long functions, boolean forceRestart, int operationId) {\n            if (DEBUG) {\n                Slog.d(TAG, \"setEnabledFunctionsi \" +\n                        \"functions=\" + functions +\n                        \", forceRestart=\" + forceRestart +\n                        \", operationId=\" + operationId);\n            }\n            if (mCurrentGadgetHalVersion < UsbManager.GADGET_HAL_V1_2) {\n                if ((functions & UsbManager.FUNCTION_NCM) != 0) {\n                    Slog.e(TAG, \"Could not set unsupported function for the GadgetHal\");\n                    return;\n                }\n            }\n            if (mCurrentFunctions != functions\n                    || !mCurrentFunctionsApplied\n                    || forceRestart) {\n                Slog.i(TAG, \"Setting USB config to \" + UsbManager.usbFunctionsToString(functions));\n                mCurrentFunctions = functions;\n                mCurrentFunctionsApplied = false;\n                // set the flag to false as that would be stale value\n                mCurrentUsbFunctionsRequested = false;\n\n                boolean chargingFunctions = functions == UsbManager.FUNCTION_NONE;\n                functions = getAppliedFunctions(functions);\n\n                // Set the new USB configuration.\n                setUsbConfig(functions, chargingFunctions, operationId);\n\n                if (mBootCompleted && isUsbDataTransferActive(functions)) {\n                    // Start up dependent services.\n                    updateUsbStateBroadcastIfNeeded(functions);\n                }\n            }\n        }\n\n        @Override\n        public void handlerInitDone(int operationId) {\n            mUsbGadgetHal.getCurrentUsbFunctions(operationId);\n        }\n    }\n\n    /* returns the currently attached USB accessory */\n    public UsbAccessory getCurrentAccessory() {\n        return mHandler.getCurrentAccessory();\n    }\n\n    /**\n     * opens the currently attached USB accessory.\n     *\n     * @param accessory accessory to be openened.\n     * @param uid Uid of the caller\n     */\n    public ParcelFileDescriptor openAccessory(UsbAccessory accessory,\n            UsbUserPermissionManager permissions, int pid, int uid) {\n        UsbAccessory currentAccessory = mHandler.getCurrentAccessory();\n        if (currentAccessory == null) {\n            throw new IllegalArgumentException(\"no accessory attached\");\n        }\n        if (!currentAccessory.equals(accessory)) {\n            String error = accessory.toString()\n                    + \" does not match current accessory \"\n                    + currentAccessory;\n            throw new IllegalArgumentException(error);\n        }\n        permissions.checkPermission(accessory, pid, uid);\n        return nativeOpenAccessory();\n    }\n\n    public long getCurrentFunctions() {\n        return mHandler.getEnabledFunctions();\n    }\n\n    public int getCurrentUsbSpeed() {\n        return mHandler.getUsbSpeed();\n    }\n\n    public int getGadgetHalVersion() {\n        return mHandler.getGadgetHalVersion();\n    }\n\n    public void setCurrentUsbFunctionsCb(long functions,\n                    int status, int mRequest, long mFunctions, boolean mChargingFunctions) {\n        mHandler.setCurrentUsbFunctionsCb(functions, status,\n                    mRequest, mFunctions, mChargingFunctions);\n    }\n\n    public void getCurrentUsbFunctionsCb(long functions, int status) {\n        mHandler.sendMessage(MSG_GET_CURRENT_USB_FUNCTIONS, functions,\n                    status == Status.FUNCTIONS_APPLIED);\n    }\n\n    public void getUsbSpeedCb(int speed) {\n        mHandler.getUsbSpeedCb(speed);\n    }\n\n    public void resetCb(int status) {\n        mHandler.resetCb(status);\n    }\n\n    /**\n     * Returns a dup of the control file descriptor for the given function.\n     */\n    public ParcelFileDescriptor getControlFd(long usbFunction) {\n        FileDescriptor fd = mControlFds.get(usbFunction);\n        if (fd == null) {\n            return null;\n        }\n        try {\n            return ParcelFileDescriptor.dup(fd);\n        } catch (IOException e) {\n            Slog.e(TAG, \"Could not dup fd for \" + usbFunction);\n            return null;\n        }\n    }\n\n    public long getScreenUnlockedFunctions() {\n        return mHandler.getScreenUnlockedFunctions();\n    }\n\n    /**\n     * Adds function to the current USB configuration.\n     *\n     * @param functions The functions to set, or empty to set the charging function.\n     */\n    public void setCurrentFunctions(long functions, int operationId) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setCurrentFunctions(\" + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        if (functions == UsbManager.FUNCTION_NONE) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_CHARGING);\n        } else if (functions == UsbManager.FUNCTION_MTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MTP);\n        } else if (functions == UsbManager.FUNCTION_PTP) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_PTP);\n        } else if (functions == UsbManager.FUNCTION_MIDI) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_MIDI);\n        } else if (functions == UsbManager.FUNCTION_RNDIS) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_RNDIS);\n        } else if (functions == UsbManager.FUNCTION_ACCESSORY) {\n            MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_ACCESSORY);\n        } else if (functions == UsbManager.FUNCTION_UVC) {\n            // MetricsLogger.action(mContext, MetricsEvent.ACTION_USB_CONFIG_UVC);\n            // TODO: Add MetricsEvent for UVC?\n        }\n        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions, operationId);\n    }\n\n    /**\n     * Sets the functions which are set when the screen is unlocked.\n     *\n     * @param functions Functions to set.\n     */\n    public void setScreenUnlockedFunctions(long functions) {\n        if (DEBUG) {\n            Slog.d(TAG, \"setScreenUnlockedFunctions(\"\n                    + UsbManager.usbFunctionsToString(functions) + \")\");\n        }\n        mHandler.sendMessage(MSG_SET_SCREEN_UNLOCKED_FUNCTIONS, functions);\n    }\n\n    /**\n     * Resets the USB Gadget.\n     */\n    public void resetUsbGadget() {\n        if (DEBUG) {\n            Slog.d(TAG, \"reset Usb Gadget\");\n        }\n\n        mHandler.sendMessage(MSG_RESET_USB_GADGET, null);\n    }\n\n    private void onAdbEnabled(boolean enabled) {\n        int operationId = sUsbOperationCount.incrementAndGet();\n        mHandler.sendMessage(MSG_ENABLE_ADB, enabled, operationId);\n    }\n\n    /**\n     * Write the state to a dump stream.\n     */\n    public void dump(DualDumpOutputStream dump, String idName, long id) {\n        long token = dump.start(idName, id);\n\n        if (mHandler != null) {\n            mHandler.dump(dump, \"handler\", UsbDeviceManagerProto.HANDLER);\n            sEventLogger.dump(new DualOutputStreamDumpSink(dump, UsbHandlerProto.UEVENT));\n        }\n\n        dump.end(token);\n    }\n\n    private native String[] nativeGetAccessoryStrings();\n\n    private native ParcelFileDescriptor nativeOpenAccessory();\n\n    private native FileDescriptor nativeOpenControl(String usbFunction);\n\n    private native boolean nativeIsStartRequested();\n\n    private native int nativeGetAudioMode();\n}\n```",
            "downstream_file_tokens": {
              "openai": 20371,
              "general": {
                "word_based": 7605,
                "char_based": 27177
              },
              "gemini": 24082
            }
          }
        ]
      }
    ]
  }
]